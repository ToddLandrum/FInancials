*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="glincrpt.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 200
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 520

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Name = "Cursor1", ;
		Order = "acctno", ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 6, ;
		Name = "Cursor2", ;
		Top = 120, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "glmaster", ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 375, ;
		Name = "Cursor3", ;
		Top = -1, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 246, ;
		Name = "Cursor4", ;
		Top = 1, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glacctyp", ;
		CursorSource = "glacctyp", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 122, ;
		Name = "Cursor5", ;
		Order = "naccttype", ;
		Top = -1, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formglinclist AS frmrptcriteria OF "appforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="chkZeroBal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkComparative" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgreportby" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="OpgQuarters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboAccountType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTotal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAcctNumbers" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: loadmonth		&& Loads the month ending array
		*p: nnetincc
		*p: nnetincc1
		*p: nnetincc2
		*p: nnetincy
		*p: nnetincy1
		*p: nnetincy2
		*a: lamonthend[12,0]
		*a: lamonth[12,0]
	*</DefinedPropArrayMethod>

	Caption = "Income Statement"
	DataSession = 2
	DoCreate = .T.
	Height = 406
	HelpContextID = 415
	Name = "FormGlinclist"
	Visible = .T.
	Width = 412
	Swrptcriteriabuttons1.chkExport.Alignment = 0
	Swrptcriteriabuttons1.chkExport.Name = "chkExport"
	Swrptcriteriabuttons1.cmdclose.Name = "cmdclose"
	Swrptcriteriabuttons1.cmdPreview.Name = "cmdPreview"
	Swrptcriteriabuttons1.cmdPrint.Name = "cmdPrint"
	Swrptcriteriabuttons1.Left = 89
	Swrptcriteriabuttons1.Name = "Swrptcriteriabuttons1"
	Swrptcriteriabuttons1.TabIndex = 15
	Swrptcriteriabuttons1.Top = 319

	ADD OBJECT 'cboAccountType' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		Height = 20, ;
		Left = 145, ;
		Name = "cboAccountType", ;
		TabIndex = 9, ;
		Top = 134, ;
		Width = 217
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkAcctNumbers' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print Account Numbers", ;
		Height = 16, ;
		Left = 105, ;
		Name = "chkAcctNumbers", ;
		TabIndex = 14, ;
		Top = 269, ;
		Value = .F., ;
		Width = 129
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkComparative' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print a Comparative Statement", ;
		Height = 16, ;
		Left = 105, ;
		Name = "chkComparative", ;
		TabIndex = 12, ;
		Top = 217, ;
		Value = .F., ;
		Width = 162
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkTotal' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print Total Lines for All Sub-Accounts", ;
		Height = 16, ;
		Left = 105, ;
		Name = "chkTotal", ;
		TabIndex = 13, ;
		Top = 243, ;
		Value = .T., ;
		Width = 199
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkZeroBal' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Include Accounts with a Zero Balance", ;
		Height = 16, ;
		Left = 105, ;
		Name = "chkZeroBal", ;
		TabIndex = 11, ;
		Top = 191, ;
		Value = .F., ;
		Width = 203
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 24, ;
		Name = "Glmaint", ;
		Top = 300
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Report By", ;
		Left = 44, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 2, ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Quarter", ;
		Left = 25, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 7, ;
		Top = 76
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblPeriod' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Fiscal Period:", ;
		Height = 16, ;
		Left = 212, ;
		Name = "lblPeriod", ;
		TabIndex = 6, ;
		Top = 48, ;
		Width = 66, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom1' AS lbltextcustom WITH ;
		Caption = "Include Accounts:", ;
		Left = 50, ;
		Name = "Lbltextcustom1", ;
		TabIndex = 10, ;
		Top = 136
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblYear' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Fiscal Year:", ;
		Height = 16, ;
		Left = 74, ;
		Name = "lblYear", ;
		TabIndex = 5, ;
		Top = 48, ;
		Width = 60, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'OpgQuarters' AS opgoptiongroupcustom WITH ;
		BorderStyle = 1, ;
		ButtonCount = 4, ;
		Enabled = .T., ;
		Height = 35, ;
		Left = 18, ;
		Name = "OpgQuarters", ;
		TabIndex = 8, ;
		Top = 82, ;
		Width = 373, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "1st (Jan - Mar)", ;
		Option1.Enabled = .F., ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Q1", ;
		Option1.Top = 11, ;
		Option1.Width = 89, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "2nd (Apr - Jun)", ;
		Option2.Enabled = .F., ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 96, ;
		Option2.Name = "Q2", ;
		Option2.Top = 11, ;
		Option2.Width = 92, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "3rd (Jul - Sep)", ;
		Option3.Enabled = .F., ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 192, ;
		Option3.Name = "Q3", ;
		Option3.Top = 11, ;
		Option3.Width = 87, ;
		Option4.AutoSize = .T., ;
		Option4.Caption = "4th (Oct - Dec)", ;
		Option4.Enabled = .F., ;
		Option4.FontSize = 8, ;
		Option4.Height = 16, ;
		Option4.Left = 281, ;
		Option4.Name = "Q4", ;
		Option4.Top = 11, ;
		Option4.Width = 90
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'opgreportby' AS opgoptiongroupcustom WITH ;
		AutoSize = .T., ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		Height = 26, ;
		Left = 104, ;
		Name = "opgreportby", ;
		TabIndex = 1, ;
		Top = 14, ;
		Value = 1, ;
		Width = 194, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Fiscal Period", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 79, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Fiscal Quarter", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 103, ;
		Option2.Name = "Option2", ;
		Option2.Top = 5, ;
		Option2.Width = 86
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtPeriod' AS swperiod WITH ;
		Left = 296, ;
		MaxLength = 2, ;
		Name = "txtPeriod", ;
		TabIndex = 4, ;
		Top = 46, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtYear' AS swyear WITH ;
		Height = 20, ;
		Left = 152, ;
		MaxLength = 4, ;
		Name = "txtYear", ;
		TabIndex = 3, ;
		Top = 46, ;
		Width = 39, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE builddata
		*
		*  Builds the income statement cursor (balance) from the
		*  coabalnew table.  Uses the criteria entered on the form.
		*
		LOCAL jlines, llfirst, jcYear, jcPeriod, m.cCurEarn, lnCount
		LOCAL lcYear, lcPeriod, llZero, llCompare, latypes[14]
		LOCAL lnGrossPC, lnGrossPY, lnGrossPC1, lnGrossPC2, lnGrossPY1, lnGrossPY2
		LOCAL lnGrossPOC, lnGrossPOY, lnGrossPOC1, lnGrossPOC2, lnGrossPOY1, lnGrossPOY2
		LOCAL lnGrossPPC, lnGrossPPY, lnGrossPPC1, lnGrossPPC2, lnGrossPPY1, lnGrossPPY2
		LOCAL lTotalAcct, laCOGS[1], laCurEarn[1], laDepreciation[1], laExpense[1], laExpenses[1]
		LOCAL laGrossRev[1], laIncome[1], lcCurYear, lcDesc, lcLastAcctNo, lcLevel, lcParent, lcPeriod1
		LOCAL lcPeriod2, llShowTotals, lnBegBal, lnBonusC, lnBonusC1, lnBonusC2, lnBonusY, lnBonusY1
		LOCAL lnBonusY2, lnBreak, lnCOGS, lnCOGSC, lnCOGSC1, lnCOGSC2, lnCOGSY, lnCOGSY1, lnCOGSY2, lnCurBal
		LOCAL lnCurrentLevel, lnDeprC, lnDeprC1, lnDeprC2, lnDeprY, lnDeprY1, lnDeprY2, lnExpC, lnExpC1
		LOCAL lnExpC2, lnExpY, lnExpY1, lnExpY2, lnExpenseC, lnExpenseC1, lnExpenseC2, lnExpenseY
		LOCAL lnExpenseY1, lnExpenseY2, lnGrossC, lnGrossC1, lnGrossC2, lnGrossY, lnGrossY1, lnGrossY2
		LOCAL lnIncC, lnIncC1, lnIncC2, lnIncY, lnIncY1, lnIncY2, lnLastLevel, lnLevel, lnNETPC, lnNETPC1
		LOCAL lnNETPC2, lnNETPY, lnNETPY1, lnNETPY2, lnQtr, lnRecNo, lnRecNo2, lnReportBy, lnTotal, lnTotal2
		LOCAL lnTotalYr, lnTotalYr2, lnYearBal
		LOCAL cAcctDesc, cAcctNo, cAcctType, cBalGroup, cBreak, cCurEarn, cFiscalPrd, cFiscalYr
		LOCAL cSortField, nAcctType, nBegBal, nBegBal1, nBegBal2, nCredits, nCurBal, nCurBal1, nCurBal2
		LOCAL nCurPct, nCurPct1, nCurPct2, nDebits, nDebits1, nDebits2, nLevel, nNetIncC1, nNetIncC2
		LOCAL nNetIncY1, nNetIncY2, nYearBal, nYearBal1, nYearBal2, nYearPct, nYearPct1, nYearPct2
		
		
		llReturn = .T.
		
		TRY
		   STORE 0 TO lnGrossPC, lnGrossPY, lnGrossPC1, lnGrossPC2, lnGrossPY1, lnGrossPY2
		   STORE 0 TO lnGrossPOC, lnGrossPOY, lnGrossPOC1, lnGrossPOC2, lnGrossPOY1, lnGrossPOY2
		   STORE 0 TO lnGrossPPC, lnGrossPPY, lnGrossPPC1, lnGrossPPC2, lnGrossPPY1, lnGrossPPY2
		   STORE 0 TO m.nNetIncC1, m.nNetIncC2, m.nNetIncY1, m.nNetIncY2
		   STORE 0 TO lnGrossC, lnGrossY, lnGrossC1, lnGrossC2, lnGrossY1, lnGrossY2
		   STORE 0 TO m.nCurPct, m.nCurPct1, m.nCurPct2, m.nYearPct, m.nYearPct1, m.nYearPct2
		   STORE 0 TO m.nDebits, m.nCredits, m.nDebits1, m.nDebits2, m.nCredits1, m.nCredits2
		   STORE 0 TO m.nNetIncY1, m.nNetIncY2, m.nNetIncC1, m.nNetIncC2
		   STORE 0 TO m.nBegBal, m.nBegBal1, m.nBegBal2, m.nCurBal, m.nCurBal1, m.nCurBal2
		   STORE 0 TO m.nLevel, m.nAcctType, lnTotalYr, lnTotalYr2, lnYearBal
		   STORE '' TO m.cAcctDesc, m.cAcctNo, m.cAcctType, m.cBalGroup, m.cBreak, m.cCurEarn
		   STORE '' TO m.cFiscalPrd, m.cFiscalYr, lcYear, lcPeriod, lcPeriod2
		
		
		*
		*  Load the month array properties
		*
		   THISFORM.loadmonth()
		
		*
		*  Set the report name based upon the criteria chosen
		*
		   IF THISFORM.chkComparative.VALUE
		      THISFORM.cReportName = 'source\glinc02'
		   ELSE
		      THISFORM.cReportName = 'source\glinc01'
		   ENDIF
		
		*
		*  Get the current criteria for the income statement
		*
		   lcYear         = THISFORM.txtYear.VALUE
		   lcPeriod       = THISFORM.txtPeriod.VALUE
		   llZero         = THISFORM.chkZeroBal.VALUE
		   llCompare      = THISFORM.chkComparative.VALUE
		   lnReportBy     = THISFORM.opgReportBy.VALUE
		   lnQtr          = THISFORM.opgQuarters.VALUE
		   lcLevel        = THISFORM.cboAccountType.VALUE
		   llShowTotals   = THISFORM.chkTotal.VALUE
		   llPrintNumbers = THISFORM.chkAcctNumbers.VALUE
		
		   DO CASE
		      CASE lnReportBy = 1
		         lcPeriod1 = lcPeriod
		         lcPeriod2 = lcPeriod
		      CASE lnQtr = 1
		         lcPeriod1 = '01'
		         lcPeriod2 = '03'
		      CASE lnQtr = 2
		         lcPeriod1 = '04'
		         lcPeriod2 = '06'
		      CASE lnQtr = 3
		         lcPeriod1 = '07'
		         lcPeriod2 = '09'
		      CASE lnQtr = 4
		         lcPeriod1 = '10'
		         lcPeriod2 = '12'
		   ENDCASE
		
		
		   jcYear   = STR(VAL(lcYear) - 1, 4)
		   jcPeriod = lcPeriod
		
		*
		*  Set the report titles, sort & selection criteria
		*
		   THISFORM.cTitle1 = 'Income Statement'
		   IF lnReportBy = 1
		      THISFORM.cTitle2 = 'For the month ending ' + THISFORM.laMonthEnd[VAL(thisform.txtPeriod.value)]
		   ELSE
		      THISFORM.cTitle2 = 'For the quarter ending ' + THISFORM.laMonthEnd[VAL(lcPeriod2)]
		   ENDIF
		
		*
		*  Recalculate account balances
		*
		
		   WAIT WIND NOWAIT 'Calculating Account Balances...'
		   THISFORM.glmaint.calcbalance(.T.)
		   WAIT CLEAR
		
		   WAIT WIND NOWAIT 'Building Income Statement...'
		*
		*  Get the current earnings account number.
		*
		   swselect('glopt')
		   GO TOP
		   m.cCurEarn = cCurEarn
		
		*
		*  Create the balance cursor. (This is what report is printed from)
		*  If a comparative is to be calculated, change the cursor format.
		*
		   IF llCompare
		      CREATE CURSOR balanceb   ;
		         (cAcctNo     C(6),    ;
		           cSortField  C(31),  ;
		           nLevel      N(1, 0),  ;
		           cParent     C(6),  ;
		           cBalGroup   C(1),    ;
		           cBreak      C(2),    ;
		           nAcctType   N(2),    ;
		           cPeriod1    C(30), ;
		           cPeriod2    C(30), ;
		           cYear1      C(30), ;
		           cYear2      C(30), ;
		           lTitle      L,       ;
		           lTotalAcct  L,       ;
		           cAcctType   C(25),   ;
		           cAcctDesc   C(40),   ;
		           nBegBal1    N(14, 2), ;
		           nDebits1    N(14, 2), ;
		           nCredits1   N(14, 2), ;
		           nCurBal1    N(14, 2), ;
		           nCurPct1    N(12, 1),  ;
		           nYearBal1   N(13, 2), ;
		           nYearPct1   N(12, 1),  ;
		           nBegBal2    N(14, 2), ;
		           nDebits2    N(14, 2), ;
		           nCredits2   N(14, 2), ;
		           nCurBal2    N(14, 2), ;
		           nCurPct2    N(12, 1),  ;
		           nYearBal2   N(14, 2), ;
		           nYearPct2   N(12, 1))
		
		      CREATE CURSOR balance   ;
		         (cAcctNo     C(6),    ;
		           cSortField  C(31),  ;
		           nLevel      N(1, 0),  ;
		           cParent     C(6),  ;
		           cBalGroup   C(1),    ;
		           cBreak      C(2),    ;
		           nAcctType   N(2),    ;
		           cPeriod1    C(30), ;
		           cPeriod2    C(30), ;
		           cYear1      C(30), ;
		           cYear2      C(30), ;
		           lTitle      L,       ;
		           lTotalAcct  L,       ;
		           cAcctType   C(25),   ;
		           cAcctDesc   C(40),   ;
		           nBegBal1    N(14, 2), ;
		           nDebits1    N(14, 2), ;
		           nCredits1   N(14, 2), ;
		           nCurBal1    N(14, 2), ;
		           nCurPct1    N(12, 1),  ;
		           nYearBal1   N(14, 2), ;
		           nYearPct1   N(12, 1),  ;
		           nBegBal2    N(14, 2), ;
		           nDebits2    N(14, 2), ;
		           nCredits2   N(14, 2), ;
		           nCurBal2    N(14, 2), ;
		           nCurPct2    N(12, 1),  ;
		           nYearBal2   N(14, 2), ;
		           nYearPct2   N(12, 1))
		
		   ELSE
		      CREATE CURSOR balanceb   ;
		         (cAcctNo      C(6),    ;
		           cSortField  C(31),  ;
		           nLevel      N(1, 0),  ;
		           cParent     C(6),  ;
		           cBalGroup    C(1),    ;
		           cBreak       C(2),    ;
		           nAcctType    N(2),    ;
		           cPeriod1     C(30), ;
		           cPeriod2     C(30), ;
		           lTitle       L,       ;
		           lTotalAcct   L,       ;
		           cAcctType    C(25),   ;
		           cAcctDesc    C(40),   ;
		           cFiscalYr    C(4),    ;
		           cFiscalPrd   C(2),    ;
		           nBegBal      N(13, 2), ;
		           nDebits      N(13, 2), ;
		           nCredits     N(13, 2), ;
		           nCurBal      N(13, 2), ;
		           nCurPct      N(12, 1),  ;
		           nYearBal     N(13, 2), ;
		           nYearPct     N(12, 1))
		
		      CREATE CURSOR balance   ;
		         (cAcctNo      C(6),    ;
		           cSortField  C(31),  ;
		           nLevel      N(1, 0),  ;
		           cParent     C(6),  ;
		           cBalGroup    C(1),    ;
		           cBreak       C(2),    ;
		           nAcctType    N(2),    ;
		           cPeriod1     C(30), ;
		           cPeriod2     C(30), ;
		           lTitle       L,       ;
		           lTotalAcct   L,       ;
		           cAcctType    C(25),   ;
		           cAcctDesc    C(40),   ;
		           cFiscalYr    C(4),    ;
		           cFiscalPrd   C(2),    ;
		           nBegBal      N(13, 2), ;
		           nDebits      N(13, 2), ;
		           nCredits     N(13, 2), ;
		           nCurBal      N(13, 2), ;
		           nCurPct      N(12, 1),  ;
		           nYearBal     N(13, 2), ;
		           nYearPct     N(12, 1))
		   ENDIF
		
		   SELECT balance
		   SCATTER MEMVAR BLANK
		
		   INDEX ON cBalGroup + cSortField + cBreak TAG AcctNo
		   INDEX ON cAcctNo TAG Acct
		
		   IF NOT llCompare
		
		      IF lnReportBy = 1
		         m.cPeriod1 = 'This Month'
		         m.cPeriod2 = 'Year-to-Date'
		      ELSE
		         m.cPeriod1 = 'This Quarter'
		         m.cPeriod2 = 'Year-to-Date'
		      ENDIF
		
		*
		*  Get the periods activity for each account in the range.
		*
			  SELECT  coa.cAcctNo,       ;
					  coa.cAcctDesc,     ;
					  coa.nAcctType,     ;
					  coa.lTitle,        ;
					  coa.lTotalAcct,    ;
					  coabalnew.cYear AS cFiscalYr,  ;
					  coabalnew.cPeriod AS cFiscalPrd, ;
					  SUM(coabalnew.nDebits) AS nDebits,    ;
					  SUM(coabalnew.nCredits) AS nCredits    ;
				  FROM coabalnew ;
				  JOIN coa ;
					  ON coabalnew.cAcctNo = coa.cAcctNo ;
				  WHERE BETWEEN(coabalnew.cYear + coabalnew.cPeriod, lcYear + lcPeriod1, lcYear + lcPeriod2)  ;
					  AND NOT DELETED() ;
				  INTO CURSOR tempbal1 ;
				  ORDER BY 1 ;
				  GROUP BY 1
		
			  SELECT  coa.cAcctNo,            ;
					  coa.cAcctDesc,          ;
					  coa.nAcctType,          ;
					  coa.lTitle,             ;
					  coa.lTotalAcct,         ;
					  lcYear AS cFiscalYr,    ;
					  lcPeriod AS cFiscalPrd, ;
					  0 AS nDebits,           ;
					  0 AS nCredits           ;
				  FROM coa ;
				  WHERE coa.cAcctNo NOT IN ;
					  (SELECT  cAcctNo ;
						   FROM tempbal1) ;
				  INTO CURSOR tempbal2 ;
				  ORDER BY 1 ;
				  GROUP BY 1
		
		*
		*  If there were no records found, bail out.
		*
		      IF _TALLY = 0
		         llReturn = .F.
		         EXIT
		      ENDIF
		
		*
		*  Append the records to the balance table
		*
		      SELECT balance
		      APPEND FROM DBF('tempbal1')
		      APPEND FROM DBF('tempbal2')
		      SET ORDER TO AcctNo
		      USE IN tempbal1
		      USE IN tempbal2
		
		      REPLACE cPeriod1 WITH m.cPeriod1, ;
		         cPeriod2 WITH m.cPeriod2 ALL
		*
		*  Get the beginning balances for each account in the range.
		*
			  SELECT  coabalnew.cAcctNo, ;
					  SUM(nDebits) AS nDebits, ;
					  SUM(nCredits) AS nCredits ;
				  FROM coabalnew ;
				  WHERE coabalnew.cYear = lcYear ;
					  AND coabalnew.cPeriod < lcPeriod1 ;
					  AND NOT DELETED() ;
				  INTO CURSOR tempbeg ;
				  ORDER BY coabalnew.cAcctNo ;
				  GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		      IF _TALLY > 0
		         SELECT tempbeg
		         SCAN
		            SCATTER MEMVAR
		            SELECT balance
		            SET ORDER TO Acct
		            IF SEEK(m.cAcctNo)
		               IF nAcctType = 8 OR nAcctType = 13
		                  lnBegBal  = m.nCredits - m.nDebits
		                  lnYearBal = lnBegBal + (nCredits - nDebits)
		                  lnCurBal  = nCredits - nDebits
		               ELSE
		                  lnBegBal  = m.nDebits - m.nCredits
		                  lnYearBal = lnBegBal + (nDebits - nCredits)
		                  lnCurBal  = nDebits - nCredits
		               ENDIF
		               REPLACE nBegBal  WITH lnBegBal, ;
		                  nCurBal  WITH lnCurBal, ;
		                  nYearBal WITH lnYearBal
		            ENDIF
		         ENDSCAN
		      ENDIF
		
		*
		*  Plug in the ending balance numbers.
		*
		      SELECT balance
		      SET ORDER TO 0
		      SCAN
		         IF EMPTY(nBegBal)
		            IF nAcctType = 8 OR nAcctType = 13
		               REPLACE nYearBal WITH nCredits - nDebits, ;
		                  nCurBal  WITH nCredits - nDebits, ;
		                  nBegBal WITH 0
		            ELSE
		               REPLACE nYearBal WITH nDebits - nCredits, ;
		                  nCurBal  WITH nDebits - nCredits, ;
		                  nBegBal WITH 0
		            ENDIF
		         ENDIF
		      ENDSCAN
		
		*
		*  Calculate the Gross Revenue
		*
			  SELECT  SUM(nCurBal),;
					  SUM(nYearBal) ;
				  FROM balance ;
				  WHERE nAcctType = 8 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laGrossRev
		
		      IF _TALLY > 0
		         lnGrossC = laGrossRev[1, 1]
		         lnGrossY = laGrossRev[1, 2]
		         SELECT balance
		         SCAN FOR BETWEEN(nAcctType, 8, 16)
		            IF lnGrossC # 0
		               REPLACE nCurPct WITH ABS(ROUND(((nCurBal / lnGrossC) * 100), 1))
		            ENDIF
		            IF lnGrossY # 0
		               REPLACE nYearPct WITH ABS(ROUND(((nYearBal / lnGrossY) * 100), 1))
		            ENDIF
		         ENDSCAN
		      ELSE
		         lnGrossC = 0
		         lnGrossY = 0
		      ENDIF
		
		*
		*  Calculate the Cost of Goods Sold
		*
			  SELECT  SUM(nCurBal),;
					  SUM(nYearBal) ;
				  FROM balance ;
				  WHERE nAcctType = 9 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laCOGS
		
		      IF _TALLY > 0
		         lnCOGSC = laCOGS[1, 1]
		         lnCOGSY = laCOGS[1, 2]
		      ELSE
		         lnCOGSC = 0
		         lnCOGSY = 0
		      ENDIF
		
		*
		*  Calculate the Gross Profit
		*
		      lnGrossPC = lnGrossC - lnCOGSC
		      lnGrossPY = lnGrossY - lnCOGSY
		
		*
		*  Insert gross profit line in balance table
		*
		      m.nYearBal = lnGrossPY
		      m.nCurBal  = lnGrossPC
		      IF lnGrossC # 0
		         m.nCurPct = ROUND((m.nCurBal / lnGrossC) * 100, 1)
		      ELSE
		         m.nCurPct = 0
		      ENDIF
		      IF lnGrossY # 0
		         m.nYearPct = ROUND((m.nYearBal / lnGrossY) * 100, 1)
		      ELSE
		         m.nYearPct = 0
		      ENDIF
		      m.cAcctDesc  = 'Gross Profit'
		      m.cAcctNo    = ' '
		      m.cBalGroup  = 'C'
		      m.cAcctType  = 'Gross Profit'
		      m.nAcctType  = 0
		      m.cFiscalYr  = lcYear
		      m.cFiscalPrd = lcPeriod
		      m.nBegBal    = 0
		      m.nDebits    = 0
		      m.nCredits   = 0
		      IF lnGrossC # 0
		         m.nCurPct = ABS(ROUND(((m.nCurBal / lnGrossC) * 100), 1))
		      ELSE
		         m.nCurPct = 0
		      ENDIF
		      IF lnGrossY # 0
		         m.nYearPct = ABS(ROUND(((m.nYearBal / lnGrossY) * 100), 1))
		      ELSE
		         m.nYearPct = 0
		      ENDIF
		
		*
		*  Only show a gross profit here if there is at lease
		*  one cost of goods sold account defined.
		*
		      SELE cAcctNo FROM coa INTO ARRAY laCOGS WHERE nAcctType = 9
		      lnCOGS = _TALLY
		      IF lnCOGS > 0
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		
		*
		*  Calculate the gross profit from operations
		*
			  SELECT  SUM(nCurBal),;
					  SUM(nYearBal) ;
				  FROM balance ;
				  WHERE BETWEEN(nAcctType, 10, 11) ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laExpenses
		
		      IF _TALLY > 0
		         lnExpenseC = laExpenses[1, 1]
		         lnExpenseY = laExpenses[1, 2]
		      ELSE
		         STORE 0 TO lnExpenseC, lnExpenseY
		      ENDIF
		
		      lnGrossPOC = lnGrossPC - lnExpenseC
		      lnGrossPOY = lnGrossPY - lnExpenseY
		
		      IF lnExpenseC # 0 OR lnExpenseY # 0
		*
		*  Insert gross profit line in balance table
		*
		         m.nYearBal = lnGrossPOY
		         m.nCurBal  = lnGrossPOC
		         IF lnGrossC # 0
		            m.nCurPct = ROUND((m.nCurBal / lnGrossC) * 100, 1)
		         ELSE
		            m.nCurPct = 0
		         ENDIF
		         IF lnGrossY # 0
		            m.nYearPct = ROUND((m.nYearBal / lnGrossY) * 100, 1)
		         ELSE
		            m.nYearPct = 0
		         ENDIF
		         m.cAcctDesc  = 'Gross Profit From Operations'
		         m.cAcctNo    = ' '
		         m.cBalGroup  = 'F'
		         m.cAcctType  = 'Gross Profit'
		         m.nAcctType  = 0
		         m.cFiscalYr  = lcYear
		         m.cFiscalPrd = lcPeriod
		         m.nBegBal    = 0
		         m.nDebits    = 0
		         m.nCredits   = 0
		
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the net income from Oil & Gas Operations
		*
			  SELECT  SUM(nCurBal),;
					  SUM(nYearBal) ;
				  FROM balance ;
				  WHERE nAcctType = 12 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laDepreciation
		
		      IF _TALLY > 0
		         lnDeprC = laDepreciation[1, 1]
		         lnDeprY = laDepreciation[1, 2]
		      ELSE
		         STORE 0 TO lnDeprC, lnDeprY
		      ENDIF
		
		      lnGrossPPC = lnGrossPOC - lnDeprC
		      lnGrossPPY = lnGrossPOY - lnDeprY
		
		      IF lnDeprC # 0 OR lnDeprY # 0
		*
		*  Insert gross profit line in balance table
		*
		         m.nYearBal = lnGrossPPY
		         m.nCurBal  = lnGrossPPC
		         IF lnGrossC # 0
		            m.nCurPct = ROUND((m.nCurBal / lnGrossC) * 100, 1)
		         ELSE
		            m.nCurPct = 0
		         ENDIF
		         IF lnGrossY # 0
		            m.nYearPct = ROUND((m.nYearBal / lnGrossY) * 100, 1)
		         ELSE
		            m.nYearPct = 0
		         ENDIF
		         m.cAcctDesc  = 'Net Income from O & G Operations'
		         m.cAcctNo    = ' '
		         m.cBalGroup  = 'H'
		         m.cAcctType  = 'Gross Profit'
		         m.nAcctType  = 0
		         m.cFiscalYr  = lcYear
		         m.cFiscalPrd = lcPeriod
		         m.nBegBal    = 0
		         m.nDebits    = 0
		         m.nCredits   = 0
		
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the net income before pension & bonus
		*
			  SELECT  SUM(nCurBal),;
					  SUM(nYearBal) ;
				  FROM balance ;
				  WHERE nAcctType = 13  ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laIncome
		
		      IF _TALLY > 0
		         lnIncC = laIncome[1, 1]
		         lnIncY = laIncome[1, 2]
		      ELSE
		         STORE 0 TO lnIncC, lnIncY
		      ENDIF
		
			  SELECT  SUM(nCurBal),;
					  SUM(nYearBal) ;
				  FROM balance ;
				  WHERE nAcctType = 14 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laExpense
		
		      IF _TALLY > 0
		         lnExpC = laExpense[1, 1]
		         lnExpY = laExpense[1, 2]
		      ELSE
		         STORE 0 TO lnExpC, lnExpY
		      ENDIF
		
		      lnNETPC = lnGrossPPC + lnIncC - lnExpC
		      lnNETPY = lnGrossPPY + lnIncY - lnExpY
		
		      IF lnIncC # 0 OR lnExpC # 0 OR ;
		            lnIncY # 0 OR lnExpY # 0
		*
		*  Insert gross profit line in balance table
		*
		         m.nYearBal = lnNETPY
		         m.nCurBal  = lnNETPC
		         IF lnGrossC # 0
		            m.nCurPct = ROUND((m.nCurBal / lnGrossC) * 100, 1)
		         ELSE
		            m.nCurPct = 0
		         ENDIF
		         IF lnGrossY # 0
		            m.nYearPct = ROUND((m.nYearBal / lnGrossY) * 100, 1)
		         ELSE
		            m.nYearPct = 0
		         ENDIF
		         m.cAcctDesc  = 'Net Income Before Pension & Bonus'
		         m.cAcctNo    = ' '
		         m.cBalGroup  = 'K'
		         m.cAcctType  = 'Net Income'
		         m.nAcctType  = 0
		         m.cFiscalYr  = lcYear
		         m.cFiscalPrd = lcPeriod
		         m.nBegBal    = 0
		         m.nDebits    = 0
		         m.nCredits   = 0
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the net income before taxes
		*
			  SELECT  SUM(nCurBal),;
					  SUM(nYearBal) ;
				  FROM balance ;
				  WHERE nAcctType = 16  ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laIncome
		
		      IF _TALLY > 0
		         lnBonusC = laIncome[1, 1]
		         lnBonusY = laIncome[1, 2]
		      ELSE
		         STORE 0 TO lnBonusC, lnBonusY
		      ENDIF
		
		
		      lnNETPC = lnNETPC  - lnBonusC
		      lnNETPY = lnNETPY  - lnBonusY
		
		      IF lnBonusC # 0 OR lnBonusY # 0
		*
		*  Insert gross profit line in balance table
		*
		         m.nYearBal = lnNETPY
		         m.nCurBal  = lnNETPC
		         IF lnGrossC # 0
		            m.nCurPct = ROUND((m.nCurBal / lnGrossC) * 100, 1)
		         ELSE
		            m.nCurPct = 0
		         ENDIF
		         IF lnGrossY # 0
		            m.nYearPct = ROUND((m.nYearBal / lnGrossY) * 100, 1)
		         ELSE
		            m.nYearPct = 0
		         ENDIF
		         m.cAcctDesc  = 'Net Income Before Taxes'
		         m.cAcctNo    = ' '
		         m.cBalGroup  = 'M'
		         m.cAcctType  = 'Net Income'
		         m.nAcctType  = 0
		         m.cFiscalYr  = lcYear
		         m.cFiscalPrd = lcPeriod
		         m.nBegBal    = 0
		         m.nDebits    = 0
		         m.nCredits   = 0
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the Current Earnings
		*
		
			  SELECT  SUM(nCurBal),;
					  SUM(nYearBal) ;
				  FROM balance ;
				  WHERE nAcctType = 15 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laCurEarn
		
		      IF _TALLY > 0
		         THISFORM.nnetincC = lnNETPC - laCurEarn[1, 1]
		         THISFORM.nnetincY = lnNETPY - laCurEarn[1, 2]
		      ELSE
		         THISFORM.nnetincC = lnNETPC
		         THISFORM.nnetincY = lnNETPY
		      ENDIF
		
		
		*
		*  Plug in breaks after totals
		*
		      lnBreak = 1
		      SELE balance
		      SCAN FOR EMPTY(cBreak)
		         SCATTER MEMVAR
		         IF lTotalAcct
		            m.cBreak = PADL(ALLT(STR(lnBreak)), 2, '0')
		            INSERT INTO balanceb FROM MEMVAR
		            lnBreak = lnBreak + 1
		         ENDIF
		      ENDSCAN
		
		      SELE balance
		      APPEND FROM DBF('balanceb')
		*
		*  Plug in the account descriptions and delete any non income stmt
		*  accounts.
		*
		      SELECT balance
		      SET ORDER TO 0
		      SCAN
		         m.nAcctType = nAcctType
		         IF nAcctType # 0
		            swselect('glacctyp')
		            IF SEEK(m.nAcctType)
		               lcDesc = glacctyp.ctypedesc
		               SELECT balance
		               REPLACE cAcctType WITH lcDesc
		            ELSE
		               SELECT balance
		               REPLACE cAcctType WITH 'Unknown'
		            ENDIF
		         ELSE
		            LOOP
		         ENDIF
		         DO CASE
		            CASE m.nAcctType = 8
		               REPLACE cBalGroup WITH 'A'
		            CASE m.nAcctType = 9
		               REPLACE cBalGroup WITH 'B'
		            CASE m.nAcctType = 10
		               REPLACE cBalGroup WITH 'D'
		            CASE m.nAcctType = 11
		               REPLACE cBalGroup WITH 'E'
		            CASE m.nAcctType = 12
		               REPLACE cBalGroup WITH 'G'
		            CASE m.nAcctType = 13
		               REPLACE cBalGroup WITH 'I'
		            CASE m.nAcctType = 14
		               REPLACE cBalGroup WITH 'J'
		            CASE m.nAcctType = 16
		               REPLACE cBalGroup WITH 'L'
		            CASE m.nAcctType = 15
		               REPLACE cBalGroup WITH 'N'
		            OTHERWISE
		               DELETE NEXT 1
		               LOOP
		         ENDCASE
		*@
		      ENDSCAN
		
		   ELSE
		
		      IF lnReportBy = 1
		         m.cPeriod1 = 'This Month'
		         m.cPeriod2 = 'This Month' + CHR(10) + 'Last Year'
		         m.cYear1   = 'Year-to-Date'
		         m.cYear2   = 'Last' + CHR(10) + 'Year-to-Date'
		      ELSE
		         m.cPeriod1 = 'This Quarter'
		         m.cPeriod2 = 'This Quarter' + CHR(10) + 'Last Year'
		         m.cYear1   = 'Year-to-Date'
		         m.cYear2   = 'Last' + CHR(10) + 'Year-to-Date'
		      ENDIF
		
		*
		*  Get the periods activity for each account in the range. (current year)
		*
			  SELECT  coa.cAcctNo,       ;
					  coa.cAcctDesc,     ;
					  coa.nAcctType,     ;
					  coa.lTitle,        ;
					  coa.lTotalAcct,    ;
					  coabalnew.cYear AS cFiscalYr,  ;
					  coabalnew.cPeriod AS cFiscalPrd, ;
					  SUM(coabalnew.nDebits) AS nDebits1,   ;
					  SUM(coabalnew.nCredits) AS nCredits1   ;
				  FROM coabalnew ;
				  JOIN coa ;
					  ON coabalnew.cAcctNo = coa.cAcctNo ;
				  WHERE BETWEEN(coabalnew.cYear + coabalnew.cPeriod, lcYear + lcPeriod1, lcYear + lcPeriod2) ;
					  AND NOT DELETED() ;
				  INTO CURSOR tempbal1 ;
				  ORDER BY 1 ;
				  GROUP BY 1
		
			  SELECT  coa.cAcctNo,            ;
					  coa.cAcctDesc,          ;
					  coa.nAcctType,          ;
					  coa.lTitle,             ;
					  coa.lTotalAcct,         ;
					  lcYear AS cFiscalYr,    ;
					  lcPeriod AS cFiscalPrd, ;
					  0 AS nDebits1, ;
					  0 AS nCredits1 ;
				  FROM coa ;
				  WHERE coa.cAcctNo NOT IN (SELECT  cAcctNo ;
												FROM tempbal1) ;
				  INTO CURSOR tempbal2 ;
				  ORDER BY 1 ;
				  GROUP BY 1
		
		      lcCurYear = _TALLY
		
		*
		*  Get the periods activity for each account in the range for last year.
		*
			  SELECT  coa.cAcctNo,       ;
					  coa.cAcctDesc,     ;
					  coa.nAcctType,     ;
					  coabalnew.cYear AS cFiscalYr,  ;
					  coabalnew.cPeriod AS cFiscalPrd, ;
					  SUM(coabalnew.nDebits) AS nDebits2, ;
					  SUM(coabalnew.nCredits) AS nCredits2 ;
				  FROM coabalnew ;
				  JOIN coa ;
					  ON coabalnew.cAcctNo = coa.cAcctNo ;
				  WHERE BETWEEN(coabalnew.cYear + coabalnew.cPeriod, jcYear + lcPeriod1, jcYear + lcPeriod2) ;
					  AND NOT DELETED() ;
				  INTO CURSOR tempbal3 ;
				  ORDER BY 1 ;
				  GROUP BY 1
		
			  SELECT  coa.cAcctNo,            ;
					  coa.cAcctDesc,          ;
					  coa.nAcctType,     ;
					  lcYear AS cFiscalYr,    ;
					  lcPeriod AS cFiscalPrd, ;
					  0 AS nDebits2, ;
					  0 AS nCredits2 ;
				  FROM coabalnew, coa ;
				  WHERE coa.cAcctNo NOT IN (SELECT  cAcctNo ;
												FROM tempbal3) ;
				  INTO CURSOR tempbal4 ;
				  ORDER BY 1 ;
				  GROUP BY 1
		
		*
		*  Append the records to the balance table
		*
		      SELECT balance
		      APPEND FROM DBF('tempbal1')
		      APPEND FROM DBF('tempbal2')
		      SET ORDER TO AcctNo
		      USE IN tempbal1
		      USE IN tempbal2
		
		      REPLACE cPeriod1 WITH m.cPeriod1, ;
		         cPeriod2 WITH m.cPeriod2, ;
		         cYear1   WITH m.cYear1, ;
		         cYear2   WITH m.cYear2 ALL
		
		*
		*  Add in last year's balances.
		*
		      SELECT tempbal3
		      SCAN
		         SCATTER MEMVAR
		         SELECT balance
		         LOCATE FOR cAcctNo = m.cAcctNo
		         IF FOUND()
		            REPLACE nDebits2  WITH m.nDebits2, ;
		               nCredits2 WITH m.nCredits2
		         ELSE
		            INSERT INTO balance FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		
		*
		*  Get the beginning balances for each account in the range (current year)
		*
			  SELECT  coabalnew.cAcctNo, ;
					  SUM(nDebits) AS nDebits1, ;
					  SUM(nCredits) AS nCredits1 ;
				  FROM coabalnew ;
				  WHERE coabalnew.cYear  = lcYear ;
					  AND coabalnew.cPeriod < lcPeriod1 ;
				  INTO CURSOR tempbeg ;
				  ORDER BY coabalnew.cAcctNo ;
				  GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		      IF _TALLY > 0
		         SELECT tempbeg
		         SCAN
		            SCATTER MEMVAR
		            SELECT balance
		            LOCATE FOR cAcctNo = m.cAcctNo
		            IF FOUND()
		               IF nAcctType = 8 OR nAcctType = 13
		                  lnBegBal  = m.nCredits1 - m.nDebits1
		                  lnYearBal = lnBegBal + (nCredits1 - nDebits1)
		                  lnCurBal  = nCredits1 - nDebits1
		               ELSE
		                  lnBegBal  = m.nDebits1 - m.nCredits1
		                  lnYearBal = lnBegBal + (nDebits1 - nCredits1)
		                  lnCurBal  = nDebits1 - nCredits1
		               ENDIF
		               REPLACE nBegBal1  WITH lnBegBal, ;
		                  nCurBal1  WITH lnCurBal, ;
		                  nYearBal1 WITH lnYearBal
		            ENDIF
		         ENDSCAN
		      ENDIF
		
		*
		*  Get the beginning balances for each account in the range (last year)
		*
			  SELECT  coabalnew.cAcctNo, ;
					  SUM(nDebits) AS nDebits2, ;
					  SUM(nCredits) AS nCredits2 ;
				  FROM coabalnew ;
				  WHERE coabalnew.cYear = jcYear ;
					  AND coabalnew.cPeriod < lcPeriod1 ;
					  AND NOT DELETED() ;
				  INTO CURSOR tempbeg ;
				  ORDER BY coabalnew.cAcctNo ;
				  GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		      IF _TALLY > 0
		         SELECT tempbeg
		         SCAN
		            SCATTER MEMVAR
		            SELECT balance
		            LOCATE FOR cAcctNo = m.cAcctNo
		            IF FOUND()
		               IF nAcctType = 8 OR nAcctType = 13
		                  lnBegBal  = m.nCredits2 - m.nDebits2
		                  lnYearBal = lnBegBal + (nCredits2 - nDebits2)
		                  lnCurBal  = nCredits2 - nDebits2
		               ELSE
		                  lnBegBal  = m.nDebits2 - m.nCredits2
		                  lnYearBal = lnBegBal + (nDebits2 - nCredits2)
		                  lnCurBal  = nDebits2 - nCredits2
		               ENDIF
		               REPLACE nBegBal2  WITH lnBegBal, ;
		                  nCurBal2  WITH lnCurBal, ;
		                  nYearBal2 WITH lnYearBal
		            ENDIF
		         ENDSCAN
		      ENDIF
		
		*
		*  Plug in the ending balances
		*
		      SELECT balance
		      SET ORDER TO 0
		      SCAN
		         IF EMPTY(nBegBal1)
		            IF nAcctType = 8 OR nAcctType = 13
		               REPLACE nYearBal1 WITH nCredits1 - nDebits1, ;
		                  nCurBal1  WITH nCredits1 - nDebits1, ;
		                  nBegBal1  WITH 0
		            ELSE
		               REPLACE nYearBal1 WITH nDebits1 - nCredits1, ;
		                  nCurBal1  WITH nDebits1 - nCredits1, ;
		                  nBegBal1  WITH 0
		            ENDIF
		         ENDIF
		         IF EMPTY(nBegBal2)
		            IF nAcctType = 8 OR nAcctType = 13
		               REPLACE nYearBal2 WITH nCredits2 - nDebits2, ;
		                  nCurBal2  WITH nCredits2 - nDebits2, ;
		                  nBegBal2  WITH 0
		            ELSE
		               REPLACE nYearBal2 WITH nDebits2 - nCredits2, ;
		                  nCurBal2  WITH nDebits2 - nCredits2, ;
		                  nBegBal2  WITH 0
		            ENDIF
		         ENDIF
		      ENDSCAN
		
		*
		*  Calculate the Gross Revenue
		*
			  SELECT  SUM(nCurBal1),;
					  SUM(nYearBal1), ;
					  SUM(nCurBal2),;
					  SUM(nYearBal2) ;
				  FROM balance ;
				  WHERE nAcctType = 8 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laGrossRev
		
		      IF _TALLY > 0
		         lnGrossC1 = laGrossRev[1, 1]
		         lnGrossY1 = laGrossRev[1, 2]
		         lnGrossC2 = laGrossRev[1, 3]
		         lnGrossY2 = laGrossRev[1, 4]
		         SELECT balance
		         SCAN FOR BETWEEN(nAcctType, 8, 16)
		            IF lnGrossC1 # 0
		               REPLACE nCurPct1 WITH ABS(ROUND(((nCurBal1 / lnGrossC1) * 100), 1))
		            ENDIF
		            IF lnGrossY1 # 0
		               REPLACE nYearPct1 WITH ABS(ROUND(((nYearBal1 / lnGrossY1) * 100), 1))
		            ENDIF
		            IF lnGrossC2 # 0
		               REPLACE nCurPct2 WITH ABS(ROUND(((nCurBal2 / lnGrossC2) * 100), 1))
		            ENDIF
		            IF lnGrossY2 # 0
		               REPLACE nYearPct2 WITH ABS(ROUND(((nYearBal2 / lnGrossY2) * 100), 1))
		            ENDIF
		         ENDSCAN
		      ELSE
		         STORE 0 TO lnGrossC1, lnGrossY1, lnGrossC2, lnGrossY2
		      ENDIF
		
		*
		*  Calculate the Cost of Goods Sold
		*
			  SELECT  SUM(nCurBal1),;
					  SUM(nYearBal1), ;
					  SUM(nCurBal2),;
					  SUM(nYearBal2)  ;
				  FROM balance ;
				  WHERE nAcctType = 9 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laCOGS
		
		      IF _TALLY > 0
		         lnCOGSC1 = laCOGS[1, 1]
		         lnCOGSY1 = laCOGS[1, 2]
		         lnCOGSC2 = laCOGS[1, 3]
		         lnCOGSY2 = laCOGS[1, 4]
		      ELSE
		         STORE 0 TO lnCOGSC1, lnCOGSY1, lnCOGSC2, lnCOGSY2
		      ENDIF
		
		*
		*  Calculate the Gross Profit
		*
		      lnGrossPC1 = lnGrossC1 - lnCOGSC1
		      lnGrossPY1 = lnGrossY1 - lnCOGSY1
		      lnGrossPC2 = lnGrossC2 - lnCOGSC2
		      lnGrossPY2 = lnGrossY2 - lnCOGSY2
		
		*
		*  Insert gross profit line in balance table
		*
		      m.nYearBal1 = lnGrossPY1
		      m.nCurBal1  = lnGrossPC1
		      m.nYearBal2 = lnGrossPY2
		      m.nCurBal2  = lnGrossPC2
		      m.cAcctDesc = 'Gross Profit'
		      m.cAcctNo   = ' '
		      m.cBalGroup = 'C'
		      m.cAcctType = 'Gross Profit'
		      STORE 0 TO m.nBegBal1, m.nBegBal2, m.nDebits1, m.nDebits2, m.nAcctType
		      IF lnGrossC1 # 0
		         m.nCurPct1 = ABS(ROUND(((m.nCurBal1 / lnGrossC1) * 100), 1))
		      ELSE
		         m.nCurPct1 = 0
		      ENDIF
		      IF lnGrossY1 # 0
		         m.nYearPct1 = ABS(ROUND(((m.nYearBal1 / lnGrossY1) * 100), 1))
		      ELSE
		         m.nYearPct1 = 0
		      ENDIF
		      IF lnGrossC2 # 0
		         m.nCurPct2 = ABS(ROUND(((m.nCurBal2 / lnGrossC2) * 100), 1))
		      ELSE
		         m.nCurPct2 = 0
		      ENDIF
		      IF lnGrossY2 # 0
		         m.nYearPct2 = ABS(ROUND(((m.nYearBal2 / lnGrossY2) * 100), 1))
		      ELSE
		         m.nYearPct2 = 0
		      ENDIF
		
		*
		*  Only show a gross profit here if there is at lease
		*  one cost of goods sold account defined.
		*
		      SELE cAcctNo FROM coa INTO ARRAY laCOGS WHERE nAcctType = 9
		      lnCOGS = _TALLY
		      IF lnCOGS > 0
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the gross profit from operations
		*
			  SELECT  SUM(nCurBal1),;
					  SUM(nYearBal1), ;
					  SUM(nCurBal2),;
					  SUM(nYearBal2) ;
				  FROM balance ;
				  WHERE BETWEEN(nAcctType, 10, 11) ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laExpenses
		
		      IF _TALLY > 0
		         lnExpenseC1 = laExpenses[1, 1]
		         lnExpenseY1 = laExpenses[1, 2]
		         lnExpenseC2 = laExpenses[1, 3]
		         lnExpenseY2 = laExpenses[1, 4]
		      ELSE
		         STORE 0 TO lnExpenseC1, lnExpenseY1, lnExpenseC2, lnExpenseY2
		      ENDIF
		
		      lnGrossPOC1 = lnGrossPC1 - lnExpenseC1
		      lnGrossPOY1 = lnGrossPY1 - lnExpenseY1
		      lnGrossPOC2 = lnGrossPC2 - lnExpenseC2
		      lnGrossPOY2 = lnGrossPY2 - lnExpenseY2
		
		      IF lnExpenseC1 # 0 OR lnExpenseY1 # 0 OR ;
		            lnExpenseC2 # 0 OR lnExpenseY2 # 0
		*
		*  Insert gross profit line in balance table
		*
		         m.nYearBal1 = lnGrossPOY1
		         m.nCurBal1  = lnGrossPOC1
		         m.nYearBal2 = lnGrossPOY2
		         m.nCurBal2  = lnGrossPOC2
		         IF lnGrossC1 # 0
		            m.nCurPct1 = ABS(ROUND(((m.nCurBal1 / lnGrossC1) * 100), 1))
		         ELSE
		            m.nCurPct1 = 0
		         ENDIF
		         IF lnGrossY1 # 0
		            m.nYearPct1 = ABS(ROUND(((m.nYearBal1 / lnGrossY1) * 100), 1))
		         ELSE
		            m.nYearPct1 = 0
		         ENDIF
		         IF lnGrossC2 # 0
		            m.nCurPct2 = ABS(ROUND(((m.nCurBal2 / lnGrossC2) * 100), 1))
		         ELSE
		            m.nCurPct2 = 0
		         ENDIF
		         IF lnGrossY2 # 0
		            m.nYearPct2 = ABS(ROUND(((m.nYearBal2 / lnGrossY2) * 100), 1))
		         ELSE
		            m.nYearPct2 = 0
		         ENDIF
		         m.cAcctDesc  = 'Gross Profit From Operations'
		         m.cAcctNo    = ' '
		         m.cBalGroup  = 'F'
		         m.cAcctType  = 'Gross Profit'
		         m.nAcctType  = 0
		         m.cFiscalYr  = lcYear
		         m.cFiscalPrd = lcPeriod
		         m.nBegBal    = 0
		         m.nDebits    = 0
		         m.nCredits   = 0
		
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the gross profit from producing leases
		*
			  SELECT  SUM(nCurBal1),;
					  SUM(nYearBal1), ;
					  SUM(nCurBal2),;
					  SUM(nYearBal2) ;
				  FROM balance ;
				  WHERE nAcctType = 12 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laDepreciation
		
		      IF _TALLY > 0
		         lnDeprC1 = laDepreciation[1, 1]
		         lnDeprY1 = laDepreciation[1, 2]
		         lnDeprC2 = laDepreciation[1, 3]
		         lnDeprY2 = laDepreciation[1, 4]
		      ELSE
		         STORE 0 TO lnDeprC1, lnDeprY1, lnDeprC2, lnDeprY2
		      ENDIF
		
		      lnGrossPPC1 = lnGrossPOC1 - lnDeprC1
		      lnGrossPPY1 = lnGrossPOY1 - lnDeprY1
		      lnGrossPPC2 = lnGrossPOC2 - lnDeprC2
		      lnGrossPPY2 = lnGrossPOY2 - lnDeprY2
		
		      IF lnDeprC1 # 0 OR lnDeprY1 # 0 OR ;
		            lnDeprC2 # 0 OR lnDeprY2 # 0
		*
		*  Insert gross profit line in balance table
		*
		         m.nYearBal1 = lnGrossPPY1
		         m.nCurBal1  = lnGrossPPC1
		         m.nYearBal2 = lnGrossPPY2
		         m.nCurBal2  = lnGrossPPC2
		         IF lnGrossC1 # 0
		            m.nCurPct1 = ABS(ROUND(((m.nCurBal1 / lnGrossC1) * 100), 1))
		         ELSE
		            m.nCurPct1 = 0
		         ENDIF
		         IF lnGrossY1 # 0
		            m.nYearPct1 = ABS(ROUND(((m.nYearBal1 / lnGrossY1) * 100), 1))
		         ELSE
		            m.nYearPct1 = 0
		         ENDIF
		         IF lnGrossC2 # 0
		            m.nCurPct2 = ABS(ROUND(((m.nCurBal2 / lnGrossC2) * 100), 1))
		         ELSE
		            m.nCurPct2 = 0
		         ENDIF
		         IF lnGrossY2 # 0
		            m.nYearPct2 = ABS(ROUND(((m.nYearBal2 / lnGrossY2) * 100), 1))
		         ELSE
		            m.nYearPct2 = 0
		         ENDIF
		         m.cAcctDesc  = 'Gross Profit From Producing Leases'
		         m.cAcctNo    = ' '
		         m.cBalGroup  = 'H'
		         m.cAcctType  = 'Gross Profit'
		         m.nAcctType  = 0
		         m.cFiscalYr  = lcYear
		         m.cFiscalPrd = lcPeriod
		         m.nBegBal    = 0
		         m.nDebits    = 0
		         m.nCredits   = 0
		
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the net income before pension & bonus
		*
			  SELECT  SUM(nCurBal1),;
					  SUM(nYearBal1), ;
					  SUM(nCurBal2),;
					  SUM(nYearBal2) ;
				  FROM balance ;
				  WHERE nAcctType = 13  ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laIncome
		
		      IF _TALLY > 0
		         lnIncC1 = laIncome[1, 1]
		         lnIncY1 = laIncome[1, 2]
		         lnIncC2 = laIncome[1, 3]
		         lnIncY2 = laIncome[1, 4]
		      ELSE
		         STORE 0 TO lnIncC1, lnIncY1, lnIncC2, lnIncY2
		      ENDIF
		
			  SELECT  SUM(nCurBal1),;
					  SUM(nYearBal1), ;
					  SUM(nCurBal2),;
					  SUM(nYearBal2) ;
				  FROM balance ;
				  WHERE nAcctType = 14 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laExpense
		
		      IF _TALLY > 0
		         lnExpC1 = laExpense[1, 1]
		         lnExpY1 = laExpense[1, 2]
		         lnExpC2 = laExpense[1, 3]
		         lnExpY2 = laExpense[1, 4]
		      ELSE
		         STORE 0 TO lnExpC1, lnExpY1, lnExpC2, lnExpY2
		      ENDIF
		
		      lnNETPC1 = lnGrossPPC1 + lnIncC1 - lnExpC1
		      lnNETPY1 = lnGrossPPY1 + lnIncY1 - lnExpY1
		      lnNETPC2 = lnGrossPPC2 + lnIncC2 - lnExpC2
		      lnNETPY2 = lnGrossPPY2 + lnIncY2 - lnExpY2
		
		      IF lnIncC1 # 0 OR lnIncY1 # 0 OR lnIncC2 # 0 OR lnIncY2 # 0 OR ;
		            lnExpC1 # 0 OR lnExpY1 # 0 OR lnExpC2 # 0 OR lnExpY2 # 0
		*
		*  Insert gross profit line in balance table
		*
		         m.nYearBal1 = lnNETPY1
		         m.nCurBal1  = lnNETPC1
		         m.nYearBal2 = lnNETPY2
		         m.nCurBal2  = lnNETPC2
		         IF lnGrossC1 # 0
		            m.nCurPct1 = ROUND((m.nCurBal1 / lnGrossC1) * 100, 1)
		         ELSE
		            m.nCurPct1 = 0
		         ENDIF
		         IF lnGrossY1 # 0
		            m.nYearPct1 = ROUND((m.nYearBal1 / lnGrossY1) * 100, 1)
		         ELSE
		            m.nYearPct1 = 0
		         ENDIF
		         IF lnGrossC2 # 0
		            m.nCurPct2 = ROUND((m.nCurBal2 / lnGrossC2) * 100, 1)
		         ELSE
		            m.nCurPct2 = 0
		         ENDIF
		         IF lnGrossY2 # 0
		            m.nYearPct2 = ROUND((m.nYearBal2 / lnGrossY2) * 100, 1)
		         ELSE
		            m.nYearPct2 = 0
		         ENDIF
		         m.cAcctDesc  = 'Net Income Before Pension & Bonus'
		         m.cAcctNo    = ' '
		         m.cBalGroup  = 'K'
		         m.cAcctType  = 'Net Income'
		         m.nAcctType  = 0
		         m.cFiscalYr  = lcYear
		         m.cFiscalPrd = lcPeriod
		         m.nBegBal    = 0
		         m.nDebits    = 0
		         m.nCredits   = 0
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the net income before taxes
		*
			  SELECT  SUM(nCurBal1),;
					  SUM(nYearBal1), ;
					  SUM(nCurBal2),;
					  SUM(nYearBal2) ;
				  FROM balance ;
				  WHERE nAcctType = 16  ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laIncome
		
		      IF _TALLY > 0
		         lnBonusC1 = laIncome[1, 1]
		         lnBonusY1 = laIncome[1, 2]
		         lnBonusC2 = laIncome[1, 3]
		         lnBonusY2 = laIncome[1, 4]
		      ELSE
		         STORE 0 TO lnBonusC1, lnBonusY1, lnBonusC2, lnBonusY2
		      ENDIF
		
		
		      lnNETPC1 = lnNETPC1  - lnBonusC1
		      lnNETPY1 = lnNETPY1  - lnBonusY1
		      lnNETPC2 = lnNETPC2  - lnBonusC2
		      lnNETPY2 = lnNETPY2  - lnBonusY2
		
		      IF lnBonusC1 # 0 OR lnBonusY1 # 0 OR ;
		            lnBonusC2 # 0 OR lnBonusY2 # 0
		*
		*  Insert gross profit line in balance table
		*
		         m.nYearBal1 = lnNETPY1
		         m.nCurBal1  = lnNETPC1
		         m.nYearBal2 = lnNETPY2
		         m.nCurBal2  = lnNETPC2
		         IF lnGrossC1 # 0
		            m.nCurPct1 = ROUND((m.nCurBal1 / lnGrossC1) * 100, 1)
		         ELSE
		            m.nCurPct1 = 0
		         ENDIF
		         IF lnGrossY1 # 0
		            m.nYearPct1 = ROUND((m.nYearBal1 / lnGrossY1) * 100, 1)
		         ELSE
		            m.nYearPct1 = 0
		         ENDIF
		         IF lnGrossC2 # 0
		            m.nCurPct2 = ROUND((m.nCurBal2 / lnGrossC2) * 100, 1)
		         ELSE
		            m.nCurPct2 = 0
		         ENDIF
		         IF lnGrossY2 # 0
		            m.nYearPct2 = ROUND((m.nYearBal2 / lnGrossY2) * 100, 1)
		         ELSE
		            m.nYearPct2 = 0
		         ENDIF
		         m.cAcctDesc  = 'Net Income Before Taxes'
		         m.cAcctNo    = ' '
		         m.cBalGroup  = 'M'
		         m.cAcctType  = 'Net Income'
		         m.nAcctType  = 0
		         m.cFiscalYr  = lcYear
		         m.cFiscalPrd = lcPeriod
		         m.nBegBal    = 0
		         m.nDebits    = 0
		         m.nCredits   = 0
		         m.nNetIncC1  = 0
		         m.nNetIncC2  = 0
		         m.nNetIncY1  = 0
		         m.nNetIncY2  = 0
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		
		*
		*  Calculate the Current Earnings
		*
		
			  SELECT  SUM(nCurBal1),;
					  SUM(nYearBal1), ;
					  SUM(nCurBal2),;
					  SUM(nYearBal2) ;
				  FROM balance ;
				  WHERE nAcctType = 15 ;
					  AND lTotalAcct = .F. ;
				  INTO ARRAY laCurEarn
		
		      IF _TALLY > 0
		         THISFORM.nNetIncC1 = lnNETPC1 - laCurEarn[1, 1]
		         THISFORM.nNetIncY1 = lnNETPY1 - laCurEarn[1, 2]
		         THISFORM.nNetIncC2 = lnNETPC2 - laCurEarn[1, 3]
		         THISFORM.nNetIncY2 = lnNETPY2 - laCurEarn[1, 4]
		      ELSE
		         THISFORM.nNetIncC1 = lnNETPC1
		         THISFORM.nNetIncY1 = lnNETPY1
		         THISFORM.nNetIncC2 = lnNETPC2
		         THISFORM.nNetIncY2 = lnNETPY2
		      ENDIF
		
		*
		*  Calculate the Current Earnings
		*
		
		*
		*  Plug in breaks after totals
		*
		      lnBreak = 1
		      SELE balance
		      SCAN FOR EMPTY(cBreak)
		         SCATTER MEMVAR
		         IF lTotalAcct
		            m.cBreak = PADL(ALLT(STR(lnBreak)), 2, '0')
		            INSERT INTO balanceb FROM MEMVAR
		            lnBreak = lnBreak + 1
		         ENDIF
		      ENDSCAN
		
		      SELE balance
		      APPEND FROM DBF('balanceb')
		
		*
		*  Plug in the account types
		*
		      SELECT balance
		      SCAN
		         m.nAcctType = nAcctType
		         IF m.nAcctType # 0
		            swselect('glacctyp')
		            LOCATE FOR nAcctType = m.nAcctType
		            IF FOUND()
		               lcDesc = glacctyp.ctypedesc
		               SELECT balance
		               REPLACE cAcctType WITH lcDesc
		            ELSE
		               SELECT balance
		               REPLACE cAcctType WITH 'Unknown'
		            ENDIF
		         ELSE
		            LOOP
		         ENDIF
		         DO CASE
		            CASE m.nAcctType = 8
		               REPLACE cBalGroup WITH 'A'
		            CASE m.nAcctType = 9
		               REPLACE cBalGroup WITH 'B'
		            CASE m.nAcctType = 10
		               REPLACE cBalGroup WITH 'D'
		            CASE m.nAcctType = 11
		               REPLACE cBalGroup WITH 'E'
		            CASE m.nAcctType = 12
		               REPLACE cBalGroup WITH 'G'
		            CASE m.nAcctType = 13
		               REPLACE cBalGroup WITH 'I'
		            CASE m.nAcctType = 14
		               REPLACE cBalGroup WITH 'J'
		            CASE m.nAcctType = 16
		               REPLACE cBalGroup WITH 'L'
		            CASE m.nAcctType = 15
		               REPLACE cBalGroup WITH 'N'
		            OTHERWISE
		               DELETE NEXT 1
		               LOOP
		         ENDCASE
		      ENDSCAN
		
		   ENDIF  && IF NOT llCompare
		
		   SELECT balance
		   SET DELETED OFF
		   SCAN
		      REPLACE cSortField WITH cAcctNo
		   ENDSCAN
		   SET DELETED ON
		
		   IF lcLevel # '*'  &&  Not reporting on all levels, so sum the balances
		      WAIT WINDOW NOWAIT 'Summing Sub-Accounts....Please Wait'
		      lnLevel = VAL(lcLevel)
		      SELECT balance
		      SCAN
		         SCATTER MEMVAR
		         lnRecNo        = RECNO()  &&  Store the current record, so we can return to it
		         lnCurrentLevel = THISFORM.glmaint.calcsublevel(m.cAcctNo)  &&  Determine the level of the current account, so we know whether it should be added to a parent account
		         IF lnCurrentLevel > lnLevel  &&  This account is below the level on which to report, so find the parent and add to its total
		            SELECT balance
		            DO CASE
		               CASE lnCurrentLevel - lnLevel = 1  &&  Only need to go up a single level to add on the totals
		                  swselect('coa')
		                  LOCATE FOR cAcctNo = m.cAcctNo  &&  Locate current account, and then check its parent
		                  IF FOUND()
		                     lcParent = cParent  &&  This is the account to have the current totals added to
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 2  &&  Need to go up two levels to find the parent
		                  swselect('coa')
		                  LOCATE FOR cAcctNo = m.cAcctNo
		                  IF FOUND()
		                     lcParent = cParent
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 3  &&  Need to go up 3 levels to find the parent
		                  swselect('coa')
		                  LOCATE FOR cAcctNo = m.cAcctNo
		                  IF FOUND()
		                     lcParent = cParent  &&  One level up
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent  &&  Two levels up
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent  &&  Three levels up
		                        ELSE
		                           WAIT WINDOW 'Problem locating parent account...'
		                        ENDIF
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 4  &&  Need to go up 4 levels to find the parent - this is the max
		                  swselect('coa')
		                  LOCATE FOR cAcctNo = m.cAcctNo
		                  IF FOUND()
		                     lcParent = cParent  &&  One level up
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent  &&  Two levels up
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent  &&  Three levels up
		                           LOCATE FOR cAcctNo = lcParent
		                           IF FOUND()
		                              lcParent = cParent  &&  Four levels up
		                           ELSE
		                              WAIT WINDOW 'Problem locating parent account...'
		                           ENDIF
		                        ELSE
		                           WAIT WINDOW 'Problem locating parent account...'
		                        ENDIF
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               OTHERWISE  &&  Should never get here, since it means there's more than a 4 level difference
		                  WAIT WINDOW 'Too many levels'
		            ENDCASE
		
		**  Now that we know what the parent account is on the right level, add the current record totals to it  **
		            SELECT balance
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               IF llCompare  &&  Comparison report, so the fields with numbers in them are slightly different
		                  REPLACE nBegBal1 WITH nBegBal1 + m.nBegBal1, nDebits1 WITH nDebits1 + m.nDebits1, nCredits1 WITH nCredits1 + m.nCredits1,  ;
		                     nCurBal1 WITH nCurBal1 + m.nCurBal1, nCurPct1 WITH nCurPct1 + m.nCurPct1, nYearBal1 WITH nYearBal1 + m.nYearBal1,  ;
		                     nYearPct1 WITH nYearPct1 + m.nYearPct1, nBegBal2 WITH nBegBal2 + m.nBegBal2, nDebits2 WITH nDebits2 + m.nDebits2,  ;
		                     nCredits2 WITH nCredits2 + m.nCredits2, nCurBal2 WITH nCurBal2 + m.nCurBal2, nCurPct2 WITH nCurPct2 + m.nCurPct2,  ;
		                     nYearBal2 WITH nYearBal2 + m.nYearBal2, nYearPct2 WITH nYearPct2 + m.nYearPct2
		               ELSE  &&  Not a comparison report, so replace the appropriate fields
		                  REPLACE nBegBal WITH nBegBal + m.nBegBal, nDebits WITH nDebits + m.nDebits, nCredits WITH nCredits + m.nCredits,  ;
		                     nCurBal WITH nCurBal + m.nCurBal, nCurPct WITH nCurPct + m.nCurPct, nYearBal WITH nYearBal + m.nYearBal,  ;
		                     nYearPct WITH nYearPct + m.nYearPct
		               ENDIF
		            ELSE
		               WAIT WINDOW 'Cannot find parent account to add totals to'
		            ENDIF
		            GOTO lnRecNo  &&  Go back to original record, ready to continue scanning
		            DELETE NEXT 1
		         ENDIF
		
		      ENDSCAN
		
		   ENDIF
		
		* Mark parent accounts that have sub accounts as a title account
		* so the income stmt prints them in bold.
		   SELECT balance
		   SET DELETED OFF
		   SCAN
		      IF EMPTY(cAcctNo)
		         REPLACE nLevel WITH 1
		         LOOP
		      ENDIF
		
		      lnRecNo   = RECNO()
		      m.cAcctNo = ALLTRIM(cAcctNo)
		
		      swselect('coa')
		      SCAN FOR cParent = m.cAcctNo  &&  Do a scan instead of a locate, because there could be multiple subaccounts, some with activity, some without
		         SELECT balance
		         LOCATE FOR cAcctNo = coa.cAcctNo AND NOT DELETED() AND IIF(NOT llZero, IIF(llCompare, nCurBal1 + nYearBal1 # 0, nCurBal + nYearBal # 0), .T.)
		         IF FOUND()
		            GOTO lnRecNo
		            IF DELETED()
		               RECALL
		            ENDIF
		            REPLACE lTitle WITH .T. &&@
		         ENDIF
		         GOTO lnRecNo
		      ENDSCAN
		      SELECT balance
		
		      lnCurrentLevel = THISFORM.glmaint.calcsublevel(m.cAcctNo)
		      SELECT balance
		      REPLACE nLevel WITH lnCurrentLevel
		
		*  To ensure proper sorting, we need to allow for them marking an account as being subaccount of an account that's not necessarily
		*  right in line previous to this one.  Since the account number isn't shown on the report, we'll fudge the account number by padding
		*  it with all the parent account numbers, so it prints correctly in order, even if the actual account numbers aren't.
		      swselect('coa')
		      LOCATE FOR cAcctNo = m.cAcctNo
		      IF FOUND()
		         IF NOT EMPTY(cParent)
		            lcParent = cParent
		            SELECT balance
		            REPLACE cSortField WITH lcParent + cSortField, cParent WITH lcParent
		            swselect('coa')
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               lcParent = cParent
		               IF NOT EMPTY(lcParent)
		                  SELECT balance
		                  REPLACE cSortField WITH lcParent + cSortField
		                  swselect('coa')
		                  LOCATE FOR cAcctNo = lcParent
		                  IF FOUND()
		                     lcParent = cParent
		                     IF NOT EMPTY(lcParent)
		                        SELECT balance
		                        REPLACE cSortField WITH lcParent + cSortField
		                        swselect('coa')
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent
		                           IF NOT EMPTY(lcParent)
		                              SELECT balance
		                              REPLACE cSortField WITH lcParent + cSortField
		                              swselect('coa')
		                              LOCATE FOR cAcctNo = lcParent
		                              IF FOUND()
		                                 lcParent = cParent
		                                 IF NOT EMPTY(lcParent)
		                                    SELECT balance
		                                    REPLACE cSortField WITH lcParent + cSortField
		                                 ENDIF
		                              ENDIF
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		**  Scan and remove zero balance entries.  We'll delete every zero account, and then check to see whether the non-deleted accounts
		**  have parent accounts that need recalled to avoid orphaning subaccounts on the report.
		   IF NOT llZero
		      WAIT WINDOW NOWAIT 'Removing Zero Balance Entries'
		      SELECT balance
		      SET ORDER TO AcctNo
		      SCAN FOR IIF(llCompare, balance.nCurBal1 = 0 AND balance.nCurBal2 = 0 AND balance.nYearBal1 = 0 AND balance.nYearBal2 = 0, ;
		              balance.nCurBal = 0 AND balance.nYearBal = 0)  AND balance.cAcctNo # m.cCurEarn AND NOT EMPTY(cAcctNo) AND NOT lTitle
		         DELETE NEXT 1
		      ENDSCAN
		
		      SELECT balance
		      SCAN FOR LEN(ALLTRIM(cSortField)) > 6 AND IIF(llCompare, balance.nCurBal1 # 0  OR balance.nCurBal2 # 0, balance.nCurBal # 0) AND nAcctType >= 8 AND NOT EMPTY(cAcctNo) AND IIF(lcLevel # '*', nLevel <= VAL(lcLevel), .T.) &&  Accounts with parent accounts and activity
		         lnRecNo  = RECNO()
		         lcParent = balance.cParent
		         LOCATE FOR cAcctNo = lcParent
		         IF FOUND()
		            IF DELETED()  &&  This is a parent acct with activity for a subaccount, so recall it, so it shows up
		               RECALL
		            ENDIF
		            lcParent = balance.cParent
		            IF EMPTY(lcParent)
		               GOTO lnRecNo
		               LOOP
		            ENDIF
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               IF DELETED()
		                  RECALL
		               ENDIF
		               lcParent = balance.cParent
		               IF EMPTY(lcParent)
		                  GOTO lnRecNo
		                  LOOP
		               ENDIF
		               LOCATE FOR cAcctNo = lcParent
		               IF FOUND()
		                  IF DELETED()
		                     RECALL
		                  ENDIF
		                  lcParent = balance.cParent
		                  IF EMPTY(lcParent)
		                     GOTO lnRecNo
		                     LOOP
		                  ENDIF
		                  LOCATE FOR cAcctNo = lcParent
		                  IF FOUND()
		                     IF DELETED()
		                        RECALL
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		         SELECT balance
		         GOTO lnRecNo
		      ENDSCAN
		   ENDIF
		
		   SET DELETED ON
		**  Scan balance one more time.  This time, it's to sum up totals for each level, and determine when a total line should be printed.
		**  When scanning, we know that no total will need to be printed when the account levels are continually descending or staying at the same level.
		**  When the account level has gone back up (decreased), then we know we've got to print at least one total.  Possibly more, depending on the
		**  difference between the previous level and the current level.  For example, going from a level 5 account to a level 2 account would entail
		**  the possibility of having to print a total for the level 5, 4, and 3 accounts.
		   IF llShowTotals
		      STORE 0 TO lnLastLevel, lnTotal, lnTotal2
		      STORE '' TO lcLastAcctNo
		      WAIT WINDOW NOWAIT 'Counting Levels...'
		      SELECT balance
		      SET ORDER TO AcctNo
		      SCAN FOR NOT EMPTY(cAcctNo)
		         lnRecNo      = RECNO()
		         m.cAcctNo    = ALLTRIM(cAcctNo)
		         m.lTotalAcct = .T.
		
		         IF nLevel < lnLastLevel  &&  We've started back up, so totals may need to be added, depending on the counts for each level
		            SELECT balance
		            lnCount    = 1
		            lnTotal    = 0
		            lnTotal2   = 0
		            lnTotalYr  = 0
		            lnTotalYr2 = 0
		            LOCATE FOR cAcctNo = lcLastAcctNo
		            IF FOUND()  &&  Better find it, except for the first record...
		               lcParent = balance.cParent
		               SCAN FOR cParent = lcParent
		                  lnCount   = lnCount + 1
		                  lnTotal   = lnTotal + IIF(llCompare, nCurBal1, nCurBal)
		                  lnTotalYr = lnTotalYr + IIF(llCompare, nYearBal1, nYearBal)
		                  IF llCompare
		                     lnTotal2   = lnTotal2 + nCurBal2
		                     lnTotalYr2 = lnTotalYr2 + IIF(llCompare, nYearBal2, nYearBal)
		                  ENDIF
		               ENDSCAN
		
		               IF lnCount > 1
		                  SELECT balance
		                  LOCATE FOR cAcctNo = lcParent
		                  IF FOUND()  &&  Darn well better be...
		                     m.cAcctDesc  = balance.cAcctDesc
		                     m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                     m.nAcctType  = balance.nAcctType
		                     m.cBalGroup  = balance.cBalGroup
		                     m.cAcctType  = balance.cAcctType
		                     m.cAcctNo    = balance.cAcctNo
		                     m.nLevel     = balance.nLevel
		                     m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                     IF llCompare
		                        m.nCurBal1  = lnTotal + balance.nCurBal1
		                        m.nCurBal2  = lnTotal2 + balance.nCurBal2
		                        m.nYearBal1 = lnTotalYr + balance.nYearBal1
		                        m.nYearBal2 = lnTotalYr2 + balance.nYearBal2
		                        IF lnGrossC1 # 0
		                           m.nCurPct1 = ABS(ROUND(((m.nCurBal1 / lnGrossC1) * 100), 1))
		                        ELSE
		                           m.nCurPct1 = 0
		                        ENDIF
		                        IF lnGrossY1 # 0
		                           m.nYearPct1 = ABS(ROUND(((m.nYearBal1 / lnGrossY1) * 100), 1))
		                        ELSE
		                           m.nYearPct1 = 0
		                        ENDIF
		                        IF lnGrossC2 # 0
		                           m.nCurPct2 = ABS(ROUND(((m.nCurBal2 / lnGrossC2) * 100), 1))
		                        ELSE
		                           m.nCurPct2 = 0
		                        ENDIF
		                        IF lnGrossY2 # 0
		                           m.nYearPct2 = ABS(ROUND(((m.nYearBal2 / lnGrossY2) * 100), 1))
		                        ELSE
		                           m.nYearPct2 = 0
		                        ENDIF
		                     ELSE
		                        m.nCurBal  = lnTotal + balance.nCurBal  &&  Have to include the total for this specific account in the total, too
		                        m.nYearBal = lnTotalYr + balance.nYearBal
		                        IF lnGrossC # 0
		                           m.nCurPct = ABS(ROUND(((m.nCurBal / lnGrossC) * 100), 1))
		                        ELSE
		                           m.nCurPct = 0
		                        ENDIF
		                        IF lnGrossY # 0
		                           m.nYearPct = ABS(ROUND(((m.nYearBal / lnGrossY) * 100), 1))
		                        ELSE
		                           m.nYearPct = 0
		                        ENDIF
		                     ENDIF
		                     lnRecNo2 = RECNO()
		                     SELECT balance
		                     LOCATE FOR lTotalAcct AND cSortField = m.cSortField
		                     IF NOT FOUND()
		                        INSERT INTO balance FROM MEMVAR
		                     ENDIF
		                     GOTO lnRecNo2
		                  ENDIF
		
		                  IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 4 accounts now
		                     SELECT balance
		                     lnCount    = 1
		                     lnTotal    = 0
		                     lnTotal2   = 0
		                     lnTotalYr  = 0
		                     lnTotalYr2 = 0
		                     lcParent   = balance.cParent
		                     IF EMPTY(lcParent)
		                        lnLastLevel = 1
		                        GOTO lnRecNo
		                        LOOP
		                     ENDIF
		                     SCAN FOR cParent = lcParent
		                        lnCount   = lnCount + 1
		                        lnTotal   = lnTotal + IIF(llCompare, nCurBal1, nCurBal)
		                        lnTotalYr = lnTotalYr + IIF(llCompare, nYearBal1, nYearBal)
		                        IF llCompare
		                           lnTotal2   = lnTotal2 + nCurBal2
		                           lnTotalYr2 = lnTotalYr2 + IIF(llCompare, nYearBal2, nYearBal)
		                        ENDIF
		                     ENDSCAN
		
		                     IF lnCount > 1
		                        SELECT balance
		                        LOCATE FOR cAcctNo = lcParent AND NOT EMPTY(cAcctNo)
		                        IF FOUND()  &&  Darn well better be...
		                           m.cAcctDesc  = balance.cAcctDesc
		                           m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                           m.nAcctType  = balance.nAcctType
		                           m.cBalGroup  = balance.cBalGroup
		                           m.cAcctType  = balance.cAcctType
		                           m.cAcctNo    = balance.cAcctNo
		                           m.nLevel     = balance.nLevel
		                           m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                           IF llCompare
		                              m.nCurBal1  = lnTotal + balance.nCurBal1
		                              m.nCurBal2  = lnTotal2 + balance.nCurBal2
		                              m.nYearBal1 = lnTotalYr + balance.nYearBal1
		                              m.nYearBal2 = lnTotalYr2 + balance.nYearBal2
		                              IF lnGrossC1 # 0
		                                 m.nCurPct1 = ABS(ROUND(((m.nCurBal1 / lnGrossC1) * 100), 1))
		                              ELSE
		                                 m.nCurPct1 = 0
		                              ENDIF
		                              IF lnGrossY1 # 0
		                                 m.nYearPct1 = ABS(ROUND(((m.nYearBal1 / lnGrossY1) * 100), 1))
		                              ELSE
		                                 m.nYearPct1 = 0
		                              ENDIF
		                              IF lnGrossC2 # 0
		                                 m.nCurPct2 = ABS(ROUND(((m.nCurBal2 / lnGrossC2) * 100), 1))
		                              ELSE
		                                 m.nCurPct2 = 0
		                              ENDIF
		                              IF lnGrossY2 # 0
		                                 m.nYearPct2 = ABS(ROUND(((m.nYearBal2 / lnGrossY2) * 100), 1))
		                              ELSE
		                                 m.nYearPct2 = 0
		                              ENDIF
		                           ELSE
		                              m.nCurBal  = lnTotal + balance.nCurBal  &&  Have to include the total for this specific account in the total, too
		                              m.nYearBal = lnTotalYr + balance.nYearBal
		                              IF lnGrossC # 0
		                                 m.nCurPct = ABS(ROUND(((m.nCurBal / lnGrossC) * 100), 1))
		                              ELSE
		                                 m.nCurPct = 0
		                              ENDIF
		                              IF lnGrossY # 0
		                                 m.nYearPct = ABS(ROUND(((m.nYearBal / lnGrossY) * 100), 1))
		                              ELSE
		                                 m.nYearPct = 0
		                              ENDIF
		                           ENDIF
		                           lnRecNo2 = RECNO()
		                           SELECT balance
		                           LOCATE FOR lTotalAcct AND cSortField = m.cSortField
		                           IF NOT FOUND()
		                              INSERT INTO balance FROM MEMVAR
		                           ENDIF
		                           GOTO lnRecNo2
		                        ENDIF
		
		                        IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 3 accounts now
		                           SELECT balance
		                           lnCount    = 1
		                           lnTotal    = 0
		                           lnTotal2   = 0
		                           lnTotalYr  = 0
		                           lnTotalYr2 = 0
		                           lcParent   = balance.cParent
		                           IF EMPTY(lcParent)
		                              lnLastLevel = 1
		                              GOTO lnRecNo
		                              LOOP
		                           ENDIF
		                           SCAN FOR cParent = lcParent
		                              lnCount   = lnCount + 1
		                              lnTotal   = lnTotal + IIF(llCompare, nCurBal1, nCurBal)
		                              lnTotalYr = lnTotalYr + IIF(llCompare, nYearBal1, nYearBal)
		                              IF llCompare
		                                 lnTotal2   = lnTotal2 + nCurBal2
		                                 lnTotalYr2 = lnTotalYr2 + IIF(llCompare, nYearBal2, nYearBal)
		                              ENDIF
		                           ENDSCAN
		
		                           IF lnCount > 1
		                              SELECT balance
		                              LOCATE FOR cAcctNo = lcParent
		                              IF FOUND()  &&  Darn well better be...
		                                 m.cAcctDesc  = balance.cAcctDesc
		                                 m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                                 m.nAcctType  = balance.nAcctType
		                                 m.cBalGroup  = balance.cBalGroup
		                                 m.cAcctType  = balance.cAcctType
		                                 m.cAcctNo    = balance.cAcctNo
		                                 m.nLevel     = balance.nLevel
		                                 m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                                 IF llCompare
		                                    m.nCurBal1  = lnTotal + balance.nCurBal1
		                                    m.nCurBal2  = lnTotal2 + balance.nCurBal2
		                                    m.nYearBal1 = lnTotalYr + balance.nYearBal1
		                                    m.nYearBal2 = lnTotalYr2 + balance.nYearBal2
		                                    IF lnGrossC1 # 0
		                                       m.nCurPct1 = ABS(ROUND(((m.nCurBal1 / lnGrossC1) * 100), 1))
		                                    ELSE
		                                       m.nCurPct1 = 0
		                                    ENDIF
		                                    IF lnGrossY1 # 0
		                                       m.nYearPct1 = ABS(ROUND(((m.nYearBal1 / lnGrossY1) * 100), 1))
		                                    ELSE
		                                       m.nYearPct1 = 0
		                                    ENDIF
		                                    IF lnGrossC2 # 0
		                                       m.nCurPct2 = ABS(ROUND(((m.nCurBal2 / lnGrossC2) * 100), 1))
		                                    ELSE
		                                       m.nCurPct2 = 0
		                                    ENDIF
		                                    IF lnGrossY2 # 0
		                                       m.nYearPct2 = ABS(ROUND(((m.nYearBal2 / lnGrossY2) * 100), 1))
		                                    ELSE
		                                       m.nYearPct2 = 0
		                                    ENDIF
		                                 ELSE
		                                    m.nCurBal  = lnTotal + balance.nCurBal  &&  Have to include the total for this specific account in the total, too
		                                    m.nYearBal = lnTotalYr + balance.nYearBal
		                                    IF lnGrossC # 0
		                                       m.nCurPct = ABS(ROUND(((m.nCurBal / lnGrossC) * 100), 1))
		                                    ELSE
		                                       m.nCurPct = 0
		                                    ENDIF
		                                    IF lnGrossY # 0
		                                       m.nYearPct = ABS(ROUND(((m.nYearBal / lnGrossY) * 100), 1))
		                                    ELSE
		                                       m.nYearPct = 0
		                                    ENDIF
		                                 ENDIF
		                                 lnRecNo2 = RECNO()
		                                 SELECT balance
		                                 LOCATE FOR lTotalAcct AND cSortField = m.cSortField
		                                 IF NOT FOUND()
		                                    INSERT INTO balance FROM MEMVAR
		                                 ENDIF
		                                 GOTO lnRecNo2
		                              ENDIF
		
		                              IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 2 accounts now
		                                 SELECT balance
		                                 lnCount    = 1
		                                 lnTotal    = 0
		                                 lnTotal2   = 0
		                                 lnTotalYr  = 0
		                                 lnTotalYr2 = 0
		                                 lcParent   = balance.cParent
		                                 IF EMPTY(lcParent)
		                                    lnLastLevel = 1
		                                    GOTO lnRecNo
		                                    LOOP
		                                 ENDIF
		                                 SCAN FOR cParent = lcParent
		                                    lnCount   = lnCount + 1
		                                    lnTotal   = lnTotal + IIF(llCompare, nCurBal1, nCurBal)
		                                    lnTotalYr = lnTotalYr + IIF(llCompare, nYearBal1, nYearBal)
		                                    IF llCompare
		                                       lnTotal2   = lnTotal2 + nCurBal2
		                                       lnTotalYr2 = lnTotalYr2 + IIF(llCompare, nYearBal2, nYearBal)
		                                    ENDIF
		                                 ENDSCAN
		
		                                 IF lnCount > 1
		                                    SELECT balance
		                                    LOCATE FOR cAcctNo = lcParent
		                                    IF FOUND()  &&  Darn well better be...
		                                       m.cAcctDesc  = balance.cAcctDesc
		                                       m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                                       m.nAcctType  = balance.nAcctType
		                                       m.cBalGroup  = balance.cBalGroup
		                                       m.cAcctType  = balance.cAcctType
		                                       m.cAcctNo    = balance.cAcctNo
		                                       m.nLevel     = balance.nLevel
		                                       m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                                       IF llCompare
		                                          m.nCurBal1  = lnTotal + balance.nCurBal1
		                                          m.nCurBal2  = lnTotal2 + balance.nCurBal2
		                                          m.nYearBal1 = lnTotalYr + balance.nYearBal1
		                                          m.nYearBal2 = lnTotalYr2 + balance.nYearBal2
		                                          IF lnGrossC1 # 0
		                                             m.nCurPct1 = ABS(ROUND(((m.nCurBal1 / lnGrossC1) * 100), 1))
		                                          ELSE
		                                             m.nCurPct1 = 0
		                                          ENDIF
		                                          IF lnGrossY1 # 0
		                                             m.nYearPct1 = ABS(ROUND(((m.nYearBal1 / lnGrossY1) * 100), 1))
		                                          ELSE
		                                             m.nYearPct1 = 0
		                                          ENDIF
		                                          IF lnGrossC2 # 0
		                                             m.nCurPct2 = ABS(ROUND(((m.nCurBal2 / lnGrossC2) * 100), 1))
		                                          ELSE
		                                             m.nCurPct2 = 0
		                                          ENDIF
		                                          IF lnGrossY2 # 0
		                                             m.nYearPct2 = ABS(ROUND(((m.nYearBal2 / lnGrossY2) * 100), 1))
		                                          ELSE
		                                             m.nYearPct2 = 0
		                                          ENDIF
		                                       ELSE
		                                          m.nCurBal  = lnTotal + balance.nCurBal  &&  Have to include the total for this specific account in the total, too
		                                          m.nYearBal = lnTotalYr + balance.nYearBal
		                                          IF lnGrossC # 0
		                                             m.nCurPct = ABS(ROUND(((m.nCurBal / lnGrossC) * 100), 1))
		                                          ELSE
		                                             m.nCurPct = 0
		                                          ENDIF
		                                          IF lnGrossY # 0
		                                             m.nYearPct = ABS(ROUND(((m.nYearBal / lnGrossY) * 100), 1))
		                                          ELSE
		                                             m.nYearPct = 0
		                                          ENDIF
		                                       ENDIF
		                                       lnRecNo2 = RECNO()
		                                       SELECT balance
		                                       LOCATE FOR lTotalAcct AND cSortField = m.cSortField
		                                       IF NOT FOUND()
		                                          INSERT INTO balance FROM MEMVAR
		                                       ENDIF
		                                       GOTO lnRecNo2
		                                    ENDIF
		                                 ENDIF
		                              ENDIF
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		
		         GOTO lnRecNo
		
		         lnLastLevel  = balance.nLevel
		         lcLastAcctNo = balance.cAcctNo
		      ENDSCAN
		   ENDIF
		
		   IF lcLevel # '*'
		      SELECT balance
		      SCAN FOR nLevel > VAL(lcLevel)
		         DELETE
		      ENDSCAN
		   ENDIF
		
		*  Make sure no percentages exceed 9999.99.  Really, that signifies that you've screwed up your account types, so it's meaningless when it's that size anyway.
		   IF llCompare
		      SELECT balance
		      SCAN FOR nCurPct1 > 9999.9 OR nCurPct2 > 9999.9 OR nYearPct1 > 9999.9 OR nYearPct2 > 9999.9
		         IF nCurPct1 > 9999.9
		            REPLACE nCurPct1 WITH 9999.9
		         ENDIF
		         IF nCurPct2 > 9999.9
		            REPLACE nCurPct2 WITH 9999.9
		         ENDIF
		         IF nYearPct1 > 9999.9
		            REPLACE nYearPct1 WITH 9999.9
		         ENDIF
		         IF nYearPct2 > 9999.9
		            REPLACE nYearPct2 WITH 9999.9
		         ENDIF
		      ENDSCAN
		   ELSE
		      SELECT balance
		      SCAN FOR nCurPct > 9999.9 OR nYearPct > 9999.9
		         IF nCurPct > 9999.9
		            REPLACE nCurPct WITH 9999.9
		         ENDIF
		         IF nYearPct > 9999.9
		            REPLACE nYearPct WITH 9999.9
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		   SELECT balance
		   SCAN
		      IF llCompare
		         IF NOT llZero AND nYearBal1 = 0 AND nYearBal2 = 0 AND nCurBal1 = 0 AND nCurBal2 = 0 AND NOT cBalGroup = 'C' AND NOT lTitle AND lcLevel = '*'
		            DELETE NEXT 1
		            LOOP
		         ENDIF
		      ELSE
		         IF NOT llZero AND nYearBal = 0 AND nCurBal = 0 AND NOT cBalGroup = 'C' AND NOT lTitle AND lcLevel = '*'
		            DELETE NEXT 1
		            LOOP
		         ENDIF
		      ENDIF
		
		      IF llPrintNumbers
		         SELECT balance
		         REPLACE cAcctDesc WITH cAcctNo + ' - ' + ALLTRIM(cAcctDesc)
		      ENDIF
		
		   ENDSCAN
		
		   SELECT balance
		   COUNT FOR NOT DELETED() TO lnCount
		   SET ORDER TO AcctNo
		   GO TOP
		
		   WAIT CLEAR
		
		   IF lnCount > 0
		      llReturn = .T.
		   ELSE
		      llReturn = .F.
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildData', loError.LINENO, 'GLIncRpt', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE Init
		
		THISFORM.txtPeriod.VALUE = GetFiscalPeriod(DATE())
		THISFORM.txtYear.VALUE = GetFiscalYear(DATE())
		
		*
		*  Save the current deleted status
		*
		SET DELETED ON
		
		RETURN (DODEFAULT())
		
	ENDPROC

	PROCEDURE loadmonth		&& Loads the month ending array
		LOCAL lnX, lnMonth, lcYear
		
		tcYear = thisform.txtYear.value
		
		*
		*  Load the titles for the financial statements
		*
		thisform.laMonth[1] = 'January 31, ' 
		
		thisform.laMonth[3]  = 'March 31, '     
		thisform.laMonth[4]  = 'April 30, '     
		thisform.laMonth[5]  = 'May 31, '       
		thisform.laMonth[6]  = 'June 30, '      
		thisform.laMonth[7]  = 'July 31, '      
		thisform.laMonth[8]  = 'August 31, '    
		thisform.laMonth[9]  = 'September 30, ' 
		thisform.laMonth[10] = 'October 31, '   
		thisform.laMonth[11] = 'November 30, '  
		thisform.laMonth[12] = 'December 31, '  
		
		*
		*  Get the beginning month of the fiscal year
		*
		swselect('glopt')
		GO TOP
		llFYEnd = lFYEnd
		lnMonth = VAL(glopt.cfybegin)
		lnMonth1 = lnMonth
		IF llFYEnd
		   lcYear = STR(VAL(tcYear)-1,4)
		ELSE
		   lcYear = tcYear
		ENDIF   
		
		*
		*  Load up the monthend array
		*
		FOR lnX = 1 TO 12
		   IF lnMonth1 = 2
		      *
		      *  Check for leap year
		      *
		      IF MOD(VAL(lcYear),4) = 0
		         thisform.laMonth[2] = 'February 29, '
		      ELSE   
		         thisform.laMonth[2] = 'February 28, '
		      ENDIF   
		   ENDIF   
		
		   thisform.laMonthEnd[lnX] = thisform.laMonth[lnMonth1] + ' ' + lcYear
		   IF lnMonth1 = 12
		      lnMonth1 = 1
		      lcYear = STR(VAL(lcYear)+1,4)
		   ELSE
		      lnMonth1 = lnMonth1 + 1
		   ENDIF
		ENDFOR         
		  
		
		
		
		
	ENDPROC

	PROCEDURE report
		LPARAMETERS cbutton
		PRIV lcCompany
		PUBLIC nNetIncY1, nNetIncY2, nNetIncC1, nNetIncC2
		
		IF thisform.chkComparative.value
		   m.nNetIncY1 = thisform.nNetIncY1
		   m.nNetIncC1 = thisform.nNetIncC1
		   m.nNetIncY2 = thisform.nNetIncY2
		   m.nNetIncC2 = thisform.nNetIncC2
		ELSE   
		   m.nNetIncY1 = thisform.nNetIncY
		   m.nNetIncC1 = thisform.nNetIncC
		ENDIF
		
		lcCompany = m.goApp.cCompanyName
		
		DODEFAULT(m.cButton)
	ENDPROC

	PROCEDURE cboAccountType.Init
		THIS.ADDLISTITEM('**  All Account Levels  **',1,1)
		THIS.ADDLISTITEM('*',1,2)
		THIS.ADDLISTITEM('Level 1 Accounts',2,1)
		THIS.ADDLISTITEM('1',2,2)
		THIS.ADDLISTITEM('Level 2 Accounts and Above',3,1)
		THIS.ADDLISTITEM('2',3,2)
		THIS.ADDLISTITEM('Level 3 Accounts and Above',4,1)
		THIS.ADDLISTITEM('3',4,2)
		THIS.ADDLISTITEM('Level 4 Accounts and Above',5,1)
		THIS.ADDLISTITEM('4',5,2)
		
		THIS.LISTITEMID = 1
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE OpgQuarters.Init
		this.q1.value = 1
	ENDPROC

	PROCEDURE OpgQuarters.Q1.GotFocus
		THISFORM.opgQuarters.VALUE = 1
		
	ENDPROC

	PROCEDURE OpgQuarters.Q2.GotFocus
		THISFORM.opgQuarters.VALUE = 2
	ENDPROC

	PROCEDURE OpgQuarters.Q3.GotFocus
		THISFORM.opgQuarters.VALUE = 3
	ENDPROC

	PROCEDURE OpgQuarters.Q4.GotFocus
		THISFORM.opgQuarters.VALUE = 4
	ENDPROC

	PROCEDURE opgreportby.Valid
		
		DODEFAULT()
		
		IF this.value = 1
		   thisform.txtyear.enabled = .t.
		   thisform.txtperiod.enabled = .t.
		   thisform.opgquarters.q1.enabled = .f.
		   thisform.opgquarters.q2.enabled = .f.
		   thisform.opgquarters.q3.enabled = .f.
		   thisform.opgquarters.q4.enabled = .f.
		else
		   thisform.txtyear.enabled = .t.
		   thisform.txtperiod.enabled = .f.
		   thisform.opgquarters.q1.enabled = .t.
		   thisform.opgquarters.q2.enabled = .t.
		   thisform.opgquarters.q3.enabled = .t.
		   thisform.opgquarters.q4.enabled = .t.
		endif      
	ENDPROC

ENDDEFINE
