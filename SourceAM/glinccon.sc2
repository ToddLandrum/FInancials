*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="glinccon.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 200
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 520

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 99, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 363, ;
		Name = "Cursor4", ;
		Top = 9, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glacctyp", ;
		CursorSource = "glacctyp", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 218, ;
		Name = "Cursor5", ;
		Order = "naccttype", ;
		Top = 11, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formglinccon AS frmrptcriteria OF "appforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="chkZeroBal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkComparative" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdChoose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgreportby" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="OpgQuarters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAcctNumbers" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: comparitive
		*m: loadmonth		&& Loads the month ending array
		*m: standard
		*p: nnetincc
		*p: nnetincc1
		*p: nnetincc2
		*p: nnetincy
		*p: nnetincy1
		*p: nnetincy2
		*a: lamonthend[12,0]
		*a: lamonth[12,0]
	*</DefinedPropArrayMethod>

	Caption = "Consolidated Income Statement"
	DataSession = 2
	DoCreate = .T.
	Height = 397
	HelpContextID = 416
	Name = "FormGlincCon"
	nnetincc = 0
	nnetincc1 = 0
	nnetincc2 = 0
	nnetincy = 0
	nnetincy1 = 0
	nnetincy2 = 0
	Visible = .T.
	Width = 479
	_memberdata = <VFPData>
		<memberdata name="standard" display="Standard"/>
		<memberdata name="comparitive" display="Comparitive"/>
		</VFPData>
	Swrptcriteriabuttons1.chkExport.Alignment = 0
	Swrptcriteriabuttons1.chkExport.Name = "chkExport"
	Swrptcriteriabuttons1.cmdclose.Name = "cmdclose"
	Swrptcriteriabuttons1.cmdPreview.Name = "cmdPreview"
	Swrptcriteriabuttons1.cmdPrint.Name = "cmdPrint"
	Swrptcriteriabuttons1.Left = 118
	Swrptcriteriabuttons1.Name = "Swrptcriteriabuttons1"
	Swrptcriteriabuttons1.TabIndex = 13
	Swrptcriteriabuttons1.Top = 313

	ADD OBJECT 'chkAcctNumbers' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print Account Numbers", ;
		Height = 16, ;
		Left = 132, ;
		Name = "chkAcctNumbers", ;
		TabIndex = 10, ;
		Top = 246, ;
		Value = .F., ;
		Width = 129
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkComparative' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print a Comparative Statement", ;
		Height = 16, ;
		Left = 132, ;
		Name = "chkComparative", ;
		TabIndex = 9, ;
		Top = 220, ;
		Value = .F., ;
		Width = 162
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkZeroBal' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Include Accounts with a Zero Balance", ;
		Height = 16, ;
		Left = 132, ;
		Name = "chkZeroBal", ;
		TabIndex = 8, ;
		Top = 194, ;
		Value = .F., ;
		Width = 203
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdChoose' AS cmdcommandbuttoncustom WITH ;
		Caption = "Choose Companies", ;
		Height = 36, ;
		Left = 183, ;
		Name = "cmdChoose", ;
		TabIndex = 7, ;
		Top = 120, ;
		Width = 108
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 384, ;
		Name = "Glmaint", ;
		Top = 324
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Report By", ;
		Left = 79, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 12, ;
		Top = 7
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Quarter", ;
		Left = 60, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 11, ;
		Top = 64
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblPeriod' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Fiscal Period:", ;
		Height = 16, ;
		Left = 247, ;
		Name = "lblPeriod", ;
		TabIndex = 5, ;
		Top = 36, ;
		Width = 66, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblYear' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Fiscal Year:", ;
		Height = 16, ;
		Left = 109, ;
		Name = "lblYear", ;
		TabIndex = 3, ;
		Top = 36, ;
		Width = 60, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'OpgQuarters' AS opgoptiongroupcustom WITH ;
		BorderStyle = 1, ;
		ButtonCount = 4, ;
		Enabled = .T., ;
		Height = 35, ;
		Left = 53, ;
		Name = "OpgQuarters", ;
		TabIndex = 6, ;
		Top = 70, ;
		Width = 373, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "1st (Jan - Mar)", ;
		Option1.Enabled = .F., ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Q1", ;
		Option1.Top = 11, ;
		Option1.Width = 89, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "2nd (Apr - Jun)", ;
		Option2.Enabled = .F., ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 96, ;
		Option2.Name = "Q2", ;
		Option2.Top = 11, ;
		Option2.Width = 92, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "3rd (Jul - Sep)", ;
		Option3.Enabled = .F., ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 192, ;
		Option3.Name = "Q3", ;
		Option3.Top = 11, ;
		Option3.Width = 87, ;
		Option4.AutoSize = .T., ;
		Option4.Caption = "4th (Oct - Dec)", ;
		Option4.Enabled = .F., ;
		Option4.FontSize = 8, ;
		Option4.Height = 16, ;
		Option4.Left = 281, ;
		Option4.Name = "Q4", ;
		Option4.Top = 11, ;
		Option4.Width = 90
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'opgreportby' AS opgoptiongroupcustom WITH ;
		AutoSize = .T., ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		Height = 26, ;
		Left = 139, ;
		Name = "opgreportby", ;
		TabIndex = 1, ;
		Top = 2, ;
		Value = 1, ;
		Width = 194, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Fiscal Period", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 79, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Fiscal Quarter", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 103, ;
		Option2.Name = "Option2", ;
		Option2.Top = 5, ;
		Option2.Width = 86
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtPeriod' AS swperiod WITH ;
		Left = 331, ;
		Name = "txtPeriod", ;
		TabIndex = 4, ;
		Top = 34, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtYear' AS swyear WITH ;
		Left = 187, ;
		Name = "txtYear", ;
		TabIndex = 2, ;
		Top = 34, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE builddata
		*
		*  Builds the income statement cursor (balance) from the
		*  newcoabal table.  Uses the criteria entered on the form.
		*
		
		LOCAL lnCompanies
		LOCAL llReturn, loError
		
		llReturn = .T.
		
		TRY
		*
		*  Load the month array properties
		*
		   llReturn = THISFORM.loadmonth()
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		
		   IF NOT USED('compmast')
		      USE datafiles\compmast IN 0
		   ENDIF
		   SELE cProducer, cDataPath FROM compmast WHERE RIGHT(xflag, 1) = 'C' INTO CURSOR compsel
		
		*  Check to see if any companies were selected.
		   SELECT compsel
		   IF RECC() = 0
		      THISFORM.omessage.Warning('No companies have been selected to be consolidated. Please choose the companies to consolidate.')
		      llReturn = .F.
		      EXIT 
		   ELSE
		      lnCompanies = RECC()
		   ENDIF
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		*
		*  Check to make sure the currently open company is one of the consolidated companies
		*
		   SELE compsel
		   LOCATE FOR ALLT(m.goApp.cCompanyName) $ cProducer
		   IF NOT FOUND()
		      THISFORM.omessage.Warning('The currently open company MUST be one of the consolidated companies.  Please choose this company.')
		      llReturn = .F.
		      EXIT 
		   ENDIF
		
		   * Combine the companies
		   llReturn = thisform.glmaint.CalcConBalance()
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		    
		   IF THISFORM.chkComparative.VALUE
		      llReturn = THISFORM.Comparitive()
		   ELSE
		      llReturn = THISFORM.Standard()
		   ENDIF
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		   
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildData', loError.LINENO, 'Consolidated Income Stmt', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE comparitive
		*
		*  Builds the income statement cursor (balance) from the
		*  newcoabal table.  Uses the criteria entered on the form.
		*
		LOCAL jlines, llfirst, jcYear, jcPeriod, m.cCurEarn, lnCount
		LOCAL lcYear, lcPeriod, llZero, llCompare, latypes[14]
		LOCAL lnGrossProfitOperCur, lnGrossProfitOperYr, lnGrossProfitOperCur1
		LOCAL lnGrossProfitOperYr1, lnGrossProfitOperCur2, lnGrossProfitOperYr2
		LOCAL lnGrossProfitProdLeaseCur, lnGrossProfitProdLeaseYr
		LOCAL lnGrossProfitProdLeaseCur1, lnGrossProfitProdLeaseYr1
		LOCAL lnGrossProfitProdLeaseCur2, lnGrossProfitProdLeaseYr2
		LOCAL lnGrossProfitCur, lnGrossProfitYr
		LOCAL lnIncC, lnIncY, lnExpC, lnExpY
		LOCAL lnGrossProfitCur1, lnGrossProfitYr1, lnGrossProfitCur2, lnGrossProfitYr2
		LOCAL m.nNetIncC, m.nNetIncY, m.nNetIncC1, m.nNetIncY1, m.nNetIncC2, m.nNetIncY2
		LOCAL lnCOGSC, lnCOGSY, lnCOGSC1, lnCOGSC2, lnCOGSY1, lnCOGSY2
		LOCAL lnNetPY, lnNetPC, lnBonusC, lnBonusY
		LOCAL lnIncC1, lnIncY1, lnExpC1, lnExpY1, lnBonusC1, lnBonusY1
		LOCAL lnIncC2, lnIncY2, lnExpC2, lnExpY2, lnBonusC2, lnBonusY2
		LOCAL laCOGS[1], laCurEarn[1], laDepreciation[1], laExpense[1], laExpenses[1], laGrossRev[1]
		LOCAL laIncome[1], lcCurYear, lcDesc, lcPeriod1, lcPeriod2, llReturn, lnBegBal, lnBreak, lnCOGS
		LOCAL lnCurBal, lnDeprC1, lnDeprC2, lnDeprY1, lnDeprY2, lnExpenseC1, lnExpenseC2, lnExpenseY1
		LOCAL lnExpenseY2, lnGrossC1, lnGrossC2, lnGrossY1, lnGrossY2, lnNETPC1, lnNETPC2, lnNETPY1
		LOCAL lnNETPY2, lnQtr, lnReportBy, lnYearBal, loError
		*:Global cAcctDesc, cAcctNo, cAcctType, cBalGroup, cBreak, cCurEarn, cFiscalPrd, cFiscalYr
		*:Global nAcctType, nBegBal, nBegBal1, nBegBal2, nCredits, nCurBal1, nCurBal2, nCurPct1, nCurPct2
		*:Global nDebits, nDebits1, nDebits2, nLevel, nNetIncC, nNetIncC1, nNetIncC2, nNetIncY, nNetIncY1
		*:Global nNetIncY2, nYearBal1, nYearBal2, nYearPct1, nYearPct2
		
		llReturn = .T.
		 
		TRY
		* Initialize variables
		   STORE 0 TO lnNetPC, lnNetPY, lnGrossProfitOperCur, lnGrossProfitOperYr
		   STORE 0 TO lnGrossProfitOperCur1, lnGrossProfitOperYr1, lnGrossProfitOperCur2, lnGrossProfitOperYr2
		   STORE 0 TO lnGrossProfitProdLeaseCur1, lnGrossProfitProdLeaseYr1, lnGrossProfitProdLeaseCur2, lnGrossProfitProdLeaseYr2
		   STORE 0 TO lnGrossProfitProdLeaseCur, lnGrossProfitProdLeaseYr
		   STORE 0 TO lnGrossProfitCur, lnGrossProfitYr, lnGrossProfitCur1, lnGrossProfitYr1, lnGrossProfitCur2, lnGrossProfitYr2
		   STORE 0 TO m.nNetIncC, m.nNetIncY, m.nNetIncC1, m.nNetIncY1, m.nNetIncC2, m.nNetIncY2
		   STORE 0 TO lnCOGSC, lnCOGSY, lnCOGSC1, lnCOGSC2, lnCOGSY1, lnCOGSY2
		   STORE 0 TO lnIncC, lnIncY, lnExpC, lnExpY, lnBonusC, lnBonusY
		   STORE 0 TO lnIncC1, lnIncY1, lnExpC1, lnExpY1, lnBonusC1, lnBonusY1
		   STORE 0 TO lnIncC2, lnIncY2, lnExpC2, lnExpY2, lnBonusC2, lnBonusY2
		
		   m.nLevel = 1
		*
		*  Set the report name based upon the criteria chosen
		*
		   m.nNetIncY1          = THISFORM.nNetIncY1
		   m.nNetIncC1          = THISFORM.nNetIncC1
		   m.nNetIncY2          = THISFORM.nNetIncY2
		   m.nNetIncC2          = THISFORM.nNetIncC2
		
		*
		*  Get the current criteria for the income statement
		*
		   lcYear     = THISFORM.txtYear.VALUE
		   lcPeriod   = THISFORM.txtPeriod.VALUE
		   llZero     = THISFORM.chkZeroBal.VALUE
		   llCompare  = THISFORM.chkComparative.VALUE
		   lnReportBy = THISFORM.opgReportBy.VALUE
		   lnQtr      = THISFORM.opgQuarters.VALUE
		   llPrintNumbers = thisform.chkAcctNumbers.Value 
		
		   DO CASE
		      CASE lnReportBy = 1
		         lcPeriod1 = lcPeriod
		         lcPeriod2 = lcPeriod
		      CASE lnQtr = 1
		         lcPeriod1 = '01'
		         lcPeriod2 = '03'
		      CASE lnQtr = 2
		         lcPeriod1 = '04'
		         lcPeriod2 = '06'
		      CASE lnQtr = 3
		         lcPeriod1 = '07'
		         lcPeriod2 = '09'
		      CASE lnQtr = 4
		         lcPeriod1 = '10'
		         lcPeriod2 = '12'
		   ENDCASE
		   jcYear   = STR(VAL(lcYear) - 1, 4)
		   jcPeriod = lcPeriod
		
		*
		*  Set the report titles, sort & selection criteria
		*
		   IF lnReportBy = 1
		      THISFORM.cReportName = 'source\glinc02'
		   ELSE
		      THISFORM.cReportName = 'source\glincqtrcomp'       
		   ENDIF       
		   
		   THISFORM.cTitle1 = 'Consolidated Income Statement'
		
		   IF lnReportBy = 1
		      THISFORM.cTitle2 = 'For the month ending ' + THISFORM.laMonthEnd[VAL(thisform.txtPeriod.value)]
		   ELSE
		      THISFORM.cTitle2 = 'For the quarter ending ' + THISFORM.laMonthEnd[VAL(lcPeriod2)]
		   ENDIF
		
		*
		*  Get the current earnings account number.
		*
		   SELECT glopt
		   GO TOP
		   m.cCurEarn = cCurEarn
		
		*
		*  Create the balance cursor. (This is what report is printed from)
		*  If a comparative is to be calculated, change the cursor format.
		*
		   CREATE CURSOR balanceb   ;
		      (cAcctNo     C(6),    ;
		        cBalGroup   C(1),    ;
		        cBreak      C(2),    ;
		        nAcctType   N(2),    ;
		        lTitle      L,       ;
		        lTotalAcct  L,       ;
		        cAcctType   C(25),   ;
		        cAcctDesc   C(40),   ;
		        cPeriod1    c(30), ;
		        cPeriod2    c(30), ;
		        cYear1      c(30), ;
		        cYear2      c(30), ;
		        cParent     C(6),  ;
		        nLevel      N(1, 0),  ;
		        nBegBal1    N(12, 2), ;
		        nDebits1    N(12, 2), ;
		        nCredits1   N(12, 2), ;
		        nCurBal1    N(12, 2), ;
		        nCurPct1    N(6, 1),  ;
		        nYearBal1   N(12, 2), ;
		        nYearPct1   N(6, 1),  ;
		        nBegBal2    N(12, 2), ;
		        nDebits2    N(12, 2), ;
		        nCredits2   N(12, 2), ;
		        nCurBal2    N(12, 2), ;
		        nCurPct2    N(6, 1),  ;
		        nYearBal2   N(12, 2), ;
		        nYearPct2   N(6, 1))
		
		   CREATE CURSOR balance   ;
		      (cAcctNo     C(6),    ;
		        cBalGroup   C(1),    ;
		        cBreak      C(2),    ;
		        nAcctType   N(2),    ;
		        lTitle      L,       ;
		        lTotalAcct  L,       ;
		        cParent     C(6),  ;
		        nLevel      N(1, 0),  ;
		        cAcctType   C(25),   ;
		        cPeriod1    c(30), ;
		        cPeriod2    c(30), ;
		        cYear1      c(30), ;
		        cYear2      c(30), ;
		        cAcctDesc   C(40),   ;
		        nBegBal1    N(12, 2), ;
		        nDebits1    N(12, 2), ;
		        nCredits1   N(12, 2), ;
		        nCurBal1    N(12, 2), ;
		        nCurPct1    N(6, 1),  ;
		        nYearBal1   N(12, 2), ;
		        nYearPct1   N(6, 1),  ;
		        nBegBal2    N(12, 2), ;
		        nDebits2    N(12, 2), ;
		        nCredits2   N(12, 2), ;
		        nCurBal2    N(12, 2), ;
		        nCurPct2    N(6, 1),  ;
		        nYearBal2   N(12, 2), ;
		        nYearPct2   N(6, 1),  ;
		        nNetIncC1   N(12, 2), ;
		        nNetIncC2   N(12, 2), ;
		        nNetIncY1   N(12, 2), ;
		        nNetIncY2   N(12, 2))
		
		
		* INDEX ON STR(nAcctType,2)+cAcctNo TAG AcctNo
		   INDEX ON cBalGroup + cAcctNo + cBreak TAG AcctNo
		   INDEX ON cAcctNo TAG Acct
		
		   SELECT balance
		   SCATTER MEMVAR blank 
		   
		    IF lnReportBy = 1
		       m.cPeriod1 = 'This Month'
		       m.cPeriod2 = 'This Month' + CHR(10) + 'Last Year'
		       m.cYear1   = 'Year-to-Date'
		       m.cYear2   = 'Last' + CHR(10) + 'Year-to-Date'
		    ELSE
		       m.cPeriod1 = 'This Quarter'
		       m.cPeriod2 = 'This Quarter' + CHR(10) + 'Last Year'
		       m.cYear1   = 'Year-to-Date'
		       m.cYear2   = 'Last' + CHR(10) + 'Year-to-Date'
		    ENDIF    
		    
		*
		*  Get the periods activity for each account in the range. (current year)
		*
		   SELECT  newcoa.cAcctNo,       ;
				   newcoa.cAcctDesc,     ;
				   newcoa.nAcctType,     ;
				   newcoa.lTitle,        ;
				   newcoa.lTotalAcct,    ;
				   CoaBalNew.cYear AS cFiscalYr,  ;
				   CoaBalNew.cPeriod AS cFiscalPrd, ;
				   SUM(CoaBalNew.nDebits)  AS nDebits1,   ;
				   SUM(CoaBalNew.nCredits) AS nCredits1   ;
			   FROM CoaBalNew ;
			   JOIN newcoa ;
				   ON CoaBalNew.cAcctNo = newcoa.cAcctNo ;
			   WHERE BETWEEN(CoaBalNew.cYear + CoaBalNew.cPeriod, lcYear + lcPeriod1, lcYear + lcPeriod2) ;
				   AND newcoa.nAcctType # 0 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal1 ;
			   ORDER BY 1 ;
			   GROUP BY 1
		
		   SELECT  newcoa.cAcctNo,            ;
				   newcoa.cAcctDesc,          ;
				   newcoa.nAcctType,          ;
				   newcoa.lTitle,             ;
				   newcoa.lTotalAcct,         ;
				   lcYear AS cFiscalYr,    ;
				   lcPeriod AS cFiscalPrd, ;
				   0 AS nDebits1, ;
				   0 AS nCredits1 ;
			   FROM newcoa ;
			   WHERE newcoa.cAcctNo NOT IN (SELECT  cAcctNo ;
												FROM tempbal1) ;
				   AND newcoa.nAcctType # 0 ;
			   INTO CURSOR tempbal2 ;
			   ORDER BY 1 ;
			   GROUP BY 1
		
		   lcCurYear = _TALLY
		
		*
		*  Get the periods activity for each account in the range for last year.
		*
		   SELECT  newcoa.cAcctNo,       ;
				   newcoa.cAcctDesc,     ;
				   newcoa.nAcctType,     ;
				   CoaBalNew.cYear AS cFiscalYr,  ;
				   CoaBalNew.cPeriod AS cFiscalPrd, ;
				   SUM(CoaBalNew.nDebits)  AS nDebits2, ;
				   SUM(CoaBalNew.nCredits) AS nCredits2 ;
			   FROM CoaBalNew ;
			   JOIN newcoa ;
				   ON CoaBalNew.cAcctNo = newcoa.cAcctNo ;
			   WHERE BETWEEN(CoaBalNew.cYear + CoaBalNew.cPeriod, jcYear + lcPeriod1, jcYear + lcPeriod2) ;
				   AND newcoa.nAcctType # 0 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal3 ;
			   ORDER BY 1 ;
			   GROUP BY 1
		
		   SELECT  newcoa.cAcctNo,            ;
				   newcoa.cAcctDesc,          ;
				   newcoa.nAcctType,     ;
				   lcYear AS cFiscalYr,    ;
				   lcPeriod AS cFiscalPrd, ;
				   0 AS nDebits2, ;
				   0 AS nCredits2 ;
			   FROM CoaBalNew, newcoa ;
			   WHERE newcoa.cAcctNo NOT IN (SELECT  cAcctNo ;
												FROM tempbal3) ;
				   AND newcoa.nAcctType # 0 ;
			   INTO CURSOR tempbal4 ;
			   ORDER BY 1 ;
			   GROUP BY 1
		
		*
		*  Append the records to the balance table
		*
		   SELECT balance
		   APPEND FROM DBF('tempbal1')
		   APPEND FROM DBF('tempbal2')
		   SET ORDER TO AcctNo
		   USE IN tempbal1
		   USE IN tempbal2
		
		
		REPLACE cperiod1 WITH m.cPeriod1, ;
		                cperiod2 WITH m.cPeriod2, ;
		                cYear1   WITH m.cYear1, ;
		                cYear2   WITH m.cYear2 ALL 
		
		
		*
		*  Add in last year's balances.
		*
		   SELECT tempbal3
		   SCAN
		      SCATTER MEMVAR
		      SELECT balance
		      LOCATE FOR cAcctNo = m.cAcctNo
		      IF FOUND()
		         REPLACE nDebits2  WITH m.nDebits2, ;
		            nCredits2 WITH m.nCredits2
		      ELSE
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		
		*
		*  Get the beginning balances for each account in the range (current year)
		*
		   SELECT  CoaBalNew.cAcctNo, ;
				   SUM(nDebits) AS nDebits1, ;
				   SUM(nCredits) AS nCredits1 ;
			   FROM CoaBalNew ;
			   WHERE CoaBalNew.cYear  = lcYear ;
				   AND CoaBalNew.cPeriod < lcPeriod1 ;
			   INTO CURSOR tempbeg ;
			   ORDER BY CoaBalNew.cAcctNo ;
			   GROUP BY CoaBalNew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		   IF _TALLY > 0
		      SELECT tempbeg
		      SCAN
		         SCATTER MEMVAR
		         SELECT balance
		         LOCATE FOR cAcctNo = m.cAcctNo
		         IF FOUND()
		            IF nAcctType = 8 OR nAcctType = 13
		               lnBegBal  = m.nCredits1 - m.nDebits1
		               lnYearBal = lnBegBal + (nCredits1 - nDebits1)
		               lnCurBal  = nCredits1 - nDebits1
		            ELSE
		               lnBegBal  = m.nDebits1 - m.nCredits1
		               lnYearBal = lnBegBal + (nDebits1 - nCredits1)
		               lnCurBal  = nDebits1 - nCredits1
		            ENDIF
		            REPLACE nBegBal1  WITH lnBegBal, ;
		               nCurBal1  WITH lnCurBal, ;
		               nYearBal1 WITH lnYearBal
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Get the beginning balances for each account in the range (last year)
		*
		   SELECT  CoaBalNew.cAcctNo, ;
				   SUM(nDebits) AS nDebits2, ;
				   SUM(nCredits) AS nCredits2 ;
			   FROM CoaBalNew ;
			   WHERE CoaBalNew.cYear = jcYear ;
				   AND CoaBalNew.cPeriod < lcPeriod1 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbeg ;
			   ORDER BY CoaBalNew.cAcctNo ;
			   GROUP BY CoaBalNew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		   IF _TALLY > 0
		      SELECT tempbeg
		      SCAN
		         SCATTER MEMVAR
		         SELECT balance
		         LOCATE FOR cAcctNo = m.cAcctNo
		         IF FOUND()
		            IF nAcctType = 8 OR nAcctType = 13
		               lnBegBal  = m.nCredits2 - m.nDebits2
		               lnYearBal = lnBegBal + (nCredits2 - nDebits2)
		               lnCurBal  = nCredits2 - nDebits2
		            ELSE
		               lnBegBal  = m.nDebits2 - m.nCredits2
		               lnYearBal = lnBegBal + (nDebits2 - nCredits2)
		               lnCurBal  = nDebits2 - nCredits2
		            ENDIF
		            REPLACE nBegBal2  WITH lnBegBal, ;
		               nCurBal2  WITH lnCurBal, ;
		               nYearBal2 WITH lnYearBal
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Plug in the ending balances
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      IF EMPTY(nBegBal1)
		         IF nAcctType = 8 OR nAcctType = 13
		            REPLACE nYearBal1 WITH nCredits1 - nDebits1, ;
		               nCurBal1  WITH nCredits1 - nDebits1, ;
		               nBegBal1  WITH 0
		         ELSE
		            REPLACE nYearBal1 WITH nDebits1 - nCredits1, ;
		               nCurBal1  WITH nDebits1 - nCredits1, ;
		               nBegBal1  WITH 0
		         ENDIF
		      ENDIF
		      IF EMPTY(nBegBal2)
		         IF nAcctType = 8 OR nAcctType = 13
		            REPLACE nYearBal2 WITH nCredits2 - nDebits2, ;
		               nCurBal2  WITH nCredits2 - nDebits2, ;
		               nBegBal2  WITH 0
		         ELSE
		            REPLACE nYearBal2 WITH nDebits2 - nCredits2, ;
		               nCurBal2  WITH nDebits2 - nCredits2, ;
		               nBegBal2  WITH 0
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		*
		*  Calculate the Gross Revenue
		*
		   SELECT  SUM(nCurBal1), SUM(nYearBal1), ;
				   SUM(nCurBal2), SUM(nYearBal2) ;
			   FROM balance ;
			   WHERE nAcctType = 8 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laGrossRev
		
		   IF _TALLY > 0
		      lnGrossC1 = laGrossRev[1, 1]
		      lnGrossY1 = laGrossRev[1, 2]
		      lnGrossC2 = laGrossRev[1, 3]
		      lnGrossY2 = laGrossRev[1, 4]
		      SELECT balance
		      SCAN FOR BETWEEN(nAcctType, 8, 16)
		         IF lnGrossC1 <> 0
		            REPLACE nCurPct1 WITH ABS(ROUND(((nCurBal1 / lnGrossC1) * 100), 1))
		         ENDIF
		         IF lnGrossY1 <> 0
		            REPLACE nYearPct1 WITH ABS(ROUND(((nYearBal1 / lnGrossY1) * 100), 1))
		         ENDIF
		         IF lnGrossC2 <> 0
		            REPLACE nCurPct2 WITH ABS(ROUND(((nCurBal2 / lnGrossC2) * 100), 1))
		         ENDIF
		         IF lnGrossY2 <> 0
		            REPLACE nYearPct2 WITH ABS(ROUND(((nYearBal2 / lnGrossY2) * 100), 1))
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Calculate the Cost of Goods Sold
		*
		   SELECT  SUM(nCurBal1), SUM(nYearBal1), ;
				   SUM(nCurBal2), SUM(nYearBal2)  ;
			   FROM balance ;
			   WHERE nAcctType = 9 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laCOGS
		
		   IF _TALLY > 0
		      lnCOGSC1 = laCOGS[1, 1]
		      lnCOGSY1 = laCOGS[1, 2]
		      lnCOGSC2 = laCOGS[1, 3]
		      lnCOGSY2 = laCOGS[1, 4]
		   ELSE
		      STORE 0 TO lnCOGSC1, lnCOGSY1, lnCOGSC2, lnCOGSY2
		   ENDIF
		
		*
		*  Calculate the Gross Profit
		*
		   lnGrossProfitCur1 = lnGrossC1 - lnCOGSC1
		   lnGrossProfitYr1  = lnGrossY1 - lnCOGSY1
		   lnGrossProfitCur2 = lnGrossC2 - lnCOGSC2
		   lnGrossProfitYr2  = lnGrossY2 - lnCOGSY2
		
		*
		*  Insert gross profit line in balance table
		*
		   m.nYearBal1 = lnGrossProfitYr1
		   m.nCurBal1  = lnGrossProfitCur1
		   m.nYearBal2 = lnGrossProfitYr2
		   m.nCurBal2  = lnGrossProfitCur2
		   m.cAcctDesc = 'Gross Profit'
		   m.cAcctNo   = ' '
		   m.cBalGroup = 'C'
		   m.cAcctType = 'Gross Profit'
		   STORE 0 TO m.nBegBal1, m.nBegBal2, m.nDebits1, m.nDebits2, m.nAcctType
		   IF lnGrossC1 <> 0
		      m.nCurPct1 = ABS(ROUND(((m.nCurBal1 / lnGrossC1) * 100), 1))
		   ELSE
		      m.nCurPct1 = 0
		   ENDIF
		   IF lnGrossY1 <> 0
		      m.nYearPct1 = ABS(ROUND(((m.nYearBal1 / lnGrossY1) * 100), 1))
		   ELSE
		      m.nYearPct1 = 0
		   ENDIF
		   IF lnGrossC2 <> 0
		      m.nCurPct2 = ABS(ROUND(((m.nCurBal2 / lnGrossC2) * 100), 1))
		   ELSE
		      m.nCurPct2 = 0
		   ENDIF
		   IF lnGrossY2 <> 0
		      m.nYearPct2 = ABS(ROUND(((m.nYearBal2 / lnGrossY2) * 100), 1))
		   ELSE
		      m.nYearPct2 = 0
		   ENDIF
		
		*
		*  Only show a gross profit here if there is at lease
		*  one cost of goods sold account defined.
		*
		   SELE cAcctNo FROM newcoa INTO ARRAY laCOGS WHERE nAcctType = 9
		   lnCOGS = _TALLY
		   IF lnCOGS > 0
		      INSERT INTO balance FROM MEMVAR
		   ENDIF
		
		*
		*  Calculate the gross profit from operations
		*
		   SELECT  SUM(nCurBal1), SUM(nYearBal1), ;
				   SUM(nCurBal2), SUM(nYearBal2) ;
			   FROM balance ;
			   WHERE BETWEEN(nAcctType, 10, 11) ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laExpenses
		
		   IF _TALLY > 0
		      lnExpenseC1 = laExpenses[1, 1]
		      lnExpenseY1 = laExpenses[1, 2]
		      lnExpenseC2 = laExpenses[1, 3]
		      lnExpenseY2 = laExpenses[1, 4]
		   ELSE
		      STORE 0 TO lnExpenseC1, lnExpenseY1, lnExpenseC2, lnExpenseY2
		   ENDIF
		
		   lnGrossProfitOperCur1 = lnGrossProfitCur1 - lnExpenseC1
		   lnGrossProfitOperYr1  = lnGrossProfitYr1 - lnExpenseY1
		   lnGrossProfitOperCur2 = lnGrossProfitCur2 - lnExpenseC2
		   lnGrossProfitOperYr2  = lnGrossProfitYr2 - lnExpenseY2
		
		*
		*  Insert gross profit line in balance table
		*
		   m.nYearBal1  = lnGrossProfitOperYr1
		   m.nCurBal1   = lnGrossProfitOperCur1
		   m.nYearBal2  = lnGrossProfitOperYr2
		   m.nCurBal2   = lnGrossProfitOperCur2
		   m.cAcctDesc  = 'Gross Profit From Operations'
		   m.cAcctNo    = ' '
		   m.cBalGroup  = 'F'
		   m.cAcctType  = 'Gross Profit'
		   m.nAcctType  = 0
		   m.cFiscalYr  = lcYear
		   m.cFiscalPrd = lcPeriod
		   m.nBegBal    = 0
		   m.nDebits    = 0
		   m.nCredits   = 0
		
		   INSERT INTO balance FROM MEMVAR
		
		*
		*  Calculate the gross profit from producing leases
		*
		   SELECT  SUM(nCurBal1), SUM(nYearBal1), ;
				   SUM(nCurBal2), SUM(nYearBal2) ;
			   FROM balance ;
			   WHERE nAcctType = 12 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laDepreciation
		
		   IF _TALLY > 0
		      lnDeprC1 = laDepreciation[1, 1]
		      lnDeprY1 = laDepreciation[1, 2]
		      lnDeprC2 = laDepreciation[1, 3]
		      lnDeprY2 = laDepreciation[1, 4]
		   ELSE
		      STORE 0 TO lnDeprC1, lnDeprY1, lnDeprC2, lnDeprY2
		   ENDIF
		
		   lnGrossProfitProdLeaseCur1 = lnGrossProfitOperCur1 - lnDeprC1
		   lnGrossProfitProdLeaseYr1  = lnGrossProfitOperYr1 - lnDeprY1
		   lnGrossProfitProdLeaseCur2 = lnGrossProfitOperCur2 - lnDeprC2
		   lnGrossProfitProdLeaseYr2  = lnGrossProfitOperYr2 - lnDeprY2
		
		*
		*  Insert gross profit line in balance table
		*
		   m.nYearBal1  = lnGrossProfitProdLeaseYr1
		   m.nCurBal1   = lnGrossProfitProdLeaseCur1
		   m.nYearBal2  = lnGrossProfitProdLeaseYr2
		   m.nCurBal2   = lnGrossProfitProdLeaseCur2
		   m.cAcctDesc  = 'Gross Profit From Producing Leases'
		   m.cAcctNo    = ' '
		   m.cBalGroup  = 'H'
		   m.cAcctType  = 'Gross Profit'
		   m.nAcctType  = 0
		   m.cFiscalYr  = lcYear
		   m.cFiscalPrd = lcPeriod
		   m.nBegBal    = 0
		   m.nDebits    = 0
		   m.nCredits   = 0
		
		   INSERT INTO balance FROM MEMVAR
		
		*
		*  Calculate the net income before pension & bonus
		*
		   SELECT  SUM(nCurBal1), SUM(nYearBal1), ;
				   SUM(nCurBal2), SUM(nYearBal2) ;
			   FROM balance ;
			   WHERE nAcctType = 13  ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laIncome
		
		   IF _TALLY > 0
		      lnIncC1 = laIncome[1, 1]
		      lnIncY1 = laIncome[1, 2]
		      lnIncC2 = laIncome[1, 3]
		      lnIncY2 = laIncome[1, 4]
		   ELSE
		      STORE 0 TO lnIncC1, lnIncY1, lnIncC2, lnIncY2
		   ENDIF
		
		   SELECT  SUM(nCurBal1), SUM(nYearBal1), ;
				   SUM(nCurBal2), SUM(nYearBal2) ;
			   FROM balance ;
			   WHERE nAcctType = 14 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laExpense
		
		   IF _TALLY > 0
		      lnExpC1 = laExpense[1, 1]
		      lnExpY1 = laExpense[1, 2]
		      lnExpC2 = laExpense[1, 3]
		      lnExpY2 = laExpense[1, 4]
		   ELSE
		      STORE 0 TO lnExpC1, lnExpY1, lnExpC2, lnExpY2
		   ENDIF
		
		   lnNETPC1 = lnGrossProfitProdLeaseCur1 + lnIncC1 - lnExpC1
		   lnNETPY1 = lnGrossProfitProdLeaseYr1 + lnIncY1 - lnExpY1
		   lnNETPC2 = lnGrossProfitProdLeaseCur2 + lnIncC2 - lnExpC2
		   lnNETPY2 = lnGrossProfitProdLeaseYr2 + lnIncY2 - lnExpY2
		
		*
		*  Insert gross profit line in balance table
		*
		   m.nYearBal1  = lnNETPY1
		   m.nCurBal1   = lnNETPC1
		   m.nYearBal2  = lnNETPY2
		   m.nCurBal2   = lnNETPC2
		   m.cAcctDesc  = 'Net Income Before Pension & Bonus'
		   m.cAcctNo    = ' '
		   m.cBalGroup  = 'K'
		   m.cAcctType  = 'Net Income'
		   m.nAcctType  = 0
		   m.cFiscalYr  = lcYear
		   m.cFiscalPrd = lcPeriod
		   m.nBegBal    = 0
		   m.nDebits    = 0
		   m.nCredits   = 0
		   INSERT INTO balance FROM MEMVAR
		
		*
		*  Calculate the net income before taxes
		*
		   SELECT  SUM(nCurBal1), SUM(nYearBal1), ;
				   SUM(nCurBal2), SUM(nYearBal2) ;
			   FROM balance ;
			   WHERE nAcctType = 16  ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laIncome
		
		   IF _TALLY > 0
		      lnBonusC1 = laIncome[1, 1]
		      lnBonusY1 = laIncome[1, 2]
		      lnBonusC2 = laIncome[1, 3]
		      lnBonusY2 = laIncome[1, 4]
		   ELSE
		      STORE 0 TO lnBonusC1, lnBonusY1, lnBonusC2, lnBonusY2
		   ENDIF
		
		
		   lnNETPC1 = lnNETPC1  - lnBonusC1
		   lnNETPY1 = lnNETPY1  - lnBonusY1
		   lnNETPC2 = lnNETPC2  - lnBonusC2
		   lnNETPY2 = lnNETPY2  - lnBonusY2
		
		*
		*  Insert gross profit line in balance table
		*
		   m.nYearBal1  = lnNETPY1
		   m.nCurBal1   = lnNETPC1
		   m.nYearBal2  = lnNETPY2
		   m.nCurBal2   = lnNETPC2
		   m.cAcctDesc  = 'Net Income Before Taxes'
		   m.cAcctNo    = ' '
		   m.cBalGroup  = 'M'
		   m.cAcctType  = 'Net Income'
		   m.nAcctType  = 0
		   m.cFiscalYr  = lcYear
		   m.cFiscalPrd = lcPeriod
		   m.nBegBal    = 0
		   m.nDebits    = 0
		   m.nCredits   = 0
		   INSERT INTO balance FROM MEMVAR
		
		*
		*  Calculate the Current Earnings
		*
		
		   SELECT  SUM(nCurBal1), SUM(nYearBal1), ;
				   SUM(nCurBal2), SUM(nYearBal2) ;
			   FROM balance ;
			   WHERE nAcctType = 15 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laCurEarn
		
		   IF _TALLY > 0
		      THISFORM.nNetIncC1 = lnNETPC1 - laCurEarn[1, 1]
		      THISFORM.nNetIncY1 = lnNETPY1 - laCurEarn[1, 2]
		      THISFORM.nNetIncC2 = lnNETPC2 - laCurEarn[1, 3]
		      THISFORM.nNetIncY2 = lnNETPY2 - laCurEarn[1, 4]
		   ELSE
		      THISFORM.nNetIncC1 = lnNETPC1
		      THISFORM.nNetIncY1 = lnNETPY1
		      THISFORM.nNetIncC2 = lnNETPC2
		      THISFORM.nNetIncY2 = lnNETPY2
		   ENDIF
		
		*
		*  Calculate the Current Earnings
		*
		
		*
		*  Plug in breaks after totals
		*
		   lnBreak = 1
		   SELE balance
		   SCAN FOR EMPTY(cBreak)
		      SCATTER MEMVAR
		      IF lTotalAcct
		         m.cBreak = PADL(ALLT(STR(lnBreak)), 2, '0')
		         INSERT INTO balanceb FROM MEMVAR
		         lnBreak = lnBreak + 1
		      ENDIF
		   ENDSCAN
		
		   SELE balance
		   APPEND FROM DBF('balanceb')
		
		*
		*  Plug in the account types
		*
		   SELECT balance
		   SCAN
		      m.nAcctType = nAcctType
		      IF m.nAcctType <> 0
		         SELECT glacctyp
		         LOCATE FOR nAcctType = m.nAcctType
		         IF FOUND()
		            lcDesc = glacctyp.ctypedesc
		            SELECT balance
		            REPLACE cAcctType WITH lcDesc
		         ELSE
		            SELECT balance
		            REPLACE cAcctType WITH 'Unknown'
		         ENDIF
		      ELSE
		         LOOP
		      ENDIF
		      DO CASE
		         CASE m.nAcctType = 8
		            REPLACE cBalGroup WITH 'A'
		         CASE m.nAcctType = 9
		            REPLACE cBalGroup WITH 'B'
		         CASE m.nAcctType = 10
		            REPLACE cBalGroup WITH 'D'
		         CASE m.nAcctType = 11
		            REPLACE cBalGroup WITH 'E'
		         CASE m.nAcctType = 12
		            REPLACE cBalGroup WITH 'G'
		         CASE m.nAcctType = 13
		            REPLACE cBalGroup WITH 'I'
		         CASE m.nAcctType = 14
		            REPLACE cBalGroup WITH 'J'
		         CASE m.nAcctType = 16
		            REPLACE cBalGroup WITH 'L'
		         CASE m.nAcctType = 15
		            REPLACE cBalGroup WITH 'N'
		         OTHERWISE
		            DELETE NEXT 1
		            LOOP
		      ENDCASE
		      IF NOT llZero AND nYearBal1 = 0 AND nYearBal2 = 0 AND nCurBal1 = 0 AND nCurBal2 = 0 AND NOT cBalGroup = 'C' AND NOT lTitle
		         DELETE NEXT 1
		         LOOP
		      ENDIF
		      
		      IF llPrintNumbers
		         SELECT balance
		         REPLACE cacctdesc WITH cacctno + ' - ' + ALLTRIM(cacctdesc)
		      ENDIF 
		   ENDSCAN
		
		
		   SELECT balance
		   REPLACE nNetIncC1 WITH THISFORM.nNetIncC1, ;
		      nNetIncC2 WITH THISFORM.nNetIncC2, ;
		      nNetIncY1 WITH THISFORM.nNetIncY1, ;
		      nNetIncY2 WITH THISFORM.nNetIncY2,  ;
		      nLevel WITH 1 ALL
		
		   SELECT balance
		   COUNT FOR NOT DELETED() TO lnCount
		   SET ORDER TO AcctNo
		   GO TOP
		
		   IF lnCount > 0
		      llReturn = .T.
		   ELSE
		      llReturn = .F.
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Comparitive', loError.LINENO, 'Consolidated Income Stmt', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE Init
		
		THISFORM.txtPeriod.VALUE = GetFiscalPeriod(DATE())
		THISFORM.txtYear.VALUE = GetFiscalYear(DATE())
		*
		*  Save the current deleted status
		*
		SET DELETED ON
		
		RETURN (DODEFAULT())
		
	ENDPROC

	PROCEDURE loadmonth		&& Loads the month ending array
		LOCAL lnX, lnMonth, lcYear
		LOCAL llFYEnd, llReturn, lnMonth1, loError
		*:Global tcYear
		
		llReturn = .T.
		
		TRY
		   tcYear = THISFORM.txtYear.VALUE
		
		*
		*  Load the titles for the financial statements
		*
		   THISFORM.laMonth[1] = 'January 31, '
		
		   THISFORM.laMonth[3]  = 'March 31, '
		   THISFORM.laMonth[4]  = 'April 30, '
		   THISFORM.laMonth[5]  = 'May 31, '
		   THISFORM.laMonth[6]  = 'June 30, '
		   THISFORM.laMonth[7]  = 'July 31, '
		   THISFORM.laMonth[8]  = 'August 31, '
		   THISFORM.laMonth[9]  = 'September 30, '
		   THISFORM.laMonth[10] = 'October 31, '
		   THISFORM.laMonth[11] = 'November 30, '
		   THISFORM.laMonth[12] = 'December 31, '
		
		*
		*  Get the beginning month of the fiscal year
		*
		   SELECT glopt
		   GO TOP
		   llFYEnd  = lFYEnd
		   lnMonth  = VAL(glopt.cfybegin)
		   lnMonth1 = lnMonth
		   IF llFYEnd
		      lcYear = STR(VAL(tcYear) - 1, 4)
		   ELSE
		      lcYear = tcYear
		   ENDIF
		
		*
		*  Load up the monthend array
		*
		   FOR lnX = 1 TO 12
		      IF lnMonth1 = 2
		*
		*  Check for leap year
		*
		         IF MOD(VAL(lcYear), 4) = 0
		            THISFORM.laMonth[2] = 'February 29, '
		         ELSE
		            THISFORM.laMonth[2] = 'February 28, '
		         ENDIF
		      ENDIF
		
		      THISFORM.laMonthEnd[lnX] = THISFORM.laMonth[lnMonth1] + ' ' + lcYear
		      IF lnMonth1 = 12
		         lnMonth1 = 1
		         lcYear   = STR(VAL(lcYear) + 1, 4)
		      ELSE
		         lnMonth1 = lnMonth1 + 1
		      ENDIF
		   ENDFOR
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'LoadMonth', loError.LINENO, 'Consolidated Income Stmt', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
	ENDPROC

	PROCEDURE report
		LPARAMETERS cbutton
		PRIV lcCompany
		
		IF thisform.chkComparative.value
		   m.nNetIncY1 = thisform.nNetIncY1
		   m.nNetIncC1 = thisform.nNetIncC1
		   m.nNetIncY2 = thisform.nNetIncY2
		   m.nNetIncC2 = thisform.nNetIncC2
		ELSE   
		   m.nNetIncY = thisform.nNetIncY
		   m.nNetIncC = thisform.nNetIncC
		ENDIF
		
		lcCompany = ''
		
		SELE compsel
		SCAN
		   IF NOT EMPTY(lcCompany)
		      lcCompany = ALLT(lcCompany) + '/'+ ALLT(cProducer)
		   ELSE
		      lcCompany = ALLT(cProducer)
		   ENDIF   
		ENDSCAN
		
		SELE balance
		
		DODEFAULT(m.cButton)
		
		
	ENDPROC

	PROCEDURE standard
		*
		*  Builds the income statement cursor (balance) from the
		*  newcoabal table.  Uses the criteria entered on the form.
		*
		LOCAL jlines, llfirst, jcYear, jcPeriod, m.cCurEarn, lnCount
		LOCAL lcYear, lcPeriod, llZero, llCompare, latypes[14]
		LOCAL lnGrossProfitOperCur, lnGrossProfitOperYr, lnGrossProfitOperCur1
		LOCAL lnGrossProfitOperYr1, lnGrossProfitOperCur2, lnGrossProfitOperYr2
		LOCAL lnGrossProfitProdLeaseCur, lnGrossProfitProdLeaseYr
		LOCAL lnGrossProfitProdLeaseCur1, lnGrossProfitProdLeaseYr1
		LOCAL lnGrossProfitProdLeaseCur2, lnGrossProfitProdLeaseYr2
		LOCAL lnGrossProfitCur, lnGrossProfitYr
		LOCAL lnIncC, lnIncY, lnExpC, lnExpY
		LOCAL lnGrossProfitCur1, lnGrossProfitYr1, lnGrossProfitCur2, lnGrossProfitYr2
		LOCAL m.nNetIncC, m.nNetIncY, m.nNetIncC1, m.nNetIncY1, m.nNetIncC2, m.nNetIncY2
		LOCAL lnCOGSC, lnCOGSY, lnCOGSC1, lnCOGSC2, lnCOGSY1, lnCOGSY2
		LOCAL lnNetPY, lnNetPC, lnBonusC, lnBonusY
		LOCAL lnIncC1, lnIncY1, lnExpC1, lnExpY1, lnBonusC1, lnBonusY1
		LOCAL lnIncC2, lnIncY2, lnExpC2, lnExpY2, lnBonusC2, lnBonusY2
		LOCAL laCOGS[1], laCurEarn[1], laDepreciation[1], laExpense[1], laExpenses[1], laGrossRev[1]
		LOCAL laIncome[1], lcDesc, lcPeriod1, lcPeriod2, llReturn, lnBegBal, lnBreak, lnCOGS, lnCurBal
		LOCAL lnDeprC, lnDeprY, lnExpenseC, lnExpenseY, lnGrossC, lnGrossY, lnQtr, lnReportBy, lnYearBal
		LOCAL loError
		*:Global cAcctDesc, cAcctNo, cAcctType, cBalGroup, cBreak, cCurEarn, cFiscalPrd, cFiscalYr
		*:Global nAcctType, nBegBal, nCredits, nCurBal, nCurPct, nDebits, nLevel, nNetIncC, nNetIncC1
		*:Global nNetIncC2, nNetIncY, nNetIncY1, nNetIncY2, nYearBal, nYearPct
		
		llReturn = .T.
		
		TRY
		* Initialize variables
		   STORE 0 TO lnNetPC, lnNetPY, lnGrossProfitOperCur, lnGrossProfitOperYr
		   STORE 0 TO lnGrossProfitOperCur1, lnGrossProfitOperYr1, lnGrossProfitOperCur2, lnGrossProfitOperYr2
		   STORE 0 TO lnGrossProfitProdLeaseCur1, lnGrossProfitProdLeaseYr1, lnGrossProfitProdLeaseCur2, lnGrossProfitProdLeaseYr2
		   STORE 0 TO lnGrossProfitProdLeaseCur, lnGrossProfitProdLeaseYr
		   STORE 0 TO lnGrossProfitCur, lnGrossProfitYr, lnGrossProfitCur1, lnGrossProfitYr1, lnGrossProfitCur2, lnGrossProfitYr2
		   STORE 0 TO m.nNetIncC, m.nNetIncY, m.nNetIncC1, m.nNetIncY1, m.nNetIncC2, m.nNetIncY2
		   STORE 0 TO lnCOGSC, lnCOGSY, lnCOGSC1, lnCOGSC2, lnCOGSY1, lnCOGSY2
		   STORE 0 TO lnIncC, lnIncY, lnExpC, lnExpY, lnBonusC, lnBonusY
		   STORE 0 TO lnIncC1, lnIncY1, lnExpC1, lnExpY1, lnBonusC1, lnBonusY1
		   STORE 0 TO lnIncC2, lnIncY2, lnExpC2, lnExpY2, lnBonusC2, lnBonusY2
		
		   m.nLevel = 1
		
		* Set the report format
		   m.nNetIncY           = THISFORM.nNetIncY
		   m.nNetIncC           = THISFORM.nNetIncC
		
		
		*
		*  Get the current criteria for the income statement
		*
		   lcYear     = THISFORM.txtYear.VALUE
		   lcPeriod   = THISFORM.txtPeriod.VALUE
		   llZero     = THISFORM.chkZeroBal.VALUE
		   llCompare  = THISFORM.chkComparative.VALUE
		   lnReportBy = THISFORM.opgReportBy.VALUE
		   lnQtr      = THISFORM.opgQuarters.VALUE
		   llPrintNumbers = thisform.chkAcctNumbers.Value 
		
		
		   DO CASE
		      CASE lnReportBy = 1
		         lcPeriod1 = lcPeriod
		         lcPeriod2 = lcPeriod
		      CASE lnQtr = 1
		         lcPeriod1 = '01'
		         lcPeriod2 = '03'
		      CASE lnQtr = 2
		         lcPeriod1 = '04'
		         lcPeriod2 = '06'
		      CASE lnQtr = 3
		         lcPeriod1 = '07'
		         lcPeriod2 = '09'
		      CASE lnQtr = 4
		         lcPeriod1 = '10'
		         lcPeriod2 = '12'
		   ENDCASE
		   jcYear   = STR(VAL(lcYear) - 1, 4)
		   jcPeriod = lcPeriod
		
		*
		*  Set the report titles, sort & selection criteria
		*
		   IF lnReportBy = 1
		      THISFORM.cReportName = 'source\glinc01'
		   ELSE
		      THISFORM.cReportName = 'source\glincqtr'       
		   ENDIF       
		   
		   THISFORM.cTitle1 = 'Consolidated Income Statement'
		
		   IF lnReportBy = 1
		      THISFORM.cTitle2 = 'For the month ending ' + THISFORM.laMonthEnd[VAL(thisform.txtPeriod.value)]
		   ELSE
		      THISFORM.cTitle2 = 'For the quarter ending ' + THISFORM.laMonthEnd[VAL(lcPeriod2)]
		   ENDIF
		
		*
		*  Recalculate account balances
		*
		   WAIT WIND NOWAIT 'Calculating Account Balances...'
		   THISFORM.glmaint.calcconbalance(.T.)
		   WAIT CLEAR
		
		*
		*  Get the current earnings account number.
		*
		   SELECT glopt
		   GO TOP
		   m.cCurEarn = cCurEarn
		
		*
		*  Create the balance cursor. (This is what report is printed from)
		*
		   CREATE CURSOR balanceb   ;
		      (cAcctNo      C(6),    ;
		        cBalGroup    C(1),    ;
		        cBreak       C(2),    ;
		        nAcctType    N(2),    ;
		        lTitle       L,       ;
		        lTotalAcct   L,       ;
		        cPeriod1     c(30), ;
		        cPeriod2     c(30), ;
		        cYear1       c(30), ;
		        cYear2       c(30), ;
		        cParent     C(6),  ;
		        nLevel      N(1, 0),  ;
		        cAcctType    C(25),   ;
		        cAcctDesc    C(40),   ;
		        cFiscalYr    C(4),    ;
		        cFiscalPrd   C(2),    ;
		        nBegBal      N(12, 2), ;
		        nDebits      N(12, 2), ;
		        nCredits     N(12, 2), ;
		        nCurBal      N(12, 2), ;
		        nCurPct      N(6, 1),  ;
		        nYearBal     N(12, 2), ;
		        nYearPct     N(6, 1))
		
		   CREATE CURSOR balance   ;
		      (cAcctNo      C(6),    ;
		        cBalGroup    C(1),    ;
		        cBreak       C(2),    ;
		        nAcctType    N(2),    ;
		        lTitle       L,       ;
		        lTotalAcct   L,       ;
		        cParent     C(6),  ;
		        nLevel      N(1, 0),  ;
		        cPeriod1     c(30), ;
		        cPeriod2     c(30), ;
		        cYear1       c(30), ;
		        cYear2       c(30), ;
		        cAcctType    C(25),   ;
		        cAcctDesc    C(40),   ;
		        cFiscalYr    C(4),    ;
		        cFiscalPrd   C(2),    ;
		        nBegBal      N(12, 2), ;
		        nDebits      N(12, 2), ;
		        nCredits     N(12, 2), ;
		        nCurBal      N(12, 2), ;
		        nCurPct      N(6, 1),  ;
		        nYearBal     N(12, 2), ;
		        nYearPct     N(6, 1),  ;
		        nNetIncC1   N(12, 2), ;
		        nNetIncC2   N(12, 2), ;
		        nNetIncY1   N(12, 2), ;
		        nNetIncY2   N(12, 2))
		
		   INDEX ON cBalGroup + cAcctNo + cBreak TAG AcctNo
		   INDEX ON cAcctNo TAG Acct
		
		   SELECT balance
		   SCATTER MEMVAR blank
		   
		    IF lnReportBy = 1
		       m.cPeriod1 = 'This Month'
		       m.cPeriod2 = 'Year-to-Date'
		    ELSE
		       m.cPeriod1 = 'This Quarter'
		       m.cPeriod2 = 'Year-to-Date'
		    ENDIF    
		    
		*
		*  Get the periods activity for each account in the range.
		*
		   SELECT  newcoa.cAcctNo,       ;
				   newcoa.cAcctDesc,     ;
				   newcoa.nAcctType,     ;
				   newcoa.lTitle,        ;
				   newcoa.lTotalAcct,    ;
				   CoaBalNew.cyear AS cFiscalYr,  ;
				   CoaBalNew.cPeriod AS cFiscalPrd, ;
				   SUM(CoaBalNew.nDebits) AS nDebits,    ;
				   SUM(CoaBalNew.nCredits) AS nCredits    ;
			   FROM CoaBalNew ;
			   JOIN newcoa ;
				   ON CoaBalNew.cAcctNo = newcoa.cAcctNo ;
			   WHERE BETWEEN(CoaBalNew.cyear + CoaBalNew.cPeriod, lcYear + lcPeriod1, lcYear + lcPeriod2) ;
				   AND newcoa.nAcctType # 0 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal1 ;
			   ORDER BY 1 ;
			   GROUP BY 1
		
		   SELECT  newcoa.cAcctNo,            ;
				   newcoa.cAcctDesc,          ;
				   newcoa.nAcctType,          ;
				   newcoa.lTitle,             ;
				   newcoa.lTotalAcct,         ;
				   lcYear AS cFiscalYr,    ;
				   lcPeriod AS cFiscalPrd, ;
				   0 AS nDebits,           ;
				   0 AS nCredits           ;
			   FROM newcoa ;
			   WHERE newcoa.cAcctNo NOT IN ;
				   (SELECT  cAcctNo ;
						FROM tempbal1) ;
				   AND newcoa.nAcctType # 0 ;
			   INTO CURSOR tempbal2 ;
			   ORDER BY 1 ;
			   GROUP BY 1
		
		*
		*  If there were no records found, bail out.
		*
		   IF _TALLY = 0
		      RETURN
		   ENDIF
		   
		
		*
		*  Append the records to the balance table
		*
		   SELECT balance
		   APPEND FROM DBF('tempbal1')
		   APPEND FROM DBF('tempbal2')
		   SET ORDER TO AcctNo
		   USE IN tempbal1
		   USE IN tempbal2
		
		   SELECT balance
		   REPLACE cperiod1 WITH m.cPeriod1, ;
		           cperiod2 WITH m.cPeriod2 ALL 
		
		*
		*  Get the beginning balances for each account in the range.
		*
		   SELECT  CoaBalNew.cAcctNo, ;
				   SUM(nDebits)  AS nDebits, ;
				   SUM(nCredits) AS nCredits ;
			   FROM CoaBalNew ;
			   WHERE CoaBalNew.cyear = lcYear ;
				   AND CoaBalNew.cPeriod < lcPeriod1 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbeg ;
			   ORDER BY CoaBalNew.cAcctNo ;
			   GROUP BY CoaBalNew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		   IF _TALLY > 0
		      SELECT tempbeg
		      SCAN
		         SCATTER MEMVAR
		         SELECT balance
		         SET ORDER TO Acct
		         IF SEEK(m.cAcctNo)
		            IF nAcctType = 8 OR nAcctType = 13
		               lnBegBal  = m.nCredits - m.nDebits
		               lnYearBal = lnBegBal + (nCredits - nDebits)
		               lnCurBal  = nCredits - nDebits
		            ELSE
		               lnBegBal  = m.nDebits - m.nCredits
		               lnYearBal = lnBegBal + (nDebits - nCredits)
		               lnCurBal  = nDebits - nCredits
		            ENDIF
		            REPLACE nBegBal  WITH lnBegBal, ;
		               nCurBal  WITH lnCurBal, ;
		               nYearBal WITH lnYearBal
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Plug in the ending balance numbers.
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      IF EMPTY(nBegBal)
		         IF nAcctType = 8 OR nAcctType = 13
		            REPLACE nYearBal WITH nCredits - nDebits, ;
		               nCurBal  WITH nCredits - nDebits, ;
		               nBegBal WITH 0
		         ELSE
		            REPLACE nYearBal WITH nDebits - nCredits, ;
		               nCurBal  WITH nDebits - nCredits, ;
		               nBegBal WITH 0
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		*
		*  Calculate the Gross Revenue
		*
		   SELECT  SUM(nCurBal), SUM(nYearBal) ;
			   FROM balance ;
			   WHERE nAcctType = 8 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laGrossRev
		
		   IF _TALLY > 0
		      lnGrossC = laGrossRev[1, 1]
		      lnGrossY = laGrossRev[1, 2]
		      SELECT balance
		      SCAN FOR BETWEEN(nAcctType, 8, 16)
		         IF lnGrossC <> 0
		            REPLACE nCurPct WITH ABS(ROUND(((nCurBal / lnGrossC) * 100), 1))
		         ENDIF
		         IF lnGrossY <> 0
		            REPLACE nYearPct WITH ABS(ROUND(((nYearBal / lnGrossY) * 100), 1))
		         ENDIF
		      ENDSCAN
		   ELSE
		      lnGrossC = 0
		      lnGrossY = 0
		   ENDIF
		
		*
		*  Calculate the Cost of Goods Sold
		*
		   SELECT  SUM(nCurBal), SUM(nYearBal) ;
			   FROM balance ;
			   WHERE nAcctType = 9 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laCOGS
		
		   IF _TALLY > 0
		      lnCOGSC = laCOGS[1, 1]
		      lnCOGSY = laCOGS[1, 2]
		   ELSE
		      lnCOGSC = 0
		      lnCOGSY = 0
		   ENDIF
		
		*
		*  Calculate the Gross Profit
		*
		   lnGrossProfitCur = lnGrossC - lnCOGSC
		   lnGrossProfitYr  = lnGrossY - lnCOGSY
		
		*
		*  Insert gross profit line in balance table
		*
		   m.nYearBal   = lnGrossProfitYr
		   m.nCurBal    = lnGrossProfitCur
		   m.cAcctDesc  = 'Gross Profit'
		   m.cAcctNo    = ' '
		   m.cBalGroup  = 'C'
		   m.cAcctType  = 'Gross Profit'
		   m.nAcctType  = 0
		   m.cFiscalYr  = lcYear
		   m.cFiscalPrd = lcPeriod
		   m.nBegBal    = 0
		   m.nDebits    = 0
		   m.nCredits   = 0
		   IF lnGrossC <> 0
		      m.nCurPct = ABS(ROUND(((m.nCurBal / lnGrossC) * 100), 1))
		   ELSE
		      m.nCurPct = 0
		   ENDIF
		   IF lnGrossY <> 0
		      m.nYearPct = ABS(ROUND(((m.nYearBal / lnGrossY) * 100), 1))
		   ELSE
		      m.nYearPct = 0
		   ENDIF
		
		*
		*  Only show a gross profit here if there is at lease
		*  one cost of goods sold account defined.
		*
		   SELE cAcctNo FROM newcoa INTO ARRAY laCOGS WHERE nAcctType = 9
		   lnCOGS = _TALLY
		   IF lnCOGS > 0
		      INSERT INTO balance FROM MEMVAR
		   ENDIF
		
		
		*
		*  Calculate the gross profit from operations
		*
		   SELECT  SUM(nCurBal), SUM(nYearBal) ;
			   FROM balance ;
			   WHERE BETWEEN(nAcctType, 10, 11) ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laExpenses
		
		   IF _TALLY > 0
		      lnExpenseC = laExpenses[1, 1]
		      lnExpenseY = laExpenses[1, 2]
		   ELSE
		      STORE 0 TO lnExpenseC, lnExpenseY
		   ENDIF
		
		   lnGrossProfitOperCur = lnGrossProfitCur - lnExpenseC
		   lnGrossProfitOperYr  = lnGrossProfitYr - lnExpenseY
		
		*
		*  Insert gross profit line in balance table
		*
		   m.nYearBal   = lnGrossProfitOperYr
		   m.nCurBal    = lnGrossProfitOperCur
		   m.cAcctDesc  = 'Gross Profit From Operations'
		   m.cAcctNo    = ' '
		   m.cBalGroup  = 'F'
		   m.cAcctType  = 'Gross Profit'
		   m.nAcctType  = 0
		   m.cFiscalYr  = lcYear
		   m.cFiscalPrd = lcPeriod
		   m.nBegBal    = 0
		   m.nDebits    = 0
		   m.nCredits   = 0
		
		   INSERT INTO balance FROM MEMVAR
		
		*
		*  Calculate the gross profit from producing leases
		*
		   SELECT  SUM(nCurBal), SUM(nYearBal) ;
			   FROM balance ;
			   WHERE nAcctType = 12 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laDepreciation
		
		   IF _TALLY > 0
		      lnDeprC = laDepreciation[1, 1]
		      lnDeprY = laDepreciation[1, 2]
		   ELSE
		      STORE 0 TO lnDeprC, lnDeprY
		   ENDIF
		
		   IF lnDeprC <> 0 OR lnDeprY <> 0
		      lnGrossProfitProdLeaseCur = lnGrossProfitOperCur - lnDeprC
		      lnGrossProfitProdLeaseYr  = lnGrossProfitOperYr - lnDeprY
		
		*
		*  Insert gross profit line in balance table
		*
		      m.nYearBal   = lnGrossProfitProdLeaseYr
		      m.nCurBal    = lnGrossProfitProdLeaseCur
		      m.cAcctDesc  = 'Gross Profit From Producing Leases'
		      m.cAcctNo    = ' '
		      m.cBalGroup  = 'H'
		      m.cAcctType  = 'Gross Profit'
		      m.nAcctType  = 0
		      m.cFiscalYr  = lcYear
		      m.cFiscalPrd = lcPeriod
		      m.nBegBal    = 0
		      m.nDebits    = 0
		      m.nCredits   = 0
		
		      INSERT INTO balance FROM MEMVAR
		   ELSE
		      lnGrossProfitProdLeaseCur = lnGrossProfitOperCur
		      lnGrossProfitProdLeaseYr  = lnGrossProfitOperYr
		   ENDIF
		*
		*  Calculate the net income before pension & bonus
		*
		   SELECT  SUM(nCurBal), SUM(nYearBal) ;
			   FROM balance ;
			   WHERE nAcctType = 13  ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laIncome
		
		   IF _TALLY > 0
		      lnIncC = laIncome[1, 1]
		      lnIncY = laIncome[1, 2]
		   ELSE
		      STORE 0 TO lnIncC, lnIncY
		   ENDIF
		
		   SELECT  SUM(nCurBal), SUM(nYearBal) ;
			   FROM balance ;
			   WHERE nAcctType = 14 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laExpense
		
		   IF _TALLY > 0
		      lnExpC = laExpense[1, 1]
		      lnExpY = laExpense[1, 2]
		   ELSE
		      STORE 0 TO lnExpC, lnExpY
		   ENDIF
		
		   IF lnIncC <> 0 OR lnIncY <> 0 OR lnExpC <> 0 OR lnExpY <> 0
		
		      lnNetPC = lnGrossProfitProdLeaseCur + lnIncC - lnExpC
		      lnNetPY = lnGrossProfitProdLeaseYr + lnIncY - lnExpY
		
		*
		*  Insert gross profit line in balance table
		*
		      m.nYearBal   = lnNetPY
		      m.nCurBal    = lnNetPC
		      m.cAcctDesc  = 'Net Income Before Pension & Bonus'
		      m.cAcctNo    = ' '
		      m.cBalGroup  = 'K'
		      m.cAcctType  = 'Net Income'
		      m.nAcctType  = 0
		      m.cFiscalYr  = lcYear
		      m.cFiscalPrd = lcPeriod
		      m.nBegBal    = 0
		      m.nDebits    = 0
		      m.nCredits   = 0
		      INSERT INTO balance FROM MEMVAR
		   ENDIF
		
		*
		*  Calculate the net income before taxes
		*
		   SELECT  SUM(nCurBal), SUM(nYearBal) ;
			   FROM balance ;
			   WHERE nAcctType = 16  ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laIncome
		
		   IF _TALLY > 0
		      lnBonusC = laIncome[1, 1]
		      lnBonusY = laIncome[1, 2]
		
		
		      lnNetPC = lnNetPC  - lnBonusC
		      lnNetPY = lnNetPY  - lnBonusY
		
		*
		*  Insert gross profit line in balance table
		*
		      m.nYearBal   = lnNetPY
		      m.nCurBal    = lnNetPC
		      m.cAcctDesc  = 'Net Income Before Taxes'
		      m.cAcctNo    = ' '
		      m.cBalGroup  = 'M'
		      m.cAcctType  = 'Net Income'
		      m.nAcctType  = 0
		      m.cFiscalYr  = lcYear
		      m.cFiscalPrd = lcPeriod
		      m.nBegBal    = 0
		      m.nDebits    = 0
		      m.nCredits   = 0
		      INSERT INTO balance FROM MEMVAR
		
		   ELSE
		      STORE 0 TO lnBonusC, lnBonusY
		   ENDIF
		*
		*  Calculate the Current Earnings
		*
		
		   SELECT  SUM(nCurBal), SUM(nYearBal) ;
			   FROM balance ;
			   WHERE nAcctType = 15 ;
				   AND lTotalAcct = .F. ;
			   INTO ARRAY laCurEarn
		
		   IF _TALLY > 0
		      THISFORM.nNetIncC1 = lnNetPC - laCurEarn[1, 1]
		      THISFORM.nNetIncY1 = lnNetPY - laCurEarn[1, 2]
		   ELSE
		      THISFORM.nNetIncC1 = lnNetPC
		      THISFORM.nNetIncY1 = lnNetPY
		   ENDIF
		
		*
		*  Plug in breaks after totals
		*
		   lnBreak = 1
		   SELE balance
		   SCAN FOR EMPTY(cBreak)
		      SCATTER MEMVAR
		      IF lTotalAcct
		         m.cBreak = PADL(ALLT(STR(lnBreak)), 2, '0')
		         INSERT INTO balanceb FROM MEMVAR
		         lnBreak = lnBreak + 1
		      ENDIF
		   ENDSCAN
		
		   SELE balance
		   APPEND FROM DBF('balanceb')
		*
		*  Plug in the account descriptions and delete any non income stmt
		*  accounts.
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      m.nAcctType = nAcctType
		      IF nAcctType <> 0
		         SELECT glacctyp
		         IF SEEK(m.nAcctType)
		            lcDesc = glacctyp.ctypedesc
		            SELECT balance
		            REPLACE cAcctType WITH lcDesc
		         ELSE
		            SELECT balance
		            REPLACE cAcctType WITH 'Unknown'
		         ENDIF
		      ELSE
		         LOOP
		      ENDIF
		      DO CASE
		         CASE m.nAcctType = 8
		            REPLACE cBalGroup WITH 'A'
		         CASE m.nAcctType = 9
		            REPLACE cBalGroup WITH 'B'
		         CASE m.nAcctType = 10
		            REPLACE cBalGroup WITH 'D'
		         CASE m.nAcctType = 11
		            REPLACE cBalGroup WITH 'E'
		         CASE m.nAcctType = 12
		            REPLACE cBalGroup WITH 'G'
		         CASE m.nAcctType = 13
		            REPLACE cBalGroup WITH 'I'
		         CASE m.nAcctType = 14
		            REPLACE cBalGroup WITH 'J'
		         CASE m.nAcctType = 16
		            REPLACE cBalGroup WITH 'L'
		         CASE m.nAcctType = 15
		            REPLACE cBalGroup WITH 'N'
		         OTHERWISE
		            DELETE NEXT 1
		            LOOP
		      ENDCASE
		      IF NOT llZero AND nYearBal = 0 AND nCurBal = 0 AND NOT lTitle
		         DELETE NEXT 1
		         LOOP
		      ENDIF
		      
		      IF llPrintNumbers
		         SELECT balance
		         REPLACE cacctdesc WITH cacctno + ' - ' + ALLTRIM(cacctdesc)
		      ENDIF 
		
		   ENDSCAN
		
		
		   SELECT balance
		   REPLACE nNetIncC1 WITH THISFORM.nNetIncC1, ;
		      nNetIncC2 WITH THISFORM.nNetIncC2, ;
		      nNetIncY1 WITH THISFORM.nNetIncY1, ;
		      nNetIncY2 WITH THISFORM.nNetIncY2,  ;
		      nLevel WITH 1 ALL
		
		   SELECT balance
		   COUNT FOR NOT DELETED() TO lnCount
		   SET ORDER TO AcctNo
		   GO TOP
		
		   IF lnCount > 0
		      llReturn = .T.
		   ELSE
		      llReturn =  .F.
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Standard', loError.LINENO, 'Consolidated Income Stmt', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE cmdChoose.Click
		DO FORM source\glConsolidate
	ENDPROC

	PROCEDURE OpgQuarters.Init
		this.q1.value = 1
	ENDPROC

	PROCEDURE OpgQuarters.Q1.GotFocus
		THISFORM.opgQuarters.VALUE = 1
		
	ENDPROC

	PROCEDURE OpgQuarters.Q2.GotFocus
		THISFORM.opgQuarters.VALUE = 2
	ENDPROC

	PROCEDURE OpgQuarters.Q3.GotFocus
		THISFORM.opgQuarters.VALUE = 3
	ENDPROC

	PROCEDURE OpgQuarters.Q4.GotFocus
		THISFORM.opgQuarters.VALUE = 4
	ENDPROC

	PROCEDURE opgreportby.Valid
		
		DODEFAULT()
		
		IF this.value = 1
		   thisform.txtyear.enabled = .t.
		   thisform.txtperiod.enabled = .t.
		   thisform.opgquarters.q1.enabled = .f.
		   thisform.opgquarters.q2.enabled = .f.
		   thisform.opgquarters.q3.enabled = .f.
		   thisform.opgquarters.q4.enabled = .f.
		else
		   thisform.txtyear.enabled = .t.
		   thisform.txtperiod.enabled = .f.
		   thisform.opgquarters.q1.enabled = .t.
		   thisform.opgquarters.q2.enabled = .t.
		   thisform.opgquarters.q3.enabled = .t.
		   thisform.opgquarters.q4.enabled = .t.
		endif      
	ENDPROC

ENDDEFINE
