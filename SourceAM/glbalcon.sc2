*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="glbalcon.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 363
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 662

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 113, ;
		Name = "Cursor2", ;
		Top = 121, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 333, ;
		Name = "Cursor4", ;
		Top = 2, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 220, ;
		Name = "Cursor5", ;
		Top = 1, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glacctyp", ;
		CursorSource = "glacctyp", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 115, ;
		Name = "Cursor6", ;
		Order = "naccttype", ;
		Top = 0, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formglballist AS frmrptcriteria OF "appforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdChoose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgreportby" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="OpgQuarters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkZeroBal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkComparative" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboAccountType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTotal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAcctNumbers" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: accountlevel
		*m: comparitivebal
		*m: loadmonth
		*m: removezero
		*m: standardbal
		*m: subtotals
		*p: lerror
		*a: lamonthend[12,0]
		*a: lamonth[12,0]
	*</DefinedPropArrayMethod>

	Caption = "Consolidated Balance Sheet"
	DoCreate = .T.
	Height = 488
	HelpContextID = 416
	Name = "FormGlballist"
	Width = 478
	Swrptcriteriabuttons1.chkExport.Alignment = 0
	Swrptcriteriabuttons1.chkExport.Name = "chkExport"
	Swrptcriteriabuttons1.cmdclose.Name = "cmdclose"
	Swrptcriteriabuttons1.cmdPreview.Name = "cmdPreview"
	Swrptcriteriabuttons1.cmdPrint.Name = "cmdPrint"
	Swrptcriteriabuttons1.Left = 108
	Swrptcriteriabuttons1.Name = "Swrptcriteriabuttons1"
	Swrptcriteriabuttons1.TabIndex = 16
	Swrptcriteriabuttons1.Top = 403

	ADD OBJECT 'cboAccountType' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		Height = 20, ;
		Left = 179, ;
		Name = "cboAccountType", ;
		TabIndex = 6, ;
		Top = 200, ;
		Width = 217
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkAcctNumbers' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print Account Numbers", ;
		Height = 16, ;
		Left = 117, ;
		Name = "chkAcctNumbers", ;
		TabIndex = 15, ;
		Top = 323, ;
		Value = .F., ;
		Width = 129
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkComparative' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print a Comparative Statement", ;
		Height = 16, ;
		Left = 117, ;
		Name = "chkComparative", ;
		TabIndex = 13, ;
		Top = 271, ;
		Value = .F., ;
		Width = 162
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkTotal' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print Total Lines for All Sub-Accounts", ;
		Height = 16, ;
		Left = 117, ;
		Name = "chkTotal", ;
		TabIndex = 14, ;
		Top = 297, ;
		Value = .T., ;
		Width = 199
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkZeroBal' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Include Accounts with a Zero Balance", ;
		Height = 16, ;
		Left = 117, ;
		Name = "chkZeroBal", ;
		TabIndex = 12, ;
		Top = 245, ;
		Value = .F., ;
		Width = 203
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdChoose' AS cmdcommandbuttoncustom WITH ;
		Caption = "Choose Companies", ;
		Height = 36, ;
		Left = 195, ;
		Name = "cmdChoose", ;
		TabIndex = 10, ;
		Top = 140, ;
		Width = 108
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = -24, ;
		Name = "Glmaint", ;
		Top = 348
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Report By", ;
		Left = 86, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 11, ;
		Top = 21
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Quarter", ;
		Left = 67, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 7, ;
		Top = 78
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblPeriod' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Fiscal Period:", ;
		Height = 16, ;
		Left = 254, ;
		Name = "lblPeriod", ;
		TabIndex = 5, ;
		Top = 50, ;
		Width = 66, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom1' AS lbltextcustom WITH ;
		Caption = "Include Accounts:", ;
		Left = 83, ;
		Name = "Lbltextcustom1", ;
		TabIndex = 9, ;
		Top = 202
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblYear' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Fiscal Year:", ;
		Height = 16, ;
		Left = 116, ;
		Name = "lblYear", ;
		TabIndex = 3, ;
		Top = 50, ;
		Width = 60, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'OpgQuarters' AS opgoptiongroupcustom WITH ;
		BorderStyle = 1, ;
		ButtonCount = 4, ;
		Enabled = .T., ;
		Height = 35, ;
		Left = 60, ;
		Name = "OpgQuarters", ;
		TabIndex = 8, ;
		Top = 84, ;
		Width = 373, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "1st (Jan - Mar)", ;
		Option1.Enabled = .F., ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Q1", ;
		Option1.Top = 11, ;
		Option1.Width = 89, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "2nd (Apr - Jun)", ;
		Option2.Enabled = .F., ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 96, ;
		Option2.Name = "Q2", ;
		Option2.Top = 11, ;
		Option2.Width = 92, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "3rd (Jul - Sep)", ;
		Option3.Enabled = .F., ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 192, ;
		Option3.Name = "Q3", ;
		Option3.Top = 11, ;
		Option3.Width = 87, ;
		Option4.AutoSize = .T., ;
		Option4.Caption = "4th (Oct - Dec)", ;
		Option4.Enabled = .F., ;
		Option4.FontSize = 8, ;
		Option4.Height = 16, ;
		Option4.Left = 281, ;
		Option4.Name = "Q4", ;
		Option4.Top = 11, ;
		Option4.Width = 90
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'opgreportby' AS opgoptiongroupcustom WITH ;
		AutoSize = .T., ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		Height = 26, ;
		Left = 146, ;
		Name = "opgreportby", ;
		TabIndex = 1, ;
		Top = 16, ;
		Value = 1, ;
		Width = 194, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Fiscal Period", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 79, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Fiscal Quarter", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 103, ;
		Option2.Name = "Option2", ;
		Option2.Top = 5, ;
		Option2.Width = 86
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtPeriod' AS swperiod WITH ;
		Left = 338, ;
		Name = "txtPeriod", ;
		TabIndex = 4, ;
		Top = 48, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtYear' AS swyear WITH ;
		Left = 194, ;
		Name = "txtYear", ;
		TabIndex = 2, ;
		Top = 48, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE accountlevel
		LOCAL lcParent, lcPreviousLevel, lnCurrentLevel, lnLevel, lnRecNo, tlCompare
		LOCAL lcLevel
		LOCAL llReturn, loError
		LOCAL cAcctNo
		
		llReturn = .T.
		
		TRY
		   tlCompare = THISFORM.chkComparative.VALUE
		   lcLevel   = THISFORM.cboAccountType.VALUE
		
		   IF lcLevel <> '*'  &&  Not reporting on all levels, so sum the balances back to the parent accounts that are on the chosen level
		      WAIT WINDOW NOWAIT 'Summing Sub-Accounts....Please Wait'
		      lnLevel         = VAL(lcLevel)
		      lcPreviousLevel = 1
		      SELECT balance
		      SCAN
		         SCATTER MEMVAR
		         lnRecNo        = RECNO()  &&  Store the current record, so we can return to it
		         lnCurrentLevel = THISFORM.glmaint.calcsublevelcon(m.cAcctNo)  &&  Determine the level of the current account, so we know whether it should be added to a parent account
		
		         lcPreviousLevel = lnCurrentLevel
		         IF lnCurrentLevel > lnLevel  &&  This account is below the level on which to report, so find the parent and add to its total
		            SELECT balance
		            DO CASE
		               CASE lnCurrentLevel - lnLevel = 1  &&  Only need to go up a single level to add on the totals
		                  swselect('NewCoa')
		                  LOCATE FOR cAcctNo = m.cAcctNo  &&  Locate current account, and then check its parent
		                  IF FOUND()
		                     lcParent = cParent  &&  This is the account to have the current totals added to
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 2  &&  Need to go up two levels to find the parent
		                  swselect('NewCoa')
		                  LOCATE FOR cAcctNo = m.cAcctNo
		                  IF FOUND()
		                     lcParent = cParent
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 3  &&  Need to go up 3 levels to find the parent
		                  swselect('NewCoa')
		                  LOCATE FOR cAcctNo = m.cAcctNo
		                  IF FOUND()
		                     lcParent = cParent  &&  One level up
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent  &&  Two levels up
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent  &&  Three levels up
		                        ELSE
		                           WAIT WINDOW 'Problem locating parent account...'
		                        ENDIF
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 4  &&  Need to go up 4 levels to find the parent - this is the max
		                  swselect('NewCoa')
		                  LOCATE FOR cAcctNo = m.cAcctNo
		                  IF FOUND()
		                     lcParent = cParent  &&  One level up
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent  &&  Two levels up
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent  &&  Three levels up
		                           LOCATE FOR cAcctNo = lcParent
		                           IF FOUND()
		                              lcParent = cParent  &&  Four levels up
		                           ELSE
		                              WAIT WINDOW 'Problem locating parent account...'
		                           ENDIF
		                        ELSE
		                           WAIT WINDOW 'Problem locating parent account...'
		                        ENDIF
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               OTHERWISE  &&  Should never get here, since it means there's more than a 4 level difference
		                  WAIT WINDOW 'Too many levels'
		            ENDCASE
		
		**  Now that we know what the parent account is on the right level, add the current record totals to it  **
		            SELECT balance
		            SET DELETED OFF
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               IF DELETED()
		                  RECALL
		               ENDIF
		               IF tlCompare  &&  Comparison report, so the fields with numbers in them are slightly different
		                  REPLACE nBegBal1 WITH nBegBal1 + m.nBegBal1, nDebits1 WITH nDebits1 + m.nDebits1, nCredits1 WITH nCredits1 + m.nCredits1, ;
		                     nEndBal1 WITH nEndBal1 + m.nEndBal1, nBegBal2 WITH nBegBal2 + m.nBegBal2, nDebits2 WITH nDebits2 + m.nDebits2, nCredits2 WITH nCredits2 + m.nCredits2, ;
		                     nEndBal2 WITH nEndBal2 + m.nEndBal2
		               ELSE  &&  Not a comparison report, so replace the appropriate fields
		                  REPLACE nBegBal WITH nBegBal + m.nBegBal, nDebits WITH nDebits + m.nDebits, nCredits WITH nCredits + m.nCredits, ;
		                     nEndBal WITH nEndBal + m.nEndBal
		               ENDIF
		            ELSE
		               WAIT WINDOW 'Cannot find parent account to add totals to'
		            ENDIF
		            GOTO lnRecNo  &&  Go back to original record, ready to continue scanning
		            DELETE NEXT 1
		            SET DELETED ON
		         ENDIF
		
		      ENDSCAN
		   ENDIF
		
		* Mark parent accounts that have sub accounts as a title account
		* so the balance sheet prints them in bold.
		   SELECT balance
		   SET DELETED OFF
		   SCAN
		      lnRecNo   = RECNO()
		      m.cAcctNo = ALLTRIM(cAcctNo)
		
		      swselect('NewCoa')
		      SCAN FOR cParent = m.cAcctNo  &&  Do a scan instead of a locate, because there could be multiple subaccounts, some with activity, some without
		         SELECT balance
		         LOCATE FOR cAcctNo = NewCoa.cAcctNo AND NOT DELETED() AND IIF(NOT tlZero, IIF(tlCompare, nBegBal1 + nBegBal2 <> 0, nBegBal <> 0), .T.)
		         IF FOUND()
		            GOTO lnRecNo
		            REPLACE lTitle WITH .T.
		         ENDIF
		         GOTO lnRecNo
		      ENDSCAN
		      SELECT balance
		
		      lnCurrentLevel = THISFORM.glmaint.calcsublevelcon(m.cAcctNo)
		      SELECT balance
		      REPLACE nLevel WITH lnCurrentLevel
		
		*  To ensure proper sorting, we need to allow for them marking an account as being subaccount of an account that's not necessarily
		*  right in line previous to this one.  Since the account number isn't shown on the report, we'll fudge the account number by padding
		*  it with all the parent account numbers, so it prints correctly in order, even if the actual account numbers aren't.
		      swselect('NewCoa')
		      LOCATE FOR cAcctNo = m.cAcctNo
		      IF FOUND()
		         IF NOT EMPTY(cParent)
		            lcParent = cParent
		            SELECT balance
		            REPLACE cSortField WITH lcParent + cSortField, cParent WITH lcParent
		            swselect('NewCoa')
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               lcParent = cParent
		               IF NOT EMPTY(lcParent)
		                  SELECT balance
		                  REPLACE cSortField WITH lcParent + cSortField
		                  swselect('NewCoa')
		                  LOCATE FOR cAcctNo = lcParent
		                  IF FOUND()
		                     lcParent = cParent
		                     IF NOT EMPTY(lcParent)
		                        SELECT balance
		                        REPLACE cSortField WITH lcParent + cSortField
		                        swselect('NewCoa')
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent
		                           IF NOT EMPTY(lcParent)
		                              SELECT balance
		                              REPLACE cSortField WITH lcParent + cSortField
		                              swselect('NewCoa')
		                              LOCATE FOR cAcctNo = lcParent
		                              IF FOUND()
		                                 lcParent = cParent
		                                 IF NOT EMPTY(lcParent)
		                                    SELECT balance
		                                    REPLACE cSortField WITH lcParent + cSortField
		                                 ENDIF
		                              ENDIF
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'AccountLevel', loError.LINENO, 'Consolidated Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		WAIT CLEAR
		
		
	ENDPROC

	PROCEDURE builddata
		LOCAL tlCompare
		LOCAL lTotalAcct, lcLastAcctNo, lcLastYr, lcLastYr1, lcLevel, lcParent, llShowTotals, lnCount
		LOCAL lnLastLevel, lnQtr, lnRecNo, lnRecNo2, lnReportBy, lnTotal, lnTotal2
		LOCAL llReturn, loError
		*:Global cAcctDesc, cAcctNo, cAcctType, cBalGroup, cSortField, nAcctType, nEndBal, nEndBal1
		*:Global nEndBal2, nLevel, tcPeriod, tcYear, tlZero
		
		llReturn = .T.
		
		TRY
		   tcYear       = THISFORM.txtYear.VALUE
		   tcPeriod     = THISFORM.txtPeriod.VALUE
		   tlZero       = THISFORM.chkZeroBal.VALUE
		   tlCompare    = THISFORM.chkComparative.VALUE
		   lcLastYr     = STR(VAL(tcYear) - 1, 4)
		   lcLastYr1    = STR(VAL(tcYear) - 2, 4)
		   lnReportBy   = THISFORM.opgReportBy.VALUE
		   lnQtr        = THISFORM.opgQuarters.VALUE
		   lcLevel      = THISFORM.cboAccountType.VALUE
		   llShowTotals = THISFORM.chkTotal.VALUE
		
		   IF NOT tlCompare
		      llReturn = THISFORM.standardbal()
		   ELSE
		      llReturn = THISFORM.comparitivebal()
		   ENDIF
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		   
		   SELECT balance
		   SET DELETED OFF
		   SCAN
		      REPLACE cSortField WITH cAcctNo
		   ENDSCAN
		   SET DELETED ON
		
		* Process the account level chosen
		   llReturn = THISFORM.accountlevel()
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		   
		**  Scan and remove zero balance entries.  We'll delete every zero account, and then check to see whether the non-deleted accounts
		**  have parent accounts that need recalled to avoid orphaning subaccounts on the report.
		   llReturn = THISFORM.removezero(tlZero)
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		   
		   SET DELETED ON
		
		   llReturn = THISFORM.subtotals(llShowTotals)
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		   
		   SELECT balance
		   COUNT FOR NOT DELETED() TO lnCount
		   SET ORDER TO AcctNo
		   GO TOP
		
		   IF lnCount > 0
		      llReturn = .T.
		   ELSE
		      llReturn = .F.
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildData', loError.LINENO, 'Consolidated Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE comparitivebal
		LOCAL jlines, llfirst, m.cCurEarn, lcLastYr, lcLastYr1
		LOCAL llLastYrClosed, llCurYrClosed, tcYear, tcPeriod, tlZero, tlCompare
		LOCAL lnCount, lnRecNo, lcLevel, lnLevel, lnCurrentLevel, lcParent, llDetailExists
		LOCAL laCurEarn1[1], laCurEarn2[1], lcCurYear, lcPeriod1, lcPeriod2, lcYear, llShowTotals
		LOCAL lnAcctType, lnBegBal, lnCompanies, lnEndBal, lnQtr, lnReportBy
		LOCAL llReturn, loError
		*:Global cCurEarn, cRetEarn, cyear, nRetEarn
		
		llReturn = .T.
		
		TRY
		   tcYear       = THISFORM.txtYear.VALUE
		   tcPeriod     = THISFORM.txtPeriod.VALUE
		   tlZero       = THISFORM.chkZeroBal.VALUE
		   tlCompare    = THISFORM.chkComparative.VALUE
		   lcLastYr     = STR(VAL(tcYear) - 1, 4)
		   lcLastYr1    = STR(VAL(tcYear) - 2, 4)
		   lnReportBy   = THISFORM.opgReportBy.VALUE
		   lnQtr        = THISFORM.opgQuarters.VALUE
		   lcLevel      = THISFORM.cboAccountType.VALUE
		   llShowTotals = THISFORM.chkTotal.VALUE
		   llPrintNumbers = thisform.chkacctNumbers.Value 
		
		   DO CASE
		      CASE lnReportBy = 1
		         lcPeriod1 = tcPeriod
		         lcPeriod2 = tcPeriod
		      CASE lnQtr = 1
		         lcPeriod1 = '01'
		         lcPeriod2 = '03'
		      CASE lnQtr = 2
		         lcPeriod1 = '04'
		         lcPeriod2 = '06'
		      CASE lnQtr = 3
		         lcPeriod1 = '07'
		         lcPeriod2 = '09'
		      CASE lnQtr = 4
		         lcPeriod1 = '10'
		         lcPeriod2 = '12'
		   ENDCASE
		
		   THISFORM.cTitle1 = 'Consolidated Balance Sheet'
		   IF lnReportBy = 1
		      THISFORM.cTitle2 = THISFORM.laMonthEnd[VAL(tcPeriod)]
		   ELSE
		      THISFORM.cTitle2 = 'For the quarter ending ' + THISFORM.laMonthEnd[VAL(lcPeriod2)]
		   ENDIF
		
		*  Open the company master file, if not open.
		   IF NOT USED('compmast')
		      USE datafiles\compmast IN 0
		   ENDIF
		   SELE cProducer, cDataPath FROM compmast WHERE RIGHT(xflag, 1) = 'C' INTO CURSOR compsel
		
		*  Check to see if any companies were selected.
		   SELECT compsel
		   IF RECC() = 0
		      THISFORM.omessage.Warning('No companies have been selected to be consolidated. Please choose the companies to consolidate.')
		      THISFORM.lerror = .T.
		      llReturn = .F.
		      EXIT 
		   ELSE
		      lnCompanies = RECC()
		   ENDIF
		
		*
		*  Recalculate account balances
		*
		   WAIT WIND NOWAIT 'Calculating Account Balances...'
		   THISFORM.glmaint.calcconbalance()
		   WAIT CLEAR
		
		   WAIT WIND NOWAIT 'Processing Report Request...Please Wait'
		
		*
		*  Get the current earnings account number.
		*
		   swselect('glopt')
		   GO TOP
		   m.cCurEarn = cCurEarn
		   m.cRetEarn = cRetEarn
		
		* Get list of years so we can check if they've been closed
		   SELECT  coabalnew.cyear, .F. AS lclosed ;
			   FROM coabalnew ;
			   WHERE cyear < tcYear ;
			   INTO CURSOR closedyears READWRITE ;
			   ORDER BY cyear ;
			   GROUP BY cyear
		
		   SELECT closedyears
		   SCAN
		      m.cyear = cyear
		      swselect('sysctl')
		      SCAN FOR cyear == m.cyear AND ctypeclose = 'A'
		         IF sysctl.lyearclose
		            SELECT closedyears
		            REPLACE lclosed WITH .T.
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		
		*
		*  Check to make sure the currently open company is one of the consolidated companies
		*
		   SELE compsel
		   LOCATE FOR ALLT(m.goApp.cCompanyName) $ cProducer
		   IF NOT FOUND()
		      THISFORM.omessage.Warning('The currently open company MUST be one of the consolidated companies.  Please choose this company.')
		      THISFORM.lerror = .T.
		      llReturn = .F.
		      EXIT 
		   ENDIF
		
		   THISFORM.creportname = 'source\glbal02'
		   CREATE CURSOR balance ;
		      (cAcctNo     C(6), ;
		        cSortField  C(30), ;
		        cBalGroup   C(1), ;
		        nAcctType   N(2), ;
		        lTitle      L, ;
		        lTotalAcct  L, ;
		        cAcctType   C(25), ;
		        cAcctDesc   C(50), ;
		        cFiscalYr   C(4), ;
		        cFiscalPrd  C(2), ;
		        cParent     C(6), ;
		        nLevel      N(1, 0), ;
		        nBegBal1    N(13, 2), ;
		        nDebits1    N(13, 2), ;
		        nCredits1   N(13, 2), ;
		        nEndBal1    N(13, 2), ;
		        nBegBal2    N(13, 2), ;
		        nDebits2    N(13, 2), ;
		        nCredits2   N(13, 2), ;
		        nEndBal2    N(13, 2))
		   INDEX ON STR(nAcctType, 2) + cSortField TAG AcctNo
		   INDEX ON cAcctNo TAG Acct
		
		*
		*  Get the periods activity for each account in the range. (current year)
		*
		   SELECT  NewCoa.cAcctNo, ;
				   NewCoa.cAcctDesc, ;
				   NewCoa.nAcctType, ;
				   NewCoa.lTitle, ;
				   NewCoa.lTotalAcct, ;
				   coabalnew.cyear AS cFiscalYr, ;
				   coabalnew.cPeriod AS cFiscalPrd, ;
				   SUM(coabalnew.nDebits)  AS nDebits1, ;
				   SUM(coabalnew.nCredits) AS nCredits1 ;
			   FROM coabalnew, NewCoa ;
			   WHERE coabalnew.cAcctNo = NewCoa.cAcctNo ;
				   AND BETWEEN(coabalnew.cyear + coabalnew.cPeriod, tcYear + lcPeriod1, tcYear + lcPeriod2) ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal1 ;
			   ORDER BY NewCoa.cAcctNo ;
			   GROUP BY NewCoa.cAcctNo
		
		   SELECT  NewCoa.cAcctNo, ;
				   NewCoa.cAcctDesc, ;
				   NewCoa.nAcctType, ;
				   NewCoa.lTitle, ;
				   NewCoa.lTotalAcct, ;
				   tcYear AS cFiscalYr, ;
				   tcPeriod AS cFiscalPrd, ;
				   0 AS nDebits1, ;
				   0 AS nCredits1 ;
			   FROM NewCoa ;
			   WHERE NewCoa.cAcctNo NOT IN (SELECT  cAcctNo ;
												FROM tempbal1) ;
			   INTO CURSOR tempbal2 ;
			   ORDER BY NewCoa.cAcctNo ;
			   GROUP BY NewCoa.cAcctNo
		
		   lcCurYear = _TALLY
		
		*
		*  Get the periods activity for each account in the range for last year.
		*
		   SELECT  NewCoa.cAcctNo, ;
				   NewCoa.cAcctDesc, ;
				   NewCoa.nAcctType, ;
				   coabalnew.cyear AS cFiscalYr, ;
				   coabalnew.cPeriod AS cFiscalPrd, ;
				   SUM(coabalnew.nDebits)  AS nDebits2, ;
				   SUM(coabalnew.nCredits) AS nCredits2 ;
			   FROM coabalnew, NewCoa ;
			   WHERE coabalnew.cAcctNo = NewCoa.cAcctNo ;
				   AND BETWEEN(coabalnew.cyear + coabalnew.cPeriod, lcLastYr + lcPeriod1, lcLastYr + lcPeriod2) ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal3 ;
			   ORDER BY NewCoa.cAcctNo ;
			   GROUP BY NewCoa.cAcctNo
		
		   SELECT  NewCoa.cAcctNo, ;
				   NewCoa.cAcctDesc, ;
				   NewCoa.nAcctType, ;
				   lcLastYr AS cFiscalYr, ;
				   tcPeriod AS cFiscalPrd, ;
				   0 AS nDebits2, ;
				   0 AS nCredits2 ;
			   FROM NewCoa ;
			   WHERE NewCoa.cAcctNo NOT IN (SELECT  cAcctNo ;
												FROM tempbal3) ;
			   INTO CURSOR tempbal4 ;
			   ORDER BY NewCoa.cAcctNo ;
			   GROUP BY NewCoa.cAcctNo
		
		*
		*  Append the records to the balance table
		*
		   SELECT balance
		   APPEND FROM DBF('tempbal1')
		   APPEND FROM DBF('tempbal2')
		   SET ORDER TO AcctNo
		   USE IN tempbal1
		   USE IN tempbal2
		
		*
		*  Add in last year's balances.
		*
		   SELECT tempbal3
		   SCAN
		      SCATTER MEMVAR
		      SELECT balance
		      SET ORDER TO Acct
		      IF SEEK(m.cAcctNo)
		         REPLACE nDebits2  WITH m.nDebits2, ;
		            nCredits2 WITH m.nCredits2
		      ELSE
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   SELECT tempbal4
		   SCAN
		      SCATTER MEMVAR
		      SELECT balance
		      SET ORDER TO Acct
		      IF NOT SEEK(m.cAcctNo)
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   USE IN tempbal3
		   USE IN tempbal4
		*
		*  Get the beginning balances for each account in the range (current year)
		*
		   SELECT  coabalnew.cAcctNo, ;
				   SUM(nDebits) AS nDebits1, ;
				   SUM(nCredits) AS nCredits1 ;
			   FROM coabalnew ;
			   WHERE coabalnew.cyear + coabalnew.cPeriod < tcYear + lcPeriod1 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbeg ;
			   ORDER BY coabalnew.cAcctNo ;
			   GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		   IF _TALLY > 0
		      SELECT tempbeg
		      SCAN
		         SCATTER MEMVAR
		         lnBegBal = m.nDebits1 - m.nCredits1
		         SELECT balance
		         SET ORDER TO Acct
		         IF SEEK(m.cAcctNo)
		            lnEndBal = lnBegBal + nDebits1 - nCredits1
		            REPLACE nBegBal1 WITH lnBegBal, ;
		               nEndBal1 WITH lnEndBal
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Get the beginning balances for each account in the range (last year)
		*
		   SELECT  coabalnew.cAcctNo, ;
				   SUM(nDebits) AS nDebits2, ;
				   SUM(nCredits) AS nCredits2 ;
			   FROM coabalnew ;
			   WHERE coabalnew.cyear + coabalnew.cPeriod < lcLastYr + lcPeriod1 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbeg ;
			   ORDER BY coabalnew.cAcctNo ;
			   GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		   IF _TALLY > 0
		      SELECT tempbeg
		      SCAN
		         SCATTER MEMVAR
		         lnBegBal = m.nDebits2 - m.nCredits2
		         SELECT balance
		         IF SEEK(m.cAcctNo)
		            lnEndBal = lnBegBal + nDebits2 - nCredits2
		            REPLACE nBegBal2 WITH lnBegBal, ;
		               nEndBal2 WITH lnEndBal
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Plug in the ending balances
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      IF EMPTY(nBegBal1)
		         REPLACE nEndBal1 WITH nDebits1 - nCredits1, ;
		            nBegBal1 WITH 0
		      ENDIF
		      IF EMPTY(nBegBal2)
		         REPLACE nEndBal2 WITH nDebits2 - nCredits2, ;
		            nBegBal2 WITH 0
		      ENDIF
		      IF BETWEEN(nAcctType, 4, 7)
		         REPLACE nEndBal1 WITH (nEndBal1 * -1), ;
		            nEndBal2 WITH (nEndBal2 * -1)
		      ENDIF
		   ENDSCAN
		
		*
		*  Calculate the net income for last year to add to
		*  retained earnings.   
		
		   SELECT closedyears
		*!*	   LOCATE FOR NOT lclosed
		*!*	   IF FOUND()
		      SELECT closedyears
		      SCAN 
		         lcLastYr = cyear
		
				 SELECT  coabalnew.cAcctNo, ;
						 NewCoa.nAcctType, ;
						 SUM(nDebits - nCredits)  AS nRetEarn ;
					 FROM coabalnew, NewCoa ;
					 WHERE coabalnew.cyear = lcLastYr ;
						 AND coabalnew.cAcctNo = NewCoa.cAcctNo ;
						 AND BETWEEN(NewCoa.nAcctType, 8, 16) ;
						 AND NOT DELETED() ;
					 INTO CURSOR tempbeg
		
		         IF _TALLY > 0
		            SELECT tempbeg
		            GO TOP
		            m.nRetEarn = nRetEarn
		         ELSE
		            m.nRetEarn = 0
		         ENDIF
		
		*  Plug in the new retained earnings number
		         SELECT balance
		         SET ORDER TO Acct
		         IF SEEK(m.cRetEarn)
		            REPLACE nEndBal1 WITH nEndBal1 + (m.nRetEarn * -1)
		         ENDIF
		      ENDSCAN
		*!*	   ENDIF
		
		*
		*  Calculate the Current Earnings for this year
		*
		   SELECT  SUM(nDebits - nCredits) AS nEndBal1, ;
				   NewCoa.nAcctType ;
			   FROM coabalnew, NewCoa ;
			   WHERE BETWEEN(NewCoa.nAcctType, 8, 16) ;
				   AND coabalnew.cyear = tcYear ;
				   AND coabalnew.cPeriod <= lcPeriod2 ;
				   AND coabalnew.cAcctNo = NewCoa.cAcctNo ;
				   AND NewCoa.lTotalAcct = .F. ;
				   AND NOT DELETED() ;
			   INTO ARRAY laCurEarn1
		
		   IF _TALLY > 0
		      SELECT balance
		      SET ORDER TO Acct
		      IF SEEK(m.cCurEarn)
		         REPLACE nEndBal1 WITH nEndBal1 + (laCurEarn1[1, 1] * -1)
		      ENDIF
		   ENDIF
		
		*
		*  Calculate the Current Earnings for last year
		*
		   SELECT  SUM(nDebits - nCredits) AS nEndBal1, ;
				   NewCoa.nAcctType ;
			   FROM coabalnew, NewCoa ;
			   WHERE BETWEEN(NewCoa.nAcctType, 8, 16) ;
				   AND coabalnew.cyear = lcLastYr ;
				   AND coabalnew.cPeriod <= lcPeriod2 ;
				   AND coabalnew.cAcctNo = NewCoa.cAcctNo ;
				   AND NewCoa.lTotalAcct = .F. ;
				   AND NOT DELETED() ;
			   INTO ARRAY laCurEarn2
		
		   IF _TALLY > 0
		      SELECT balance
		      SET ORDER TO Acct
		      IF SEEK(m.cCurEarn)
		         REPLACE nEndBal2 WITH nEndBal2 + (laCurEarn2[1, 1] * -1)
		      ENDIF
		   ENDIF
		
		*
		*  Plug in the account types
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      lnAcctType = nAcctType
		      swselect('glacctyp')
		      IF SEEK(lnAcctType)
		         SELECT balance
		         REPLACE cAcctType WITH glacctyp.cTypeDesc
		      ELSE
		         SELECT balance
		         REPLACE cAcctType WITH 'Unknown'
		      ENDIF
		      DO CASE
		         CASE BETWEEN(lnAcctType, 1, 3)
		            REPLACE cBalGroup WITH 'A'
		         CASE BETWEEN(lnAcctType, 4, 7)
		            REPLACE cBalGroup WITH 'B'
		         OTHERWISE
		            DELETE NEXT 1
		            LOOP
		      ENDCASE
		      SELECT balance
		*  Only delete if reporting on something other than 'All Levels' since the level processing will delete later on
		      IF NOT tlZero AND nEndBal1 = 0 AND nEndBal2 = 0  AND cAcctNo <> m.cCurEarn AND NOT lTitle AND lcLevel <> '*'
		         DELETE NEXT 1
		         LOOP
		      ENDIF
		      
		      IF llPrintNumbers
		         SELECT balance
		         REPLACE cacctdesc WITH cacctno + ' - ' + ALLTRIM(cacctdesc)
		      ENDIF 
		   ENDSCAN
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'ComparitiveBal', loError.LINENO, 'Consolidated Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		WAIT CLEAR
		
	ENDPROC

	PROCEDURE Init
		
		IF DODEFAULT()
		   THISFORM.txtPeriod.VALUE = GetFiscalPeriod(DATE())
		   THISFORM.txtYear.VALUE   = GetFiscalYear(DATE())
		   SET DELETED ON
		
		*
		*  Load the month array properties
		*
		   THISFORM.loadmonth()
		ENDIF
		
		
		
		
	ENDPROC

	PROCEDURE loadmonth
		LOCAL lnX, lnMonth, lcYear
		LOCAL llFYEnd, llReturn, lnMonth1, loError
		*:Global tcYear
		
		llReturn = .T.
		
		TRY
		   tcYear = THISFORM.txtYear.VALUE
		
		*
		*  Load the titles for the financial statements
		*
		   THISFORM.laMonth[1] = 'January 31, '
		
		   THISFORM.laMonth[3]  = 'March 31, '
		   THISFORM.laMonth[4]  = 'April 30, '
		   THISFORM.laMonth[5]  = 'May 31, '
		   THISFORM.laMonth[6]  = 'June 30, '
		   THISFORM.laMonth[7]  = 'July 31, '
		   THISFORM.laMonth[8]  = 'August 31, '
		   THISFORM.laMonth[9]  = 'September 30, '
		   THISFORM.laMonth[10] = 'October 31, '
		   THISFORM.laMonth[11] = 'November 30, '
		   THISFORM.laMonth[12] = 'December 31, '
		
		*
		*  Get the beginning month of the fiscal year
		*
		   SELECT glopt
		   GO TOP
		   llFYEnd  = lFYEnd
		   lnMonth  = VAL(glopt.cfybegin)
		   lnMonth1 = lnMonth
		   IF llFYEnd
		      lcYear = STR(VAL(tcYear) - 1, 4)
		   ELSE
		      lcYear = tcYear
		   ENDIF
		
		*
		*  Load up the monthend array
		*
		   FOR lnX = 1 TO 12
		      IF lnMonth1 = 2
		*
		*  Check for leap year
		*
		         IF MOD(VAL(lcYear), 4) = 0
		            THISFORM.laMonth[2] = 'February 29, '
		         ELSE
		            THISFORM.laMonth[2] = 'February 28, '
		         ENDIF
		      ENDIF
		
		      THISFORM.laMonthEnd[lnX] = THISFORM.laMonth[lnMonth1] + ' ' + lcYear
		      IF lnMonth1 = 12
		         lnMonth1 = 1
		         lcYear   = STR(VAL(lcYear) + 1, 4)
		      ELSE
		         lnMonth1 = lnMonth1 + 1
		      ENDIF
		   ENDFOR
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'LoadMonth', loError.LINENO, 'Consolidated Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE removezero
		LPARAMETERS tlZero
		LOCAL lcParent, lnRecNo, m.cCurEarn, tlCompare
		LOCAL llReturn, loError
		*:Global cCurEarn, cRetEarn
		
		llReturn = .T.
		
		TRY
		
		   IF thisform.chkzeroBal.Value
		      llReturn = .t
		      EXIT
		   ENDIF 
		
		   tlCompare = THISFORM.chkComparative.VALUE
		
		*
		*  Get the current earnings account number.
		*
		   swselect('glopt')
		   GO TOP
		   m.cCurEarn = cCurEarn
		   m.cRetEarn = cRetEarn
		
		   IF NOT tlZero
		      WAIT WINDOW NOWAIT 'Removing Zero Balance Entries'
		      SELECT balance
		      SCAN FOR IIF(tlCompare, balance.nEndBal1 = 0 AND balance.nEndBal2 = 0, balance.nEndBal = 0)  AND balance.cAcctNo <> m.cCurEarn
		         DELETE NEXT 1
		      ENDSCAN
		
		      SELECT balance
		      SCAN FOR LEN(ALLTRIM(cSortField)) > 6 AND IIF(tlCompare, balance.nEndBal1 <> 0  OR balance.nEndBal2 <> 0, balance.nEndBal <> 0) AND nAcctType < 8  &&  Accounts with parent accounts and activity
		         lnRecNo  = RECNO()
		         lcParent = SUBSTR(cSortField, 1, 6)
		         LOCATE FOR cAcctNo = lcParent
		         IF FOUND()
		            IF DELETED()  &&  This is a parent acct with activity for a subaccount, so recall it, so it shows up
		               RECALL
		            ENDIF
		            lcParent = SUBSTR(cSortField, 7, 6)
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               IF DELETED()
		                  RECALL
		               ENDIF
		               lcParent = SUBSTR(cSortField, 13, 6)
		               LOCATE FOR cAcctNo = lcParent
		               IF FOUND()
		                  IF DELETED()
		                     RECALL
		                  ENDIF
		                  lcParent = SUBSTR(cSortField, 19, 6)
		                  LOCATE FOR cAcctNo = lcParent
		                  IF FOUND()
		                     IF DELETED()
		                        RECALL
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		         SELECT balance
		         GOTO lnRecNo
		      ENDSCAN
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'RemoveZero', loError.LINENO, 'Consolidated Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE report
		LPARAMETERS cbutton
		PRIV lcCompany
		
		if thisform.lerror
		   return
		endif
		   
		lcCompany = ''
		
		SELE compsel
		SCAN
		   IF EMPTY(ALLT(lcCompany))
		      lcCompany = ALLT(cProducer)
		   ELSE
		      lcCompany = ALLT(lcCompany) + '/' + ALLT(cProducer)
		   ENDIF
		ENDSCAN
		
		SELE balance
		
		DODEFAULT(cButton)      
		
		
	ENDPROC

	PROCEDURE standardbal
		LOCAL jlines, llfirst, m.cCurEarn, lcLastYr, lcLastYr1
		LOCAL llLastYrClosed, llCurYrClosed, tcYear, tcPeriod, tlZero, tlCompare
		LOCAL lnCount, lnRecNo, lcLevel, lnLevel, lnCurrentLevel, lcParent, llDetailExists
		LOCAL laCurEarn[1], lcPeriod1, lcPeriod2, lcYear, llShowTotals, lnAcctType, lnBegBal, lnCompanies
		LOCAL lnEndBal, lnQtr, lnReportBy
		LOCAL llReturn, loError
		*:Global cCurEarn, cRetEarn, cyear, nRetEarn
		
		llReturn = .T.
		
		TRY
		   tcYear       = THISFORM.txtYear.VALUE
		   tcPeriod     = THISFORM.txtPeriod.VALUE
		   tlZero       = THISFORM.chkZeroBal.VALUE
		   tlCompare    = THISFORM.chkComparative.VALUE
		   lcLastYr     = STR(VAL(tcYear) - 1, 4)
		   lcLastYr1    = STR(VAL(tcYear) - 2, 4)
		   lnReportBy   = THISFORM.opgReportBy.VALUE
		   lnQtr        = THISFORM.opgQuarters.VALUE
		   lcLevel      = THISFORM.cboAccountType.VALUE
		   llShowTotals = THISFORM.chkTotal.VALUE
		   llPrintNumbers = thisform.chkAcctNumbers.Value 
		
		
		   DO CASE
		      CASE lnReportBy = 1
		         lcPeriod1 = tcPeriod
		         lcPeriod2 = tcPeriod
		      CASE lnQtr = 1
		         lcPeriod1 = '01'
		         lcPeriod2 = '03'
		      CASE lnQtr = 2
		         lcPeriod1 = '04'
		         lcPeriod2 = '06'
		      CASE lnQtr = 3
		         lcPeriod1 = '07'
		         lcPeriod2 = '09'
		      CASE lnQtr = 4
		         lcPeriod1 = '10'
		         lcPeriod2 = '12'
		   ENDCASE
		
		*
		*  Load the month array properties
		*
		   THISFORM.loadmonth()
		
		   THISFORM.cTitle1 = 'Consolidated Balance Sheet'
		   IF lnReportBy = 1
		      THISFORM.cTitle2 = THISFORM.laMonthEnd[VAL(tcPeriod)]
		   ELSE
		      THISFORM.cTitle2 = 'For the quarter ending ' + THISFORM.laMonthEnd[VAL(lcPeriod2)]
		   ENDIF
		
		*  Open the company master file, if not open.
		   IF NOT USED('compmast')
		      USE datafiles\compmast IN 0
		   ENDIF
		   SELE cProducer, cDataPath FROM compmast WHERE RIGHT(xflag, 1) = 'C' INTO CURSOR compsel
		
		*  Check to see if any companies were selected.
		   SELECT compsel
		   IF RECC() = 0
		      THISFORM.omessage.Warning('No companies have been selected to be consolidated. Please choose the companies to consolidate.')
		      THISFORM.lerror = .T.
		      llReturn        = .F.
		      EXIT
		   ELSE
		      lnCompanies = RECC()
		   ENDIF
		
		*
		*  Recalculate account balances
		*
		   WAIT WIND NOWAIT 'Calculating Account Balances...'
		   THISFORM.glmaint.calcconbalance()
		   WAIT CLEAR
		
		   WAIT WIND NOWAIT 'Processing Report Request...Please Wait'
		
		*
		*  Get the current earnings account number.
		*
		   swselect('glopt')
		   GO TOP
		   m.cCurEarn = cCurEarn
		   m.cRetEarn = cRetEarn
		
		* Get list of years so we can check if they've been closed
		   SELECT  coabalnew.cyear, .F. AS lclosed ;
			   FROM coabalnew ;
			   WHERE cyear < tcYear ;
			   INTO CURSOR closedyears READWRITE ;
			   ORDER BY cyear ;
			   GROUP BY cyear
		
		   SELECT closedyears
		   SCAN
		      m.cyear = cyear
		      swselect('sysctl')
		      SCAN FOR cyear == m.cyear AND ctypeclose = 'A'
		         IF sysctl.lyearclose
		            SELECT closedyears
		            REPLACE lclosed WITH .T.
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		
		*
		*  Check to make sure the currently open company is one of the consolidated companies
		*
		   SELE compsel
		   LOCATE FOR ALLT(m.goApp.cCompanyName) $ cProducer
		   IF NOT FOUND()
		      THISFORM.omessage.Warning('The currently open company MUST be one of the consolidated companies.  Please choose this company.')
		      THISFORM.lerror = .T.
		      llReturn        = .F.
		      EXIT
		   ENDIF
		
		   CREATE CURSOR balance ;
		      (cAcctNo    C(6), ;
		        cSortField  C(30), ;
		        cBalGroup   C(1), ;
		        nAcctType   N(2), ;
		        lTitle      L, ;
		        lTotalAcct  L, ;
		        cAcctType   C(25), ;
		        cAcctDesc   C(50), ;
		        cFiscalYr   C(4), ;
		        cFiscalPrd  C(2), ;
		        cParent     C(6), ;
		        nLevel      N(1, 0), ;
		        nCount      N(4, 0), ;
		        nBegBal     N(13, 2), ;
		        nDebits     N(13, 2), ;
		        nCredits    N(13, 2), ;
		        nEndBal     N(13, 2))
		   INDEX ON STR(nAcctType, 2) + cSortField TAG AcctNo
		   INDEX ON cAcctNo TAG Acct
		
		   THISFORM.creportname = 'source\glbal01'
		*
		*  Get the periods activity for each account for the current year.
		*
		   SELECT  NewCoa.cAcctNo, ;
				   NewCoa.cAcctDesc, ;
				   NewCoa.nAcctType, ;
				   NewCoa.lTitle, ;
				   NewCoa.lTotalAcct, ;
				   coabalnew.cyear AS cFiscalYr, ;
				   coabalnew.cPeriod AS cFiscalPrd, ;
				   SUM(coabalnew.nDebits) AS nDebits, ;
				   SUM(coabalnew.nCredits) AS nCredits ;
			   FROM coabalnew, NewCoa ;
			   WHERE coabalnew.cAcctNo = NewCoa.cAcctNo ;
				   AND BETWEEN(coabalnew.cyear + coabalnew.cPeriod, tcYear + lcPeriod1, tcYear + lcPeriod2) ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal1 ;
			   ORDER BY NewCoa.cAcctNo ;
			   GROUP BY NewCoa.cAcctNo
		
		   SELECT  NewCoa.cAcctNo, ;
				   NewCoa.cAcctDesc, ;
				   NewCoa.nAcctType, ;
				   NewCoa.lTitle, ;
				   NewCoa.lTotalAcct, ;
				   tcYear AS cFiscalYr, ;
				   tcPeriod AS cFiscalPrd, ;
				   0 AS nDebits, ;
				   0 AS nCredits ;
			   FROM NewCoa ;
			   WHERE NewCoa.cAcctNo NOT IN (SELECT  cAcctNo ;
												FROM tempbal1) ;
			   INTO CURSOR tempbal2 ;
			   ORDER BY NewCoa.cAcctNo ;
			   GROUP BY NewCoa.cAcctNo
		
		*
		*  If there were no records found, bail out.
		*
		   IF _TALLY = 0
		      llReturn = .F.
		      EXIT
		   ENDIF
		*
		*  Append the records to the balance table
		*
		   SELECT balance
		   APPEND FROM DBF('tempbal1')
		   USE IN tempbal1
		
		   SELECT balance
		   APPEND FROM DBF('tempbal2')
		   SET ORDER TO AcctNo
		   USE IN tempbal2
		
		
		*
		*  Get the beginning balances for each account in the range.
		*
		   SELECT  coabalnew.cAcctNo, ;
				   SUM(nDebits) AS nDebits, ;
				   SUM(nCredits) AS nCredits ;
			   FROM coabalnew ;
			   WHERE coabalnew.cyear + coabalnew.cPeriod < tcYear + lcPeriod1 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbeg ;
			   ORDER BY coabalnew.cAcctNo ;
			   GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		   IF _TALLY > 0
		      SELECT tempbeg
		      SCAN
		         SCATTER MEMVAR
		         lnBegBal = m.nDebits - m.nCredits
		         SELECT balance
		         SET ORDER TO Acct
		         IF SEEK(m.cAcctNo)
		*
		*  Only update balance sheet accounts
		*
		            IF nAcctType < 8
		               lnEndBal = lnBegBal + nDebits - nCredits
		               REPLACE nBegBal WITH lnBegBal, ;
		                  nEndBal WITH lnEndBal
		            ENDIF
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Plug in the ending balance numbers.
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      IF EMPTY(nBegBal)
		         REPLACE nEndBal WITH nDebits - nCredits, ;
		            nBegBal WITH 0
		      ENDIF
		      IF BETWEEN(nAcctType, 4, 7)
		         REPLACE nEndBal WITH (nEndBal * -1)
		      ENDIF
		   ENDSCAN
		
		*
		*  Calculate the net income for last year to add to
		*  retained earnings.   
		*
		   SELECT closedyears
		*!*	   LOCATE FOR NOT lclosed
		*!*	   IF FOUND()
		      SELECT closedyears
		      SCAN 
		         lcYear = cyear
		
				 SELECT  coabalnew.cAcctNo, ;
						 NewCoa.nAcctType, ;
						 SUM(nDebits - nCredits)  AS nRetEarn ;
					 FROM coabalnew, NewCoa ;
					 WHERE coabalnew.cyear = lcYear ;
						 AND coabalnew.cAcctNo = NewCoa.cAcctNo ;
						 AND BETWEEN(NewCoa.nAcctType, 8, 16) ;
						 AND NOT DELETED() ;
					 INTO CURSOR tempbeg
		
		         IF _TALLY > 0
		            SELECT tempbeg
		            GO TOP
		            m.nRetEarn = nRetEarn
		         ELSE
		            m.nRetEarn = 0
		         ENDIF
		
		*
		*  Plug in the new retained earnings number
		*
		         SELECT balance
		         SET ORDER TO Acct
		         IF SEEK(m.cRetEarn)
		            REPLACE nEndBal WITH nEndBal + (m.nRetEarn * -1)
		         ENDIF
		      ENDSCAN
		*!*	   ENDIF
		
		*
		*  Calculate the Current Earnings
		*
		   SELECT  SUM(coabalnew.nDebits - coabalnew.nCredits) AS nCurEarn, ;
				   NewCoa.nAcctType ;
			   FROM coabalnew, NewCoa ;
			   WHERE BETWEEN(NewCoa.nAcctType, 8, 16) ;
				   AND coabalnew.cyear = tcYear ;
				   AND coabalnew.cPeriod <= lcPeriod2 ;
				   AND coabalnew.cAcctNo = NewCoa.cAcctNo ;
				   AND NewCoa.lTotalAcct = .F. ;
				   AND NewCoa.lTitle     = .F. ;
				   AND NOT DELETED() ;
			   INTO ARRAY laCurEarn
		
		   IF _TALLY > 0
		      SELECT balance
		      SET ORDER TO Acct
		      IF SEEK(m.cCurEarn)
		         REPLACE nEndBal WITH nEndBal + (laCurEarn[1, 1] * -1)
		      ENDIF
		   ENDIF
		
		
		*
		*  Plug in the account descriptions and delete any non balance sheet
		*  accounts.
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      lnAcctType = nAcctType
		      swselect('glacctyp')
		      IF SEEK(lnAcctType)
		         SELECT balance
		         REPLACE cAcctType WITH glacctyp.cTypeDesc
		      ELSE
		         SELECT balance
		         REPLACE cAcctType WITH 'Unknown'
		      ENDIF
		      DO CASE
		         CASE BETWEEN(lnAcctType, 1, 3)
		            REPLACE cBalGroup WITH 'A'
		         CASE BETWEEN(lnAcctType, 4, 7)
		            REPLACE cBalGroup WITH 'B'
		         OTHERWISE
		            DELETE NEXT 1
		            LOOP
		      ENDCASE
		      SELECT balance
		*  Only delete if reporting on something other than 'All Levels' since the level processing will delete later on
		      IF NOT tlZero AND nEndBal = 0 AND cAcctNo <> m.cCurEarn AND NOT lTitle AND lcLevel <> '*'
		         DELETE NEXT 1
		         LOOP
		      ENDIF
		      
				IF llPrintNumbers
		         SELECT balance
		         REPLACE cacctdesc WITH cacctno + ' - ' + ALLTRIM(cacctdesc)
		      ENDIF 
		
		   ENDSCAN
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'StandardBal', loError.LINENO, 'Consolidated Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		WAIT CLEAR
		
		
	ENDPROC

	PROCEDURE subtotals
		LPARAMETERS llShowTotals
		
		**  Scan balance one more time.  This time, it's to sum up totals for each level, and determine when a total line should be printed.
		**  When scanning, we know that no total will need to be printed when the account levels are continually descending or staying at the same level.
		**  When the account level has gone back up (decreased), then we know we've got to print at least one total.  Possibly more, depending on the
		**  difference between the previous level and the current level.  For example, going from a level 5 account to a level 2 account would entail
		**  the possibility of having to print a total for the level 5, 4, and 3 accounts.
		LOCAL lTotalAcct, lcLastAcctNo, lcParent, lnCount, lnLastLevel, lnRecNo, lnRecNo2, lnTotal, lnTotal2
		LOCAL llReturn, loError
		*:Global tlCompare
		*:Global cAcctDesc, cAcctNo, cAcctType, cBalGroup, cSortField, nAcctType, nEndBal, nEndBal1
		*:Global nEndBal2, nLevel
		
		llReturn = .T.
		
		TRY
		   tlCompare    = THISFORM.chkComparative.VALUE
		
		   IF llShowTotals
		      STORE 0 TO lnLastLevel, lnTotal, lnTotal2
		      STORE '' TO lcLastAcctNo
		      WAIT WINDOW NOWAIT 'Counting Levels...'
		      SELECT balance
		      SET ORDER TO AcctNo
		      SCAN
		         lnRecNo      = RECNO()
		         m.cAcctNo    = ALLTRIM(cAcctNo)
		         m.lTotalAcct = .T.
		
		         IF nLevel < lnLastLevel  &&  We've started back up, so totals may need to be added, depending on the counts for each level
		            SELECT balance
		            lnCount  = 1
		            lnTotal  = 0
		            lnTotal2 = 0
		            LOCATE FOR cAcctNo = lcLastAcctNo
		            IF FOUND()  &&  Better find it, except for the first record...
		               lcParent = balance.cParent
		               SCAN FOR cParent = lcParent
		                  lnCount = lnCount + 1
		                  lnTotal = lnTotal + IIF(tlCompare, nEndBal1, nEndBal)
		                  IF tlCompare
		                     lnTotal2 = lnTotal2 + nEndBal2
		                  ENDIF
		               ENDSCAN
		
		               IF lnCount > 1
		                  SELECT balance
		                  LOCATE FOR cAcctNo = lcParent
		                  IF FOUND()  &&  Darn well better be...
		                     m.cAcctDesc  = balance.cAcctDesc
		                     m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                     m.nAcctType  = balance.nAcctType
		                     m.cBalGroup  = balance.cBalGroup
		                     m.cAcctType  = balance.cAcctType
		                     m.cAcctNo    = balance.cAcctNo
		                     m.nLevel     = balance.nLevel
		                     m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                     IF tlCompare
		                        m.nEndBal1 = lnTotal + balance.nEndBal1
		                        m.nEndBal2 = lnTotal2 + balance.nEndBal2
		                     ELSE
		                        m.nEndBal = lnTotal + balance.nEndBal  &&  Have to include the total for this specific account in the total, too
		                     ENDIF
		                     lnRecNo2 = RECNO()
		                     INSERT INTO balance FROM MEMVAR
		                     GOTO lnRecNo2
		                  ENDIF
		
		                  IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 4 accounts now
		                     SELECT balance
		                     lnCount  = 1
		                     lnTotal  = 0
		                     lnTotal2 = 0
		                     lcParent = balance.cParent
		                     SCAN FOR cParent = lcParent
		                        lnCount = lnCount + 1
		                        lnTotal = lnTotal + IIF(tlCompare, nEndBal1, nEndBal)
		                        IF tlCompare
		                           lnTotal2 = lnTotal2 + nEndBal2
		                        ENDIF
		                     ENDSCAN
		
		                     IF lnCount > 1
		                        SELECT balance
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()  &&  Darn well better be...
		                           m.cAcctDesc  = balance.cAcctDesc
		                           m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                           m.nAcctType  = balance.nAcctType
		                           m.cBalGroup  = balance.cBalGroup
		                           m.cAcctType  = balance.cAcctType
		                           m.cAcctNo    = balance.cAcctNo
		                           m.nLevel     = balance.nLevel
		                           m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                           IF tlCompare
		                              m.nEndBal1 = lnTotal + balance.nEndBal1
		                              m.nEndBal2 = lnTotal2 + balance.nEndBal2
		                           ELSE
		                              m.nEndBal = lnTotal + balance.nEndBal  &&  Have to include the total for this specific account in the total, too
		                           ENDIF
		                           lnRecNo2 = RECNO()
		                           INSERT INTO balance FROM MEMVAR
		                           GOTO lnRecNo2
		                        ENDIF
		
		                        IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 3 accounts now
		                           SELECT balance
		                           lnCount  = 1
		                           lnTotal  = 0
		                           lnTotal2 = 0
		                           lcParent = balance.cParent
		                           SCAN FOR cParent = lcParent
		                              lnCount = lnCount + 1
		                              lnTotal = lnTotal + IIF(tlCompare, nEndBal1, nEndBal)
		                              IF tlCompare
		                                 lnTotal2 = lnTotal2 + nEndBal2
		                              ENDIF
		                           ENDSCAN
		
		                           IF lnCount > 1
		                              SELECT balance
		                              LOCATE FOR cAcctNo = lcParent
		                              IF FOUND()  &&  Darn well better be...
		                                 m.cAcctDesc  = balance.cAcctDesc
		                                 m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                                 m.nAcctType  = balance.nAcctType
		                                 m.cBalGroup  = balance.cBalGroup
		                                 m.cAcctType  = balance.cAcctType
		                                 m.cAcctNo    = balance.cAcctNo
		                                 m.nLevel     = balance.nLevel
		                                 m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                                 IF tlCompare
		                                    m.nEndBal1 = lnTotal + balance.nEndBal1
		                                    m.nEndBal2 = lnTotal2 + balance.nEndBal2
		                                 ELSE
		                                    m.nEndBal = lnTotal + balance.nEndBal  &&  Have to include the total for this specific account in the total, too
		                                 ENDIF
		                                 lnRecNo2 = RECNO()
		                                 INSERT INTO balance FROM MEMVAR
		                                 GOTO lnRecNo2
		                              ENDIF
		
		                              IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 2 accounts now
		                                 SELECT balance
		                                 lnCount  = 1
		                                 lnTotal  = 0
		                                 lnTotal2 = 0
		                                 lcParent = balance.cParent
		                                 SCAN FOR cParent = lcParent
		                                    lnCount = lnCount + 1
		                                    lnTotal = lnTotal + IIF(tlCompare, nEndBal1, nEndBal)
		                                    IF tlCompare
		                                       lnTotal2 = lnTotal2 + nEndBal2
		                                    ENDIF
		                                 ENDSCAN
		
		                                 IF lnCount > 1
		                                    SELECT balance
		                                    LOCATE FOR cAcctNo = lcParent
		                                    IF FOUND()  &&  Darn well better be...
		                                       m.cAcctDesc  = balance.cAcctDesc
		                                       m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                                       m.nAcctType  = balance.nAcctType
		                                       m.cBalGroup  = balance.cBalGroup
		                                       m.cAcctType  = balance.cAcctType
		                                       m.cAcctNo    = balance.cAcctNo
		                                       m.nLevel     = balance.nLevel
		                                       m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                                       IF tlCompare
		                                          m.nEndBal1 = lnTotal + balance.nEndBal1
		                                          m.nEndBal2 = lnTotal2 + balance.nEndBal2
		                                       ELSE
		                                          m.nEndBal = lnTotal + balance.nEndBal  &&  Have to include the total for this specific account in the total, too
		                                       ENDIF
		                                       lnRecNo2 = RECNO()
		                                       INSERT INTO balance FROM MEMVAR
		                                       GOTO lnRecNo2
		                                    ENDIF
		                                 ENDIF
		                              ENDIF
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		
		         GOTO lnRecNo
		
		         lnLastLevel  = balance.nLevel
		         lcLastAcctNo = balance.cAcctNo
		      ENDSCAN
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'SubTotals', loError.LINENO, 'Consolidated Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		WAIT CLEAR
		
		
	ENDPROC

	PROCEDURE cboAccountType.Init
		THIS.ADDLISTITEM('**  All Account Levels  **',1,1)
		THIS.ADDLISTITEM('*',1,2)
		THIS.ADDLISTITEM('Level 1 Accounts',2,1)
		THIS.ADDLISTITEM('1',2,2)
		THIS.ADDLISTITEM('Level 2 Accounts and Above',3,1)
		THIS.ADDLISTITEM('2',3,2)
		THIS.ADDLISTITEM('Level 3 Accounts and Above',4,1)
		THIS.ADDLISTITEM('3',4,2)
		THIS.ADDLISTITEM('Level 4 Accounts and Above',5,1)
		THIS.ADDLISTITEM('4',5,2)
		
		THIS.LISTITEMID = 1
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cmdChoose.Click
		DO FORM glConsolidate
	ENDPROC

	PROCEDURE OpgQuarters.Init
		this.q1.value = 1
	ENDPROC

	PROCEDURE OpgQuarters.Q1.GotFocus
		THISFORM.opgQuarters.VALUE = 1
		
	ENDPROC

	PROCEDURE OpgQuarters.Q2.GotFocus
		THISFORM.opgQuarters.VALUE = 2
	ENDPROC

	PROCEDURE OpgQuarters.Q3.GotFocus
		THISFORM.opgQuarters.VALUE = 3
	ENDPROC

	PROCEDURE OpgQuarters.Q4.GotFocus
		THISFORM.opgQuarters.VALUE = 4
	ENDPROC

	PROCEDURE opgreportby.Valid
		
		DODEFAULT()
		
		IF this.value = 1
		   thisform.txtyear.enabled = .t.
		   thisform.txtperiod.enabled = .t.
		   thisform.opgquarters.q1.enabled = .f.
		   thisform.opgquarters.q2.enabled = .f.
		   thisform.opgquarters.q3.enabled = .f.
		   thisform.opgquarters.q4.enabled = .f.
		else
		   thisform.txtyear.enabled = .t.
		   thisform.txtperiod.enabled = .f.
		   thisform.opgquarters.q1.enabled = .t.
		   thisform.opgquarters.q2.enabled = .t.
		   thisform.opgquarters.q3.enabled = .t.
		   thisform.opgquarters.q4.enabled = .t.
		endif      
	ENDPROC

ENDDEFINE
