*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="glcloseyr.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="1" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 325
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 537

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\amdata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\amdata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\amdata\appdata.dbc, ;
		Height = 90, ;
		Left = 289, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\amdata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "sysctl", ;
		BufferModeOverride = 5, ;
		CursorSource = "sysctl", ;
		Database = ..\amdata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 139, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "sysctl1", ;
		CursorSource = "sysctl", ;
		Database = ..\amdata\appdata.dbc, ;
		Height = 90, ;
		Left = 288, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formglcloseyr AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Lbltextcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swyear1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: backup
		*m: closeyear		&& Closes the fiscal year.
		*p: oprogress
	*</DefinedPropArrayMethod>

	Caption = "Close Fiscal Accounting Year"
	DoCreate = .T.
	Height = 241
	HelpContextID = 553
	lcloseonescape = .T.
	Name = "FormGlcloseyr"
	Visible = .T.
	Width = 357
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Left = 336
	Mwresize1.Name = "Mwresize1"
	Mwresize1.Top = 216

	ADD OBJECT 'cmdClose' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Process", ;
		FontSize = 8, ;
		Height = 33, ;
		Left = 88, ;
		Name = "cmdClose", ;
		Top = 180, ;
		Width = 80
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Exit", ;
		FontSize = 8, ;
		Height = 33, ;
		Left = 180, ;
		Name = "cmdExit", ;
		Top = 180, ;
		Width = 80
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 19, ;
		Left = 240, ;
		Name = "Glmaint", ;
		Top = 0, ;
		Width = 77
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbltextcustom1' AS lbltextcustom WITH ;
		Caption = "Close Fiscal  Accounting Year:", ;
		FontSize = 8, ;
		Left = 96, ;
		Name = "Lbltextcustom1", ;
		Top = 60
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Swyear1' AS swyear WITH ;
		Height = 20, ;
		ldefvalue = .T., ;
		Left = 153, ;
		MaxLength = 4, ;
		Name = "Swyear1", ;
		Top = 80, ;
		Width = 37
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		IF DODEFAULT()
		   *
		   * Find first year that needs to be closed
		   *
		   swselect('sysctl')
		   SET ORDER to YEARCLOSE   && CYEAR+IIF(LYEARCLOSE,"Y","N")+CTYPECLOSE
		   GO TOP 
		   LOCATE FOR lYearClose
		   IF FOUND()
		      thisform.swyear1.setvalue(ALLTRIM(STR(VAL(sysctl.cYear)+1)))
		   ELSE
		      thisform.swyear1.setvalue(ALLTRIM(STR(YEAR(DATE()))))
		   ENDIF 
		ENDIF   
	ENDPROC

	PROCEDURE backup
		LOCAL lcDataPath, lcFileName, lcFolderName, lcBackupPath
		LOCAL lcFolder, lcSavePath, llReturn, lnError, loError
		*:Global tcYear
		
		llReturn = .T.
		
		TRY
		
		   tcYear    = THISFORM.swyear1.VALUE
		
		   m.goapp.closealldata()
		
		   IF TYPE('m.goApp') = 'O'
		      lcDataPath = ALLT(m.goapp.cDataFilePath)
		      IF NOT ':' $ lcDataPath AND NOT '\\' $ lcDataPath AND LEFT(lcDataPath, 1) <> '\'
		         lcSavePath = ALLT(CURDIR())
		         lcDataPath = SYS(5) + CURDIR() + lcDataPath
		      ENDIF
		      lcBackupPath = lcDataPath
		      lcFolderName = lcDataPath
		      lcDataPath   = '"' + lcDataPath + '*.*' + '"'
		   ELSE
		      lcBackupPath = ALLTRIM(GETDIR())
		      lcDataPath   = lcBackupPath + '*.*'
		   ENDIF
		
		   IF NOT '\' $ lcDataPath
		      lcDataPath = 'Data\*.*'
		   ENDIF
		
		* Create the backup folders if needed
		   IF NOT DIRECTORY(lcBackupPath + 'Archive')
		      MD (lcBackupPath + 'Archive')
		   ENDIF
		
		   lcBackupPath = lcBackupPath + 'Backups\'
		   lcFolder     = lcBackupPath
		   IF NOT DIRECTORY(lcBackupPath)
		      MD (lcBackupPath)
		   ENDIF
		
		   lcFileName   = 'Year-' + tcYear + ' - ' + ALLTRIM(STRTRAN(m.goapp.cCompanyName, ' ', '')) + '.zip'
		   lcBackupPath = ADDBS(lcBackupPath)
		
		* Create the backup
		   lnError = swbackup('B', lcFolderName, ALLTRIM(lcFileName), lcBackupPath)
		
		   DO CASE
		      CASE lnError = 0
		         WAIT WIND NOWAIT 'Backup Completed'
		         SET DATASESSION TO &lnSession
		      CASE lnError = 4
		         THISFORM.oMessage.DISPLAY('Backup Encountered Errors. Unable to create backup file.')
		      CASE lnError = 6
		         THISFORM.oMessage.DISPLAY('Backup Encountered Errors. Unable to compress file.')
		   ENDCASE
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Backup', loError.LINENO, 'GLCloseYr', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the fiscal year closing at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE closeyear		&& Closes the fiscal year.
		LOCAL tcYear, lcYear, oRegistry
		LOCAL jcYear, tcPeriod, m.cCurEarn, lcLastYr, lcLastYr1
		LOCAL llLastYrClosed
		LOCAL lcNextYr, lfyend, llReturn, lnBegBal, lnCount, lnCurEarn, lnEndBal, lnRecCount, loError
		LOCAL lyearclose
		*:Global cCurEarn, cFYBegin, cFiscalPrd, cFiscalYr, cGroup, cPeriod, cRetEarn, cTimeClose, cidsysctl
		*:Global ctypeclose, cyear, dAcctDate, dDate, dDateClose, nAmount, nCredits, nDebits
		
		llReturn = .T.
		
		TRY
		   tcYear = THISFORM.swYear1.VALUE
		
		   lcYear = THIS.glmaint.getperiod(DATE(), .T.)
		
		   oRegistry = findglobalobject('cmregistry')
		   
		   IF lcYear = tcYear
		      IF NOT THISFORM.omessage.CONFIRM("You are closing the current fiscal year. If you continue you won't be able to enter any more transactions this year. Do you want to continue?")
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   IF tcYear > lcYear
		      THISFORM.omessage.warning('You are trying to close a future fiscal year. Future years cannot be closed.')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   IF USED('tempyr')
		      SELECT tempyr
		      LOCATE FOR cyear == tcYear
		      IF NOT FOUND()
		         THISFORM.omessage.warning('There are no transactions in the G/L for this year. It cannot be closed.')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		*
		*  Check to see if the year is closed
		*
		   swselect('sysctl')
		   SET ORDER TO yearclose
		   IF SEEK(tcYear + 'Y')
		      THISFORM.omessage.warning('Fiscal Year ' + tcYear + ' is already closed.')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		*
		* Check to make sure all prior years are closed
		*
		   WAIT WINDOW NOWAIT 'Checking prior years...'
		   SELECT cyear FROM glmaster WHERE cyear > '1950' INTO CURSOR temp1 ORDER BY cyear GROUP BY cyear
		   SELECT temp1
		   SCAN FOR cyear < tcYear
		      lcYear = cyear
		      SELECT sysctl
		      LOCATE FOR cyear == lcYear AND lyearclose
		      IF NOT FOUND()
		         THISFORM.omessage.severe('Prior year ' + ALLTRIM(lcYear) + ' needs to be closed before this year can be closed.')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDSCAN
		   
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		
		
		*
		*  Ask to make sure the user wants to close this fiscal year.
		*
		   IF NOT THISFORM.omessage.CONFIRM('Are you sure you want to close fiscal year ' + tcYear + '?')
		      WAIT WIND NOWAIT 'Close of fiscal year ' + tcYear + ' cancelled...'
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   THISFORM.backup()
		
		   swselect('glopt')
		   swselect('glmaster', .T.)
		   swselect('sysctl', .T.)
		   swselect('coa')
		
		   lcLastYr  = STR(VAL(tcYear) - 1, 4)
		
		*
		*  Recalculate account balances
		*
		   WAIT WIND NOWAIT 'Calculating Accounting Balances....'
		   THISFORM.glmaint.calcbalance()
		
		*
		*  Make sure we have a good glopt record
		*
		   SELECT glopt
		   COUNT FOR NOT DELETED() TO lnRecCount
		   IF lnRecCount = 0
		      SELECT glopt
		      GO TOP
		      IF DELETED()
		         RECALL
		      ELSE
		         THISFORM.omessage.severe('Please setup the G/L Options in the Preferences before continuing.')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		*
		*  Get the current earnings account number.
		*
		   SELECT glopt
		   GO TOP
		   m.cCurEarn = cCurEarn
		   m.cRetEarn = cRetEarn
		   m.cFYBegin = cFYBegin
		   IF EMPTY(m.cFYBegin)
		      m.cFYBegin = '01'
		   ENDIF
		   m.lfyend   = lfyend
		
		*
		*  Create the balance cursor. (This is what report is printed from)
		*  If a comparative is to be calculated, change the cursor format.
		*
		   CREATE CURSOR balance  ;
		      (cAcctNo     C(6),    ;
		        cBalGroup   C(1),    ;
		        nAcctType   N(2),    ;
		        lTitle      L,       ;
		        lTotalAcct  L,       ;
		        cAcctType   C(25),   ;
		        cAcctDesc   C(30),   ;
		        cFiscalYr   C(4),    ;
		        cFiscalPrd  C(2),    ;
		        nBegBal     N(12, 2), ;
		        nDebits     N(12, 2), ;
		        nCredits    N(12, 2), ;
		        nEndBal     N(12, 2))
		   INDEX ON STR(nAcctType, 2) + cAcctNo TAG AcctNo
		   INDEX ON cAcctNo TAG Acct
		
		*
		*  Get the periods activity for each account in the range.
		*
		   SELE coabalnew
		   SCAN FOR coabalnew.cyear + coabalnew.cPeriod = tcYear + '12'
		      SCATTER MEMVAR
		      m.cFiscalYr  = m.cyear
		      m.cFiscalPrd = m.cPeriod
		      SELE coa
		      LOCATE FOR cAcctNo = m.cAcctNo
		      IF FOUND()
		         IF lTotalAcct
		            LOOP
		         ENDIF
		         IF lTitle
		            LOOP
		         ENDIF
		         SCATTER MEMVAR
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELE coa
		   SCAN FOR NOT lTotalAcct AND NOT lTitle
		      SCATTER MEMVAR
		      SELE balance
		      LOCATE FOR cAcctNo = m.cAcctNo
		      IF NOT FOUND()
		         STORE 0 TO m.nDebits, m.nCredits
		         m.cFiscalYr  = tcYear
		         m.cFiscalPrd = '12'
		         INSERT INTO balance FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		
		   SELE balance
		   lnCount = RECC()
		
		*
		*  If there were no records found, bail out.
		*
		   IF lnCount = 0
		      SELECT sysctl
		      m.cyear      = tcYear
		      m.lyearclose = .T.
		      m.dDateClose = DATE()
		      m.cTimeClose = TIME()
		      m.dAcctDate  = DATE()
		      m.cPeriod    = '12'
		      m.cGroup     = '00'
		      m.ctypeclose = 'A'
		      m.cidsysctl  = oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		      SET DELETED OFF
		      SELECT sysctl
		      SET ORDER TO cidsysctl
		      DO WHILE SEEK(m.cidsysctl)
		         m.cidsysctl = oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		      ENDDO
		      SET DELETED ON
		      INSERT INTO sysctl FROM MEMVAR
		      SELECT sysctl
		      = TABLEUPDATE(.T.)
		      THISFORM.omessage.warning('Fiscal year ' + tcYear + ' is now closed.')
		      llReturn = .T.
		      EXIT
		   ENDIF
		
		*
		*  Get the beginning balances for each account in the range.
		*
		   SELECT  coabalnew.cAcctNo, ;
				   SUM(nDebits) AS nDebits, ;
				   SUM(nCredits) AS nCredits ;
			   FROM coabalnew ;
			   WHERE coabalnew.cyear = tcYear ;
				   AND BETWEEN(coabalnew.cPeriod, '01', '11') ;
			   INTO CURSOR tempbeg ;
			   ORDER BY coabalnew.cAcctNo ;
			   GROUP BY coabalnew.cAcctNo
		
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		   IF _TALLY > 0
		      SELECT tempbeg
		      SCAN
		         SCATTER MEMVAR
		         lnBegBal = m.nDebits - m.nCredits
		         SELECT balance
		         SET ORDER TO Acct
		         IF SEEK(m.cAcctNo)
		*
		*  Only update balance sheet accounts
		*
		            lnEndBal = lnBegBal + nDebits - nCredits
		            REPLACE nBegBal WITH lnBegBal, ;
		               nEndBal WITH lnEndBal
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Plug in the ending balance numbers.
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      IF EMPTY(nBegBal)
		         REPLACE nEndBal WITH nDebits - nCredits, ;
		            nBegBal WITH 0
		      ENDIF
		   ENDSCAN
		
		   SELE coabalnew
		   SET ORDER TO 0
		   SELE coa
		   SET ORDER TO 0
		
		*
		*  Calculate the Current Earnings
		*
		   lnCurEarn = 0
		   SELE coabalnew
		   SCAN FOR coabalnew.cyear = tcYear ;
		         AND BETWEEN(coabalnew.cPeriod, '01', '12')
		      SCATTER MEMVAR
		      SELE coa
		      LOCATE FOR cAcctNo = m.cAcctNo
		      IF FOUND() AND BETWEEN(nAcctType, 8, 16) AND NOT coa.lTotalAcct AND NOT coa.lTitle
		         lnCurEarn = lnCurEarn + m.nDebits - m.nCredits
		      ENDIF
		   ENDSCAN
		
		   IF lnCurEarn <> 0
		      SELECT balance
		      SET ORDER TO Acct
		      IF SEEK(m.cCurEarn)
		         REPLACE nEndBal WITH nEndBal + (lnCurEarn * -1)
		      ENDIF
		   ENDIF
		
		   SELECT balance
		   SET ORDER TO AcctNo
		   GO TOP
		
		   lcNextYr = STR(VAL(tcYear) + 1, 4)
		
		   IF m.lfyend
		      lcNextYr = tcYear
		   ENDIF
		
		   DO CASE
		      CASE m.cFYBegin = '01'
		         m.dDate = CTOD('12/31/' + tcYear)
		      CASE m.cFYBegin = '02'
		         m.dDate = CTOD('01/31/' + lcNextYr)
		      CASE m.cFYBegin = '03'
		         m.dDate = CTOD('03/01/' + lcNextYr) - 1
		      CASE m.cFYBegin = '04'
		         m.dDate = CTOD('03/31/' + lcNextYr)
		      CASE m.cFYBegin = '05'
		         m.dDate = CTOD('04/30/' + lcNextYr)
		      CASE m.cFYBegin = '06'
		         m.dDate = CTOD('05/31/' + lcNextYr)
		      CASE m.cFYBegin = '07'
		         m.dDate = CTOD('06/30/' + lcNextYr)
		      CASE m.cFYBegin = '08'
		         m.dDate = CTOD('07/31/' + lcNextYr)
		      CASE m.cFYBegin = '09'
		         m.dDate = CTOD('08/31/' + lcNextYr)
		      CASE m.cFYBegin = '10'
		         m.dDate = CTOD('09/30/' + lcNextYr)
		      CASE m.cFYBegin = '11'
		         m.dDate = CTOD('10/31/' + lcNextYr)
		      CASE m.cFYBegin = '12'
		         m.dDate = CTOD('11/30/' + lcNextYr)
		   ENDCASE
		
		*
		*  Get the batch number for the G/L master entries to be
		*  created.
		*
		   THISFORM.glmaint.cbatch     = oRegistry.IncrementCounter('%Shared.Counters.Batch')
		   THISFORM.glmaint.dgldate    = m.dDate
		   THISFORM.glmaint.csource    = 'YE'
		   THISFORM.glmaint.cReference = 'Closed Year'
		   THISFORM.glmaint.cunitno    = ' '
		   THISFORM.glmaint.cdeptno    = ' '
		   THISFORM.glmaint.ccatcode   = ''
		   THISFORM.glmaint.cid        = ''
		   THISFORM.glmaint.cyear      = ' '
		   THISFORM.glmaint.cPeriod    = ' '
		
		*
		*  If we're not removing history transactions, enter offsetting
		*  entries to the G/L to remove income/expense amounts
		*  If we have removed history transactions, we don't need to enter
		*  balance forward entries for the income/expense accounts
		*
		
		   WAIT WIND NOWAIT 'Transferring current earnings to retained earnings...'
		   SELECT balance
		   SCAN FOR BETWEEN(nAcctType, 8, 16)   && Income/Expense type range is 8-12
		      THISFORM.glmaint.cAcctNo = cAcctNo
		      THISFORM.glmaint.nAmount = nEndBal * -1
		      THISFORM.glmaint.cDesc   = 'Balance Forward'
		      THISFORM.glmaint.updatebatch()
		   ENDSCAN
		
		*
		*  Change the retained earnings account to reflect the
		*  fiscal year's current earnings
		*
		   THISFORM.glmaint.cDesc   = 'Current Earnings'
		   THISFORM.glmaint.cAcctNo = m.cRetEarn
		
		   SELECT balance
		   SET ORDER TO Acct
		   IF SEEK(m.cCurEarn)
		      m.nAmount = nEndBal
		   ELSE
		      m.nAmount = 0
		   ENDIF
		
		   THISFORM.glmaint.nAmount = m.nAmount * -1
		
		   THISFORM.glmaint.updatebatch()
		
		   m.cidsysctl  = oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		
		   SELECT sysctl
		   SET DELE OFF
		   SET ORDER TO cidsysctl
		   DO WHILE SEEK(m.cidsysctl)
		      m.cidsysctl  = oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		   ENDDO
		   SET DELE ON
		
		   SELECT sysctl
		   m.cyear      = tcYear
		   m.lyearclose = .T.
		   m.dDateClose = DATE()
		   m.cTimeClose = TIME()
		   m.dAcctDate  = DATE()
		   m.cPeriod    = '12'
		   m.cGroup     = '00'
		   m.ctypeclose = 'A'
		   m.cidsysctl  = oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		   SET DELETED OFF
		   SELECT sysctl
		   SET ORDER TO cidsysctl
		   DO WHILE SEEK(m.cidsysctl)
		      m.cidsysctl = oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		   ENDDO
		   SET DELETED ON
		   INSERT INTO sysctl FROM MEMVAR
		
		   SELECT glmaster
		   TABLEUPDATE(.T.)
		   SELECT sysctl
		   TABLEUPDATE(.T.)
		
		   WAIT CLEAR
		   THISFORM.omessage.DISPLAY('Fiscal year ' + tcYear + ' has been closed.  No more entries can be made to this year without first re-opening it under Utilities >> Special Utilities.')
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'CloseYear', loError.LINENO, 'GLCloseYr', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the fiscal year closing at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		
		IF txnlevel() > 0
		   ROLLBACK
		ENDIF
		
		DODEFAULT(nerror,cmethod,nline)   
	ENDPROC

	PROCEDURE cmdClose.Click
		thisform.closeyear()
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

ENDDEFINE
