*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="csdisbd.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor19" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor20" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor21" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor22" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor23" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor24" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor25" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 651
	InitialSelectedAlias = "csdishdr"
	Left = 21
	Name = "Dataenvironment"
	Top = 209
	Width = 981

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "csdisdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "csdisdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 96, ;
		Left = 584, ;
		Name = "Cursor1", ;
		Order = "", ;
		Top = 119, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 314, ;
		Name = "Cursor10", ;
		Order = "glbatch", ;
		Top = 129, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 200, ;
		Name = "Cursor11", ;
		Top = 129, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "wells", ;
		BufferModeOverride = 1, ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 427, ;
		Name = "Cursor12", ;
		Order = "cwellid", ;
		Top = 5, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "expense", ;
		BufferModeOverride = 5, ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 578, ;
		Name = "Cursor13", ;
		Top = 255, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "expsusp", ;
		BufferModeOverride = 5, ;
		CursorSource = "expsusp", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 430, ;
		Name = "Cursor14", ;
		Top = 261, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 316, ;
		Name = "Cursor15", ;
		Top = 251, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "trangroup", ;
		CursorSource = "trangroup", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor16", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "custownvend", ;
		CursorSource = "custownvend", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor17", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor19' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 430, ;
		Name = "Cursor19", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "csdishdr", ;
		BufferModeOverride = 1, ;
		CursorSource = "csdishdr", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 545, ;
		Name = "Cursor2", ;
		Order = "date", ;
		Top = 7, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor20' AS cursor WITH ;
		Alias = "expense1", ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 710, ;
		Name = "Cursor20", ;
		Top = 260, ;
		Width = 97
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor21' AS cursor WITH ;
		Alias = "csdisdet1", ;
		CursorSource = "csdisdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 850, ;
		Name = "Cursor21", ;
		Top = 260, ;
		Width = 97
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor22' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 750, ;
		Name = "Cursor22", ;
		Top = 145, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor23' AS cursor WITH ;
		Alias = "wellinv", ;
		CursorSource = "wellinv", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 743, ;
		Name = "Cursor23", ;
		Top = 13, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor24' AS cursor WITH ;
		Alias = "afeopt", ;
		CursorSource = "afeopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 798, ;
		Name = "Cursor24", ;
		Top = 436, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor25' AS cursor WITH ;
		Alias = "allunits", ;
		CursorSource = "allunits", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 582, ;
		Name = "Cursor25", ;
		Top = 379, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "expcat", ;
		CursorSource = "expcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 66, ;
		Name = "Cursor4", ;
		Order = "ccatcode", ;
		Top = 143, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "vendor", ;
		BufferModeOverride = 1, ;
		CursorSource = "vendor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 199, ;
		Name = "Cursor5", ;
		Order = "cvendorid", ;
		Top = 7, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor6", ;
		Order = "cidchec", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "coa", ;
		BufferModeOverride = 1, ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 432, ;
		Name = "Cursor7", ;
		Order = "acctno", ;
		Top = 132, ;
		Width = 104
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "gldept", ;
		BufferModeOverride = 1, ;
		CursorSource = "gldept", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 312, ;
		Name = "Cursor8", ;
		Order = "cdeptno", ;
		Top = 7, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "othnames", ;
		CursorSource = "othnames", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 201, ;
		Name = "Cursor9", ;
		Top = 250, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Relation1' AS relation WITH ;
		ChildAlias = "csdisdet", ;
		ChildOrder = "cbatch", ;
		Name = "Relation1", ;
		ParentAlias = "csdishdr", ;
		RelationalExpr = "cbatch"
		*< END OBJECT: BaseClass="relation" />

ENDDEFINE

DEFINE CLASS formcsdisb AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtwastecode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcdispcode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCdeptdesc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcdisperm" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCCashacct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCitemdesc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCitemdesc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNextension" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCunitdesc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDpostdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLookUnit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLookDept" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcDeptNo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcUnitNo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAddr1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCcheckno" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCcheckno" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCinvnum2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCinvnum2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtdpostdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDentdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNcashamt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNcashamt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAddr2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAddr3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLookCat" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcCatCode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtDisbMemo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkPrintMemo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcProdYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLookCOA" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcProdPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtnSaltBBL" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLookID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAcctDesc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAcctNo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcOwnerName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtnExtension" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="List1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLookOwner" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDocument" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcOwnerID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtdEntDate2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grouptran" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblVoided" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: adddetail
		*m: calcext		&& Calculates the detail extension total
		*m: calctot		&& Calculates the Invoice Totals
		*m: checkhist		&& Checks to see if production or JIB period has been closed.
		*m: dmexpense		&& Create expense entries for the Disbursement Manager
		*m: editdetail		&& Moves a detail line from the grid to the detail area.
		*m: getaddr
		*m: getprice		&& Gets the price for the item based upon the price code passed.
		*m: lookcoa
		*m: setstate		&& Resets the form state for non bound controls so that the save button still works.
		*m: valterms		&& Validate Terms and Set Due Date and Disc Date based on the Terms
		*p: coldacct
		*p: laskedaboutid
		*p: lconfirm
		*p: ldeptrequired
		*p: lfoundid
		*p: linvestment		&& .T. if the well is an investment well.
		*p: lsendtoallocate
		*p: lsepclose		&& Separate close for revenue and Jibs.
		*p: lvalidwell		&& .T. if a valid well id was entered.
		*p: lwellrequired
		*p: nextension
		*p: nprice
		*p: nquantity
		*p: odist		&& Distproc object
	*</DefinedPropArrayMethod>

	Caption = "Cash Disbursements"
	cdisplayname = 
	clistexpression = cdishdr.cbatch
	cnavworkarea = csdishdr
	cworkarea = csdishdr
	DoCreate = .T.
	FontName = "Arial"
	Height = 482
	HelpContextID = 353
	laskedaboutid = .F.
	lexpliciteditmode = .F.
	lfoundid = .F.
	lsendtoallocate = .F.
	Name = "FormCsdisb"
	Visible = .T.
	Width = 632
	_memberdata = <VFPData>
		<memberdata name="lnodataentry" type="property" display="lNoDataEntry"/>
		<memberdata name="lsendtoallocate" type="property" display="lSendToAllocate"/>
		</VFPData>
	cmdatamanager.Left = 3
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 3
	cmdatamanager.Top = 5
	cmdatamanager.ZOrderSet = 0
	cmlookupmanager.Left = 20
	cmlookupmanager.Name = "cmlookupmanager"
	cmlookupmanager.Top = 6
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cboAcct' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		ColumnCount = 1, ;
		ControlSource = "csdishdr.ccashacct", ;
		FontName = "Courier New", ;
		Height = 20, ;
		Left = 252, ;
		lrequired = .T., ;
		Name = "cboAcct", ;
		TabIndex = 9, ;
		Top = 2, ;
		Width = 348, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkPrintMemo' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Print Notes on Check Stub", ;
		ControlSource = "csdishdr.lchkmemo", ;
		Left = 150, ;
		Name = "chkPrintMemo", ;
		TabIndex = 43, ;
		Top = 390, ;
		ZOrderSet = 33
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdDocument' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Document", ;
		Height = 29, ;
		Left = 288, ;
		Name = "cmdDocument", ;
		TabIndex = 17, ;
		TabStop = .F., ;
		Top = 84, ;
		Width = 75, ;
		ZOrderSet = 27
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLookCat' AS cmdcommandbuttoncustom WITH ;
		Alignment = 2, ;
		Caption = "Exp Code", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 388, ;
		Name = "cmdLookCat", ;
		TabIndex = 31, ;
		Top = 134, ;
		Width = 54, ;
		ZOrderSet = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLookCOA' AS cmdcommandbuttoncustom WITH ;
		Alignment = 2, ;
		Caption = "Account", ;
		FontName = "Tahoma", ;
		Height = 20, ;
		Left = 10, ;
		Name = "cmdLookCOA", ;
		TabIndex = 32, ;
		TabStop = .F., ;
		Top = 134, ;
		Width = 72, ;
		ZOrderSet = 36
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLookDept' AS cmdcommandbuttoncustom WITH ;
		Alignment = 2, ;
		Caption = "Dept", ;
		FontName = "Tahoma", ;
		Height = 20, ;
		Left = 448, ;
		Name = "cmdLookDept", ;
		TabIndex = 37, ;
		Top = 134, ;
		Width = 53, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLookID' AS swlookupbutton WITH ;
		Left = 115, ;
		Name = "cmdLookID", ;
		TabIndex = 15, ;
		Top = 2, ;
		ZOrderSet = 41
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLookOwner' AS cmdcommandbuttoncustom WITH ;
		Alignment = 2, ;
		Caption = "Allocate All To", ;
		Height = 20, ;
		Left = 219, ;
		Name = "cmdLookOwner", ;
		TabIndex = 24, ;
		Top = 210, ;
		ZOrderSet = 49
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLookUnit' AS cmdcommandbuttoncustom WITH ;
		Alignment = 2, ;
		Caption = " Well/Lease", ;
		FontName = "Tahoma", ;
		Height = 20, ;
		Left = 314, ;
		Name = "cmdLookUnit", ;
		TabIndex = 36, ;
		Top = 134, ;
		Width = 65, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtDisbMemo' AS edteditboxcustom WITH ;
		ControlSource = "csdishdr.mdisbmemo", ;
		FontName = "Courier New", ;
		Height = 64, ;
		Left = 60, ;
		Name = "edtDisbMemo", ;
		TabIndex = 42, ;
		Top = 413, ;
		Width = 564, ;
		ZOrderSet = 32
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="editbox" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 22, ;
		Left = 283, ;
		Name = "Glmaint", ;
		Top = 38, ;
		Width = 29
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Grouptran' AS grouptran WITH ;
		Height = 19, ;
		Left = 5, ;
		Name = "Grouptran", ;
		Top = 29, ;
		Width = 19
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Label1' AS label WITH ;
		AutoSize = .F., ;
		Caption = "ID:", ;
		Height = 17, ;
		Left = 11, ;
		Name = "Label1", ;
		TabIndex = 45, ;
		Top = 4, ;
		Width = 17, ;
		ZOrderSet = 43
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblCCashacct' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Cash Acct:", ;
		Height = 16, ;
		Left = 180, ;
		Name = "lblCCashacct", ;
		TabIndex = 33, ;
		Top = 4, ;
		Width = 56, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCcheckno' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Check Number", ;
		Height = 16, ;
		Left = 442, ;
		Name = "lblCcheckno", ;
		TabIndex = 38, ;
		Top = 32, ;
		Width = 72, ;
		ZOrderSet = 21
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCinvnum2' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Invoice Number", ;
		Height = 16, ;
		Left = 442, ;
		Name = "lblCinvnum2", ;
		TabIndex = 39, ;
		Top = 55, ;
		Width = 76, ;
		ZOrderSet = 23
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCitemdesc' AS lblfieldlabelcustom WITH ;
		Caption = "Item Description", ;
		FontName = "Tahoma", ;
		Height = 15, ;
		Left = 91, ;
		Name = "lblCitemdesc", ;
		TabIndex = 34, ;
		Top = 137, ;
		Width = 80, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDentdate' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Acct Date", ;
		Height = 16, ;
		Left = 442, ;
		Name = "lblDentdate", ;
		TabIndex = 40, ;
		Top = 100, ;
		Width = 50, ;
		ZOrderSet = 25
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDpostdate' AS lblfieldlabelcustom WITH ;
		Caption = "Post Date", ;
		Height = 16, ;
		Left = 442, ;
		Name = "lblDpostdate", ;
		TabIndex = 8, ;
		Top = 77, ;
		Width = 48, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Notes", ;
		Left = 18, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 44, ;
		Top = 412, ;
		ZOrderSet = 34
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Prod Period", ;
		Left = 15, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 29, ;
		Top = 212, ;
		ZOrderSet = 37
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		Caption = "/", ;
		FontSize = 10, ;
		Left = 103, ;
		Name = "Lbllabelcustom3", ;
		TabIndex = 30, ;
		Top = 211, ;
		ZOrderSet = 39
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNcashamt' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Total Amount", ;
		Height = 16, ;
		Left = 432, ;
		Name = "lblNcashamt", ;
		TabIndex = 41, ;
		Top = 390, ;
		Width = 65, ;
		ZOrderSet = 27
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNextension' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Amount", ;
		FontName = "Tahoma", ;
		Height = 15, ;
		Left = 578, ;
		Name = "lblNextension", ;
		TabIndex = 35, ;
		Top = 137, ;
		Width = 39, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblVoided' AS lblfieldlabelcustom WITH ;
		Caption = "VOIDED", ;
		FontSize = 32, ;
		ForeColor = 255,0,0, ;
		Height = 52, ;
		Left = 268, ;
		Name = "lblVoided", ;
		Top = 48, ;
		Visible = .F., ;
		Width = 167
		*< END OBJECT: ClassLib="..\..\dmie_rv\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'List1' AS listbox WITH ;
		ColumnCount = 6, ;
		ColumnWidths = "55,220,75,55,90,100", ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 133, ;
		Left = 3, ;
		Name = "List1", ;
		RowSource = "csdisdet.cacctno,cdesc,cunitno,ccatcode,cdeptno,nAmount", ;
		RowSourceType = 6, ;
		TabIndex = 47, ;
		Top = 250, ;
		Width = 624, ;
		ZOrderSet = 48
		*< END OBJECT: BaseClass="listbox" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		BackColor = 255,255,128, ;
		Height = 112, ;
		Left = 6, ;
		Name = "Shape1", ;
		Top = 126, ;
		Width = 624, ;
		ZOrderSet = 4
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'txtcAcctDesc' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 10, ;
		lreadonly = .T., ;
		Name = "txtcAcctDesc", ;
		TabIndex = 26, ;
		TabStop = .F., ;
		Top = 184, ;
		Width = 194, ;
		ZOrderSet = 42
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcAcctNo' AS txtquickfill WITH ;
		clistexpression = cacctno, ;
		clistworkarea = coa, ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 20, ;
		InputMask = "999999", ;
		Left = 10, ;
		MaxLength = 6, ;
		Name = "txtcAcctNo", ;
		TabIndex = 14, ;
		Top = 158, ;
		Width = 72, ;
		ZOrderSet = 44
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcAddr1' AS txttextboxcustom WITH ;
		Comment = "", ;
		ControlSource = " ", ;
		DisabledForeColor = 0,0,0, ;
		Height = 20, ;
		Left = 30, ;
		lreadonly = .F., ;
		Name = "txtcAddr1", ;
		TabIndex = 5, ;
		Top = 50, ;
		Width = 222, ;
		ZOrderSet = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcAddr2' AS txttextboxcustom WITH ;
		ControlSource = " ", ;
		DisabledForeColor = 0,0,0, ;
		Height = 20, ;
		Left = 30, ;
		lreadonly = .F., ;
		Name = "txtcAddr2", ;
		TabIndex = 6, ;
		Top = 73, ;
		Width = 222, ;
		ZOrderSet = 28
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcAddr3' AS txttextboxcustom WITH ;
		ControlSource = " ", ;
		DisabledForeColor = 0,0,0, ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 30, ;
		lreadonly = .F., ;
		Name = "txtcAddr3", ;
		TabIndex = 7, ;
		Top = 96, ;
		Width = 222, ;
		ZOrderSet = 29
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcCatCode' AS txtquickfill WITH ;
		clistexpression = ccatcode, ;
		clistworkarea = expcat, ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 389, ;
		MaxLength = 4, ;
		Name = "txtcCatCode", ;
		TabIndex = 18, ;
		Top = 158, ;
		Width = 49, ;
		ZOrderSet = 31
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCcheckno' AS txttextboxcustom WITH ;
		ControlSource = "csdishdr.ccheckno", ;
		Height = 21, ;
		Left = 526, ;
		MaxLength = 10, ;
		Name = "txtCcheckno", ;
		TabIndex = 10, ;
		Top = 30, ;
		Width = 95, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCdeptdesc' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		ControlSource = " ", ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 440, ;
		lreadonly = .T., ;
		MaxLength = 30, ;
		Name = "txtCdeptdesc", ;
		TabIndex = 28, ;
		TabStop = .F., ;
		Top = 184, ;
		Width = 177, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcDeptNo' AS txtquickfill WITH ;
		clistexpression = cdeptno, ;
		clistworkarea = gldept, ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 20, ;
		InputMask = "XXXXXXXX", ;
		Left = 442, ;
		Name = "txtcDeptNo", ;
		TabIndex = 19, ;
		Top = 158, ;
		Width = 61, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcdispcode' AS txttextboxcustom WITH ;
		Left = 515, ;
		Name = "txtcdispcode", ;
		TabIndex = 59, ;
		Top = 185, ;
		Visible = .F., ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcdisperm' AS txttextboxcustom WITH ;
		Left = 516, ;
		Name = "txtcdisperm", ;
		TabIndex = 59, ;
		Top = 184, ;
		Visible = .F., ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcID' AS txtquickfill WITH ;
		clistexpression = custownvend.cid, ;
		clistworkarea = custownvend, ;
		ControlSource = "csdishdr.cid", ;
		Format = "K!", ;
		lallowexceptions = .T., ;
		Left = 30, ;
		MaxLength = 10, ;
		Name = "txtcID", ;
		TabIndex = 2, ;
		Top = 2, ;
		Width = 79, ;
		ZOrderSet = 45
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCinvnum2' AS txttextboxcustom WITH ;
		ControlSource = "csdishdr.cinvnum", ;
		Height = 20, ;
		Left = 526, ;
		MaxLength = 10, ;
		Name = "txtCinvnum2", ;
		TabIndex = 11, ;
		Top = 53, ;
		Width = 95, ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCitemdesc' AS txttextboxcustom WITH ;
		Comment = "", ;
		ControlSource = " ", ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 87, ;
		MaxLength = 40, ;
		Name = "txtCitemdesc", ;
		TabIndex = 16, ;
		Top = 158, ;
		Width = 215, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcName' AS txtquickfill WITH ;
		clistexpression = cname, ;
		clistworkarea = othnames, ;
		ControlSource = "csdishdr.cname", ;
		Height = 20, ;
		lallowexceptions = .T., ;
		Left = 30, ;
		lreadonly = .F., ;
		MaxLength = 40, ;
		Name = "txtcName", ;
		TabIndex = 4, ;
		Top = 27, ;
		Width = 222, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcOwnerID' AS txtquickfill WITH ;
		clistexpression = cownerid, ;
		clistworkarea = investor, ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 301, ;
		MaxLength = 10, ;
		Name = "txtcOwnerID", ;
		TabIndex = 25, ;
		Top = 210, ;
		Width = 76, ;
		ZOrderSet = 51
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcOwnerName' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		Height = 20, ;
		Left = 396, ;
		Name = "txtcOwnerName", ;
		TabIndex = 46, ;
		Top = 210, ;
		Width = 221, ;
		ZOrderSet = 46
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcProdPeriod' AS txttextboxcustom WITH ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 75, ;
		Name = "txtcProdPeriod", ;
		TabIndex = 21, ;
		Top = 210, ;
		Width = 24, ;
		ZOrderSet = 38
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcProdYear' AS txttextboxcustom WITH ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 111, ;
		MaxLength = 4, ;
		Name = "txtcProdYear", ;
		TabIndex = 22, ;
		Top = 210, ;
		Width = 45, ;
		ZOrderSet = 35
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCunitdesc' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		ControlSource = " ", ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 214, ;
		lreadonly = .T., ;
		MaxLength = 30, ;
		Name = "txtCunitdesc", ;
		TabIndex = 27, ;
		TabStop = .F., ;
		Top = 184, ;
		Width = 216, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcUnitNo' AS txtquickfill WITH ;
		clistexpression = cunitno, ;
		clistworkarea = allunits, ;
		FontName = "Courier New", ;
		FontSize = 8, ;
		Format = "!", ;
		Height = 20, ;
		InputMask = "XXXXXXXXXX", ;
		lallowexceptions = .T., ;
		Left = 308, ;
		MaxLength = 10, ;
		Name = "txtcUnitNo", ;
		TabIndex = 17, ;
		Top = 158, ;
		Width = 77, ;
		ZOrderSet = 18
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtdEntDate2' AS dpk WITH ;
		ControlSource = "csdishdr.ddate", ;
		Height = 20, ;
		lcheckdate = .T., ;
		Left = 526, ;
		Name = "txtdEntDate2", ;
		TabIndex = 13, ;
		Top = 97, ;
		Width = 75, ;
		ZOrderSet = 53
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtdpostdate' AS dpk WITH ;
		ControlSource = "csdishdr.dpostdate", ;
		Height = 20, ;
		lcheckdate = .T., ;
		Left = 526, ;
		lmorethan90 = .T., ;
		Name = "txtdpostdate", ;
		TabIndex = 12, ;
		Top = 75, ;
		Width = 75, ;
		ZOrderSet = 24
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNcashamt' AS txttextboxcustom WITH ;
		ControlSource = "csdishdr.ncashamt", ;
		Height = 21, ;
		InputMask = "999999999.99", ;
		Left = 509, ;
		lrequired = .T., ;
		Name = "txtNcashamt", ;
		ReadOnly = .F., ;
		TabIndex = 1, ;
		TabStop = .F., ;
		Top = 387, ;
		Width = 95, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtnExtension' AS txttextboxcustom WITH ;
		Height = 20, ;
		InputMask = "9999999.99", ;
		Left = 515, ;
		Name = "txtnExtension", ;
		TabIndex = 20, ;
		Top = 158, ;
		Width = 102, ;
		ZOrderSet = 47
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtnSaltBBL' AS txttextboxcustom WITH ;
		Alignment = 3, ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 159, ;
		Name = "txtnSaltBBL", ;
		TabIndex = 23, ;
		Top = 210, ;
		Value = 0, ;
		Visible = .F., ;
		Width = 36, ;
		ZOrderSet = 40
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtwastecode' AS txttextboxcustom WITH ;
		Left = 515, ;
		Name = "txtwastecode", ;
		TabIndex = 59, ;
		Top = 185, ;
		Visible = .F., ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		IF DODEFAULT()
		   IF TYPE('thisform.txtnExtension.value') <> 'N'
		      THISFORM.txtnExtension.VALUE = 0
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE adddetail
		*
		*  Adds the detail line to the csdisdet table
		*
		
		LOCAL m.cItemDesc, m.cAcctNo, m.cUnitno, m.cDeptNo, m.nExtension, m.cidpurd, m.cBatch
		
		m.cBatch = csdishdr.cBatch
		
		* Setup the default property lSendToAllocate
		THISFORM.lSendToAllocate = m.goApp.lSendToAllocate
		
		WITH THIS
		   m.nAmount     = .txtnExtension.VALUE
		   m.cDesc       = .txtcItemDesc.VALUE
		   m.cAcctNo     = .txtcAcctno.VALUE
		   m.cUnitno     = .txtcUnitno.VALUE
		   m.cCatCode    = .txtcCatCode.VALUE
		   m.cDeptNo 	  = .txtcDeptno.VALUE
		   m.nSaltBBL    = .txtnSaltBBL.VALUE
		   m.cProdYear   = .txtcProdYear.VALUE
		   m.cProdPeriod = .txtcProdPeriod.VALUE
		   m.cOwnerID    = .txtcOwnerID.VALUE
		   m.cDisperm    = .txtcDisperm.VALUE
		   m.cdispcode   = .txtcdispCode.VALUE
		   m.cWasteCode  = .txtwastecode.VALUE
		
		   * Check Water hauling variables for NULL
		   IF ISNULL(m.nSaltBBL)
		      m.nSaltBBL = 0
		   ENDIF 
		   IF ISNULL(m.cDisperm)
		      m.cDisperm = ''
		   ENDIF
		   IF ISNULL(m.cDispcode)
		      m.cDispcode = ''
		   ENDIF
		   IF ISNULL(m.cWasteCode)
		      m.cWasteCode = ''
		   ENDIF
		   
		   *
		   *  Get the group for the given well
		   *
		   SELE wells
		   LOCATE FOR cWellID = m.cUnitno
		   IF FOUND()
		      m.cGroup = cGroup
		   ELSE
		      m.cGroup = '00'
		   ENDIF
		
		   *
		   *  Check to see if the given production period is closed
		   *
		   IF NOT EMPTY(m.cProdYear) AND NOT EMPTY(m.cProdPeriod)
		      SELE expense
		      LOCATE FOR cBatch = m.cBatch AND (nRunNoRev <> 0 OR nRunNoJIB <> 0)
		      IF FOUND()
		         THIS.omessage.warning('The run no this expense is being allocated to is closed. No changes can be made.')
		         THIS.setnextcontrol(.txtcProdPeriod)
		         RETURN
		      ENDIF
		   ENDIF
		
		   IF m.nAmount = 0
		      THISFORM.omessage.warning('Detail lines must contain an amount greater than zero.')
		      THISFORM.setnextcontrol(.txtnExtension)
		      RETURN
		   ENDIF
		
		   IF EMPTY(m.cAcctNo)
		      THISFORM.omessage.warning('Detail lines must have an account number associated with them.')
		      THISFORM.setnextcontrol(.txtcAcctno)
		      RETURN
		   ENDIF
		
		   IF EMPTY(m.cUnitno) AND THISFORM.lWellRequired
		      THISFORM.omessage.DISPLAY('%msgWellRequired')
		      THISFORM.setnextcontrol(.txtcUnitno)
		      RETURN
		   ENDIF
		
		   IF EMPTY(m.cDeptNo) AND THISFORM.lDeptRequired
		      THISFORM.omessage.DISPLAY('%msgDeptRequired')
		      THISFORM.setnextcontrol(.txtcDeptno)
		      RETURN
		   ENDIF
		
		   IF NOT EMPTY(m.cOwnerID) AND NOT EMPTY(m.cUnitno) AND NOT EMPTY(m.cCatCode)  &&  Check to make sure this owner has an interest in this well
		      IF m.cUnitno <> 'ALLOC'
		         SELECT wellinv
		         LOCATE FOR cOwnerID = m.cOwnerID AND cWellID = m.cUnitno
		         IF NOT FOUND()
		            THISFORM.omessage.warning('You cannot allocate a well expense to an owner that has no interests in that well.')
		            RETURN .F.
		         ENDIF
		      ELSE
		         SELE wellsel
		         SCAN
		            m.cWellID = cWellID
		            SELECT wellinv
		            LOCATE FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		            IF NOT FOUND()
		               THISFORM.omessage.warning('You cannot allocate a well expense to an owner that has no interests in well: ' + m.cWellID)
		               RETURN .F.
		            ENDIF
		         ENDSCAN
		      ENDIF
		   ENDIF
		
		   IF NOT EMPTY(m.cUnitno) AND NOT EMPTY(m.cCatCode) AND NOT EMPTY(m.cProdYear) AND NOT EMPTY(m.cProdPeriod) AND m.cUnitno <> 'ALLOC'
		      IF NOT THISFORM.lSendToAllocate
		         *  Make sure the well has owners
		         SELECT cWellID FROM wellinv WHERE cWellID = m.cUnitno INTO ARRAY temp
		         IF _TALLY = 0
		            THISFORM.omessage.warning('Unable to allocate to this period for well: ' + m.cUnitno + ' This well has no owners. Expenses will be sent to unallocated file.')
		            THISFORM.lSendToAllocate = .T.
		         ENDIF
		      ENDIF
		   ENDIF
		
		
		   m.nDiscPct   = 0
		   m.nItemTax   = 0
		   m.nInterest  = 0
		   m.cTaxCode   = ' '
		   m.dExpDate   = {}
		   m.nDiscount  = 0
		   m.cExtDesc   = 0
		
		   IF m.cUnitno = 'ALLOC'
		      SELECT wellsel
		      lnCount = RECC()
		      lnRec   = 0
		      IF lnCount > 0
		         *  Calculate how much should go to each well.
		         lnAmount = ROUND((m.nAmount / lnCount),2)
		         *  Calculate the amount left over in case the amount didn't divide evenly among the wells
		         lnWellEnd = m.nAmount - (lnAmount * lnCount)
		         WAIT WIND NOWAIT 'Allocating the expenses evenly among the chosen wells...'
		         SCAN
		            m.cUnitno = cWellID
		            m.nAmount = lnAmount
		            m.cOwnerID = ''
		            lnRec = lnRec + 1
		            IF lnRec = lnCount
		               *  Adjust the last well so the total adds to the amount entered.
		               m.nAmount = m.nAmount + lnWellEnd
		            ENDIF
		            SET DELETED OFF
		            m.ciddisd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Disbursement Detail')
		            SELECT csdisdet1
		            SET ORDER TO ciddisd
		            DO WHILE SEEK(m.ciddisd)
		               m.ciddisd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Disbursement Detail')
		            ENDDO
		            SET DELETED ON
		            m.cBatch = csdishdr.cBatch
		
		            INSERT INTO csdisdet FROM MEMVAR
		         ENDSCAN
		         WAIT CLEAR
		      ELSE
		         THISFORM.omessage.warning('There must be at least 1 well chosen when ALLOC is used.')
		         THISFORM.setnextcontrol(.txtcUnitno)
		         RETURN
		      ENDIF
		   ELSE
		      SET DELETED OFF
		      m.ciddisd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Disbursement Detail')
		      SELECT csdisdet1
		      SET ORDER TO ciddisd
		      DO WHILE SEEK(m.ciddisd)
		         m.ciddisd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Disbursement Detail')
		      ENDDO
		      SET DELETED ON
		      m.cBatch = csdishdr.cBatch
		      INSERT INTO csdisdet FROM MEMVAR
		   ENDIF
		   .txtcItemDesc.VALUE = ' '
		   .txtnExtension.SetValue(0)
		   .txtcAcctno.VALUE = ' '
		   .txtcUnitno.VALUE = ' '
		   .txtcDeptno.VALUE = ' '
		   .txtcAcctDesc.VALUE = ' '
		   .txtcUnitDesc.VALUE = ' '
		   .txtcDeptDesc.VALUE = ' '
		   .txtcCatCode.VALUE  = ' '
		   .txtnSaltBBL.VALUE = 0
		   .txtcdispCode.VALUE = ''
		   .txtwastecode.VALUE = ''
		   .txtcDisperm.VALUE = ''
		   .txtcOwnerID.VALUE = ' '
		   .txtcOwnerName.VALUE = ' '
		   .txtcAcctno.SETFOCUS()
		   .lValidWell = .F.
		   .lInvestment = .F.
		   .CalcTot()
		   .SetState()
		   .lChanged = .T.
		   .list1.REQUERY()
		   .list1.REFRESH()
		   m.goStateManager.RefreshAll('Form Edit')
		   .REFRESH()
		ENDWITH
		
		
	ENDPROC

	PROCEDURE calcext		&& Calculates the detail extension total
	ENDPROC

	PROCEDURE calctot		&& Calculates the Invoice Totals
		*
		*  Calculates the invoice totals
		*
		
		LOCAL lnSelect, lnRecno, lnTotal, lcBatch, lnSubTotal, lnBalance
		
		lcBatch = csdisdet.cbatch
		
		lnSelect = SELECT()
		SELECT csdisdet
		lnRecno = RECNO()
		SUM(nAmount) TO lnTotal FOR cbatch == lcBatch
		
		IF lnRecno <= RECCOUNT()
			GOTO (lnRecno)
		ENDIF
		
		SELECT (lnSelect)
		
		IF csdishdr.ncashamt <> lnTotal
		   THIS.cmdatamanager.REPLACE('csdishdr', 'nCashAmt', lnTotal)
		   THISFORM.txtnCashamt.REFRESH()
		ENDIF   
		
		
	ENDPROC

	PROCEDURE checkhist		&& Checks to see if production or JIB period has been closed.
		Lpara tcYear, tcPeriod, tcGroup, tcWellID
		Local llHist, llSepClose, lcDeleted
		*
		*  Checks to see if the given period is closed
		*  Returns .T. if the period is closed
		*
		
		lcDeleted = SET('DELETED')
		Set DELETED ON
		
		llHist = .F.
		
		*
		*  Check to see if there are any JIB owners in the well. We need to check to see if the JIB period
		*  is closed if there are JIB owners. Otherwise, we check the revenue period 'cause it means we're
		*  netting expenses from revenue.
		*
		Sele wellinv
		Locate FOR cWellID = tcWellID AND lJIB = .T.
		If FOUND()
			llJIB = .T.
		Else
			llJIB = .F.
		Endif
		
		If llJIB
			If tcGroup = '**'
				Select sysctl
				Locate FOR cyear+cperiod = tcYear+tcPeriod AND lDisbMan AND cTypeClose = 'J'
				If FOUND()
					llHist = .T.
				Endif
			Else
				Select sysctl
				Set ORDER TO yrprdgrp
				If SEEK(tcYear+tcPeriod+tcGroup+'YJ')
					llHist = .T.
				Endif
			Endif
		Else
			If tcGroup = '**'
				Select sysctl
				Locate FOR cyear+cperiod = tcYear+tcPeriod AND lDisbMan AND cTypeClose = 'R'
				If FOUND()
					llHist = .T.
				Endif
			Else
				Select sysctl
				Set ORDER TO yrprdgrp
				If SEEK(tcYear+tcPeriod+tcGroup+'YR')
					llHist = .T.
				Endif
			Endif
		
		Endif
		Set DELETED &lcDeleted
		
		Return (llHist)
		
	ENDPROC

	PROCEDURE Deactivate
		ON KEY LABEL f2 *
		DODEFAULT()
	ENDPROC

	PROCEDURE Destroy
		thisform.grouptran.unload()
		DODEFAULT()
	ENDPROC

	PROCEDURE dmexpense		&& Create expense entries for the Disbursement Manager
		LOCAL lcBatch, lcYear, lcPeriod, lcWellStat, m.cOwnerID
		*
		*  Adds the expense entries to the disbursement manager EXPSUSP or
		*  EXPENSE tables depending on whether the production year and
		*  period are specified.
		*
		
		*
		*  Call distproc to create the (invtmp) and (wellwork) cursors
		*
		SELECT wells
		SET ORDER TO cWellID
		GO TOP
		lcWellID1 = cWellID
		GO BOTT
		lcWellID2 = cWellID
		
		sele afeopt
		GO TOP
		llAllocexp = lAllocexp
		
		lcBatch = csdishdr.cBatch
		m.cvendorid  = csdishdr.cid
		m.dExpDate   = csdishdr.ddate
		m.cidchec    = csdishdr.cidchec
		
		*  Check to see if the expenses have been closed
		IF NOT checkexp(lcBatch)
		   RETURN .F.
		ENDIF
		
		*  Delete any expenses found in the allocation file with this batch number.
		SELECT expsusp
		SCAN FOR cBatch == lcBatch
		   DELE NEXT 1
		ENDSCAN
		
		* Delete any expenses found in the expense table with this batch number.
		SELECT expense
		SCAN FOR cBatch == lcBatch
		   DELE NEXT 1
		ENDSCAN
		
		lcYear       = THISFORM.glmaint.getperiod(m.dExpDate,.T.)
		lcPeriod     = THISFORM.glmaint.getperiod(m.dExpDate,.F.)
		m.crefid     = csdishdr.ccheckno
		m.cPayee     = THISFORM.txtcName.VALUE
		m.lAPTran    = .T.
		m.cBatch     = lcBatch
		m.dPostDate  = csdishdr.ddate
		m.cMemo      = ''
		m.cPaidByCk  = m.cidchec
		m.cPrdPaid   = ''
		m.lFixed     = .F.
		m.lClosed    = .F.
		m.lAllocated = .F.
		m.nRunNoRev  = 0
		m.nRunNoJIB  = 0
		m.cRunYearRev = ''
		m.cRunYearJIB = ''
		
		SELECT csdisdet
		SCAN FOR cBatch == lcBatch AND NOT EMPTY(cUnitNo) AND NOT EMPTY(cCatCode)
		   SCATTER MEMVAR
		
		   *
		   *  Don't process any non-well expenses
		   *
		   SELECT wells
		   SET ORDER TO cWellID
		   IF NOT SEEK(m.cUnitNo)
		      LOOP
		   else
		     lcWellStat = wells.cWellStat  &&  Store current well status, so we know whether to send it to the allocation file or not
		   ENDIF
		
		   *
		   *  Don't process any expenses that aren't tied
		   *  to a valid expense category code
		   *
		   SELECT expcat
		   SET ORDER TO cCatCode
		   IF NOT SEEK(m.cCatCode)
		      LOOP
		   ELSE
		      IF lAFEType and NOT llAllocExp
		         LOOP
		      ENDIF   
		      m.cCateg = cCateg
		      m.cExpClass = cExpClass
		   ENDIF
		
		   * Adjust amount for dummy owners
		   m.nAmount = swNetExp(m.nAmount, m.cUnitNo, .F., m.cExpClass, 'B')
		
		   m.cYear   = m.cProdYear
		   m.cPeriod = m.cProdPeriod
		
		   m.cWellID    = m.cUnitNo
		   m.nSaltWater = m.nSaltBBL
		
		   IF NOT EMPTY(m.cOwnerID)
		      m.lOneMan = .T.
		   ELSE
		      m.lOneMan = .F.
		   ENDIF
		   
		   IF NOT EMPTY(m.cOwnerID)  &&  Change all one-man items to class 0
		      m.cExpClass = '0'
		   ENDIF 
		
		   IF (NOT EMPTY(m.cProdYear) AND NOT EMPTY(m.cProdPeriod)) AND not THISFORM.lSendtoAllocate and not inlist(lcWellStat,'I','S','P')
		      m.cidexph = ''
		      m.cidexpe = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Expense')
		      SET DELE OFF
		      SELE expense
		      SET ORDER TO cidexpe
		      DO WHILE SEEK(m.cidexpe)
		         m.cidexpe = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Expense')
		      ENDDO
		      SET DELE ON
		      m.cYear   = m.cProdYear
		      m.cPeriod = m.cProdPeriod
		      INSERT INTO expense FROM MEMVAR
		   ELSE
		      m.cidexps    = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Expense')
		      SET DELE OFF
		      SELE expsusp
		      SET ORDER TO cidexps
		      DO WHILE SEEK(m.cidexps)
		         m.cidexps = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Expense')
		      ENDDO
		      SET DELE ON
		      INSERT INTO expsusp FROM MEMVAR
		   ENDIF
		ENDSCAN
		
		RETURN .T.
		
	ENDPROC

	PROCEDURE editdetail		&& Moves a detail line from the grid to the detail area.
		WITH THISFORM
		   .txtcAcctNo.VALUE     = csdisdet.cacctno
		   .txtcItemDesc.VALUE   = csdisdet.cdesc
		   .txtcUnitNo.VALUE     = csdisdet.cUnitNo
		   .txtcCatCode.VALUE    = csdisdet.ccatcode
		   .txtcDeptNo.VALUE     = csdisdet.cDeptNo
		   .txtnExtension.setvalue(csdisdet.nAmount)
		   .txtcProdYear.VALUE   = csdisdet.cProdYear
		   .txtcProdPeriod.VALUE = csdisdet.cProdPeriod
		   .txtcOwnerID.VALUE    = csdisdet.cOwnerID
		   .txtnSaltBBL.VALUE    = csdisdet.nSaltBBL
		
		* Fill in the account description
		   SELECT coa
		   SET ORDER TO acctno
		   IF SEEK(csdisdet.cacctno)
		      .txtcAcctDesc.VALUE = coa.cacctdesc
		   ENDIF
		
		*  Fill in the well name
		   SELECT wells
		   SET ORDER TO cwellid
		   IF SEEK(csdisdet.cUnitNo)
		      .txtcUnitDesc.VALUE = wells.cwellname
		      .lValidWell = .T.
		   ENDIF
		
		*  Fill in the category name
		   SELECT expcat
		   SET ORDER TO ccatcode
		   IF SEEK(csdisdet.ccatcode)
		      .txtcDeptDesc.VALUE = expcat.ccateg
		   ENDIF
		
		*  Fill in the owner name
		   IF NOT EMPTY(csdisdet.cOwnerID)
		      SELECT investor
		      SET ORDER TO cOwnerID
		      IF SEEK(csdisdet.cOwnerID)
		         THISFORM.txtcOwnerName.SET('value',investor.cOwnName)
		      ENDIF
		   ELSE
		      THISFORM.txtcOwnerName.SET('value','')
		   ENDIF
		
		   .txtcAcctNo.SETFOCUS()
		
		   *  Delete the current check, if there is one.
		   *  If this is an update to the payment, we
		   *  don't want duplicate checks to show up in
		   *  the register
		   THISFORM.glmaint.delcheck(csdisdet.cidchec)
		   
		   SELECT csdisdet
		   THISFORM.cmdatamanager.deleterecord('Csdisdet')
		   this.list1.requery()
		   this.list1.refresh()
		   THISFORM.calctot()
		   THISFORM.REFRESH()
		ENDWITH
		
		*
		*  Let the form know something changed
		*
		THISFORM.setstate()
		
	ENDPROC

	PROCEDURE getaddr
		LOCAL lnSelect, lcText
		
		lnSelect = SELECT()
		THISFORM.txtcID.REFRESH()
		
		SELECT custownvend
		LOCATE FOR cID = THISFORM.txtcID.VALUE
		IF FOUND()
		   WITH THISFORM
		      .txtcAddr1.set('enabled',.f.)  &&  Make the address invisible if the ID selected is found in the system, otherwise, let them enter it
		      .txtcAddr2.set('enabled',.f.)
		      .txtcAddr3.set('enabled',.f.)
		      .txtcAddr1.VALUE = cAddr1
		      .txtcAddr2.VALUE = STRTRAN(cAddr2,'  ',' ')
		      lcText = STRTRAN(cAddr3,'  ',' ')
		      lcText = STRTRAN(lcText,'  ',' ')
		      .txtcAddr3.VALUE = STRTRAN(lcText,'  ',' ')
		      .lFoundID = .t.
		   ENDWITH
		ELSE
		   WITH THISFORM
		      .txtcName.REFRESH()
		      .txtcAddr1.set('enabled',.t.)  &&  Make the address invisible if the ID selected is found in the system, otherwise, let them enter it
		      .txtcAddr2.set('enabled',.t.)
		      .txtcAddr3.set('enabled',.t.)
		      .lFoundID = .f.
		      IF NOT EMPTY(.txtcName.VALUE)
		         SELECT othnames
		         SET ORDER TO cname
		         IF SEEK(TRIM(UPPER(.txtcName.VALUE)))
		            .txtcAddr1.VALUE = othnames.cAddr1
		            lcText = STRTRAN(othnames.cAddr2,'  ',' ')
		            .txtcAddr2.VALUE = STRTRAN(lcText,'  ',' ')
		            lcText = STRTRAN(othnames.cAddr3,'  ',' ')
		            .txtcAddr3.VALUE = STRTRAN(lcText,'  ',' ')
		         ELSE
		            .txtcName.VALUE = ""
		            .txtcAddr1.VALUE = ""
		            .txtcAddr3.VALUE = ""
		            .txtcAddr2.VALUE = ""
		         ENDIF
		      ELSE
		         .txtcName.VALUE = ""
		         .txtcAddr1.VALUE = ""
		         .txtcAddr3.VALUE = ""
		         .txtcAddr2.VALUE = ""
		      ENDIF
		   ENDWITH
		
		ENDIF
		
		SELECT (lnSelect)
		
		WITH THISFORM
		   .txtcName.REFRESH()
		   .txtcAddr1.REFRESH()
		   .txtcAddr2.REFRESH()
		   .txtcAddr3.REFRESH()
		ENDWITH
		
		
	ENDPROC

	PROCEDURE getprice		&& Gets the price for the item based upon the price code passed.
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   SELECT options
		   GO TOP
		   THIS.lSepClose = lSepClose
		   SET SAFETY OFF
		   SELE allunits
		   INDEX ON cunitno TAG cunitno
		   INDEX ON cname TAG cname
		   SET SAFETY ON
		   
		   IF m.goApp.lDocuments
		      thisform.AddObject('oFileDialog','sffiledialog')
		      thisform.cmdDocument.visible = .t.
		   ELSE
		      thisform.cmdDocument.visible = .f.
		   ENDIF 
		
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF nKeyCode = 3 OR nKeyCode = 18
		   thisform.List1.SetFocus
		ENDIF 
		
		DODEFAULT(nKeyCode, nShiftAltCtrl)
		
	ENDPROC

	PROCEDURE list
		LPARAMETERS cworkarea
		LOCAL lcList, lnRecNo
		PRIV llOK
		
		IF USED('lookuptmp')
		   USE IN lookuptmp
		ENDIF
		IF USED('lookuptmp1')
		   USE IN lookuptmp1
		ENDIF
		
		llOK = .T.
		lcList = 'cBatch\Batch,ddate\Date,ccheckno\Check No,cid\ID,cname\Name,ncashamt\Amount'
		
		IF THIS.FlushControlBuffer() AND THIS.beforenav('Csdishdr')
		
		   SELECT cBatch,ddate,ccheckno,cid,cname,ncashamt,.F. AS junk FROM csdishdr INTO CURSOR lookuptmp1
		   USE DBF('lookuptmp1') AGAIN IN 0 ALIAS lookuptmp EXCL
		   SELECT lookuptmp
		   INDEX ON cBatch    TAG cBatch
		   INDEX ON ddate     TAG ddate
		   INDEX ON ccheckno  TAG ccheckno
		   INDEX ON cid       TAG cid
		   INDEX ON cname     TAG cname
		   INDEX ON ncashamt  TAG ncashamt
		
		   DO FORM ..\CUSTOM\picklist WITH 'lookuptmp', lcList, csdishdr.cBatch, 6,.T.,.T.
		
		   IF llOK
		      SELECT csdishdr
		      LOCATE FOR cBatch = lookuptmp.cBatch
		      THISFORM.cmdatamanager.setrecordposition('Csdishdr')
		      THISFORM.REFRESH()
		   ENDIF
		ELSE
		   RETURN
		ENDIF
		
	ENDPROC

	PROCEDURE lookcoa
	ENDPROC

	PROCEDURE save
		LPARAMETERS cworkarealist
		
		dodefault(cworkarealist)
		
		thisform.txtcid.setfocus()
		thisform.setnextcontrol(thisform.txtcid)
		thisform.activatenextcontrol()
	ENDPROC

	PROCEDURE setstate		&& Resets the form state for non bound controls so that the save button still works.
		RETURN
		this.lChanged = .T.
		m.goStateManager.RefreshAll('Form Edit')
	ENDPROC

	PROCEDURE valterms		&& Validate Terms and Set Due Date and Disc Date based on the Terms
	ENDPROC

	PROCEDURE cboAcct.Init
		*
		*  Builds the data displayed in the combo list box
		*
		
		SELECT  cAcctNo + ' - ' +cAcctDesc, cAcctNo, cAcctDesc FROM coa INTO ARRAY laAcct WHERE lBankacct = .T. ORDER BY cAcctNo
		
		IF _TALLY > 0
		   FOR lnX = 1 TO ALEN(laAcct,1)
		      THIS.ADDLISTITEM(laAcct[lnX,1],lnX,1)
		      THIS.ADDLISTITEM(laAcct[lnX,2],lnX,2)
		   ENDFOR
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cmdatamanager.afterchange
		LPARAMETERS cworkarea,cfield
		
		IF UPPER(m.cWorkarea) == 'CSDISDET'
		   * Recalculate the invoice totals
		   thisform.calctot()
		ENDIF   
		
		RETURN (DODEFAULT(m.cworkArea, m.cField))
	ENDPROC

	PROCEDURE cmdatamanager.afterdelete
		LPARAMETERS cworkarea
		
		DO CASE
		   CASE m.cWorkarea = 'Csdishdr'
		
		   CASE m.cWorkarea = 'Csdisdet'
		      * Recalculate the invoice totals
		      thisform.calctot()
		ENDCASE   
		
		RETURN (DODEFAULT(m.cWorkArea))
	ENDPROC

	PROCEDURE cmdatamanager.afternav
		LPARAMETERS cworkarea
		
		IF m.cWorkArea = 'Csdishdr'
		   thisform.getaddr()
		      lcidchec = Csdishdr.cidchec
		      SELECT checks
		      SET ORDER TO cidchec
		      IF SEEK(lcidchec)
		         IF checks.lvoid
		            thisform.lblvoided.Visible = .t.
		         ELSE 
		            thisform.lblvoided.Visible = .f.   
		         ENDIF 
		      ELSE
		         thisform.lblvoided.Visible = .f.   
		      ENDIF    
		
		   IF EMPTY(csdishdr.dpostdate)
		      this.replace('Csdishdr','dPostDate',csdishdr.ddate)
		      IF NOT THISFORM.cmdatamanager.isnew('Csdishdr')
		         SELECT csdishdr
		         =TABLEUPDATE(.T.)
		      ENDIF
		   ENDIF    
		ENDIF
		
		thisform.list1.requery()
		thisform.list1.refresh()
		   
		RETURN (dodefault(m.cWorkarea))
		
		
	ENDPROC

	PROCEDURE cmdatamanager.afternew
		LPARAMETERS cworkarea
		
		DO CASE
		   CASE UPPER(m.cworkarea) = 'CSDISHDR'    && Cash Header
		      thisform.cboacct.value = thisform.coldacct 
		      REPLACE cBatch  WITH THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch'),  ;
		              cCashAcct WITH THISFORM.cboAcct.value, dDate WITH DATE(), dPostDate WITH DATE()
		      thisform.txtnExtension.value = 0        
		      thisform.setnextcontrol(thisform.txtcid)
		
		   CASE UPPER(m.cworkarea) = 'CSDISDET'    && Cash Detail
		      SET DELETED OFF
		      m.ciddisd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Disbursement Detail')
		      SELECT csdisdet1
		      SET ORDER TO ciddisd
		      DO WHILE SEEK(m.ciddisd)
		         m.ciddisd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Disbursement Detail')
		      ENDDO
		      SET DELETED ON
		      SELECT csdisdet   
		      REPLACE csdisdet.cidDisd WITH m.ciddisd
		ENDCASE
		
		RETURN (DODEFAULT(m.cWorkarea))
		
	ENDPROC

	PROCEDURE cmdatamanager.afterupdatefailure
		LPARAMETERS cworkarealist
		
		
		IF txnlevel() <> 0
		   ROLLBACK
		ENDIF   
	ENDPROC

	PROCEDURE cmdatamanager.beforedelete
		LPARAMETERS cworkarea
		
		THISFORM.txtcid.SETFOCUS()
		THISFORM.setnextcontrol(THISFORM.txtcid)
		THISFORM.activatenextcontrol()
		
		*  Make sure the period or year isn't closed
		IF NOT THISFORM.glmaint.CheckPeriod(Csdishdr.ddate)
		   THISFORM.omessage.warning('Unable to delete this check. Either the fiscal year or period represented by this date has been closed.')
		   RETURN .F.
		ENDIF
		
		IF m.cworkarea = 'Csdishdr'
		   *  Look to see if check is marked as cleared
		   lcidchec = Csdishdr.cidchec
		   SELECT checks
		   SET ORDER TO cidchec
		   IF SEEK(lcidchec)
		      DO CASE 
		         CASE checks.lvoid   && If the checks been voided, don't let them delete it.
		            THISFORM.omessage.warning('This check is marked as voided in the check register. It cannot be deleted.')
		            RETURN .F.
		         CASE checks.lCleared
		            THISFORM.omessage.warning('This check is marked as cleared in the check register. It cannot be deleted.')
		            RETURN .F.
		         CASE checks.lPrinted
		            THISFORM.omessage.warning('This check has been printed. It cannot be deleted.')
		            RETURN .F.
		      ENDCASE 
		   ENDIF
		
		   BEGIN TRANSACTION
		   lcBatch = Csdishdr.cbatch
		   THISFORM.glmaint.delbatch(lcBatch,'CS')
		
		   *  Delete the deposit entry from the check register
		   THISFORM.glmaint.delcheck(lcBatch,.T.)
		
		   *  Make sure none of the detail lines that affect cash accounts have been cleared
		   SELECT csdisdet
		   SCAN FOR cbatch = lcBatch AND NOT EMPTY(cidchec)
		      SELECT checks
		      SET ORDER TO cidchec
		      IF SEEK(csdisdet.cidchec)
		         IF checks.lCleared
		            THISFORM.omessage.warning('This deposit is marked as cleared in the check register. It cannot be deleted.')
		            RETURN .F.
		         ENDIF
		      ENDIF
		   ENDSCAN
		   GO TOP 
		   
		   *  Once we know that it's safe to delete it, go ahead and scan the detail lines again, and remove the check register entries
		   SELECT csdisdet
		   SCAN FOR cbatch = lcBatch AND NOT EMPTY(cidchec)
		      THISFORM.glmaint.delcheck(csdisdet.cidchec,.T.)
		   ENDSCAN
		   GO TOP 
		
		   *  Check to see if expenses entered for wells was allocated
		   *  If so, and the period isn't closed, delete it.  Otherwise
		   *  let the user know he can't delete this entry.
		   SELECT expense
		   SCAN FOR cbatch = lcBatch
		      m.cYear   = cYear
		      m.cPeriod = cPeriod
		      m.cWellID = cWellID
		      SELECT wells
		      SET ORDER TO cWellID
		      SEEK(m.cWellID)
		      m.cGroup = cGroup
		      SELECT sysctl
		      SET ORDER TO yrprdgrp
		      IF THISFORM.lSepClose
		         IF SEEK(m.cYear+m.cPeriod+m.cGroup+'YJ')
		            THISFORM.omessage.warning('%msgProdClosed')
		            ROLLBACK
		            RETURN .F.
		         ENDIF
		      ELSE
		         IF SEEK(m.cYear+m.cPeriod+m.cGroup+'YR')
		            THISFORM.omessage.warning('%msgProdClosed')
		            ROLLBACK
		            RETURN .F.
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   *  Delete the expense entries
		   SELECT expense
		   SCAN FOR cbatch == lcBatch
		      DELE NEXT 1
		   ENDSCAN
		
		   SELECT expsusp
		   SCAN FOR cbatch == lcBatch
		      DELE NEXT 1
		   ENDSCAN
		
		   END TRANSACTION
		
		   SELECT glmaster
		   =TABLEUPDATE(.T.)
		   SELECT coabal
		   =TABLEUPDATE(.T.)
		   SELECT expense
		   =TABLEUPDATE(.T.)
		   SELECT expsusp
		   =TABLEUPDATE(.T.)
		   SELECT checks
		   =TABLEUPDATE(.T.)
		
		ENDIF
		
	ENDPROC

	PROCEDURE cmdatamanager.beforenew
		LPARAMETERS cworkarea
		
		thisform.coldacct = csdishdr.ccashacct
		
		* Save the entry if they haven't clicked save in between checks
		IF thisform.lChanged = .T.
		   IF thisform.flushcontrolbuffer()
		      thisform.save()
		   ENDIF
		ENDIF 
	ENDPROC

	PROCEDURE cmdatamanager.beforeupdate
		LPARAMETERS cworkarealist
		LOCAL lcBatch, lcAPAcct,  llReturn, lcSelect, lnRecNo, lcidchec
		
		IF NOT THISFORM.lChanged
		   RETURN .F.
		ENDIF
		
		*  Make sure the period or year isn't closed
		IF NOT THISFORM.glmaint.CheckPeriod(Csdishdr.ddate)
		   THISFORM.omessage.warning('Unable to save this check. Either the fiscal year or period represented by this date has been closed.')
		   RETURN .F.
		ENDIF
		
		IF Csdishdr.nCashAmt = 0
		   WAIT WIND NOWAIT 'You cannot save a zero amount cash disbursement...'
		   RETURN
		ENDIF
		
		*  Look to see if check is marked as cleared
		lcidchec = Csdishdr.cidchec
		SELECT checks
		SET ORDER TO cidchec
		IF SEEK(lcidchec)
		   IF checks.lCleared
		      THISFORM.omessage.warning('This check is marked as cleared in the check register. It cannot be modified.')
		      RETURN .F.
		   ENDIF
		   IF checks.lPrinted
		      THISFORM.omessage.warning('This check has been printed. It cannot be modified.')
		      RETURN .F.
		   ENDIF
		ENDIF
		
		lcBatch  = Csdishdr.cBatch
		lcidchec = Csdishdr.cidchec
		
		*  Look to see if any check register entries created by the detail lines have cleared.
		SELECT csdisdet
		SCAN FOR cBatch = lcBatch AND NOT EMPTY(cidchec)
		   SELECT checks
		   SET ORDER TO cidchec
		   IF SEEK(csdisdet.cidchec)
		      IF checks.lCleared
		         THISFORM.omessage.warning('This deposit is marked as cleared in the check register. It cannot be modified.')
		         RETURN .F.
		      ENDIF      
		   ENDIF
		ENDSCAN
		GO TOP 
		
		
		lcSelect = SELECT()
		
		WAIT WINDOW NOWAIT 'Saving Changes, Please Wait.....'
		
		*
		*  Delete the G/L journal entries for this invoice
		*
		THISFORM.glmaint.delbatch(lcBatch,'CS')
		
		*  Remove any check register entries created by the detail lines, if they were bank accounts, too.
		SELECT csdisdet
		SCAN FOR cBatch = lcBatch AND NOT EMPTY(cidchec)
		   THISFORM.glmaint.delcheck(csdisdet.cidchec)
		ENDSCAN
		GO TOP
		
		*  Delete the current check, if there is one.
		*  If this is an update to the payment, we
		*  don't want duplicate checks to show up in
		*  the register
		THISFORM.glmaint.delcheck(lcidchec)
		
		*
		*  Create the G/L journal entries for this invoice
		*
		
		*  Cash entry
		THISFORM.glmaint.cSource    = 'CS'
		THISFORM.glmaint.cBatch     = lcBatch
		THISFORM.glmaint.dGLDate    = Csdishdr.dPostDate
		THISFORM.glmaint.cReference = 'CHK: ' + ALLTRIM(Csdishdr.ccheckno)
		THISFORM.glmaint.cDesc      = THISFORM.txtcname.VALUE
		THISFORM.glmaint.cAcctNo    = Csdishdr.cCashAcct
		THISFORM.glmaint.cid        = Csdishdr.cid
		THISFORM.glmaint.cBunch     = THISFORM.cBunch
		THISFORM.glmaint.mNotes     = 'csdishdr.mDisbMemo'
		THISFORM.glmaint.cYear      = ' '
		THISFORM.glmaint.cPeriod    = ' '
		THISFORM.glmaint.cUnitNo    = ''
		THISFORM.glmaint.cDeptNo    = ''
		*
		*  Create Check Register Entry for cash account
		*
		SELECT custownvend
		LOCATE FOR cid = Csdishdr.cid
		IF FOUND()
		   THISFORM.glmaint.cid        = Csdishdr.cid
		   THISFORM.glmaint.cidType    = 'V'
		ELSE
		   THISFORM.glmaint.cid        = ' '
		   THISFORM.glmaint.cidType    = 'M'
		   *
		   *  Create other names entry
		   *
		   SELECT othnames
		   SET ORDER TO cname
		   IF NOT SEEK(TRIM(UPPER(THISFORM.txtcname.VALUE)))
		      m.cidothn = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.OtherNames')
		      m.cname   = THISFORM.txtcname.VALUE
		      m.caddr1  = THISFORM.txtcAddr1.VALUE
		      m.caddr2  = THISFORM.txtcAddr2.VALUE
		      m.caddr3  = THISFORM.txtcAddr3.VALUE
		      INSERT INTO othnames FROM MEMVAR
		   ENDIF
		ENDIF
		
		THISFORM.glmaint.dCheckDate = Csdishdr.dPostDate
		THISFORM.glmaint.dPostDate  = Csdishdr.dPostDate
		THISFORM.glmaint.cSource    = 'CS'
		THISFORM.glmaint.cPayee     = THISFORM.txtcname.VALUE
		THISFORM.glmaint.nAmount    = Csdishdr.nCashAmt
		THISFORM.glmaint.cEntryType = 'C'
		THISFORM.glmaint.cAcctNo    = Csdishdr.cCashAcct
		THISFORM.glmaint.cBatch     = lcBatch
		THISFORM.glmaint.ccheckno   = Csdishdr.ccheckno
		
		IF RIGHT(Csdishdr.ccheckno,1) <> ' '
		   THISFORM.glmaint.lPrinted = .T.
		ELSE
		   THISFORM.glmaint.lPrinted = .F.
		ENDIF
		
		*  Add the entry to the checks table
		THISFORM.glmaint.addcheck()
		
		*  Get the key of the check just created
		*  and put it in the payment detail rec.
		lcCheckKey = THISFORM.glmaint.GETKEY()
		
		THISFORM.glmaint.ccheckno = Csdishdr.ccheckno
		THISFORM.glmaint.cidchec  = lcCheckKey
		THISFORM.glmaint.nAmount  = Csdishdr.nCashAmt * -1
		THISFORM.glmaint.updatebatch()
		
		*
		*  Plug in the key to the entry in the check register
		*
		THISFORM.cmdatamanager.REPLACE('Csdishdr','Cidchec',lcCheckKey)
		
		*  Detail Lines
		SELECT csdisdet
		lnRecNo = RECNO()
		SCAN FOR cBatch == lcBatch
		   lcAcctNo = csdisdet.cAcctNo
		   SELECT coa
		   SET ORDER TO acctno
		   IF SEEK(lcAcctNo) AND coa.lbankacct
		      THISFORM.glmaint.dCheckDate = Csdishdr.dPostDate
		      THISFORM.glmaint.dPostDate  = Csdishdr.dPostDate
		      THISFORM.glmaint.cSource    = 'CS'
		      THISFORM.glmaint.cPayee     = THISFORM.txtcname.VALUE
		      THISFORM.glmaint.nAmount    = csdisdet.nAmount
		      THISFORM.glmaint.cEntryType = 'D'
		      THISFORM.glmaint.cidType    = 'D'
		      THISFORM.glmaint.cAcctNo    = lcAcctNo
		      THISFORM.glmaint.cBatch     = lcBatch
		      THISFORM.glmaint.ccheckno   = Csdishdr.ccheckno
		      THISFORM.glmaint.lPrinted   = .T.
		      THISFORM.glmaint.cDeptNo    = csdisdet.cDeptNo
		
		      lcidchec = csdisdet.cidchec
		      *  Delete the current check, if there is one.
		      *  If this is an update to the payment, we
		      *  don't want duplicate checks to show up in
		      *  the register
		      THISFORM.glmaint.delcheck(lcidchec)
		      
		      *  Add the entry to the checks table
		      THISFORM.glmaint.addcheck()
		
		      *  Get the key of the check just created
		      *  and put it in the payment detail rec.
		      lcCheckKey = THISFORM.glmaint.GETKEY()
		      SELECT csdisdet
		      REPL cidchec WITH lcCheckKey
		   ENDIF
		
		   THISFORM.glmaint.cBatch     = lcBatch
		   THISFORM.glmaint.dGLDate    = Csdishdr.dPostDate
		
		   IF NOT EMPTY(Csdishdr.cinvnum)
		      THISFORM.glmaint.cReference = 'CHK: ' + ALLTRIM(Csdishdr.ccheckno)
		   ELSE
		      THISFORM.glmaint.cReference = ' '
		   ENDIF
		   THISFORM.glmaint.cDesc      = csdisdet.cDesc
		   THISFORM.glmaint.cAcctNo    = lcAcctNo
		   THISFORM.glmaint.cid        = Csdishdr.cid
		   THISFORM.glmaint.cUnitNo    = csdisdet.cUnitNo
		   THISFORM.glmaint.cCatCode   = csdisdet.cCatCode
		   THISFORM.glmaint.nAmount    = csdisdet.nAmount
		   THISFORM.glmaint.cDeptNo    = csdisdet.cDeptNo
		   THISFORM.glmaint.updatebatch()
		ENDSCAN
		GOTO lnRecNo
		
		*
		*  Check to make sure the batch balances
		*
		llReturn = THISFORM.glmaint.chkBalance()
		
		IF llReturn
		   llReturn = THISFORM.dmexpense()
		   IF llReturn
		      *      SELECT glmaster
		      *      =TABLEUPDATE(.T.)
		      WAIT WINDOW NOWAIT 'Changes Saved....' TIMEOUT 2
		   ENDIF
		ELSE
		   WAIT WIND 'The Batch Was Not In Balance...Unable to save invoice.'
		ENDIF
		
		SELECT (lcSelect)
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE cmdatamanager.new
		LPARAMETERS cworkarea
		
		DO CASE
		CASE UPPER(m.cworkarea) == 'CSDISHDR'    && Cash Header
			WITH THISFORM
				.txtcId.VALUE = ""
				.txtcName.VALUE = ""
				.txtcAddr1.VALUE = ""
				.txtcAddr2.VALUE = ""
				.txtcAddr3.VALUE = ""
			ENDWITH
		ENDCASE
		
		RETURN DODEFAULT(cworkarea)
		
	ENDPROC

	PROCEDURE cmdDocument.Click
		LOCAL lnx, llReturn, llNewDoc
		
		llNewDoc = .T.
		
		swSELECT('documents')
		m.cfk      = 'CS'+csdishdr.cbatch
		LOCATE FOR cfk == m.cfk
		IF FOUND()
		   IF MESSAGEBOX('There is a document attached to this Cash Disbursement. Do you want to view the document? Choosing No will allow you to attach a new document.', 36, 'Attached Document') = 6
		      DO viewdocument WITH documents.cpath
		      llNewDoc = .F.
		   ELSE
		      llNewDoc = .T.
		   ENDIF
		ENDIF
		IF llNewDoc
		    THISFORM.oFileDialog.FileName = ''
		   llReturn = THISFORM.oFileDialog.openfile()
		   IF NOT THISFORM.oFileDialog.lcancelled
		      m.cDesc    = THISFORM.omessage.gettext('Enter a description for this file.','Get File Description')
		      m.cpath    = THISFORM.ofilEDIALOG.aFiles[1]
		      IF EMPTY(m.cDesc) OR ISNULL(m.cDesc)
		         m.cDesc = ALLTRIM(m.cpath)
		      ENDIF
		
		      m.cDocLink = 'CS'
		      swSELECT('documents')
		      LOCATE FOR cfk == m.cfk
		      IF NOT FOUND()
		         INSERT INTO documents FROM MEMVAR
		      ELSE
		         REPLACE cpath WITH m.cpath, ;
		                 cdesc WITH m.cdesc
		      ENDIF
		      THISFORM.setchanged(.T., 'Documents')
		      m.gostatemanager.refreshall('Form')
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE cmdLookCat.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .F.
		SELECT cCatCode,cCateg,cExpClass,IIF(lAFEType,'A','') AS cAFEType, IIF(lJIBOnly,'J','') as cJIBOnly  ;
		   FROM expcat INTO CURSOR exptmp readwrite
		
		SELECT exptmp
		INDEX ON cCatCode           TAG cCatCode
		INDEX ON cCateg             TAG cCateg
		INDEX ON cExpClass+cCatCode TAG cExpClass
		INDEX on cafetype           TAG cafetype
		INDEX on cjibonly           TAG cjibonly
		
		lcList = 'ccatcode\Code,ccateg\Category,cexpclass\Cls,cAFEType\AFE,cJIBOnly\JIB'
		
		DO FORM '..\custom\picklist' WITH 'exptmp', lcList, thisform.txtcCatCode.value, 5, .T., .T.
		
		IF llOK
		   thisform.txtcCatCode.value = exptmp.ccatcode
		   thisform.txtcDeptDesc.value = exptmp.ccateg
		   thisform.txtcCatCode.refresh()
		   thisform.txtcDeptDesc.refresh()
		ENDIF   
		
		*thisform.txtccatCode.SetFocus()
		thisform.setnextcontrol(thisform.txtcCatCode)
	ENDPROC

	PROCEDURE cmdLookCat.When
		RETURN thisform.lValidWell
	ENDPROC

	PROCEDURE cmdLookCOA.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		lcList = 'cacctno/acctno,cacctdesc/acctdesc'
		
		DO FORM ..\custom\picklist WITH 'Coa', lcList, thisform.txtcacctno.value, 2
		
		IF llOK
		   thisform.txtcAcctNo.value = coa.cacctno
		   thisform.txtcAcctDesc.value = coa.cAcctDesc
		   thisform.txtcAcctNo.refresh()
		   thisform.txtcAcctDesc.refresh()
		   thisform.ldeptrequired = lacctdept
		   thisform.lwellrequired = lacctunit
		ENDIF   
		
		thisform.setnextcontrol(thisform.txtcAcctNo)
	ENDPROC

	PROCEDURE cmdLookDept.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		lcList = 'cdeptno\Dept No,cdeptdesc\Department Description'
		
		DO FORM ..\custom\picklist WITH 'Gldept', lcList, thisform.txtcdeptno.value, 2,.f.,.t.
		
		IF llOK
		   THISFORM.txtcDeptNo.VALUE = gldept.cdeptno
		   THISFORM.txtcDeptDesc.VALUE = gldept.cDeptDesc
		   THISFORM.txtcDeptNo.REFRESH()
		   THISFORM.txtcDeptDesc.REFRESH()
		ENDIF
		
		THISFORM.setnextcontrol(thisform.txtcDeptNo)
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cmdLookID.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		lcList = 'cid\ID,cname\Name,ctype\Type'
		
		SELECT custownvend
		SET SAFETY OFF
		INDEX ON cid TAG cid
		INDEX ON cname TAG cname
		INDEX ON ctype TAG ctype
		
		DO FORM ..\custom\picklist WITH 'Custownvend', lcList, thisform.txtcid.value, 3,.f.,.t.
		
		IF llOK
		   THISFORM.cmdatamanager.REPLACE('csdishdr','cId', custownvend.cid)
		   DO CASE
		      CASE LEFT(custownvend.ctype,1) = 'O'  &&  Owner
		         SELECT investor
		         LOCATE FOR cownerid = custownvend.cid
		         IF FOUND()
		            THISFORM.txtcName.SET('value',investor.cownname)
		         ELSE
		            THISFORM.txtcName.SET('value',custownvend.cname)
		         ENDIF
		      CASE LEFT(custownvend.ctype,1) = 'V'  &&  Vendor
		         SELECT vendor
		         LOCATE FOR cvendorid = custownvend.cid
		         IF FOUND()
		            THISFORM.txtcName.SET('value',vendor.cvendname)
		         ELSE
		            THISFORM.txtcName.SET('value',custownvend.cname)
		         ENDIF
		      OTHERWISE  &&  Any other type of name
		         THISFORM.txtcName.SET('value',custownvend.cname)
		   ENDCASE
		   THISFORM.txtcName.VALUE  = custownvend.cname
		   THISFORM.txtcId.VALUE    = custownvend.cID
		   THISFORM.txtcAddr1.set('enabled',.f.)  &&  Make the address invisible if the ID selected is found in the system, otherwise, let them enter it
		   THISFORM.txtcAddr2.set('enabled',.f.)
		   THISFORM.txtcAddr3.set('enabled',.f.)
		   THISFORM.txtcAddr1.VALUE = custownvend.cAddr1
		   THISFORM.txtcAddr2.VALUE = custownvend.cAddr2
		   THISFORM.txtcAddr3.VALUE = custownvend.cAddr3
		   THISFORM.REFRESH()
		ENDIF
		
		THISFORM.txtcId.SETFOCUS()
		
		
	ENDPROC

	PROCEDURE cmdLookOwner.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		
		lcList = 'cOwnerID\Owner ID,csortfield\Owner Name'
		
		IF USED('tempown')
		   USE IN tempown
		ENDIF
		IF USED('tempown1')
		   USE IN tempown1
		ENDIF
		
		IF NOT EMPTY(THISFORM.txtcunitno.VALUE)
		   SET SAFETY OFF
		   SELECT cOwnerID, cSortField FROM investor ;
		      WHERE cOwnerID IN (SELECT cOwnerID FROM wellinv WHERE cWellID = THISFORM.txtcunitno.VALUE) ;
		      INTO CURSOR tempown1 ;
		      ORDER BY cOwnerID
		
		   IF _TALLY > 0
		
		      USE DBF('tempown1') AGAIN IN 0 ALIAS tempown
		      SELECT tempown
		      INDEX ON cOwnerID TAG cOwnerID
		      INDEX ON cSortField TAG cSortField
		
		      DO FORM ..\CUSTOM\Picklist WITH 'tempown', lcList, THISFORM.txtcownerid.VALUE, 2, .T.,.t.
		
		      IF llOK
		         THISFORM.txtcownerid.VALUE = tempown.cOwnerID
		         THISFORM.txtcOwnerName.VALUE = tempown.cSortField
		         THISFORM.txtcownerid.REFRESH()
		         THISFORM.txtcOwnerName.REFRESH()
		      ENDIF
		
		      THISFORM.setnextcontrol(THIS.PARENT.txtcownerid)
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE cmdLookOwner.When
		RETURN MDOWN()
	ENDPROC

	PROCEDURE cmdLookUnit.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		
		lcList = 'cunitno\Unit No,cname\Name,ctype\Type'
		
		DO FORM ..\Custom\PickList WITH 'Allunits', lcList, thisform.txtcunitno.value, 3, .f., .t.
		
		IF llOK
		   thisform.txtcUnitNo.value   = allunits.cunitno
		   thisform.txtcUnitDesc.value = allunits.cname
		   thisform.txtcUnitNo.refresh()
		   thisform.txtcUnitDesc.refresh()
		ENDIF   
		
		thisform.setnextcontrol(This.Parent.txtcUnitNo)
		
		ON KEY LABEL F10 _screen.activeform.Save()
		ON KEY LABEL CTRL+A _screen.activeform.New()
		ON KEY LABEL CTRL+D _screen.activeform.Delete()
		ON KEY LABEL CTRL+L _screen.activeform.List()
		
	ENDPROC

	PROCEDURE List1.DblClick
		thisform.editdetail()
	ENDPROC

	PROCEDURE txtcAcctNo.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdLookCOA.Click()
		DODEFAULT()
	ENDPROC

	PROCEDURE txtcAcctNo.InteractiveChange
		IF DODEFAULT()
		   SELECT coa
		   LOCATE FOR cacctno == this.Value
		   IF FOUND()
		      thisform.txtcAcctDesc.set('value',coa.cAcctDesc)
		    ELSE
		      thisform.txtcAcctDesc.set('value','')
		    ENDIF 
		ENDIF    
	ENDPROC

	PROCEDURE txtcAcctNo.LostFocus
		ON KEY LABEL F2 *
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcAcctNo.Valid
		IF NOT EMPTY(THIS.VALUE) AND THIS.VALUE <> '*'
		   SELECT coa
		   SET ORDER TO acctno
		   IF SEEK(THIS.VALUE)
		      thisform.txtcAcctDesc.value = coa.cAcctDesc
		      thisform.txtcAcctDesc.refresh()
		      thisform.ldeptrequired = lacctdept
		      thisform.lwellrequired = lacctunit    
		   ENDIF
		ENDIF
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcAddr1.When
		IF thisform.lFoundID
		   RETURN .f.
		ENDIF 
	ENDPROC

	PROCEDURE txtcAddr2.When
		IF thisform.lFoundID
		   RETURN .f.
		ENDIF 
	ENDPROC

	PROCEDURE txtcAddr3.When
		IF thisform.lFoundID
		   RETURN .f.
		ENDIF 
	ENDPROC

	PROCEDURE txtcCatCode.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdLookCat.Click()
		THISFORM.lConfirm = SET('confirm')
		SET CONFIRM ON
		DODEFAULT()
	ENDPROC

	PROCEDURE txtcCatCode.InteractiveChange
		IF DODEFAULT()
		   SELECT expcat
		   LOCATE FOR ccatcode == this.Value
		   IF FOUND()
		      thisform.txtcDeptDesc.set('value',expcat.ccateg)
		   ELSE
		      thisform.txtcDeptDesc.set('value','')
		   ENDIF 
		ENDIF    
	ENDPROC

	PROCEDURE txtcCatCode.LostFocus
		local lcConfirm  &&  Local variable to keep from advancing automatically when this field is full, which can screw up the popup for number of salt water bbls. - BH 06/24/2004
		
		ON KEY LABEL F2 *
		
		WITH THISFORM
		
		IF 'SALT'  $ UPPER(.txtcDeptDesc.value) OR ;
		   'BRINE' $ UPPER(.txtcDeptDesc.value) OR ;
		   'WATER' $ UPPER(.txtcDeptDesc.value) OR ;
		   'H2O' $ UPPER(.txtcDeptDesc.value)
		   IF FILE(m.goapp.cRptsFolder+'paprod.frx')
		         m.odialog = CREATEOBJECT('frmWaterDialog',.txtnsaltbbl.VALUE,.txtcdisperm.VALUE,.txtcdispcode.VALUE,.txtWasteCode.VALUE)
		         m.odialog.SHOW()
		         lnbbl   = m.odialog.txtwaterbbl.VALUE
		         lcperm  = m.odialog.cbodisposal.VALUE
		         lcdisp  = m.odialog.cbodispcode.VALUE
		         lcWaste = m.odialog.cbowastecode.value
		         m.odialog.RELEASE()
		         .txtnsaltbbl.VALUE = lnbbl
		         .txtcdisperm.VALUE = lcperm
		         .txtWasteCode.value = lcWaste
		         .txtcdispcode.value = lcdisp
		      ELSE
		         .txtnSaltBBL.VALUE = thisform.oMessage.GetText('Enter the number of BBLs of water.  (5 digits max)','Amount of Water in BBL')
		         IF VARTYPE(.txtnsaltbbl.value) <> 'N'
		            .txtnsaltbbl.set('value',VAL(.txtnsaltbbl.value))
		         ENDIF 
		         .txtcdispcode.VALUE = ''
		         .txtcdisperm.value = ''
		         .txtwastecode.value = ''
		      ENDIF
		ENDIF         
		ENDWITH
		
		lcConfirm = thisform.lConfirm
		
		set confirm &lcConfirm
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcCatCode.Valid
		LOCAL lcAcctNo
		DODEFAULT()
		
		SELE afeopt
		GO TOP
		llAllocExp = lAllocExp
		
		IF NOT EMPTY(THIS.VALUE)
		   SELECT expcat
		   SET ORDER TO cCatCode
		   IF SEEK(THIS.VALUE)
		      IF EMPTY(THISFORM.txtcitemdesc.VALUE)
		         THISFORM.txtcitemdesc.VALUE = expcat.ccateg
		         THISFORM.txtcitemdesc.REFRESH()
		      ENDIF
		      lcAcctNo = expcat.cdraccto
		      DO CASE 
		         CASE thisform.lInvestment
		            * If the well is an investment well, get the account
		            * to debit from the category so that we can post it
		            * directly.
		            THISFORM.txtcAcctNo.VALUE = lcAcctNo
		            THISFORM.txtcAcctNo.REFRESH()         
		         CASE NOT lAFEType   
		            THISFORM.txtcAcctNo.VALUE = glopt.cExpClear
		            SELECT coa
		            LOCATE FOR cacctno == glopt.cexpclear
		            thisform.txtcAcctDesc.Value = coa.cacctdesc
		            THISFORM.txtcAcctNo.REFRESH()
		            thisform.txtcAcctDesc.Refresh()
		        CASE lAFEType AND llAllocExp
		            THISFORM.txtcAcctNo.VALUE = glopt.cExpClear
		            SELECT coa
		            LOCATE FOR cacctno == glopt.cexpclear
		            thisform.txtcAcctDesc.Value = coa.cacctdesc
		            THISFORM.txtcAcctNo.REFRESH()
		            thisform.txtcAcctDesc.Refresh()
		      ENDCASE 
		   ENDIF
		ELSE
		   THISFORM.txtcDeptDesc.SET('value','')
		ENDIF
		
	ENDPROC

	PROCEDURE txtcCatCode.When
		DODEFAULT()
		RETURN thisform.lValidWell
	ENDPROC

	PROCEDURE txtCcheckno.fieldvalid
		this.value = PADL(ALLTRIM(this.value),10,' ')
		
	ENDPROC

	PROCEDURE txtCcheckno.Valid
		**  See if this check number has been used in the check register before, and warn them if it has.  **
		
		IF NOT EMPTY(THIS.VALUE)
		   SELECT checks
		   LOCATE FOR ALLT(ccheckno) == ALLT(THIS.VALUE) AND cacctno = THISFORM.cboAcct.VALUE AND cEntrytype = 'C' AND cidchec <> csdishdr.cidchec
		   IF FOUND()
		      IF NOT THISFORM.oMessage.confirm('There is already a check with this number in this account in the check register.  Would you like to continue?')
		         RETURN 0
		      ENDIF
		   ENDIF
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtCdeptdesc.When
		RETURN .F. 
	ENDPROC

	PROCEDURE txtcDeptNo.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdLookDept.Click()
		DODEFAULT()
	ENDPROC

	PROCEDURE txtcDeptNo.InteractiveChange
		IF DODEFAULT()
		   SELECT gldept
		   LOCATE FOR cdeptno == this.Value
		   IF FOUND()
		      THISFORM.txtcDeptDesc.set('VALUE',gldept.cDeptDesc)
		   ELSE
		      THISFORM.txtcDeptDesc.set('VALUE','')
		   ENDIF    
		ENDIF
		
	ENDPROC

	PROCEDURE txtcDeptNo.LostFocus
		ON KEY LABEL F2 *
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcDeptNo.Valid
		DODEFAULT()
		
		IF EMPTY(this.value) AND NOT MDOWN()
		   IF thisform.ldeptrequired
		      thisform.omessage.display('%msgdeptrequired')
		      RETURN 0
		   ENDIF
		ENDIF     
	ENDPROC

	PROCEDURE txtcID.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdLookID.Click()
		RETURN (DODEFAULT())
	ENDPROC

	PROCEDURE txtcID.InteractiveChange
		IF DODEFAULT()
		   SELECT custownvend
		   LOCATE FOR cid == THIS.VALUE
		   IF FOUND()
		      DO CASE  &&  We have to find out the actual name to fill into the name field, since custownvend.cname is actually the sortfield.
		         CASE LEFT(custownvend.ctype,1) = 'O'  &&  Owner
		            SELECT investor
		            LOCATE FOR cownerid = custownvend.cid
		            IF FOUND()
		               THISFORM.txtcName.SET('value',investor.cownname)
		            ELSE
		               THISFORM.txtcName.SET('value',custownvend.cname)
		            ENDIF
		         CASE LEFT(custownvend.ctype,1) = 'V'  &&  Vendor
		            SELECT vendor
		            LOCATE FOR cvendorid = custownvend.cid
		            IF FOUND()
		               THISFORM.txtcName.SET('value',vendor.cvendname)
		            ELSE
		               THISFORM.txtcName.SET('value',custownvend.cname)
		            ENDIF
		         OTHERWISE  &&  Any other type of name
		            THISFORM.txtcName.SET('value',custownvend.cname)
		      ENDCASE
		      THISFORM.txtcAddr1.SET('enabled',.F.)  &&  Make the address invisible if the ID selected is found in the system, otherwise, let them enter it
		      THISFORM.txtcAddr2.SET('enabled',.F.)
		      THISFORM.txtcAddr3.SET('enabled',.F.)
		      THISFORM.txtcAddr1.SET('VALUE',custownvend.cAddr1)
		      THISFORM.txtcAddr2.SET('VALUE',custownvend.cAddr2)
		      THISFORM.txtcAddr3.SET('VALUE',custownvend.cAddr3)
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE txtcID.LostFocus
		ON KEY LABEL F2 *
		IF MDOWN() OR LASTKEY() = -1  && Dont run this code if the mouse buttong was clicked or the F2 key was pressed.
		   RETURN .t.
		ENDIF 
		
		SELECT custownvend
		LOCATE FOR cid == THIS.VALUE
		IF FOUND()
		   THISFORM.getaddr()
		   THISFORM.lFoundID = .T.
		   THISFORM.lAskedAboutID = .F.
		ELSE
		   IF NOT THISFORM.lAskedAboutID
		      swselect('othnames')
		      LOCATE FOR UPPER(cname) = UPPER(THISFORM.txtcname.VALUE)
		      IF NOT FOUND()
		         IF THISFORM.omessage.CONFIRM('This ID was not found in the Customer, Vendor or Owner files. Would you like to enter the name and address for the payee of this check?')
		            THISFORM.lFoundID = .F.
		            THISFORM.lAskedAboutID = .T.
		            THISFORM.txtcAddr1.set('enabled',.t.)  &&  Make the address invisible if the ID selected is found in the system, otherwise, let them enter it
		            THISFORM.txtcAddr2.set('enabled',.t.)
		            THISFORM.txtcAddr3.set('enabled',.t.)
		            THISFORM.txtcname.SET('value','')
		            THISFORM.txtcAddr1.SET('VALUE','')
		            THISFORM.txtcAddr2.SET('VALUE','')
		            THISFORM.txtcAddr3.SET('VALUE','')
		            THISFORM.txtcname.SETFOCUS()
		         ELSE
		            IF thisform.omessage.confirm('Would you like to choose a valid payee from the payee lookup list?')
		               thisform.cmdlookid.Click()
		            ENDIF    
		            THISFORM.setnextcontrol(THISFORM.txtciD)
		         ENDIF
		      ENDIF
		   ENDIF
		ENDIF
		
		
		RETURN (DODEFAULT())
		
	ENDPROC

	PROCEDURE txtcName.GotFocus
		IF EMPTY(THISFORM.txtcID.VALUE)
		   THIS.cListExpression = 'cname'
		   THIS.clistworkarea   = 'othnames'
		ENDIF
		
	ENDPROC

	PROCEDURE txtcName.Valid
		IF EMPTY(THISFORM.txtcID.VALUE) AND NOT EMPTY(THIS.VALUE)  &&  Check othnames table and plug in address if they've been used before
		   SELECT othnames
		   LOCATE FOR ALLT(cname) = ALLT(THIS.VALUE)
		   IF FOUND()
		      THISFORM.txtcAddr1.SET('value',othnames.cAddr1)
		      THISFORM.txtcAddr2.SET('value',othnames.cAddr2)
		      THISFORM.txtcAddr3.SET('value',othnames.cAddr3)
		   ENDIF
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcName.When
		IF thisform.lFoundID
		   RETURN .f.
		ENDIF 
	ENDPROC

	PROCEDURE txtcOwnerID.GotFocus
		ON KEY LABEL F2 _SCREEN.ACTIVEFORM.cmdLookOwner.CLICK()
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcOwnerID.InteractiveChange
		IF DODEFAULT()
		   SELECT investor
		   LOCATE FOR cownerid == this.value
		   IF FOUND()
		      THISFORM.txtcOwnerName.set('VALUE',investor.cSortField)
		   ELSE
		      THISFORM.txtcOwnerName.set('VALUE','')
		   ENDIF    
		ENDIF
		   
	ENDPROC

	PROCEDURE txtcOwnerID.LostFocus
		IF (LASTKEY() = 13 OR LASTKEY() = 9) AND not mDown()  &&  Tab or enter, but not a mouseclick
		   THISFORM.adddetail()
		ENDIF
		
		
	ENDPROC

	PROCEDURE txtcOwnerID.When
		RETURN thisform.lValidWell
	ENDPROC

	PROCEDURE txtcOwnerName.When
		RETURN .F.
	ENDPROC

	PROCEDURE txtcProdPeriod.Valid
		IF NOT EMPTY(THIS.VALUE)
		   THIS.VALUE = PADL(ALLTRIM(THIS.VALUE),2,'0')
		   THIS.REFRESH()
		ELSE
		   IF THISFORM.lInvestment
		      THISFORM.oMessage.Warning('The well ID entered is an investment well. The production period must be specified for investment wells.')
		      RETURN 0
		   ELSE
		      RETURN .T.
		   ENDIF
		ENDIF
		
		IF NOT BETWEEN(THIS.VALUE,'01','12')
		   WAIT WIND NOWAIT 'An Invalid Production Period Was Entered.'
		   RETURN 0
		ENDIF
		
		IF NOT EMPTY(THIS.VALUE) AND EMPTY(thisform.txtcprodyear.value)
		   THISFORM.txtcProdYear.SET('value',ALLTRIM(STR(YEAR(DATE()))))
		ENDIF
		
		
	ENDPROC

	PROCEDURE txtcProdPeriod.When
		RETURN thisform.lValidWell
	ENDPROC

	PROCEDURE txtcProdYear.LostFocus
		IF thisform.txtcownerID.Enabled = .f.
		   IF (LASTKEY() = 13 OR LASTKEY() = 9) AND not mDown()  &&  Tab or enter, but not a mouseclick   
		      THISFORM.adddetail()
		   ENDIF
		ENDIF 
		
		DODEFAULT()   
	ENDPROC

	PROCEDURE txtcProdYear.Valid
		IF EMPTY(this.value)
		   IF thisform.lInvestment
		      thisform.oMessage.Warning('The well ID entered is an investment well. The production period must be specified for investment wells.')
		      RETURN 0
		   ELSE   
		      RETURN .T.   
		   ENDIF   
		   RETURN .T.
		ENDIF
		   
		IF NOT BETWEEN(this.value,'1930','2030')
		   WAIT WIND NOWAIT 'The Production Year Entered is Invalid.'
		   RETURN 0
		ENDIF   
	ENDPROC

	PROCEDURE txtcProdYear.When
		RETURN thisform.lValidWell
	ENDPROC

	PROCEDURE txtcUnitNo.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdLookUnit.Click()
		DODEFAULT()
	ENDPROC

	PROCEDURE txtcUnitNo.InteractiveChange
		IF DODEFAULT()
		   SELECT allunits
		   LOCATE FOR cunitno == this.Value
		   IF FOUND()
		      thisform.txtcUnitDesc.set('value',allunits.cname)
		   ELSE
		      thisform.txtcUnitDesc.set('value','')
		   ENDIF 
		ENDIF
		
	ENDPROC

	PROCEDURE txtcUnitNo.LostFocus
		ON KEY LABEL F2 *
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcUnitNo.Valid
		LOCAL lnCount
		
		DODEFAULT()
		
		IF EMPTY(THIS.VALUE) AND NOT MDOWN()
		   IF THISFORM.lwellrequired
		      THISFORM.omessage.DISPLAY('%msgwellrequired')
		      RETURN 0
		   ENDIF
		ENDIF
		
		IF NOT EMPTY(THIS.VALUE)
		   IF 'ALLOC' $ THIS.VALUE
		      THISFORM.txtcownerID.ENABLED = .F.
		      THISFORM.cmdLookOwner.ENABLED = .F.
		      IF LEN(ALLTRIM(THIS.VALUE)) > 5
		         lcGroup = SUBSTR(THIS.VALUE,6,2)
		         SELE groups
		         LOCATE FOR cGroup = lcGroup
		         IF FOUND()
		            DO FORM dmselwells WITH lcGroup
		         ELSE
		            DO FORM dmselwells WITH '**'
		         ENDIF
		      ELSE
		         DO FORM dmselwells WITH '**'
		      ENDIF
		      SELECT wellsel
		      COUNT FOR NOT DELETED() TO lnCount
		      IF lnCount > 0
		         THISFORM.lValidWell = .T.
		         SELECT wellsel
		         SCAN
		            SELECT wells
		            SET ORDER TO cwellid
		            IF SEEK(wellsel.cwellid) AND INLIST(wells.cWellStat,'I','S','P')  &&  All non-active statuses except investment
		               THISFORM.omessage.warning('One or more of the wells chosen to allocate are not active.  Those expenses will be sent to the allocation file.')
		            ENDIF
		         ENDSCAN
		         SELECT wellsel
		      ELSE
		         THISFORM.lValidWell = .F.
		      ENDIF
		   ELSE
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(THIS.VALUE)
		         IF INLIST(wells.cWellStat,'I','S','P')  &&  All non-active statuses except investment
		            THISFORM.lValidWell = .T.
		            THISFORM.omessage.warning('This well is not an active well. Its expenses will be sent to the allocation file.')
		         ELSE
		            THISFORM.lValidWell = .T.
		         ENDIF
		         THISFORM.lInvestment = IIF(wells.cWellStat='V',.T.,.F.)
		      ELSE
		         SELE land
		         LOCATE FOR cleaseid = THIS.VALUE
		         IF FOUND()
		            THISFORM.lValidWell = .F.
		         ELSE
		            THISFORM.omessage.warning('The Well/Lease ID entered is not valid.  Please reenter.')
		            RETURN 0
		         ENDIF
		      ENDIF
		   ENDIF
		ELSE
		   THISFORM.lValidWell = .F.
		ENDIF
		
	ENDPROC

	PROCEDURE txtdEntDate2.Valid
		IF DODEFAULT()
		*++
		*>>If value has changed, call the FieldValid() event, and store value to datasource on success.
		*--
		  IF THISFORM.cmBindingManager.ValidNeeded(THIS)
		    * Convert to proper capitalization if desired
		    IF THIS.lPropercase AND VARTYPE(THIS.Value) $ 'CM'
		      IF ISNULL(THISFORM.oString)
		        THIS.Value = PROPER(THIS.Value)
		      ELSE
		        THIS.Value = THISFORM.oString.ProperCase(THIS.Value)
		      ENDIF
		    ENDIF
		
		    * Call binding manager for the remaining common control valid() processing.
		    RETURN THISFORM.cmBindingManager.Valid(THIS)
		  ENDIF
		  RETURN .T.
		ENDIF 
	ENDPROC

	PROCEDURE txtdpostdate.Valid
		DODEFAULT()
		
		IF this.Value <> thisform.txtdEntDate2.Value AND thisform.txtdEntDate2.Value = DATE()  &&  They changed the value of this one, but the ACCT DATE is still set as the current date, so change it to match
		   thisform.txtdEntDate2.set('value',this.Value)
		ENDIF
		
		
	ENDPROC

	PROCEDURE txtNcashamt.When
		return .f.
	ENDPROC

	PROCEDURE txtnExtension.GotFocus
		SET CONFIRM ON
		
		DODEFAULT()
	ENDPROC

	PROCEDURE txtnExtension.LostFocus
		IF NOT THISFORM.lValidWell
		   IF (LASTKEY() = 13 OR LASTKEY() = 9) AND NOT MDOWN()  &&  Tab or enter, but not a mouseclick
		      THISFORM.adddetail()
		   ENDIF
		ENDIF
		
		SET CONFIRM off
	ENDPROC

ENDDEFINE
