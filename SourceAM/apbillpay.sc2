*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="apbillpay.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor18" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 619
	InitialSelectedAlias = "appmthdr"
	Left = 14
	Name = "Dataenvironment"
	Top = 66
	Width = 1016

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 238, ;
		Left = 47, ;
		Name = "Cursor1", ;
		Order = "cvendorid", ;
		Top = 291, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 463, ;
		Name = "Cursor10", ;
		Top = 44, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = -1, ;
		Name = "Cursor11", ;
		Top = 157, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "apinvoutv", ;
		CursorSource = "apinvoutv", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 726, ;
		Name = "Cursor12", ;
		NoDataOnLoad = .T., ;
		Top = 12, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "appmtdet1", ;
		BufferModeOverride = 5, ;
		CursorSource = "appmtdet", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 850, ;
		Name = "Cursor14", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "terms", ;
		CursorSource = "terms", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 882, ;
		Name = "Cursor15", ;
		Top = 289, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "trangroup", ;
		CursorSource = "trangroup", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 606, ;
		Name = "Cursor16", ;
		Top = 193, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "appmthdr1", ;
		CursorSource = "appmthdr", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 854, ;
		Name = "Cursor17", ;
		Top = 18, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor18' AS cursor WITH ;
		Alias = "apinvoutdd", ;
		CursorSource = "apinvoutdd", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 749, ;
		Name = "Cursor18", ;
		NoDataOnLoad = .T., ;
		Top = 409, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "appmthdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "appmthdr", ;
		Database = ..\newdbc\appdata.dbc, ;
		Filter = "", ;
		Height = 90, ;
		Left = 114, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 335, ;
		Name = "Cursor3", ;
		Order = "acctno", ;
		Top = 321, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "appmtdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "appmtdet", ;
		Database = ..\newdbc\appdata.dbc, ;
		Filter = "NOT DELETED()", ;
		Height = 187, ;
		Left = 200, ;
		Name = "Cursor4", ;
		Top = 149, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 560, ;
		Name = "Cursor5", ;
		Order = "glbatch", ;
		Top = 331, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 591, ;
		Name = "Cursor6", ;
		Top = 45, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "apinvoutd", ;
		CursorSource = "apinvoutd", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 743, ;
		Name = "Cursor7", ;
		NoDataOnLoad = .T., ;
		Top = 290, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "apopt", ;
		CursorSource = "apopt", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 372, ;
		Name = "Cursor8", ;
		Top = 168, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "appurchh", ;
		BufferModeOverride = 5, ;
		CursorSource = "appurchh", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 491, ;
		Name = "Cursor9", ;
		Order = "cbatch", ;
		Top = 168, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Relation1' AS relation WITH ;
		ChildAlias = "appmtdet", ;
		ChildOrder = "cbatch", ;
		Name = "Relation1", ;
		ParentAlias = "appmthdr", ;
		RelationalExpr = "cbatch"
		*< END OBJECT: BaseClass="relation" />

	ADD OBJECT 'Relation2' AS relation WITH ;
		ChildAlias = "vendor", ;
		ChildOrder = "cvendorid", ;
		Name = "Relation2", ;
		ParentAlias = "appmtdet", ;
		RelationalExpr = "cvendorid"
		*< END OBJECT: BaseClass="relation" />

ENDDEFINE

DEFINE CLASS formapbillpay AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboCashAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCashAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgSelectBills" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtnBalance" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtnTotPaid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDrecdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grouptran" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtdPmtDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPaybyCheck" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboPayBy" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column1.txtcVendName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column2.Header2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column2.txtcInvNum" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column3.Header3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column3.txtnDiscAvail" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column4.Header4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column4.txtnDistaken" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column6.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column6.txtnAmtDue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column7.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column7.txtnPayment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column8.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column8.txtdDueDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column5.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdappmtdet.Column5.cmdPay" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboSortBy" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: applypmts		&& Automatically applies the payment amount to outstanding invoices.
		*m: billsselected		&& Returns the balance of bills selected for the given vendor.
		*m: calcapplied
		*m: calctot
		*m: checkforpmts
		*m: markbills
		*m: newpayments
		*m: requeryrecordsource
		*p: coldacctno
		*p: cpmttype
		*p: lnewbuild
		*p: lnewrecord
		*p: lnotnew
	*</DefinedPropArrayMethod>

	Caption = "Pay Bills"
	cnavworkarea = appmthdr
	cpmttype = 
	cworkarea = appmthdr
	DoCreate = .T.
	Height = 666
	HelpContextID = 99
	lexpliciteditmode = .F.
	lnonewask = .T.
	lnotnew = .F.
	lrememberposition = .F.
	lrememberrecord = .F.
	Name = "formapbillpay"
	Visible = .T.
	Width = 917
	_memberdata = <VFPData>
		<memberdata name="billsselected" display="BillsSelected"/>
		<memberdata name="markbills" display="MarkBills"/>
		<memberdata name="cpmttype" display="cPmtType"/>
		<memberdata name="checkforpmts" display="CheckForPmts"/>
		</VFPData>
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 1
	cmdatamanager.ZOrderSet = 1
	cmlookupmanager.Name = "cmlookupmanager"
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Left = 675
	Mwresize1.Name = "Mwresize1"
	Mwresize1.Top = 456

	ADD OBJECT 'cboCashAcct' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		ControlSource = "appmthdr.cacctno", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 242, ;
		Margin = 2, ;
		Name = "cboCashAcct", ;
		TabIndex = 3, ;
		Top = 4, ;
		Width = 394
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboPayBy' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		Height = 22, ;
		Left = 600, ;
		Name = "cboPayBy", ;
		Top = 628, ;
		Width = 156
		*< END OBJECT: ClassLib="..\..\codeminenew\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboSortBy' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		Height = 22, ;
		Left = 300, ;
		Name = "cboSortBy", ;
		Top = 48, ;
		Width = 240
		*< END OBJECT: ClassLib="..\..\codeminenew\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdPaybyCheck' AS cmdcommandbuttoncustom WITH ;
		Caption = "Pay Now", ;
		FontBold = .T., ;
		Height = 31, ;
		Left = 780, ;
		Name = "cmdPaybyCheck", ;
		Top = 624, ;
		Width = 96
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 17, ;
		Left = 27, ;
		Name = "Glmaint", ;
		Top = 396, ;
		Width = 21
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'grdappmtdet' AS grdgridcustom WITH ;
		ColumnCount = 8, ;
		cworkarea = .NULL., ;
		HeaderHeight = 22, ;
		Height = 489, ;
		lcolumnmemory = .F., ;
		Left = 16, ;
		LinkMaster = "appmthdr", ;
		Name = "grdappmtdet", ;
		Panel = 1, ;
		RecordSource = "appmtdet", ;
		RelationalExpr = "cbatch", ;
		TabIndex = 10, ;
		Top = 96, ;
		Width = 887, ;
		ZOrderSet = 18, ;
		Column1.Bound = .F., ;
		Column1.ControlSource = "vendor.cvendname", ;
		Column1.FontSize = 8, ;
		Column1.Name = "Column1", ;
		Column1.ReadOnly = .T., ;
		Column1.Width = 195, ;
		Column2.Bound = .T., ;
		Column2.ControlSource = "appmtdet.cinvnum", ;
		Column2.FontSize = 8, ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 124, ;
		Column3.Bound = .T., ;
		Column3.ColumnOrder = 6, ;
		Column3.ControlSource = "appmtdet.ndisctot", ;
		Column3.FontSize = 8, ;
		Column3.Name = "Column3", ;
		Column3.ReadOnly = .T., ;
		Column3.Width = 97, ;
		Column4.BackColor = 255,255,128, ;
		Column4.Bound = .T., ;
		Column4.ColumnOrder = 5, ;
		Column4.ControlSource = "appmtdet.ndisctaken", ;
		Column4.FontSize = 8, ;
		Column4.Name = "Column4", ;
		Column4.Width = 91, ;
		Column5.Bound = .T., ;
		Column5.ColumnOrder = 4, ;
		Column5.ControlSource = "appmtdet.ninvbal", ;
		Column5.FontSize = 8, ;
		Column5.Name = "Column6", ;
		Column5.ReadOnly = .T., ;
		Column5.Width = 100, ;
		Column6.BackColor = 255,255,128, ;
		Column6.Bound = .T., ;
		Column6.ColumnOrder = 7, ;
		Column6.ControlSource = "appmtdet.namtpaid", ;
		Column6.FontSize = 8, ;
		Column6.Name = "Column7", ;
		Column6.Width = 95, ;
		Column7.ColumnOrder = 3, ;
		Column7.ControlSource = "appmtdet.dduedate", ;
		Column7.FontSize = 8, ;
		Column7.Name = "Column8", ;
		Column7.ReadOnly = .T., ;
		Column7.Width = 90, ;
		Column8.FontSize = 8, ;
		Column8.Name = "Column5", ;
		Column8.Sparse = .F., ;
		Column8.Width = 55
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="grid" />

	ADD OBJECT 'grdappmtdet.Column1.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Vendor", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdappmtdet.Column1.txtcVendName' AS textbox WITH ;
		ControlSource = "vendor.cvendname", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 104, ;
		Name = "txtcVendName", ;
		ReadOnly = .T., ;
		TabStop = .F., ;
		Top = 26, ;
		Width = 100
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdappmtdet.Column2.Header2' AS header WITH ;
		Alignment = 2, ;
		Caption = "Inv No.", ;
		FontSize = 8, ;
		Name = "Header2"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdappmtdet.Column2.txtcInvNum' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 38, ;
		Name = "txtcInvNum", ;
		ReadOnly = .T., ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdappmtdet.Column3.Header3' AS header WITH ;
		Alignment = 2, ;
		Caption = "Disc Avail", ;
		FontSize = 8, ;
		Name = "Header3"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdappmtdet.Column3.txtnDiscAvail' AS textbox WITH ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 32, ;
		Name = "txtnDiscAvail", ;
		TabIndex = 5, ;
		TabStop = .F., ;
		Top = 26, ;
		Width = 100
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdappmtdet.Column4.Header4' AS header WITH ;
		Alignment = 2, ;
		BackColor = 255,255,128, ;
		Caption = "Disc Taken", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Name = "Header4"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdappmtdet.Column4.txtnDistaken' AS txttextboxcustom WITH ;
		BackColor = 255,255,128, ;
		FontName = "Arial", ;
		Left = 44, ;
		Name = "txtnDistaken", ;
		TabIndex = 6, ;
		Top = 26
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdappmtdet.Column5.cmdPay' AS cmdcommandbuttoncustom WITH ;
		Caption = "Pay", ;
		FontSize = 8, ;
		Left = 9, ;
		Name = "cmdPay", ;
		TabStop = .F., ;
		Top = 26
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'grdappmtdet.Column5.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "", ;
		FontSize = 8, ;
		Name = "Header1", ;
		Picture = ..\graphics\checkoff.bmp, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdappmtdet.Column6.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Amt Due", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdappmtdet.Column6.txtnAmtDue' AS txttextboxcustom WITH ;
		BackColor = 255,255,255, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 25, ;
		Name = "txtnAmtDue", ;
		ReadOnly = .T., ;
		TabIndex = 4, ;
		TabStop = .F., ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdappmtdet.Column7.Header1' AS header WITH ;
		Alignment = 2, ;
		BackColor = 255,255,128, ;
		Caption = "Payment", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdappmtdet.Column7.txtnPayment' AS txttextboxcustom WITH ;
		BackColor = 255,255,128, ;
		FontName = "Arial", ;
		InputMask = "9999999.99", ;
		Left = 34, ;
		Name = "txtnPayment", ;
		TabIndex = 7, ;
		Top = 26
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdappmtdet.Column8.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Due Date", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdappmtdet.Column8.txtdDueDate' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "txtdDueDate", ;
		ReadOnly = .T., ;
		TabIndex = 3, ;
		TabStop = .F.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'Grouptran' AS grouptran WITH ;
		Height = 19, ;
		Left = 648, ;
		Name = "Grouptran", ;
		Top = 12, ;
		Width = 21
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCashAcct' AS lbllabelcustom WITH ;
		Caption = "Pmt Account", ;
		FontSize = 8, ;
		Left = 177, ;
		Name = "lblCashAcct", ;
		TabIndex = 5, ;
		Top = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDrecdate' AS lblfieldlabelcustom WITH ;
		Caption = "Pmt Date", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 13, ;
		Name = "lblDrecdate", ;
		TabIndex = 4, ;
		Top = 6, ;
		Width = 44, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Total Paid", ;
		FontSize = 8, ;
		Left = 652, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 14, ;
		Top = 594
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Total Due", ;
		FontSize = 8, ;
		Left = 377, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 13, ;
		Top = 594
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		Caption = "Pay By", ;
		Left = 553, ;
		Name = "Lbllabelcustom3", ;
		Top = 631
		*< END OBJECT: ClassLib="..\..\codeminenew\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'opgSelectBills' AS opgoptiongroupcustom WITH ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		Height = 48, ;
		Left = 24, ;
		Name = "opgSelectBills", ;
		TabIndex = 6, ;
		Top = 45, ;
		Width = 192, ;
		Option1.Caption = "Show Bills Due On Or Before", ;
		Option1.FontSize = 8, ;
		Option1.Height = 17, ;
		Option1.Left = 5, ;
		Option1.Name = "SelectDate", ;
		Option1.Top = 5, ;
		Option1.Width = 175, ;
		Option2.Caption = "Show All Bills", ;
		Option2.FontSize = 8, ;
		Option2.Height = 17, ;
		Option2.Left = 5, ;
		Option2.Name = "SelectAll", ;
		Option2.Top = 24, ;
		Option2.Width = 151
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtDate' AS dpk WITH ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 192, ;
		Name = "txtDate", ;
		TabIndex = 7, ;
		Top = 49, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtdPmtDate' AS dpk WITH ;
		ControlSource = "appmthdr.dpmtdate", ;
		Height = 20, ;
		lcheckdate = .T., ;
		Left = 60, ;
		Name = "txtdPmtDate", ;
		TabIndex = 2, ;
		Top = 5, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtnBalance' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		ControlSource = "appmthdr.ntotdue", ;
		FontSize = 8, ;
		Height = 20, ;
		InputMask = "999,999,999.99", ;
		Left = 431, ;
		Margin = 1, ;
		Name = "txtnBalance", ;
		TabIndex = 11, ;
		Top = 590, ;
		Width = 107
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtnTotPaid' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		ControlSource = "appmthdr.ntotpaid", ;
		FontSize = 8, ;
		Height = 20, ;
		InputMask = "999,999,999.99", ;
		Left = 704, ;
		Margin = 1, ;
		Name = "txtnTotPaid", ;
		TabIndex = 12, ;
		Top = 590, ;
		Width = 123
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE applypmts		&& Automatically applies the payment amount to outstanding invoices.
	ENDPROC

	PROCEDURE beforeclose
		LPARAMETERS nCloseReason
		
		lcBatch = appmthdr.cbatch
		SELECT appmtdet
		LOCATE FOR cbatch == lcBatch AND nAmtPaid <> 0  
		IF NOT FOUND()
		   SELECT appmthdr
		   =TABLEREVERT(.t.)
		   SELECT appmtdet
		   =TABLEREVERT(.t.)
		ELSE 
		   DODEFAULT(nCloseReason)   
		ENDIF
		
		
	ENDPROC

	PROCEDURE billsselected		&& Returns the balance of bills selected for the given vendor.
		LPARAMETERS tcVendorid, tcBatch, tcPK
		
		
		SELECT SUM(namtpaid) as nselected ;
		   FROM appmtdet WITH (buffering=.t.) ;
		   WHERE cvendorid = tcVendorID AND cBatch = tcBatch ;
		     AND appmtdet.cidappmd # tcPK ;
		   INTO CURSOR temp
		lnBalance = nselected
		
		RETURN lnBalance
		
		
	ENDPROC

	PROCEDURE calcapplied
	ENDPROC

	PROCEDURE calctot
		LOCAL lnSelect, lcBatch, lnBalance, lnTotal
		
		lnBalance = 0
		lcBatch   = appmthdr.cBatch
		* wait wind 'Hdr = ' + appmthdr.cbatch + ' Det = ' + appmtdet.cbatch
		lnSelect = SELECT()
		
		SELECT appmtdet
		lnRecNo = RECNO()
		
		lnBalance = 0
		lnTotal   = 0
		SCAN FOR cBatch == lcBatch
		   lnBalance = lnBalance + ninvbal
		   lnTotal   = lnTotal   + namtpaid
		ENDSCAN
		
		IF lnRecNo <= RECCOUNT()
		   GOTO (lnRecNo)
		ENDIF
		
		THISFORM.cmdatamanager.REPLACE('Appmthdr', 'NtotDue', lnBalance)
		THISFORM.cmdatamanager.REPLACE('Appmthdr', 'Ntotpaid', lnTotal)
		THISFORM.txtnBalance.VALUE = lnBalance
		THISFORM.txtnBalance.REFRESH()
		
		THISFORM.txtnTotPaid.VALUE = lnTotal
		THISFORM.txtnTotPaid.REFRESH()
		
		SELECT (lnSelect)
		
		UNLOCK
		
	ENDPROC

	PROCEDURE checkforpmts
		*
		* Check to see if any bills have been marked to pay
		*
		LOCAL lcBatch, lnCount
		
		lnCount = 0
		lcBatch = appmthdr.cbatch
		
		SELECT COUNT(*) as pmts, SUM(namtpaid) as ntotal ;
		  FROM appmtdet WITH (BUFFERING=.T.) ;
		  WHERE cbatch = lcbatch ;
		  INTO CURSOR temp
		  
		 
		 SELECT temp
		 GO top
		 lnCount = pmts
		 USE IN temp
		 
		 RETURN lnCount
	ENDPROC

	PROCEDURE close
		LPARAMETERS nCloseReason
		thisform.LockScreen = .t.
		**  Check for any payments applied.  If there aren't any, just revert and close the screen, so it doesn't have to ask about saving. - BH 2/3/09
		SELECT appmtdet
		LOCATE FOR nAmtPaid <> 0  
		IF NOT FOUND()
		   SELECT appmthdr
		   =TABLEREVERT(.t.)
		   SELECT appmtdet
		   =TABLEREVERT(.t.)
		ENDIF
		
		
		return(DODEFAULT(nCloseReason))
		
	ENDPROC

	PROCEDURE Destroy
		
		thisform.grouptran.unload()
		thisform.LockScreen = .f.
		DODEFAULT()
	ENDPROC

	PROCEDURE first
		LPARAMETERS cworkarea
		*
	ENDPROC

	PROCEDURE Init
		LOCAL lcCashAcct
		swselect('apopt')
		lcCashAcct = apopt.cAPCash
		IF EMPTY(lcCashAcct)  &&  No cash account chosen, so warn them, and don't let them in until they specify one
		   THISFORM.oMessage.Warning('Before paying bills, you must specify the cash account in the Accounts Payable section of the Edit >> Preferences screen. Once chosen, it will be the default cash account for paying bills.')
		   THISFORM.RELEASE()
		   RETURN .F.
		ENDIF
		
		IF DODEFAULT()
		   thisform.NewPayments()
		ENDIF
		
	ENDPROC

	PROCEDURE last
		LPARAMETERS cworkarea
		*
	ENDPROC

	PROCEDURE list
		LPARAMETERS cworkarea
		*
	ENDPROC

	PROCEDURE markbills
		LOCAL tcType
		LOCAL lcBatch 
		
		lcBatch     = appmthdr.cBatch
		
		SELECT SUM(namtpaid) as ntot FROM appmtdet WITH (BUFFERING=.T.) WHERE cBatch == lcBatch INTO CURSOR temp
		GO top
		lnTotal = temp.ntot
		swclose('temp')
		
		IF lnTotal > 0
		   tcType = 'UNMARK'
		   thisform.grdappmtdet.column5.header1.Picture = "checkoff.bmp"
		ELSE
		   tcType = 'MARK'
		   thisform.grdappmtdet.column5.header1.Picture = "checkon.bmp"
		ENDIF   
		
		DO CASE
		   CASE tcType = 'MARK'
		      
		      SELECT appmtdet
		      SCAN FOR cBatch = lcBatch
		         REPL nAmtPaid WITH IIF(appmtdet.dDiscDate>=appmthdr.dPmtDate,appmtdet.nInvBal-appmtdet.nDiscTot,appmtdet.nInvBal),appmtdet.ndisctaken WITH IIF(appmtdet.dDiscDate>=appmthdr.dPmtDate,appmtdet.ndisctot,0)
		      ENDSCAN
		      thisform.calctot()
		      thisform.refresh()
		               
		   CASE tcType = 'UNMARK'
		      
		      SELECT appmtdet
		      SCAN FOR cBatch = lcBatch
		         REPL nAmtPaid WITH 0, ndisctaken WITH 0
		      ENDSCAN
		      thisform.calctot()
		      thisform.refresh()
		       
		ENDCASE   
	ENDPROC

	PROCEDURE new
		LPARAMETERS cWorkarea
		
		IF thisform.lnotnew = .f.
		   thisform.lnotnew = .t.
		ELSE
		   RETURN .f.
		ENDIF
		
		DODEFAULT(cWorkarea)
	ENDPROC

	PROCEDURE newpayments
		
		
		
		swselect('apopt')
		lcCashAcct = cAPCash
		
		swselect('coa')
		LOCATE FOR cAcctNo == lcCashAcct AND lBankAcct  &&  Make sure this account is a bank account.  If not, just select the first available bank account to use
		IF NOT FOUND()
		   LOCATE FOR lBankAcct
		   IF FOUND()
		      lcCashAcct = cAcctNo
		   ENDIF
		ENDIF
		
		lcAcct = lcCashAcct
		lnCash = 1
		FOR lnX = 1 TO THISFORM.cbocashacct.DISPLAYCOUNT
		   IF THISFORM.cbocashacct[lnx, 2].VALUE = lcCashAcct
		      lnCash = lnX
		      lcAcct = THISFORM.cbocashacct[lnx, 2].VALUE
		   ENDIF
		ENDFOR
		THISFORM.cmdatamanager.REPLACE('Appmthdr', 'Cacctno', lcAcct)
		THISFORM.cbocashacct.LISTITEMID = lnCash
		
		THISFORM.new('Appmthdr')
		thisform.lNewrecord = .T.
		THISFORM.requeryrecordsource()
		THISFORM.txtdpmtdate.SETFOCUS()
		THISFORM.setnextcontrol(THISFORM.grdappmtdet)
	ENDPROC

	PROCEDURE next
		LPARAMETERS cworkarea
		*
	ENDPROC

	PROCEDURE prior
		LPARAMETERS cworkarea
		*
	ENDPROC

	PROCEDURE requeryrecordsource
		LOCAL lcBatch, lnCount, lnSelect, lcDeleted, lnDueOrder
		
		*
		*  If the sort order = 2  this routine requeries the due date view,
		*  otherwise it requeries the vendor view
		
		DO CASE 
		   CASE thisform.cbosortBy.Value = 'V '
		      lnDueOrder = 1
		   CASE thisform.cbosortBy.Value = 'DA'
		      lnDueOrder = 2
		   CASE thisform.cbosortBy.Value = 'DD'
		      lnDueOrder = 3
		   CASE thisform.cbosortBy.Value = 'VD'
		      lnDueOrder = 4
		ENDCASE                
		
		* 
		*
		*  Check for outstanding bills.
		*
		lnSelect   = SELECT()
		lcBatch    = appmthdr.cBatch
		IF VARTYPE(thisform.txtDate.value) <> 'D'
		   ldSelectBy = CTOD(thisform.txtDate.value)
		ELSE
		   ldSelectBy = thisform.txtDate.value
		ENDIF   
		ldDiscBy   = ldSelectBy
		lcDeleted = SET('DELETED')
		SET DELETED ON
		
		SELECT appurchh
		SET ORDER TO cBatch
		
		SELECT terms
		SET ORDER TO cidterm
		WAIT WINDOW NOWAIT 'Building list of outstanding bills...Please wait.'
		IF this.lNewRecord
		   DO CASE
		      CASE lnDueOrder = 1
		         =requery('APInvOutV')
		      CASE lnDueOrder = 2   
		         =requery('APInvOutD')
		      CASE lnDueOrder = 3   
		         =requery('APInvOutDD')   
		   ENDCASE      
		
		*
		*  Check for existing outstanding invoices in the
		*  payment detail file.  If we find any, we shouldn't
		*  have, because this is supposed to be a new record
		*
		
		   SELECT appmtdet
		   SCAN FOR cBatch == lcBatch
		      DELE NEXT 1
		   ENDSCAN   
		
		   *  Had to put this refresh in so the currently displayed records
		   *  will disappear from the grid.  A grid refresh didn't work.
		   thisform.grdappmtdet.refresh()
		   GO TOP
		   lcSafety = SET('safety')
		   SET SAFETY OFF 
		   DO CASE
		      CASE lnDueOrder = 1
		         SELECT APInvOutV
		         INDEX on cvendname+cbatch TAG myorder1
		      CASE lnDueOrder = 2
		         SELECT APInvOutD
		      CASE lnDueOrder = 3
		         SELECT APInvOutDD   
		      CASE lnDueOrder = 4
		         SELECT APInvOutV
		         INDEX on cvendname+DTOS(dduedate) TAG myorder2    
		   ENDCASE
		   SET SAFETY &lcSafety
		   
		   IF RECC() > 0
		      SCAN
		         SCATTER MEMVAR
		         m.cBillToken = cBatch
		         m.cBatch = lcBatch
		         SELECT appmtdet1
		         SET ORDER TO cidarpmd
		         SET DELETED OFF
		         m.cidappmd = thisform.oRegistry.IncrementCounter('%Shared.Counters.AP Payment Detail')
		         DO WHILE SEEK(m.cidappmd)
		            m.cidappmd = thisform.oRegistry.IncrementCounter('%Shared.Counters.AP Payment Detail')
		         ENDDO   
		         SELECT appurchh
		         LOCATE FOR cBatch = m.cBillToken
		         IF FOUND()
		            m.cidterm = cidterm
		         ELSE
		            m.cidterm = ''
		         ENDIF
		                        
		         SELECT terms
		         LOCATE FOR cidterm = m.cidterm
		         IF FOUND()
		            m.nDiscPct = nDiscPct
		         ELSE 
		            m.nDiscPct = 0
		         ENDIF      
		         
		         IF m.nDiscPct <> 0
		            m.nDiscTot = ROUND(m.nInvBal * (m.nDiscPct/100),2)
		         ELSE
		            m.nDiscTot = 0
		         ENDIF
		               
		         SELECT appmtdet
		         SET DELETED ON
		         INSERT INTO appmtdet FROM MEMVAR
		
		      ENDSCAN
		
		      SELECT appmtdet
		      GO TOP
		
		      *  Show new records
		      thisform.refresh()
		   ENDIF
		ENDIF
		
		*  Show the total amount due
		thisform.calctot()
		
		SET DELETED &lcDeleted
		
		SELECT (lnSelect)
		
		WAIT CLEAR
	ENDPROC

	PROCEDURE Resize
		DODEFAULT()
		thisform.grdappmtdet.Refresh()
	ENDPROC

	PROCEDURE save
		LPARAMETERS cworkarealist
		
		IF thisform.txtnTotPaid.Value < 0
		   MESSAGEBOX('There are more credits than bills being applied. Please correct before saving these payments.',16,'Pmt Problem')
		   RETURN .f.
		ENDIF 
		
		lcBatch = appmthdr.cbatch
		SELECT appmtdet
		DELETE FOR cbatch == lcBatch AND nAmtPaid = 0
		THISFORM.lchanged = .T.
		DODEFAULT(cworkarealist)
		
		IF MESSAGEBOX('Continue paying bills?', 36, 'Pay Bills') = 7
		   THISFORM.RELEASE()
		ELSE
		   thisform.lnotnew = .f.
		   THISFORM.NewPayments()
		   thisform.requeryrecordsource()
		ENDIF
		
		
	ENDPROC

	PROCEDURE cboCashAcct.Init
		LOCAL lnX, laBankAcct[1,1], lnCount, lcCashAcct, lnCash, lnAcct
		
		* Get the default payment account from A/P Options
		SELECT apopt
		GO TOP
		lcCashAcct = cAPCash
		lnAcct     = 1
		
		SELECT cAcctNo, cAcctDesc FROM coa WHERE lBankAcct = .T. INTO ARRAY laBankAcct ORDER BY cAcctNo
		
		lnCount = _TALLY
		IF lnCount > 0
		   FOR lnX = 1 TO lnCount
		      IF laBankAcct[lnX,1] = lcCashAcct
		         lnAcct = lnX
		      ENDIF
		      THIS.ADDLISTITEM(laBankAcct[lnX,1]+'-'+TRIM(laBankAcct[lnX,2]),lnX,1)
		      THIS.ADDLISTITEM(laBankAcct[lnX,1],lnX,2)
		   ENDFOR
		*   this.ListItemId = lnAcct
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cboPayBy.Init
		IF DODEFAULT()
		   this.AddListItem('Check      ',1,1)
		   this.AddListItem('CHK',1,2)
		   this.AddListItem('Wire       ',2,1)
		   this.AddListItem('WRE',2,2)
		   this.AddListItem('ACH        ',3,1)
		   this.AddListItem('ACH',3,2)
		   this.AddListItem('Credit Card',4,1)
		   this.AddListItem('CRD',4,2)
		ENDIF 
		
		this.Value = 'CHK'
	ENDPROC

	PROCEDURE cboSortBy.Init
		IF DODEFAULT()
		   this.AddListItem('Sort By Vendor',1,1)
		   this.AddListItem('V ',1,2)
		   this.AddListItem('Sort By Due Date( Ascending)',2,1)
		   this.AddListItem('DA',2,2)
		   this.AddListItem('Sort By Due Date (Descending)',3,1)
		   this.AddListItem('DD',3,2)
		   this.AddListItem('Sort By Vendor/Due Date',4,1)
		   this.AddListItem('VD',4,2)
		   this.Value = 'V '
		ENDIF 
	ENDPROC

	PROCEDURE cboSortBy.Valid
		IF DODEFAULT()
		   thisform.requeryrecordsource()
		ENDIF 
	ENDPROC

	PROCEDURE cmdatamanager.afternew
		LPARAMETERS cworkarea
		LOCAL lcCashAcct
		
		IF m.cworkarea == 'Appmthdr'
		   SELECT apopt
		   GO TOP
		   lcCashAcct = cAPCash
		   
		   SELECT coa
		   LOCATE FOR cAcctNo == lcCashAcct AND lBankAcct  &&  Make sure this account is a bank account.  If not, just select the first available bank account to use
		   IF NOT FOUND()
		      LOCATE FOR lBankAcct 
		      IF FOUND()
		         lcCashAcct = cAcctNo
		      ENDIF
		   endif
		
		   m.cBatch = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		   SELECT glmaster
		   SET ORDER TO glBatch
		   SET DELETED OFF
		   DO WHILE SEEK(m.cBatch)
		      m.cBatch = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		   ENDDO
		   SELECT appmthdr
		   SET DELETED ON
		   REPLACE cBatch    WITH m.cBatch,  ;
		      dBillDate WITH DATE(), ;
		      dPmtDate  WITH DATE(), ;
		      cAcctNo   WITH lcCashAcct, ;
		      lNewPmt   WITH .T.
		   THISFORM.cboCashAcct.REFRESH()
		   THISFORM.txtDate.value = DATE()
		   THISFORM.txtDate.REFRESH()
		   THISFORM.requeryrecordsource()
		   THISFORM.txtdPmtDate.value = DATE()
		   THISFORM.txtdPmtDate.REFRESH()
		   THISFORM.txtdPmtDate.SETFOCUS()
		   SELECT appmthdr
		   THISFORM.lNewRecord = .T.
		ENDIF
		
		DODEFAULT(m.cworkarea)
		
	ENDPROC

	PROCEDURE cmdatamanager.afterupdate
		LPARAMETERS cworkarealist
		LOCAL lcBatch
		
		lcBatch = THISFORM.glmaint.cbatch
		
		IF TYPE('m.goApp') = 'O'
		    m.cProducer = m.goApp.cCompanyName
		ELSE
		    m.cProducer = 'Sample Company'
		ENDIF
		
		TRY
		    IF THISFORM.oMessage.CONFIRM('Do you want a report on these payments? If you answer No at this time, you will be unable to reprint this report later.')
				SELECT  appmtdet.cInvNum, ;
						appmtdet.cVendorId, ;
						vendor.cVendName, ;
						appmtdet.dDueDate, ;
						appmtdet.dDiscDate, ;
						appmtdet.nDiscTaken AS nDiscTot, ;  &&  nDiscTaken is the actual field the amount applied is stored in - BH 10/26/09
						appmtdet.nInvBal, ;
						appmtdet.cidchec, ;
						appmtdet.nAmtPaid ;
					FROM appmtdet, vendor ;
					WHERE cbatch == lcBatch ;
						AND appmtdet.cVendorId = vendor.cVendorId ;
						AND appmtdet.nAmtPaid <> 0 ;
					INTO CURSOR temppmt ;
					ORDER BY appmtdet.cVendorId
		        IF _TALLY > 0
		            lcTitle1     = 'Payments Made on ' + DTOC(THISFORM.txtdPmtDate.VALUE)
		            llPrintError = .F.
		            lcError      = ''
		
		* Catch any printer errors and exit gracefully instead of bombing out
		            TRY
		                REPORT FORM apbillpay.frx TO PRINTER PREVIEW
		            CATCH TO loError
		                llPrintError = .T.
		                lcError      = loError.MESSAGE
		            ENDTRY
		            IF llPrintError
		                MESSAGEBOX('The report could not be printed. There was a problem with the printer.' + CHR(10) + ;
		                      lcError, 16, 'Printer Problem')
		            ELSE
		                IF THISFORM.oMessage.CONFIRM('Should the report be sent to the printer now?')
		                    REPORT FORM apbillpay.frx TO PRINTER PROMPT NOCONSOLE NOEJECT
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		CATCH TO loError
		* log any errors encountered
		    DO errorlog WITH 'afterupdate', loError.LineNo, 'APBILLPAY', loError.ERRORNO, loError.MESSAGE
		    MESSAGEBOX('The report could not be printed. ' + CHR(10) + ;
		          'Error: ' + loError.MESSAGE + CHR(10) + CHR(10) + ;
		          'Try to reprint it from the A/P Reports menu.', 16, 'Report Problem')
		ENDTRY
		
		
	ENDPROC

	PROCEDURE cmdatamanager.beforedelete
		LPARAMETERS cworkarea
		LOCAL lcBatch
		
		*  Payments cannot be deleted using this form.
		thisform.omessage.display('Payments cannot be deleted using this screen.  You must delete or void the check created by the payment.')
		RETURN .F.
		
	ENDPROC

	PROCEDURE cmdatamanager.beforenew
		LPARAMETERS cworkarea
		
		IF m.cworkarea == 'Appmthdr'
		
		   SELECT appmthdr
		   REPLACE dAdded   WITH DATETIME(), ;
		           cAddedBy WITH m.goapp.cuser
		           
		   SELECT coa
		   SET ORDER TO acctno
		   IF SEEK(appmthdr.cacctno) AND lBankAcct
		      THISFORM.coldacctno = appmthdr.cacctno
		   ELSE
		      THISFORM.coldacctno = ''
		   ENDIF      
		   WAIT WIND NOWAIT 'Looking for bills...'
		ENDIF
		
	ENDPROC

	PROCEDURE cmdatamanager.beforeupdate
		LPARAMETERS cworkarealist
		LOCAL lcBatch, lcAPAcct, lcDiscAcct, llReturn, lcSelect, lnRecNo
		LOCAL lcVendor, lcVendName, lnX, lnChkCount, llDiscTaken
		LOCAL lcCheckKey
		*:Global cVendName, cVendorId, cidchec, nAmtPaid
		
		lcBatch     = appmthdr.cBatch
		lnChkCount  = 0
		llDiscTaken = .F.
		lcSelect    = SELECT()
		lnChkCount  = 0
		
		*  Make sure the period or year isn't closed
		IF NOT THISFORM.glmaint.CheckPeriod(appmthdr.dpmtdate)
		   THISFORM.omessage.warning('Unable to save this payment. Either the fiscal year or period represented by this date has been closed.')
		   RETURN .F.
		ENDIF
		
		IF NOT THISFORM.lChanged
		   RETURN .F.
		ENDIF
		
		*  Look for checks that have already been printed
		swselect('appmtdet')
		SCAN FOR cBatch == lcBatch
		   m.nAmtPaid = nAmtPaid
		   m.cidchec  = cidchec
		
		*  Remove bills that weren't paid
		   IF m.nAmtPaid = 0
		      DELETE NEXT 1
		      LOOP
		   ENDIF
		
		   IF nDiscTaken # 0  &&  A discount has been taken, so set the flag, so we know to check the discount account setting
		      m.llDiscTaken = .T.
		   ENDIF
		
		   IF NOT EMPTY(m.cidchec)
		      THISFORM.omessage.DISPLAY('You cannot update bill payment records.')
		      THISFORM.cmdatamanager.revertall()
		      RETURN .F.
		   ENDIF
		ENDSCAN
		
		swselect('appmtdet')
		LOCATE FOR cBatch == lcBatch AND NOT DELETED()
		IF NOT FOUND()  &&  No bills paid, so bail out, and don't try and post or print a report
		   THISFORM.omessage.DISPLAY('No bills were marked to be paid.')
		   RETURN .F.
		ENDIF
		
		*
		* Get the default A/P accounts
		*
		swselect('apopt')
		GO TOP
		lcAPAcct   = cAPAcct
		lcDiscAcct = cDiscAcct
		
		IF EMPTY(lcAPAcct)
		   THISFORM.omessage.warning('Please specify the A/P Account on the Accounts Payable section of the Edit >> Preferences screen before saving this payment.')
		   RETURN .F.
		ENDIF
		IF llDiscTaken AND EMPTY(lcDiscAcct)
		   THISFORM.omessage.warning('You are using a discount on one or more bills.  Please specify the Discounts Taken Account on the Accounts Payable section of the Edit >> Preferences screen before saving this payment.')
		   RETURN .F.
		ENDIF
		
		TRY
		
		   WAIT WINDOW NOWAIT 'Saving Changes, Please Wait.....'
		
		
		*
		*  Delete the G/L journal entries for this payment
		*
		   THISFORM.glmaint.delbatch(lcBatch, 'AP')
		
		*
		*  Set the source for this entry
		*
		   THISFORM.glmaint.cSource = 'AP'
		
		*
		*  Create cursor that combines bill payments by vendor
		*
		   CREATE CURSOR tempchks ;
		      (cVendorId    C(10), ;
		        cVendName    C(40), ;
		        nAmtPaid     N(12, 2), ;
		        nDiscTaken   N(12, 2), ;
		        cidchec      C(8))
		   INDEX ON cVendorId TAG vendor
		
		   swselect('appmtdet')
		   SCAN FOR cBatch == lcBatch
		      SCATTER MEMVAR
		      SELECT tempchks
		      IF m.nAmtPaid # 0
		         IF SEEK(m.cVendorId)
		            REPL nAmtPaid WITH nAmtPaid + m.nAmtPaid
		         ELSE
		            APPEND BLANK
		            REPL cVendorId WITH m.cVendorId, ;
		               nAmtPaid  WITH m.nAmtPaid, ;
		               cidchec   WITH m.cidchec
		         ENDIF
		      ENDIF
		      IF m.nDiscTaken # 0
		         IF SEEK(m.cVendorId)
		            REPL nDiscTaken WITH nDiscTaken + m.nDiscTaken
		         ELSE
		            APPEND BLANK
		            REPL cVendorId  WITH m.cVendorId, ;
		               nDiscTaken WITH m.nDiscTaken
		         ENDIF
		      ENDIF
		   ENDSCAN
		*
		*  Fill in the vendor name
		*
		   SELECT tempchks
		   SCAN
		      m.cVendorId = cVendorId
		      IF nAmtPaid < 0
		         DELE NEXT 1
		      ELSE
		         swselect('vendor')
		         IF SEEK(m.cVendorId)
		            m.cVendName = cVendName
		            SELECT tempchks
		            REPL cVendName WITH m.cVendName
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		*
		*  Create the G/L journal entries for this payment
		*
		   SELECT tempchks
		   SCAN
		      SCATTER MEMVAR
		
		*
		*  Create Check Register Entry
		*
		      IF m.nAmtPaid > 0
		         THISFORM.glmaint.cId        = m.cVendorId
		         THISFORM.glmaint.cidType    = 'V'
		         THISFORM.glmaint.dCheckDate = appmthdr.dpmtdate
		         THISFORM.glmaint.dPostDate  = appmthdr.dpmtdate
		         THISFORM.glmaint.cSource    = 'AP'
		         THISFORM.glmaint.cPayee     = m.cVendName
		         THISFORM.glmaint.nAmount    = m.nAmtPaid
		         THISFORM.glmaint.cEntryType = 'C'
		         THISFORM.glmaint.cAcctNo    = appmthdr.cAcctNo
		         THISFORM.glmaint.cBatch     = lcBatch
		
		* Set the check register entry correctly depending on how
		* the bill is being paid. If it is a check, set the check
		* to be printed. If it is an ACH or WIRE mark them as such
		* and mark them as printed.            
		         DO CASE
		            CASE THISFORM.cPmtType = 'CHK'
		               THISFORM.glmaint.cCheckno = ''
		               THISFORM.glmaint.lprinted = .F.
		            CASE THISFORM.cPmtType = 'ACH'
		               THISFORM.glmaint.cCheckno = '       ACH'
		               THISFORM.glmaint.lprinted = .T.
		            CASE THISFORM.cPmtType = 'WRE'
		               THISFORM.glmaint.cCheckno = '      WIRE'
		               THISFORM.glmaint.lprinted = .T.
		            CASE THISFORM.cPmtType = 'CRD'
		               THISFORM.glmaint.cCheckno = '     CCPMT'
		               THISFORM.glmaint.lprinted = .T.   
		            OTHERWISE
		               THISFORM.glmaint.cCheckno = ''
		               THISFORM.glmaint.lprinted = .F.
		         ENDCASE
		
		*  Add the entry to the checks table
		         THISFORM.glmaint.addcheck()
		         lnChkCount = lnChkCount + 1
		
		*  Get the key of the check just created
		*  and put it in the payment detail rec.
		         lcCheckKey               = THISFORM.glmaint.GETKEY()
		         THISFORM.glmaint.cidchec = lcCheckKey
		         SELECT appmtdet
		         SCAN FOR cBatch == lcBatch ;
		               AND cVendorId == m.cVendorId ;
		               AND nAmtPaid # 0
		            REPL cidchec WITH lcCheckKey
		         ENDSCAN
		      ENDIF
		
		*  Create A/P entry
		      THISFORM.glmaint.cBatch     = lcBatch
		      THISFORM.glmaint.dGLDate    = appmthdr.dpmtdate
		      THISFORM.glmaint.cReference = 'PMT'
		      THISFORM.glmaint.cDesc      = m.cVendName
		      THISFORM.glmaint.cAcctNo    = lcAPAcct
		      THISFORM.glmaint.cId        = m.cVendorId
		      THISFORM.glmaint.nAmount    = m.nAmtPaid + m.nDiscTaken
		      THISFORM.glmaint.cbunch     = THISFORM.cbunch
		      THISFORM.glmaint.cyear      = ' '
		      THISFORM.glmaint.cperiod    = ' '
		
		      THISFORM.glmaint.updatebatch()
		
		*  Create Discount Taken Entry
		      IF m.nDiscTaken # 0
		         THISFORM.glmaint.cBatch     = lcBatch
		         THISFORM.glmaint.dGLDate    = appmthdr.dpmtdate
		         THISFORM.glmaint.cReference = 'PMT'
		         THISFORM.glmaint.cDesc      = m.cVendName
		         THISFORM.glmaint.cAcctNo    = lcDiscAcct
		         THISFORM.glmaint.cId        = m.cVendorId
		         THISFORM.glmaint.nAmount    = m.nDiscTaken * -1     && Assume to be credit
		         THISFORM.glmaint.updatebatch()
		      ENDIF
		
		*  Create Cash Entry
		      THISFORM.glmaint.cBatch     = lcBatch
		      THISFORM.glmaint.dGLDate    = appmthdr.dpmtdate
		      THISFORM.glmaint.cReference = 'PMT'
		      THISFORM.glmaint.cDesc      = m.cVendName
		      THISFORM.glmaint.cAcctNo    = appmthdr.cAcctNo
		      THISFORM.glmaint.cId        = m.cVendorId
		      THISFORM.glmaint.nAmount    = m.nAmtPaid * -1     && Assume to be credit
		      THISFORM.glmaint.updatebatch()
		
		   ENDSCAN
		
		*
		*  Change the balance of the bills being paid
		*
		   SELECT tempchks
		   IF RECC() > 0
		      swselect('appmtdet')
		      SCAN FOR cBatch == lcBatch AND nAmtPaid # 0
		         SCATTER MEMVAR
		         SELECT tempchks
		         LOCATE FOR cVendorId == m.cVendorId
		         IF NOT FOUND()
		            LOOP  && Don't mark the bill or credit as paid if we didn't create a check
		         ENDIF
		         SELECT appurchh
		         IF SEEK(m.cBillToken)
		*  Don't allow the invoice balance to go below zero.
		*  An invoice can't have a negative balance unless it's
		*  a credit invoice and those aren't created here.
		            IF ((m.nAmtPaid + m.nDiscTaken) <= nInvBal) OR m.nAmtPaid < 0  &&  Added OR condition so credit memos can update their balances correctly - BH 01/17/2007
		               REPL nInvBal WITH nInvBal - (m.nAmtPaid + m.nDiscTaken), ;
		                  nPayments WITH m.nAmtPaid
		            ENDIF
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Check to make sure the batch balances
		*
		   llReturn = THISFORM.glmaint.chkBalance()
		
		   IF llReturn
		      IF NOT THIS.isnew('Appmthdr')
		         SELECT appmthdr
		         REPLACE dChanged WITH DATETIME(), ;
		                 cChangedBy WITH m.goapp.cUser
		      ENDIF
		         
		      WAIT WINDOW NOWAIT 'Changes Saved....' TIMEOUT 2
		      THISFORM.lNewRecord = .F.
		
		      DO CASE
		         CASE THISFORM.cPmtType = 'CHK'
		            IF lnChkCount = 1
		               THISFORM.omessage.DISPLAY('Created 1 check and placed it into the check register to be printed.')
		            ELSE
		               THISFORM.omessage.DISPLAY('Created ' + ALLTRIM(STR(lnChkCount)) + ' checks and placed them into the check register to be printed.')
		            ENDIF
		         CASE THISFORM.cPmtType = 'ACH'
		            IF lnChkCount = 1
		               THISFORM.omessage.DISPLAY('Created 1 ACH and placed it into the check register.')
		            ELSE
		               THISFORM.omessage.DISPLAY('Created ' + ALLTRIM(STR(lnChkCount)) + ' ACH entries and placed them into the check register.')
		            ENDIF
		         CASE THISFORM.cPmtType = 'WRE'
		            IF lnChkCount = 1
		               THISFORM.omessage.DISPLAY('Created 1 WIRE and placed it into the check register.')
		            ELSE
		               THISFORM.omessage.DISPLAY('Created ' + ALLTRIM(STR(lnChkCount)) + ' WIRE entries and placed them into the check register.')
		            ENDIF
		         CASE THISFORM.cPmtType = 'CRD'
		            IF lnChkCount = 1
		               THISFORM.omessage.DISPLAY('Created 1 Credit Card payment and placed it into the check register.')
		            ELSE
		               THISFORM.omessage.DISPLAY('Created ' + ALLTRIM(STR(lnChkCount)) + ' Credit Card payments and placed them into the check register.')
		            ENDIF   
		         OTHERWISE
		            THISFORM.glmaint.cCheckno = ''
		            THISFORM.glmaint.lprinted = .F.
		      ENDCASE
		
		   ELSE
		      WAIT WIND 'The Batch Was Not In Balance...Unable to save bill payments'
		   ENDIF
		
		   TABLEUPDATE(.T., .F., 'Appmthdr')
		   TABLEUPDATE(.T., .F., 'Appmtdet')
		
		CATCH TO loError
		   DO errorlog WITH 'beforeupdate', loError.LINENO, 'APBILLPAY', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX("The bill payments can't be saved. Please go to Reports, Other Reports, System Log and email the log to SherWare", 16, 'Save Problem')
		   llReturn = .F.
		ENDTRY
		
		RETURN (llReturn)
		
		
		
		
	ENDPROC

	PROCEDURE cmdatamanager.revertall
		LPARAMETERS cworkarealist
		
		IF DODEFAULT(cworkarealist)
		   thisform.release()
		ENDIF   
	ENDPROC

	PROCEDURE cmdPaybyCheck.Click
		IF THISFORM.CheckForPmts() # 0
		   DO CASE
		      CASE THISFORM.cbopayBy.VALUE = 'CHK'
		         IF MESSAGEBOX('This will create checks to pay the bills chosen. Is this correct?', 36, THISFORM.CAPTION) = 6
		            THISFORM.cPmtType = thisform.cbopayBy.value
		            THISFORM.SAVE()
		         ENDIF
		      CASE THISFORM.cbopayBy.VALUE = 'WRE'
		         IF MESSAGEBOX('This will mark the payments as a Wire Transfer to pay the bills chosen. Is this correct?', 36, THISFORM.CAPTION) = 6
		            THISFORM.cPmtType = thisform.cbopayBy.value
		            THISFORM.SAVE()
		         ENDIF
		      CASE THISFORM.cbopayBy.VALUE = 'ACH'
		         IF MESSAGEBOX('This will mark the payments as ACH payments to pay the bills chosen. Is this correct?', 36, THISFORM.CAPTION) = 6
		            THISFORM.cPmtType = thisform.cbopayBy.value
		            THISFORM.SAVE()
		         ENDIF
		      CASE THISFORM.cbopayBy.VALUE = 'CRD'
		         IF MESSAGEBOX('This will mark the payments as Credit Card payments to pay the bills chosen. Is this correct?', 36, THISFORM.CAPTION) = 6
		            THISFORM.cPmtType = thisform.cbopayBy.value
		            THISFORM.SAVE()
		         ENDIF
		   ENDCASE
		ELSE
		   MESSAGEBOX('No bills were chosen to be paid. Please mark some bills and then click Payment Type.', 64, THISFORM.CAPTION)
		ENDIF
	ENDPROC

	PROCEDURE grdappmtdet.AfterRowColChange
		LPARAMETERS ncol
		
		if ncol <> 7 and ncol <> 8 AND ncol <> 6
		   this.column7.txtnpayment.setfocus()
		endif
		   
		IF thisform.lChanged
		   thisform.calctot()
		ENDIF
		   
		RETURN (DODEFAULT(ncol))
		
	ENDPROC

	PROCEDURE grdappmtdet.Column1.Header1.Click
		thisform.requeryrecordsource()
	ENDPROC

	PROCEDURE grdappmtdet.Column1.txtcVendName.Click
		thisform.grdappmtdet.column7.txtnpayment.setfocus()
	ENDPROC

	PROCEDURE grdappmtdet.Column1.txtcVendName.When
		return .f.
	ENDPROC

	PROCEDURE grdappmtdet.Column2.Header2.Click
		thisform.requeryrecordsource()
	ENDPROC

	PROCEDURE grdappmtdet.Column2.txtcInvNum.Click
		thisform.grdappmtdet.column7.txtnpayment.setfocus()
	ENDPROC

	PROCEDURE grdappmtdet.Column2.txtcInvNum.When
		return .f.
	ENDPROC

	PROCEDURE grdappmtdet.Column3.Header3.Click
		thisform.requeryrecordsource()
	ENDPROC

	PROCEDURE grdappmtdet.Column3.txtnDiscAvail.Click
		thisform.grdappmtdet.column7.txtnpayment.setfocus()
	ENDPROC

	PROCEDURE grdappmtdet.Column3.txtnDiscAvail.When
		return .f.
	ENDPROC

	PROCEDURE grdappmtdet.Column4.txtnDistaken.Valid
		IF this.Value <> 0 AND This.parent.parent.Column7.txtnPayment.value <> 0  ;
		   AND This.parent.parent.Column7.txtnPayment.value+this.value > This.parent.parent.Column6.txtnAmtDue.Value
		   replace appmtdet.nAmtPaid WITH appmtdet.ninvbal-this.Value
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE grdappmtdet.Column5.cmdPay.Click
		thisform.grdappmtdet.column7.txtnpayment.dblclick()
		
	ENDPROC

	PROCEDURE grdappmtdet.Column5.Header1.Click
		thisform.MarkBills()
	ENDPROC

	PROCEDURE grdappmtdet.Column6.Header1.Click
		thisform.requeryrecordsource()
	ENDPROC

	PROCEDURE grdappmtdet.Column6.txtnAmtDue.Click
		thisform.grdappmtdet.column7.txtnpayment.setfocus()
	ENDPROC

	PROCEDURE grdappmtdet.Column6.txtnAmtDue.When
		return .f.
	ENDPROC

	PROCEDURE grdappmtdet.Column7.Header1.Click
		thisform.requeryrecordsource()
	ENDPROC

	PROCEDURE grdappmtdet.Column7.txtnPayment.DblClick
		IF appmtdet.namtpaid = 0
		   IF appmtdet.ninvbal > 0
		      IF appmtdet.nDiscTaken = 0
		         REPL appmtdet.namtpaid WITH appmtdet.ninvbal - IIF(appmtdet.dDiscDate >= appmthdr.dPmtDate, appmtdet.ndisctot, 0), ;
		            appmtdet.nDiscTaken WITH IIF(appmtdet.dDiscDate >= appmthdr.dPmtDate, appmtdet.ndisctot, 0)
		      ELSE
		         REPL appmtdet.namtpaid WITH appmtdet.ninvbal - appmtdet.nDiscTaken
		      ENDIF
		   ELSE
		      lnBillsPaid = THISFORM.BillsSelected(appmtdet.cvendorid, appmtdet.cbatch, appmtdet.cidappmd)
		      IF lnBillsPaid > 0
		         IF lnBillsPaid >= ABS(appmtdet.ninvbal)
		            REPL appmtdet.namtpaid WITH appmtdet.ninvbal
		         ELSE
		            REPLACE appmtdet.namtpaid WITH lnBillsPaid *-1
		         ENDIF 
		      ELSE
		         MESSAGEBOX('There are no bills selected to offset this credit. Please select the ' + ;
		                    'bills that should be offset by the credit first, then apply the credit',16,'Apply Credit problem')   
		         thisform.grdappmtdet.Click()
		         RETURN            
		      ENDIF
		   ENDIF
		ELSE
		   REPL appmtdet.namtpaid WITH 0, appmtdet.nDiscTaken WITH 0
		ENDIF
		thisform.grdappmtdet.Click()
		THISFORM.calctot()
		THIS.REFRESH()
	ENDPROC

	PROCEDURE grdappmtdet.Column7.txtnPayment.Valid
		DODEFAULT()
		
		DO CASE
		   CASE appmtdet.namtpaid > 0 AND appmtdet.ninvbal < 0
		      MESSAGEBOX('A credit must be entered as negative. A positive amount paid cannot be entered on a credit.',16,'Credit problem')
		      THISFORM.cmdatamanager.REPLACE('appmtdet', 'namtpaid', 0)
		      THISFORM.cmdatamanager.setrecordposition('Vendor')
		
		   CASE ABS(appmtdet.namtpaid) > ABS(appmtdet.ninvbal) - appmtdet.ndisctaken AND appmtdet.namtpaid # 0
		      THISFORM.omessage.warning('A payment cannot be made for more than the outstanding balance.')
		      THISFORM.cmdatamanager.REPLACE('appmtdet', 'namtpaid', appmtdet.ninvbal - appmtdet.ndisctot)
		      THISFORM.cmdatamanager.setrecordposition('Vendor')
		
		   CASE appmtdet.namtpaid < 0 AND appmtdet.ninvbal - appmtdet.ndisctaken > 0
		      THISFORM.omessage.warning('A negative payment cannot be made.')
		      THISFORM.cmdatamanager.REPLACE('appmtdet', 'namtpaid', appmtdet.ninvbal - appmtdet.ndisctot)
		      THISFORM.cmdatamanager.setrecordposition('Vendor')
		
		   CASE appmtdet.namtpaid < 0
		      lnBillsPaid = THISFORM.BillsSelected(appmtdet.cvendorid, appmtdet.cbatch, appmtdet.cidappmd)
		      IF lnBillsPaid # 0
		         IF lnBillsPaid < ABS(appmtdet.namtpaid)
		            MESSAGEBOX('There are not bills selected with a balance to offset this credit. Please select the ' + ;
		                 'bills that should be offset by the credit first, then apply the credit', 16, 'Apply Credit problem')
		            THISFORM.cmdatamanager.REPLACE('appmtdet', 'namtpaid', 0)
		            THISFORM.cmdatamanager.setrecordposition('Vendor')
		         ENDIF
		      ENDIF
		ENDCASE
		
		
		
	ENDPROC

	PROCEDURE grdappmtdet.Column8.Header1.Click
		thisform.requeryrecordsource()
	ENDPROC

	PROCEDURE grdappmtdet.Column8.txtdDueDate.Click
		thisform.grdappmtdet.column7.txtnpayment.setfocus()
	ENDPROC

	PROCEDURE grdappmtdet.Column8.txtdDueDate.When
		return .f.
	ENDPROC

	PROCEDURE opgSelectBills.Valid
		DO CASE
		   CASE this.value = 1     && Select by date
		      IF thisform.txtDate.value = {^2999-12-31}
		         thisform.txtDate.value = DATE()
		      endif
		      thisform.txtDate.enabled = .T.
		      thisform.txtdate.set('enabled',.t.)
		      
		      thisform.requeryrecordsource()
		      thisform.txtDate.setfocus()
		   CASE this.value = 2     && All bills
		      thisform.txtDate.enabled = .F.
		      thisform.txtDate.value = {^2999-12-31}
		      thisform.txtDate.refresh()
		      thisform.txtdate.set('enabled',.f.)
		
		      thisform.requeryrecordsource()
		ENDCASE      
		
		thisform.cmdPayClear.set('caption','Mark All Bills')
	ENDPROC

	PROCEDURE opgSelectBills.When
		RETURN (thisform.lNewRecord)
	ENDPROC

	PROCEDURE txtDate.Valid
		IF DODEFAULT()
		   thisform.requeryrecordsource()
		ENDIF    
	ENDPROC

	PROCEDURE txtnBalance.When
		RETURN .F.
	ENDPROC

	PROCEDURE txtnTotPaid.When
		RETURN .F.
	ENDPROC

ENDDEFINE
