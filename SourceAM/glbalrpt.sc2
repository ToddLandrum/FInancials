*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="glbalrpt.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 200
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 520

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 4, ;
		Name = "Cursor1", ;
		Top = 0, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 113, ;
		Name = "Cursor2", ;
		Top = 121, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "glmaster", ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 6, ;
		Name = "Cursor3", ;
		Top = 122, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 333, ;
		Name = "Cursor4", ;
		Top = 2, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 220, ;
		Name = "Cursor5", ;
		Top = 1, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glacctyp", ;
		CursorSource = "glacctyp", ;
		Database = ..\datafiles\brinetestingdata\appdata.dbc, ;
		Height = 90, ;
		Left = 115, ;
		Name = "Cursor6", ;
		Order = "naccttype", ;
		Top = 0, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formglballist AS frmrptcriteria OF "appforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkZeroBal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkComparative" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgreportby" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="OpgQuarters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboAccountType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTotal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAcctNumbers" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: comparitivebal
		*m: loadmonth
		*m: removezero
		*m: standardbal
		*m: subaccounts
		*m: subtotals
		*a: lamonthend[12,0]
		*a: lamonth[12,0]
	*</DefinedPropArrayMethod>

	Caption = "Balance Sheet"
	DoCreate = .T.
	Height = 394
	HelpContextID = 414
	Name = "FormGlballist"
	Width = 423
	Swrptcriteriabuttons1.chkExport.Alignment = 0
	Swrptcriteriabuttons1.chkExport.Name = "chkExport"
	Swrptcriteriabuttons1.cmdclose.Name = "cmdclose"
	Swrptcriteriabuttons1.cmdPreview.Name = "cmdPreview"
	Swrptcriteriabuttons1.cmdPrint.Name = "cmdPrint"
	Swrptcriteriabuttons1.Left = 94
	Swrptcriteriabuttons1.Name = "Swrptcriteriabuttons1"
	Swrptcriteriabuttons1.TabIndex = 15
	Swrptcriteriabuttons1.Top = 313

	ADD OBJECT 'cboAccountType' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		Height = 20, ;
		Left = 151, ;
		Name = "cboAccountType", ;
		TabIndex = 9, ;
		Top = 132, ;
		Width = 217
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkAcctNumbers' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print Account Numbers", ;
		Height = 16, ;
		Left = 89, ;
		Name = "chkAcctNumbers", ;
		TabIndex = 14, ;
		Top = 255, ;
		Value = .F., ;
		Width = 129
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkComparative' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print a Comparative Statement", ;
		Height = 16, ;
		Left = 89, ;
		Name = "chkComparative", ;
		TabIndex = 12, ;
		Top = 203, ;
		Value = .F., ;
		Width = 162
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkTotal' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Print Total Lines for All Sub-Accounts", ;
		Height = 16, ;
		Left = 89, ;
		Name = "chkTotal", ;
		TabIndex = 13, ;
		Top = 229, ;
		Value = .T., ;
		Width = 199
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkZeroBal' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Include Accounts with a Zero Balance", ;
		Height = 16, ;
		Left = 89, ;
		Name = "chkZeroBal", ;
		TabIndex = 11, ;
		Top = 177, ;
		Value = .F., ;
		Width = 203
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 104, ;
		Name = "Glmaint", ;
		Top = 343
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Report By", ;
		Left = 84, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 2, ;
		Top = 14
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Quarter", ;
		Left = 32, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 7, ;
		Top = 71
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblPeriod' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Fiscal Period:", ;
		Height = 16, ;
		Left = 227, ;
		Name = "lblPeriod", ;
		TabIndex = 6, ;
		Top = 43, ;
		Width = 66, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom1' AS lbltextcustom WITH ;
		Caption = "Include Accounts:", ;
		Left = 55, ;
		Name = "Lbltextcustom1", ;
		TabIndex = 10, ;
		Top = 134
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblYear' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Fiscal Year:", ;
		Height = 16, ;
		Left = 89, ;
		Name = "lblYear", ;
		TabIndex = 5, ;
		Top = 43, ;
		Width = 60, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'OpgQuarters' AS opgoptiongroupcustom WITH ;
		BorderStyle = 1, ;
		ButtonCount = 4, ;
		Enabled = .T., ;
		Height = 35, ;
		Left = 25, ;
		Name = "OpgQuarters", ;
		TabIndex = 8, ;
		Top = 77, ;
		Width = 373, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "1st (Jan - Mar)", ;
		Option1.Enabled = .F., ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Q1", ;
		Option1.Top = 11, ;
		Option1.Width = 89, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "2nd (Apr - Jun)", ;
		Option2.Enabled = .F., ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 96, ;
		Option2.Name = "Q2", ;
		Option2.Top = 11, ;
		Option2.Width = 92, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "3rd (Jul - Sep)", ;
		Option3.Enabled = .F., ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 192, ;
		Option3.Name = "Q3", ;
		Option3.Top = 11, ;
		Option3.Width = 87, ;
		Option4.AutoSize = .T., ;
		Option4.Caption = "4th (Oct - Dec)", ;
		Option4.Enabled = .F., ;
		Option4.FontSize = 8, ;
		Option4.Height = 16, ;
		Option4.Left = 281, ;
		Option4.Name = "Q4", ;
		Option4.Top = 11, ;
		Option4.Width = 90
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'opgreportby' AS opgoptiongroupcustom WITH ;
		AutoSize = .T., ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		Height = 26, ;
		Left = 144, ;
		Name = "opgreportby", ;
		TabIndex = 1, ;
		Top = 9, ;
		Value = 1, ;
		Width = 194, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Fiscal Period", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 79, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Fiscal Quarter", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 103, ;
		Option2.Name = "Option2", ;
		Option2.Top = 5, ;
		Option2.Width = 86
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtPeriod' AS swperiod WITH ;
		Height = 20, ;
		Left = 311, ;
		MaxLength = 2, ;
		Name = "txtPeriod", ;
		TabIndex = 4, ;
		Top = 41, ;
		Width = 24, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtYear' AS swyear WITH ;
		Left = 167, ;
		Name = "txtYear", ;
		TabIndex = 3, ;
		Top = 41, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE builddata
		LOCAL llCompare, lnCount, llShowTotals
		LOCAL llReturn, loError
		
		llReturn = .T.
		
		TRY
		   llCompare      = THISFORM.chkComparative.VALUE
		   llShowTotals   = THISFORM.chkTotal.VALUE
		
		   IF llCompare
		      llReturn = THISFORM.comparitivebal()
		   ELSE
		      llReturn = THISFORM.standardbal()
		   ENDIF
		
		   IF NOT llReturn
		      EXIT
		   ENDIF 
		   
		   SELECT balance
		   SET DELETED OFF
		   SCAN
		      REPLACE cSortField WITH cAcctNo
		   ENDSCAN
		   SET DELETED ON
		
		
		   llReturn = THISFORM.subaccounts()
		
		   IF llReturn 
		      llReturn =  THISFORM.removezero()
		   ENDIF    
		
		   IF llShowTotals AND llReturn
		      llReturn = THISFORM.subtotals()
		   ENDIF
		
		   SELECT balance
		   COUNT FOR NOT DELETED() TO lnCount
		   SET ORDER TO AcctNo
		   GO TOP
		   
		   SET SAFETY OFF
		   TRY 
		   SELECT balance
		   REPLACE nlevel WITH 1 FOR EMPTY(nlevel)
		   GO top
		   CATCH
		   ENDTRY 
		  
		   WAIT CLEAR
		
		   IF lnCount > 0
		      llReturn = .T.
		   ELSE
		      llReturn = .F.
		   ENDIF
		   
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildData', loError.LINENO, 'G/L Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE comparitivebal
		LOCAL jlines, llfirst, jcYear, jcPeriod, m.cCurEarn, lcLastYr, lcLastYr1
		LOCAL llLastYrClosed, llCurYrClosed, tcYear, tcPeriod, tlIncludeZero
		LOCAL lnCount, lnRecNo, lcLevel, lnLevel, lnCurrentLevel, lcParent, llDetailExists
		LOCAL laCurEarn1[1], laCurEarn2[1], lcCurYear, lcPeriod1, lcPeriod2, lcYear, llReturn, llShowTotals
		LOCAL lnAcctType, lnBegBal, lnEndBal, lnQtr, lnReportBy, loError
		*:Global cCurEarn, cRetEarn, cyear, nRetEarn
		
		llReturn = .T.
		
		TRY
		    tcYear        = THISFORM.txtYear.VALUE
		    tcPeriod      = THISFORM.txtPeriod.VALUE
		    tlIncludeZero = THISFORM.chkZeroBal.VALUE
		    lcLastYr      = STR(VAL(tcYear) - 1, 4)
		    lcLastYr1     = STR(VAL(tcYear) - 2, 4)
		    lnReportBy    = THISFORM.opgReportBy.VALUE
		    lnQtr         = THISFORM.opgQuarters.VALUE
		    lcLevel       = THISFORM.cboAccountType.VALUE
		    llShowTotals  = THISFORM.chkTotal.VALUE
		    llPrintNumbers = THISFORM.chkAcctNumbers.Value 
		
		    DO CASE
		        CASE lnReportBy = 1
		            lcPeriod1 = tcPeriod
		            lcPeriod2 = tcPeriod
		        CASE lnQtr = 1
		            lcPeriod1 = '01'
		            lcPeriod2 = '03'
		        CASE lnQtr = 2
		            lcPeriod1 = '04'
		            lcPeriod2 = '06'
		        CASE lnQtr = 3
		            lcPeriod1 = '07'
		            lcPeriod2 = '09'
		        CASE lnQtr = 4
		            lcPeriod1 = '10'
		            lcPeriod2 = '12'
		    ENDCASE
		
		    jcYear   = STR(VAL(tcYear) - 1, 4)
		    jcPeriod = tcPeriod
		
		*
		*  Load the month array properties
		*
		    THISFORM.loadmonth()
		
		    THISFORM.cTitle1 = 'Balance Sheet'
		    IF lnReportBy = 1
		        THISFORM.cTitle2 = THISFORM.laMonthEnd[VAL(tcPeriod)]
		    ELSE
		        THISFORM.cTitle2 = 'For the quarter ending ' + THISFORM.laMonthEnd[VAL(lcPeriod2)]
		    ENDIF
		
		*
		*  Recalculate account balances
		*
		    WAIT WIND NOWAIT 'Calculating Account Balances...'
		    THISFORM.glmaint.calcbalance()
		    WAIT CLEAR
		
		    WAIT WIND NOWAIT 'Processing Report Request...Please Wait'
		
		*
		*  Get the current earnings account number.
		*
		    swselect('glopt')
		    GO TOP
		    m.cCurEarn = cCurEarn
		    m.cRetEarn = cRetEarn
		
		* Get list of years so we can check if they've been closed
			SELECT  coabalnew.cyear, .F. AS lclosed ;
			   FROM coabalnew ;
			   WHERE cyear < tcYear ;
				   AND ISDIGIT(LEFT(TRANSFORM(cyear), 1));
			   INTO CURSOR closedyears READWRITE ;
			   ORDER BY cyear ;
			   GROUP BY cyear
		
		    SELECT closedyears
		    SCAN
		        m.cyear = cyear
		        swselect('sysctl')
		        SCAN FOR cyear == m.cyear AND ctypeclose = 'A'
		            IF sysctl.lyearclose
		                SELECT closedyears
		                REPLACE lclosed WITH .T.
		            ENDIF
		        ENDSCAN
		    ENDSCAN
		
		    THISFORM.creportname = 'source\glbal02'
		
		    CREATE CURSOR balance ;
		        (cAcctNo     C(6), ;
		          cSortField  C(30), ;
		          cBalGroup   C(1), ;
		          nAcctType   N(2), ;
		          lTitle      L, ;
		          lTotalAcct  L, ;
		          cAcctType   C(25), ;
		          cAcctDesc   C(50), ;
		          cFiscalYr   C(4), ;
		          cFiscalPrd  C(2), ;
		          cParent     C(6), ;
		          nLevel      N(1, 0), ;
		          nBegBal1    N(13, 2), ;
		          nDebits1    N(13, 2), ;
		          nCredits1   N(13, 2), ;
		          nEndBal1    N(13, 2), ;
		          nBegBal2    N(13, 2), ;
		          nDebits2    N(13, 2), ;
		          nCredits2   N(13, 2), ;
		          nEndBal2    N(13, 2))
		    INDEX ON STR(nAcctType, 2) + cSortField TAG AcctNo
		    INDEX ON cAcctNo TAG Acct
		
		*
		*  Get the periods activity for each account in the range. (current year)
		*
			SELECT  coa.cAcctNo, ;
					coa.cAcctDesc, ;
					coa.nAcctType, ;
					coa.lTitle, ;
					coa.lTotalAcct, ;
					coabalnew.cyear AS cFiscalYr, ;
					coabalnew.cPeriod AS cFiscalPrd, ;
					SUM(coabalnew.nDebits)  AS nDebits1, ;
					SUM(coabalnew.nCredits) AS nCredits1 ;
			   FROM coabalnew, coa ;
			   WHERE coabalnew.cAcctNo = coa.cAcctNo ;
				   AND BETWEEN(coabalnew.cyear + coabalnew.cPeriod, tcYear + lcPeriod1, tcYear + lcPeriod2) ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal1 ;
			   ORDER BY coa.cAcctNo ;
			   GROUP BY coa.cAcctNo
		
			SELECT  coa.cAcctNo, ;
					coa.cAcctDesc, ;
					coa.nAcctType, ;
					coa.lTitle, ;
					coa.lTotalAcct, ;
					tcYear AS cFiscalYr, ;
					tcPeriod AS cFiscalPrd, ;
					0 AS nDebits1, ;
					0 AS nCredits1 ;
			   FROM coa ;
			   WHERE coa.cAcctNo NOT IN (SELECT  cAcctNo ;
											FROM tempbal1) ;
			   INTO CURSOR tempbal2 ;
			   ORDER BY coa.cAcctNo ;
			   GROUP BY coa.cAcctNo
		
		    lcCurYear = _TALLY
		
		*
		*  Get the periods activity for each account in the range for last year.
		*
			SELECT  coa.cAcctNo, ;
					coa.cAcctDesc, ;
					coa.nAcctType, ;
					coabalnew.cyear AS cFiscalYr, ;
					coabalnew.cPeriod AS cFiscalPrd, ;
					SUM(coabalnew.nDebits)  AS nDebits2, ;
					SUM(coabalnew.nCredits) AS nCredits2 ;
			   FROM coabalnew, coa ;
			   WHERE coabalnew.cAcctNo = coa.cAcctNo ;
				   AND BETWEEN(coabalnew.cyear + coabalnew.cPeriod, lcLastYr + lcPeriod1, lcLastYr + lcPeriod2) ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal3 ;
			   ORDER BY coa.cAcctNo ;
			   GROUP BY coa.cAcctNo
		
			SELECT  coa.cAcctNo, ;
					coa.cAcctDesc, ;
					coa.nAcctType, ;
					lcLastYr AS cFiscalYr, ;
					tcPeriod AS cFiscalPrd, ;
					0 AS nDebits2, ;
					0 AS nCredits2 ;
			   FROM coa ;
			   WHERE coa.cAcctNo NOT IN (SELECT  cAcctNo ;
											FROM tempbal3) ;
			   INTO CURSOR tempbal4 ;
			   ORDER BY coa.cAcctNo ;
			   GROUP BY coa.cAcctNo
		
		*
		*  Append the records to the balance table
		*
		    SELECT balance
		    APPEND FROM DBF('tempbal1')
		    APPEND FROM DBF('tempbal2')
		    SET ORDER TO AcctNo
		    USE IN tempbal1
		    USE IN tempbal2
		
		*
		*  Add in last year's balances.
		*
		    SELECT tempbal3
		    SCAN
		        SCATTER MEMVAR
		        SELECT balance
		        SET ORDER TO Acct
		        IF SEEK(m.cAcctNo)
		            REPLACE nDebits2  WITH m.nDebits2, ;
		                nCredits2 WITH m.nCredits2
		        ELSE
		            INSERT INTO balance FROM MEMVAR
		        ENDIF
		    ENDSCAN
		    SELECT tempbal4
		    SCAN
		        SCATTER MEMVAR
		        SELECT balance
		        SET ORDER TO Acct
		        IF NOT SEEK(m.cAcctNo)
		            INSERT INTO balance FROM MEMVAR
		        ENDIF
		    ENDSCAN
		
		    USE IN tempbal3
		    USE IN tempbal4
		*
		*  Get the beginning balances for each account in the range (current year)
		*
			SELECT  coabalnew.cAcctNo, ;
					SUM(nDebits) AS nDebits1, ;
					SUM(nCredits) AS nCredits1 ;
			   FROM coabalnew ;
			   WHERE coabalnew.cyear + coabalnew.cPeriod < tcYear + lcPeriod1 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbeg ;
			   ORDER BY coabalnew.cAcctNo ;
			   GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		    IF _TALLY > 0
		        SELECT tempbeg
		        SCAN
		            SCATTER MEMVAR
		            lnBegBal = m.nDebits1 - m.nCredits1
		            SELECT balance
		            SET ORDER TO Acct
		            IF SEEK(m.cAcctNo)
		                lnEndBal = lnBegBal + nDebits1 - nCredits1
		                REPLACE nBegBal1 WITH lnBegBal, ;
		                    nEndBal1 WITH lnEndBal
		            ENDIF
		        ENDSCAN
		    ENDIF
		
		*
		*  Get the beginning balances for each account in the range (last year)
		*
			SELECT  coabalnew.cAcctNo, ;
					SUM(nDebits) AS nDebits2, ;
					SUM(nCredits) AS nCredits2 ;
			   FROM coabalnew ;
			   WHERE coabalnew.cyear + coabalnew.cPeriod < jcYear + lcPeriod1 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbeg ;
			   ORDER BY coabalnew.cAcctNo ;
			   GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		    IF _TALLY > 0
		        SELECT tempbeg
		        SCAN
		            SCATTER MEMVAR
		            lnBegBal = m.nDebits2 - m.nCredits2
		            SELECT balance
		            IF SEEK(m.cAcctNo)
		                lnEndBal = lnBegBal + nDebits2 - nCredits2
		                REPLACE nBegBal2 WITH lnBegBal, ;
		                    nEndBal2 WITH lnEndBal
		            ENDIF
		        ENDSCAN
		    ENDIF
		
		*
		*  Plug in the ending balances
		*
		    SELECT balance
		    SET ORDER TO 0
		    SCAN
		        IF EMPTY(nBegBal1)
		            REPLACE nEndBal1 WITH nDebits1 - nCredits1, ;
		                nBegBal1 WITH 0
		        ENDIF
		        IF EMPTY(nBegBal2)
		            REPLACE nEndBal2 WITH nDebits2 - nCredits2, ;
		                nBegBal2 WITH 0
		        ENDIF
		        IF BETWEEN(nAcctType, 4, 7)
		            REPLACE nEndBal1 WITH (nEndBal1 * -1), ;
		                nEndBal2 WITH (nEndBal2 * -1)
		        ENDIF
		    ENDSCAN
		
		*
		*  Calculate the net income for last year to add to
		*  retained earnings.   
		*
		    SELECT closedyears
		    LOCATE FOR NOT lclosed
		    IF FOUND()
		        SELECT closedyears
		        SCAN FOR NOT lclosed
		            lcYear = cyear
		
					SELECT  coabalnew.cAcctNo, ;
							coa.nAcctType, ;
							SUM(nDebits - nCredits)  AS nRetEarn ;
					   FROM coabalnew, coa ;
					   WHERE coabalnew.cyear = lcYear ;
						   AND coabalnew.cAcctNo = coa.cAcctNo ;
						   AND BETWEEN(coa.nAcctType, 8, 16) ;
						   AND NOT DELETED() ;
					   INTO CURSOR tempbeg
		
		            IF _TALLY > 0
		                SELECT tempbeg
		                GO TOP
		                m.nRetEarn = nRetEarn
		            ELSE
		                m.nRetEarn = 0
		            ENDIF
		
		*
		*  Plug in the new retained earnings number
		*
		            SELECT balance
		            SET ORDER TO Acct
		            IF SEEK(m.cRetEarn)
		                REPLACE nEndBal1 WITH nEndBal1 + (m.nRetEarn * -1)
		            ENDIF
		        ENDSCAN
		    ENDIF
		
		*
		* If we're running the report for period 12 and the year
		* has been closed let's calculate the current earnings
		* and remove it from retained earnings so we can display it.
		*
		
		    IF tcPeriod = '12'
		        llClosed = .F.
		        swselect('sysctl')
		        LOCATE FOR cyear == tcYear AND ctypeclose = 'A' AND lYearClose
		        IF FOUND()
		           llClosed = .T.
		        ENDIF
		        IF llClosed
					SELECT  glmaster.cAcctNo, ;
							coa.nAcctType, ;
							SUM(nDebits - nCredits)  AS nRetEarn ;
					   FROM glmaster, coa ;
					   WHERE glmaster.cyear = tcYear ;
						   AND glmaster.cAcctNo = coa.cAcctNo ;
						   AND BETWEEN(coa.nAcctType, 8, 16) ;
						   AND glmaster.csource # 'YE' ;
						   AND NOT DELETED() ;
					   INTO CURSOR tempbeg
		            SELECT balance
		            SET ORDER TO Acct
		            IF SEEK(m.cRetEarn)
		                REPLACE nEndBal1 WITH nEndBal1 - tempbeg.nRetEarn * -1
		                IF SEEK(m.cCurEarn)
		                    REPLACE nEndBal1 WITH nEndBal1 + tempbeg.nRetEarn * -1
		                ENDIF
		            ENDIF
		        ENDIF
		
		        llClosed = .F.
		        swselect('sysctl')
		        LOCATE FOR cyear == lcLastYr AND ctypeclose = 'A' AND lYearClose
		        IF FOUND()
		           llClosed = .T.
		        ENDIF
		        IF llClosed
					SELECT  glmaster.cAcctNo, ;
							coa.nAcctType, ;
							SUM(nDebits - nCredits)  AS nRetEarn ;
					   FROM glmaster, coa ;
					   WHERE glmaster.cyear = lcLastYr ;
						   AND glmaster.cAcctNo = coa.cAcctNo ;
						   AND BETWEEN(coa.nAcctType, 8, 16) ;
						   AND glmaster.csource # 'YE' ;
						   AND NOT DELETED() ;
					   INTO CURSOR tempbeg
		            SELECT balance
		            SET ORDER TO Acct
		            IF SEEK(m.cRetEarn)
		                REPLACE nEndBal2 WITH nEndBal2 - tempbeg.nRetEarn * -1
		                IF SEEK(m.cCurEarn)
		                    REPLACE nEndBal2 WITH nEndBal2 + tempbeg.nRetEarn * -1
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		
		*
		*  Calculate the Current Earnings for this year
		*
			SELECT  SUM(nDebits - nCredits) AS nEndBal1, ;
					coa.nAcctType ;
			   FROM coabalnew, coa ;
			   WHERE BETWEEN(coa.nAcctType, 8, 16) ;
				   AND coabalnew.cyear = tcYear ;
				   AND coabalnew.cPeriod <= lcPeriod2 ;
				   AND coabalnew.cAcctNo = coa.cAcctNo ;
				   AND coa.lTotalAcct = .F. ;
				   AND NOT DELETED() ;
			   INTO ARRAY laCurEarn1
		
		    IF _TALLY > 0
		        SELECT balance
		        SET ORDER TO Acct
		        IF SEEK(m.cCurEarn)
		            REPLACE nEndBal1 WITH nEndBal1 + (laCurEarn1[1, 1] * -1)
		        ENDIF
		    ENDIF
		
		*
		*  Calculate the net income for last year to add to
		*  retained earnings.   
		*
		    SELECT closedyears
		    LOCATE FOR NOT lclosed
		    IF FOUND()
		        SELECT closedyears
		        SCAN FOR NOT lclosed AND cyear < lcLastYr
		            lcYear = cyear
		
					SELECT  coabalnew.cAcctNo, ;
							coa.nAcctType, ;
							SUM(nDebits - nCredits)  AS nRetEarn ;
					   FROM coabalnew, coa ;
					   WHERE coabalnew.cyear = lcYear ;
						   AND coabalnew.cAcctNo = coa.cAcctNo ;
						   AND BETWEEN(coa.nAcctType, 8, 16) ;
						   AND NOT DELETED() ;
					   INTO CURSOR tempbeg
		
		            IF _TALLY > 0
		                SELECT tempbeg
		                GO TOP
		                m.nRetEarn = nRetEarn
		            ELSE
		                m.nRetEarn = 0
		            ENDIF
		
		*
		*  Plug in the new retained earnings number
		*
		            SELECT balance
		            SET ORDER TO Acct
		            IF SEEK(m.cRetEarn)
		                REPLACE nEndBal2 WITH nEndBal2 + (m.nRetEarn * -1)
		            ENDIF
		        ENDSCAN
		    ENDIF
		*
		*  Calculate the Current Earnings for last year
		*
			SELECT  SUM(nDebits - nCredits) AS nEndBal1, ;
					coa.nAcctType ;
			   FROM coabalnew, coa ;
			   WHERE BETWEEN(coa.nAcctType, 8, 16) ;
				   AND coabalnew.cyear = lcLastYr ;
				   AND coabalnew.cPeriod <= lcPeriod2 ;
				   AND coabalnew.cAcctNo = coa.cAcctNo ;
				   AND coa.lTotalAcct = .F. ;
				   AND NOT DELETED() ;
			   INTO ARRAY laCurEarn2
		
		    IF _TALLY > 0
		        SELECT balance
		        SET ORDER TO Acct
		        IF SEEK(m.cCurEarn)
		            REPLACE nEndBal2 WITH nEndBal2 + (laCurEarn2[1, 1] * -1)
		        ENDIF
		    ENDIF
		
		*
		*  Plug in the account types
		*
		    SELECT balance
		    SET ORDER TO 0
		    SCAN
		        lnAcctType = nAcctType
		        swselect('glacctyp')
		        LOCATE FOR naccttype = lnAcctType
		        IF FOUND()
		            SELECT balance
		            REPLACE cAcctType WITH glacctyp.cTypeDesc
		        ELSE
		            SELECT balance
		            REPLACE cAcctType WITH 'Unknown'
		        ENDIF
		        DO CASE
		            CASE BETWEEN(lnAcctType, 1, 3)
		                REPLACE cBalGroup WITH 'A'
		            CASE BETWEEN(lnAcctType, 4, 7)
		                REPLACE cBalGroup WITH 'B'
		            OTHERWISE
		                DELETE NEXT 1
		                LOOP
		        ENDCASE
		        SELECT balance
		*  Only delete if reporting on something other than 'All Levels' since the level processing will delete later on
		        IF tlIncludeZero AND nEndBal1 = 0 AND nEndBal2 = 0  AND cAcctNo <> m.cCurEarn AND NOT lTitle AND lcLevel <> '*'
		            DELETE NEXT 1
		            LOOP
		        ENDIF
		        
		        IF llPrintNumbers
		           SELECT balance
		           REPLACE cacctdesc WITH cacctno + ' - ' + ALLTRIM(cacctdesc)
		        ENDIF 
		    ENDSCAN
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'ComparitiveBal', loError.LINENO, 'G/L Balance Sheet', loError.ERRORNO, loError.MESSAGE
		    MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE Init
		
		THISFORM.txtPeriod.VALUE = GetFiscalPeriod(DATE())
		THISFORM.txtYear.VALUE = GetFiscalYear(DATE())
		
		SET DELETED ON
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE loadmonth
		LOCAL lnX, lnMonth, lcYear
		LOCAL llFYEnd, llReturn, lnMonth1, loError
		*:Global tcYear
		
		llReturn = .T.
		
		TRY
		   tcYear = THISFORM.txtYear.VALUE
		
		*
		*  Load the titles for the financial statements
		*
		   THISFORM.laMonth[1] = 'January 31, '
		
		   THISFORM.laMonth[3]  = 'March 31, '
		   THISFORM.laMonth[4]  = 'April 30, '
		   THISFORM.laMonth[5]  = 'May 31, '
		   THISFORM.laMonth[6]  = 'June 30, '
		   THISFORM.laMonth[7]  = 'July 31, '
		   THISFORM.laMonth[8]  = 'August 31, '
		   THISFORM.laMonth[9]  = 'September 30, '
		   THISFORM.laMonth[10] = 'October 31, '
		   THISFORM.laMonth[11] = 'November 30, '
		   THISFORM.laMonth[12] = 'December 31, '
		
		*
		*  Get the beginning month of the fiscal year
		*
		   swselect('glopt')
		   GO TOP
		   llFYEnd  = lFYEnd
		   lnMonth  = VAL(glopt.cfybegin)
		   lnMonth1 = lnMonth
		   IF llFYEnd
		      lcYear = STR(VAL(tcYear) - 1, 4)
		   ELSE
		      lcYear = tcYear
		   ENDIF
		
		*
		*  Load up the monthend array
		*
		   FOR lnX = 1 TO 12
		      IF lnMonth1 = 2
		*
		*  Check for leap year
		*
		         IF MOD(VAL(lcYear), 4) = 0
		            THISFORM.laMonth[2] = 'February 29, '
		         ELSE
		            THISFORM.laMonth[2] = 'February 28, '
		         ENDIF
		      ENDIF
		
		      THISFORM.laMonthEnd[lnX] = THISFORM.laMonth[lnMonth1] + ' ' + lcYear
		      IF lnMonth1 = 12
		         lnMonth1 = 1
		         lcYear   = STR(VAL(lcYear) + 1, 4)
		      ELSE
		         lnMonth1 = lnMonth1 + 1
		      ENDIF
		   ENDFOR
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'LoadMonth', loError.LINENO, 'G/L Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
	ENDPROC

	PROCEDURE removezero
		LOCAL llReturn, loError
		*:Global cCurEarn, cRetEarn
		llReturn = .T.
		
		TRY
		**  Scan and remove zero balance entries.  We'll delete every zero account, and then check to see whether the non-deleted accounts
		**  have parent accounts that need recalled to avoid orphaning subaccounts on the report.
		
		   LOCAL lcParent, lnRecNo, llCompare, m.cCurEarn, m.cRetEarn
		
		   llCompare = THISFORM.chkComparative.VALUE
		
		   IF THISFORM.chkzeroBal.VALUE
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		*
		*  Get the current earnings account number.
		*
		   swselect('glopt')
		   GO TOP
		   m.cCurEarn = cCurEarn
		   m.cRetEarn = cRetEarn
		
		   WAIT WINDOW NOWAIT 'Removing Zero Balance Entries'
		   SELECT balance
		   SCAN FOR IIF(llCompare, balance.nEndBal1 = 0 AND balance.nEndBal2 = 0, balance.nEndBal = 0)  AND balance.cAcctNo <> m.cCurEarn AND NOT ltitle AND NOT ltotalacct
		      DELETE NEXT 1
		   ENDSCAN
		
		   SELECT balance
		   SCAN FOR LEN(ALLTRIM(cSortField)) > 6 AND IIF(llCompare, balance.nEndBal1 <> 0  OR balance.nEndBal2 <> 0, balance.nEndBal <> 0) AND nAcctType < 8  &&  Accounts with parent accounts and activity
		      lnRecNo  = RECNO()
		      lcParent = SUBSTR(cSortField, 1, 6)
		      LOCATE FOR cAcctNo = lcParent
		      IF FOUND()
		         IF DELETED()  &&  This is a parent acct with activity for a subaccount, so recall it, so it shows up
		            RECALL
		         ENDIF
		         lcParent = SUBSTR(cSortField, 7, 6)
		         LOCATE FOR cAcctNo = lcParent
		         IF FOUND()
		            IF DELETED()
		               RECALL
		            ENDIF
		            lcParent = SUBSTR(cSortField, 13, 6)
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               IF DELETED()
		                  RECALL
		               ENDIF
		               lcParent = SUBSTR(cSortField, 19, 6)
		               LOCATE FOR cAcctNo = lcParent
		               IF FOUND()
		                  IF DELETED()
		                     RECALL
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		      SELECT balance
		      GOTO lnRecNo
		   ENDSCAN
		
		   SET DELETED ON
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'RemoveZero', loError.LINENO, 'G/L Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE report
		LPARAMETERS cbutton
		PRIV lcCompany
		
		lcCompany = m.goApp.cCompanyName
		
		DODEFAULT(cButton)
	ENDPROC

	PROCEDURE standardbal
		LOCAL jlines, llfirst, jcYear, jcPeriod, m.cCurEarn, lcLastYr, lcLastYr1
		LOCAL llLastYrClosed, llCurYrClosed, tcYear, tcPeriod, tlZero
		LOCAL lnCount, lnRecNo, lcLevel, lnLevel, lnCurrentLevel, lcParent, llDetailExists
		LOCAL laCurEarn[1], lcPeriod1, lcPeriod2, lcYear, llReturn, llShowTotals, lnAcctType, lnBegBal
		LOCAL lnEndBal, lnQtr, lnReportBy, loError
		*:Global cCurEarn, cRetEarn, cyear, nRetEarn, tlIncludeZero
		
		llReturn = .T.
		
		TRY
		   tcYear        = THISFORM.txtYear.VALUE
		   tcPeriod      = THISFORM.txtPeriod.VALUE
		   tlIncludeZero = THISFORM.chkZeroBal.VALUE
		   lcLastYr      = STR(VAL(tcYear) - 1, 4)
		   lcLastYr1     = STR(VAL(tcYear) - 2, 4)
		   lnReportBy    = THISFORM.opgReportBy.VALUE
		   lnQtr         = THISFORM.opgQuarters.VALUE
		   lcLevel       = THISFORM.cboAccountType.VALUE
		   llShowTotals  = THISFORM.chkTotal.VALUE
		   llPrintNumbers = thisform.chkAcctNumbers.Value 
		
		
		   DO CASE
		      CASE lnReportBy = 1
		         lcPeriod1 = tcPeriod
		         lcPeriod2 = tcPeriod
		      CASE lnQtr = 1
		         lcPeriod1 = '01'
		         lcPeriod2 = '03'
		      CASE lnQtr = 2
		         lcPeriod1 = '04'
		         lcPeriod2 = '06'
		      CASE lnQtr = 3
		         lcPeriod1 = '07'
		         lcPeriod2 = '09'
		      CASE lnQtr = 4
		         lcPeriod1 = '10'
		         lcPeriod2 = '12'
		   ENDCASE
		
		   jcYear   = STR(VAL(tcYear) - 1, 4)
		   jcPeriod = tcPeriod
		
		*
		*  Load the month array properties
		*
		   THISFORM.loadmonth()
		
		   THISFORM.cTitle1 = 'Balance Sheet'
		   IF lnReportBy = 1
		      THISFORM.cTitle2 = THISFORM.laMonthEnd[VAL(tcPeriod)]
		   ELSE
		      THISFORM.cTitle2 = 'For the quarter ending ' + THISFORM.laMonthEnd[VAL(lcPeriod2)]
		   ENDIF
		
		*
		*  Recalculate account balances
		*
		   WAIT WIND NOWAIT 'Calculating Account Balances...'
		   THISFORM.glmaint.calcbalance(.F.)
		   WAIT CLEAR
		
		   WAIT WIND NOWAIT 'Processing Report Request...Please Wait'
		
		*
		*  Get the current earnings account number.
		*
		   swselect('glopt')
		   GO TOP
		   m.cCurEarn = cCurEarn
		   m.cRetEarn = cRetEarn
		
		* Get list of years so we can check if they've been closed
		   SELECT  coabalnew.cyear, .F. AS lclosed ;
			   FROM coabalnew ;
			   WHERE cyear < tcYear ;
				   AND ISDIGIT(LEFT(TRANSFORM(cyear), 1));
			   INTO CURSOR closedyears READWRITE ;
			   ORDER BY cyear ;
			   GROUP BY cyear
		
		   SELECT closedyears
		   SCAN
		      m.cyear = cyear
		      swselect('sysctl')
		      SCAN FOR cyear == m.cyear AND ctypeclose = 'A'
		         IF sysctl.lyearclose
		            SELECT closedyears
		            REPLACE lclosed WITH .T.
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		
		   CREATE CURSOR balance ;
		      (cAcctNo    C(6), ;
		        cSortField  C(30), ;
		        cBalGroup   C(1), ;
		        nAcctType   N(2), ;
		        lTitle      L, ;
		        lTotalAcct  L, ;
		        cAcctType   C(25), ;
		        cAcctDesc   C(50), ;
		        cFiscalYr   C(4), ;
		        cFiscalPrd  C(2), ;
		        cParent     C(6), ;
		        nLevel      N(1, 0), ;
		        nCount      N(4, 0), ;
		        nBegBal     N(13, 2), ;
		        nDebits     N(13, 2), ;
		        nCredits    N(13, 2), ;
		        nEndBal     N(13, 2))
		   INDEX ON STR(nAcctType, 2) + cSortField TAG AcctNo
		   INDEX ON cAcctNo TAG Acct
		
		   THISFORM.creportname = 'source\glbal01'
		*
		*  Get the periods activity for each account in the range.
		*
		   SELECT  coa.cAcctNo, ;
				   coa.cAcctDesc, ;
				   coa.nAcctType, ;
				   coa.lTitle, ;
				   coa.lTotalAcct, ;
				   coabalnew.cyear AS cFiscalYr, ;
				   coabalnew.cPeriod AS cFiscalPrd, ;
				   SUM(coabalnew.nDebits) AS nDebits, ;
				   SUM(coabalnew.nCredits) AS nCredits ;
			   FROM coabalnew, coa ;
			   WHERE coabalnew.cAcctNo = coa.cAcctNo ;
				   AND BETWEEN(coabalnew.cyear + coabalnew.cPeriod, tcYear + lcPeriod1, tcYear + lcPeriod2) ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbal1 ;
			   ORDER BY coa.cAcctNo ;
			   GROUP BY coa.cAcctNo
		
		   SELECT  coa.cAcctNo, ;
				   coa.cAcctDesc, ;
				   coa.nAcctType, ;
				   coa.lTitle, ;
				   coa.lTotalAcct, ;
				   tcYear AS cFiscalYr, ;
				   tcPeriod AS cFiscalPrd, ;
				   0 AS nDebits, ;
				   0 AS nCredits ;
			   FROM coa ;
			   WHERE coa.cAcctNo NOT IN (SELECT  cAcctNo ;
											 FROM tempbal1) ;
			   INTO CURSOR tempbal2 ;
			   ORDER BY coa.cAcctNo ;
			   GROUP BY coa.cAcctNo
		
		*
		*  If there were no records found, bail out.
		*
		   IF _TALLY = 0
		      llReturn = .F.
		      EXIT
		   ENDIF
		*
		*  Append the records to the balance table
		*
		   SELECT balance
		   APPEND FROM DBF('tempbal1')
		   USE IN tempbal1
		
		   SELECT balance
		   APPEND FROM DBF('tempbal2')
		   SET ORDER TO AcctNo
		   USE IN tempbal2
		
		
		*
		*  Get the beginning balances for each account in the range.
		*
		   SELECT  coabalnew.cAcctNo, ;
				   SUM(nDebits) AS nDebits, ;
				   SUM(nCredits) AS nCredits ;
			   FROM coabalnew ;
			   WHERE coabalnew.cyear + coabalnew.cPeriod < tcYear + lcPeriod1 ;
				   AND NOT DELETED() ;
			   INTO CURSOR tempbeg ;
			   ORDER BY coabalnew.cAcctNo ;
			   GROUP BY coabalnew.cAcctNo
		
		*
		*  If there are any beginning balances, update the balance table.
		*  Otherwise, the beginning balances are assumed to be zero.
		*
		   IF _TALLY > 0
		      SELECT tempbeg
		      SCAN
		         SCATTER MEMVAR
		         lnBegBal = m.nDebits - m.nCredits
		         SELECT balance
		         SET ORDER TO Acct
		         IF SEEK(m.cAcctNo)
		*
		*  Only update balance sheet accounts
		*
		            IF nAcctType < 8
		               lnEndBal = lnBegBal + nDebits - nCredits
		               REPLACE nBegBal WITH lnBegBal, ;
		                  nEndBal WITH lnEndBal
		            ENDIF
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		*  Plug in the ending balance numbers.
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      IF EMPTY(nBegBal)
		         REPLACE nEndBal WITH nDebits - nCredits, ;
		            nBegBal WITH 0
		      ENDIF
		      IF BETWEEN(nAcctType, 4, 7)
		         REPLACE nEndBal WITH (nEndBal * -1)
		      ENDIF
		   ENDSCAN
		
		*
		*  Calculate the net income for last year to add to
		*  retained earnings.   
		*
		   SELECT closedyears
		   LOCATE FOR NOT lclosed
		   IF FOUND()
		      SELECT closedyears
		      SCAN FOR NOT lclosed
		         lcYear = cyear
		
				 SELECT  coabalnew.cAcctNo, ;
						 coa.nAcctType, ;
						 SUM(nDebits - nCredits)  AS nRetEarn ;
					 FROM coabalnew, coa ;
					 WHERE coabalnew.cyear = lcYear ;
						 AND coabalnew.cAcctNo = coa.cAcctNo ;
						 AND BETWEEN(coa.nAcctType, 8, 16) ;
						 AND NOT DELETED() ;
					 INTO CURSOR tempbeg
		
		         IF _TALLY > 0
		            SELECT tempbeg
		            GO TOP
		            m.nRetEarn = nRetEarn
		         ELSE
		            m.nRetEarn = 0
		         ENDIF
		
		*
		*  Plug in the new retained earnings number
		*
		         SELECT balance
		         SET ORDER TO Acct
		         IF SEEK(m.cRetEarn)
		            REPLACE nEndBal WITH nEndBal + (m.nRetEarn * -1)
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		*
		* If we're running the report for period 12 and the year
		* has been closed let's calculate the current earnings
		* and remove it from retained earnings so we can display it.
		*
		    IF tcPeriod = '12'
		        llClosed = .F.
		        swselect('sysctl')
		        LOCATE FOR cyear == tcYear AND ctypeclose = 'A' AND lYearClose
		        IF FOUND()
		           llClosed = .T.
		        ENDIF
		        IF llClosed 
				SELECT  glmaster.cAcctNo, ;
						coa.nAcctType, ;
						SUM(nDebits - nCredits)  AS nRetEarn ;
					FROM glmaster, coa ;
					WHERE glmaster.cyear = tcYear ;
						AND glmaster.cAcctNo = coa.cAcctNo ;
						AND BETWEEN(coa.nAcctType, 8, 16) ;
						AND glmaster.csource # 'YE' ;
						AND NOT DELETED() ;
					INTO CURSOR tempbeg
		        SELECT balance
		        SET ORDER TO Acct
		        IF SEEK(m.cRetEarn)
		            REPLACE nEndBal WITH nEndBal - tempbeg.nRetEarn * -1
		            IF SEEK(m.cCurEarn)
		                REPLACE nEndBal WITH nendbal + tempbeg.nRetEarn*-1
		            ENDIF
		        ENDIF
		        ENDIF 
		    ENDIF
		*
		*  Calculate the Current Earnings
		*
		   SELECT  SUM(coabalnew.nDebits - coabalnew.nCredits) AS nCurEarn, ;
				   coa.nAcctType ;
			   FROM coabalnew, coa ;
			   WHERE BETWEEN(coa.nAcctType, 8, 16) ;
				   AND coabalnew.cyear = tcYear ;
				   AND coabalnew.cPeriod <= lcPeriod2 ;
				   AND coabalnew.cAcctNo = coa.cAcctNo ;
				   AND coa.lTotalAcct = .F. ;
				   AND coa.lTitle     = .F. ;
				   AND NOT DELETED() ;
			   INTO ARRAY laCurEarn
		
		   IF _TALLY > 0
		      SELECT balance
		      SET ORDER TO Acct
		      IF SEEK(m.cCurEarn)
		         REPLACE nEndBal WITH nEndBal + (laCurEarn[1, 1] * -1)
		      ENDIF
		   ENDIF
		
		
		*
		*  Plug in the account descriptions and delete any non balance sheet
		*  accounts.
		*
		   SELECT balance
		   SET ORDER TO 0
		   SCAN
		      lnAcctType = nAcctType
		      swselect('glacctyp')
		      LOCATE FOR naccttype = lnAcctType
		        IF FOUND()
		         SELECT balance
		         REPLACE cAcctType WITH glacctyp.cTypeDesc
		      ELSE
		         SELECT balance
		         REPLACE cAcctType WITH 'Unknown'
		      ENDIF
		      DO CASE
		         CASE BETWEEN(lnAcctType, 1, 3)
		            REPLACE cBalGroup WITH 'A'
		         CASE BETWEEN(lnAcctType, 4, 7)
		            REPLACE cBalGroup WITH 'B'
		         OTHERWISE
		            DELETE NEXT 1
		            LOOP
		      ENDCASE
		      SELECT balance
		*  Only delete if reporting on something other than 'All Levels' since the level processing will delete later on
		      IF NOT tlIncludeZero AND nEndBal = 0 AND cAcctNo <> m.cCurEarn AND NOT lTitle AND lcLevel <> '*'
		         DELETE NEXT 1
		         LOOP
		      ENDIF
		      
		      IF llPrintNumbers
		         SELECT balance
		         REPLACE cacctdesc WITH cacctno + ' - ' + ALLTRIM(cacctdesc)
		      ENDIF 
		
		   ENDSCAN
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'StandardBal', loError.LINENO, 'G/L Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE subaccounts
		LOCAL lcParent, lcPreviousLevel, lnCurrentLevel, lnLevel, lnRecNo, llIncludeZero, llCompare, lcLevel
		LOCAL llReturn, loError
		*:Global cAcctNo
		
		llReturn = .T.
		
		TRY
		   llIncludeZero = THISFORM.chkzeroBal.VALUE
		   llCompare     = THISFORM.chkComparative.VALUE
		   lcLevel       = THISFORM.cboAccountType.VALUE
		
		   swselect('coa')
		   SET ORDER TO acctno
		
		   IF lcLevel <> '*'  &&  Not reporting on all levels, so sum the balances back to the parent accounts that are on the chosen level
		      WAIT WINDOW NOWAIT 'Summing Sub-Accounts....Please Wait'
		      lnLevel         = VAL(lcLevel)
		      lcPreviousLevel = 1
		      SELECT balance
		      SET ORDER to acctno
		      SCAN 
		         SCATTER MEMVAR
		         lnRecNo        = RECNO()  &&  Store the current record, so we can return to it
		         lnCurrentLevel = THISFORM.glmaint.calcsublevel(m.cAcctNo)  &&  Determine the level of the current account, so we know whether it should be added to a parent account
		
		         lcPreviousLevel = lnCurrentLevel
		         IF lnCurrentLevel > lnLevel  &&  This account is below the level on which to report, so find the parent and add to its total
		            SELECT balance
		            DO CASE
		               CASE lnCurrentLevel - lnLevel = 1  &&  Only need to go up a single level to add on the totals
		                  swselect('coa')
		                  IF SEEK(m.cAcctNo)  &&  Locate current account, and then check its parent
		                     lcParent = cParent  &&  This is the account to have the current totals added to
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 2  &&  Need to go up two levels to find the parent
		                  swselect('coa')
		                  IF SEEK(m.cAcctNo)
		                     lcParent = cParent
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 3  &&  Need to go up 3 levels to find the parent
		                  swselect('coa')
		                  IF SEEK(m.cAcctNo)
		                     lcParent = cParent  &&  One level up
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent  &&  Two levels up
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent  &&  Three levels up
		                        ELSE
		                           WAIT WINDOW 'Problem locating parent account...'
		                        ENDIF
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               CASE lnCurrentLevel - lnLevel = 4  &&  Need to go up 4 levels to find the parent - this is the max
		                  swselect('coa')
		                  IF SEEK(m.cAcctNo)
		                     lcParent = cParent  &&  One level up
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()
		                        lcParent = cParent  &&  Two levels up
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent  &&  Three levels up
		                           LOCATE FOR cAcctNo = lcParent
		                           IF FOUND()
		                              lcParent = cParent  &&  Four levels up
		                           ELSE
		                              WAIT WINDOW 'Problem locating parent account...'
		                           ENDIF
		                        ELSE
		                           WAIT WINDOW 'Problem locating parent account...'
		                        ENDIF
		                     ELSE
		                        WAIT WINDOW 'Problem locating parent account...'
		                     ENDIF
		                  ELSE
		                     WAIT WINDOW 'Problem locating parent account...'
		                  ENDIF
		               OTHERWISE  &&  Should never get here, since it means there's more than a 4 level difference
		                  WAIT WINDOW 'Too many levels'
		            ENDCASE
		
		**  Now that we know what the parent account is on the right level, add the current record totals to it  **
		            SELECT balance
		            SET DELETED OFF
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               IF DELETED()
		                  RECALL
		               ENDIF
		               IF llCompare  &&  Comparison report, so the fields with numbers in them are slightly different
		                  REPLACE nBegBal1 WITH nBegBal1 + m.nBegBal1, nDebits1 WITH nDebits1 + m.nDebits1, nCredits1 WITH nCredits1 + m.nCredits1, ;
		                     nEndBal1 WITH nEndBal1 + m.nEndBal1, nBegBal2 WITH nBegBal2 + m.nBegBal2, nDebits2 WITH nDebits2 + m.nDebits2, nCredits2 WITH nCredits2 + m.nCredits2, ;
		                     nEndBal2 WITH nEndBal2 + m.nEndBal2
		               ELSE  &&  Not a comparison report, so replace the appropriate fields
		                  REPLACE nBegBal WITH nBegBal + m.nBegBal, nDebits WITH nDebits + m.nDebits, nCredits WITH nCredits + m.nCredits, ;
		                     nEndBal WITH nEndBal + m.nEndBal
		               ENDIF
		            ELSE
		               WAIT WINDOW 'Cannot find parent account to add totals to'
		            ENDIF
		            GOTO lnRecNo  &&  Go back to original record, ready to continue scanning
		            DELETE NEXT 1
		            SET DELETED ON
		         ENDIF
		
		      ENDSCAN
		   ENDIF
		
		* Mark parent accounts that have sub accounts as a title account
		* so the balance sheet prints them in bold.
		   SELECT balance
		   SET ORDER to acctno 
		   SET DELETED OFF
		   SCAN
		      lnRecNo   = RECNO()
		      m.cAcctNo = ALLTRIM(cAcctNo)
		
		      swselect('coa')
		      SCAN FOR cParent = m.cAcctNo  &&  Do a scan instead of a locate, because there could be multiple subaccounts, some with activity, some without
		         SELECT balance
		         LOCATE FOR cAcctNo = coa.cAcctNo AND NOT DELETED() AND IIF(NOT llIncludeZero, IIF(llCompare, nBegBal1 + nBegBal2 <> 0, nBegBal <> 0), .T.)
		         IF FOUND()
		            GOTO lnRecNo
		            REPLACE lTitle WITH .T.
		         ENDIF
		         GOTO lnRecNo
		      ENDSCAN
		      SELECT balance
		
		      lnCurrentLevel = THISFORM.glmaint.calcsublevel(m.cAcctNo)
		      SELECT balance
		      REPLACE nLevel WITH lnCurrentLevel
		
		*  To ensure proper sorting, we need to allow for them marking an account as being subaccount of an account that's not necessarily
		*  right in line previous to this one.  Since the account number isn't shown on the report, we'll fudge the account number by padding
		*  it with all the parent account numbers, so it prints correctly in order, even if the actual account numbers aren't.
		      swselect('coa')
		      LOCATE FOR cAcctNo = m.cAcctNo
		      IF FOUND()
		         IF NOT EMPTY(cParent)
		            lcParent = cParent
		            SELECT balance
		            REPLACE cSortField WITH lcParent + cSortField, cParent WITH lcParent
		            swselect('coa')
		            LOCATE FOR cAcctNo = lcParent
		            IF FOUND()
		               lcParent = cParent
		               IF NOT EMPTY(lcParent)
		                  SELECT balance
		                  REPLACE cSortField WITH lcParent + cSortField
		                  swselect('coa')
		                  LOCATE FOR cAcctNo = lcParent
		                  IF FOUND()
		                     lcParent = cParent
		                     IF NOT EMPTY(lcParent)
		                        SELECT balance
		                        REPLACE cSortField WITH lcParent + cSortField
		                        swselect('coa')
		                        LOCATE FOR cAcctNo = lcParent
		                        IF FOUND()
		                           lcParent = cParent
		                           IF NOT EMPTY(lcParent)
		                              SELECT balance
		                              REPLACE cSortField WITH lcParent + cSortField
		                              swselect('coa')
		                              LOCATE FOR cAcctNo = lcParent
		                              IF FOUND()
		                                 lcParent = cParent
		                                 IF NOT EMPTY(lcParent)
		                                    SELECT balance
		                                    REPLACE cSortField WITH lcParent + cSortField
		                                 ENDIF
		                              ENDIF
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		   SET DELETED ON 
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'SubAccounts', loError.LINENO, 'G/L Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE subtotals
		LOCAL lTotalAcct, lcLastAcctNo, lcParent, llShowTotals, lnCount, lnLastLevel, lnRecNo, lnRecNo2
		LOCAL lnTotal, lnTotal2, llCompare
		LOCAL llReturn, loError
		*:Global cAcctDesc, cAcctNo, cAcctType, cBalGroup, cSortField, nAcctType, nEndBal, nEndBal1
		*:Global nEndBal2, nLevel
		
		llReturn = .T.
		
		TRY
		   llCompare    = THISFORM.chkComparative.VALUE
		   llShowTotals = THISFORM.chkTotal.VALUE
		
		**  Scan balance one more time.  This time, it's to sum up totals for each level, and determine when a total line should be printed.
		**  When scanning, we know that no total will need to be printed when the account levels are continually descending or staying at the same level.
		**  When the account level has gone back up (decreased), then we know we've got to print at least one total.  Possibly more, depending on the
		**  difference between the previous level and the current level.  For example, going from a level 5 account to a level 2 account would entail
		**  the possibility of having to print a total for the level 5, 4, and 3 accounts.
		   STORE 0 TO lnLastLevel, lnTotal, lnTotal2
		   STORE '' TO lcLastAcctNo
		   WAIT WINDOW NOWAIT 'Counting Levels...'
		
		   SELECT balance
		   SET ORDER TO AcctNo
		   SCAN FOR naccttype < 8
		      lnRecNo      = RECNO()
		      m.cAcctNo    = ALLTRIM(cAcctNo)
		      m.lTotalAcct = .T.
		
		      IF nLevel < lnLastLevel  &&  We've started back up, so totals may need to be added, depending on the counts for each level
		         SELECT balance
		         lnCount  = 1
		         lnTotal  = 0
		         lnTotal2 = 0
		         LOCATE FOR cAcctNo = lcLastAcctNo
		         IF FOUND()  &&  Better find it, except for the first record...
		            lcParent = balance.cParent
		            SCAN FOR cParent = lcParent
		               lnCount = lnCount + 1
		               lnTotal = lnTotal + IIF(llCompare, nEndBal1, nEndBal)
		               IF llCompare
		                  lnTotal2 = lnTotal2 + nEndBal2
		               ENDIF
		            ENDSCAN
		
		            IF lnCount > 1
		               SELECT balance
		               LOCATE FOR cAcctNo = lcParent
		               IF FOUND()  &&  Darn well better be...
		                  m.cAcctDesc  = balance.cAcctDesc
		                  m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                  m.nAcctType  = balance.nAcctType
		                  m.cBalGroup  = balance.cBalGroup
		                  m.cAcctType  = balance.cAcctType
		                  m.cAcctNo    = balance.cAcctNo
		                  m.nLevel     = balance.nLevel
		                  m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                  IF llCompare
		                     m.nEndBal1 = lnTotal + balance.nEndBal1
		                     m.nEndBal2 = lnTotal2 + balance.nEndBal2
		                  ELSE
		                     m.nEndBal = lnTotal + balance.nEndBal  &&  Have to include the total for this specific account in the total, too
		                  ENDIF
		                  lnRecNo2 = RECNO()
		                  INSERT INTO balance FROM MEMVAR
		                  GOTO lnRecNo2
		               ENDIF
		
		               IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 4 accounts now
		                  SELECT balance
		                  lnCount  = 1
		                  lnTotal  = 0
		                  lnTotal2 = 0
		                  lcParent = balance.cParent
		                  SCAN FOR cParent = lcParent
		                     lnCount = lnCount + 1
		                     lnTotal = lnTotal + IIF(llCompare, nEndBal1, nEndBal)
		                     IF llCompare
		                        lnTotal2 = lnTotal2 + nEndBal2
		                     ENDIF
		                  ENDSCAN
		
		                  IF lnCount > 1
		                     SELECT balance
		                     LOCATE FOR cAcctNo = lcParent
		                     IF FOUND()  &&  Darn well better be...
		                        m.cAcctDesc  = balance.cAcctDesc
		                        m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                        m.nAcctType  = balance.nAcctType
		                        m.cBalGroup  = balance.cBalGroup
		                        m.cAcctType  = balance.cAcctType
		                        m.cAcctNo    = balance.cAcctNo
		                        m.nLevel     = balance.nLevel
		                        m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                        IF llCompare
		                           m.nEndBal1 = lnTotal + balance.nEndBal1
		                           m.nEndBal2 = lnTotal2 + balance.nEndBal2
		                        ELSE
		                           m.nEndBal = lnTotal + balance.nEndBal  &&  Have to include the total for this specific account in the total, too
		                        ENDIF
		                        lnRecNo2 = RECNO()
		                        INSERT INTO balance FROM MEMVAR
		                        GOTO lnRecNo2
		                     ENDIF
		
		                     IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 3 accounts now
		                        SELECT balance
		                        lnCount  = 1
		                        lnTotal  = 0
		                        lnTotal2 = 0
		                        lcParent = balance.cParent
		                        SCAN FOR cParent = lcParent
		                           lnCount = lnCount + 1
		                           lnTotal = lnTotal + IIF(llCompare, nEndBal1, nEndBal)
		                           IF llCompare
		                              lnTotal2 = lnTotal2 + nEndBal2
		                           ENDIF
		                        ENDSCAN
		
		                        IF lnCount > 1
		                           SELECT balance
		                           LOCATE FOR cAcctNo = lcParent
		                           IF FOUND()  &&  Darn well better be...
		                              m.cAcctDesc  = balance.cAcctDesc
		                              m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                              m.nAcctType  = balance.nAcctType
		                              m.cBalGroup  = balance.cBalGroup
		                              m.cAcctType  = balance.cAcctType
		                              m.cAcctNo    = balance.cAcctNo
		                              m.nLevel     = balance.nLevel
		                              m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                              IF llCompare
		                                 m.nEndBal1 = lnTotal + balance.nEndBal1
		                                 m.nEndBal2 = lnTotal2 + balance.nEndBal2
		                              ELSE
		                                 m.nEndBal = lnTotal + balance.nEndBal  &&  Have to include the total for this specific account in the total, too
		                              ENDIF
		                              lnRecNo2 = RECNO()
		                              INSERT INTO balance FROM MEMVAR
		                              GOTO lnRecNo2
		                           ENDIF
		
		                           IF lnLastLevel > balance.nLevel  &&  We're still not on the same level, so we may need to add another total - worst case scenario, this is level 2 accounts now
		                              SELECT balance
		                              lnCount  = 1
		                              lnTotal  = 0
		                              lnTotal2 = 0
		                              lcParent = balance.cParent
		                              SCAN FOR cParent = lcParent
		                                 lnCount = lnCount + 1
		                                 lnTotal = lnTotal + IIF(llCompare, nEndBal1, nEndBal)
		                                 IF llCompare
		                                    lnTotal2 = lnTotal2 + nEndBal2
		                                 ENDIF
		                              ENDSCAN
		
		                              IF lnCount > 1
		                                 SELECT balance
		                                 LOCATE FOR cAcctNo = lcParent
		                                 IF FOUND()  &&  Darn well better be...
		                                    m.cAcctDesc  = balance.cAcctDesc
		                                    m.cSortField = ALLTRIM(balance.cSortField) + '}'
		                                    m.nAcctType  = balance.nAcctType
		                                    m.cBalGroup  = balance.cBalGroup
		                                    m.cAcctType  = balance.cAcctType
		                                    m.cAcctNo    = balance.cAcctNo
		                                    m.nLevel     = balance.nLevel
		                                    m.cAcctDesc  = '**  Total - ' + ALLTRIM(balance.cAcctDesc) + '  **'
		                                    IF llCompare
		                                       m.nEndBal1 = lnTotal + balance.nEndBal1
		                                       m.nEndBal2 = lnTotal2 + balance.nEndBal2
		                                    ELSE
		                                       m.nEndBal = lnTotal + balance.nEndBal  &&  Have to include the total for this specific account in the total, too
		                                    ENDIF
		                                    lnRecNo2 = RECNO()
		                                    INSERT INTO balance FROM MEMVAR
		                                    GOTO lnRecNo2
		                                 ENDIF
		                              ENDIF
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		
		      GOTO lnRecNo
		
		      lnLastLevel  = balance.nLevel
		      lcLastAcctNo = balance.cAcctNo
		   ENDSCAN
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'SubTotals', loError.LINENO, 'G/L Balance Sheet', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE cboAccountType.Init
		THIS.ADDLISTITEM('**  All Account Levels  **',1,1)
		THIS.ADDLISTITEM('*',1,2)
		THIS.ADDLISTITEM('Level 1 Accounts',2,1)
		THIS.ADDLISTITEM('1',2,2)
		THIS.ADDLISTITEM('Level 2 Accounts and Above',3,1)
		THIS.ADDLISTITEM('2',3,2)
		THIS.ADDLISTITEM('Level 3 Accounts and Above',4,1)
		THIS.ADDLISTITEM('3',4,2)
		THIS.ADDLISTITEM('Level 4 Accounts and Above',5,1)
		THIS.ADDLISTITEM('4',5,2)
		
		THIS.LISTITEMID = 1
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE OpgQuarters.Init
		this.q1.value = 1
	ENDPROC

	PROCEDURE OpgQuarters.Q1.GotFocus
		THISFORM.opgQuarters.VALUE = 1
		
	ENDPROC

	PROCEDURE OpgQuarters.Q2.GotFocus
		THISFORM.opgQuarters.VALUE = 2
	ENDPROC

	PROCEDURE OpgQuarters.Q3.GotFocus
		THISFORM.opgQuarters.VALUE = 3
	ENDPROC

	PROCEDURE OpgQuarters.Q4.GotFocus
		THISFORM.opgQuarters.VALUE = 4
	ENDPROC

	PROCEDURE opgreportby.Valid
		
		DODEFAULT()
		
		IF this.value = 1
		   thisform.txtyear.enabled = .t.
		   thisform.txtperiod.enabled = .t.
		   thisform.opgquarters.q1.enabled = .f.
		   thisform.opgquarters.q2.enabled = .f.
		   thisform.opgquarters.q3.enabled = .f.
		   thisform.opgquarters.q4.enabled = .f.
		else
		   thisform.txtyear.enabled = .t.
		   thisform.txtperiod.enabled = .f.
		   thisform.opgquarters.q1.enabled = .t.
		   thisform.opgquarters.q2.enabled = .t.
		   thisform.opgquarters.q3.enabled = .t.
		   thisform.opgquarters.q4.enabled = .t.
		endif      
	ENDPROC

ENDDEFINE
