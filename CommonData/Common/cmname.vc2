*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmname.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
*< LIBCOMMENT: CodeMine name parser and name entry controls />
*
DEFINE CLASS cmnameparser AS cmserviceabstract OF "cmdataa.vcx" 		&& Codemine name parsing support library.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: displayname		&& Return a formated name string from standard component fields.
		*m: formalname		&& Translate common nicknames to their more formal first name.
		*m: formatname		&& Return a formated name string from standard component fields.
		*m: getgender		&& Try to determine gender from name prefix.
		*m: getnamefields		&& Return the field names related to the specified lastname field.
		*m: parsename		&& Parse a name string into its various components.
		*m: registryupdate		&& Initialize object properties from values stored in registry.
		*p: cfemaleprefixlist
		*p: clastnameprefixlist
		*p: cmaleprefixlist
		*p: cneutralprefixlist
		*p: csuffixlist
		*p: cversion
		*p: lallowtwoprefixes		&& Allow double prefixes, like "Mr. & Mrs."
		*p: ldisplaylastfirst		&& Display names in last, first order.
		*p: linitial		&& Add periods after first and middle initials.
		*p: lsinglenameislast
		*p: lstorelastfirst		&& Storage format for names stored as single string. True for last, first order.
		*p: luppercase		&& Force name strings to all upper case.
		*p: oapp
		*p: omessage
		*p: oregistry
		*p: ostring
		*a: alastprefix[1,2]
		*a: aprefix[1,3]
		*a: asuffix[1,2]
	*</DefinedPropArrayMethod>

	PROTECTED omessage,oregistry,ostring
	cfemaleprefixlist = Mrs.,Miss.,Ms.
	clastnameprefixlist = El,de,des,der,La,Le,Mc,Van,St
	cmaleprefixlist = Mr.
	cneutralprefixlist = Dr.,Rev.,Prof.
	csuffixlist = Jr.,Sr.,II,III,IV,Esq.
	cversion = 2.0.0
	lallowtwoprefixes = .F.		&& Allow double prefixes, like "Mr. & Mrs."
	ldisplaylastfirst = .F.		&& Display names in last, first order.
	linitial = .T.		&& Add periods after first and middle initials.
	lsinglenameislast = .T.
	lstorelastfirst = .F.		&& Storage format for names stored as single string. True for last, first order.
	luppercase = .F.		&& Force name strings to all upper case.
	Name = "cmnameparser"
	oapp = .NULL.
	omessage = .NULL.
	oregistry = .NULL.
	ostring = .NULL.
	
	PROCEDURE displayname		&& Return a formated name string from standard component fields.
		LPARAMETERS cSalute, cFirst, cMiddle, cLast, cSuffix
		*++
		*>>Return a formated name string from standard component fields.
		* Replace underscores with space, for use in printed reports.
		*--
		  RETURN CHRTRAN(THIS.FormatName(@m.cSalute, @m.cFirst, @m.cMiddle, @m.cLast, @m.cSuffix), '_', ' ')
		
	ENDPROC

	PROCEDURE formalname		&& Translate common nicknames to their more formal first name.
		LPARAMETERS cName, cGender
		*++
		*>>Translate common nicknames to their more formal first name.
		*--
		LOCAL cNicknamePath
		
		  * Open the nickname translation table in the current datasession.
		  m.cNicknamePath = 'Nickname.dbf'
		  IF NOT USED('cmNicknameTable')
		    IF NOT ISNULL(THIS.oApp)
		      m.cNicknamePath = THIS.oApp.GetFilePath(m.cNicknamePath)
		    ENDIF
		    USE (m.cNicknamePath) SHARED ALIAS cmNicknameTable ORDER nickname AGAIN IN 0
		  ENDIF
		
		  m.cGender = IIF(EMPTY(m.cGender), '', UPPER(m.cGender))
		  IF NOT EMPTY(m.cName) AND SEEK(PADR(UPPER(m.cName), LEN(cmNicknameTable.nickname)) + m.cGender, 'cmNicknameTable')
		    RETURN UPPER(TRIM(cmNicknameTable.realname))
		  ENDIF
		  RETURN UPPER(TRIM(m.cName))
		
	ENDPROC

	PROCEDURE formatname		&& Return a formated name string from standard component fields.
		LPARAMETERS cSalute, cFirst, cMiddle, cLast, cSuffix, lStorageFormat
		*++
		*>>Return a formated name string from standard component fields.
		*--
		LOCAL cFullName, lLastFirst
		
		  m.lLastFirst = IIF(m.lStorageFormat, THIS.lStoreLastFirst, THIS.lDisplayLastFirst)
		
		  m.cFullName = ''
		  IF m.lLastFirst
		    m.cFullName = IIF(EMPTY(m.cLast), '', TRIM(m.cLast) + ', ')
		  ENDIF
		
		  m.cFullName = m.cFullName + IIF(EMPTY(m.cSalute), '', TRIM(m.cSalute) + ' ')
		  m.cFullName = m.cFullName + IIF(EMPTY(m.cFirst), '', TRIM(m.cFirst) ;
		                            + IIF(THIS.lInitial AND LEN(TRIM(m.cFirst)) = 1, '. ',' '))
		  m.cFullName = m.cFullName + IIF(EMPTY(m.cMiddle), '', TRIM(m.cMiddle) ;
		                            + IIF(THIS.lInitial AND LEN(TRIM(m.cMiddle)) = 1, '. ',' '))
		  IF NOT m.lLastFirst
		    m.cFullName = m.cFullName + IIF(EMPTY(m.cLast), '', TRIM(m.cLast) + ' ')
		  ENDIF
		  RETURN TRIM(m.cFullName + IIF(EMPTY(m.cSuffix), '', TRIM(m.cSuffix)))
		
	ENDPROC

	PROCEDURE getgender		&& Try to determine gender from name prefix.
		LPARAMETERS cPrefix
		*++
		*>>Try to determine gender from name prefix.
		* Returns the male/female code character (M or F by default) or empty
		* string if unknown.
		*--
		LOCAL nMatch
		  IF NOT EMPTY(m.cPrefix)
		    m.nMatch = ASCAN(THIS.aPrefix, LOWER(CHRTRAN(m.cPrefix, '.', '')))
		    IF m.nMatch > 0
		      RETURN THIS.aPrefix[ASUBSCRIPT(THIS.aPrefix, m.nMatch, 1), 3]
		    ENDIF
		  ENDIF
		  RETURN ''
		
	ENDPROC

	PROCEDURE getnamefields		&& Return the field names related to the specified lastname field.
		LPARAMETERS cLastName, cFldPrefix, cFldFirst, cFldMiddle, cFldSuffix
		*++
		*>>Return the field names related to the specified lastname field.
		*--
		LOCAL cNameList
		  m.cNameList = THIS.oRegistry.GetKeyValue(KEYNAME_NAME_COMPONENTS + '.' + ALLTRIM(m.cLastname), KEY_TYPE_CHAR, '')
		  IF NOT EMPTY(m.cNameList)
		    m.cFldPrefix = GetToken(@m.cNameList, ',')
		    m.cFldFirst = GetToken(@m.cNameList, ',')
		    m.cFldMiddle = GetToken(@m.cNameList, ',')
		    m.cFldSuffix = GetToken(@m.cNameList, ',')
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Init
		*++
		* Initialize this instance of cmNameTools.
		*--
		  THIS.oRegistry = FindGlobalObject('cmRegistry')
		  THIS.oMessage = FindGlobalObject('cmMessage')
		  THIS.oApp = FindGlobalObject('AppApplication')
		  THIS.oString = CreateGlobalObject('cmStringTools')
		
		  * Registry is optional. If not found, then initialize from internal defaults.
		  IF ISNULL(THIS.oRegistry)
		    THIS.RegistryUpdate
		  ELSE
		    THIS.oRegistry.RequestUpdateMessages(THIS)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE parsename		&& Parse a name string into its various components.
		LPARAMETERS cInString, cSalute, cFirst, cMiddle, cLast, cSuffix
		*++
		*>>Parse a name string into its various components.
		*     Acceptable formats for the name are:
		*        1. [pfx] [Firstname] [Middle] Lastname [Sfx]
		*        2. Lastname, [pfx] Firstname [Middle] [Sfx]
		*
		* Return value:
		*   .T. if name parsed OK
		*   .F. if parse error
		*--
		LOCAL aTokens[20], nTokens, nIndex, cFullName, lHaveLastName, cExact
		
		    STORE '' TO m.cSalute, m.cFirst, m.cMiddle, m.cLast, m.cSuffix
		    IF NOT THIS.lUpperCase
		      m.cFullName = THIS.oString.ProperCase(ALLTRIM(STRTRAN(m.cInString, '.', ' ')))
		    ELSE
		      m.cFullName = UPPER(ALLTRIM(STRTRAN(m.cInString, '.', ' ')))
		    ENDIF
		
		    * If two full names are passed (like "Bob Jones & Mary Smith"), only the first will be parsed.
		    * Remainder will be returned in the cInString parameter.
		    m.cInString = ''
		
		    IF NOT EMPTY(m.cFullName)
		      m.cExact = SET('EXACT')
		      SET EXACT ON    && So ASCAN will work the way we want.
		
		      * Strip leading last name if present.
		      m.lHaveLastName = ',' $ m.cFullname
		      IF m.lHaveLastName
		        m.cLast = GetToken(@m.cFullName, ',')
		      ENDIF
		
		      m.cFullName = ALLTRIM(STRTRAN(m.cFullName, ',', ' '))
		      m.cFullName = CHRTRAN(m.cFullName, '+/', '&' + '&')
		      m.cFullName = STRTRAN(m.cFullName, '&', ' & ')  && Make sure space delimiters surround ampersand
		
		      * Test for and remove Salutation prefix(es).
		      m.nMatch = ASCAN(THIS.aPrefix, LOWER(GetToken(m.cFullName)))
		      IF m.nMatch > 0
		        m.cSalute = THIS.aPrefix[ASUBSCRIPT(THIS.aPrefix, m.nMatch, 1), 2]
		        GetToken(@m.cFullName)
		        DO WHILE LEFT(m.cFullName, 1) = '&'
		          m.cFullName = LTRIM(SUBSTR(m.cFullName, 2))
		        ENDDO
		
		        * See if there is a second prefix...
		        m.nMatch = ASCAN(THIS.aPrefix, LOWER(GetToken(m.cFullName)))
		        IF m.nMatch > 0
		          IF THIS.lAllowTwoPrefixes   && Ignore it if not allowed.
		            m.cSalute = m.cSalute + ' & ' + THIS.aPrefix[ASUBSCRIPT(THIS.aPrefix, m.nMatch, 1), 2]
		          ELSE
		            THIS.oMessage.SetLastMessage('%MsgTwoPrefixes')
		            RETURN .F.
		          ENDIF
		          GetToken(@m.cFullName)
		        ENDIF
		        IF THIS.lUpperCase
		          m.cSalute = UPPER(m.cSalute)
		        ENDIF
		      ENDIF
		
		      * If an ampersand remains in the string, it must be a couple's name. Remove all
		      * the spaces around the ampersands, so the names will be treated as a unit.
		      IF '&' $ m.cFullName
		        LOCAL nTokenCount, ix, cName, cToken
		        m.cName = ''
		        m.nTokenCount = 0
		        DO WHILE NOT EMPTY(m.cFullName)
		          m.cToken = GetToken(@m.cFullName)
		          m.nTokenCount = m.nTokenCount + 1
		          IF m.cToken = '&'
		            * If 2 or more tokens before "&", we treat this as 2 complete separate names.
		            * For example, "Mr John Smith & Miss Mary Jones". In this case, we only parse 
		            * the first complete name. The second full name is returned in the cInString 
		            * parameter to be parsed later, or ignored by the caller.
		            IF m.nTokenCount > 2
		              m.cInString = m.cFullname
		              EXIT
		            ELSE
		              m.cName = LTRIM(m.cName + '&' + GetToken(@m.cFullName))
		            ENDIF
		          ELSE
		            m.cName = LTRIM(m.cName + ' ' + m.cToken)
		          ENDIF
		        ENDDO
		        m.cFullName = m.cName
		      ENDIF
		
		      * Build a local array of remaining tokens.
		      m.nTokens = 0
		      DO WHILE NOT EMPTY(m.cFullName)
		        m.nTokens = m.nTokens + 1
		        IF m.nTokens <= ALEN(aTokens)
		          * Store the token, and restore (or force) spaces around embedded ampersands.
		          aTokens[m.nTokens] = STRTRAN(GetToken(@m.cFullName), '&', ' & ')
		        ELSE
		          m.cFullName = ''   && Truncate when array full.
		        ENDIF
		      ENDDO
		
		      IF m.nTokens > 0
		        * See if last token is a recognized suffix, and store if so.
		        m.nMatch = ASCAN(THIS.aSuffix, LOWER(aTokens[m.nTokens]))
		        IF m.nMatch > 0
		          m.cSuffix = THIS.aSuffix[ASUBSCRIPT(THIS.aSuffix, m.nMatch, 1), 2]
		          =ADEL(aTokens, m.nTokens)
		          m.nTokens = m.nTokens - 1
		          IF THIS.lUpperCase
		            m.cSuffix = UPPER(m.cSuffix)
		          ENDIF
		        ENDIF
		
		        * If last name is still needed, pick it off from the end of the token list.
		        IF m.nTokens > 0 AND NOT m.lHaveLastName
		          m.cLast = aTokens[m.nTokens]
		          m.nTokens = m.nTokens - 1
		
		          * Allow double prefix on last name strings, eg: van de Campe
		          IF m.nTokens > 0 AND ASCAN(THIS.aLastPrefix, LOWER(aTokens[m.nTokens])) > 0
		            m.cLast = aTokens[m.nTokens] + ' ' + m.cLast
		            m.nTokens = m.nTokens - 1
		            IF m.nTokens > 0 AND ASCAN(THIS.aLastPrefix, LOWER(aTokens[m.nTokens])) > 0
		              m.cLast = aTokens[m.nTokens] + ' ' + m.cLast
		              m.nTokens = m.nTokens - 1
		            ENDIF
		          ENDIF
		        ENDIF
		
		        * Now pick off the middle and first names that remain.
		        IF m.nTokens > 0
		          IF m.nTokens > 1
		            m.cMiddle = aTokens[m.nTokens]
		            m.nTokens = m.nTokens - 1
		          ENDIF
		          FOR nIndex = 1 TO m.nTokens
		            m.cFirst = LTRIM(m.cFirst + ' ' + aTokens[m.nIndex])
		          ENDFOR
		        ENDIF
		      ENDIF
		
		      * Restore changed settings.
		      IF m.cExact = 'OFF'
		        SET EXACT OFF
		      ENDIF
		
		      * A last name is required for success return.
		      IF EMPTY(m.cLast)
		        THIS.oMessage.SetLastMessage('%MsgLastRequired')
		        RETURN .F.
		      ENDIF
		
		      * If only a LastName and lSingleNameIsLast is not set, make it the first name.
		      IF NOT THIS.lSingleNameIsLast AND EMPTY(m.cFirst) AND EMPTY(m.cSalute)
		        m.cFirst = m.cLast
		        m.cLast = ''
		      ENDIF
		    ENDIF   && NOT EMPTY(m.cFullname)
		    RETURN .T.
		
	ENDPROC

	PROCEDURE registryupdate		&& Initialize object properties from values stored in registry.
		*++
		*>>Initialize object properties from values stored in registry.
		*--
		LOCAL nIndex, cItems
		
		  IF ISNULL(THIS.oRegistry)
		    m.cItems = THIS.cMalePrefixList
		  ELSE
		    m.citems = THIS.oRegistry.GetKeyValue(KEYNAME_MALE_PREFIX_LIST, KEY_TYPE_CHAR, THIS.cMalePrefixList)
		  ENDIF
		  DIMENSION THIS.aPrefix[OCCURS(',', m.cItems) + 1, 3]
		  FOR nIndex = 1 TO ALEN(THIS.aPrefix, 1)
		    THIS.aPrefix[m.nIndex, 2] = GetToken(@m.cItems, ',')
		    THIS.aPrefix[m.nIndex, 1] = LOWER(ALLTRIM(STRTRAN(THIS.aPrefix[m.nIndex, 2], '.', '')))
		    THIS.aPrefix[m.nIndex, 3] = 'M'
		  ENDFOR
		
		  IF ISNULL(THIS.oRegistry)
		    m.cItems = THIS.cFemalePrefixList
		  ELSE
		    m.cItems = THIS.oRegistry.GetKeyValue(KEYNAME_FEMALE_PREFIX_LIST, KEY_TYPE_CHAR, THIS.cFemalePrefixList)
		  ENDIF
		  DIMENSION THIS.aPrefix[ALEN(THIS.aPrefix, 1) + OCCURS(',', m.cItems) + 1, 3]
		  FOR nIndex = m.nIndex TO ALEN(THIS.aPrefix, 1)
		    THIS.aPrefix[m.nIndex, 2] = GetToken(@m.cItems, ',')
		    THIS.aPrefix[m.nIndex, 1] = LOWER(ALLTRIM(STRTRAN(THIS.aPrefix[m.nIndex, 2], '.', '')))
		    THIS.aPrefix[m.nIndex, 3] = 'F'
		  ENDFOR
		
		  IF ISNULL(THIS.oRegistry)
		    m.cItems = THIS.cNeutralPrefixList
		  ELSE
		    m.cItems = THIS.oRegistry.GetKeyValue(KEYNAME_NEUTRAL_PREFIX_LIST, KEY_TYPE_CHAR, THIS.cNeutralPrefixList)
		  ENDIF
		  DIMENSION THIS.aPrefix[ALEN(THIS.aPrefix, 1) + OCCURS(',', m.cItems) + 1, 3]
		  FOR nIndex = m.nIndex TO ALEN(THIS.aPrefix, 1)
		    THIS.aPrefix[m.nIndex, 2] = GetToken(@m.cItems, ',')
		    THIS.aPrefix[m.nIndex, 1] = LOWER(ALLTRIM(STRTRAN(THIS.aPrefix[m.nIndex, 2], '.', '')))
		    THIS.aPrefix[m.nIndex, 3] = ''
		  ENDFOR
		
		  IF ISNULL(THIS.oRegistry)
		    m.cItems = THIS.cSuffixList
		  ELSE
		    m.cItems = THIS.oRegistry.GetKeyValue(KEYNAME_SUFFIX_LIST, KEY_TYPE_CHAR, THIS.cSuffixList)
		  ENDIF
		  DIMENSION THIS.aSuffix[OCCURS(',', m.cItems) + 1, 2]
		  FOR nIndex = 1 TO ALEN(THIS.aSuffix, 1)
		    THIS.aSuffix[m.nIndex, 2] = GetToken(@m.cItems, ',')
		    THIS.aSuffix[m.nIndex, 1] = LOWER(ALLTRIM(STRTRAN(THIS.aSuffix[m.nIndex, 2], '.', '')))
		  ENDFOR
		
		  IF ISNULL(THIS.oRegistry)
		    m.cItems = THIS.cLastNamePrefixList
		  ELSE
		    m.cItems = THIS.oRegistry.GetKeyValue(KEYNAME_LAST_PREFIX_LIST, KEY_TYPE_CHAR, THIS.cLastNamePrefixList)
		  ENDIF
		  DIMENSION THIS.aLastPrefix[OCCURS(',', m.cItems) + 1, 2]
		  FOR nIndex = 1 TO ALEN(THIS.aLastPrefix, 1)
		    THIS.aLastPrefix[m.nIndex, 2] = GetToken(@m.cItems, ',')
		    THIS.aLastPrefix[m.nIndex, 1] = LOWER(ALLTRIM(STRTRAN(THIS.aLastPrefix[m.nIndex, 2], '.', '')))
		  ENDFOR
		
		  IF NOT ISNULL(THIS.oRegistry)
		    THIS.lDisplayLastFirst = THIS.oRegistry.GetKeyValue(KEYNAME_DISPLAY_LAST_FIRST, KEY_TYPE_LOGICAL, THIS.lDisplayLastFirst)
		    THIS.lStoreLastFirst = THIS.oRegistry.GetKeyValue(KEYNAME_STORE_LAST_FIRST, KEY_TYPE_LOGICAL, THIS.lStoreLastFirst)
		    THIS.lUppercase = THIS.oRegistry.GetKeyValue(KEYNAME_UPPER_NAME, KEY_TYPE_LOGICAL, THIS.lUppercase)
		    THIS.lInitial = THIS.oRegistry.GetKeyValue(KEYNAME_PERIOD_INITIAL, KEY_TYPE_LOGICAL, THIS.lInitial)
		    THIS.lAllowTwoPrefixes = THIS.oRegistry.GetKeyValue(KEYNAME_DOUBLE_PREFIX, KEY_TYPE_LOGICAL, THIS.lAllowTwoPrefixes)
		  ENDIF
		
	ENDPROC

	PROCEDURE release
		*++
		*>>Tell the registry we don't exist any more.
		*--
		  IF NOT ISNULL(THIS.oRegistry)
		    THIS.oRegistry.CancelUpdateMessages(THIS)
		  ENDIF
		
		  THIS.oRegistry = .NULL.
		  THIS.oString = .NULL.
		  THIS.oMessage = .NULL.
		
		  RELEASE THIS
		
	ENDPROC

ENDDEFINE

DEFINE CLASS txtname AS txttextboxcustom OF "..\custom\ccontrol.vcx" 		&& Custom Codemine textbox control for entering, parsing, and displaying proper names.
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: cfirst		&& First name
		*p: clast		&& Last name
		*p: cmiddle		&& Middle name
		*p: cprefix		&& Name prefix
		*p: csuffix		&& Name suffix
		*p: cvaluesourcefirst		&& Value source for the "first name" component of the name data.
		*p: cvaluesourcelast		&& Value source for the "last name" component of the name data.
		*p: cvaluesourcemiddle		&& Value source for the "middle name" component of the name data.
		*p: cvaluesourceprefix		&& Value source for the "prefix" component of the name data.
		*p: cvaluesourcesuffix		&& Value source for the "suffix" component of the name data.
	*</DefinedPropArrayMethod>

	cfirst = 		&& First name
	chelpclasskey = %hlpNameTextbox,%hlpTextbox
	clast = 		&& Last name
	cmiddle = 		&& Middle name
	cprefix = 		&& Name prefix
	csuffix = 		&& Name suffix
	cvaluesourcefirst = 		&& Value source for the "first name" component of the name data.
	cvaluesourcelast = 		&& Value source for the "last name" component of the name data.
	cvaluesourcemiddle = 		&& Value source for the "middle name" component of the name data.
	cvaluesourceprefix = 		&& Value source for the "prefix" component of the name data.
	cvaluesourcesuffix = 		&& Value source for the "suffix" component of the name data.
	Height = 22
	InputMask = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
	Name = "txtname"
	Width = 160
	
	PROCEDURE contextmenuexecute
		LPARAMETER cOption
		
		  * Custom revert code for this class - revert all 5 source fields.
		  IF PROPER(m.cOption) == '%barrevert'
		    THIS.cPrefix = IIF(NOT EMPTY(THIS.cValueSourcePrefix), THIS.LoadTranslation(OLDVAL(THIS.cValueSourcePrefix, THIS.cWorkarea)), '')
		    THIS.cFirst = IIF(NOT EMPTY(THIS.cValueSourceFirst), THIS.LoadTranslation(OLDVAL(THIS.cValueSourceFirst, THIS.cWorkarea)), '')
		    THIS.cMiddle = IIF(NOT EMPTY(THIS.cValueSourceMiddle), THIS.LoadTranslation(OLDVAL(THIS.cValueSourceMiddle, THIS.cWorkarea)), '')
		    THIS.cLast = IIF(NOT EMPTY(THIS.cValueSourceLast), THIS.LoadTranslation(OLDVAL(THIS.cValueSourceLast, THIS.cWorkarea)), '')
		    THIS.cSuffix = IIF(NOT EMPTY(THIS.cValueSourceSuffix), THIS.LoadTranslation(OLDVAL(THIS.cValueSourceSuffix, THIS.cWorkarea)), '')
		    THIS.Value = THIS.oName.FormatName(THIS.cPrefix, THIS.cFirst, THIS.cMiddle, THIS.cLast, THIS.cSuffix)
		
		    IF NOT EMPTY(THIS.Valid())
		      =SETFLDSTATE(SUBSTR(THIS.cValueSource, AT('.', THIS.cValueSource) + 1), 1, THIS.cWorkarea)
		    ENDIF
		  ELSE
		    RETURN DODEFAULT(m.cOption)
		  ENDIF
		
	ENDPROC

	PROCEDURE Init
		* Get a reference to the name parsing functions object
		THIS.AddProperty('oName', CreateGlobalObject('cmNameParser'))
		
		* For compatability with other controls, put a copy of the lastname source in the cValueSource property.
		IF NOT EMPTY(THIS.ControlSource)
		  THIS.cValueSource = THIS.ControlSource
		  THIS.ControlSource = ''
		ENDIF
		
		THIS.cValueSourceLast = THIS.cValueSource
		
		* If only a lastname source is specified, see if it is registered, and get remaining source fields if so.
		IF NOT EMPTY(THIS.cValueSource) AND EMPTY(THIS.cValueSourceFirst)
		  LOCAL cWorkarea, cFldFirst, cFldMiddle, cFldPrefix, cFldSuffix
		
		  m.cWorkarea = IIF('.' $ THIS.cValueSourceLast, LEFT(THIS.cValueSourceLast, RAT('.', THIS.cValueSourceLast)), '')
		
		  IF THIS.oName.GetNameFields(SUBSTR(THIS.cValueSourceLast, RAT('.', THIS.cValueSourceLast) + 1), ;
		                              @m.cFldPrefix, @m.cFldFirst, @m.cFldMiddle, @m.cFldSuffix)
		    THIS.cValueSourcePrefix = m.cWorkarea + m.cFldPrefix
		    THIS.cValueSourceFirst = m.cWorkarea + m.cFldFirst
		    THIS.cValueSourceMiddle = m.cWorkarea + m.cFldMiddle
		    THIS.cValueSourceSuffix = m.cWorkarea + m.cFldSuffix
		  ENDIF
		ENDIF
		
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE loadvalue
		THIS.lChanged = .F.
		IF NOT EMPTY(THIS.cValueSource)
		  IF NOT THIS.lReadLock
		    IF EMPTY(THIS.cValueSourceFirst)   && If only using a single source field to store entire name
		      LOCAL cPrefix, cFirst, cMiddle, cLast, cSuffix
		      THIS.oName.ParseName(THIS.LoadTranslation(EVALUATE(THIS.cValueSource)), @m.cPrefix, @m.cFirst, @m.cMiddle, @m.cLast, @m.cSuffix)
		      THIS.cPrefix = m.cPrefix
		      THIS.cFirst = m.cFirst
		      THIS.cMiddle = m.cMiddle
		      THIS.cLast = m.cLast
		      THIS.cSuffix = m.cSuffix
		    ELSE
		      THIS.cPrefix = IIF(NOT EMPTY(THIS.cValueSourcePrefix), THIS.LoadTranslation(EVALUATE(THIS.cValueSourcePrefix)), '')
		      THIS.cFirst = IIF(NOT EMPTY(THIS.cValueSourceFirst), THIS.LoadTranslation(EVALUATE(THIS.cValueSourceFirst)), '')
		      THIS.cMiddle = IIF(NOT EMPTY(THIS.cValueSourceMiddle), THIS.LoadTranslation(EVALUATE(THIS.cValueSourceMiddle)), '')
		      THIS.cLast = IIF(NOT EMPTY(THIS.cValueSourceLast), THIS.LoadTranslation(EVALUATE(THIS.cValueSourceLast)), '')
		      THIS.cSuffix = IIF(NOT EMPTY(THIS.cValueSourceSuffix), THIS.LoadTranslation(EVALUATE(THIS.cValueSourceSuffix)), '')
		    ENDIF
		    THIS.Value = THIS.oName.FormatName(THIS.cPrefix, THIS.cFirst, THIS.cMiddle, THIS.cLast, THIS.cSuffix)
		  ELSE
		    * Read-protected or parse error from single field source.
		    STORE '' TO THIS.Value, THIS.cPrefix, THIS.cFirst, THIS.cMiddle, THIS.cLast, THIS.cSuffix
		  ENDIF
		ENDIF
		RETURN .T.
		
	ENDPROC

	PROCEDURE setvalue
		LPARAMETERS cNewValue
		LOCAL cPrefix, cFirst, cMiddle, cLast, cSuffix
		
		  IF NOT THIS.oName.ParseName(TRIM(m.cNewValue), @m.cPrefix, @m.cFirst, @m.cMiddle, @m.cLast, @m.cSuffix)
		    IF NOT ISNULL(THISFORM.oMessage)
		      THISFORM.oMessage.DisplayLastMessage()
		    ELSE
		      THISFORM.DisplayMessage('%msgFieldValidFailed', THIS.Value)   && Generic message if no message object
		    ENDIF
		    RETURN .F.
		  ENDIF
		
		  * Keep a copy of all components, even if no corresponding data source.
		  THIS.cPrefix = m.cPrefix
		  THIS.cFirst = m.cFirst
		  THIS.cMiddle = m.cMiddle
		  THIS.cLast = m.cLast
		  THIS.cSuffix = m.cSuffix
		  THIS.Value = THIS.oName.FormatName(THIS.cPrefix, THIS.cFirst, THIS.cMiddle, THIS.cLast, THIS.cSuffix)
		
		  * Continue with validation and valuesource update.
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE storevalue
		IF EMPTY(THIS.cValueSource)
		  THIS.lChanged = .F.
		ELSE
		  WITH THISFORM.cmBindingManager
		    IF EMPTY(THIS.cValueSourceFirst)   && If only using a single source field to store entire name
		      IF .StoreValue(THIS, THIS.oName.FormatName(THIS.cPrefix, THIS.cFirst, THIS.cMiddle, THIS.cLast, THIS.cSuffix))
		        THIS.lChanged = .F.
		      ENDIF
		    ELSE
		      LOCAL lChangeFlag
		      m.lChangeFlag = THIS.lChanged
		
		      IF  .StoreValue(THIS, THIS.cPrefix, THIS.cValueSourcePrefix) ;
		      AND .StoreValue(THIS, THIS.cFirst, THIS.cValueSourceFirst) ;
		      AND .StoreValue(THIS, THIS.cMiddle, THIS.cValueSourceMiddle) ;
		      AND .StoreValue(THIS, THIS.cSuffix, THIS.cValueSourceSuffix) ;
		      AND .StoreValue(THIS, THIS.cLast, THIS.cValueSourceLast)  && Lastname must update last
		        THIS.lChanged = .F.
		      ELSE
		        THIS.lChanged = m.lChangeFlag  && Restore flag value on store error, since BindMan may have cleared it.
		      ENDIF
		    ENDIF
		  ENDWITH
		
		
		  * Update any other controls bound to the same cursor fields. We do this once
		  * here, rather than once for each name component field store, in order
		  * to get the best runtime performance.
		*  IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		*    THISFORM.cmDataManager.RefreshUI()
		*  ENDIF
		ENDIF
		
		RETURN NOT THIS.lChanged    && If change flag is still set, a rule violation occurred
		
	ENDPROC

	PROCEDURE Valid
		LOCAL cPrefix, cFirst, cMiddle, cLast, cSuffix
		IF THIS.lChanged
		  IF NOT THIS.oName.ParseName(TRIM(THIS.Value), @m.cPrefix, @m.cFirst, @m.cMiddle, @m.cLast, @m.cSuffix)
		    IF NOT ISNULL(THISFORM.oMessage)
		      THISFORM.oMessage.DisplayLastMessage()
		    ELSE
		      THISFORM.DisplayMessage('%msgFieldValidFailed', THIS.Value)   && Generic message if no message object
		    ENDIF
		    RETURN 0
		  ENDIF
		
		  * Keep a copy of all components, even if no corresponding data source.
		  THIS.cPrefix = m.cPrefix
		  THIS.cFirst = m.cFirst
		  THIS.cMiddle = m.cMiddle
		  THIS.cLast = m.cLast
		  THIS.cSuffix = m.cSuffix
		  THIS.Value = THIS.oName.FormatName(THIS.cPrefix, THIS.cFirst, THIS.cMiddle, THIS.cLast, THIS.cSuffix)
		
		  * Continue with validation and valuesource update.
		  RETURN DODEFAULT()
		ENDIF
		RETURN .T.
		
	ENDPROC

ENDDEFINE
