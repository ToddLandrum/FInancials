*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmapp.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
*< LIBCOMMENT: CodeMine application manager class and associated form classes />
*
DEFINE CLASS cmapplicationmanager AS cmserviceabstract OF "cmdataa.vcx" 		&& CodeMine application manager class.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Display the "About" dialog for the application.
		*m: activateexistinginstance		&& Check for existing instances of this app, and return .T. if OK to start a new instance.
		*m: aftercreateglobalobjects		&& This event occurs after all Global Service Object have been created. It occurs in a compiled app and in the Interactive Development Environemnt.
		*m: aftercreateglobalobjectsfailure		&& This event occurs after an error prevented a necessary Global Service Object from starting.
		*m: afterinit		&& Custom developer code, called just after application Init() event. Can be used to define class name aliases.
		*m: afterinstall		&& Custom developer code to run after the First-time Install Dialog completes successfully.
		*m: afterreadevents		&& This event occurs after the READ EVENTS command returns. Not called when application is running under the Interactive Development Environemnt.
		*m: aftershutdown		&& Called after application shutdown but before CLEAR EVENTS, return .T. to CLEAR EVENTS and exit.
		*m: beforeactivateexistinginstance		&& Custom developer code to run before re-activating an existing instance of the application (and closing this instance) on startup.
		*m: beforecreateglobalobjects		&& This event occurs before any Global Service Object have been created. It occurs in a compiled app and in the Interactive Development Environemnt.
		*m: beforeexit		&& Custom developer code. Called just before all Global service objects are released, when the applicaiton is exiting.  Not called when application is running under the Interactive Development Environemnt.
		*m: beforemenu		&& Called before System menu is displayed. Must return .T. for application to run.  Not called when application is running under the Interactive Development Environemnt.
		*m: beforereadevents		&& This event occurs before the application goes into its main event loop for the first time.  Not called when application is running under the Interactive Development Environemnt.
		*m: beforeshutdown		&& Called before application shutdown, must return .T. to allow shutdown.
		*m: beforestart		&& Custom developer code, called during application startup, after core VCX libraries are loaded, but before the installation check.
		*m: cformbackground_assign		&& Apply background texture to all open forms when the property value is changed.
		*m: checkversion		&& Verify that the app is running with the correct version of VFP and Codemine.fll
		*m: clearbanner		&& Remove the banner bitmap from the main application window.
		*m: clearpreference		&& Delete a stored preference value from the Windows registry.
		*m: closeapptoolbars		&& Close and remove all application global toolbars at application shutdown. Called after the READ EVENTS command finishes.
		*m: closefoxtoolbars		&& Hide VFP development mode system toolbars.
		*m: closesplash		&& Remove the splash screen.
		*m: createglobalobjects		&& Create Global Service Objects from list specified in the "%Local.Application.Global Objects" key.
		*m: createstates		&& Create definitions for custom states and actions used by the application.
		*m: get		&& Return information about the current application.
		*m: getconnectionstring		&& Given a connection name, return the actual connection name or connection string to use at runtime.
		*m: getfilepath		&& Given a filespec, return the full path name to use to find the file at runtime.
		*m: getpreference		&& Retreive a user preference in the Windows registry, using the specified key path.
		*m: initsession		&& Initialize various SET settings for the default data session, and also global session-independant settings.
		*m: install		&& Called on startup to determine what setup or registration steps need to be done. Returning .F. will prevent applicatin from starting.
		*m: installdialog		&& Called on startup to Display the once-only registration and setup dialog when necessary.
		*m: isdatapathvalid		&& Called on startup to verify stored data paths. Return .T. if the paths are valid, or .F. if one or more paths are invalid. Return .NULL. to Abort app startup.
		*m: isenabled		&& Custom developer code to determine if form launch buttons or other items are available at any given time.
		*m: isregistered		&& Called on startup to determine if the applciation has been registered with a valid serial number.
		*m: lformbackgroundtile_assign
		*m: loadapilibrary		&& Find and load the Codemine.fll API library.
		*m: loadcorelibraries		&& Load the core class libraries required for all client applications.
		*m: loadlibraries		&& Load all the class libraries and Procedure libraries used by the app, from a dynamic list stored in the app registry tables.
		*m: omessage_access
		*m: openapptoolbars		&& Define and open all application global toolbars.
		*m: opensplash		&& Create and display the splash screen for the application.
		*m: oregistry_access
		*m: osecurity_access
		*m: ostatemanager_access
		*m: pathnotfound		&& Display a dialog when one of the file paths in the Windows registry is no longer valid.
		*m: rebuildwindowpopup		&& Rebuild the active window list in the Window popup menu.
		*m: refresh		&& Called on startup and main window resize to re-center the banner bitmap.
		*m: restorefoxtoolbars		&& Redisplay VFP development mode toolbars.
		*m: restoresizeandposition		&& Restore last saved main window size and position on application startup.
		*m: savesizeandposition		&& Save main window size and position on application exit.
		*m: serialhash		&& Provide a simple algorithm for validating serial numbers.
		*m: setdevsearchpath		&& Set search path used for the CodeMine Development Environment for this app.
		*m: setpreference		&& Store a user preference in the Windows registry, using the specified key path under the HKEY_CURRENT_USER root.
		*m: setsearchpath		&& Set default search path for data files from vaules set in system registry
		*m: settitle		&& Set the title (caption) of the main application window.
		*m: showbanner		&& Center the banner bitmap in the main application window. Return .F. if there is no bitmap.
		*m: showmainwindow		&& Show the main VFP window, if not already visuble
		*m: showmenu		&& Put up the main application menu bar.
		*m: shutdown		&& Shut down the application.
		*m: start		&& Begin application execution.
		*m: uninstall		&& Remove all system registry entries for this application in preperation for unisntall or reinstall.
		*p: cbanner		&& Welcome banner. Bitmap file displayed on background screen thoughout app execution.
		*p: ccoreclasslibraries		&& Coma separated list of Core CodeMine class libraries required at application startup.
		*p: cfillbitmap		&& Background fill bitmap pattern.
		*p: cformbackground		&& Global form background BMP/JPG image file to apply to every form in the app. Set to .NULL. to disable.
		*p: cicon		&& Default icon used for all forms
		*p: cinstanceid		&& Unique string to Identify this application for detection of multiple instances. Leave empty to use default value.
		*p: clocalregistry		&& Table name for the local registry table - usually a free table.
		*p: cmaindbc		&& File name (not full path) of the main DBC for the application, containing the shared registry table. The default is 'AppData.dbc'.
		*p: cmenu		&& Main menu program name
		*p: cpathcommon		&& Path to common data tables shared by multiple applications
		*p: cpathlocal		&& Path to local data tables
		*p: cpathshared		&& Path to shared network data tables
		*p: csecuritysource		&& Set to "AppRegRemote" to use remote server based security tables. Leave blank to use default shared appreg01 table.
		*p: csharedregistry		&& Table or view name for the shared registry VFP table. Do not change this value unless you are sure you know what you are doing.
		*p: csplash		&& Name of splash screen form - displayed temporarily during app startup
		*p: csysregroot		&& System registry root key used to save app properties. Design-time value is overridden at runtime by parameter to Init() method.
		*p: ctoolbars		&& Comma separated list of application toolbars
		*p: cversion		&& Application version number
		*p: cwindowpopup		&& Name of Window menu popup. Set to empty string to disable the Window menu.
		*p: lautoyield		&& VFP AutoYield setting to apply during app execution. Set to .f. if using any ActiveX controls.
		*p: lformbackgroundtile		&& Set to .T. to tile the cFormBackground image, .F. to stretch the image to fill the form.
		*p: lmaximize		&& Set to .T. to always unconditionaly maximize the main VFP window on startup
		*p: lremembersizeandposition		&& Set to .T. to save and restore the main application window size
		*p: lshowmain		&& Set true to display the main VFP window on application startup.
		*p: lshutdown
		*p: lsingleinstance		&& Set to .T. if only a single instance of the application is allowed to run on each machine, or .F. if multiple instances are allowed.
		*p: ltoolbarmemory		&& Set to .T. if application should remember which toolbars are open and which ones are closed each time the application starts.
		*p: omessage		&& Runtime object reference to the Message Manager
		*p: oregistry		&& Runtime object reference to the App Registry Manager
		*p: osecurity		&& Runtime object reference to the Security Manager
		*p: ostatemanager		&& Runtime object reference to the State Manager
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cbanner = c:\develop\codeminenew\graphics\swlogo1.bmp		&& Welcome banner. Bitmap file displayed on background screen thoughout app execution.
	ccoreclasslibraries = Codemine,cmButton,cmRegKey,cmForms,cmData,cmDataA,cmState,cmMsgMan,cmDialog,appforms		&& Coma separated list of Core CodeMine class libraries required at application startup.
	cfillbitmap = 		&& Background fill bitmap pattern.
	cformbackground = .NULL.		&& Global form background BMP/JPG image file to apply to every form in the app. Set to .NULL. to disable.
	cicon = 		&& Default icon used for all forms
	cinstanceid = 		&& Unique string to Identify this application for detection of multiple instances. Leave empty to use default value.
	clocalregistry = AppReg02.dbf		&& Table name for the local registry table - usually a free table.
	cmaindbc = appdata.dbc		&& File name (not full path) of the main DBC for the application, containing the shared registry table. The default is 'AppData.dbc'.
	cmenu = 		&& Main menu program name
	cpathcommon = 		&& Path to common data tables shared by multiple applications
	cpathlocal = 		&& Path to local data tables
	cpathshared = 		&& Path to shared network data tables
	csecuritysource = 		&& Set to "AppRegRemote" to use remote server based security tables. Leave blank to use default shared appreg01 table.
	csharedregistry = AppReg01		&& Table or view name for the shared registry VFP table. Do not change this value unless you are sure you know what you are doing.
	csplash = 		&& Name of splash screen form - displayed temporarily during app startup
	csysregroot = Software\Soft Classics\CodeMine		&& System registry root key used to save app properties. Design-time value is overridden at runtime by parameter to Init() method.
	ctoolbars = 		&& Comma separated list of application toolbars
	cversion = 1.0.0		&& Application version number
	cwindowpopup = Window		&& Name of Window menu popup. Set to empty string to disable the Window menu.
	Height = 143
	lautoyield = .F.		&& VFP AutoYield setting to apply during app execution. Set to .f. if using any ActiveX controls.
	lformbackgroundtile = .F.		&& Set to .T. to tile the cFormBackground image, .F. to stretch the image to fill the form.
	lmaximize = .F.		&& Set to .T. to always unconditionaly maximize the main VFP window on startup
	lremembersizeandposition = .T.		&& Set to .T. to save and restore the main application window size
	lshowmain = .T.		&& Set true to display the main VFP window on application startup.
	lshutdown = .F.
	lsingleinstance = .T.		&& Set to .T. if only a single instance of the application is allowed to run on each machine, or .F. if multiple instances are allowed.
	ltoolbarmemory = .T.		&& Set to .T. if application should remember which toolbars are open and which ones are closed each time the application starts.
	Name = "cmapplicationmanager"
	omessage = .NULL.		&& Runtime object reference to the Message Manager
	oregistry = .NULL.		&& Runtime object reference to the App Registry Manager
	osecurity = .NULL.		&& Runtime object reference to the Security Manager
	ostatemanager = .NULL.		&& Runtime object reference to the State Manager
	Width = 100
	_memberdata = <VFPData>
		<memberdata name="lshutdown" display="lShutDown"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Display the "About" dialog for the application.
		*++
		*>>Display the "About" dialog for the application.
		*--
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.OpenModalForm('frmAboutApplication')
		  ENDIF
		
	ENDPROC

	PROCEDURE activateexistinginstance		&& Check for existing instances of this app, and return .T. if OK to start a new instance.
		LPARAMETERS cWindowIdString
		#INCLUDE ..\Common\win32.h 
		  IF THIS.lSingleInstance
		    LOCAL nHWND, oWindow, cGlobalName
		    
		    THIS.LogCodePath(.T.,'CMAPP:ActivateExistingInstance')
		
		    #define GW_HWNDFIRST        0
		    #define GW_HWNDLAST         1
		    #define GW_HWNDNEXT         2
		    #define GW_HWNDPREV         3
		    #define GW_OWNER            4
		    #define GW_CHILD            5
		    DECLARE Integer FindWindow in Win32Api String, String
		    DECLARE Integer GetWindow in Win32Api Integer, Integer
		
		    * If we own the lock window already, this method has been called more than once.
		    IF NOT EMPTY(THIS.nLockWindow)
		      RETURN .T.
		    ENDIF
		
		    * Look for a desktop window with a title based on the application's
		    * system registry key root, or the ID string passed to us.
		    IF EMPTY(m.cWindowIdString)
		      m.cWindowIdString = 'CodeMine App ' + THIS.cSysRegRoot
		    ENDIF
		    m.nHWND = FindWindow(0, m.cWindowIdString)
		    m.nHWND = GetWindow(m.nHWND, GW_OWNER)
		
		    * If there is another instance, activate it and exit
		    IF m.nHWND > 0
		      IF SYS(2335) = '1'  && Only attempt activation of other instance if UI is enabled
		        DECLARE Integer IsIconic in Win32APi Integer
		        DECLARE Integer IsWindowVisible in Win32APi Integer
		        DECLARE BringWindowToTop in Win32APi Integer
		        DECLARE ShowWindow in Win32Api Integer, Integer
		
		        * If the parent of the lock window (main _SCREEN window of existing instance) is
		        * not visible, then we assume it is running with a VFP form as the "TopWindow"
		        * (usually SDI). In this case, there is no easy way to find the Top window that
		        * we should activate, so we can't do anything about it.
		        IF THIS.BeforeActivateExistingInstance() AND NOT EMPTY(IsWindowVisible(m.nHWND))
		          BringWindowToTop(m.nHWND)
		          IF NOT EMPTY(IsIconic(m.nHWND))
		            ShowWindow(m.nHWND, 1)
		          ENDIF
		        ENDIF
		      ENDIF
		      RETURN .T.   && We found an existing instance, and activated it if possible.
		    ENDIF
		
		    * No existing instance found. Create an invisible destop window to mark us as the first instance.
		    * Use native Windows function so this will work when we are in VFP server mode (no UI allowed).
		    DECLARE Integer CreateWindowEx IN Win32APi ;
		            Integer dwExStyle, String lpClassName, String lpWindowName, Integer dwStyle, ;
		            Integer x, Integer y, Integer nWidth, Integer nHeight, ;
		            Integer hWndParent, Integer hMenu, Integer hInstance, Integer lpParam 
		    THIS.nLockWindow = CreateWindowEx(0, 'STATIC', m.cWindowIdString, WS_CAPTION + WS_DISABLED, ;
		                       0, 0, 25, 25, _SCREEN.HWnd, 0, 0, 0)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE aftercreateglobalobjects		&& This event occurs after all Global Service Object have been created. It occurs in a compiled app and in the Interactive Development Environemnt.
		*++
		*>>This event occurs after all Global Service Object have been created. It occurs in a compiled app and in the Interactive Development Environemnt.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE aftercreateglobalobjectsfailure		&& This event occurs after an error prevented a necessary Global Service Object from starting.
		*++
		*>>This event occurs after an error prevented a necessary Global Service Object from starting.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterinit		&& Custom developer code, called just after application Init() event. Can be used to define class name aliases.
		*++
		*>>Custom developer code, called just after application Init() event. Can be used to define class name aliases.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterinstall		&& Custom developer code to run after the First-time Install Dialog completes successfully.
		*++
		*>>Custom developer code to run after the First-time Install Dialog completes successfully.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterreadevents		&& This event occurs after the READ EVENTS command returns. Not called when application is running under the Interactive Development Environemnt.
		*++
		*>>This event occurs after the READ EVENTS command returns. Not called when application is running under the Interactive Development Environemnt.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE aftershutdown		&& Called after application shutdown but before CLEAR EVENTS, return .T. to CLEAR EVENTS and exit.
		*++
		*>>Called after application shutdown but before CLEAR EVENTS, return .T. to CLEAR EVENTS and exit.
		* This event commonly used to offer user a chance to log back in under a different username.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeactivateexistinginstance		&& Custom developer code to run before re-activating an existing instance of the application (and closing this instance) on startup.
		*++
		*>>Custom developer code to run before re-activating an existing instance of the application (and closing this instance) on startup.
		*--
		  * Developers can use this method to display a message explaining why a new 
		  * instance will not be started. Note that no global service objects (including 
		  * message manager) will have been created when this event is called.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforecreateglobalobjects		&& This event occurs before any Global Service Object have been created. It occurs in a compiled app and in the Interactive Development Environemnt.
		*++
		*>>This event occurs before any Global Service Object have been created. It occurs in a compiled app and in the Interactive Development Environemnt.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeexit		&& Custom developer code. Called just before all Global service objects are released, when the applicaiton is exiting.  Not called when application is running under the Interactive Development Environemnt.
		*++
		*>>Custom developer code. Called just before all Global service objects are released, when the applicaiton is exiting.  Not called when application is running under the Interactive Development Environemnt.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforemenu		&& Called before System menu is displayed. Must return .T. for application to run.  Not called when application is running under the Interactive Development Environemnt.
		*++
		*>>Called before System menu is displayed. Must return .T. for application to run.  Not called when application is running under the Interactive Development Environemnt.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforereadevents		&& This event occurs before the application goes into its main event loop for the first time.  Not called when application is running under the Interactive Development Environemnt.
		*++
		*>>This event occurs before the application goes into its main event loop for the first time.  Not called when application is running under the Interactive Development Environemnt.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeshutdown		&& Called before application shutdown, must return .T. to allow shutdown.
		*++
		*>>Called before application shutdown, must return .T. to allow shutdown.
		*--
		  this.lShutDown = .T.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforestart		&& Custom developer code, called during application startup, after core VCX libraries are loaded, but before the installation check.
		*++
		*>>Custom developer code, called during application startup, after core VCX libraries are loaded, but before the installation check.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE cformbackground_assign		&& Apply background texture to all open forms when the property value is changed.
		LPARAMETERS cValue
		*++
		*>>Apply background texture to all open forms when the property value is changed.
		*--
		  LOCAL oForm
		  THIS.cFormBackground = m.cValue
		  FOR EACH oForm IN _SCREEN.Forms
		    IF PEMSTATUS(m.oForm, 'SetBackgroundTexture', 5)
		      m.oForm.SetBackgroundTexture()
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE checkversion		&& Verify that the app is running with the correct version of VFP and Codemine.fll
		*++
		*>>Verify that the app is running with the correct version of VFP and Codemine.fll
		*--
		
		THIS.LogCodePath(.T.,'CMAPP:CheckVersion')
		LOCAL nVersion
		  m.nVersion = VERSION(5)/100
		  IF NOT BETWEEN(m.nVersion, 7.0, 9.9)
		    MESSAGEBOX('This version of VFP is not supported by the CodeMine Framework. Please contact Soft Classics for an upgrade.', 16, 'Unsupported VFP version')
		    RETURN .F.
		  ENDIF
		
		  * Make sure the correct FLL file is loaded.
		  IF cmGetFLLVersion() < MIN_FLL_VERSION
		    LOCAL cFllPath, cPath
		    * Display full path to the fll file in the error message, to make it easier to track down version problems.
		    m.cFllPath = ''
		    m.cPath = LOWER(SET('LIBRARY'))
		    DO WHILE NOT EMPTY(m.cPath) AND NOT 'codemine.fll' $ m.cFllPath
		      m.cFllPath = GetToken(@m.cPath, ',')
		    ENDDO
		    MESSAGEBOX(PROPER(m.cFllPath) + ' is outdated. Copy current version to your \Windows\System or Application folder')
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE clearbanner		&& Remove the banner bitmap from the main application window.
		*++
		*>>Remove the banner bitmap from the main application window.
		*--
		
		THIS.LogCodePath(.T.,'CMAPP:ClearBanner')
		
		  IF PEMSTATUS(_SCREEN, 'imgCodemineBanner', 5)
		    _SCREEN.RemoveObject('imgCodemineBanner')
		  ENDIF
		
	ENDPROC

	PROCEDURE clearpreference		&& Delete a stored preference value from the Windows registry.
		LPARAMETERS cPrefName
		*++
		*>>Delete a stored preference value from the Windows registry.
		*--
		  RETURN cmRegDeleteValue((HKEY_CURRENT_USER), (m.cPrefName))
		
	ENDPROC

	PROCEDURE closeapptoolbars		&& Close and remove all application global toolbars at application shutdown. Called after the READ EVENTS command finishes.
		*++
		*>>Close and remove all application global toolbars at application shutdown. Called after the READ EVENTS command finishes.
		*--
		
		THIS.LogCodePath(.T.,'CMAPP:CloseAppToolbars')
		
		LOCAL cTool, cTools
		  m.cTools = THIS.cToolbars
		  DO WHILE NOT EMPTY(m.cTools)
		    m.cTool = GetToken(@m.cTools, ',')
		    IF NOT EMPTY(m.cTool)
		      THIS.oStateManager.RemoveToolbar(m.cTool)
		    ENDIF
		  ENDDO
		
	ENDPROC

	PROCEDURE closefoxtoolbars		&& Hide VFP development mode system toolbars.
		*++
		*>>Hide VFP development mode system toolbars.
		*--
		THIS.LogCodePath(.T.,'CMAPP:CloseFoxToolbars')
		
		  IF NOT THIS.lApplicationStarted
		    * If called from development env, only close the standard toolbar.
		    IF WVISIBLE('Standard')
		      HIDE WINDOW Standard
		      THIS.aFoxToolbars[1] = 'Standard'
		    ENDIF
		  ELSE
		    IF FILE(SYS(2005))
		      SELECT 0
		      USE (SYS(2005)) AGAIN SHARED
		      SCAN FOR TRIM(id) == 'TTOOLBAR'
		        IF WVISIBLE(name) AND NOT ' - ' $ WTITLE(name)
		          IF NOT EMPTY(THIS.aFoxToolbars[1])
		            DIMENSION THIS.aFoxToolbars[ALEN(THIS.aFoxToolbars) + 1]
		          ENDIF
		          THIS.aFoxToolbars[ALEN(THIS.aFoxToolbars)] = TRIM(name)
		          HIDE WINDOW (TRIM(name)) SAME
		        ENDIF
		      ENDSCAN
		      USE
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE closesplash		&& Remove the splash screen.
		LPARAMETERS lForce
		*++
		*>>Remove the splash screen.
		*--
		
		THIS.LogCodePath(.T.,'CMAPP:CloseSplash')
		
		  IF NOT ISNULL(THIS.oSplash)
		    IF PEMSTATUS(THIS.oSplash, 'nMaxTime', 5)
		      IF NOT m.lForce AND THIS.oSplash.nMaxTime > 0
		        RETURN .T. && Leave splash open if it is set to time-out.
		      ENDIF
		    ENDIF
		    RETURN THIS.oSplash.Release()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE createglobalobjects		&& Create Global Service Objects from list specified in the "%Local.Application.Global Objects" key.
		*++
		*>>Create Global Service Objects from list specified in the "%Local.Application.Global Objects" key.
		*
		* Called by EXE and Development Environment to create shared service objects
		*--
		LOCAL cObjectList
		  THIS.LogCodePath(.T.,'CMAPP:CreateGlobalObjects')
		  
		  IF NOT THIS.BeforeCreateGlobalObjects()
		    RETURN .F.
		  ENDIF
		
		  * Create the application registry object. When running under development env, this may
		  * find an existing instance of the app registry manager.
		  IF ISNULL(CreateGlobalObject('cmRegistry', '7.0', ;
		                      THIS.cPathShared + THIS.cMainDBC, THIS.cLocalRegistry, THIS.cSharedRegistry))
		    * If appreg creation fails, we cannot start the app.
		    RETURN .F.
		  ENDIF
		
		  * Create core global service objects shared by all forms.
		  CreateGlobalObject('cmStateManager')       && Create state manager first
		  CreateGlobalObject('cmStringTools')        && Create early, so it is released near last
		  CreateGlobalObject('cmMessage')            && Message manager
		
		  * Read local property for the list of optional global service objects to create.
		  m.cObjectList = THIS.appSettings.cGlobalObjectList
		  IF NOT ISNULL(m.cObjectList)
		    DO WHILE NOT EMPTY(m.cObjectList)
		      IF ISNULL(CreateGlobalObject(GetToken(@m.cObjectList, ',')))  && Displays message on error.
		        RETURN .F.
		      ENDIF
		    ENDDO
		  ENDIF
		
		  RETURN THIS.AfterCreateGlobalObjects()
		
	ENDPROC

	PROCEDURE createstates		&& Create definitions for custom states and actions used by the application.
		*++
		*>>Create definitions for custom states and actions used by the application.
		* Call on startup of Developer Environment and Full Application.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Destroy
		*++
		*>>Cleanup application after it is released, or if statup was aborted.
		*--
		THIS.LogCodePath(.T.,'CMAPP:Destroy')
		  THIS.CloseSplash(.T.)    && In case normal startup was aborted early
		  ON SHUTDOWN              && Must be cleared in order for VFP to exit
		
		  IF VERSION(2) != 0    && If running in developer copy of VFP
		    * Restore system toobars.
		    THIS.RestoreFoxToolbars()
		    SET SYSMENU TO DEFAULT
		    SET MESSAGE TO
		
		    IF THIS.lApplicationStarted   && If running a full app in a dev copy of VFP.
		      * Restore original main window title and bitmap.
		      _SCREEN.Caption = THIS.cFoxCaption
		      _SCREEN.Picture = THIS.cFoxFill
		      _SCREEN.Icon = ''
		
		      * Retore default autoyield setting.
		      _VFP.AutoYield = .T.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Fatal coding error - Pass it on to CodeMine error handler if available.
		*--
		  THIS.AddProperty('nLastError', m.nError)
		  DO CASE
		    CASE INLIST(m.nError, 1, 1726) AND LOWER(m.cMethod) == 'loadapilibrary'
		      * Display a more helpful message if FLL file cannot be located
		      MESSAGEBOX('CMAPP: The files "codemine.fll" and "msvcrt.dll" must be placed in the application directory, or in your Windows System directory', ;
		                 16, 'Error loading FLL file')
		
		    CASE m.nError = 1733 AND LOWER(SYS(2018)) == LOWER('appApplicationSettings')
		      MESSAGEBOX('Class "appApplicationSettings" is not found.' + CR_LF ;
		               + 'Select "Prepare Project for Build" from the CodeMine Menu and rebuild the APP/EXE', ;
		               16, _SCREEN.Caption)
		
		    CASE LOWER(m.cMethod) == 'restorefoxtoolbars'
		      RETURN .T.     && Ignore any errors trying to restore VFP toolbars in dev env.
		    
		    OTHERWISE
		      IF NOT DODEFAULT(@m.nError, @m.cMethod, m.nLine)
		        * For unhandled errors, make sure entire app exits by clearing the event loop
		        CLEAR EVENTS
		      ENDIF
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE get		&& Return information about the current application.
		LPARAMETERS cItem
		*++
		*>>Return information about the current application.
		*--
		  IF NOT EMPTY(m.cItem)
		    m.cItem = PROPER(m.cItem)
		    DO CASE
		      CASE m.cItem = 'Key'
		        RETURN THIS.cSysRegRoot
		      CASE m.cItem = 'Name'
		        RETURN THIS.cName
		      CASE m.cItem = 'Icon'
		        RETURN THIS.cIcon
		    ENDCASE
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getconnectionstring		&& Given a connection name, return the actual connection name or connection string to use at runtime.
		LPARAMETERS cConnection
		*++
		*>>Given a connection name, return the actual connection name or connection string to use at runtime.
		*--
		  RETURN m.cConnection
		
	ENDPROC

	PROCEDURE getfilepath		&& Given a filespec, return the full path name to use to find the file at runtime.
		LPARAMETERS cFile
		*++
		*>>Given a filespec, return the full path name to use to find the file at runtime.
		*--
		LOCAL ix, cExact, cPath
		  IF THIS.lApplicationStarted
		    * Strip off any path info in the original spec.
		    m.cFile = UPPER(SUBSTR(m.cFile, RAT('\', m.cFile) + 1))
		
		    * Look in filespec cache first to keep it fast.
		    m.cExact = SET('EXACT')
		    SET EXACT ON
		    m.ix = ASCAN(THIS.aPathCache, m.cFile)
		    IF m.cExact = 'OFF'
		      SET EXACT OFF
		    ENDIF
		
		    IF m.ix > 0
		      m.ix = ASUBSCRIPT(THIS.aPathCache, m.ix, 1)
		    ELSE
		      IF EMPTY(THIS.aPathCache[1])
		        m.ix = 1
		      ELSE
		        m.ix = ALEN(THIS.aPathCache, 1) + 1
		        DIMENSION THIS.aPathCache[m.ix, 2]
		      ENDIF
		      THIS.aPathCache[m.ix, 1] = m.cFile
		
		      * Look in the system registry for a path override for this file.
		      * The path returned here will be empty unless developer added installation code
		      * to assign a specific system registry key value for this file path.
		      m.cPath = ''
		      cmRegGetValue(HKEY_LOCAL_MACHINE, THIS.cSysRegRoot + '\Paths\' + m.cFile, @m.cPath)
		      THIS.aPathCache[m.ix, 2] = LOWER(m.cPath + m.cFile)
		    ENDIF
		    RETURN THIS.aPathCache[m.ix, 2]
		  ENDIF
		
		  * Application object not started, so disable path name processing
		  RETURN m.cFile
		
	ENDPROC

	PROCEDURE getpreference		&& Retreive a user preference in the Windows registry, using the specified key path.
		LPARAMETERS cPrefName, uValue
		*++
		*>>Retreive a user preference in the Windows registry, using the specified key path.
		*--
		LOCAL uKeyValue
		  m.uKeyValue = .NULL.
		  IF cmRegGetValue((HKEY_CURRENT_USER), (m.cPrefName), @m.uKeyValue)
		    * In WinNT, a 0 length (empty) string value will return .T., but no data will be returned.
		    * We detect this case here by testing for the variable still set to NULL.
		    m.uValue = IIF(ISNULL(m.uKeyValue), '', m.uKeyValue)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS cRootKey
		*++
		*>>Initialize application, load class libraries, and create global support objects.
		*--
		THIS.LogCodePath(.F.,'CMAPP:Init')
		  THIS.AddProperty('lApplicationStarted')     && set to .T. once the Start() method has been called
		  THIS.AddProperty('lNewInstall')             && Set when the app setup dialog is displayed on startup
		  THIS.AddProperty('aPathCache[1,2]')         && Array used to cache file paths for fast lookup
		  THIS.AddProperty('nOldWidth', 0)
		  THIS.AddProperty('nOldHeight', 0)
		  THIS.AddProperty('oSplash', .NULL.)
		  THIS.AddProperty('nLastError', 0)           && Error number of last error trapped
		  THIS.AddProperty('cParameter', '')          && Paramter value passed to Start() method
		  THIS.AddProperty('nLockWindow', 0)          && HWND of lock window used for single instance enforcement.
		
		  IF VERSION(2) != 0                          && Properties when run in a development copy of VFP
		    THIS.AddProperty('cFoxCaption', '')       && Original caption to restore on app exit
		    THIS.AddProperty('cFoxFill', '')          && Original Fill file (_screen.picture)
		    THIS.AddProperty('aFoxToolbars[1]')       && Array of VFP toolbars to restore on app exit
		  ENDIF
		
		  * Declare frequently used Windows API functions here, so every control doesnt need to
		  * do it in its own init()
		  DECLARE INTEGER GetSysColor IN user32.dll INTEGER nColorValue
		
		  THIS.InitSession()
		
		  THIS.lApplicationStarted = .F.
		  IF NOT EMPTY(m.cRootKey)
		    THIS.cSysRegRoot = m.cRootKey        && Save system registry root key
		  ENDIF
		    _SCREEN.Icon = THIS.cIcon            && Set main window icon and fill bitmap.
		  THIS.AfterInit()
		  RETURN .T.
		
	ENDPROC

	PROCEDURE initsession		&& Initialize various SET settings for the default data session, and also global session-independant settings.
		*++
		*>>Initialize various SET settings for the default data session, and also global session-independant settings.
		*--
		  * Settings for the default data session
		  SET TALK OFF
		  SET DELETED ON              && Deleted must be ON for correct operation.
		  SET MULTILOCKS ON
		
		  THIS.LogCodePath(.T.,'CMAPP:InitSession')
		   
		  * Global, session-independent settings
		  SET BELL OFF         && We do our own bell if/when necessary
		  SET COMPATIBLE OFF   && Make sure no DB4 settings alter default behavoir
		
		  * Global EXE-only settings
		  IF VERSION(2) = 0
		    * Turn off default status bar cursor messages in status bar. Only works in VFP8.0SP1 and later.
		    #IF VERSION(4) >= '08.00.0000.3117'
		      SET NOTIFY CURSOR OFF
		    #ENDIF
		
		    SET ESCAPE OFF       && No interuptions for finished EXE application
		  ENDIF
		
	ENDPROC

	PROCEDURE install		&& Called on startup to determine what setup or registration steps need to be done. Returning .F. will prevent applicatin from starting.
		LPARAMETERS lNeedInstall
		*++
		*>>Called on startup to determine what setup or registration steps need to be done. Returning .F. will prevent applicatin from starting.
		*--
		  * The lNeedInstall parameter can be used to force re-display of the install/setup dialog
		  m.lNeedInstall = m.lNeedInstall OR NOT THIS.IsRegistered()
		  IF NOT m.lNeedInstall
		    m.lNeedInstall = NOT THIS.IsDataPathValid()
		    IF ISNULL(m.lNeedInstall)
		      RETURN .F.
		    ENDIF
		  ENDIF
		
		  IF m.lNeedInstall    && Display the Install/Setup dialog
		    RETURN THIS.InstallDialog()
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE installdialog		&& Called on startup to Display the once-only registration and setup dialog when necessary.
		*++
		*>>Called on startup to Display the once-only registration and setup dialog when necessary.
		*--
		LOCAL oDialog
		
		  * Do Once-only setup & install.
		  m.oDialog = CreateNewObject('frmAppInstallDialog')
		  IF VARTYPE(m.oDialog) = 'O'
		    THIS.CloseSplash(.T.)
		
		    * Install dialog runs as an SDI form in the desktop, so it will work in both
		    * MDI and SDI style apps, regardless of whether the main VFP window is visible.
		    m.oDialog.Show()
		    IF m.oDialog.ShowWindow == 2
		      READ EVENTS  && Allow for subclassed dialog as TopLevelForm, for SDI apps.
		    ENDIF
		    IF NOT m.oDialog.ReturnValue()
		      RETURN .F.
		    ENDIF
		    THIS.lNewInstall = .T.
		    RETURN THIS.AfterInstall()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isdatapathvalid		&& Called on startup to verify stored data paths. Return .T. if the paths are valid, or .F. if one or more paths are invalid. Return .NULL. to Abort app startup.
		*++
		*>>Called on startup to verify stored data paths. Return .T. if the paths are valid, or .F. if one or more paths are invalid. Return .NULL. to Abort app startup.
		*--
		LOCAL cValue, cPaths
		  THIS.LogCodePath(.T.,'CMAPP:IsDataPathValid')
		  * Make sure files paths are still valid.
		  m.cPaths = 'Local,Shared,Common'
		  DO WHILE NOT EMPTY(m.cPaths)
		    m.cValue = ''
		    IF NOT cmRegGetValue(HKEY_LOCAL_MACHINE, THIS.cSysRegRoot + '\Paths\' + GetToken(@m.cPaths, ','), @m.cValue) ;
		    OR (NOT EMPTY(m.cValue) AND NOT DIRECTORY(m.cValue))
		      * The path is invalid. If user opts to cancel, return NULL. Otherwise return false.
		      RETURN IIF(THIS.PathNotFound(m.cValue), .F., .NULL.)
		    ENDIF
		  ENDDO
		  RETURN .T.
		
	ENDPROC

	PROCEDURE isenabled		&& Custom developer code to determine if form launch buttons or other items are available at any given time.
		LPARAMETERS cItem
		*++
		*>>Custom developer code to determine if form launch buttons or other items are available at any given time.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE isregistered		&& Called on startup to determine if the applciation has been registered with a valid serial number.
		*++
		*>>Called on startup to determine if the applciation has been registered with a valid serial number.
		*--
		LOCAL cValue
		
		  IF cmRegGetValue(HKEY_LOCAL_MACHINE, THIS.cSysregRoot + '\SerialNumber', @m.cValue)
		    * Make sure serial number is valid, so no funny business is allowed.
		    IF THIS.SerialHash(LEFT(m.cValue, 6)) == RIGHT(m.cValue,5)
		      RETURN .T.
		    ENDIF
		    MESSAGEBOX('Installation Serial Number is Invalid or Missing', 16, _SCREEN.Caption)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE lformbackgroundtile_assign
		LPARAMETERS lValue
		  THIS.lFormBackgroundTile = m.lValue
		
		  * Reset the form background also, to trigger its assign method.
		  THIS.cFormBackground = THIS.cFormBackground
		
	ENDPROC

	PROCEDURE loadapilibrary		&& Find and load the Codemine.fll API library.
		*++
		*>>Find and load the Codemine.fll API library.
		*--
		LOCAL cFllPath, cSysDir
		  IF NOT '\CODEMINE.FLL' $ SET('LIBRARY')
		    m.cFllPath = IIF('...' $ SYS(16, 1), SYS(16, 2), SYS(16,1))
		    m.cFllPath = LEFT(m.cFllPath, RAT('\', m.cFllPath)) + 'codemine.fll'
		    IF NOT FILE(m.cFllPath)
		      * Get Windows system path for API library.
		      DECLARE INTEGER GetSystemDirectory IN Kernel32.dll STRING cBuffer, INTEGER nLength
		      m.cSysDir = SPACE(128)
		      =GetSystemDirectory(@m.cSysDir, LEN(m.cSysDir))
		      m.cSysDir = LEFT(m.cSysDir, AT(CHR(0), m.cSysDir) - 1)
		      m.cFllPath = m.cSysDir + '\codemine.fll'
		    ENDIF
		
		    SET LIBRARY TO (m.cFllPath) ADDITIVE
		  ENDIF
		  RETURN '\CODEMINE.FLL' $ SET('LIBRARY')
		
	ENDPROC

	PROCEDURE loadcorelibraries		&& Load the core class libraries required for all client applications.
		*++
		*>>Load the core class libraries required for all client applications.
		*--
		LOCAL cList
		  * These should always be excluded from library lists built from the project file.
		  m.cList = THIS.cCoreClassLibraries
		  SET CLASSLIB TO &cList 
		  
		  ***** pws 1/6/09  removed additive from the above set classlib
		  *****             The only libraries loaded at this point were
		  *****             appmain and appforms so I added them to the
		  *****             ccoreclasslibraries property
		
	ENDPROC

	PROCEDURE loadlibraries		&& Load all the class libraries and Procedure libraries used by the app, from a dynamic list stored in the app registry tables.
		*++
		*>>Load all the class libraries and Procedure libraries used by the app, from a dynamic list stored in the app registry tables.
		*--
		LOCAL cProgList, cClassList
		
		  * Create a local instance of the object containing current library file lists.
		  THIS.NewObject('appSettings', 'appApplicationSettings', THIS.ClassLibrary)
		  IF NOT PEMSTATUS(THIS, 'appSettings', 5)
		    RETURN .F.   && Error message will have been displayed by error handler.
		  ENDIF
		
		  THIS.nLastError = 0
		
		  * Set class libraries.
		  m.cClassList = THIS.appSettings.LoadLongProperty('cClassLibraryList')
		  IF NOT EMPTY(m.cClassList)
		    m.cClassList = ["] + STRTRAN(m.cClassList, ',', '","') + ["]
		    TRY 
		       SET CLASSLIB TO &cClassList ADDITIVE
		    CATCH TO loerror 
		       MESSAGEBOX('Unable to load project class library list. ' + CHR(13) + ;
		                  loerror.message,16,'Load Libraries')
		    ENDTRY 
		  ENDIF
		
		  m.cProgList = THIS.appSettings.LoadLongProperty('cProcedureLibraryList')
		  IF NOT EMPTY(m.cProgList)
		    m.cProgList = ["] + STRTRAN(m.cProgList, ',', '","') + ["]
		    TRY 
		       SET PROCEDURE TO &cProgList ADDITIVE
		    CATCH
		    ENDTRY    
		  ENDIF
		  RETURN (THIS.nLastError == 0)   && Fail if something didn't load
		
	ENDPROC

	PROCEDURE omessage_access
		  IF ISNULL(THIS.oMessage)
		    THIS.oMessage = FindGlobalObject('cmMessage')
		  ENDIF
		  RETURN THIS.oMessage
		
	ENDPROC

	PROCEDURE openapptoolbars		&& Define and open all application global toolbars.
		*++
		*>>Define and open all application global toolbars.
		*--
		LOCAL cTool, cTools
		  m.cTools = THIS.cToolbars
		  DO WHILE NOT EMPTY(m.cTools)
		    m.cTool = GetToken(@m.cTools, ',')
		    IF NOT EMPTY(m.cTool)
		      THIS.oStateManager.AddToolbar(m.cTool, THIS.lToolbarMemory, .T.)
		    ENDIF
		  ENDDO
		
	ENDPROC

	PROCEDURE opensplash		&& Create and display the splash screen for the application.
		*++
		*>>Create and display the splash screen for the application.
		*--
		LOCAL oForm
		
		   THIS.LogCodePath(.T.,'CMAPP:OpenSplash')
		   
		  IF NOT EMPTY(THIS.cSplash)
		    IF '.scx' $ LOWER(THIS.cSplash)
		      DO FORM (THIS.cSplash) NAME m.oForm LINKED 
		    ELSE
		      m.oForm = CreateNewObject(THIS.cSplash)
		      m.oForm.Show(0)
		    ENDIF
		    m.oForm.Draw()
		    THIS.oSplash = m.oForm
		  ENDIF
		
	ENDPROC

	PROCEDURE oregistry_access
		  IF ISNULL(THIS.oRegistry)
		    THIS.oRegistry = FindGlobalObject('cmRegistry')
		  ENDIF
		  RETURN THIS.oRegistry
		
	ENDPROC

	PROCEDURE osecurity_access
		  IF ISNULL(THIS.oSecurity)
		    THIS.oSecurity = FindGlobalObject('cmSecurity')
		  ENDIF
		  RETURN THIS.oSecurity
		
	ENDPROC

	PROCEDURE ostatemanager_access
		  IF ISNULL(THIS.oStateManager)
		    THIS.oStateManager = FindGlobalObject('cmStateManager')
		  ENDIF
		  RETURN THIS.oStateManager
		
	ENDPROC

	PROCEDURE pathnotfound		&& Display a dialog when one of the file paths in the Windows registry is no longer valid.
		LPARAMETERS cPath
		*++
		*>>Display a dialog when one of the file paths in the Windows registry is no longer valid.
		* Return .T. to re-prompt user for file paths, or .F. to cancel application.
		*--
		LOCAL oDialog
		  m.oDialog = CreateNewObject('frmAppInstallConfirm', m.cPath)
		  IF NOT ISNULL(m.oDialog)
		    THIS.CloseSplash(.T.)
		    m.oDialog.Show()
		    IF m.oDialog.ShowWindow == 2
		      READ EVENTS  && Allow for subclassed dialog as TopLevelForm, for SDI apps.
		    ENDIF
		    RETURN m.oDialog.ReturnValue()
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE rebuildwindowpopup		&& Rebuild the active window list in the Window popup menu.
		*++
		*>>Rebuild the active window list in the Window popup menu.
		*--
		#define WINDOW_LIST_BASE 20       && Base bar number for window list
		LOCAL ix, nBar, cCommand
		
		  IF NOT EMPTY(THIS.cWindowPopup) AND THIS.lApplicationStarted
		    * Clear any existing window list from the popup - items after the last sepatarot.
		    FOR ix = CNTBAR(THIS.cWindowPopup) TO 1 STEP -1
		      m.nBar = GETBAR(THIS.cWindowPopup, m.ix)
		      IF m.nBar >= WINDOW_LIST_BASE
		        RELEASE BAR GETBAR(THIS.cWindowPopup, m.ix) OF (THIS.cWindowPopup)
		      ELSE
		        EXIT
		      ENDIF
		    ENDFOR
		
		    * Now add the current window list to the popup.
		    m.nBar = 0
		    FOR ix = 1 TO _SCREEN.FormCount
		      m.oForm = _SCREEN.Forms[m.ix]
		      IF m.oForm.BaseClass == 'Form' AND m.oForm.WindowType = 0
		        IF PEMSTATUS(m.oForm, 'lWindowMenu', 5)  && PEMSTATUS needs to be on its own line
		          IF m.oForm.lWindowMenu
		            IF m.nBar = 0
		              DEFINE BAR WINDOW_LIST_BASE OF (THIS.cWindowPopup) PROMPT '\-'
		            ENDIF
		            m.nBar = m.nBar + 1
		            DEFINE BAR (WINDOW_LIST_BASE + m.nBar) OF (THIS.cWindowPopup) ;
		              PROMPT IIF(m.nBar < 10, '\<'+ALLTRIM(STR(m.nBar))+' ', '  ') + m.oForm.Caption
		            m.cCommand = "ACTIVATE WINDOW '" + m.oForm.Name + "'"
		            ON SELECTION BAR (WINDOW_LIST_BASE + m.nBar) OF (THIS.cWindowPopup) &cCommand
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDFOR
		  ENDIF
		
	ENDPROC

	PROCEDURE refresh		&& Called on startup and main window resize to re-center the banner bitmap.
		*++
		*>>Called on startup and main window resize to re-center the banner bitmap.
		*--
		  IF PEMSTATUS(_SCREEN, 'imgCodemineBanner', 5)
		    WITH _SCREEN.imgCodemineBanner
		      .Top = INT((_SCREEN.Height - .Height) / 2.2)  && Position a little higher than centered
		      .Left = INT((_SCREEN.Width - .Width) / 2)
		      .Visible = .T.
		    ENDWITH
		  ENDIF
		
	ENDPROC

	PROCEDURE release
		*++
		*>>Cleanup application object and clear references to external objects.
		*--
		  IF VERSION(2) = 0    && If runtime EXE version
		    THIS.SaveSizeAndPosition()
		  ENDIF
		  THIS.LogCodePath(.T.,'CMAPP:Release')
		  THIS.oRegistry = .NULL.
		  THIS.oMessage = .NULL.
		  THIS.oSecurity = .NULL.
		  THIS.oStateManager = .NULL.
		
		  * Clear error handler
		  ON ERROR
		  RELEASE THIS
		
	ENDPROC

	PROCEDURE restorefoxtoolbars		&& Redisplay VFP development mode toolbars.
		*++
		*>>Redisplay VFP development mode toolbars.
		*--
		LOCAL ix
		
		  * Redisplay in the reverse order they were hidden.
		  FOR ix = ALEN(THIS.aFoxToolbars) TO 1 STEP -1
		    IF NOT EMPTY(THIS.aFoxToolbars[m.ix]) AND WEXIST(THIS.aFoxToolbars[m.ix])
		      SHOW WINDOW (THIS.aFoxToolbars[m.ix]) SAME
		    ENDIF
		  ENDFOR
		
		  DIMENSION THIS.aFoxToolbars[1]
		  THIS.aFoxToolbars = ''
		
	ENDPROC

	PROCEDURE restoresizeandposition		&& Restore last saved main window size and position on application startup.
		*++
		*>>Restore last saved main window size and position on application startup.
		*--
		LOCAL nValue, cPos
		  IF THIS.lMaximize
		    _SCREEN.WindowState = 2
		  ELSE
		    IF THIS.lRememberSizeAndPosition ;
		    AND THIS.GetPreference(THIS.cSysRegRoot + '\Position', @m.cPos) AND LEN(m.cPos) == 17
		      IF _SCREEN.MaxButton AND SUBSTR(m.cPos, 17, 1) == 'M'
		        _SCREEN.WindowState = 2
		      ELSE
		        _SCREEN.Height= VAL(SUBSTR(m.cPos, 9, 4))
		        _SCREEN.Width = VAL(SUBSTR(m.cPos, 13, 4))
		        _SCREEN.Top = MAX(0, VAL(SUBSTR(m.cPos, 1, 4)))
		        _SCREEN.Left = MAX(0, VAL(SUBSTR(m.cPos, 5, 4)))
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE savesizeandposition		&& Save main window size and position on application exit.
		*++
		*>>Save main window size and position on application exit.
		*--
		LOCAL cPos
		  SET SYSMENU OFF  && Need to save size without menu bar
		
		  IF THIS.lRememberSizeAndPosition AND _SCREEN.Top >= 0 AND _SCREEN.Left >=0
		    m.cPos = STR(_SCREEN.Top,4) + STR(_SCREEN.Left,4) + STR(_SCREEN.Height,4) + STR(_SCREEN.Width,4) ;
		           + IIF(_SCREEN.WindowState == 2, 'M', ' ')
		    THIS.SetPreference(THIS.cSysRegRoot  + '\Position', m.cPos)
		  ENDIF
		
	ENDPROC

	PROCEDURE serialhash		&& Provide a simple algorithm for validating serial numbers.
		LPARAMETERS cString
		*++
		*>>Provide a simple algorithm for validating serial numbers.
		* Given the first part of a serial number (characters and/or digits), it returns a
		* 5 digit string that should correspond to the last five digits of the serial number.
		*--
		  m.cString = LEFT(THIS.cSysRegRoot, RAT('\', THIS.cSysRegRoot)) ;
		            + STRTRAN(STRTRAN(m.cString, ' ', ''), '-', '')
		  RETURN PADL(SYS(2007, UPPER(m.cString) + LOWER(m.cString)), 5, '0')
		
	ENDPROC

	PROCEDURE setdevsearchpath		&& Set search path used for the CodeMine Development Environment for this app.
		*++
		*>>Set search path used for the CodeMine Development Environment for this app.
		* Default directory must be set to app root on entry.
		*
		* Putting this code in the app object makes it possible to set correct paths when running
		* an uncompiled application via the appmain.prg program, where the normal developer 
		* environment is not running. This method is never called if running a compiled APP or EXE.
		*--
		LOCAL cPath, cDefault
		
		  * Add Data, Source, and Reports folders to the path.
		  m.cDefault = SYS(5) + CURDIR()
		  m.cPath = m.cDefault + 'source\,' + m.cDefault + 'data\,'
		  IF DIRECTORY(m.cDefault + 'reports')
		    m.cPath = m.cPath + m.cDefault + 'reports\,'
		  ENDIF
		  IF DIRECTORY(m.cDefault + 'graphics')
		    m.cPath = m.cPath + m.cDefault + 'graphics\,'
		  ENDIF
		
		  * Add paths to CodeMine common library and support files.
		  IF NOT PEMSTATUS(_SCREEN, 'cCodemineCommonPath', 5)
		    ERROR 'CodeMine Development Environment is not installed. You can only run standalone EXE files on this machine.'
		    RETURN .F.
		  ENDIF
		  m.cPath = m.cPath ;
		          + _SCREEN.cCodemineCommonPath + ',' ;
		          + _SCREEN.cCodemineRootPath + 'Custom\,' ;
		          + _SCREEN.cCodemineRootPath + 'Graphics\,' ;
		          + _SCREEN.cCodemineRootPath + 'Data\'
		  IF NOT EMPTY(_SCREEN.cCodemineDeveloperPath)
		    m.cPath = m.cPath + ',' + _SCREEN.cCodemineDeveloperPath
		  ENDIF
		
		  SET PATH TO &cPath
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setpreference		&& Store a user preference in the Windows registry, using the specified key path under the HKEY_CURRENT_USER root.
		LPARAMETERS cPrefName, uValue
		*++
		*>>Store a user preference in the Windows registry, using the specified key path under the HKEY_CURRENT_USER root.
		*--
		  DO CASE
		    CASE VARTYPE(m.uValue) = 'X'     && Ignore NULL values - can't store them, but don't signal error.
		      RETURN .F.
		    CASE VARTYPE(m.uValue) = 'C'
		      RETURN cmRegSetString((HKEY_CURRENT_USER), (m.cPrefName), (m.uValue))
		    CASE VARTYPE(m.uValue) $ 'NIY'
		      RETURN cmRegSetInteger((HKEY_CURRENT_USER), (m.cPrefName), INT(m.uValue))
		    OTHERWISE
		      ERROR 'Unsupported data type for ' + m.cPrefname + ': ' + VARTYPE(m.uValue)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setsearchpath		&& Set default search path for data files from vaules set in system registry
		*++
		*>>Set default search path for data files from vaules set in system registry
		*--
		LOCAL cPath
		
		  IF cmRegGetValue(HKEY_LOCAL_MACHINE, THIS.cSysRegRoot + '\Paths\Local', @m.cPath)
		    THIS.cPathLocal = IIF(EMPTY(m.cPath), '', m.cPath)
		  ENDIF
		  IF cmRegGetValue(HKEY_LOCAL_MACHINE, THIS.cSysRegRoot + '\Paths\Shared', @m.cPath)
		    THIS.cPathShared = IIF(EMPTY(m.cPath), '', m.cPath)
		  ENDIF
		  IF cmRegGetValue(HKEY_LOCAL_MACHINE, THIS.cSysRegRoot + '\Paths\Common', @m.cPath)
		    THIS.cPathCommon = IIF(EMPTY(m.cPath), '', m.cPath)
		  ENDIF
		
		  * Now build the search path string from the retrieved values.
		  m.cPath = THIS.cPathLocal
		  IF NOT THIS.cPathLocal == THIS.cPathShared
		    m.cPath = m.cPath + ',' + THIS.cPathShared
		  ENDIF
		  IF NOT EMPTY(THIS.cPathCommon) ;
		  AND NOT THIS.cPathLocal == THIS.cPathCommon AND NOT THIS.cPathShared == THIS.cPathCommon
		    m.cPath = m.cPath + ',' + THIS.cPathCommon
		  ENDIF
		  SET PATH TO &cPath
		  RETURN .T.
		
	ENDPROC

	PROCEDURE settitle		&& Set the title (caption) of the main application window.
		LPARAMETERS cTitle
		*++
		*>>Set the title (caption) of the main application window.
		*--
		  IF PCOUNT() = 0
		    m.cTitle = THIS.oMessage.TranslateString('%txtApplicationName')
		    IF EMPTY(m.cTitle) OR LEFT(m.cTitle, 1) = '%'
		      RETURN .F.    && No title found to set.
		    ENDIF
		  ENDIF
		  _SCREEN.Caption = m.cTitle
		  RETURN .T.
		
	ENDPROC

	PROCEDURE showbanner		&& Center the banner bitmap in the main application window. Return .F. if there is no bitmap.
		*++
		*>>Center the banner bitmap in the main application window. Return .F. if there is no bitmap.
		*--
		  THIS.LogCodePath(.T.,'CMAPP:ShowBanner')
		  
		  IF NOT EMPTY(THIS.cBanner) AND (THIS.nOldWidth != _SCREEN.Width OR THIS.nOldHeight != _SCREEN.Height)
		    THIS.nOldWidth = _SCREEN.Width
		    THIS.nOldHeight = _SCREEN.Height
		    THIS.ClearBanner()
		
		    _SCREEN.AddObject('imgCodemineBanner','Image')
		    WITH _SCREEN.imgCodemineBanner
		      .Picture = THIS.cBanner   && Graphic name
		      .BackStyle = 0            && Transparent
		    ENDWITH
		    RETURN THIS.Refresh()
		  ENDIF
		  RETURN .F.   && No banner.
		
	ENDPROC

	PROCEDURE showmainwindow		&& Show the main VFP window, if not already visuble
		*++
		*>>Show the main VFP window, if not already visuble
		*--
		
		THIS.LogCodePath(.T.,'CMAPP:ShowMainWindow')
		
		  IF THIS.lShowMain
		    _SCREEN.Visible = .T.
		  ENDIF
		
	ENDPROC

	PROCEDURE showmenu		&& Put up the main application menu bar.
		*++
		*>>Put up the main application menu bar.
		*--
		
		THIS.LogCodePath(.T.,'CMAPP:ShowMenu')
		  IF NOT EMPTY(THIS.cMenu)
		    DO (THIS.cMenu)
		  ENDIF
		
	ENDPROC

	PROCEDURE shutdown		&& Shut down the application.
		LPARAMETERS lForced
		*++
		*>>Shut down the application.
		*--
		LOCAL oForm, cShutCmd
		  THIS.LogCodePath(.T.,'CMAPP:Shutdown')
		  * Ignore further shutdown requests until we finish.
		  m.cShutCmd = ON('Shutdown')
		  ON SHUTDOWN *
		
		  * Don't allow shutdown if any modal forms are open. Check all forms, because a "modeless" form opened
		  * from within a modal one is really modal, even though it appears modeless.
		  FOR EACH oForm IN _SCREEN.Forms
		    IF TYPE('m.oForm.WindowType') = 'N' AND m.oForm.WindowType = 1 AND m.oForm.Visible
		      IF NOT ISNULL(THIS.oMessage)
		        LOCAL cMsg, cName
		        IF TYPE('_SCREEN.Activeform.Baseclass') = 'C'
		          m.cName = _SCREEN.Activeform.Caption
		        ELSE
		          m.cName = WONTOP()
		        ENDIF
		        m.cMsg = THIS.oMessage.TranslateString('%txtNoShutdown')
		        m.cMsg = THIS.oMessage.Format(m.cMsg, m.cName)
		        THIS.oMessage.FlashMessage(m.cMsg)
		      ENDIF
		      ON SHUTDOWN &cShutCmd
		      RETURN .F.
		    ENDIF
		  ENDFOR
		
		  IF NOT ISNULL(THIS.oStateManager)
		    * Exit the event loop only if all forms close successfully.
		    IF NOT THIS.BeforeShutdown() OR NOT THIS.oStateManager.CloseAllForms() ;
		    OR (NOT m.lForced AND NOT THIS.AfterShutdown())
		       ON SHUTDOWN &cShutCmd
		       RETURN .F.
		    ENDIF
		  ENDIF
		
		  * Success, or State manager is gone - clear shutdown handler and end event loop.
		  ON SHUTDOWN
		  CLEAR EVENTS
		
	ENDPROC

	PROCEDURE start		&& Begin application execution.
		LPARAMETERS cParameter
		*++
		*>>Begin application execution.
		*--
		SET MESSAGE TO ''   && Hide VFP's workarea alias messages on the status bar
		THIS.LogCodePath(.T.,'CMAPP:Start')
		* Set exclusive off here, instead of in INitSession(), so Dev Environment won't be affected.
		SET EXCLUSIVE OFF
		
		_SCREEN.ICON = THIS.cIcon            && Set main window icon and fill bitmap.
		
		* Store the optional parameter where it can be easily accessed from any other event or method.
		THIS.cParameter = IIF(VARTYPE(m.cParameter) = 'C', ALLTRIM(m.cParameter), '')
		
		* Load API library and make sure the right version of everything is loaded.
		IF NOT THIS.LoadApiLibrary() OR NOT THIS.CheckVersion()
		   RETURN .F.
		ENDIF
		
		* If running as a standalone EXE, enforce the single-instance setting.
		IF VERSION(2) = 0
		   IF THIS.ActivateExistingInstance(THIS.cInstanceID)
		      RETURN .F.
		   ENDIF
		ELSE
		   THIS.CloseFoxToolbars()
		ENDIF
		
		* At this point, other methods can consider the application running.
		THIS.lApplicationStarted = .T.
		
		IF UPPER(THIS.cParameter) == 'UNINSTALL'
		   RETURN THIS.Uninstall()
		ENDIF
		
		* Establish last-chance error handler for objects with no error event
		ON ERROR m.goApp.ERROR(ERROR(), PROGRAM(), LINE())
		
		* Interim Shutdown handler in effect during install dialogs. This helps to
		* prevent application "hangs" after cancelling from app errors during initial startup.
		ON SHUTDOWN QUIT
		
		THIS.OpenSplash()                    && Put up optional splash screen.
		
		IF NOT EMPTY(THIS.cMenu)             && Disable system menu if we have our own.
		   SET SYSMENU OFF
		ENDIF
		
		IF VERSION(2) = 0                    && If standalone-EXE runtime version
		   THIS.RestoreSizeAndPosition()
		ELSE
		 *  THIS.CloseFoxToolbars()
		   THIS.cFoxCaption = _SCREEN.CAPTION
		   THIS.cFoxFill = _SCREEN.PICTURE
		ENDIF
		
		IF NOT EMPTY(THIS.cFillBitmap)
		   _SCREEN.PICTURE = THIS.cFillBitmap && Set main window background fill bitmap.
		ENDIF
		
		* Load core class libraries that are always necessary.
		THIS.LoadCoreLibraries()
		
		* Call custom user statup code.
		IF NOT THIS.BeforeStart()
		   RETURN .F.
		ENDIF
		
		* Install & register application if necessary
		IF NOT THIS.Install(UPPER(THIS.cParameter) == 'RESET')    && Make sure we are properly installed
		   RETURN .F.
		ENDIF
		
		* Set default data search path, unless developer ran appMain.prg directly
		IF VERSION(2) = 2 AND '.FXP' $ IIF('...' $ SYS(16, 1), SYS(16, 2), SYS(16,1))
		   THIS.SetDevSearchPath()
		ELSE
		   THIS.SetSearchPath()
		ENDIF
		
		* Load all VCX libraries used by the app. Must be done before global objects are created.
		IF NOT THIS.LoadLibraries()
		   RETURN .F.
		ENDIF
		
		* Close splash screen
		THIS.CloseSplash(.T.)
		
		IF NOT EMPTY(THIS.cBanner)
		   THIS.ShowBanner()
		ENDIF
		
		* Create Optional Global Service objects used by this application
		IF NOT THIS.CreateGlobalObjects()
		   THIS.AfterCreateGlobalObjectsFailure()
		   RETURN .F.
		ENDIF
		
		* Show translated title as soon as possible - requires global message manager object
		THIS.SetTitle()
		
		* Show the main VFP window, if not already visible
		THIS.ShowMainWindow()
		
		* Create custom application states and actions
		THIS.CreateStates()
		
		*  Setup for screen resizing
		THIS.oStateManager.RequestRefresh('Main Window Resize', THIS)
		
		* Establish Global Shutdown handler
		ON SHUTDOWN m.goApp.SHUTDOWN(.T.)
		
		* Disable windows event processing between commands. Makes ActiveX controls work more reliably.
		_VFP.AUTOYIELD = THIS.lAutoYield
		
		* Display main application menu and toolbars
		IF THIS.BeforeMenu() AND THIS.ShowMenu() AND THIS.OpenAppToolbars()
		   * Close splash screen
		   THIS.CloseSplash()
		   * Request refresh whenever the main window resizes so we can recenter the banner bitmap.
		
		
		   IF THIS.BeforeReadEvents()
		      * Request refresh whenever the main window resizes so we can recenter the banner bitmap.
		      IF NOT EMPTY(THIS.cBanner)
		         THIS.ShowBanner()
		         THIS.oStateManager.RequestRefresh('Main Window Resize', THIS)
		      ENDIF
		
		      * Enter primary event loop.
		      READ EVENTS
		      THIS.AfterReadEvents()
		   ENDIF
		
		   * Remove our shutdown handler
		   ON SHUTDOWN
		   THIS.ClearBanner()
		
		   * Remove system toolbars
		   THIS.CloseAppToolbars()
		ENDIF
		THIS.BeforeExit()
		
	ENDPROC

	PROCEDURE uninstall		&& Remove all system registry entries for this application in preperation for unisntall or reinstall.
		*++
		*>>Remove all system registry entries for this application in preperation for unisntall or reinstall.
		*--
		LOCAL cAppRoot
		
		  * Don't save position & size info on Release after we uninstall
		  THIS.lRememberSizeAndPosition = .F.
		
		  m.cAppRoot = THIS.cSysregRoot
		  IF MESSAGEBOX('Are you sure you want to remove the registration information for this application?', 36, _SCREEN.Caption) = 6
		    * Make sure root key path is in the correct format before proceeding with the delete.
		    IF UPPER(LEFT(m.cAppRoot, 9)) == 'SOFTWARE\'
		      cmRegDeleteKey(HKEY_LOCAL_MACHINE, m.cAppRoot)
		      cmRegDeleteKey(HKEY_CURRENT_USER, m.cAppRoot)
		    ENDIF
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmapplicationsettings AS custom 		&& CodeMine Application Settings and Library Lists.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: loadlongproperty		&& Join long Property strings that are stored across multiple property values.
		*m: storelongproperty		&& Store long Property strings across multiple property values, each with less than 250 characters.
		*p: cclasslibrarylist		&& Coma separated list of class libraries to load at application startup.
		*p: cdevelopertoolbarclass		&& Class name of the Development Environemnt toolbar to use for this application.
		*p: cglobalobjectlist		&& List of optional Global Service Objects to instantiate on application startup.
		*p: clocalizedlibrarylist		&& Coma separated list of Language-Localized class libraries to load at application startup.
		*p: cprocedurelibrarylist		&& Coma separated list of procedure libraries to load at application startup.
		*p: cproject		&& Name of the project file used to build this application.
		*p: lupdateclass		&& Set to .T. to rebuild Class Library List from project file automatically when project is built, or when Dev Env is started.
		*p: lupdatelocalized		&& Set to .T. to rebuild Localized Class Library List from project file automatically when project is built, or when Dev Env is started.
		*p: lupdateproc		&& Set to .T. to rebuild Procedure Library List from project file automatically when project is built, or when Dev Env is started.
	*</DefinedPropArrayMethod>

	cclasslibrarylist = 		&& Coma separated list of class libraries to load at application startup.
	cdevelopertoolbarclass = tbrDevelopmentToolbarCustom		&& Class name of the Development Environemnt toolbar to use for this application.
	cglobalobjectlist = 		&& List of optional Global Service Objects to instantiate on application startup.
	clocalizedlibrarylist = 		&& Coma separated list of Language-Localized class libraries to load at application startup.
	cprocedurelibrarylist = 		&& Coma separated list of procedure libraries to load at application startup.
	cproject = 		&& Name of the project file used to build this application.
	lupdateclass = .F.		&& Set to .T. to rebuild Class Library List from project file automatically when project is built, or when Dev Env is started.
	lupdatelocalized = .F.		&& Set to .T. to rebuild Localized Class Library List from project file automatically when project is built, or when Dev Env is started.
	lupdateproc = .F.		&& Set to .T. to rebuild Procedure Library List from project file automatically when project is built, or when Dev Env is started.
	Name = "cmapplicationsettings"
	
	PROCEDURE loadlongproperty		&& Join long Property strings that are stored across multiple property values.
		LPARAMETERS cProperty
		*++
		*>>Join long Property strings that are stored across multiple property values.
		*--
		LOCAL ix, cValue
		  m.cValue = EVALUATE('THIS.' + m.cProperty)
		  FOR ix = 0 TO 9
		    IF PEMSTATUS(THIS, m.cProperty + STR(m.ix, 1), 5)
		      m.cValue = m.cValue + EVALUATE('THIS.' + m.cProperty + STR(m.ix, 1))
		    ELSE
		      EXIT
		    ENDIF
		  ENDFOR
		  RETURN m.cValue
		
	ENDPROC

	PROCEDURE storelongproperty		&& Store long Property strings across multiple property values, each with less than 250 characters.
		LPARAMETERS cProperty, cValue
		*++
		*>>Store long Property strings across multiple property values, each with less than 250 characters.
		*
		* VFP can only store property values up to ~250 characters long in VCX class definitions.
		* So, we break up longer string values across multiple properties, based on the original
		* appended with a single digit of 0 through 9.
		*--
		LOCAL ix, nBreak, cValue
		
		  FOR ix = 0 TO 9     && Maximum of 10 extension properties
		    IF LEN(m.cValue) > 250
		      m.nBreak = RAT(',', LEFT(m.cValue, 250))
		      IF m.nBreak = 0
		        m.nBreak = 250
		      ENDIF
		    ELSE
		      m.nBreak = LEN(m.cValue)
		    ENDIF
		    THIS.AddProperty(m.cProperty + IIF(m.ix =0, '', CHR(ASC('0') + m.ix-1)), LEFT(m.cValue, m.nBreak))
		    m.cValue = SUBSTR(m.cValue, m.nBreak + 1)
		
		    * Exit after first pass through, once string is empty.
		    IF EMPTY(m.cValue)
		      EXIT
		    ENDIF
		  ENDFOR
		
	ENDPROC

ENDDEFINE
