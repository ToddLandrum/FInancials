*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="codemine.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cbocombobox AS combobox 		&& CodeMine foundation combobox class.
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*m: applysecurity		&& Evaluate security access for the control.
		*m: beforechange		&& Determine if it is OK to interactively change the control's value.
		*m: contextmenubuild		&& Define all the bars for a combobox context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: fieldvalid		&& Field level validation code goes here.
		*m: formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*m: getvalue		&& Return the control's current value
		*m: loadmemory		&& Load combobox value from stored memory.
		*m: loadtranslation		&& Translate bound data value into a format suitable for display.
		*m: loadvalue		&& Load combobox value property from cValuesource.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: setvalue		&& Set the combobox control's value
		*m: showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*m: storememory		&& Save current value in system registry for later use.
		*m: storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		*m: storevalue		&& Write combobox value back to data source using table or memvar syntax as appropriate.
		*m: undochanges		&& Undo changes to the current control, and restore original value.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpclasskey		&& List of class help keys for this class.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: clinkedlabel		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
		*p: creadprivilege		&& Privilege required to display data in this field.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cvaluesource		&& Data source bound to this control.
		*p: cviewparameter		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
		*p: cworkarea		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lallownull		&& Set True if null values can be entered into the control.
		*p: lautoremember		&& When true and lValueMemory is also true, most recently entered value is remembered.
		*p: lchanged		&& Set to true if data was changed interactively.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: lgridgetsarrows		&& When set to .T. and in a Codemine grdGrid based grid, up/down arrows navigate rows in the grid, not in the combo.
		*p: lnativebinding		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
		*p: lnoinitdata		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
		*p: lnullforempty		&& If set to .T., store .NULL. to bound data when value is EMPTY. Set to .NULL. to use BindingManager setting.
		*p: lreadlock		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
		*p: lreadonly		&& When true, Control value cannont be edited interactively.
		*p: lrequired		&& If true, a non-zero value must be entered before changes can be saved.
		*p: lvaluememory		&& When true, control's value can be remembered and restored under user control.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
		*p: nreadonlybackcolor		&& Background color used when the control is read-only. Defaults to parent container background color.
		*p: nvalidationmode		&& Determines when FieldValid() event is triggered for text editing controls. Settings: NULL=Use BindingManager Setting,0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	*</DefinedPropArrayMethod>

	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpclasskey = 		&& List of class help keys for this class.
	chelpkey = 		&& Name of context help message key for this field.
	clinkedlabel = 		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	creadonlydisplay = Dim		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
	creadprivilege = 		&& Privilege required to display data in this field.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cvaluesource = 		&& Data source bound to this control.
	cviewparameter = 		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
	cworkarea = 		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	Height = 22
	lallownull = .F.		&& Set True if null values can be entered into the control.
	lautoremember = .T.		&& When true and lValueMemory is also true, most recently entered value is remembered.
	lchanged = .F.		&& Set to true if data was changed interactively.
	lenabled = .T.		&& Specifies desired enable state for the control.
	lgridgetsarrows = .T.		&& When set to .T. and in a Codemine grdGrid based grid, up/down arrows navigate rows in the grid, not in the combo.
	lnativebinding = .F.		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
	lnoinitdata = .F.		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
	lnullforempty = .NULL.		&& If set to .T., store .NULL. to bound data when value is EMPTY. Set to .NULL. to use BindingManager setting.
	lreadlock = .F.		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
	lreadonly = .F.		&& When true, Control value cannont be edited interactively.
	lrequired = .F.		&& If true, a non-zero value must be entered before changes can be saved.
	lvaluememory = .F.		&& When true, control's value can be remembered and restored under user control.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "cbocombobox"
	nreadonlybackcolor = .NULL.		&& Background color used when the control is read-only. Defaults to parent container background color.
	nvalidationmode = .NULL.		&& Determines when FieldValid() event is triggered for text editing controls. Settings: NULL=Use BindingManager Setting,0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	Style = 2
	Width = 100
	
	PROCEDURE afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*++
		*>>Method called after the control value has been successfuly changed and valuesource is updated.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE applysecurity		&& Evaluate security access for the control.
		*++
		*>>Evaluate security access for the control.
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  IF NOT EMPTY(THIS.cReadprivilege) AND NOT ISNULL(THISFORM.oSecurity)
		    THIS.lReadLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cReadPrivilege)
		  ENDIF
		
		  * If its not readable, its not writable either.
		  IF THIS.lReadLock
		    THIS.lWriteLock = .T.
		  ELSE
		    IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		      THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE beforechange		&& Determine if it is OK to interactively change the control's value.
		*++
		*>>Determine if it is OK to interactively change the control's value.
		* Sets the lChanged flag for the control on success.
		*--
		  RETURN THISFORM.cmBindingManager.BeforeChange(THIS)
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define all the bars for a combobox context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a combobox context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.cmBindingManager.ContextMenuExecute(THIS, m.cOption)
		
	ENDPROC

	PROCEDURE DropDown
		  * Set flag so KeyPress() event knows when dropdown is open.
		  THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_POPPED)
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Combo Errors. Record rule (1583) applys here only if no buffering.
		*--
		LOCAL cMsg
		
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		  DO CASE
		    CASE INLIST(m.nError, 12, 13, 1734, 1925) AND NOT THIS.lNativeBinding AND '.controlsource' $ LOWER(m.cMethod)
		      * Ignore ControlSource Errors during Init.
		      RETURN .T.
		
		    CASE INLIST(m.nError, 1581,1582,1583) AND THIS.lNativeBinding
		      * DBC rule violated (1581,1582,1583) applies here only if lNativeBinding is set.
		      RETURN .T.
		
		    CASE m.nError = 1925 AND SYS(2018) == 'CMBINDINGMANAGER'
		      * Handle BindMan not found errors gracefuly. Usually this only will happen in a VCX based form
		      * with BindMan placed onthe form at design time, higher in the Z order than bound controls.
		      * Init method will fail in this case, and control will not be created.
		      MESSAGEBOX('No Binding Manager, or too high in Z order', 48, THIS.Name)
		      RETURN .T.
		  ENDCASE
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE fieldvalid		&& Field level validation code goes here.
		*++
		*>>Field level validation code goes here.
		* Success return: .T. or n != 0
		* Failure return: .F., 0
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*++
		*>>Form level control validation code goes here. Must return .T. before changes can be committed.
		* Success return: .T.
		* Failure return: .F.
		*--
		LOCAL lRequired
		  m.lRequired = THIS.lRequired
		  * If we are bound to a cursor field, and in a form with a data manager, evaluate the IsRequiredRule().
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		      m.lRequired = m.lRequired OR THISFORM.cmDataManager.IsRequired(THIS.cWorkarea, THIS.cValueSource)
		    ENDIF
		  ENDIF
		  IF m.lRequired AND EMPTY(NVL(THIS.GetValue(), ''))
		    THISFORM.DisplayMessage('%msgFieldRequired', THISFORM.NiceName(THIS))
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getvalue		&& Return the control's current value
		*++
		*>>Return the control's current value
		*--
		  RETURN THIS.Value
		
	ENDPROC

	PROCEDURE GotFocus
		  THISFORM.cmBindingManager.GotFocus(THIS)
		
		  * Set flag if we got focus due to a mouseclick. Used by Mousdown() event to prevent 
		  * premature open of popup in a grid, when clicking on a new cell.
		  IF THIS.Parent.BaseClass == 'Column' AND THIS.lGridGetsArrows AND MDOWN()
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_FIRST_CLICK)
		  ENDIF
		
		  * SelectOnEntry doesnt work well on its own, so we manually force it here.
		  IF THIS.SelectOnEntry
		    THIS.SelStart = 0
		    THIS.SelLength = LEN(TRIM(NVL(THIS.DisplayValue,'')))
		  ENDIF
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Foundation combobox control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  * Make sure binding manager is instantiated.
		  IF NOT PEMSTATUS(THISFORM, 'cmBindingManager', 5)
		    THISFORM.AddObject('cmBindingManager', 'cmBindingManagerCustom')
		  ENDIF
		
		  * Process common data-bound control binding initialization.
		  IF NOT THISFORM.cmBindingManager.InitBinding(THIS)
		    RETURN .F.    && This line will also execute if above "IF" generates error.
		  ENDIF
		
		  * Setup various layout properties when control is placed in a grid.
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_INGRID) AND THIS.Parent.Baseclass != 'Container'
		    THIS.SelectedBackColor = GetSysColor(COLOR_HIGHLIGHT)
		    THIS.SpecialEffect = 1   && Turn off 3d in a grid
		    THIS.BorderStyle = 0     && and no border
		    IF THIS.Style = 0
		      THIS.Margin = 0        && No margin if combo style
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		*++
		*>>Intercept all change attempts, enforce security, and secure locks as needed.
		* Return .T. if the change was accepted, .F. if it was rejected and original value restored.
		*--
		  * Test here only applies to the combo textbox for Style=0
		  IF THIS.Style = 0
		    IF NOT THIS.lChanged AND NOT THIS.BeforeChange()
		      * At this point, value has already changed, so 
		      * if changes are not allowed, we must restore original value.
		      THIS.UndoChanges()
		      RETURN .F.
		    ENDIF
		  ELSE
		    * Set flag so valid() code only triggers BindMan when data actually is changed.
		    THIS.lChanged = .T.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Key processing for combo boxes.
		*--
		  DO CASE
		    CASE m.nKeyCode = 27
		      THIS.UndoChanges()             && Escape resets data, so clear change flag to prevent validation
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_POPPED)
		
		    CASE INLIST(m.nKeycode, 5, 24) AND THIS.Parent.Baseclass = 'Column'   && Up = 5, Dn = 24
		      IF PEMSTATUS(THIS.Parent.Parent, 'AutoAppend', 5)       && If this is a CodeMine grid
		        IF THIS.Style = 0   && Combo
		          * Add a new record to grid on downarrow , if at the end.
		          IF m.nKeyCode = 24 AND NOT EMPTY(THIS.Valid()) AND THIS.Parent.Parent.AutoAppend()
		            NODEFAULT
		          ENDIF
		        ELSE                && Dropdown List
		          * Have the up/dn arrows navigate in the grid per lGridGetsArrows if Popup List style.
		          IF THIS.lGridGetsArrows AND NOT EMPTY(THIS.Parent.Parent.cWorkarea) ;
		          AND NOT BITTEST(THIS.nControlFlags, CTLFLAG_POPPED)
		            * Add a new record to grid on downarrow, if at the end. Otherwise navigate rows.
		            IF NOT (m.nKeyCode = 24 AND THIS.Parent.Parent.AutoAppend())
		              THISFORM.cmDataManager.Skip(IIF(m.nKeyCode = 5, -1, 1), THIS.Parent.Parent.cWorkarea)
		            ENDIF
		            NODEFAULT
		          ENDIF
		        ENDIF
		      ENDIF
		
		    CASE NOT THIS.lChanged AND m.nShiftAltCtrl <= 1 AND m.nKeyCode > 0 AND (m.nKeyCode % 128 >= ASC(' ') OR m.nKeyCode = 7)
		      * For data characters, check if changes are allowed before accepting the character.
		      IF THIS.Style = 0 AND NOT THIS.BeforeChange()   && Only applies to combo style (with embedded textbox)
		        NODEFAULT
		      ENDIF
		
		    CASE m.nShiftAltCtrl = 0 AND m.nKeyCode = 22 && Insert mode toggle
		      =INSMODE(NOT INSMODE())
		      NODEFAULT
		
		    CASE m.nKeyCode = ASC('0') AND m.nShiftAltCtrl = 2
		      NODEFAULT
		      IF THIS.lAllowNull
		        IF THIS.BeforeChange()
		          THIS.SetValue(.NULL.)
		        ENDIF
		      ELSE
		        ??CHR(7)   && Ignore ctrl+0 keystrokes (prevent entering a .NULL. via keyboard).
		      ENDIF
		  ENDCASE
		
	ENDPROC

	PROCEDURE loadmemory		&& Load combobox value from stored memory.
		*++
		*>>Load combobox value from stored memory.
		* Return .T. if there was a value stored in memory.
		*--
		  RETURN THISFORM.cmBindingManager.LoadMemory(THIS)
		
	ENDPROC

	PROCEDURE loadtranslation		&& Translate bound data value into a format suitable for display.
		LPARAMETERS uValue
		*++
		*>>Translate bound data value into a format suitable for display.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE loadvalue		&& Load combobox value property from cValuesource.
		*++
		*>>Load combobox value property from cValuesource.
		*--
		  LOCAL uValue
		  IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)
		    THIS.Value = m.uValue
		    IF THIS.Style = 0
		      THIS.DisplayValue = THIS.Value
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE LostFocus
		* Clear the default VFP workarea alias text from the status bar
		  IF VERSION(2) = 0
		    TRY 
		       SET MESSAGE TO ''
		       IF m.goApp.lCloudServer
		          _VFP.StatusBar = 'Company Name: ' + proper(m.goapp.cCompanyName) + ' Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ELSE
		          _VFP.StatusBar = 'Data Path: ' + LOWER(m.goapp.cdatafilepath) + ' Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ENDIF    
		    CATCH
		    ENDTRY    
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Ignore Left-clicks if control is read-only. This prevents the list
		* contents from poping up.
		*--
		  IF m.nButton = 1 AND THIS.lWriteLock
		    NODEFAULT
		  ELSE
		    * Suppress dropdown popup on initial click when in a grid.
		    IF BITTEST(THIS.nControlFlags, CTLFLAG_FIRST_CLICK)
		      NODEFAULT
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		  * Clear flag for select-all-on-entry behavior
		  IF THIS.Style = 0 AND THIS.SelLength > 0
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Custom May be able to dispose of this code in later versions of VFP, if they fix the problem.
		*--
		  * Suppress dropdown popup on initial click when in a grid.
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_FIRST_CLICK)
		    NODEFAULT
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_FIRST_CLICK)
		  ENDIF
		
		  * Special workaround for VFP5.0 quirks. If a control Valid fails when the user clicks on another form
		  * the user cannot re-activate the original window by clicking on the control that failed validation.
		  * We detect this case here and re-activate the window.
		  IF THIS.lChanged
		    IF THISFORM.BaseClass == 'Form' AND NOT BITTEST(THISFORM.nControlFlags, FRMFLAG_ACTIVE)
		      ACTIVATE WINDOW (THISFORM.Name)
		    ENDIF
		  ENDIF
		
		  * Implement SelectOnEntry that will work in grids, and on entry by mouse-click.
		  IF THIS.Style = 0 AND THIS.SelLength = 0 AND BITTEST(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		    THIS.SelStart = 0
		    THIS.SelLength = LEN(TRIM(THIS.Text))
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		
	ENDPROC

	PROCEDURE Refresh
		*++
		* Reinitialize display buffers from combo's data source.
		*--
		  DODEFAULT()   && Do default combo/list refresh first, in case rowsource has changed.
		
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    THISFORM.cmBindingManager.InitBinding(THIS)
		  ENDIF
		
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_VALUE_LOADED) ;
		  OR BITTEST(THISFORM.nControlFlags, FRMFLAG_FORCE_RELOAD)
		    THIS.ShowControl()
		    THIS.LoadValue()
		    IF THIS.lValueMemory
		      THISFORM.cmBindingManager.DefaultFromMemory(THIS)
		    ENDIF
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		
	ENDPROC

	PROCEDURE RightClick
		*++
		* Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    * Use the binding manager to put up common control context menus. This will make a callback
		    * to owr own ContextMenuBuild() method to control-specific items.
		    IF THISFORM.ContextMenuInit(THIS) AND THISFORM.cmBindingManager.ContextMenuBuild(THIS)
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty   && lReadonly and ReadOnly
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    CASE m.cProperty = 'value'
		      RETURN THIS.SetValue(@m.uValue)
		
		    CASE INLIST(m.cProperty, 'cvaluesource', 'controlsource')
		      THIS.cWorkarea = ''
		      THIS.cValueSource = m.uValue
		      THISFORM.cmBindingManager.LoadWorkarea(THIS)
		
		      IF THIS.lNativeBinding
		        IF NOT THIS.Parent.Baseclass == 'Column' OR NOT THIS.Parent.Bound
		          THIS.ControlSource = m.uValue
		        ENDIF
		      ENDIF
		      THIS.Refresh()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setvalue		&& Set the combobox control's value
		LPARAMETERS cNewValue
		*++
		*>>Set the combobox control's value
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		  RETURN THISFORM.cmBindingManager.SetValue(THIS, m.cNewValue)
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*++
		*>>Re-evaluate security access, and update control display to reflect current state.
		* Called by Init and refresh methods. Checking security is a little slow, so it is optional.
		*--
		LOCAL lOldWriteLock
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  m.lOldWriteLock = THIS.lWriteLock
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * Check for no data or Write-Protect (explicit edit mode).
		  IF NOT THIS.lWriteLock AND NOT EMPTY(THIS.cValueSource) ;
		  AND (NOT EMPTY(THIS.cWorkarea) OR NOT THISFORM.lIgnoreBoundProperties)
		    IF EMPTY(THIS.cWorkarea)
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed()  && Only pass workarea parameter if non-empty
		    ELSE
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea, SUBSTR(THIS.cValueSource, RAT('.', THIS.cValueSource) + 1))
		    ENDIF
		  ENDIF
		
		  * Apply or remove readonly display effect if read-only condition changed.
		  IF m.lOldWriteLock != THIS.lWriteLock
		    IF 'DIM' $ THIS.cReadOnlyDisplay
		      IF THIS.lWriteLock
		        IF ISNULL(THIS.nBackColor)
		          THIS.nBackColor = THIS.BackColor
		        ENDIF
		        IF ISNULL(THIS.nReadOnlyBackColor)
		          THIS.nReadOnlyBackColor = THIS.Parent.BackColor
		        ENDIF
		        THIS.BackColor = THIS.nReadOnlyBackColor
		      ELSE
		        IF NOT ISNULL(THIS.nBackColor)
		          THIS.BackColor = THIS.nBackColor
		        ENDIF
		      ENDIF
		    ENDIF
		    THIS.MousePointer = IIF(THIS.lWriteLock, 1, 0)  && Change cursor to arrow while read-only.
		  ENDIF
		
		  * Control is Disabled if readonly (optionaly), or if datasource is EOF().
		  IF THIS.lWriteLock AND 'DISABLE' $ THIS.cReadOnlyDisplay
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
		  * Update linked label control, if any.
		  IF NOT EMPTY(THIS.cLinkedLabel)
		    LOCAL oLabel
		    m.oLabel = EVALUATE('THIS.Parent.' + THIS.cLinkedLabel)
		    m.oLabel.Visible = THIS.Visible
		    m.oLabel.Refresh()
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the combobox.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT   && Don't process native help if using Codemine context help
		
		      * Customize class help keys for optional features in this instance of the control.
		      IF NOT EMPTY(THIS.cHelpClassKey)  && If no class help, leave it empty
		        THIS.cHelpClassKey = LOWER(THIS.cHelpClassKey)
		        IF THIS.lValueMemory AND NOT '%hlpvaluememory' $ THIS.cHelpClassKey
		          THIS.cHelpClassKey = THIS.cHelpClassKey + ',%hlpvaluememory'
		        ENDIF
		      ENDIF
		      THISFORM.DisplayHelp(THIS)    && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE storememory		&& Save current value in system registry for later use.
		*++
		*>>Save current value in system registry for later use.
		*--
		  RETURN THISFORM.cmBindingManager.StoreMemory(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		LPARAMETERS uValue
		*++
		*>>Translate control value into a format suitable for storage in bound data source.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE storevalue		&& Write combobox value back to data source using table or memvar syntax as appropriate.
		*++
		*>>Write combobox value back to data source using table or memvar syntax as appropriate.
		*--
		  RETURN THISFORM.cmBindingManager.StoreValue(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  * Pages in Forms instaniated from a VCX trigger UIenable events for the initial active
		  * page, before the form is visible. We ignore these events, as they can mess up lNoInitData.
		  IF m.lEnableEvent AND THISFORM.Visible
		    IF PEMSTATUS(THIS, 'nControlFlags', 5)
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		      THIS.Refresh()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE undochanges		&& Undo changes to the current control, and restore original value.
		*++
		*>>Undo changes to the current control, and restore original value.
		*--
		  IF EMPTY(THIS.cValueSource)
		    THIS.Value = THIS.uOriginalValue
		  ELSE
		    THIS.LoadValue()
		  ENDIF
		  THIS.lChanged = .F.
		
	ENDPROC

	PROCEDURE Valid
		*++
		*>>If combobox value has changed, call the FieldValid() event, and store value to datasource on success.
		*--
		LOCAL lStatus
		
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_POPPED)
		  IF (THIS.Style = 2 AND THIS.lChanged) ;
		  OR (THIS.Style = 0 AND THISFORM.cmBindingManager.ValidNeeded(THIS))
		    * For combobox style, allow items not in the list to be entered. If only items in the
		    * rowsource are allowed, dropdownList style (2) should be used instead.
		    IF THIS.Style = 0
		      STORE THIS.DisplayValue TO THIS.Value, THIS.DisplayValue
		    ENDIF
		
		    * Call binding manager for the remaining common control valid() processing.
		    m.lStatus = THISFORM.cmBindingManager.Valid(THIS)
		    IF EMPTY(m.lStatus) AND THIS.Style = 2 && Validation failure with discrete values
		      THIS.UndoChanges()
		    ENDIF
		    RETURN m.lStatus
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE When
		*++
		* Determine when the combobox is allowed to receive focus.
		*--
		  IF TYPE('THISFORM') = 'O'
		    RETURN THISFORM.cmBindingManager.When(THIS)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS chkbusybutton AS checkbox 		&& Graphical Command Button that stays down while Click is executing.
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\button.bmp" ClassIcon="..\graphics\button.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: applysecurity		&& Evaluate security access for the control.
		*m: contextmenubuild		&& Define all the bars for a button context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: set		&& Set various BusyButton control properties. Parameters are property name and value to set.
		*m: showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Hide,Disable
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
		*p: lreadonly		&& When true the control's value cannont be edited interactively.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
	*</DefinedPropArrayMethod>

	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpkey = 		&& Name of context help message key for this field.
	creadonlydisplay = Disable		&& Controls how read-only fields are handled. Options: Hide,Disable
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	fontbold = .F.
	fontsize = 8
	height = 23
	lenabled = .T.		&& Specifies desired enable state for the control.
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	lreadonly = .F.		&& When true the control's value cannont be edited interactively.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "chkbusybutton"
	style = 1
	width = 75
	
	PROCEDURE applysecurity		&& Evaluate security access for the control.
		*++
		*>>Evaluate security access for the control.
		* Responsible for setting THIS.lWriteLock
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		    THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		  ENDIF
		
	ENDPROC

	PROCEDURE click
		* Retore focus to last active data control, if this button is in a form.
		  IF THISFORM.Baseclass == 'Form' 
		    THISFORM.ActivateNextControl()
		  ENDIF
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define all the bars for a button context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a button context menu. Return false if no bars are defined.
		*--
		  * Busy buttons only have help if a help key is specified - no class help support.
		  IF NOT EMPTY(THIS.cHelpKey)
		    THISFORM.ContextMenuBar(CTX_BAR_CTL_HELP, '%barHelp')
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%barhelp'
		      THIS.ShowWhatsThis(THIS.WhatsThisHelpID)
		    OTHERWISE
		      RETURN THISFORM.ContextMenuExecute(m.cOption)
		  ENDCASE
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		LOCAL cMsg
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE init
		*++
		* Codemine chkBusyButton control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('nRight', .NULL.)               && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)              && Offset of bottom edge from bottom of parent container.
		  THIS.AddProperty('nControlFlags', 0)             && Internal flags used to set and determine the state of this control.
		
		  ASSERT EMPTY(THIS.ControlSource) MESSAGE 'chkBusyButton class does not support data binding'
		
		  * If either enabled flag is false, disable the field.
		  THIS.lEnabled = THIS.Enabled AND THIS.lEnabled
		  THIS.cReadOnlyDisplay = UPPER(THIS.cReadOnlyDisplay)
		
		  * Set value to False, so button is up. Clickng on it pushes it down, while the
		  * click method executes. Then the Valid method puts the button back up to indicate completion.
		  THIS.Value = .F.
		
		  * Localize the caption if localization is enabled
		  IF THIS.lLocalizeCaption AND NOT ISNULL(THISFORM.oMessage)
		    THIS.Caption = THISFORM.oMessage.Localize(THIS.Caption, .T.)
		  ENDIF
		
		  * Apply initial security and display state.
		  THIS.ShowControl()
		
	ENDPROC

	PROCEDURE refresh
		*++
		*>> Refresh control states.
		*--
		  THIS.ShowControl()
		
	ENDPROC

	PROCEDURE rightclick
		*++
		*>>Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various BusyButton control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various BusyButton control properties. Parameters are property name and value to set.
		*--
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty   && lReadonly and ReadOnly
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*++
		*>>Re-evaluate security access, and update control display to reflect current state.
		* Called by Init and refresh methods. Checking security is a little slow, so it is optional.
		*--
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * For buttons, ReadonlyDisplay options are Hide or Disable.
		  IF 'HIDE' $ THIS.cReadOnlyDisplay
		    THIS.Visible = NOT THIS.lWriteLock
		  ENDIF
		  IF THIS.lWriteLock
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
	ENDPROC

	PROCEDURE showwhatsthis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the busybutton.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                   && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS)  && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE uienable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  IF m.lEnableEvent AND THISFORM.Visible
		    THIS.Refresh()    && Buttons call refresh method directly on UIEnable
		  ENDIF
		
	ENDPROC

	PROCEDURE valid
		  *>> Executes after click method is finished. Put the button back up.
		  THIS.Value = .F.
		
	ENDPROC

	PROCEDURE when
		*++
		* Default When method prevents off-screen objects from getting focus.
		*--
		LOCAL lStatus
		  IF TYPE('THISFORM') = 'O'
		    IF PEMSTATUS(THISFORM, 'InitializeHelp', 5)
		      THISFORM.InitializeHelp(THIS)
		    ENDIF
		
		    IF PEMSTATUS(THISFORM, 'ScrollBars', 5)
		      m.lStatus = THISFORM.ScrollBars != 0
		    ENDIF
		    IF NOT m.lStatus
		      m.lStatus = THISFORM.ScaleMode != 3 ;
		                OR (OBJTOCLIENT(THIS, 1) < THISFORM.Height AND OBJTOCLIENT(THIS, 2) < THISFORM.Width)
		    ENDIF
		
		    IF m.lStatus
		      * Remember the control that had focus so we can return to it after.
		      IF THISFORM.Baseclass == 'Form' AND TYPE('THISFORM.ActiveControl.Baseclass') = 'C' ;
		      AND NOT THISFORM.ActiveControl.Baseclass $ 'Commandbutton,Checkbox,Pageframe'
		        IF PEMSTATUS(THISFORM, 'SetLastControl', 5)
		          THISFORM.SetLastControl(THISFORM.activecontrol)
		        ENDIF
		      ENDIF
		      RETURN .T.
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS chkcheckbox AS checkbox 		&& CodeMine checkbox class.
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*m: applysecurity		&& Evaluate security access for the control.
		*m: beforechange		&& Determine if it is OK to interactively change the control's value.
		*m: contextmenubuild		&& Define the checkbox-specific context menu bars. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: fieldvalid		&& Field level validation code goes here.
		*m: formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*m: getvalue		&& Return the control's current value
		*m: loadmemory		&& Load checkbox value from stored memory.
		*m: loadtranslation		&& Translate bound data value into a format suitable for display.
		*m: loadvalue		&& Load checkbox value property from cValuesource.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: setvalue		&& Set the checkbox control's value
		*m: showcontrol		&& Re-evaluate checkbox security access, and update control display to reflect current state.
		*m: storememory		&& Save current value in system registry for later use.
		*m: storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		*m: storevalue		&& Write checkbox value back to data source using table or memvar syntax as appropriate.
		*m: undochanges		&& Undo changes to the current control, and restore original value.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpclasskey		&& List of class help keys for this class.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Disable,Normal,Hide,Nofocus
		*p: creadprivilege		&& Privilege required to display data in this field.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cvaluesource		&& Data source bound to this control.
		*p: cviewparameter		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
		*p: cworkarea		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lallownull		&& Set True if null values can be entered into the control.
		*p: lautoremember		&& When true and lValueMemory is also true, most recently entered value is remembered.
		*p: lchanged		&& Set to true if data was changed interactively.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
		*p: lnativebinding		&& Set true to use native data binding. This is required for use in a grid with Sparse set to .F.
		*p: lnoinitdata		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
		*p: lreadlock		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
		*p: lreadonly		&& When true, Control value cannont be edited interactively.
		*p: lrequired		&& If True a value must be entered before changes can be saved.
		*p: lvaluememory		&& When true, control's value can be remembered and restored under user control.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
	*</DefinedPropArrayMethod>

	backstyle = 0
	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpclasskey = 		&& List of class help keys for this class.
	chelpkey = 		&& Name of context help message key for this field.
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	creadonlydisplay = Normal		&& Controls how read-only fields are handled. Options: Disable,Normal,Hide,Nofocus
	creadprivilege = 		&& Privilege required to display data in this field.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cvaluesource = 		&& Data source bound to this control.
	cviewparameter = 		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
	cworkarea = 		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	height = 18
	lallownull = .F.		&& Set True if null values can be entered into the control.
	lautoremember = .T.		&& When true and lValueMemory is also true, most recently entered value is remembered.
	lchanged = .F.		&& Set to true if data was changed interactively.
	lenabled = .T.		&& Specifies desired enable state for the control.
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	lnativebinding = .F.		&& Set true to use native data binding. This is required for use in a grid with Sparse set to .F.
	lnoinitdata = .F.		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
	lreadlock = .F.		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
	lreadonly = .F.		&& When true, Control value cannont be edited interactively.
	lrequired = .F.		&& If True a value must be entered before changes can be saved.
	lvaluememory = .F.		&& When true, control's value can be remembered and restored under user control.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "chkcheckbox"
	width = 100
	
	PROCEDURE afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*++
		*>>Method called after the control value has been successfuly changed and valuesource is updated.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE applysecurity		&& Evaluate security access for the control.
		*++
		*>>Evaluate security access for the control.
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  IF NOT EMPTY(THIS.cReadprivilege) AND NOT ISNULL(THISFORM.oSecurity)
		    THIS.lReadLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cReadPrivilege)
		  ENDIF
		
		  * If its not readable, its not writable either.
		  IF THIS.lReadLock
		    THIS.lWriteLock = .T.
		  ELSE
		    IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		      THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE beforechange		&& Determine if it is OK to interactively change the control's value.
		*++
		*>>Determine if it is OK to interactively change the control's value.
		* Sets the lChanged flag for the control on success.
		*--
		  RETURN THISFORM.cmBindingManager.BeforeChange(THIS)
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define the checkbox-specific context menu bars. Return false if no bars are defined.
		*++
		*>>Define the checkbox-specific context menu bars. Return false if no bars are defined.
		*--
		  RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.cmBindingManager.ContextMenuExecute(THIS, m.cOption)
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Checkbox Errors. Record rule (1583) applys here only if no buffering.
		*--
		LOCAL cMsg
		
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		  DO CASE
		    CASE INLIST(m.nError, 12, 13, 1734, 1925) AND NOT THIS.lNativeBinding AND '.controlsource' $ LOWER(m.cMethod)
		      * Ignore ControlSource Errors during Init.
		      RETURN .T.
		
		    CASE INLIST(m.nError, 1581,1582,1583) AND THIS.lNativeBinding
		      * DBC rule violated (1581,1582,1583) applies here only if lNativeBinding is set.
		      RETURN .T.
		
		    CASE m.nError = 1925 AND SYS(2018) == 'CMBINDINGMANAGER'
		      * Handle BindMan not found errors gracefuly. Usually this only will happen in a VCX based form
		      * with BindMan placed onthe form at design time, higher in the Z order than bound controls.
		      * Init method will fail in this case, and control will not be created.
		      MESSAGEBOX('No Binding Manager, or too high in Z order', 48, THIS.Name)
		      RETURN .T.
		  ENDCASE
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE fieldvalid		&& Field level validation code goes here.
		*++
		*>>Field level validation code goes here.
		* Success return: .T. or n != 0    Failure return: .F., 0
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*++
		*>>Form level control validation code goes here. Must return .T. before changes can be committed.
		* Success return: .T.   Failure return: .F.
		*--
		LOCAL lRequired
		  m.lRequired = THIS.lRequired
		  * If we are bound to a cursor field, and in a form with a data manager, evaluate the IsRequiredRule().
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		      m.lRequired = m.lRequired OR THISFORM.cmDataManager.IsRequired(THIS.cWorkarea, THIS.cValueSource)
		    ENDIF
		  ENDIF
		  IF m.lRequired AND EMPTY(NVL(THIS.GetValue(), ''))
		    THISFORM.DisplayMessage('%msgFieldRequired', THISFORM.NiceName(THIS))
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getvalue		&& Return the control's current value
		*++
		*>>Return the control's current value
		*--
		  RETURN THIS.Value
		
	ENDPROC

	PROCEDURE gotfocus
		* Save the undo value for the control, if it has not yet been modified.
		  THISFORM.cmBindingManager.GotFocus(THIS)
		
	ENDPROC

	PROCEDURE init
		*++
		* Codemine Foundation checkbox control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  * Make sure binding manager is instantiated.
		  IF NOT PEMSTATUS(THISFORM, 'cmBindingManager', 5)
		    THISFORM.AddObject('cmBindingManager', 'cmBindingManagerCustom')
		  ENDIF
		
		  * Process common data-bound control binding initialization.
		  IF NOT THISFORM.cmBindingManager.InitBinding(THIS)
		    RETURN .F.    && This line will also execute if above "IF" generates error.
		  ENDIF
		
		  * Localize the caption if localization is enabled
		  IF THIS.lLocalizeCaption AND NOT ISNULL(THISFORM.oMessage)
		    THIS.Caption = THISFORM.oMessage.Localize(THIS.Caption, .T.)
		  ENDIF
		
	ENDPROC

	PROCEDURE keypress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Key processing for checkboxes.
		* Intercept and filter out select keystrokes
		*--
		  DO CASE
		    CASE NOT THIS.lChanged AND INLIST(m.nKeyCode % 128, 13, ASC(' ')) AND m.nShiftAltCtrl <= 1
		      IF NOT THIS.BeforeChange()
		        NODEFAULT
		      ENDIF
		
		    CASE m.nKeyCode = 24 AND BITTEST(THIS.nControlFlags, CTLFLAG_INGRID)
		      IF PEMSTATUS(THIS.Parent.Parent, 'AutoAppend', 5)
		        * Add a new record to the parent grid, if at the end.
		        IF THIS.Parent.Parent.AutoAppend()
		          NODEFAULT
		        ENDIF
		      ENDIF
		
		    CASE m.nShiftAltCtrl = 0 AND m.nKeyCode = 22 && Insert mode toggle
		      =INSMODE(NOT INSMODE())
		      NODEFAULT
		
		    CASE m.nKeyCode = ASC('0') AND m.nShiftAltCtrl = 2
		      NODEFAULT
		      IF THIS.lAllowNull
		        IF THIS.BeforeChange()
		          THIS.SetValue(.NULL.)
		        ENDIF
		      ELSE
		        ??CHR(7)   && Ignore ctrl+0 keystrokes (prevent entering a .NULL. via keyboard).
		      ENDIF
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE loadmemory		&& Load checkbox value from stored memory.
		*++
		*>>Load checkbox value from stored memory.
		* Return .T. if there was a value stored in memory.
		*--
		  RETURN THISFORM.cmBindingManager.LoadMemory(THIS)
		
	ENDPROC

	PROCEDURE loadtranslation		&& Translate bound data value into a format suitable for display.
		LPARAMETERS uValue
		*++
		*>>Translate bound data value into a format suitable for display.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE loadvalue		&& Load checkbox value property from cValuesource.
		*++
		*>>Load checkbox value property from cValuesource.
		*--
		  LOCAL uValue
		  IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)
		    THIS.Value = m.uValue
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE lostfocus
		* Clear the default VFP workarea alias text from the status bar
		  IF VERSION(2) = 0
		    SET MESSAGE TO ''
		  ENDIF
		
	ENDPROC

	PROCEDURE mousedown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++ 
		* Don't allow mouseclick to change value of checkbox if write-protected
		*--
		  IF m.nButton = 1 AND THIS.lWriteLock
		    NODEFAULT
		  ENDIF
		
	ENDPROC

	PROCEDURE mouseup
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		  * Don't allow mouseclick to change value if write-protected
		  IF m.nButton = 1 AND THIS.lWriteLock
		    NODEFAULT
		  ENDIF
		
	ENDPROC

	PROCEDURE refresh
		*++
		* Reinitialize display buffer from checkbox's data source.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    THISFORM.cmBindingManager.InitBinding(THIS)
		  ENDIF
		
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_VALUE_LOADED) ;
		  OR BITTEST(THISFORM.nControlFlags, FRMFLAG_FORCE_RELOAD)
		    THIS.ShowControl()
		    THIS.LoadValue()
		    IF THIS.lValueMemory
		      THISFORM.cmBindingManager.DefaultFromMemory(THIS)
		    ENDIF
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		
	ENDPROC

	PROCEDURE rightclick
		*++
		* Put up checkbox context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    IF THISFORM.ContextMenuInit(THIS) AND THISFORM.cmBindingManager.ContextMenuBuild(THIS)
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty   && lReadonly and ReadOnly
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    CASE m.cProperty = 'value'
		      RETURN THIS.SetValue(@m.uValue)
		
		    CASE INLIST(m.cProperty, 'cvaluesource', 'controlsource')
		      THIS.cWorkarea = ''
		      THIS.cValueSource = m.uValue
		      THISFORM.cmBindingManager.LoadWorkarea(THIS)
		
		      IF THIS.lNativeBinding
		        IF NOT THIS.Parent.Baseclass == 'Column' OR NOT THIS.Parent.Bound
		          THIS.ControlSource = m.uValue
		        ENDIF
		      ENDIF
		      THIS.Refresh()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setvalue		&& Set the checkbox control's value
		LPARAMETERS uNewValue
		*++
		*>>Set the checkbox control's value
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		  RETURN THISFORM.cmBindingManager.SetValue(THIS, m.uNewValue)
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate checkbox security access, and update control display to reflect current state.
		*++
		*>>Re-evaluate checkbox security access, and update control display to reflect current state.
		* Called by Init and refresh methods.
		*--
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * Check for no data or Write-Protect (explicit edit mode).
		  IF NOT THIS.lWriteLock AND NOT EMPTY(THIS.cValueSource) ;
		  AND (NOT EMPTY(THIS.cWorkarea) OR NOT THISFORM.lIgnoreBoundProperties)
		    IF EMPTY(THIS.cWorkarea)
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed()  && Only pass workarea parameter if non-empty
		    ELSE
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea, SUBSTR(THIS.cValueSource, RAT('.', THIS.cValueSource) + 1))
		    ENDIF
		  ENDIF
		
		  IF 'HIDE' $ THIS.cReadOnlyDisplay
		    THIS.Visible = NOT THIS.lWriteLock
		  ENDIF
		  IF THIS.lWriteLock AND 'DISABLE' $ THIS.cReadonlyDisplay
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
	ENDPROC

	PROCEDURE showwhatsthis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the checkbox.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT   && Don't process native help if using Codemine context help
		
		      * Customize class help keys for optional features in this instance of the control.
		      IF NOT EMPTY(THIS.cHelpClassKey)  && If no class help, leave it empty
		        THIS.cHelpClassKey = LOWER(THIS.cHelpClassKey)
		        IF THIS.lValueMemory AND NOT '%hlpvaluememory' $ THIS.cHelpClassKey
		          THIS.cHelpClassKey = THIS.cHelpClassKey + ',%hlpvaluememory'
		        ENDIF
		      ENDIF
		      THISFORM.DisplayHelp(THIS)    && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE storememory		&& Save current value in system registry for later use.
		*++
		*>>Save current value in system registry for later use.
		*--
		  RETURN THISFORM.cmBindingManager.StoreMemory(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		LPARAMETERS uValue
		*++
		*>>Translate control value into a format suitable for storage in bound data source.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE storevalue		&& Write checkbox value back to data source using table or memvar syntax as appropriate.
		*++
		*>>Write checkbox value back to data source using table or memvar syntax as appropriate.
		*--
		  RETURN THISFORM.cmBindingManager.StoreValue(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE uienable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  IF m.lEnableEvent AND THISFORM.Visible
		    IF PEMSTATUS(THIS, 'nControlFlags', 5)
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		      THIS.Refresh()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE undochanges		&& Undo changes to the current control, and restore original value.
		*++
		*>>Undo changes to the current control, and restore original value.
		*--
		  IF EMPTY(THIS.cValueSource)
		    THIS.Value = THIS.uOriginalValue
		  ELSE
		    THIS.LoadValue()
		  ENDIF
		  THIS.lChanged = .F.
		
	ENDPROC

	PROCEDURE valid
		*++
		*>>If checkbox value has changed, call the FieldValid() event, and store value to datasource on success.
		*--
		LOCAL lStatus
		  * Call binding manager for common control valid() processing.
		  m.lStatus = THISFORM.cmBindingManager.Valid(THIS, .T.)
		  IF EMPTY(m.lStatus)
		    THIS.UndoChanges()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE when
		*++
		* Determine when the checkbox is allowed to receive focus.
		*--
		  IF TYPE('THISFORM') = 'O'
		    RETURN THISFORM.cmBindingManager.When(THIS)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS chkindicatorbutton AS chkcheckbox OF "codemine.vcx" 		&& A graphical button version of chkCheckBox.
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\button.bmp" ClassIcon="..\graphics\button.bmp" />

	#INCLUDE "codemine.h"
	Alignment = 0
	chelpclasskey = 
	creadonlydisplay = Disable
	FontBold = .F.
	FontSize = 8
	Height = 23
	Name = "chkindicatorbutton"
	Style = 1
	Width = 75

ENDDEFINE

DEFINE CLASS cmdcommandbutton AS commandbutton 		&& CodeMine foundation command button class.
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\button.bmp" ClassIcon="..\graphics\button.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: applysecurity		&& Evaluate security access for the control.
		*m: contextmenubuild		&& Define all the bars for a button context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Hide,Disable
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: lkeepfocus		&& If set to .F., after each Click() the button will attempt to return focus to the control that had it before the button was clicked.
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
		*p: lreadonly		&& When true the button cannot be clicked interactively.
		*p: lskipvalid		&& Set this to .T. for "Cancel" type buttons where current field should not be validated first.
		*p: lwritelock		&& Internal flag set when button cannot be clicked.
	*</DefinedPropArrayMethod>

	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpkey = 		&& Name of context help message key for this field.
	creadonlydisplay = Disable		&& Controls how read-only fields are handled. Options: Hide,Disable
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	FontBold = .F.
	FontSize = 8
	Height = 23
	lenabled = .T.		&& Specifies desired enable state for the control.
	lkeepfocus = .F.		&& If set to .F., after each Click() the button will attempt to return focus to the control that had it before the button was clicked.
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	lreadonly = .F.		&& When true the button cannot be clicked interactively.
	lskipvalid = .F.		&& Set this to .T. for "Cancel" type buttons where current field should not be validated first.
	lwritelock = .F.		&& Internal flag set when button cannot be clicked.
	Name = "cmdcommandbutton"
	Width = 75
	
	PROCEDURE applysecurity		&& Evaluate security access for the control.
		*++
		*>>Evaluate security access for the control.
		* Responsible for setting THIS.lWriteLock
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		    THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		  ENDIF
		
	ENDPROC

	PROCEDURE Click
		*++
		* Restore focus to last active data control.
		*--
		  IF NOT THIS.lKeepFocus
		    IF PEMSTATUS(THISFORM, 'ActivateNextControl', 5)
		      THISFORM.ActivateNextControl()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define all the bars for a button context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a button context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.ContextMenuBuild()
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.ContextMenuExecute(m.cOption)
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL cMsg
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Foundation CommandButton control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('nRight', .NULL.)               && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)              && Offset of bottom edge from bottom of parent container.
		  THIS.AddProperty('nControlFlags', 0)             && Internal flags used to set and determine the state of this control.
		
		  * If either enabled flag is false, disable the field.
		  THIS.lEnabled = THIS.Enabled AND THIS.lEnabled
		  THIS.cReadOnlyDisplay = UPPER(THIS.cReadOnlyDisplay)
		
		  * Localize the caption if localization is enabled
		  IF THIS.lLocalizeCaption AND NOT ISNULL(THISFORM.oMessage)
		    THIS.Caption = THISFORM.oMessage.Localize(THIS.Caption, .T.)
		  ENDIF
		
		  * Apply initial security and display state.
		  THIS.ShowControl()
		
	ENDPROC

	PROCEDURE LostFocus
		* Clear the default VFP workarea alias text from the status bar
		  IF VERSION(2) = 0
		    TRY 
		       SET MESSAGE TO ''
		       _VFP.StatusBar = 'Data Path: ' + LOWER(m.goapp.cdatafilepath)
		    CATCH
		    ENDTRY    
		  ENDIF
		
		
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nCol, nRow
		*++
		* If this button has the lSkipValid feature enabled, make sure focus always goes back
		* to the original control it was on.
		*--
		  IF m.nButton = 1 AND THIS.lSkipValid AND THISFORM.Baseclass == 'Form'
		    IF NOT (m.nCol >= THIS.Left AND m.nCol < THIS.Left + THIS.Width ;
		            AND m.nRow >= THIS.Top AND m.nRow < THIS.Top + THIS.Height)
		      * Mouse moved off button, so we wont get a click event.
		      * Restore focus to original control immediately.
		      THISFORM.ActivateNextControl()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE Refresh
		*++
		* Reinitialize display buffers from control's data source.
		*--
		  THIS.ShowControl()
		
	ENDPROC

	PROCEDURE RightClick
		*++
		* Put up context menu for commandbutton, if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty   && lReadonly and ReadOnly
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*++
		*>>Re-evaluate security access, and update control display to reflect current state.
		* Called by Init and refresh methods. Checking security is a little slow, so it is optional.
		*--
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * For buttons, ReadonlyDisplay options are Hide or Disable.
		  IF 'HIDE' $ THIS.cReadOnlyDisplay
		    THIS.Visible = NOT THIS.lWriteLock
		  ENDIF
		  IF THIS.lWriteLock
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the commandbutton.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                   && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS)  && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  IF m.lEnableEvent AND THISFORM.Visible
		    THIS.Refresh()    && Buttons call refresh method directly on UIEnable
		  ENDIF
		
	ENDPROC

	PROCEDURE When
		*++
		* Default When method prevents off-screen objects from getting focus.
		*--
		LOCAL lStatus
		  IF TYPE('THISFORM') = 'O'
		    IF PEMSTATUS(THISFORM, 'InitializeHelp', 5)
		      THISFORM.InitializeHelp(THIS)
		    ENDIF
		
		    IF PEMSTATUS(THISFORM, 'ScrollBars', 5)
		      m.lStatus = THISFORM.ScrollBars != 0
		    ENDIF
		    IF NOT m.lStatus
		      m.lStatus = THISFORM.ScaleMode != 3 OR THIS.Parent.BaseClass == 'Column' ;
		                OR (OBJTOCLIENT(THIS, 1) < THISFORM.Height AND OBJTOCLIENT(THIS, 2) < THISFORM.Width)
		    ENDIF
		
		    * Remember the control that had focus so we can return to it after. Only do 
		    * this if mouse is down, since WHEN method may be called spuriously after a click.
		    IF m.lStatus AND MDOWN() AND NOT THIS.lKeepFocus
		      IF THISFORM.Baseclass == 'Form' AND TYPE('THISFORM.ActiveControl.Baseclass') = 'C' ;
		      AND NOT THISFORM.ActiveControl.Baseclass $ 'Commandbutton,Checkbox,Pageframe'
		        IF PEMSTATUS(THISFORM, 'SetLastControl', 5)
		          THISFORM.SetLastControl(THISFORM.activecontrol)
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmgcommandgroup AS commandgroup 		&& CodeMine command button group class.
 	*< CLASSDATA: Baseclass="commandgroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: contextmenubuild		&& Define all the bars for a commandgroup context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
	*</DefinedPropArrayMethod>

	buttoncount = 0
	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpkey = 		&& Name of context help message key for this field.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	height = 32
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	Name = "cmgcommandgroup"
	width = 100
	
	PROCEDURE contextmenubuild		&& Define all the bars for a commandgroup context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a commandgroup context menu. Return false if no bars are defined.
		*--
		  IF NOT EMPTY(THIS.cHelpKey)
		    THISFORM.ContextMenuBar(CTX_BAR_CTL_HELP, '%barHelp')
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%barhelp'
		      THIS.ShowWhatsThis(THIS.WhatsThisHelpID)
		    OTHERWISE
		      RETURN THISFORM.ContextMenuExecute(m.cOption)
		  ENDCASE
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		LOCAL cMsg
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE init
		*++
		* CodeMine foundation CommandGroup control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('nRight', .NULL.)               && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)              && Offset of bottom edge from bottom of parent container.
		  THIS.AddProperty('nControlFlags', 0)             && Internal flags used to set and determine the state of this control.
		
		  * Localize the caption if localization is enabled
		  IF THIS.lLocalizeCaption AND NOT ISNULL(THISFORM.oMessage)
		    LOCAL oButton
		    FOR EACH oButton IN THIS.Buttons
		      m.oButton.Caption = THISFORM.oMessage.Localize(m.oButton.Caption)
		    ENDFOR
		  ENDIF
		
	ENDPROC

	PROCEDURE rightclick
		*++
		* Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE showwhatsthis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the commandGroup.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                   && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS)  && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE when
		* Default When method prevents off-screen objects from getting focus.
		  IF TYPE('THISFORM') = 'O'
		    IF PEMSTATUS(THISFORM, 'InitializeHelp', 5)
		      THISFORM.InitializeHelp(THIS)
		    ENDIF
		    IF PEMSTATUS(THISFORM, 'ScrollBars', 5)
		      IF THISFORM.ScrollBars != 0
		        RETURN .T.
		      ENDIF
		    ENDIF
		    RETURN THISFORM.ScaleMode != 3 OR (OBJTOCLIENT(THIS, 1) < THISFORM.Height AND OBJTOCLIENT(THIS, 2) < THISFORM.Width)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntbasecontainer AS container 		&& CodeMine base container class. Use for classes that have no visual representation at runtime.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
	*</DefinedPropArrayMethod>

	Name = "cntbasecontainer"
	
	PROCEDURE addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		LPARAMETERS cName, cClass, uP1, uP2, uP3, uP4, uP5, uP6, uP7, uP8, uP9
		*++
		*>>Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*--
		LOCAL ix, cParams, cLibrary
		  m.cLibrary = .NULL.
		  IF PEMSTATUS(_SCREEN, 'cmGlobalObjectManager', 5)
		    m.cClass = _SCREEN.cmGlobalObjectManager.GetClassName(m.cClass, @m.cLibrary)
		  ENDIF
		
		  m.cParams = ''
		  FOR ix = 1 TO PCOUNT() - 2
		    m.cParams = m.cParams + ', @m.uP' + STR(m.ix,1)
		  ENDFOR
		  RETURN THIS.NewObject(m.cName, m.cClass, m.cLibrary, '' &cParams)
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		LOCAL cMsg
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntbevel AS cntcontainer OF "codemine.vcx" 		&& CodeMine Beveled edge container class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	BorderWidth = 3
	Height = 24
	Name = "cntbevel"
	SpecialEffect = 0
	Width = 100

ENDDEFINE

DEFINE CLASS cntcontainer AS cntbasecontainer OF "codemine.vcx" 		&& CodeMine visual container class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	*</DefinedPropArrayMethod>

	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	Name = "cntcontainer"
	
	PROCEDURE contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.ContextMenuBuild()
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.ContextMenuExecute(m.cOption)
		
	ENDPROC

	PROCEDURE Init
		*++
		* CodeMine foundation container control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  * Store original size for use by form's reposition method.
		  THIS.AddProperty('nRight', .NULL.)               && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)              && Offset of bottom edge from bottom of parent container.
		  THIS.AddProperty('nOriginalWidth', THIS.Width)   && Original width of container, set by Init method.
		  THIS.AddProperty('nOriginalHeight', THIS.Height) && Original height of container, set by Init method.
		  THIS.AddProperty('nControlFlags', 0)             && Internal flags used to set and determine the state of this control.
		
	ENDPROC

	PROCEDURE Resize
		*++
		* Reposition container contents when it is resized
		*--
		  IF PEMSTATUS(THIS, 'nOriginalWidth', 5)
		    IF NOT EMPTY(THIS.nOriginalWidth)
		      IF PEMSTATUS(THIS, 'RepositionContents', 5)
		        * Call custom method for repositioning container contents, if there is one.
		        THIS.RepositionContents()
		      ELSE
		        IF PEMSTATUS(THISFORM, 'RepositionContents', 5)
		          THISFORM.RepositionContents(THIS)
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE RightClick
		*++
		*>>Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		    m.cOption = THISFORM.ContextMenuActivate()
		    IF NOT EMPTY(m.cOption)
		      THIS.ContextMenuExecute(m.cOption)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE SetFocus
		*++
		*>>Set focus to the first control in the container.
		*--
		LOCAL oCtl, oFocus, nBestIndex 
		
		  m.oFocus = .NULL.
		  m.nBestIndex = 99999
		  FOR EACH oCtl IN THIS.Controls
		    * For some ActiveX controls, we need to test for both SetFocus and TabIndex.
		    IF PEMSTATUS(m.oCtl, 'SetFocus', 5) 
		      IF PEMSTATUS(m.oCtl, 'TabIndex', 5) 
		        IF m.oCtl.TabIndex < m.nBestIndex AND m.oCtl.Enabled AND m.oCtl.Visible
		          m.nBestIndex = m.oCtl.TabIndex
		          m.oFocus = m.oCtl
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  * If target is another pageframe or container, this will recurse 
		  * into it to find a final target control.
		  IF NOT ISNULL(m.oFocus)
		    THISFORM.ActivateNextControl(m.oFocus)
		    NODEFAULT
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the container.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                  && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS) && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  IF m.lEnableEvent AND THISFORM.Visible
		    THIS.Refresh()
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cuscustom AS custom 		&& CodeMine foundation Custom object class.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*m: release		&& Release this object
	*</DefinedPropArrayMethod>

	Name = "cuscustom"
	
	PROCEDURE addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		LPARAMETERS cName, cClassAlias, uP1, uP2, uP3, uP4, uP5, uP6, uP7, uP8, uP9
		*++
		*>>Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*--
		LOCAL ix, cParams, cLibrary
		
		  * Translate class alias into actual class name, and extract class library prefix if present.
		  m.cLibrary = .NULL.
		  IF PEMSTATUS(_SCREEN, 'cmGlobalObjectManager', 5)
		    m.cClassAlias = _SCREEN.cmGlobalObjectManager.GetClassName(m.cClassAlias, @m.cLibrary)
		  ENDIF
		
		  m.cParams = ''
		  FOR ix = 1 TO PCOUNT() - 2
		    m.cParams = m.cParams + ', @m.uP' + STR(m.ix,1)
		  ENDFOR
		  RETURN THIS.NewObject(m.cName, m.cClassAlias, m.cLibrary, '' &cParams)
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Fatal coding error - Pass it on to CodeMine error handler if available.
		*--
		LOCAL oMessage
		
		  m.cMsg = MESSAGE()   && Save error message text in case other call clears it.
		  m.oMessage = FindGlobalObject('cmMessage')
		  IF NOT ISNULL(m.oMessage)
		    RETURN m.oMessage.FatalError(@m.cMsg, @m.cMethod, m.nLine)  && Usually .T. is anything
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		  RETURN .F.
		
	ENDPROC

	PROCEDURE release		&& Release this object
		*++
		*>>Release this object
		*--
		  RELEASE THIS
		
	ENDPROC

ENDDEFINE

DEFINE CLASS edteditbox AS editbox 		&& CodeMine foundation editbox class.
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*m: applysecurity		&& Evaluate security access for the control.
		*m: beforechange		&& Determine if it is OK to interactively change the control's value.
		*m: contextmenubuild		&& Define all the bars for a editbox context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: fieldvalid		&& Field level validation code goes here.
		*m: formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*m: getvalue		&& Return the control's current value
		*m: loadmemory		&& Load editbox value from stored memory.
		*m: loadtranslation		&& Translate bound data value into a format suitable for display.
		*m: loadvalue		&& Load value property from cValuesource.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: setvalue		&& Set the editbox control's value
		*m: showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*m: storememory		&& Save current value in system registry for later use.
		*m: storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		*m: storevalue		&& Write editbox value back to data source using table or memvar syntax as appropriate.
		*m: undochanges		&& Undo changes to the current control, and restore original value.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: cencryptionkey		&& Encryption key for encrypted data. Leave empty for unencrypted data.
		*p: chelpclasskey		&& List of class help keys for this class.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: clinkedlabel		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
		*p: creadprivilege		&& Privilege required to display data in this field.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cvaluesource		&& Data source bound to this control.
		*p: cviewparameter		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
		*p: cworkarea		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lallowenter		&& Set true if line breaks are allowed in the control value.
		*p: lallownull		&& Set True if null values can be entered into the control.
		*p: lallowzoom		&& Controls whether or not the Zoom edit option is included in the context menu.
		*p: lautoremember		&& When true and lValueMemory is also true, most recently entered value is remembered.
		*p: lchanged		&& Set to true if data was changed interactively.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: lnativebinding		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
		*p: lnoinitdata		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
		*p: lnullforempty		&& If set to .T., store .NULL. to bound data when value is EMPTY. Set to .NULL. to use BindingManager setting.
		*p: lreadlock		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
		*p: lreadonly		&& When true, Control value cannont be edited interactively.
		*p: lrequired		&& If True a value must be entered before changes can be saved.
		*p: lvaluememory		&& When true, control's value can be remembered and restored under user control.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
		*p: nreadonlybackcolor		&& Background color used when the control is read-only. Defaults to parent container background color.
		*p: nvalidationmode		&& Determines when FieldValid() event is triggered for text editing controls. Settings: NULL=Use BindingManager Setting,0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	*</DefinedPropArrayMethod>

	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	cencryptionkey = 		&& Encryption key for encrypted data. Leave empty for unencrypted data.
	chelpclasskey = %hlpTextbox		&& List of class help keys for this class.
	chelpkey = 		&& Name of context help message key for this field.
	clinkedlabel = 		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	creadonlydisplay = Dim		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
	creadprivilege = 		&& Privilege required to display data in this field.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cvaluesource = 		&& Data source bound to this control.
	cviewparameter = 		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
	cworkarea = 		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	Height = 23
	IntegralHeight = .T.
	lallowenter = .T.		&& Set true if line breaks are allowed in the control value.
	lallownull = .F.		&& Set True if null values can be entered into the control.
	lallowzoom = .T.		&& Controls whether or not the Zoom edit option is included in the context menu.
	lautoremember = .T.		&& When true and lValueMemory is also true, most recently entered value is remembered.
	lchanged = .F.		&& Set to true if data was changed interactively.
	lenabled = .T.		&& Specifies desired enable state for the control.
	lnativebinding = .F.		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
	lnoinitdata = .F.		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
	lnullforempty = .NULL.		&& If set to .T., store .NULL. to bound data when value is EMPTY. Set to .NULL. to use BindingManager setting.
	lreadlock = .F.		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
	lreadonly = .F.		&& When true, Control value cannont be edited interactively.
	lrequired = .F.		&& If True a value must be entered before changes can be saved.
	lvaluememory = .F.		&& When true, control's value can be remembered and restored under user control.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "edteditbox"
	nreadonlybackcolor = .NULL.		&& Background color used when the control is read-only. Defaults to parent container background color.
	nvalidationmode = .NULL.		&& Determines when FieldValid() event is triggered for text editing controls. Settings: NULL=Use BindingManager Setting,0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	Width = 100
	
	PROCEDURE afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*++
		*>>Method called after the control value has been successfuly changed and valuesource is updated.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE applysecurity		&& Evaluate security access for the control.
		*++
		*>> Evaluate security access for the control.
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  IF NOT EMPTY(THIS.cReadprivilege) AND NOT ISNULL(THISFORM.oSecurity)
		    THIS.lReadLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cReadPrivilege)
		  ENDIF
		
		  * If its not readable, its not writable either.
		  IF THIS.lReadLock
		    THIS.lWriteLock = .T.
		  ELSE
		    IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		      THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE beforechange		&& Determine if it is OK to interactively change the control's value.
		*++
		*>>Determine if it is OK to interactively change the control's value.
		* Sets the lChanged flag for the control on success.
		*--
		  RETURN THISFORM.cmBindingManager.BeforeChange(THIS)
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define all the bars for a editbox context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a editbox context menu. Return false if no bars are defined.
		*--
		  IF THIS.lAllowZoom AND NOT THIS.lReadLock AND VARTYPE(THIS.Value) = 'C'
		    THISFORM.ContextMenuBar(CTX_BAR_CTL_ZOOM, '%barZoom')
		    THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP3)
		  ENDIF
		  RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%barzoom'
		      LOCAL oDialog
		      m.oDialog = CreateNewObject('frmZoomEdit', THIS.Value, THISFORM.NiceName(THIS), THIS.lWriteLock, THIS.AllowTabs, THIS.lAllowEnter)
		      IF VARTYPE(m.oDialog) = 'O'
		        m.oDialog.Show(1)
		        IF VARTYPE(m.oDialog) = 'O'
		          IF m.oDialog.uValue AND THIS.BeforeChange()
		            THIS.SetValue(m.oDialog.cValue)
		          ENDIF
		          m.oDialog.Release()
		        ENDIF
		      ENDIF
		    OTHERWISE
		      RETURN THISFORM.cmBindingManager.ContextMenuExecute(THIS, m.cOption)
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Editbox Errors. Record rule (1583) applys here only if no buffering.
		*--
		LOCAL cMsg
		
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		  DO CASE
		    CASE INLIST(m.nError, 12, 13, 1734, 1925) AND NOT THIS.lNativeBinding AND '.controlsource' $ LOWER(m.cMethod)
		      * Ignore ControlSource Errors during Init.
		      RETURN .T.
		
		    CASE INLIST(m.nError, 1581,1582,1583) AND THIS.lNativeBinding
		      * DBC rule violated (1581,1582,1583) applies here only if lNativeBinding is set.
		      RETURN .T.
		
		    CASE m.nError = 1925 AND SYS(2018) == 'CMBINDINGMANAGER'
		      * Handle BindMan not found errors gracefuly. Usually this only will happen in a VCX based form
		      * with BindMan placed onthe form at design time, higher in the Z order than bound controls.
		      * Init method will fail in this case, and control will not be created.
		      MESSAGEBOX('No Binding Manager, or too high in Z order', 48, THIS.Name)
		      RETURN .T.
		  ENDCASE
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE fieldvalid		&& Field level validation code goes here.
		*++
		*>>Field level validation code goes here.
		* Success return: .T. or n != 0
		* Failure return: .F., 0
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*++
		*>>Form level control validation code goes here. Must return .T. before changes can be committed.
		* Success return: .T.
		* Failure return: .F.
		*--
		LOCAL lRequired
		  m.lRequired = THIS.lRequired
		  * If we are bound to a cursor field, and in a form with a data manager, evaluate the IsRequiredRule().
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		      m.lRequired = m.lRequired OR THISFORM.cmDataManager.IsRequired(THIS.cWorkarea, THIS.cValueSource)
		    ENDIF
		  ENDIF
		  IF m.lRequired AND EMPTY(NVL(THIS.GetValue(), ''))
		    THISFORM.DisplayMessage('%msgFieldRequired', THISFORM.NiceName(THIS))
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getvalue		&& Return the control's current value
		*++
		*>>Return the control's current value
		*--
		  RETURN THIS.Value
		
	ENDPROC

	PROCEDURE GotFocus
		  THISFORM.cmBindingManager.GotFocus(THIS)
		
		  * Remember when we have focus, so we can maintain NULL display properly.
		  THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_HAS_FOCUS)
		
		  IF THIS.SelectOnEntry
		    DODEFAULT()   && This causes SelectOnEntry to work on entry by mouseclick as well as via keyboard.
		  ENDIF
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Foundation Editbox control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  * Make sure binding manager is instantiated.
		  IF NOT PEMSTATUS(THISFORM, 'cmBindingManager', 5)
		    THISFORM.AddObject('cmBindingManager', 'cmBindingManagerCustom')
		  ENDIF
		
		  * Process common data-bound control binding initialization.
		  IF NOT THISFORM.cmBindingManager.InitBinding(THIS)
		    RETURN .F.    && This line will also execute if above "IF" generates error.
		  ENDIF
		
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_INGRID) AND THIS.Parent.Baseclass != 'Container'
		    THIS.SelectedBackColor = GetSysColor(COLOR_HIGHLIGHT)
		    THIS.Margin = 0          && No margin
		    THIS.BorderStyle = 0     && and no border
		  ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		*++
		*>>Intercept all change attempts, enforce security, and secure locks as needed.
		* Return .T. if the change was accepted, .F. if it was rejected and original value restored.
		*--
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_NULL)
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_ESCAPE)
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_ESCAPE)
		    THIS.UndoChanges()
		  ELSE
		    IF NOT THIS.lChanged AND NOT THIS.BeforeChange()
		      * At this point, value has already changed, so 
		      * if changes are not allowed, we must restore original value.
		      THIS.UndoChanges()
		      RETURN .F.
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Key processing for edit boxes
		*--
		  DO CASE
		    CASE NOT THIS.lChanged AND m.nShiftAltCtrl <= 1 AND m.nKeyCode > 0 ;
		         AND (m.nKeyCode % 128 >= ASC(' ') OR m.nKeyCode = 7)
		      * For data characters, check if changes are allowed before accepting the character.
		      IF NOT THIS.BeforeChange()
		        NODEFAULT
		      ENDIF
		
		    * Implement basic Copy & Paste in the control, for cases where no VFP menu is available.
		    CASE m.nShiftAltCtrl = 2 AND m.nKeyCode = 3   && Ctrl+C (Copy)
		      IF VARTYPE(THIS.Value) = 'C' AND THIS.SelLength > 0
		        _CLIPTEXT = TRIM(SUBSTR(THIS.Value, THIS.SelStart, THIS.SelLength))
		      ENDIF
		
		    CASE THIS.AllowTabs AND m.nShiftAltCtrl = 0 AND m.nKeyCode = 9
		      IF NOT THIS.BeforeChange()
		        NODEFAULT
		      ENDIF
		
		    CASE m.nKeyCode = ASC('0') AND m.nShiftAltCtrl = 2
		      NODEFAULT
		      IF THIS.lAllowNull
		        IF THIS.BeforeChange()
		          THIS.SetValue(.NULL.)
		        ENDIF
		      ELSE
		        ??CHR(7)   && Ignore ctrl+0 keystrokes (prevent entering a .NULL. via keyboard).
		      ENDIF
		
		    CASE NOT THIS.lAllowEnter AND m.nKeyCode = 13
		      * Dont allow line-breaks in data when .lAllowEnter is off.
		      ??CHR(7)
		      NODEFAULT
		
		    CASE m.nShiftAltCtrl = 0 AND m.nKeyCode = 22 && Insert mode toggle
		      =INSMODE(NOT INSMODE())
		      NODEFAULT
		
		    CASE m.nKeyCode = 27
		      THIS.lChanged = .F.                        && Escape resets data, so clear change flag to prevent validation
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_ESCAPE) && Flag that we are processing an escape key press.
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE loadmemory		&& Load editbox value from stored memory.
		*++
		*>>Load editbox value from stored memory.
		* Return .T. if there was a value stored in memory.
		*--
		  RETURN THISFORM.cmBindingManager.LoadMemory(THIS)
		
	ENDPROC

	PROCEDURE loadtranslation		&& Translate bound data value into a format suitable for display.
		LPARAMETERS uValue
		*++
		*>>Translate bound data value into a format suitable for display.
		*--
		  * Decrypt string, unless it is all spaces (empty field in a newly appened record).
		  IF NOT EMPTY(THIS.cEncryptionKey) AND LEN(CHRTRAN(m.uValue, ' ', '')) > 0
		    RETURN cmEncrypt(m.uValue, THIS.cEncryptionKey)
		  ENDIF
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE loadvalue		&& Load value property from cValuesource.
		*++
		*>>Load value property from cValuesource.
		*--
		  LOCAL uValue
		  IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)  && Returns .F. if native binding or unbound.
		    * Editboxes screw up if they get focus with a null value...
		    IF ISNULL(m.uValue)
		      THIS.Value = THIS.NullDisplay
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_NULL)
		    ELSE
		      THIS.Value = m.uValue
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_NULL)
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE LostFocus
		* Custom code to fix up the display of NULL values in an edit box.
		  IF VERSION(2) = 0
		    TRY 
		       SET MESSAGE TO ''
		       IF m.goApp.lCloudServer
		          _VFP.StatusBar = 'Company Name: ' + proper(m.goapp.cCompanyName) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ELSE
		          _VFP.StatusBar = 'Data Path: ' + LOWER(m.goapp.cdatafilepath) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ENDIF    
		    CATCH
		    ENDTRY    
		  ENDIF
		
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_NULL)
		    THIS.Value = THIS.NullDisplay
		  ENDIF
		
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_HAS_FOCUS)
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_NULL)
		
	ENDPROC

	PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		  * Clear flag for select-all-on-entry behavior
		  IF THIS.SelLength > 0
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Special workaround for VFP5.0 quirks. If a control Valid fails when the user clicks on another form
		* the user cannot re-activate the original window by clicking on the control that failed validation.
		* We detect this case here and re-activate the window.
		*
		* May be able to dispose of this code in later versions of VFP, if they fix the problem.
		*--
		  IF THIS.lChanged
		    IF THISFORM.BaseClass == 'Form' AND NOT BITTEST(THISFORM.nControlFlags, FRMFLAG_ACTIVE)
		      ACTIVATE WINDOW (THISFORM.Name)
		    ENDIF
		  ENDIF
		
		  * Implement SelectOnEntry that will work in grids, and on entry by mouse-click.
		  IF THIS.SelLength = 0 AND BITTEST(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		    THIS.SelStart = 0
		    THIS.SelLength = LEN(TRIM(THIS.Text))
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		
	ENDPROC

	PROCEDURE Refresh
		*++
		* Reinitialize display buffers from edit box's data source.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    THISFORM.cmBindingManager.InitBinding(THIS)
		  ENDIF
		
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_VALUE_LOADED) ;
		  OR BITTEST(THISFORM.nControlFlags, FRMFLAG_FORCE_RELOAD)
		    THIS.ShowControl()
		    THIS.LoadValue()    && Also clears lChanged
		    IF THIS.lValueMemory
		      THISFORM.cmBindingManager.DefaultFromMemory(THIS)
		    ENDIF
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		
	ENDPROC

	PROCEDURE RightClick
		*++
		* Put up context menu for editbox, if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    * Use the binding manager to put up common control context menus. This will make a callback
		    * to owr own ContextMenuBuild() method to control-specific items.
		    IF THISFORM.ContextMenuInit(THIS) AND THISFORM.cmBindingManager.ContextMenuBuild(THIS)
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty   && lReadonly and ReadOnly
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty    && lEnabled and Enabled
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    CASE m.cProperty = 'value'
		      RETURN THIS.SetValue(@m.uValue)
		
		    CASE INLIST(m.cProperty, 'cvaluesource', 'controlsource')
		      THIS.cWorkarea = ''
		      THIS.cValueSource = m.uValue
		      THISFORM.cmBindingManager.LoadWorkarea(THIS)
		
		      IF THIS.lNativeBinding
		        IF NOT THIS.Parent.Baseclass == 'Column' OR NOT THIS.Parent.Bound
		          THIS.ControlSource = m.uValue
		        ENDIF
		      ENDIF
		      THIS.Refresh()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setvalue		&& Set the editbox control's value
		LPARAMETERS cNewValue
		*++
		*>>Set the editbox control's value
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		
		  IF THISFORM.cmBindingManager.SetValue(THIS, m.cNewValue)
		    * Need to fix up NULL display if we currently have focus.
		    IF ISNULL(m.cNewValue) AND BITTEST(THIS.nControlFlags, CTLFLAG_HAS_FOCUS) AND NOT THIS.lNativeBinding
		      THIS.Value = ''
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_NULL)
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*++
		*>>Re-evaluate security access, and update control display to reflect current state.
		* Called by Init and refresh methods. Checking security is a little slow, so it is optional.
		*--
		LOCAL lOldWriteLock
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  m.lOldWriteLock = THIS.lWriteLock
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * Check for no data or Write-Protect (explicit edit mode).
		  IF NOT THIS.lWriteLock AND NOT EMPTY(THIS.cValueSource) ;
		  AND (NOT EMPTY(THIS.cWorkarea) OR NOT THISFORM.lIgnoreBoundProperties)
		    IF EMPTY(THIS.cWorkarea)
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed()  && Only pass workarea parameter if non-empty
		    ELSE
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea, SUBSTR(THIS.cValueSource, RAT('.', THIS.cValueSource) + 1))
		    ENDIF
		  ENDIF
		
		  * Apply or remove readonly display effect if read-only condition changed.
		  IF m.lOldWriteLock != THIS.lWriteLock
		    IF 'DIM' $ THIS.cReadOnlyDisplay
		      IF THIS.lWriteLock
		        IF ISNULL(THIS.nBackColor)
		          THIS.nBackColor = THIS.BackColor
		        ENDIF
		        IF ISNULL(THIS.nReadOnlyBackColor)
		          THIS.nReadOnlyBackColor = THIS.Parent.BackColor
		        ENDIF
		        THIS.BackColor = THIS.nReadOnlyBackColor
		      ELSE
		        IF NOT ISNULL(THIS.nBackColor)
		          THIS.BackColor = THIS.nBackColor
		        ENDIF
		      ENDIF
		    ENDIF
		    THIS.MousePointer = IIF(THIS.lWriteLock, 1, 0)  && Change cursor to arrow while read-only.
		  ENDIF
		
		  * Control is Disabled if readonly (optionaly), or if datasource is EOF().
		  IF THIS.lWriteLock AND 'DISABLE' $ THIS.cReadOnlyDisplay
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
		  * Update linked label control, if any.
		  IF NOT EMPTY(THIS.cLinkedLabel)
		    LOCAL oLabel
		    m.oLabel = EVALUATE('THIS.Parent.' + THIS.cLinkedLabel)
		    m.oLabel.Visible = THIS.Visible
		    m.oLabel.Refresh()
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the editbox.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT   && Don't process native help if using Codemine context help
		
		      * Customize class help keys for optional features in this instance of the control.
		      IF NOT EMPTY(THIS.cHelpClassKey)  && If no class help, leave it empty
		        THIS.cHelpClassKey = LOWER(THIS.cHelpClassKey)
		        IF THIS.lAllowZoom AND NOT '%hlpzoomedit' $ THIS.cHelpClassKey
		          THIS.cHelpClassKey = THIS.cHelpClassKey + ',%hlpzoomedit'
		        ENDIF
		        IF THIS.lValueMemory AND NOT '%hlpvaluememory' $ THIS.cHelpClassKey
		          THIS.cHelpClassKey = THIS.cHelpClassKey + ',%hlpvaluememory'
		        ENDIF
		      ENDIF
		      THISFORM.DisplayHelp(THIS)    && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE storememory		&& Save current value in system registry for later use.
		*++
		*>>Save current value in system registry for later use.
		*--
		  RETURN THISFORM.cmBindingManager.StoreMemory(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		LPARAMETERS uValue
		*++
		*>>Translate control value into a format suitable for storage in bound data source.
		*--
		  IF NOT EMPTY(THIS.cEncryptionKey)
		    RETURN cmEncrypt(m.uValue, THIS.cEncryptionKey)
		  ENDIF
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE storevalue		&& Write editbox value back to data source using table or memvar syntax as appropriate.
		*++
		*>>Write editbox value back to data source using table or memvar syntax as appropriate.
		*--
		  RETURN THISFORM.cmBindingManager.StoreValue(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  * Pages in Forms instaniated from a VCX trigger UIenable events for the initial active
		  * page, before the form is visible. We ignore these events, as they can mess up lNoInitData.
		  IF m.lEnableEvent AND THISFORM.Visible
		    IF PEMSTATUS(THIS, 'nControlFlags', 5)
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		      THIS.Refresh()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE undochanges		&& Undo changes to the current control, and restore original value.
		*++
		*>>Undo changes to the current control, and restore original value.
		*--
		  IF EMPTY(THIS.cValueSource)
		    THIS.Value = THIS.uOriginalValue
		  ELSE
		    THIS.LoadValue()
		  ENDIF
		  THIS.lChanged = .F.
		
	ENDPROC

	PROCEDURE Valid
		*++
		*>>If editbox value has changed, call the FieldValid() event, and store value to datasource on success.
		*--
		  * Call binding manager for common control valid() processing.
		  IF THISFORM.cmBindingManager.ValidNeeded(THIS)
		    RETURN THISFORM.cmBindingManager.Valid(THIS)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE When
		*++
		* Determine when the editbox control is allowed to receive focus.
		*--
		  IF TYPE('THISFORM') = 'O'
		    RETURN THISFORM.cmBindingManager.When(THIS)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS grdgrid AS grid 		&& CodeMine foundation grid class.
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterincrementalsearch		&& Custom code to execute after each character of an incremental search.
		*m: afterrowchange		&& Custom method called after the current row in the grid has changed.
		*m: autoappend		&& Append a new row on down-arrow if current row is the last row.
		*m: beforeautoappend		&& Custom code to determine if it is OK to autoappend a record at the current time.
		*m: beforerowchange		&& Custom method called before the current row in the grid has changed. Available in VFP7.0 and later.
		*m: columnordertoindex		&& Given a ColumnOrder value (like the grid ActiveColumn property), return the corresponding Columns collection index.
		*m: contextmenubuild		&& Define all the bars for the grid context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected Grid context menu item. Usually called directly from context menu activation.
		*m: formatdata1		&& Developer-defined custom method that can be used to format data for display in a column.
		*m: formatdata2		&& Developer-defined custom method that can be used to format data for display in a column.
		*m: formatdata3		&& Developer-defined custom method that can be used to format data for display in a column.
		*m: formvalid		&& Form level validation code for Grid. Default code enforces lRequired property of contained controls in current row.
		*m: headerclick		&& Developer-defined custom method that can be called on column heading clicks, or other events.
		*m: incrementalsearch		&& Process incremental search characters for the grid.
		*m: restorecolumnwidths		&& Restore columns widths and order from saved values.
		*m: restorelayout		&& Rebuild column data bindings after RecordSource cursor is changed, using values saved by SaveLayout().
		*m: savecolumnwidths		&& Save columsn widths for next time grid is created.
		*m: savelayout		&& Save current column ControlSource's and clear the RecordSource for the grid in preparation for setting a new RecordSource.
		*m: search		&& Search the cursor for the first record where the specified field matches the specified value. Used by the Incremental search feature.
		*m: showcontrol		&& Redisplay the grid with appropriate background color per readonly status
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpclasskey		&& Name of class help key for this class.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: cmenubardelete		&& Context menu prompt for the "Delete" option.
		*p: cmenubaredit		&& Context menu prompt for the "Edit" option.
		*p: cmenubarnew		&& Context menu prompt for the "New" option.
		*p: creadonlydisplay		&& Controls how read-only controls in columns are displayed. Options: Dim,Normal
		*p: crefreshcontainer		&& If lRefreshOnRowChange is set, this property specifies the container to refresh. If left empty, the default is the entire form.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter,Cstretch
		*p: csearchfield		&& The name of the field currenly used to incremental search on. Leave blank at design time.
		*p: csearchtext		&& The last text searched for. Leave blank at design time.
		*p: cworkarea		&& Workarea alias if grid.Recordsource is a cmDataManager managed cursor. Set to .NULL. to disable Codemine Grid extensions.
		*p: lallowautoappend		&& Set .T. to allow automatic append on downarrow in last row.
		*p: lallowdelete		&& Set .T. to allow deleting records via context menu option
		*p: lallowedit		&& Set .T. to enable the "Edit" context menu option
		*p: lallownew		&& Set .T. to allow adding new records via context menu option
		*p: lcolumnmemory		&& When true the control remembers the current column widths as the user changes them.
		*p: lgridgetspagekeys		&& When grid is in a Pageframe, set this to .F. to use page-up/down keys as page change keys.
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
		*p: lrefreshonrowchange		&& Set to true to refresh form whenever grid row changes.
		*p: lsearch		&& Set to .T. to enable incremental searching on read-only columns.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
		*p: nreadonlybackcolor		&& Background color used when the grid is read-only. Defaults to parent container background color.
		*p: nsearchresettime		&& Number of seconds before the incremental search string is automatically reset. Set to -1 to Never reset.
	*</DefinedPropArrayMethod>

	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpclasskey = %hlpGrid		&& Name of class help key for this class.
	chelpkey = 		&& Name of context help message key for this field.
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	cmenubardelete = %barDeleteRecord		&& Context menu prompt for the "Delete" option.
	cmenubaredit = %barEditRecord		&& Context menu prompt for the "Edit" option.
	cmenubarnew = %barNewRecord		&& Context menu prompt for the "New" option.
	creadonlydisplay = Dim		&& Controls how read-only controls in columns are displayed. Options: Dim,Normal
	crefreshcontainer = 		&& If lRefreshOnRowChange is set, this property specifies the container to refresh. If left empty, the default is the entire form.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter,Cstretch
	csearchfield = 		&& The name of the field currenly used to incremental search on. Leave blank at design time.
	csearchtext = 		&& The last text searched for. Leave blank at design time.
	cworkarea = 		&& Workarea alias if grid.Recordsource is a cmDataManager managed cursor. Set to .NULL. to disable Codemine Grid extensions.
	deletemark = .F.
	lallowautoappend = .F.		&& Set .T. to allow automatic append on downarrow in last row.
	lallowdelete = .T.		&& Set .T. to allow deleting records via context menu option
	lallowedit = .F.		&& Set .T. to enable the "Edit" context menu option
	lallownew = .T.		&& Set .T. to allow adding new records via context menu option
	lcolumnmemory = .T.		&& When true the control remembers the current column widths as the user changes them.
	lgridgetspagekeys = .T.		&& When grid is in a Pageframe, set this to .F. to use page-up/down keys as page change keys.
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	lrefreshonrowchange = .F.		&& Set to true to refresh form whenever grid row changes.
	lsearch = .F.		&& Set to .T. to enable incremental searching on read-only columns.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "grdgrid"
	nreadonlybackcolor = .NULL.		&& Background color used when the grid is read-only. Defaults to parent container background color.
	nsearchresettime = 3		&& Number of seconds before the incremental search string is automatically reset. Set to -1 to Never reset.
	scrollbars = 2
	
	PROCEDURE afterincrementalsearch		&& Custom code to execute after each character of an incremental search.
		*++
		*>>Custom code to execute after each character of an incremental search.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterrowchange		&& Custom method called after the current row in the grid has changed.
		*++
		*>>Custom method called after the current row in the grid has changed.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterrowcolchange
		LPARAMETERS nCol
		*++
		* Keep the datamanager informed of the current record selected in the grid.
		*--
		  THIS.nTargetCol = 0
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF NOT EMPTY(THIS.cSearchText) ;
		    AND NOT BITTEST(THIS.nControlFlags, CTLFLAG_SEARCHING)
		      THIS.cSearchText = ''
		      THIS.AfterIncrementalSearch()
		    ENDIF
		
		    * Grids will set the control's readonly to true if the column controlSource
		    * is an expression. This messes up Codemine controls, so we clear readonly here.
		    IF m.nCol > 0 AND THIS.ColumnCount > 0         && Watch out for custom grids with no columns yet.
		      m.nCol = THIS.ColumnOrderToIndex(m.nCol)
		      WITH THIS.Columns[m.nCol]
		        IF NOT .Bound
		          LOCAL ix
		          FOR ix = 2 TO .ControlCount
		            IF PEMSTATUS(.Controls[m.ix], 'Readonly', 5)
		              .Controls[m.ix].ReadOnly = .F.
		            ENDIF
		          ENDFOR
		        ENDIF
		      ENDWITH
		    ENDIF
		
		    IF THIS.nCurrentRecno != RECNO(THIS.cWorkarea)
		      THIS.nCurrentRecno = RECNO(THIS.cWorkarea)
		
		      * Check if we are in a form with a dataManager or not.
		      IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		        THISFORM.cmDataManager.SetRecordPosition(THIS.cWorkarea)
		      ENDIF
		      THIS.AfterRowChange()
		
		      * Refresh form if flag set, or refresh nav states if this is the form's primary navigation workarea.
		      IF THIS.lRefreshOnRowChange
		        LOCAL oContainer
		        m.oContainer = EVALUATE(IIF(EMPTY(THIS.cRefreshContainer), 'THISFORM', THIS.cRefreshContainer))
		        IF PEMSTATUS(m.oContainer, 'RefreshAll', 5)
		          m.oContainer.RefreshAll()
		        ELSE
		          m.oContainer.Refresh()
		          IF NOT ISNULL(THISFORM.oStateManager)
		            THISFORM.oStateManager.RefreshAll('Form')
		          ENDIF
		        ENDIF
		      ELSE
		        IF PEMSTATUS(THISFORM, 'cNavWorkarea', 5)
		          IF PROPER(THIS.cWorkarea) == PROPER(THISFORM.cNavWorkarea)
		            m.goStateManager.RefreshAll('Form Nav')
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE autoappend		&& Append a new row on down-arrow if current row is the last row.
		*++
		*>>Append a new row on down-arrow if current row is the last row.
		*--
		LOCAL lStatus
		  IF THIS.lAllowNew AND THIS.lAllowAutoAppend AND NOT EMPTY(THIS.cWorkarea) ;
		  AND THISFORM.IsEnabled('New', THIS.cWorkarea) ;
		  AND THISFORM.cmDataManager.IsBottom(THIS.cWorkarea) 
		    * Return .T. if append was allowed, even if validation rules prevent it.
		    m.lStatus = .T.
		    IF THIS.BeforeAutoAppend()
		      THISFORM.New(THIS.cWorkarea)
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE beforeautoappend		&& Custom code to determine if it is OK to autoappend a record at the current time.
		*++
		*>>Custom code to determine if it is OK to autoappend a record at the current time.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforerowchange		&& Custom method called before the current row in the grid has changed. Available in VFP7.0 and later.
		*++
		*>>Custom method called before the current row in the grid has changed. Available in VFP7.0 and later.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforerowcolchange
		LPARAMETERS nCol
		*++
		* Enforce Row validation before allowing row movement.
		*--
		LOCAL oCtl
		
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF VERSION(5) >= 700 AND INLIST(THIS.RowColChange, 1, 3)
		      * BeforeRowColChange() occurs before the ctl Valid(), so we need to manually trigger it here.
		      IF m.nCol > 0
		        m.nCol = THIS.ColumnOrderToIndex(m.nCol)
		        m.oCtl = THIS.Columns[m.nCol]
		        IF NOT EMPTY(m.oCtl.CurrentControl)
		          m.oCtl = EVALUATE('m.oCtl.' + m.oCtl.CurrentControl)
		          IF PEMSTATUS(m.oCtl, 'lChanged', 5) 
		            IF m.oCtl.lChanged
		              IF EMPTY(m.oCtl.Valid())
		                NODEFAULT
		                RETURN    && Ctl Validation failed. Stay right on the same cell.
		              ENDIF
		            ENDIF
		          ENDIF
		        ENDIF
		      ENDIF
		
		      * Make sure both form (UI) and data rule level validation pass before allowing row move.
		      IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		        IF THIS.BeforeRowChange() AND THISFORM.BeforeNav(THIS.cWorkarea) ;
		        AND THISFORM.cmDataManager.RecordReadyToMove(THIS.cWorkarea)
		          RETURN .T.
		        ENDIF
		        * Move to the column with the validation error
		        THISFORM.ActivateNextControl()
		      ELSE
		        * No datamanger, just call the BeforeRowChange() event.
		        IF THIS.BeforeRowChange()
		          RETURN .T.
		        ENDIF
		      ENDIF
		
		      * One or another level of row validation failed, so prevent row movement.
		      NODEFAULT
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE columnordertoindex		&& Given a ColumnOrder value (like the grid ActiveColumn property), return the corresponding Columns collection index.
		LPARAMETERS nOrder
		*++
		*>>Given a ColumnOrder value (like the grid ActiveColumn property), return the corresponding Columns collection index.
		*--
		  LOCAL ix
		  FOR ix = 1 TO THIS.ColumnCount
		    IF THIS.Columns[m.ix].ColumnOrder == m.nOrder
		      RETURN m.ix
		    ENDIF
		  ENDFOR
		
		  * Return 0 if no matching column found (usually means a coding error).
		  RETURN 0
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define all the bars for the grid context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for the grid context menu. Return false if no bars are defined.
		*--
		  * If a column control didn't already add bars, add a help bar
		  IF THISFORM.cmContextMenu.GetBarCount() = 0
		    THISFORM.ContextMenuBar(CTX_BAR_CTL_HELP, '%barHelp')
		    THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP4)
		  ENDIF
		
		  IF THIS.ColumnCount > 1
		    LOCAL oCol
		    FOR EACH oCol IN THIS.Columns
		      IF PEMSTATUS(m.oCol, '_nOriginalWidth', 5)
		        IF m.oCol.Width != m.oCol._nOriginalWidth
		          THISFORM.ContextMenuBar(CTX_BAR_CTL_COLUMNS, '%barResetColumns')
		          THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP5)
		          EXIT
		        ENDIF
		      ENDIF
		    ENDFOR
		  ENDIF
		
		  IF NOT EMPTY(THIS.cWorkarea) AND NOT THIS.ReadOnly
		    LOCAL cName
		    m.cName = IIF(EMPTY(THIS.cDisplayName), THISFORM.NiceCursorName(THIS.cWorkarea), THIS.cDisplayName)
		    IF THIS.lAllowNew AND NOT EMPTY(THIS.cMenuBarNew)
		      THISFORM.ContextMenuBar(CTX_BAR_CTL_NEW, THIS.cMenuBarNew, m.cName)
		      IF NOT THISFORM.IsEnabled('New', THIS.cWorkarea)
		        THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_NEW, .T.)
		      ENDIF
		    ENDIF
		    IF THIS.lAllowEdit AND NOT EMPTY(THIS.cMenuBarEdit)
		      THISFORM.ContextMenuBar(CTX_BAR_CTL_EDIT, THIS.cMenuBarEdit, m.cName)
		      IF NOT THISFORM.IsEnabled('Edit', THIS.cWorkarea)
		        THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_EDIT, .T.)
		      ENDIF
		    ENDIF
		    IF THIS.lAllowDelete AND NOT EMPTY(THIS.cMenuBarDelete)
		      THISFORM.ContextMenuBar(CTX_BAR_CTL_DELETE, THIS.cMenuBarDelete, m.cName)
		      IF NOT THISFORM.IsEnabled('Delete', THIS.cWorkarea)
		        THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_DELETE, .T.)
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected Grid context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected Grid context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%barhelp'
		      THIS.ShowWhatsThis(THIS.WhatsThisHelpID)
		
		    CASE m.cOption = '%barresetcolumns'
		      LOCAL oCol
		      FOR EACH oCol IN THIS.Columns
		        IF PEMSTATUS(m.oCol, '_nOriginalWidth', 5)
		          m.oCol.Width = m.oCol._nOriginalWidth
		        ENDIF
		      ENDFOR
		      THIS.Resize()    && Adjust to current window size
		
		    CASE m.cOption = PROPER(THIS.cMenuBarNew)
		      THISFORM.New(THIS.cWorkarea)
		
		    CASE m.cOption = PROPER(THIS.cMenuBarEdit)
		      THISFORM.Edit(THIS.cWorkarea)
		
		    CASE m.cOption = PROPER(THIS.cMenuBarDelete)
		      THISFORM.Delete(THIS.cWorkarea)
		
		    OTHERWISE
		      RETURN THISFORM.ContextMenuExecute(m.cOption)
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE destroy
		*++
		* Event called when grid is released.
		*--
		  IF THIS.lColumnMemory 
		    THIS.SaveColumnWidths()
		  ENDIF
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Null, Field or record valid rule violated. Record rule (1583) applys here only if no buffering.
		*--
		LOCAL cMsg
		  * Normally, the Codemine data-bound control in each column will get the error.
		  * We only get rule errors if column controls dont handle them.
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		  IF INLIST(m.nError, 1581, 1582, 1583)
		    MESSAGEBOX(m.cMsg, 48, THISFORM.NiceName(THIS))
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_RULE_VIOLATION)
		    RETURN .T.
		  ENDIF
		
		  * Error 5 is sometimes generated by the gird when new rows in an indexed cursor are 
		  * reverted during a row change. The only workaround seems to be to ignore the error.
		  IF VERSION(5) >= 700 AND m.nError = 5 AND '.MouseDown' $ m.cMethod 
		    RETURN .T.
		  ENDIF
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE formatdata1		&& Developer-defined custom method that can be used to format data for display in a column.
		*++
		*>>Developer-defined custom method that can be used to format data for display in a column.
		*--
		  RETURN ''
		
	ENDPROC

	PROCEDURE formatdata2		&& Developer-defined custom method that can be used to format data for display in a column.
		*++
		*>>Developer-defined custom method that can be used to format data for display in a column.
		*--
		  RETURN ''
		
	ENDPROC

	PROCEDURE formatdata3		&& Developer-defined custom method that can be used to format data for display in a column.
		*++
		*>>Developer-defined custom method that can be used to format data for display in a column.
		*--
		  RETURN ''
		
	ENDPROC

	PROCEDURE formvalid		&& Form level validation code for Grid. Default code enforces lRequired property of contained controls in current row.
		*++
		*>>Form level validation code for Grid. Default code enforces lRequired property of contained controls in current row.
		*--
		LOCAL oCol, oCtl, lRequired
		
		  * Enforce the lRequired property of the active control in each column for the current row.
		  IF NOT EMPTY(THIS.cWorkarea) AND NOT EOF(THIS.cWorkarea)
		    FOR EACH oCol IN THIS.Columns
		      IF NOT m.oCol.Readonly
		        m.oCtl = EVALUATE('m.oCol.' + m.oCol.CurrentControl)
		        WITH m.oCtl
		         IF PEMSTATUS(m.oCtl, 'lRequired', 5)
		            m.lRequired = .lRequired
		
		            * If we are bound to a cursor field, and in a form with a data manager, evaluate the IsRequiredRule().
		            IF NOT EMPTY(.cWorkarea) AND NOT m.lRequired
		              IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		                m.lRequired = THISFORM.cmDataManager.IsRequired(.cWorkarea, .cValueSource)
		              ENDIF
		            ENDIF
		
		            * Display error message and fail if a required column is empty in the current row.
		           IF m.lRequired 
		              .LoadValue()   && Make sure ctl has current value loaded
		              IF EMPTY(.GetValue())
		                THISFORM.DisplayMessage('%msgFieldRequired', THISFORM.NiceName(m.oCtl))
		
		                * Make this the current column next time we get focus.
		                THIS.nTargetCol = THIS.ColumnOrderToIndex(m.oCol.ColumnOrder)
		                RETURN .F.
		              ENDIF
		            ENDIF
		          ENDIF
		        ENDWITH
		      ENDIF
		    ENDFOR
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE headerclick		&& Developer-defined custom method that can be called on column heading clicks, or other events.
		LPARAMETERS nColumn
		*++
		*>>Developer-defined custom method that can be called on column heading clicks, or other events.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE incrementalsearch		&& Process incremental search characters for the grid.
		LPARAMETERS cChar, cExpression
		*++
		*>>Process incremental search characters for the grid.
		* Takes 2 parameters:
		*     cChar - the next character to add to the search string.
		*     cExpression - Optional expression to search on. Defaults to active column source.
		*--
		LOCAL nCol, cField, cWorkarea
		
		  IF EMPTY(m.cExpression)
		    * The field bound to this column is used to search on.
		    m.nCol = THIS.ColumnOrderToIndex(THIS.ActiveColumn)
		    THIS.cSearchField = THIS.Columns[m.nCol].ControlSource
		  ELSE
		    THIS.cSearchField = m.cExpression
		  ENDIF
		
		  * Search expression must be a field in the same cursor as that 
		  * specified in the grid's cWorkarea property.
		  IF '.' $ THIS.cSearchField
		    m.cWorkarea = LEFT(THIS.cSearchField, RAT('.', THIS.cSearchField) - 1)
		    IF NOT EMPTY(m.cWorkarea) AND NOT PROPER(m.cWorkarea) == PROPER(THIS.cWorkarea)
		      ERROR 'Grid I-Search workarea doesnt match cWorkarea'
		      RETURN .F.
		    ELSE
		      THIS.cSearchField = SUBSTR(THIS.cSearchField, RAT('.', THIS.cSearchField) + 1)
		    ENDIF
		  ENDIF
		
		  * Reset the search string if the specified number of second has elapsed.
		  IF THIS.nSearchResetTime >= 0
		    IF SECONDS() - THIS.nLastSearch > THIS.nSearchResetTime
		      THIS.cSearchText = ''
		    ENDIF
		    THIS.nLastSearch = SECONDS()
		  ENDIF
		
		  * If there is a primary workarea specified for the grid, and we have a 
		  * field to search on, then proceed with the incremental search.
		  IF NOT EMPTY(THIS.cWorkarea) AND TYPE(THIS.cSearchField) $ 'CMDNIY'
		    DO CASE
		      CASE m.cChar = CHR(7)
		        THIS.cSearchText = ''
		      CASE m.cChar = CHR(127)
		        THIS.cSearchText = LEFT(THIS.cSearchText, MAX(0, LEN(THIS.cSearchText) -1))
		      OTHERWISE  && Add character to Search String
		        THIS.cSearchText = THIS.cSearchText + m.cChar
		    ENDCASE
		
		    * Set flag so AfterRowColChange() knows we are in an I-search.
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_SEARCHING)
		
		    IF NOT EMPTY(THIS.cSearchText)
		      m.cField = THIS.cSearchField
		      m.nRecno = RECNO()
		      SELECT (THIS.cWorkarea)
		      IF NOT THIS.Search(@m.cField, UPPER(THIS.cSearchText))
		        * If search failed, remove most recently added character and restore original record.
		        THIS.cSearchText = LEFT(THIS.cSearchText, MAX(0, LEN(THIS.cSearchText) -1))
		        GOTO m.nRecno
		        ?? CHR(7)
		      ENDIF
		      THIS.Refresh()
		    ENDIF
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SEARCHING)
		    RETURN THIS.AfterIncrementalSearch()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE init
		*++
		* CodeMine Foundation Grid control class
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('nRight', .NULL.)               && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)              && Offset of bottom edge from bottom of parent container.
		  THIS.AddProperty('nBackColor', .NULL.)           && Holds original background color for This.ShowControl()
		  THIS.AddProperty('nCurrentRecno', 0)             && Current record number
		  THIS.AddProperty('nControlFlags', 0)             && Internal flags used to set and determine the state of this control.
		  THIS.AddProperty('nTargetCol', 0)                && Target column for next SetFocus() call.
		  THIS.AddProperty('nLastSearch', 0)               && Used for incremental searchs
		
		  * The cWorkarea property enables CodeMine grid extensions for RecordSourceType 1.
		  * Set to NULL to disable Codemine extensions.
		  IF THIS.RecordSourceType = 1 AND NOT ISNULL(THIS.cWorkarea)
		    IF EMPTY(THIS.cWorkarea) AND NOT EMPTY(THIS.RecordSource)
		      THIS.cWorkarea = PROPER(THIS.RecordSource)
		    ENDIF
		
		    IF NOT EMPTY(THIS.cWorkarea)
		      ASSERT EMPTY(THIS.LinkMaster) AND EMPTY(THIS.ChildOrder) AND EMPTY(THIS.RelationalExpr) MESSAGE ;
		        "LinkMaster, ChildOrder, and RelationalExpr properties must all be empty unless cWorkarea is set to .NULL."
		
		      * Implement our own improved append-at-end feature
		      IF THIS.AllowAddNew
		        THIS.lAllowAutoAppend = .T.
		        THIS.AllowAddNew = .F.
		      ENDIF
		    ENDIF
		  ELSE
		    THIS.cWorkarea = ''
		  ENDIF
		
		  IF THIS.ColumnCount > 0
		    LOCAL oCol
		    * Save original column widths.
		    FOR EACH oCol IN THIS.Columns
		      m.oCol.AddProperty('_nOriginalWidth', m.oCol.Width)
		
		      * Localize the header captions if desired
		      IF THIS.lLocalizeCaption AND NOT ISNULL(THISFORM.oMessage)
		        m.oCol.Controls[1].Caption = THISFORM.oMessage.Localize(m.oCol.Controls[1].Caption)
		      ENDIF
		    ENDFOR
		  ENDIF
		
		  THIS.cReadonlyDisplay = UPPER(THIS.cReadonlyDisplay)
		  THIS.ShowControl()
		
	ENDPROC

	PROCEDURE refresh
		*++
		* Redisplay the grid in correct colors
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF PEMSTATUS(THIS, 'nControlFlags', 5)
		    * Restore stored column widths if memory is enabled, on the first refresh. We do 
		    * this here instead of during Init() for better column memory with Stretchy control.
		    IF THIS.lColumnMemory AND NOT BITTEST(THIS.nControlFlags, CTLFLAG_INITIALIZED)
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_INITIALIZED)
		      THIS.RestoreColumnWidths()
		    ENDIF
		
		    * Grid can get stuck at EOF() after deleting an appended record, so try to fix it here.
		    DODEFAULT()
		    IF NOT EMPTY(THIS.cWorkarea)
		      IF EOF(THIS.cWorkarea)
		        THIS.ActivateCell(1, THIS.RelativeColumn)
		        GOTO BOTTOM IN (THIS.cWorkarea)
		      ENDIF
		      THIS.nCurrentRecno = IIF(EOF(THIS.cWorkarea), 0, RECNO(THIS.cWorkarea))
		    ENDIF
		    THIS.ShowControl()
		  ENDIF
		
	ENDPROC

	PROCEDURE resize
		*++
		* Adjust column widths to fill new grid size if "Column Stretch" is enabled.
		*--
		LOCAL ix, oCol, nGap, nAdjust, nColWidth
		
		  IF 'CSTRETCH' $ UPPER(THIS.cReposition)
		    m.nColWidth = IIF(THIS.ScrollBars >= 2, SYSMETRIC(5), 0) + IIF(THIS.DeleteMark, 8, 0) + IIF(THIS.RecordMark, 10, 0)
		    IF THIS.ColumnCount > 0
		      FOR EACH oCol IN THIS.Columns
		        m.nColWidth = m.nColWidth + m.oCol.Width + 1
		      ENDFOR
		    ENDIF
		
		    m.nGap = THIS.Width - m.nColWidth
		    IF m.nGap != 0
		      m.nAdjust = INT(m.nGap / THIS.ColumnCount)
		      m.nGap = m.nGap - (m.nAdjust * THIS.ColumnCount)
		      FOR ix = 1 to THIS.ColumnCount - 1
		        THIS.Columns[m.ix].Width = MAX(THIS.Columns[m.ix].Width + m.nAdjust, 5)
		      ENDFOR
		      THIS.Columns[m.ix].Width = MAX(THIS.Columns[m.ix].Width + m.nAdjust + m.nGap - 3, 5)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE restorecolumnwidths		&& Restore columns widths and order from saved values.
		*++
		*>>Restore columns widths and order from saved values.
		*--
		LOCAL ix, nWidth, cWidths
		  * Restore stored column widths if memory is enabled.
		  IF THIS.ColumnCount != 1 AND NOT ISNULL(THISFORM.oApp)
		    IF PEMSTATUS(THISFORM, 'cSysRegFormRoot', 5)
		      IF EMPTY(THIS.cMemoryKeyRoot)
		        THIS.cMemoryKeyRoot = THISFORM.cSysRegFormRoot + '\ControlMemory\'
		      ENDIF
		
		      * Restore column widths
		      IF THISFORM.oApp.GetPreference(THIS.cMemoryKeyRoot + 'ColWidths\' + SYS(1272, THIS), @m.cWidths)
		        FOR EACH oCol IN THIS.Columns
		          IF NOT EMPTY(m.cWidths)
		            m.nWidth = VAL(GetToken(@m.cWidths, ','))
		            m.oCol.Width = m.nWidth
		          ENDIF
		        ENDFOR
		      ENDIF
		
		      * Restore saved column order
		      IF THISFORM.oApp.GetPreference(THIS.cMemoryKeyRoot + 'ColOrder\' + SYS(1272, THIS), @m.cWidths)
		        IF NOT EMPTY(m.cWidths)
		          FOR ix = 1 TO MIN(LEN(m.cWidths), THIS.ColumnCount)
		            THIS.Columns[ASC(SUBSTR(m.cWidths, m.ix, 1))].ColumnOrder = m.ix
		          ENDFOR
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE restorelayout		&& Rebuild column data bindings after RecordSource cursor is changed, using values saved by SaveLayout().
		LPARAMETERS cRecordSource
		*++
		*>>Rebuild column data bindings after RecordSource cursor is changed, using values saved by SaveLayout().
		*--
		LOCAL ix
		  IF PEMSTATUS(THIS, 'cSavedRecordSource', 5)
		    WITH THIS
		      .RecordSource = IIF(EMPTY(m.cRecordSource), .cSavedRecordSource, m.cRecordSource)
		      IF .ColumnCount > 0
		        FOR ix = 1 TO MIN(.ColumnCount, ALEN(.aSavedControlSource, 1))
		          .Columns[m.ix].Controlsource = .aSavedControlSource[m.ix]
		        ENDFOR
		      ENDIF
		    ENDWITH
		  ENDIF
		
	ENDPROC

	PROCEDURE rightclick
		*++
		* Put up grid context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE savecolumnwidths		&& Save columsn widths for next time grid is created.
		*++
		*>>Save columsn widths for next time grid is created.
		*--
		LOCAL ix, cWidths
		  IF THIS.ColumnCount != 1 AND NOT ISNULL(THISFORM.oApp)
		    m.cWidths = ''
		    FOR ix = 1 TO THIS.ColumnCount
		      m.cWidths = m.cWidths + LTRIM(STR(THIS.Columns[m.ix].Width)) + ','
		    ENDFOR
		    THISFORM.oApp.SetPreference(THIS.cMemoryKeyRoot + 'ColWidths\' + SYS(1272, THIS), m.cWidths)
		
		    * Save column orders. This must be done in a particular way, so lowest ordered columns are always restored first.
		    m.cWidths = SPACE(THIS.ColumnCount)
		    FOR ix = 1 TO THIS.ColumnCount
		      m.cWidths = STUFF(m.cWidths, THIS.Columns[m.ix].ColumnOrder, 1, CHR(m.ix))
		    ENDFOR
		
		    * This is actually a binary encoded string value.
		    THISFORM.oApp.SetPreference(THIS.cMemoryKeyRoot + 'ColOrder\' + SYS(1272, THIS), m.cWidths)
		  ENDIF
		
	ENDPROC

	PROCEDURE savelayout		&& Save current column ControlSource's and clear the RecordSource for the grid in preparation for setting a new RecordSource.
		*++
		*>>Save current column ControlSource's and clear the RecordSource for the grid in preparation for setting a new RecordSource.
		*--
		LOCAL ix
		  WITH THIS
		    .AddProperty('cSavedRecordSource', .RecordSource)
		    .AddProperty('aSavedControlSource[1]')
		    IF .ColumnCount > 0
		      DIMENSION .aSavedControlSource[.ColumnCount]
		      FOR ix = 1 TO .ColumnCount
		        .aSavedControlSource[m.ix] = .Columns[m.ix].Controlsource
		      ENDFOR
		    ENDIF
		    .RecordSource = .NULL.
		  ENDWITH
		
	ENDPROC

	PROCEDURE search		&& Search the cursor for the first record where the specified field matches the specified value. Used by the Incremental search feature.
		LPARAMETERS cField, cValue
		*++
		*>>Search the cursor for the first record where the specified field matches the specified value. Used by the Incremental search feature.
		*--
		LOCAL lExact
		  m.lExact = (SET('EXACT') == 'ON')
		  SET EXACT OFF
		  DO CASE
		    CASE TYPE(m.cField) $ 'CM'
		      LOCATE FOR UPPER(&cField) = m.cValue
		    CASE TYPE(m.cField) $ 'DT'
		      LOCATE FOR DTOC(&cField) = m.cValue
		    CASE TYPE(m.cField) $ 'NIY'
		      LOCATE FOR LTRIM(STR(&cField, 18, 5)) = m.cValue
		    OTHERWISE
		      * Unsupported data type, do nothing.
		  ENDCASE
		  IF m.lExact
		    SET EXACT ON
		  ENDIF
		  RETURN FOUND()
		
	ENDPROC

	PROCEDURE setfocus
		*++
		* Set focus to a particular column, if one is set in the nTargetCol property.
		*--
		  IF NOT EMPTY(THIS.nTargetCol)
		    THIS.Columns[THIS.nTargetCol].SetFocus()
		  ENDIF
		
	ENDPROC

	PROCEDURE showcontrol		&& Redisplay the grid with appropriate background color per readonly status
		*++
		*>>Redisplay the grid with appropriate background color per readonly status
		*--
		LOCAL lOldWriteLock
		  IF NOT EMPTY(THIS.cWorkarea)
		    * Update the lWritelock property to match ReadOnly, so form methods 
		    * that query it will get accurate results.
		    m.lOldWriteLock = THIS.lWriteLock
		    THIS.lWriteLock = THIS.ReadOnly
		
		    * Check for no data or Write-Protect (explicit edit mode).
		    * Check for workarea used first, for cases where recordsource is assigned dynamically.
		    IF NOT THIS.lWriteLock AND USED(THIS.cWorkarea)
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea, '')
		    ENDIF
		
		    * Apply or remove readonly display effect if read-only condition changed.
		    IF m.lOldWriteLock != THIS.lWriteLock
		      IF 'DIM' $ THIS.cReadOnlyDisplay
		        IF THIS.lWriteLock
		          IF ISNULL(THIS.nBackColor)
		            THIS.nBackColor = THIS.BackColor
		          ENDIF
		          IF ISNULL(THIS.nReadOnlyBackColor)
		            THIS.nReadOnlyBackColor = THIS.Parent.BackColor
		          ENDIF
		          THIS.BackColor = THIS.nReadOnlyBackColor
		        ELSE
		          IF NOT ISNULL(THIS.nBackColor)
		            THIS.BackColor = THIS.nBackColor
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE showwhatsthis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the grid.
		*--
		LOCAL nCol, oTarget
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT
		
		      * If we are called via WhatsThis cursor or F1 Key, send help request to active control, if any.
		      IF NOT EMPTY(THIS.cWorkarea)
		        m.oTarget = .NULL.
		        IF cmLastKey() = -1   && If mouse is down, its a WhatsThis cursor click, find column under cursor.
		          m.oTarget = SYS(1270)
		          IF TYPE('m.oTarget.Baseclass') != 'C' OR NOT m.oTarget.Baseclass == 'Column'
		            m.oTarget = .NULL.
		          ENDIF
		        ENDIF
		
		        * If no column found yet, use active column, if any.
		        IF ISNULL(m.oTarget) AND NOT EMPTY(THIS.Activecolumn)
		          m.nCol = THIS.ColumnOrderToIndex(THIS.ActiveColumn)
		          m.oTarget = THIS.Columns[m.nCol]
		        ENDIF
		
		        * Find active control in target column, and call its help method.
		        IF NOT ISNULL(m.oTarget)
		          m.oTarget = m.oTarget.Controls[2]
		          IF PEMSTATUS(m.oTarget, 'ShowWhatsThis', 5)
		            RETURN m.oTarget.ShowWhatsThis()
		          ENDIF
		        ENDIF
		      ENDIF
		      THISFORM.DisplayHelp(THIS)    && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE uienable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  * Pages in Forms instaniated from a VCX trigger UIenable events for the initial active
		  * page, before the form is visible. We ignore these events.
		  IF m.lEnableEvent AND THISFORM.Visible
		    THIS.Refresh()  && Make sure grid is displaying current record set
		  ENDIF
		
	ENDPROC

	PROCEDURE valid
		*++
		* If the current control in the grid is unable to pass validation, 
		* don't let focus off the grid.
		*--
		LOCAL oRef, nCol, uStatus
		
		  m.uStatus = .T.
		  * VFP 6 does not properly enforce validation failure for ctls in a grid, so 
		  * we take care of it here, to prevent focus leaving the grid on valida failure.
		  * Problem seems to be fixed in VFP 7.0
		  IF VERSION(5) < 700 AND THIS.ActiveColumn > 0 AND NOT BITTEST(THISFORM.nControlFlags, FRMFLAG_SKIP_VALID)
		    m.nCol = THIS.ColumnOrderToIndex(THIS.ActiveColumn)
		    m.oRef = THIS.Columns[m.nCol]
		    m.oRef = EVALUATE('m.oRef.' + m.oRef.CurrentControl)
		    IF PEMSTATUS(m.oRef, 'lChanged', 5)
		      IF m.oRef.lChanged
		        m.uStatus = m.oRef.Valid()
		      ENDIF
		    ENDIF
		    m.oRef = .NULL.
		  ENDIF
		  RETURN m.uStatus
		
	ENDPROC

	PROCEDURE when
		*++
		*>>Default When method prevents off-screen objects from getting focus.
		*--
		  IF TYPE('THISFORM') = 'O'
		    IF PEMSTATUS(THISFORM, 'InitializeHelp', 5)
		      THISFORM.InitializeHelp(THIS)
		    ENDIF
		    IF PEMSTATUS(THISFORM, 'ScrollBars', 5)
		      IF THISFORM.ScrollBars != 0
		        RETURN .T.
		      ENDIF
		    ENDIF
		    RETURN THISFORM.ScaleMode != 3 OR (OBJTOCLIENT(THIS, 1) < THISFORM.Height AND OBJTOCLIENT(THIS, 2) < THISFORM.Width)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS imgimage AS image 		&& CodeMine base Image display class.
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	*</DefinedPropArrayMethod>

	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	Name = "imgimage"
	
	PROCEDURE contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.ContextMenuBuild()
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.ContextMenuExecute(m.cOption)
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Impliment standard error handling
		*--
		LOCAL cMsg
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE init
		*++
		* CodeMine foundation Image class
		*
		* Copyright 1996-2002 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('nRight', .NULL.)               && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)              && Offset of bottom edge from bottom of parent container.
		
	ENDPROC

	PROCEDURE rightclick
		*++
		*>>Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		    m.cOption = THISFORM.ContextMenuActivate()
		    IF NOT EMPTY(m.cOption)
		      THIS.ContextMenuExecute(m.cOption)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE showwhatsthis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the image control.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                  && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS) && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS lblfieldlabel AS lbltext OF "codemine.vcx" 		&& CodeMine field label text.
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\flabel.bmp" ClassIcon="..\graphics\flabel.bmp" />

	#INCLUDE "codemine.h"
	alignment = 1
	Name = "lblfieldlabel"

ENDDEFINE

DEFINE CLASS lbllabel AS lbltext OF "codemine.vcx" 		&& CodeMine Label class with custom 3D Effects.
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\label3d.bmp" ClassIcon="..\graphics\label3d.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: moved
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*p: ccustomeffect		&& Special effect to create. Valid options are: Raised, Inset, Accent, Shadow or Light
		*p: noffset		&& Number of pixels shadow and highlight text is offset from base text.
	*</DefinedPropArrayMethod>

	autosize = .T.
	ccustomeffect = 		&& Special effect to create. Valid options are: Raised, Inset, Accent, Shadow or Light
	Name = "lbllabel"
	noffset = 1		&& Number of pixels shadow and highlight text is offset from base text.
	
	PROCEDURE init
		*++
		* Codemine foundation label control with dynamic 3D effects
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  DODEFAULT()
		  IF NOT EMPTY(THIS.cCustomEffect)
		    LOCAL cName, nOffset, nOldScale, oParent
		
		    m.nOldScale = THISFORM.scaleMode
		    IF THISFORM.scaleMode != 3
		      THISFORM.scaleMode = 3  && Pixels
		    ENDIF
		
		    * Add Light object for Raised effect.
		    IF INLIST(PROPER(THIS.cCustomEffect), 'Raised', 'Inset', 'Light', 'Accent')
		      m.cName = THIS.name + '_Light__'
		      THIS.parent.NewObject(m.cName, 'lblText', 'codemine.vcx')
		      WITH EVALUATE('THIS.parent.' + m.cName)
		        .Width = THIS.Width
		        .Height = THIS.Height
		        .BackStyle = 0
		        .FontName = THIS.FontName
		        .FontSize = THIS.FontSize
		        .FontBold = THIS.FontBold
		        .FontItalic = THIS.FontItalic
		        .AutoSize = THIS.AutoSize
		        .Alignment = THIS.Alignment
		        .WordWrap = THIS.WordWrap
		        .Forecolor = GetSysColor(COLOR_BTNHIGHLIGHT)
		        IF PROPER(THIS.cCustomEffect) = 'Inset'
		          .Top = THIS.Top + THIS.nOffset
		          .Left = THIS.Left + THIS.nOffset
		        ELSE  && Raised, Light, Accent
		          .Top = THIS.Top - THIS.nOffset
		          .Left = THIS.Left - THIS.nOffset
		        ENDIF
		        .Visible = .T.
		      ENDWITH
		    ENDIF
		
		    * And a new face on top
		    IF INLIST(PROPER(THIS.cCustomEffect), 'Raised', 'Accent', 'Inset', 'Shadow')
		      m.cName = THIS.name + '_Face__'
		      THIS.parent.NewObject(m.cName, 'lblText', 'codemine.vcx')
		      WITH EVALUATE('THIS.parent.' + m.cName)
		        .Top = THIS.Top
		        .Left = THIS.Left
		        .Width = THIS.Width
		        .Height = THIS.Height
		        .BackStyle = 0
		        .FontName = THIS.FontName
		        .FontSize = THIS.FontSize
		        .FontBold = THIS.FontBold
		        .FontItalic = THIS.FontItalic
		        .AutoSize = THIS.AutoSize
		        .Alignment = THIS.Alignment
		        .WordWrap = THIS.WordWrap
		        IF PROPER(THIS.cCustomEffect) = 'Accent'
		          .ColorSource = 0
		          .Forecolor = GetSysColor(COLOR_ACTIVECAPTION)
		        ELSE
		          .ColorSource = THIS.ColorSource
		          .Forecolor = THIS.Forecolor
		        ENDIF
		        .Visible = .T.
		      ENDWITH
		    ENDIF
		
		    * Move original up or down by offset to become the shadow.
		    IF PROPER(THIS.cCustomEffect) = 'Inset'
		      THIS.top = THIS.Top - THIS.nOffset
		      THIS.Left = THIS.Left - THIS.nOffset
		    ELSE    && Raised or Shadow
		      THIS.top = THIS.Top + THIS.nOffset
		      THIS.Left = THIS.Left + THIS.nOffset
		    ENDIF
		    THIS.Enabled = .T.
		    THIS.BackStyle = 0
		    THIS.ColorSource = 0
		    
		    * Determine the best color to use for the shadow.
		    THIS.Forecolor = GetSysColor(COLOR_BTNSHADOW)
		    THISFORM.ScaleMode = m.nOldScale
		
		    THIS.Set('Caption', THIS.Caption)
		  ENDIF
		
	ENDPROC

	PROCEDURE moved
		*++
		* Update shadow and highlight position when label is moved.
		* Called by the form.RepositionContents() method after a form resize.
		*--
		LOCAL cName
		
		  * Update face position
		  IF NOT EMPTY(THIS.cCustomEffect) ;
		  AND INLIST(PROPER(THIS.cCustomEffect), 'Raised', 'Inset', 'Accent', 'Light', 'Shadow')
		    IF PROPER(THIS.cCustomEffect) != 'Light'
		      m.cName = THIS.Name + '_Face__'
		      WITH THIS.parent.&cName
		        IF PROPER(THIS.cCustomEffect) = 'Inset'
		          .Top = THIS.Top + THIS.nOffset
		          .Left = THIS.Left + THIS.nOffset
		        ELSE    && Raised or Shadow
		          .Top = THIS.Top - THIS.nOffset
		          .Left = THIS.Left - THIS.nOffset
		        ENDIF
		        .Width = THIS.Width
		      ENDWITH
		    ENDIF
		
		    * and update Highlight position if present
		    IF PROPER(THIS.cCustomEffect) != 'Shadow'
		      m.cName = THIS.name + '_Light__'
		      WITH THIS.parent.&cName
		        IF PROPER(THIS.cCustomEffect) = 'Inset'
		          .Top = THIS.Top + THIS.nOffset * 2
		          .Left = THIS.Left + THIS.nOffset * 2
		        ELSE    && Raised or Shadow
		          .Top = THIS.Top - THIS.nOffset * 2
		          .Left = THIS.Left - THIS.nOffset * 2
		        ENDIF
		        .Width = THIS.Width
		      ENDWITH
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		* Used primarily to update Visible and Caption properties for controls with 3D effects.
		*--
		LOCAL cName
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'caption' $ m.cProperty
		      THIS.Caption = m.uValue
		
		    CASE 'visible' $ m.cProperty
		      THIS.Visible = m.uValue
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		      RETURN .T.
		  ENDCASE
		
		  IF NOT EMPTY(THIS.cCustomEffect)
		    * Update Highlight text
		    IF INLIST(PROPER(THIS.cCustomEffect), 'Raised', 'Inset', 'Accent', 'Light')
		      m.cName = THIS.name + '_Light__'
		      THIS.parent.&cName..Caption = THIS.Caption
		      THIS.parent.&cName..Visible = THIS.Visible
		    ENDIF
		
		    * And face text 
		    IF INLIST(PROPER(THIS.cCustomEffect), 'Raised', 'Inset', 'Accent', 'Shadow')
		      m.cName = THIS.name + '_Face__'
		      THIS.parent.&cName..Caption = THIS.Caption
		      THIS.parent.&cName..Visible = THIS.Visible
		    ENDIF
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS lbltext AS label 		&& CodeMine Simple Text Label.
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
	*</DefinedPropArrayMethod>

	backstyle = 0
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	Name = "lbltext"
	
	PROCEDURE contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.ContextMenuBuild()
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.ContextMenuExecute(m.cOption)
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Fatal coding error - Pass it on to CodeMine Application error handler if available.
		*--
		LOCAL cMsg
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE init
		*++
		* CodeMine foundation label class
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  * Localize the caption if localization is enabled
		  IF THIS.lLocalizeCaption AND NOT ISNULL(THISFORM.oMessage)
		    THIS.Caption = THISFORM.oMessage.Localize(THIS.Caption)
		  ENDIF
		
	ENDPROC

	PROCEDURE refresh
		*++
		*>>Set new caption value.
		*--
		
	ENDPROC

	PROCEDURE rightclick
		*++
		*>>Put up label context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE showwhatsthis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the label.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                        && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS)       && Display help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS linline AS line 		&& CodeMine base Line class.
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	*</DefinedPropArrayMethod>

	bordercolor = 0,0,0
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	Name = "linline"
	
	PROCEDURE init
		*++
		* CodeMine foundation Line class
		*
		* Copyright 1996-2002 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('nRight', .NULL.)               && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)              && Offset of bottom edge from bottom of parent container.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS lstlistbox AS listbox 		&& CodeMine foundation listbox class.
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*m: applysecurity		&& Evaluate security access for the control.
		*m: beforechange		&& Determine if it is OK to interactively change the control's value.
		*m: contextmenubuild		&& Define custom bars for a listbox context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: fieldvalid		&& Field level validation code goes here.
		*m: formvalid		&& Form level ListBox validation code goes here. Must return .T. before changes can be committed.
		*m: getvalue		&& Return the control's current value
		*m: loadmemory		&& Load listbox value from stored memory.
		*m: loadtranslation		&& Translate bound data value into a format suitable for display.
		*m: loadvalue		&& Load listbox value property from cValuesource.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: setvalue		&& Set the listbox control's value
		*m: showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*m: storememory		&& Save current value for later use.
		*m: storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		*m: storevalue		&& Write listbox value back to bound data source using table or memvar syntax as appropriate.
		*m: undochanges		&& Undo changes to the current control, and restore original value.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpclasskey		&& List of class help keys for this class.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: clinkedlabel		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cvaluesource		&& Data source bound to this control.
		*p: cviewparameter		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
		*p: cworkarea		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lautoremember		&& When true and lValueMemory is also true, most recently entered value is remembered.
		*p: lchanged		&& Set to true if data was changed interactively.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: lnativebinding		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
		*p: lnoinitdata		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
		*p: lreadlock		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
		*p: lreadonly		&& When true, Control value cannont be edited interactively.
		*p: lrequired		&& If true, a non-zero value must be entered before changes can be saved.
		*p: lvaluememory		&& When true, control's value can be remembered and restored under user control.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
	*</DefinedPropArrayMethod>

	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpclasskey = 		&& List of class help keys for this class.
	chelpkey = 		&& Name of context help message key for this field.
	clinkedlabel = 		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	creadonlydisplay = Dim		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cvaluesource = 		&& Data source bound to this control.
	cviewparameter = 		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
	cworkarea = 		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	IntegralHeight = .T.
	lautoremember = .T.		&& When true and lValueMemory is also true, most recently entered value is remembered.
	lchanged = .F.		&& Set to true if data was changed interactively.
	lenabled = .T.		&& Specifies desired enable state for the control.
	lnativebinding = .F.		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
	lnoinitdata = .F.		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
	lreadlock = .F.		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
	lreadonly = .F.		&& When true, Control value cannont be edited interactively.
	lrequired = .F.		&& If true, a non-zero value must be entered before changes can be saved.
	lvaluememory = .F.		&& When true, control's value can be remembered and restored under user control.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "lstlistbox"
	
	PROCEDURE afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*++
		*>>Method called after the control value has been successfuly changed and valuesource is updated.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE applysecurity		&& Evaluate security access for the control.
		*++
		*>>Evaluate security access for the control.
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  * If its not readable, its not writable either.
		  IF THIS.lReadLock
		    THIS.lWriteLock = .T.
		  ELSE
		    IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		      THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE beforechange		&& Determine if it is OK to interactively change the control's value.
		*++
		*>>Determine if it is OK to interactively change the control's value.
		* Sets the lChanged flag for the control on success.
		*--
		  RETURN THISFORM.cmBindingManager.BeforeChange(THIS)
		
	ENDPROC

	PROCEDURE Click
		*++
		*>>Process Missed change events - where click() is called, but not InteractiveChange().
		*--
		  IF NOT THIS.nLastIndex = THIS.ListIndex
		    THIS.InteractiveChange()
		  ENDIF
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define custom bars for a listbox context menu. Return false if no bars are defined.
		*++
		*>>Define custom bars for a listbox context menu. Return false if no bars are defined.
		*--
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.cmBindingManager.ContextMenuExecute(THIS, m.cOption)
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Listbox Errors. Record rule (1583) applys here only if no buffering.
		*--
		LOCAL cMsg
		
		  m.cMsg = MESSAGE()
		  DO CASE
		    CASE INLIST(m.nError, 12, 13, 1734, 1925) AND NOT THIS.lNativeBinding AND '.controlsource' $ LOWER(m.cMethod)
		      * Ignore ControlSource Errors during Init.
		      RETURN .T.
		
		    CASE INLIST(m.nError, 1581,1582,1583) AND THIS.lNativeBinding
		      * DBC rule violated (1581,1582,1583) applies here only if lNativeBinding is set.
		      RETURN .T.
		
		    CASE m.nError = 1925 AND SYS(2018) == 'CMBINDINGMANAGER'
		      * Handle BindMan not found errors gracefuly. Usually this only will happen in a VCX based form
		      * with BindMan placed onthe form at design time, higher in the Z order than bound controls.
		      * Init method will fail in this case, and control will not be created.
		      MESSAGEBOX('No Binding Manager, or too high in Z order', 48, THIS.Name)
		      RETURN .T.
		  ENDCASE
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE fieldvalid		&& Field level validation code goes here.
		*++
		*>>Field level validation code goes here.
		* Success return: .T. or n != 0
		* Failure return: .F., 0
		*--
		LOCAL lRequired
		  m.lRequired = THIS.lRequired
		  * If we are bound to a cursor field, and in a form with a data manager, evaluate the IsRequiredRule().
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		      m.lRequired = m.lRequired OR THISFORM.cmDataManager.IsRequired(THIS.cWorkarea, SUBSTR(THIS.cValueSource, RAT('.', THIS.cValueSource) + 1))
		    ENDIF
		  ENDIF
		  IF m.lRequired AND EMPTY(THIS.Value)
		    THISFORM.DisplayMessage('%msgFieldRequired', THISFORM.NiceName(THIS))
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE formvalid		&& Form level ListBox validation code goes here. Must return .T. before changes can be committed.
		*++
		*>>Form level ListBox validation code goes here. Must return .T. before changes can be committed.
		* Success return: .T.
		* Failure return: .F.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getvalue		&& Return the control's current value
		*++
		*>>Return the control's current value
		*--
		  RETURN THIS.Value
		
	ENDPROC

	PROCEDURE GotFocus
		* Save the undo value for the control, if it has not yet been modified.
		  THISFORM.cmBindingManager.GotFocus(THIS)
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Foundation Listbox control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  * Make sure binding manager is instantiated.
		  IF NOT PEMSTATUS(THISFORM, 'cmBindingManager', 5)
		    THISFORM.AddObject('cmBindingManager', 'cmBindingManagerCustom')
		  ENDIF
		
		  * Process common data-bound control binding initialization.
		  IF NOT THISFORM.cmBindingManager.InitBinding(THIS)
		    RETURN .F.    && This line will also execute if above "IF" generates error.
		  ENDIF
		
		  * Custom property used to detect missed row move events.
		  THIS.AddProperty('nLastIndex', 0)
		
	ENDPROC

	PROCEDURE InteractiveChange
		*++
		*>>Intercept all change attempts, enforce security, and secure locks as needed.
		* Return .T. if the change was accepted, .F. if it was rejected and original value restored.
		*--
		  * Call the valid method whenever the value changes, unless multiselect is enabled.
		  IF NOT THIS.MultiSelect AND EMPTY(THIS.Valid())
		    THIS.UndoChanges()
		    RETURN .F.
		  ENDIF
		  THIS.nLastIndex = THIS.ListIndex
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Key processing for listboxes.
		* Filter out keys that change value in read-only mode.
		*--
		  IF m.nShiftAltCtrl = 0 AND m.nKeyCode = 22 && Insert mode toggle
		    =INSMODE(NOT INSMODE())
		    NODEFAULT
		  ELSE
		    * Call change handler here for most common keys, so message is displayed on errors.
		    IF INLIST(m.nKeyCode, 18, 3, 5, 24, 1, 6) AND NOT THIS.BeforeChange()
		      NODEFAULT
		    ELSE
		      IF THIS.lWriteLock AND NOT INLIST(m.nKeyCode, 9, 15, 27, 4, 19, 10)
		        NODEFAULT
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE loadmemory		&& Load listbox value from stored memory.
		*++
		*>>Load listbox value from stored memory.
		* Return .T. if there was a value stored in memory.
		*--
		  RETURN THISFORM.cmBindingManager.LoadMemory(THIS)
		
	ENDPROC

	PROCEDURE loadtranslation		&& Translate bound data value into a format suitable for display.
		LPARAMETERS uValue
		*++
		*>>Translate bound data value into a format suitable for display.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE loadvalue		&& Load listbox value property from cValuesource.
		*++
		*>>Load listbox value property from cValuesource.
		*--
		  LOCAL uValue
		  IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)
		    THIS.Value = m.uValue
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE LostFocus
		* Clear the default VFP workarea alias text from the status bar
		  IF VERSION(2) = 0
		    TRY 
		       SET MESSAGE TO ''
		       IF m.goApp.lCloudServer
		          _VFP.StatusBar = 'Company Name: ' + proper(m.goapp.cCompanyName) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ELSE
		          _VFP.StatusBar = 'Data Path: ' + LOWER(m.goapp.cdatafilepath) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ENDIF    
		    CATCH
		    ENDTRY    
		  ENDIF
		
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Ignore Left-clicks if listbox is read-only. This prevents the list
		* contents from poping up.
		*--
		  * Only trap clicks in the data area, not in the scroll bar.
		  IF THIS.lWriteLock AND m.nXCoord < THIS.Left + THIS.Width - SYSMETRIC(5)
		    IF m.nButton = 2
		      THIS.RightClick()   && Put up the context menu even when read-only
		    ELSE
		      ??CHR(7)
		    ENDIF
		    NODEFAULT
		  ENDIF
		
	ENDPROC

	PROCEDURE Refresh
		*++
		* Reinitialize display buffers from list's data source.
		*--
		  DODEFAULT()   && Do default listbox refresh first, in case rowsource has changed.
		
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    THISFORM.cmBindingManager.InitBinding(THIS)
		  ENDIF
		
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_VALUE_LOADED) ;
		  OR BITTEST(THISFORM.nControlFlags, FRMFLAG_FORCE_RELOAD)
		    THIS.ShowControl()
		    THIS.LoadValue()
		    IF THIS.lValueMemory
		      THISFORM.cmBindingManager.DefaultFromMemory(THIS)
		    ENDIF
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		
	ENDPROC

	PROCEDURE RightClick
		*++
		* Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    * Use the binding manager to put up common control context menus. This will make a callback
		    * to owr own ContextMenuBuild() method to control-specific items.
		    IF THISFORM.ContextMenuInit(THIS) AND THISFORM.cmBindingManager.ContextMenuBuild(THIS)
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty   && lReadonly and ReadOnly
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    CASE m.cProperty = 'value'
		      RETURN THIS.SetValue(@m.uValue)
		
		    CASE INLIST(m.cProperty, 'cvaluesource', 'controlsource')
		      THIS.cWorkarea = ''
		      THIS.cValueSource = m.uValue
		      THISFORM.cmBindingManager.LoadWorkarea(THIS)
		
		      IF THIS.lNativeBinding
		        IF NOT THIS.Parent.Baseclass == 'Column' OR NOT THIS.Parent.Bound
		          THIS.ControlSource = m.uValue
		        ENDIF
		      ENDIF
		      THIS.Refresh()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setvalue		&& Set the listbox control's value
		LPARAMETERS uNewValue
		*++
		*>>Set the listbox control's value
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		  RETURN THISFORM.cmBindingManager.SetValue(THIS, @m.uNewValue)
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*++
		*>>Re-evaluate security access, and update control display to reflect current state.
		* Called by Init and refresh methods. Checking security is a little slow, so it is optional.
		*--
		LOCAL lOldWriteLock
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  m.lOldWriteLock = THIS.lWriteLock
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * Check for no data or Write-Protect (explicit edit mode).
		  IF NOT THIS.lWriteLock AND NOT EMPTY(THIS.cValueSource) ;
		  AND (NOT EMPTY(THIS.cWorkarea) OR NOT THISFORM.lIgnoreBoundProperties)
		    IF EMPTY(THIS.cWorkarea)
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed()  && Only pass workarea parameter if non-empty
		    ELSE
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea, SUBSTR(THIS.cValueSource, RAT('.', THIS.cValueSource) + 1))
		    ENDIF
		  ENDIF
		
		  * Apply or remove readonly display effect if read-only condition changed.
		  IF m.lOldWriteLock != THIS.lWriteLock
		    IF 'DIM' $ THIS.cReadOnlyDisplay
		      IF THIS.lWriteLock
		        IF ISNULL(THIS.nBackColor)
		          THIS.nBackColor = THIS.ItemBackColor
		        ENDIF
		        THIS.ItemBackColor = THIS.Parent.BackColor
		      ELSE
		        IF NOT ISNULL(THIS.nBackColor)
		          THIS.ItemBackColor = THIS.nBackColor
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Control is Disabled if readonly (optionaly), or if datasource is EOF().
		  IF THIS.lWriteLock AND 'DISABLE' $ THIS.cReadOnlyDisplay
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
		  * Update linked label control, if any.
		  IF NOT EMPTY(THIS.cLinkedLabel)
		    LOCAL oLabel
		    m.oLabel = EVALUATE('THIS.Parent.' + THIS.cLinkedLabel)
		    m.oLabel.Visible = THIS.Visible
		    m.oLabel.Refresh()
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the listbox.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                   && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS)  && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE storememory		&& Save current value for later use.
		*++
		*>>Save current value for later use.
		*--
		  RETURN THISFORM.cmBindingManager.StoreMemory(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		LPARAMETERS uValue
		*++
		*>>Translate control value into a format suitable for storage in bound data source.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE storevalue		&& Write listbox value back to bound data source using table or memvar syntax as appropriate.
		*++
		*>>Write listbox value back to bound data source using table or memvar syntax as appropriate.
		*--
		  RETURN THISFORM.cmBindingManager.StoreValue(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  IF m.lEnableEvent AND THISFORM.Visible
		    IF PEMSTATUS(THIS, 'nControlFlags', 5)
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		      THIS.Refresh()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE undochanges		&& Undo changes to the current control, and restore original value.
		*++
		*>>Undo changes to the current control, and restore original value.
		*--
		  IF EMPTY(THIS.cValueSource)
		    THIS.Value = THIS.uOriginalValue
		  ELSE
		    THIS.LoadValue()
		  ENDIF
		
		  * Update last-active index property
		  THIS.nLastIndex = THIS.ListIndex
		  THIS.lChanged = .F.
		
	ENDPROC

	PROCEDURE Valid
		*++
		*>>If listbox value has changed, call the FieldValid() event, and store value to datasource on success.
		*--
		LOCAL lStatus
		  * Call binding manager for common control valid() processing.
		  m.lStatus = THISFORM.cmBindingManager.Valid(THIS, .T.)
		  IF EMPTY(m.lStatus)
		    THIS.UndoChanges()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE When
		*++
		* Determine when the listbox control is allowed to receive focus.
		*--
		  IF TYPE('THISFORM') = 'O'
		    RETURN THISFORM.cmBindingManager.When(THIS)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS opgoptiongroup AS optiongroup 		&& CodeMine Option Group class.
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*m: applysecurity		&& Evaluate security access for the control.
		*m: beforechange		&& Determine if it is OK to interactively change the control's value.
		*m: contextmenubuild		&& Define all the bars for an optiongroup context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: fieldvalid		&& Field level validation code goes here.
		*m: formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*m: getvalue		&& Return the control's current value
		*m: gotfocus		&& Occurs when an object receives the focus, either by user action or through code.
		*m: loadmemory		&& Load OptionGroup value from stored memory.
		*m: loadtranslation		&& Translate bound data value into a format suitable for display.
		*m: loadvalue		&& Load value property from cValuesource.
		*m: lostfocus		&& Occurs when an object loses the focus.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: setfocus		&& Set Focus to the first option button in the group.
		*m: setvalue		&& Set the optiongroup control's value
		*m: showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*m: storememory		&& Save current value in system registry for later use.
		*m: storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		*m: storevalue		&& Write optiongroup value back to data source using table or memvar syntax as appropriate.
		*m: undochanges		&& Undo changes to the current control, and restore original value.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpclasskey		&& List of class help keys for this class.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: clinkedlabel		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Disable,Normal
		*p: creadprivilege		&& Privilege required to display data in this field.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cvaluesource		&& Data source bound to this control.
		*p: cviewparameter		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
		*p: cworkarea		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lallownull		&& Set True if null values can be entered into the control.
		*p: lautoremember		&& When true and lValueMemory is also true, most recently entered value is remembered.
		*p: lchanged		&& Set to true if data was changed interactively.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
		*p: lnativebinding		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
		*p: lnoinitdata		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
		*p: lreadlock		&& When true the control's value cannot be seen. Controled by the cReadPrivilege property.
		*p: lreadonly		&& When true the control's value cannont be edited interactively.
		*p: lrequired		&& If True a value must be entered before changes can be saved.
		*p: lvaluememory		&& When true, control's value can be remembered and restored under user control.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	ButtonCount = 0
	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpclasskey = 		&& List of class help keys for this class.
	chelpkey = 		&& Name of context help message key for this field.
	clinkedlabel = 		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	creadonlydisplay = Normal		&& Controls how read-only fields are handled. Options: Disable,Normal
	creadprivilege = 		&& Privilege required to display data in this field.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cvaluesource = 		&& Data source bound to this control.
	cviewparameter = 		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
	cworkarea = 		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	Height = 48
	lallownull = .F.		&& Set True if null values can be entered into the control.
	lautoremember = .T.		&& When true and lValueMemory is also true, most recently entered value is remembered.
	lchanged = .F.		&& Set to true if data was changed interactively.
	lenabled = .T.		&& Specifies desired enable state for the control.
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	lnativebinding = .F.		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
	lnoinitdata = .F.		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
	lreadlock = .F.		&& When true the control's value cannot be seen. Controled by the cReadPrivilege property.
	lreadonly = .F.		&& When true the control's value cannont be edited interactively.
	lrequired = .F.		&& If True a value must be entered before changes can be saved.
	lvaluememory = .F.		&& When true, control's value can be remembered and restored under user control.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "opgoptiongroup"
	Width = 74
	
	PROCEDURE afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*++
		*>>Method called after the control value has been successfuly changed and valuesource is updated.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE applysecurity		&& Evaluate security access for the control.
		*++
		*>>Evaluate security access for the control.
		* Responsible for setting THIS.lWriteLock and THIS.lReadLock
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  IF NOT EMPTY(THIS.cReadprivilege) AND NOT ISNULL(THISFORM.oSecurity)
		    THIS.lReadLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cReadPrivilege)
		  ENDIF
		
		  * If its not readable, its not writable either.
		  IF THIS.lReadLock
		    THIS.lWriteLock = .T.
		  ELSE
		    IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		      THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE beforechange		&& Determine if it is OK to interactively change the control's value.
		*++
		*>>Determine if it is OK to interactively change the control's value.
		* Sets the lChanged flag for the control on success.
		*--
		  RETURN THISFORM.cmBindingManager.BeforeChange(THIS)
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define all the bars for an optiongroup context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for an optiongroup context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.cmBindingManager.ContextMenuExecute(THIS, m.cOption)
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* OptionGroup Errors. Record rule (1583) applys here only if no buffering.
		*--
		LOCAL cMsg
		  m.cMsg = MESSAGE()
		
		  DO CASE
		    CASE INLIST(m.nError, 12, 13, 1734, 1925) AND NOT THIS.lNativeBinding AND '.controlsource' $ LOWER(m.cMethod)
		      * Ignore ControlSource Errors during Init.
		      RETURN .T.
		
		    CASE INLIST(m.nError, 1581,1582,1583) AND THIS.lNativeBinding
		      * DBC rule violated (1581,1582,1583) applies here only if lNativeBinding is set.
		      RETURN .T.
		
		    CASE m.nError = 1925 AND SYS(2018) == 'CMBINDINGMANAGER'
		      * Handle BindMan not found errors gracefuly. Usually this only will happen in a VCX based form
		      * with BindMan placed onthe form at design time, higher in the Z order than bound controls.
		      * Init method will fail in this case, and control will not be created.
		      MESSAGEBOX('No Binding Manager, or too high in Z order', 48, THIS.Name)
		      RETURN .T.
		  ENDCASE
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE fieldvalid		&& Field level validation code goes here.
		*++
		*>>Field level validation code goes here.
		* Success return: .T. or n != 0
		* Failure return: .F., 0
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*++
		*>>Form level control validation code goes here. Must return .T. before changes can be committed.
		* Success return: .T.
		* Failure return: .F.
		*--
		LOCAL lRequired
		  m.lRequired = THIS.lRequired
		  * If we are bound to a cursor field, and in a form with a data manager, evaluate the IsRequiredRule().
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		      m.lRequired = m.lRequired OR THISFORM.cmDataManager.IsRequired(THIS.cWorkarea, THIS.cValueSource)
		    ENDIF
		  ENDIF
		  IF m.lRequired AND EMPTY(NVL(THIS.GetValue(), ''))
		    THISFORM.DisplayMessage('%msgFieldRequired', THISFORM.NiceName(THIS))
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getvalue		&& Return the control's current value
		*++
		*>>Return the control's current value
		*--
		  RETURN THIS.Value
		
	ENDPROC

	PROCEDURE gotfocus		&& Occurs when an object receives the focus, either by user action or through code.
		  * Sadly, the GotFocus() event of an OPG container is not normally triggered in VFP,
		  * so this code will not run. The only real effect of this is that the undo value will not
		  * be set for unbound OptionGroups.
		  THISFORM.cmBindingManager.GotFocus(THIS)
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Foundation OptionGroup control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  * Make sure binding manager is instantiated.
		  IF NOT PEMSTATUS(THISFORM, 'cmBindingManager', 5)
		    THISFORM.AddObject('cmBindingManager', 'cmBindingManagerCustom')
		  ENDIF
		
		  * Keep a copy of current value to supress Valid() events when clicking on current button.
		  THIS.AddProperty('uLastValue', THIS.Value)
		
		  * Process common data-bound control binding initialization.
		  IF NOT THISFORM.cmBindingManager.InitBinding(THIS)
		    RETURN .F.    && This line will also execute if above "IF" generates error.
		  ENDIF
		
		  * Localize contained button captions if localization is enabled
		  IF THIS.lLocalizeCaption AND NOT ISNULL(THISFORM.oMessage)
		    LOCAL oButton
		    FOR EACH oButton IN THIS.Buttons
		      m.oButton.Caption = THISFORM.oMessage.Localize(m.oButton.Caption)
		    ENDFOR
		  ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		*++
		* Return .T. if the change was accepted, .F. if it was rejected and original value restored.
		*--
		  IF NOT THIS.lAllowNull AND EMPTY(THIS.Value)
		    ??CHR(7)
		    THIS.UndoChanges()
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE loadmemory		&& Load OptionGroup value from stored memory.
		*++
		*>>Load OptionGroup value from stored memory.
		* Return .T. if there was a value stored in memory.
		*--
		  RETURN THISFORM.cmBindingManager.LoadMemory(THIS)
		
	ENDPROC

	PROCEDURE loadtranslation		&& Translate bound data value into a format suitable for display.
		LPARAMETERS uValue
		*++
		*>>Translate bound data value into a format suitable for display.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE loadvalue		&& Load value property from cValuesource.
		*++
		*>>Load value property from cValuesource.
		*--
		  LOCAL uValue
		  IF NOT EMPTY(THIS.cValueSource) AND NOT THIS.lNativeBinding
		    * There is an obscure VFP5.0 bug that prevents optionbuttons from refreshing properly
		    * in some case when the value is changed. Setting value to 0 first seems to fix the trouble.
		    THIS.Value = 0
		  ENDIF
		  IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)
		    THIS.Value = m.uValue
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE lostfocus		&& Occurs when an object loses the focus.
		* Clear the default VFP workarea alias text from the status bar
		  IF VERSION(2) = 0
		    TRY 
		       SET MESSAGE TO ''
		       _VFP.StatusBar = 'Data Path: ' + LOWER(m.goapp.cdatafilepath)
		    CATCH
		    ENDTRY    
		  ENDIF
		
		
	ENDPROC

	PROCEDURE Refresh
		*++
		* Reinitialize display buffers from options's data source.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    THISFORM.cmBindingManager.InitBinding(THIS)
		  ENDIF
		
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_VALUE_LOADED) ;
		  OR BITTEST(THISFORM.nControlFlags, FRMFLAG_FORCE_RELOAD)
		    THIS.ShowControl()
		    THIS.LoadValue()
		    IF THIS.lValueMemory
		      THISFORM.cmBindingManager.DefaultFromMemory(THIS)
		    ENDIF
		  ENDIF
		
		  * Keep a copy of current value to supress Valid() events when clicking on current button.
		  THIS.AddProperty('uLastValue', THIS.Value)
		
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		
	ENDPROC

	PROCEDURE RightClick
		*++
		* Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    * Use the binding manager to put up common control context menus. This will make a callback
		    * to owr own ContextMenuBuild() method to control-specific items.
		    IF THISFORM.ContextMenuInit(THIS) AND THISFORM.cmBindingManager.ContextMenuBuild(THIS)
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty   && lReadonly and ReadOnly
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    CASE m.cProperty = 'value'
		      RETURN THIS.SetValue(@m.uValue)
		
		    CASE INLIST(m.cProperty, 'cvaluesource', 'controlsource')
		      THIS.cWorkarea = ''
		      THIS.cValueSource = m.uValue
		      THISFORM.cmBindingManager.LoadWorkarea(THIS)
		
		      IF THIS.lNativeBinding
		        IF NOT THIS.Parent.Baseclass == 'Column' OR NOT THIS.Parent.Bound
		          THIS.ControlSource = m.uValue
		        ENDIF
		      ENDIF
		      THIS.Refresh()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setfocus		&& Set Focus to the first option button in the group.
		*++
		*>>Set Focus to the first option button in the group.
		*--
		  RETURN THIS.Buttons[1].Setfocus()
		
	ENDPROC

	PROCEDURE setvalue		&& Set the optiongroup control's value
		LPARAMETERS uNewValue
		*++
		*>>Set the optiongroup control's value
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		  RETURN THISFORM.cmBindingManager.SetValue(THIS, m.uNewValue)
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*++
		*>>Re-evaluate security access, and update control display to reflect current state.
		* Called by Init and refresh methods. Checking security is a little slow, so it is optional.
		*--
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * Check for no data or Write-Protect (explicit edit mode).
		  IF NOT THIS.lWriteLock AND NOT EMPTY(THIS.cValueSource) ;
		  AND (NOT EMPTY(THIS.cWorkarea) OR NOT THISFORM.lIgnoreBoundProperties)
		    IF EMPTY(THIS.cWorkarea)
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed()  && Only pass workarea parameter if non-empty
		    ELSE
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea, SUBSTR(THIS.cValueSource, RAT('.', THIS.cValueSource) + 1))
		    ENDIF
		  ENDIF
		
		  * ReadonlyDisplay options are: Disable, or Normal
		  * The only way to write-lock an optiongroup is to disable the container.
		  THIS.Enabled = IIF(THIS.lWriteLock, .F., THIS.lEnabled)
		  IF 'DISABLE' $ THIS.cReadOnlyDisplay
		    THIS.SetAll('Enabled', THIS.Enabled)
		  ENDIF
		
		  * Update linked label control, if any.
		  IF NOT EMPTY(THIS.cLinkedLabel)
		    LOCAL oLabel
		    m.oLabel = EVALUATE('THIS.Parent.' + THIS.cLinkedLabel)
		    m.oLabel.Visible = THIS.Visible
		    m.oLabel.Refresh()
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the optiongroup.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT   && Don't process native help if using Codemine context help
		
		      * Customize class help keys for optional features in this instance of the control.
		      IF NOT EMPTY(THIS.cHelpClassKey)  && If no class help, leave it empty
		        THIS.cHelpClassKey = LOWER(THIS.cHelpClassKey)
		        IF THIS.lValueMemory AND NOT '%hlpvaluememory' $ THIS.cHelpClassKey
		          THIS.cHelpClassKey = THIS.cHelpClassKey + ',%hlpvaluememory'
		        ENDIF
		      ENDIF
		      THISFORM.DisplayHelp(THIS)    && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE storememory		&& Save current value in system registry for later use.
		*++
		*>>Save current value in system registry for later use.
		*--
		  RETURN THISFORM.cmBindingManager.StoreMemory(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		LPARAMETERS uValue
		*++
		*>>Translate control value into a format suitable for storage in bound data source.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE storevalue		&& Write optiongroup value back to data source using table or memvar syntax as appropriate.
		*++
		*>>Write optiongroup value back to data source using table or memvar syntax as appropriate.
		*--
		  RETURN THISFORM.cmBindingManager.StoreValue(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  * Pages in Forms instaniated from a VCX trigger UIenable events for the initial active
		  * page, before the form is visible. We ignore these events, as they can mess up lNoInitData.
		  IF m.lEnableEvent AND THISFORM.Visible
		    IF PEMSTATUS(THIS, 'nControlFlags', 5)
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		      THIS.Refresh()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE undochanges		&& Undo changes to the current control, and restore original value.
		*++
		*>>Undo changes to the current control, and restore original value.
		*--
		  IF EMPTY(THIS.cValueSource)
		    THIS.Value = THIS.uOriginalValue
		  ELSE
		    THIS.LoadValue()
		  ENDIF
		  THIS.lChanged = .F.
		
	ENDPROC

	PROCEDURE Valid
		*++
		*>>If optiongroup value has changed, call the FieldValid() event, and store value to datasource on success.
		*--
		LOCAL lStatus
		
		  * Only trigger FieldValid() validation if the value has actually changed
		  IF NOT THIS.Value == THIS.uLastValue
		    * Call binding manager for common control valid() processing.
		    m.lStatus = THISFORM.cmBindingManager.Valid(THIS, .T.)
		    IF EMPTY(m.lStatus)   && Undo change on validation failure.
		      THIS.UndoChanges()
		    ENDIF
		    THIS.uLastValue = THIS.Value
		    RETURN m.lStatus
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE When
		*++
		* Determine when the optiongroup control is allowed to receive focus.
		*--
		  IF TYPE('THISFORM') = 'O'
		    RETURN THISFORM.cmBindingManager.When(THIS)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pgfpageframe AS pageframe 		&& CodeMine base PageFrame class.
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: activepage_assign		&& Assign method to trap page change events.
		*m: afterpagechange		&& Custom Developer code run after the active page changes. The nPageIx parameter holds the new page number index.
		*m: afterpageload		&& Custom developer code called after dynamic page contents have been loaded for a particular page.
		*m: beforepagechange		&& Must return .T. before the page is allowed to change. The nPageIx parameter holds the current page number index.
		*m: beforepageload		&& Custom developer code called before dynamic page contents have been loaded for a particular page.
		*m: contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: initpage		&& Load and Initialize dynamic page contents.
		*m: pageordertoindex		&& Given a pageOrder value (like the pageframe ActivePage property), return the corresponding PageOrder Pages collection index.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: setfocus		&& Set focus to the first control in the active page
		*m: setpage		&& Programatically change the active page, enforcing Page level validation, and setting focus to first control on new page.
		*m: validatepage		&& Trigger the FormValid() event for all controls in the current or specified page. This can be used for page level interface validation before changing a page.
		*m: _pageactivate		&& Internal method Called when a different page is activated, to determine which control in the page should get the focus.
		*p: cdynamicpagecontainers		&& Comma separated list of class names (one per page) to add to the page on first activation
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: lapplyformbackground		&& Set to .T. to apply the current form background texture to each page in the pageframe
		*p: lfocusontabs		&& Set to .T. to let focus stay on the page tabs when changing pages. Set to .F. to send focus to the first control on the new active page instead.
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
		*p: lpagechangekeys		&& Set to .T. to change pages with the PageUp & PageDown keys
		*p: lrememberpage		&& Set to .T. to remember the current page when the form is closed, and restore it next time the form is opened.
		*p: lvalidateallpages		&& Set to .T. to trigger FormValid() for controls on all pages before the Form can Save changes. Set to .F. to validate only controls on the current page.
		*p: lvalidateonpagechange		&& Set to .T. to trigger the FormValid() event for all controls on the current page before allowing a page change.
		*p: nnextpage		&& Developer code in BeforePageChange() can use this to detect and alter the new page that will become active. Only useful for page changes made by the SetPage() method.
	*</DefinedPropArrayMethod>

	cdynamicpagecontainers = 		&& Comma separated list of class names (one per page) to add to the page on first activation
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	height = 150
	lapplyformbackground = .F.		&& Set to .T. to apply the current form background texture to each page in the pageframe
	lfocusontabs = .F.		&& Set to .T. to let focus stay on the page tabs when changing pages. Set to .F. to send focus to the first control on the new active page instead.
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	lpagechangekeys = .F.		&& Set to .T. to change pages with the PageUp & PageDown keys
	lrememberpage = .F.		&& Set to .T. to remember the current page when the form is closed, and restore it next time the form is opened.
	lvalidateallpages = .T.		&& Set to .T. to trigger FormValid() for controls on all pages before the Form can Save changes. Set to .F. to validate only controls on the current page.
	lvalidateonpagechange = .F.		&& Set to .T. to trigger the FormValid() event for all controls on the current page before allowing a page change.
	Name = "pgfpageframe"
	nnextpage = 0		&& Developer code in BeforePageChange() can use this to detect and alter the new page that will become active. Only useful for page changes made by the SetPage() method.
	width = 300
	
	PROCEDURE activepage_assign		&& Assign method to trap page change events.
		LPARAMETERS nNewPage
		*++
		*>>Assign method to trap page change events.
		*--
		LOCAL nOldPage
		
		  * Set desired new page number. This value may be changed by 
		  * developer code in the BeforePageChange() event.
		  THIS.nNextPage = m.nNewPage
		  IF NOT EMPTY(BITAND(THIS.nPageFlags, PAGEMASK_SKIP_VALID)) OR THIS.ValidatePage()
		    * Remember old page and index, for comparison and use by user AfterPageChange() code.
		    m.nOldPage = THIS.ActivePage
		    THIS.nLastPage = THIS.PageOrderToIndex(m.nOldPage)
		
		    * Activate the new page
		    THIS.ActivePage = THIS.Pages(THIS.nNextPage).PageOrder
		
		    * Trigger post-change events if page actually was changed.
		    IF THIS.ActivePage != m.nOldPage
		      THIS._PageActivate(THIS.nNextPage)
		    ENDIF
		  ENDIF
		  THIS.nPageFlags = 0
		
	ENDPROC

	PROCEDURE afterpagechange		&& Custom Developer code run after the active page changes. The nPageIx parameter holds the new page number index.
		LPARAMETERS nPageIx
		*++
		*>>Custom Developer code run after the active page changes. The nPageIx parameter holds the new page number index.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterpageload		&& Custom developer code called after dynamic page contents have been loaded for a particular page.
		LPARAMETERS nPageIx, cClassName
		*++
		*>>Custom developer code called after dynamic page contents have been loaded for a particular page.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforepagechange		&& Must return .T. before the page is allowed to change. The nPageIx parameter holds the current page number index.
		LPARAMETERS nPageIx
		*++
		*>>Must return .T. before the page is allowed to change. The nPageIx parameter holds the current page number index.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforepageload		&& Custom developer code called before dynamic page contents have been loaded for a particular page.
		LPARAMETERS nPageIx, cClassName
		*++
		*>>Custom developer code called before dynamic page contents have been loaded for a particular page.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.ContextMenuBuild()
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.ContextMenuExecute(m.cOption)
		
	ENDPROC

	PROCEDURE destroy
		  * Remember the current page if page memory is enabled.
		  IF THIS.lRememberPage AND NOT ISNULL(THISFORM.oApp)
		    THISFORM.oApp.SetPreference(THIS.cMemoryKeyRoot + SYS(1272, THIS), THIS.ActivePage)
		  ENDIF
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Dispatch all errors to Codemine common error handler.
		*--
		LOCAL cMsg
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE init
		*++
		* CodeMine foundation PageFrame control
		*
		* Copyright 1996-2004 Soft Classics, Ltd. All rights reserved.
		*--
		LOCAL ix, cContents, oPage
		
		  THIS.AddProperty('nOriginalWidth', THIS.Width)   && Original width of container, set by Init method.
		  THIS.AddProperty('nOriginalHeight',THIS.Height)  && Original height of container, set by Init method.
		  THIS.AddProperty('nNewWidth', THIS.Width)        && Used in workaround for Resize() event bug in VFP.
		  THIS.AddProperty('nNewHeight', THIS.Height)      && Used in workaround for Resize() event bug in VFP.
		  THIS.AddProperty('nLastPage', .NULL.)            && Used to optimize page change events.
		  THIS.AddProperty('aPageContents[1]', .F.)        && Array of container objects to add to page on first activation.
		  THIS.AddProperty('nPageFlags', 0)                && Page-change control flags
		
		  * Init event does not fire for pages added at design time. Force-fire it now.
		  FOR EACH oPage IN this.Pages
		    m.oPage.Init()
		  ENDFOR
		
		  m.ix = 0
		  DIMENSION THIS.aPageContents[THIS.PageCount]
		  m.cContents = THIS.cDynamicPageContainers
		  DO WHILE m.ix < THIS.PageCount AND NOT EMPTY(m.cContents)
		    m.ix = m.ix + 1
		    THIS.aPageContents[m.ix] = GetToken(@m.cContents, ',')
		  ENDDO
		
		  * Localize each page caption if localization is enabled
		  IF THIS.lLocalizeCaption AND NOT ISNULL(THISFORM.oMessage)
		    LOCAL oPage
		    FOR EACH oPage IN THIS.Pages
		      m.oPage.Caption = THISFORM.oMessage.Localize(m.oPage.Caption)
		    ENDFOR
		  ENDIF
		
	ENDPROC

	PROCEDURE initpage		&& Load and Initialize dynamic page contents.
		LPARAMETERS oPage
		*++
		*>>Load and Initialize dynamic page contents.
		*--
		LOCAL nPageIx, cDynamicPage
		
		  * Verify that the parameter is a page object.
		  IF PCOUNT() = 1 AND m.oPage.baseClass == 'Page'
		    m.nPageIx = THIS.PageOrderToIndex(m.oPage.PageOrder)
		
		    m.cDynamicPage = THIS.aPageContents[m.nPageIx]
		    THIS.aPageContents[m.nPageIx] = ''
		    IF PEMSTATUS(m.oPage, 'cDynamicPage', 5)
		      IF NOT EMPTY(m.oPage.cDynamicPage)
		        m.cDynamicPage = m.oPage.cDynamicPage
		        m.oPage.cDynamicPage = ''
		      ENDIF
		    ENDIF
		    
		    IF NOT EMPTY(m.cDynamicPage)
		      LOCAL oCont
		
		      * Add a tiny delay so the page will redraw before loading the container. This
		      * allows display of a banner on the page to display while the container loads.
		      =INKEY(.01, 'h')
		
		      * Call custom developer code for this page. Often used to add a CDE used by the page.
		      IF NOT THIS.BeforePageLoad(m.nPageIx, m.cDynamicPage)
		        RETURN .F.  && Don't create contents if event failed.
		      ENDIF
		      IF PEMSTATUS(m.oPage, 'BeforePageLoad', 5)
		        IF NOT m.oPage.BeforePageLoad()
		          RETURN .F.  && Don't create contents if event failed.
		        ENDIF
		      ENDIF
		
		      m.oPage.AddObject(m.cDynamicPage, GetClassName(m.cDynamicPage))
		      IF PEMSTATUS(m.oPage, m.cDynamicPage, 5)  && Check to be sure contents were created successfuly
		        IF PEMSTATUS(m.oPage, 'AfterPageLoad', 5)
		          m.oPage.AfterPageLoad()
		        ENDIF
		        THIS.AfterPageLoad(m.nPageIx, m.cDynamicPage)
		
		        m.oCont = EVALUATE('m.oPage.' + m.cDynamicPage)
		        m.oCont.Refresh()                && Need initial refresh to ensure correct display.
		        m.oCont.Visible = .T.
		        THIS.Resize()                    && In case container needs to stretch to fit current frame size.
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE mousedown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Don't allow page change unless BeforePageChange() returns .T.
		*--
		LOCAL nActivePageIx
		  m.nActivePageIx = THIS.PageOrderToIndex(THIS.ActivePage)
		  THIS.nLastPage = m.nActivePageIx
		
		  IF NOT THIS.ValidatePage(m.nActivePageIx)
		    THISFORM.ActivateNextControl()
		    NODEFAULT
		  ENDIF
		
	ENDPROC

	PROCEDURE mouseup
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Set focus to the first control on the (new) page.
		*--
		LOCAL nActivePageIx
		
		  m.nActivePageIx = THIS.PageOrderToIndex(THIS.ActivePage)
		
		  IF (THIS.nLastPage != m.nActivePageIx)
		    THIS._PageActivate(m.nActivePageIx)
		    THIS.nLastPage = m.nActivePageIx
		    THISFORM.ActivateNextControl()
		  ENDIF
		
	ENDPROC

	PROCEDURE pageordertoindex		&& Given a pageOrder value (like the pageframe ActivePage property), return the corresponding PageOrder Pages collection index.
		LPARAMETERS nOrder
		*++
		*>>Given a pageOrder value (like the pageframe ActivePage property), return the corresponding PageOrder Pages collection index.
		*--
		  LOCAL ix
		  FOR ix = 1 TO THIS.PageCount
		    IF THIS.Pages[m.ix].PageOrder == m.nOrder
		      RETURN m.ix
		    ENDIF
		  ENDFOR
		
		  * Return 0 if not matching page found (usually means a coding error).
		  RETURN 0
		
	ENDPROC

	PROCEDURE refresh
		*++
		* Custom pageframe refresh code.
		*--
		  * Call _PageActivate() for the initial page the first time we are refreshed.
		  * Need to also test for property, in case Refresh() is called by form before Init() is called.
		  IF PEMSTATUS(THIS, 'nLastPage', 5)
		    IF ISNULL(THIS.nLastPage)
		      * Restore saved page if page number memory is enabled.
		      IF THIS.lRememberPage AND NOT ISNULL(THISFORM.oApp)
		        LOCAL nPage, nPageIx
		        IF EMPTY(THIS.cMemoryKeyRoot)
		          THIS.cMemoryKeyRoot = THISFORM.cSysRegFormRoot + '\ControlMemory\PageNumber\'
		        ENDIF
		        IF THISFORM.oApp.GetPreference(THIS.cMemoryKeyRoot + SYS(1272, THIS), @m.nPage)
		          m.nPageIx = THIS.PageOrderToIndex(m.nPage)
		          IF THIS.Pages[m.nPageIx].Enabled
		            THIS.ActivePage = m.nPage
		          ENDIF
		        ENDIF
		      ENDIF
		
		      * If pageframe is 1st control in tab-order, allow set focus to first contained control.
		      IF THIS.TabIndex != 1
		        THIS.nPageFlags = BITOR(THIS.nPageFlags, PAGEMASK_NOFOCUS)
		      ENDIF
		      THIS.nLastPage = 0   && Indicate no previous page. Dont leave NULL, to avoid possible recursion.
		      THIS._PageActivate(THIS.PageOrderToIndex(THIS.ActivePage))
		      THISFORM.ActivateNextControl()
		      THIS.nLastPage = THIS.PageOrderToIndex(THIS.ActivePage)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE resize
		*++
		* Custom Resize event for Page Frames
		*--
		  DODEFAULT()
		  IF PEMSTATUS(THIS, 'nOriginalWidth', 5)
		    IF NOT EMPTY(THIS.nOriginalWidth)
		      IF PEMSTATUS(THISFORM, 'RepositionContents', 5)
		        IF PEMSTATUS(THIS, 'RepositionContents', 5)
		          * Call custom method for repositioning pageframe contents, if there is one.
		          THIS.RepositionContents()
		        ELSE
		          LOCAL oPage
		          FOR EACH oPage IN THIS.Pages
		            THISFORM.RepositionContents(m.oPage, THIS.nNewHeight, THIS.nNewWidth)
		          ENDFOR
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE rightclick
		LPARAMETERS lMenu
		*++
		*>>Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  * Pageframes only get rightclick when you click on a tab - the pages get it in all other
		  * cases. Pages also get the click on the tab. So, for proper operation, developer should
		  * add code to each page.Rightclick to call pageframe.Rightclick(.T.), which will put up
		  * the page ctx menu on any rightclick, and avoid double-menus when clicking on tabs.
		  IF m.lMenu AND THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		    m.cOption = THISFORM.ContextMenuActivate()
		    IF NOT EMPTY(m.cOption)
		      THIS.ContextMenuExecute(m.cOption)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE m.cProperty == 'width'  && Workaround for VFP resize() event bug
		      THIS.nNewHeight = THIS.Height
		      THIS.nNewWidth = m.uValue
		      THIS.Width = m.uValue
		    CASE m.cProperty == 'height'
		      THIS.nNewHeight = m.uValue
		      THIS.nNewWidth = THIS.Width
		      THIS.Height = m.uValue
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setfocus		&& Set focus to the first control in the active page
		*++
		*>>Set focus to the first control in the active page
		*--
		LOCAL oCtl, oFocus, nPageIx, nBestIndex 
		
		  m.oFocus = .NULL.
		  m.nBestIndex = 99999
		  m.nPageIx = THIS.PageOrderToIndex(THIS.ActivePage)
		  FOR EACH oCtl IN THIS.Pages[m.nPageIx].Controls
		    IF PEMSTATUS(m.oCtl, 'SetFocus', 5) 
		      IF TYPE('oCtl.TabIndex') = 'N'  && PEMSTATUS() is unreliable on some activex controls
		        IF m.oCtl.TabIndex < m.nBestIndex AND m.oCtl.Enabled AND m.oCtl.Visible
		          m.nBestIndex = m.oCtl.TabIndex
		          m.oFocus = m.oCtl
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  IF NOT ISNULL(m.oFocus)
		    * If target is another pageframe or container, this will recurse 
		    * into it to find a final target control.
		    THISFORM.ActivateNextControl(m.oFocus)
		  ENDIF
		
	ENDPROC

	PROCEDURE setpage		&& Programatically change the active page, enforcing Page level validation, and setting focus to first control on new page.
		LPARAMETERS nPageIx, nDelta, nFlags
		*++
		*>>Programatically change the active page, enforcing Page level validation, and setting focus to first control on new page.
		*
		* The nFlags parameter bits are:
		*   PAGEMASK_NOFOCUS     - Don't set focus to the new page.
		*   PAGEMASK_SKIP_VALID  - Prevents the BeforePageChange() event from firing. This is useful 
		*                          for situations like a Next/Back buttons - where you validate before moving
		*                          to the next page, but not before returning to a previous page.
		*
		* Returns True if the page was successfully changed. False if BeforePageChange() prevented the change.
		*--
		LOCAL nPage
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF VARTYPE(m.nFlags) = 'L'  && For backward compatibility, if a .T. was passed.
		    m.nFlags = PAGEMASK_SKIP_VALID
		  ENDIF
		
		  IF NOT EMPTY(m.nPageIx)
		    IF THISFORM.FlushControlBuffer()
		      LOCAL nOldPage
		
		      * Store optional flags where all methods can access them.
		      THIS.nPageFlags = m.nFlags
		
		      * And change the page. Assign method will enforce validation and trigger events.
		      m.nOldPage = THIS.ActivePage     && Remember original page for comparison
		      THIS.ActivePage = THIS.Pages(m.nPageIx).PageOrder
		
		      THISFORM.ActivateNextControl()
		      THIS.nNextPage = 0   && Leave 0 except while SetPage() is executing
		
		      * Success if the page changed, otherwise, return failure code.
		      RETURN m.nOldPage != THIS.ActivePage
		    ENDIF
		  ENDIF
		
		  * No absolute page specified. Try relative page movement.
		  IF NOT EMPTY(m.nDelta)
		    m.nPage = THIS.ActivePage
		    IF m.nDelta < 0
		      DO WHILE m.nPage > 1
		        m.nPage = m.nPage - 1
		        m.nPageIx = THIS.PageOrderToIndex(m.nPage)
		        IF THIS.Pages[m.nPageIx].Enabled
		          EXIT
		        ENDIF
		      ENDDO
		    ELSE   && Next page
		      DO WHILE m.nPage < THIS.PageCount
		        m.nPage = m.nPage + 1
		        m.nPageIx = THIS.PageOrderToIndex(m.nPage)
		        IF THIS.Pages[m.nPageIx].Enabled
		          EXIT
		        ENDIF
		      ENDDO
		    ENDIF
		
		    * If we found a different page, make a recursive call to set it.
		    IF m.nPage != THIS.ActivePage AND THIS.Pages[m.nPageIx].Enabled
		      RETURN THIS.SetPage(m.nPageIx, 0, m.nFlags)
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE showwhatsthis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the pageframe.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                  && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS) && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE validatepage		&& Trigger the FormValid() event for all controls in the current or specified page. This can be used for page level interface validation before changing a page.
		LPARAMETERS nPageIx
		*++
		*>>Trigger the FormValid() event for all controls in the current or specified page. This can be used for page level interface validation before changing a page.
		*--
		  IF EMPTY(m.nPageIx)
		    m.nPageIx = THIS.PageOrderToIndex(THIS.ActivePage)
		  ENDIF
		
		  * If lValidateOnPageChange is set, we do FormValid() of the current page, but only if 
		  * the form contains any changes. This follows the form standard of not enforcing 
		  * formValid() rules on unmodified data. If lValidateAllPages is False, then 
		  * lValidateOnPageChange is ignored, and current page is always validated when changed.
		  IF (NOT THIS.lValidateOnPageChange AND THIS.lValidateAllPages) ;
		  OR (NOT THISFORM.lChanged OR THISFORM.ValidateContents(THIS.Pages[m.nPageIx]))
		    RETURN THIS.BeforePageChange(m.nPageIx)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE _pageactivate		&& Internal method Called when a different page is activated, to determine which control in the page should get the focus.
		LPARAMETERS nPageIx
		*++
		*>>Internal method Called when a different page is activated, to determine which control in the page should get the focus.
		*
		* nPageIx is the index of the new page
		*--
		LOCAL oPage
		
		  * Check for any dynamic page contents, and add as necessary.
		  m.oPage = THIS.Pages[m.nPageIx]
		  THIS.InitPage(m.oPage)
		
		  IF THIS.lApplyFormBackground AND m.oPage.BackStyle = 1
		    THISFORM.SetBackgroundTexture(m.oPage)
		  ENDIF
		
		  * Test for left & right arrows. If used to change pages, keep focus on the tabs.
		  IF EMPTY(BITAND(THIS.nPageFlags, PAGEMASK_NOFOCUS)) AND NOT THIS.lFocusOnTabs
		    * Use SetLastControl() to set focus so any previous explicit 
		    * SetNextControl() target will not be overridden.
		    IF INLIST(cmLastKey(), 331, 333, 404)
		      THISFORM.SetLastControl(m.oPage)   && Focus on tabs anyway for change by arrows or Ctrl+Tab
		    ELSE
		      THISFORM.SetLastControl(THIS)      && Focus on first control in current page
		    ENDIF
		  ENDIF
		  THIS.nPageFlags = 0                    && Make sure flags are cleared after use.
		
		  * Call developer-specific post page-change code.
		  THIS.AfterPageChange(m.nPageIx)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS shpshape AS shape 		&& CodeMine base Shape class.
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	*</DefinedPropArrayMethod>

	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	Name = "shpshape"
	specialeffect = 0
	
	PROCEDURE contextmenubuild		&& Define all the bars for a context menu. Return false if no bars are defined.
		*++
		*>>Define all the bars for a context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.ContextMenuBuild()
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.ContextMenuExecute(m.cOption)
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		LOCAL nReply, cMsg
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE init
		*++
		* CodeMine foundation Shape class
		*
		* Copyright 1996-2002 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('nRight', .NULL.)               && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)              && Offset of bottom edge from bottom of parent container.
		
	ENDPROC

	PROCEDURE rightclick
		*++
		*>>Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		    m.cOption = THISFORM.ContextMenuActivate()
		    IF NOT EMPTY(m.cOption)
		      THIS.ContextMenuExecute(m.cOption)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE showwhatsthis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the shape.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                  && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS) && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS spnspinner AS spinner 		&& CodeMine foundation spinner class.
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*m: applysecurity		&& Evaluate security access for the control.
		*m: beforechange		&& Determine if it is OK to interactively change the control's value.
		*m: contextmenubuild		&& Define bars for a spinner context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item.
		*m: fieldvalid		&& Field level validation code goes here.
		*m: formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*m: getvalue		&& Return the control's current value
		*m: loadmemory		&& Load spinner value from stored memory.
		*m: loadtranslation		&& Translate bound data value into a format suitable for display.
		*m: loadvalue		&& Load value property from cValuesource.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: setvalue		&& Set the spinner control's value
		*m: showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*m: storememory		&& Save current value in system registry for later use.
		*m: storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		*m: storevalue		&& Write spinner value back to data source using table or memvar syntax as appropriate.
		*m: undochanges		&& Undo changes to the current control, and restore original value.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: chelpclasskey		&& List of class help keys for this class.
		*p: chelpkey		&& Name of context help message key for this field.
		*p: clinkedlabel		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
		*p: creadprivilege		&& Privilege required to display data in this field.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cvaluesource		&& Data source bound to this control.
		*p: cviewparameter		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
		*p: cworkarea		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lallownull		&& Set True if null values can be entered into the control.
		*p: lautoremember		&& When true and lValueMemory is also true, most recently entered value is remembered.
		*p: lchanged		&& Set to true if data was changed interactively.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: lnativebinding		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
		*p: lnoinitdata		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
		*p: lnullforempty		&& If set to .T., store .NULL. to bound data when value is EMPTY. Set to .NULL. to use BindingManager setting.
		*p: lreadlock		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
		*p: lreadonly		&& When true, Control value cannont be edited interactively.
		*p: lrequired		&& If true, a non-zero value must be entered before changes can be saved.
		*p: lvaluememory		&& When true, control's value can be remembered and restored under user control.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
		*p: nreadonlybackcolor		&& Background color used when the control is read-only. Defaults to parent container background color.
		*p: nvalidationmode		&& Determines when FieldValid() event is triggered for text editing controls. Settings: NULL=Use BindingManager Setting,0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	*</DefinedPropArrayMethod>

	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	chelpclasskey = %hlpSpinner		&& List of class help keys for this class.
	chelpkey = 		&& Name of context help message key for this field.
	clinkedlabel = 		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	creadonlydisplay = Dim		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
	creadprivilege = 		&& Privilege required to display data in this field.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cvaluesource = 		&& Data source bound to this control.
	cviewparameter = 		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
	cworkarea = 		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	Height = 22
	lallownull = .F.		&& Set True if null values can be entered into the control.
	lautoremember = .T.		&& When true and lValueMemory is also true, most recently entered value is remembered.
	lchanged = .F.		&& Set to true if data was changed interactively.
	lenabled = .T.		&& Specifies desired enable state for the control.
	lnativebinding = .F.		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
	lnoinitdata = .F.		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
	lnullforempty = .NULL.		&& If set to .T., store .NULL. to bound data when value is EMPTY. Set to .NULL. to use BindingManager setting.
	lreadlock = .F.		&& When true, the control's value cannot be seen. Controled by the cReadPrivilege property.
	lreadonly = .F.		&& When true, Control value cannont be edited interactively.
	lrequired = .F.		&& If true, a non-zero value must be entered before changes can be saved.
	lvaluememory = .F.		&& When true, control's value can be remembered and restored under user control.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "spnspinner"
	nreadonlybackcolor = .NULL.		&& Background color used when the control is read-only. Defaults to parent container background color.
	NullDisplay = " "
	nvalidationmode = .NULL.		&& Determines when FieldValid() event is triggered for text editing controls. Settings: NULL=Use BindingManager Setting,0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	Width = 100
	
	PROCEDURE afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*++
		*>>Method called after the control value has been successfuly changed and valuesource is updated.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE applysecurity		&& Evaluate security access for the control.
		*++
		*>>Evaluate security access for the control.
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  IF NOT EMPTY(THIS.cReadprivilege) AND NOT ISNULL(THISFORM.oSecurity)
		    THIS.lReadLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cReadPrivilege)
		  ENDIF
		
		  * If its not readable, its not writable either.
		  IF THIS.lReadLock
		    THIS.lWriteLock = .T.
		  ELSE
		    IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		      THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE beforechange		&& Determine if it is OK to interactively change the control's value.
		*++
		*>>Determine if it is OK to interactively change the control's value.
		* Sets the lChanged flag for the control on success.
		*--
		  RETURN THISFORM.cmBindingManager.BeforeChange(THIS)
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define bars for a spinner context menu. Return false if no bars are defined.
		*++
		*>>Define bars for a spinner context menu. Return false if no bars are defined.
		*--
		  RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. 
		* May also be called directly under program control to simulate user action.
		*--
		  RETURN THISFORM.cmBindingManager.ContextMenuExecute(THIS, m.cOption)
		
	ENDPROC

	PROCEDURE DownClick
		*++
		* Validate the control after each spinner click.
		*--
		  THIS.Valid()
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Spinner errors. Record rule (1583) applys here only if no buffering.
		*--
		LOCAL cMsg
		
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		  DO CASE
		    CASE INLIST(m.nError, 12, 13, 1734, 1925) AND NOT THIS.lNativeBinding AND '.controlsource' $ LOWER(m.cMethod)
		      * Ignore ControlSource Errors during Init.
		      RETURN .T.
		
		    CASE INLIST(m.nError, 1581,1582,1583) AND THIS.lNativeBinding
		      * DBC rule violated (1581,1582,1583) applies here only if lNativeBinding is set.
		      RETURN .T.
		
		    CASE m.nError = 1925 AND SYS(2018) == 'CMBINDINGMANAGER'
		      * Handle BindMan not found errors gracefuly. Usually this only will happen in a VCX based form
		      * with BindMan placed onthe form at design time, higher in the Z order than bound controls.
		      * Init method will fail in this case, and control will not be created.
		      MESSAGEBOX('No Binding Manager, or too high in Z order', 48, THIS.Name)
		      RETURN .T.
		  ENDCASE
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE fieldvalid		&& Field level validation code goes here.
		*++
		*>>Field level validation code goes here.
		* Success return: .T. or n != 0
		* Failure return: .F., 0
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*++
		*>>Form level control validation code goes here. Must return .T. before changes can be committed.
		* Success return: .T.
		* Failure return: .F.
		*--
		LOCAL lRequired
		  m.lRequired = THIS.lRequired
		  * If we are bound to a cursor field, and in a form with a data manager, evaluate the IsRequiredRule().
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		      m.lRequired = m.lRequired OR THISFORM.cmDataManager.IsRequired(THIS.cWorkarea, THIS.cValueSource)
		    ENDIF
		  ENDIF
		  IF m.lRequired AND EMPTY(NVL(THIS.GetValue(), ''))
		    THISFORM.DisplayMessage('%msgFieldRequired', THISFORM.NiceName(THIS))
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getvalue		&& Return the control's current value
		*++
		*>>Return the control's current value
		*--
		  RETURN THIS.Value
		
	ENDPROC

	PROCEDURE GotFocus
		  THISFORM.cmBindingManager.GotFocus(THIS)
		  IF THIS.SelectOnEntry
		    DODEFAULT()   && This causes SelectOnEntry to work on entry by mouseclick as well as via keyboard.
		  ENDIF
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Foundation Spinner control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  * Make sure binding manager is instantiated.
		  IF NOT PEMSTATUS(THISFORM, 'cmBindingManager', 5)
		    THISFORM.AddObject('cmBindingManager', 'cmBindingManagerCustom')
		  ENDIF
		
		  * Process common data-bound control binding initialization.
		  IF NOT THISFORM.cmBindingManager.InitBinding(THIS)
		    RETURN .F.    && This line will also execute if above "IF" generates error.
		  ENDIF
		
		  * Setup various layout properties when control is placed in a grid.
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_INGRID) AND THIS.Parent.Baseclass != 'Container'
		    THIS.SelectedBackColor = GetSysColor(COLOR_HIGHLIGHT)
		    THIS.SpecialEffect = 1   && Turn off 3d in a grid
		    THIS.BorderStyle = 0     && and no border
		    THIS.Margin = 0          && No margin 
		  ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		*++
		* Intercept all change attempts, enforce security, and secure locks as needed.
		* Return .T. if the change was accepted, .F. if it was rejected and original value restored.
		*--
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_ESCAPE)
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_ESCAPE)
		    THIS.UndoChanges()
		  ELSE
		    IF NOT THIS.lChanged AND NOT THIS.BeforeChange()
		      * At this point, value has already changed, so 
		      * if changes are not allowed, we must restore original value.
		      THIS.UndoChanges()
		      RETURN .F.
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Key processing for spinner controls
		*--
		  DO CASE
		    CASE m.nKeyCode = 27
		      THIS.lChanged = .F.                        && Escape resets data, so clear change flag to prevent validation
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_ESCAPE) && Flag that we are processing an escape key press.
		
		    CASE m.nShiftAltCtrl <= 1 AND m.nKeyCode > 0 AND (m.nKeyCode % 128 >= ASC(' ') OR m.nKeyCode = 7)
		      * For data characters, check if changes are allowed before accepting the character.
		      * Any changes not caught here will be handled by this.InteractiveChange()
		      IF (m.nKeyCode >= ASC('0') AND m.nKeyCode <= ASC('9')) ;
		      OR INLIST(m.nKeyCode, 7, 127, ASC('-'), ASC(SET('POINT')))
		        IF THIS.lChanged OR THIS.BeforeChange()
		          RETURN .T.
		        ENDIF
		      ELSE
		        THISFORM.DisplayMessage('%msgDigitsOnly')
		      ENDIF
		      NODEFAULT   && Ignore all invalid data characters
		
		
		    CASE m.nKeyCode = ASC('0') AND m.nShiftAltCtrl = 2
		      NODEFAULT
		      IF THIS.lAllowNull
		        IF THIS.BeforeChange()
		          THIS.SetValue(.NULL.)
		        ENDIF
		      ELSE
		        ??CHR(7)   && Ignore ctrl+0 keystrokes (prevent entering a .NULL. via keyboard).
		      ENDIF
		
		    CASE m.nShiftAltCtrl = 0 AND m.nKeyCode = 22 && Insert mode toggle
		      =INSMODE(NOT INSMODE())
		      NODEFAULT
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE loadmemory		&& Load spinner value from stored memory.
		*++
		*>>Load spinner value from stored memory.
		* Return .T. if there was a value stored in memory.
		*--
		  RETURN THISFORM.cmBindingManager.LoadMemory(THIS)
		
	ENDPROC

	PROCEDURE loadtranslation		&& Translate bound data value into a format suitable for display.
		LPARAMETERS uValue
		*++
		*>>Translate bound data value into a format suitable for display.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE loadvalue		&& Load value property from cValuesource.
		*++
		*>>Load value property from cValuesource.
		*--
		  LOCAL uValue
		  IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)
		    THIS.Value = m.uValue
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE LostFocus
		* Clear the default VFP workarea alias text from the status bar
		  IF VERSION(2) = 0
		    TRY 
		       SET MESSAGE TO ''
		       _VFP.StatusBar = 'Data Path: ' + LOWER(m.goapp.cdatafilepath)
		    CATCH
		    ENDTRY    
		  ENDIF
		
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Ignore Left-clicks if spinner is read-only.
		*--
		  * Only trap clicks in the spinner up/dn buttons.
		  IF THIS.lWriteLock AND m.nXCoord > THIS.Left + THIS.Width - SYSMETRIC(5)
		    IF m.nButton = 2
		      THIS.RightClick()   && Put up the context menu even when read-only
		    ELSE
		      ??CHR(7)
		    ENDIF
		    NODEFAULT
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		  * Clear flag for select-all-on-entry behavior
		  IF THIS.SelLength > 0
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Special workaround for VFP5.0 quirks. If a control Valid fails when the user clicks on another form
		* the user cannot re-activate the original window by clicking on the control that failed validation.
		* We detect this case here and re-activate the window.
		*
		* May be able to dispose of this code in later versions of VFP, if they fix the problem.
		*--
		  IF THIS.lChanged
		    IF THISFORM.BaseClass == 'Form' AND NOT BITTEST(THISFORM.nControlFlags, FRMFLAG_ACTIVE)
		      ACTIVATE WINDOW (THISFORM.Name)
		    ENDIF
		  ENDIF
		
		  * Implement SelectOnEntry that will work in grids, and on entry by mouse-click.
		  IF THIS.SelLength = 0 AND BITTEST(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		    THIS.SelStart = 0
		    THIS.SelLength = LEN(TRIM(THIS.Text))
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		
	ENDPROC

	PROCEDURE Refresh
		*++
		* Reinitialize display buffers from spinner's data source.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    THISFORM.cmBindingManager.InitBinding(THIS)
		  ENDIF
		
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_VALUE_LOADED) ;
		  OR BITTEST(THISFORM.nControlFlags, FRMFLAG_FORCE_RELOAD)
		    THIS.ShowControl()
		    THIS.LoadValue()
		    IF THIS.lValueMemory
		      THISFORM.cmBindingManager.DefaultFromMemory(THIS)
		    ENDIF
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		
	ENDPROC

	PROCEDURE RightClick
		*++
		* Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    * Use the binding manager to put up common control context menus. This will make a callback
		    * to owr own ContextMenuBuild() method to control-specific items.
		    IF THISFORM.ContextMenuInit(THIS) AND THISFORM.cmBindingManager.ContextMenuBuild(THIS)
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty   && lReadonly and ReadOnly
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    CASE m.cProperty = 'value'
		      RETURN THIS.SetValue(@m.uValue)
		
		    CASE INLIST(m.cProperty, 'cvaluesource', 'controlsource')
		      THIS.cWorkarea = ''
		      THIS.cValueSource = m.uValue
		      THISFORM.cmBindingManager.LoadWorkarea(THIS)
		
		      IF THIS.lNativeBinding
		        IF NOT THIS.Parent.Baseclass == 'Column' OR NOT THIS.Parent.Bound
		          THIS.ControlSource = m.uValue
		        ENDIF
		      ENDIF
		      THIS.Refresh()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setvalue		&& Set the spinner control's value
		LPARAMETERS nNewValue
		*++
		*>>Set the spinner control's value
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		  RETURN THISFORM.cmBindingManager.SetValue(THIS, m.nNewValue)
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate security access, and update control display to reflect current state.
		*++
		*>>Re-evaluate security access, and update control display to reflect current state.
		* Called by Init and refresh methods. Checking security is a little slow, so it is optional.
		*--
		LOCAL lOldWriteLock
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  m.lOldWriteLock = THIS.lWriteLock
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * Check for no data or Write-Protect (explicit edit mode).
		  IF NOT THIS.lWriteLock AND NOT EMPTY(THIS.cValueSource) ;
		  AND (NOT EMPTY(THIS.cWorkarea) OR NOT THISFORM.lIgnoreBoundProperties)
		    IF EMPTY(THIS.cWorkarea)
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed()  && Only pass workarea parameter if non-empty
		    ELSE
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea, SUBSTR(THIS.cValueSource, RAT('.', THIS.cValueSource) + 1))
		    ENDIF
		  ENDIF
		
		  * Apply or remove readonly display effect if read-only condition changed.
		  IF m.lOldWriteLock != THIS.lWriteLock
		    IF 'DIM' $ THIS.cReadOnlyDisplay
		      IF THIS.lWriteLock
		        IF ISNULL(THIS.nBackColor)
		          THIS.nBackColor = THIS.BackColor
		        ENDIF
		        IF ISNULL(THIS.nReadOnlyBackColor)
		          THIS.nReadOnlyBackColor = THIS.Parent.BackColor
		        ENDIF
		        THIS.BackColor = THIS.nReadOnlyBackColor
		      ELSE
		        IF NOT ISNULL(THIS.nBackColor)
		          THIS.BackColor = THIS.nBackColor
		        ENDIF
		      ENDIF
		    ENDIF
		    THIS.MousePointer = IIF(THIS.lWriteLock, 1, 0)  && Change cursor to arrow while read-only.
		  ENDIF
		
		  * Control is Disabled if readonly (optionaly), or if datasource is EOF().
		  IF THIS.lWriteLock AND 'DISABLE' $ THIS.cReadOnlyDisplay
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
		  * Update linked label control, if any.
		  IF NOT EMPTY(THIS.cLinkedLabel)
		    LOCAL oLabel
		    m.oLabel = EVALUATE('THIS.Parent.' + THIS.cLinkedLabel)
		    m.oLabel.Visible = THIS.Visible
		    m.oLabel.Refresh()
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the spinner.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT   && Don't process native help if using Codemine context help
		
		      * Customize class help keys for optional features in this instance of the control.
		      IF NOT EMPTY(THIS.cHelpClassKey)  && If no class help, leave it empty
		        THIS.cHelpClassKey = LOWER(THIS.cHelpClassKey)
		        IF THIS.lValueMemory AND NOT '%hlpvaluememory' $ THIS.cHelpClassKey
		          THIS.cHelpClassKey = THIS.cHelpClassKey + ',%hlpvaluememory'
		        ENDIF
		      ENDIF
		      THISFORM.DisplayHelp(THIS)    && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE storememory		&& Save current value in system registry for later use.
		*++
		*>>Save current value in system registry for later use.
		*--
		  RETURN THISFORM.cmBindingManager.StoreMemory(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		LPARAMETERS uValue
		*++
		*>>Translate control value into a format suitable for storage in bound data source.
		*--
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE storevalue		&& Write spinner value back to data source using table or memvar syntax as appropriate.
		*++
		*>>Write spinner value back to data source using table or memvar syntax as appropriate.
		*--
		  RETURN THISFORM.cmBindingManager.StoreValue(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  * Pages in Forms instaniated from a VCX trigger UIenable events for the initial active
		  * page, before the form is visible. We ignore these events, as they can mess up lNoInitData.
		  IF m.lEnableEvent AND THISFORM.Visible
		    IF PEMSTATUS(THIS, 'nControlFlags', 5)
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		      THIS.Refresh()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE undochanges		&& Undo changes to the current control, and restore original value.
		*++
		*>>Undo changes to the current control, and restore original value.
		*--
		  IF EMPTY(THIS.cValueSource)
		    THIS.Value = THIS.nOriginalValue
		  ELSE
		    THIS.LoadValue()
		  ENDIF
		  THIS.lChanged = .F.
		
	ENDPROC

	PROCEDURE UpClick
		*++
		* Validate the control after each spinner click.
		*--
		  THIS.Valid()
		
	ENDPROC

	PROCEDURE Valid
		*++
		*>>If spinner value has changed, call the FieldValid() event, and store value to datasource on success.
		*--
		  * Call binding manager for common control valid() processing.
		  IF THISFORM.cmBindingManager.ValidNeeded(THIS)
		    RETURN THISFORM.cmBindingManager.Valid(THIS)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE When
		*++
		* Determine when the spinner control is allowed to receive focus.
		*--
		  IF TYPE('THISFORM') = 'O'
		    RETURN THISFORM.cmBindingManager.When(THIS)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS txttextbox AS textbox 		&& CodeMine foundation textbox class.
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*m: applysecurity		&& Evaluate security access for the textbox.
		*m: beforechange		&& Determine if it is OK to interactively change the control's value.
		*m: contextmenubuild		&& Define custom bars for a textbox context menu. Return false if no bars are defined.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called from binding manager context menu activation.
		*m: fieldvalid		&& Field level validation code goes here.
		*m: formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*m: getvalue		&& Return the textbox control's current value
		*m: loadmemory		&& Load textbox value from stored memory.
		*m: loadtranslation		&& Translate bound data value into a format suitable for display.
		*m: loadvalue		&& Load value property from cValuesource.
		*m: set		&& Set various control properties. Parameters are property name and value to set.
		*m: setvalue		&& Set the textbox control's value
		*m: showcontrol		&& Re-evaluate security access, and update textbox display to reflect current state.
		*m: storememory		&& Save current value in system registry for later use.
		*m: storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		*m: storevalue		&& Write textbox value back to data source using table or memvar syntax as appropriate.
		*m: undochanges		&& Undo changes to the current textbox, and restore original value.
		*p: cdisplayname		&& User-Friendly display name for the control used in help and error messages.
		*p: cencryptionkey		&& Encryption key for encrypted data. Leave empty for unencrypted data.
		*p: chelpclasskey		&& Name of class help keys for this class.
		*p: chelpkey		&& Name of context help message key for this control.
		*p: clinkedlabel		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
		*p: cmemorykeyroot		&& System registry key root path used for value memory. Leave empty to use default.
		*p: creadonlydisplay		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
		*p: creadprivilege		&& Privilege required to display data in this field.
		*p: creposition		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
		*p: cvaluesource		&& Data source bound to this control.
		*p: cviewparameter		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
		*p: cworkarea		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
		*p: cwriteprivilege		&& Privilege required to modify data in this field.
		*p: lallownull		&& Set True if null values can be entered into the control.
		*p: lallowzoom		&& Controls whether or not the Zoom edit option is included in the context menu.
		*p: lautoremember		&& When true and lValueMemory is also true, most recently entered value is remembered.
		*p: lchanged		&& Set to true if data was changed interactively.
		*p: lenabled		&& Specifies desired enable state for the control.
		*p: lnativebinding		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
		*p: lnoinitdata		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
		*p: lnullforempty		&& If set to .T., store .NULL. to bound data when value is EMPTY. Set to .NULL. to use BindingManager setting.
		*p: lpropercase		&& For character data, when set to .T. convert to proper capitalization.
		*p: lreadlock		&& When true the control's value cannot be seen. Controled by the cReadPrivilege property.
		*p: lreadonly		&& Specifies the desired Readonly state. When true the control's value cannont be edited interactively.
		*p: lrequired		&& If True a value must be entered before changes can be saved.
		*p: lvaluememory		&& When true, control's value can be remembered and restored under user control.
		*p: lwritelock		&& Internal flag set when control value cannot be edited.
		*p: nreadonlybackcolor		&& Background color used when the control is read-only. Defaults to parent container background color.
		*p: nvalidationmode		&& Determines when FieldValid() event is triggered for text editing controls. Settings: NULL=Use BindingManager Setting,0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	*</DefinedPropArrayMethod>

	cdisplayname = 		&& User-Friendly display name for the control used in help and error messages.
	cencryptionkey = 		&& Encryption key for encrypted data. Leave empty for unencrypted data.
	chelpclasskey = %hlpTextbox		&& Name of class help keys for this class.
	chelpkey = 		&& Name of context help message key for this control.
	clinkedlabel = 		&& Specifies the name of a label control (in the same parent container) that will be shown,hidden, and refreshed whenever this control is refreshed.
	cmemorykeyroot = 		&& System registry key root path used for value memory. Leave empty to use default.
	creadonlydisplay = Dim		&& Controls how read-only fields are handled. Options: Dim,Nofocus,Disable,Normal
	creadprivilege = 		&& Privilege required to display data in this field.
	creposition = 		&& Reposition options: Vfollow,Vstretch,Vcenter,Hfollow,Hstretch,Hcenter
	cvaluesource = 		&& Data source bound to this control.
	cviewparameter = 		&& When used in a requery dialog, specifies the view parameter associated with this control's value.
	cworkarea = 		&& If cValueSource is a table/view field cWorkarea hold the workarea alias.
	cwriteprivilege = 		&& Privilege required to modify data in this field.
	Height = 22
	lallownull = .F.		&& Set True if null values can be entered into the control.
	lallowzoom = .F.		&& Controls whether or not the Zoom edit option is included in the context menu.
	lautoremember = .T.		&& When true and lValueMemory is also true, most recently entered value is remembered.
	lchanged = .F.		&& Set to true if data was changed interactively.
	lenabled = .T.		&& Specifies desired enable state for the control.
	lnativebinding = .F.		&& Set true to disable use native data binding instead of the CodeMine ehanced data binding.
	lnoinitdata = .F.		&& Set True to bypass data load on Init. Useful when cValueSource is derived from Form.Init() parameters.
	lnullforempty = .NULL.		&& If set to .T., store .NULL. to bound data when value is EMPTY. Set to .NULL. to use BindingManager setting.
	lpropercase = .F.		&& For character data, when set to .T. convert to proper capitalization.
	lreadlock = .F.		&& When true the control's value cannot be seen. Controled by the cReadPrivilege property.
	lreadonly = .F.		&& Specifies the desired Readonly state. When true the control's value cannont be edited interactively.
	lrequired = .F.		&& If True a value must be entered before changes can be saved.
	lvaluememory = .F.		&& When true, control's value can be remembered and restored under user control.
	lwritelock = .F.		&& Internal flag set when control value cannot be edited.
	Name = "txttextbox"
	nreadonlybackcolor = .NULL.		&& Background color used when the control is read-only. Defaults to parent container background color.
	nvalidationmode = .NULL.		&& Determines when FieldValid() event is triggered for text editing controls. Settings: NULL=Use BindingManager Setting,0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	Width = 100
	
	PROCEDURE afterchange		&& Method called after the control value has been successfuly changed and valuesource is updated.
		*++
		*>>Method called after the control value has been successfuly changed and valuesource is updated.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE applysecurity		&& Evaluate security access for the textbox.
		*++
		*>>Evaluate security access for the textbox.
		* Responsible for setting THIS.lWriteLock and THIS.lReadLock
		* Implemented as a separate method to make it easy for developers to
		* subclasses for special security requirements.
		*--
		  IF NOT EMPTY(THIS.cReadprivilege) AND NOT ISNULL(THISFORM.oSecurity)
		    THIS.lReadLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cReadPrivilege)
		  ENDIF
		
		  * If its not readable, its not writable either.
		  IF THIS.lReadLock
		    THIS.lWriteLock = .T.
		  ELSE
		    IF NOT EMPTY(THIS.cWritePrivilege) AND NOT THIS.lWriteLock AND NOT ISNULL(THISFORM.oSecurity)
		      THIS.lWriteLock = NOT THISFORM.oSecurity.HasPrivilege(THIS.cWritePrivilege)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE beforechange		&& Determine if it is OK to interactively change the control's value.
		*++
		*>>Determine if it is OK to interactively change the control's value.
		* Sets the lChanged flag for the control on success.
		*--
		  RETURN THISFORM.cmBindingManager.BeforeChange(THIS)
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define custom bars for a textbox context menu. Return false if no bars are defined.
		*++
		*>>Define custom bars for a textbox context menu. Return false if no bars are defined.
		*--
		  IF THIS.lAllowZoom AND NOT THIS.lReadLock AND VARTYPE(THIS.Value) = 'C'
		    THISFORM.ContextMenuBar(CTX_BAR_CTL_ZOOM, '%barZoom')
		    THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP3)
		  ENDIF
		  RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called from binding manager context menu activation.
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item. Usually called from binding manager context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption == '%barzoom'
		      LOCAL oDialog
		      m.oDialog = CreateNewObject('frmZoomEdit', THIS.Value, THISFORM.NiceName(THIS), THIS.lWriteLock)
		      IF VARTYPE(m.oDialog) = 'O'
		        m.oDialog.Show(1)
		        IF VARTYPE(m.oDialog) = 'O'
		          IF m.oDialog.uValue AND THIS.BeforeChange()
		            THIS.SetValue(m.oDialog.cValue)
		          ENDIF
		          m.oDialog.Release()
		        ENDIF
		      ENDIF
		
		    OTHERWISE
		      RETURN THISFORM.cmBindingManager.ContextMenuExecute(THIS, @m.cOption)
		
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* TextBox Errors. 
		*--
		LOCAL cMsg
		  m.cMsg = MESSAGE()   && Save error message text - TYPE() may override it.
		
		  DO CASE
		    CASE INLIST(m.nError, 12, 13, 1734, 1925) AND NOT THIS.lNativeBinding AND '.controlsource' $ LOWER(m.cMethod)
		      * Ignore ControlSource Errors during Init.
		      RETURN .T.
		
		    CASE INLIST(m.nError, 1581,1582,1583) AND THIS.lNativeBinding
		      * DBC rule violated (1581,1582,1583) applies here only if lNativeBinding is set.
		      RETURN .T.
		
		    CASE m.nError = 1925 AND SYS(2018) == 'CMBINDINGMANAGER'
		      * Handle BindMan not found errors gracefuly. Usually this only will happen in a VCX based form
		      * with BindMan placed on the form at design time, higher in the Z order than bound controls.
		      * Init method will fail in this case, and control will not be created.
		      MESSAGEBOX('No Binding Manager, or too high in Z order', 48, THIS.Name)
		      RETURN .T.
		  ENDCASE
		
		  * Fatal coding error - Pass it on to CodeMine Application error handler if available.
		  IF VARTYPE(THISFORM.oMessage) == 'O'
		    RETURN THISFORM.oMessage.FatalError(m.cMsg, m.cMethod, m.nLine)
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		
	ENDPROC

	PROCEDURE fieldvalid		&& Field level validation code goes here.
		*++
		*>>Field level validation code goes here.
		* Success return: .T. or n != 0
		* Failure return: .F., 0
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE formvalid		&& Form level control validation code goes here. Must return .T. before changes can be committed.
		*++
		*>>Form level control validation code goes here. Must return .T. before changes can be committed.
		* Success return: .T.
		* Failure return: .F.
		*--
		LOCAL lRequired
		  m.lRequired = THIS.lRequired
		  * If we are bound to a cursor field, and in a form with a data manager, evaluate the IsRequiredRule().
		  IF NOT EMPTY(THIS.cWorkarea)
		    IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		      m.lRequired = m.lRequired OR THISFORM.cmDataManager.IsRequired(THIS.cWorkarea, THIS.cValueSource)
		    ENDIF
		  ENDIF
		  IF m.lRequired AND EMPTY(NVL(THIS.GetValue(), ''))
		    THISFORM.DisplayMessage('%msgFieldRequired', THISFORM.NiceName(THIS))
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getvalue		&& Return the textbox control's current value
		*++
		*>>Return the textbox control's current value
		*--
		  * If bound to a numeric field set to NULL, the control may forget it is numeric, so we remind it here.
		  * Same problem exists for date fields, but that conversion causes StrictDate errors. Forms should 
		  * use txtDate for dates anyway, so we don't deal with that here.
		  IF VARTYPE(THIS.Value) = 'C' AND THIS.cDataType $ 'NI'
		    RETURN VAL(THIS.Value)
		  ENDIF
		  RETURN THIS.Value
		
	ENDPROC

	PROCEDURE GotFocus
		  THISFORM.cmBindingManager.GotFocus(THIS)
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Foundation textbox control
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('cDataType', '')   && Used to preserve datatype when bound to NULL numeric or date fields
		
		  * Create default binding manager instance if none added by form. 
		  * Normally this only applies to controls in toolbars, as forms add Bindman during the load() event.
		  * It might also be necessary after errors loading a custom user BindMan subclass by the form.
		  IF NOT PEMSTATUS(THISFORM, 'cmBindingManager', 5)
		    THISFORM.AddObject('cmBindingManager', 'cmBindingManagerCustom')
		  ENDIF
		
		  * Process common data-bound control binding initialization.
		  IF NOT THISFORM.cmBindingManager.InitBinding(THIS)
		    RETURN .F.    && This line will also execute if above "IF" generates error.
		  ENDIF
		
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_INGRID) AND THIS.Parent.Baseclass != 'Container'
		    THIS.SelectedBackColor = GetSysColor(COLOR_HIGHLIGHT)
		    THIS.SpecialEffect = 1   && Turn off 3d in a grid
		    THIS.BorderStyle = 0     && and no border
		    THIS.Margin = 0          && and no margin
		  ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		*++
		*>>Intercept all change attempts, enforce security, and secure locks as needed.
		* Return .T. if the change was accepted, .F. if it was rejected and original value restored.
		*--
		  IF BITTEST(THIS.nControlFlags, CTLFLAG_ESCAPE)
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_ESCAPE)
		    THIS.UndoChanges()
		  ELSE
		    IF NOT THIS.lChanged AND NOT THIS.BeforeChange()
		      * At this point, value has already changed, so 
		      * if changes are not allowed, we must restore original value.
		      THIS.UndoChanges()
		      RETURN .F.
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Key processing for text boxes
		*--
		  * Process incremental search characters if enabled for the parent grid.
		  IF THIS.lWriteLock AND BITTEST(THIS.nControlFlags, CTLFLAG_INGRID)
		    LOCAL oGrid
		    m.oGrid = THIS.Parent.Parent
		    IF PEMSTATUS(m.oGrid, 'lSearch', 5)
		      IF m.oGrid.lSearch
		        IF (m.nKeyCode > 0 AND CHR(m.nKeycode % 128) >= ' ' AND CHR(m.nKeycode %128) <= '~') ;
		        OR INLIST(m.nKeyCode, 7, 127)
		          m.oGrid.IncrementalSearch(CHR(m.nKeycode), THIS.Parent.ControlSource)
		          NODEFAULT
		          RETURN .T.
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  DO CASE
		    CASE m.nKeyCode = 27
		      THIS.lChanged = .F.                        && Escape resets data, so clear change flag to prevent validation
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_ESCAPE) && Flag that we are processing an escape key press.
		
		    * Implement basic Copy & Paste in the control, for cases where no VFP menu is available.
		    CASE m.nShiftAltCtrl = 2 AND m.nKeyCode = 3  && Ctrl+C (Copy)
		      IF VARTYPE(THIS.Value) = 'C' AND THIS.SelLength > 0
		        _CLIPTEXT = TRIM(SUBSTR(THIS.Value, THIS.SelStart, THIS.SelLength))
		      ENDIF
		
		    CASE m.nKeyCode = 24                         && Down Arrow
		      IF BITTEST(THIS.nControlFlags, CTLFLAG_INGRID)
		        IF PEMSTATUS(THIS.Parent.Parent, 'AutoAppend', 5)
		          * Add a new record to the parent grid, if at the end.
		          IF NOT EMPTY(THIS.Valid()) AND THIS.Parent.Parent.AutoAppend()
		            NODEFAULT
		          ENDIF
		        ENDIF
		      ENDIF
		
		    CASE m.nShiftAltCtrl <= 1 AND m.nKeyCode > 0 AND (m.nKeyCode % 128 >= ASC(' ') OR m.nKeyCode = 7)
		      * For data characters, check if changes are allowed before accepting the character.
		      * Any changes not caught here will be handled by this.InteractiveChange()
		      DO CASE
		        CASE VARTYPE(THIS.Value, .T.) $ 'C'
		          IF THIS.lChanged OR THIS.BeforeChange()
		            RETURN .T.
		          ENDIF
		        CASE VARTYPE(THIS.Value, .T.) = 'L'
		          IF UPPER(CHR(m.nKeyCode)) $ 'YNTF'
		            IF THIS.lChanged OR THIS.BeforeChange()
		              RETURN .T.
		            ENDIF
		          ENDIF
		        OTHERWISE
		          IF ((m.nKeyCode >= ASC('0') AND m.nKeyCode <= ASC('9')) ;
		          OR INLIST(m.nKeyCode, 7, 127, ASC('-'), ASC(SET('POINT')))) ;
		          OR (VARTYPE(THIS.Value, .T.) = 'T' AND UPPER(CHR(m.nKeyCode)) $ 'AMP')
		            IF THIS.lChanged OR THIS.BeforeChange()
		              RETURN .T.
		            ENDIF
		          ELSE
		            THISFORM.DisplayMessage('%msgDigitsOnly')
		          ENDIF
		      ENDCASE
		      NODEFAULT   && Ignore all invalid data characters
		
		    CASE m.nShiftAltCtrl = 0 AND m.nKeyCode = 22 && Insert mode toggle
		      =INSMODE(NOT INSMODE())
		      NODEFAULT
		
		    CASE m.nKeyCode = ASC('0') AND m.nShiftAltCtrl = 2
		      NODEFAULT
		      IF THIS.lAllowNull
		        IF THIS.BeforeChange()
		          THIS.SetValue(.NULL.)
		        ENDIF
		      ELSE
		        ??CHR(7)   && Ignore ctrl+0 keystrokes (prevent entering a .NULL. via keyboard).
		      ENDIF
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE loadmemory		&& Load textbox value from stored memory.
		*++
		*>>Load textbox value from stored memory.
		* Return .T. if there was a value stored in memory.
		*--
		  RETURN THISFORM.cmBindingManager.LoadMemory(THIS)
		
	ENDPROC

	PROCEDURE loadtranslation		&& Translate bound data value into a format suitable for display.
		LPARAMETERS uValue
		*++
		*>>Translate bound data value into a format suitable for display.
		*--
		  * Decrypt string, unless it is all spaces (empty field in a newly appended record).
		  IF NOT EMPTY(this.cEncryptionkey)
		     * If we've set an encryption key on a textbox, replace it with the global encryption key
		     this.cEncryptionkey = m.goApp.cEncryptionKey
		  ENDIF 
		  IF NOT EMPTY(THIS.cEncryptionKey) AND VARTYPE(m.uValue) = 'C' AND LEN(CHRTRAN(m.uValue, ' ', '')) > 0
		    RETURN cmEncrypt(m.uValue, THIS.cEncryptionKey)
		  ENDIF
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE loadvalue		&& Load value property from cValuesource.
		*++
		*>>Load value property from cValuesource.
		*--
		LOCAL uValue
		  IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)
		    THIS.Value = m.uValue
		    THIS.AddProperty('cDataType', VARTYPE(m.uValue, .T.))
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE LostFocus
		* Clear the default VFP workarea alias text from the status bar
		  IF VERSION(2) = 0
		    TRY 
		       SET MESSAGE TO ''
		       IF m.goApp.lCloudServer
		          _VFP.StatusBar = 'Company Name: ' + proper(m.goapp.cCompanyName) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ELSE
		          _VFP.StatusBar = 'Data Path: ' + LOWER(m.goapp.cdatafilepath) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ENDIF    
		    CATCH
		    ENDTRY    
		  ENDIF
		
		
	ENDPROC

	PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		  * Clear flag for select-all-on-entry behavior
		  IF THIS.SelLength > 0
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		*++
		* Special workaround for VFP5.0 quirks. If a control Valid fails when the user clicks on another form
		* the user cannot re-activate the original window by clicking on the control that failed validation.
		* We detect this case here and re-activate the window.
		*
		* May be able to dispose of this code in later versions of VFP, if they fix the problem.
		*--
		  IF THIS.lChanged
		    IF THISFORM.BaseClass == 'Form' AND NOT BITTEST(THISFORM.nControlFlags, FRMFLAG_ACTIVE)
		      ACTIVATE WINDOW (THISFORM.Name)
		    ENDIF
		  ENDIF
		
		  * Implement SelectOnEntry that will work in grids, and on entry by mouse-click.
		  IF THIS.SelLength = 0 AND BITTEST(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		    THIS.SelStart = 0
		    THIS.SelLength = LEN(TRIM(THIS.Text))
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		
	ENDPROC

	PROCEDURE Refresh
		*++
		* Reinitialize display properties from textbox's data source.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    THISFORM.cmBindingManager.InitBinding(THIS)
		  ENDIF
		
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_VALUE_LOADED) ;
		  OR BITTEST(THISFORM.nControlFlags, FRMFLAG_FORCE_RELOAD)
		    THIS.ShowControl()
		    THIS.LoadValue()
		    IF THIS.lValueMemory
		      THISFORM.cmBindingManager.DefaultFromMemory(THIS)
		    ENDIF
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		
	ENDPROC

	PROCEDURE RightClick
		*++
		* Put up context menu for textbox, if supported for this form.
		*--
		LOCAL cOption
		  IF PEMSTATUS(THISFORM, 'ContextMenuInit', 5)
		    * Use the binding manager to put up common data-bound control context menus. This will 
		    * make a callback to our own ContextMenuBuild() method for control-specific items.
		    IF THISFORM.ContextMenuInit(THIS) AND THISFORM.cmBindingManager.ContextMenuBuild(THIS)
		      m.cOption = THISFORM.ContextMenuActivate()
		      IF NOT EMPTY(m.cOption)
		        THIS.ContextMenuExecute(m.cOption)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& Set various control properties. Parameters are property name and value to set.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various control properties. Parameters are property name and value to set.
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		
		  m.cProperty = LOWER(m.cProperty)
		  DO CASE
		    CASE 'readonly' $ m.cProperty
		      THIS.lReadonly = m.uValue
		      THIS.ShowControl()
		
		    CASE 'enabled' $ m.cProperty
		      THIS.lEnabled = m.uValue
		      THIS.ShowControl()
		
		    CASE m.cProperty = 'value'
		      RETURN THIS.SetValue(@m.uValue)
		
		    CASE INLIST(m.cProperty, 'cvaluesource', 'controlsource')
		      THIS.cWorkarea = ''
		      THIS.cValueSource = m.uValue
		      THISFORM.cmBindingManager.LoadWorkarea(THIS)
		
		      IF THIS.lNativeBinding
		        * Update controlSource if using native binding, unless in a column with Bound set to .T.
		        IF NOT THIS.Parent.Baseclass == 'Column' OR NOT THIS.Parent.Bound
		          THIS.ControlSource = m.uValue
		        ENDIF
		      ENDIF
		      THIS.Refresh()
		
		    OTHERWISE
		      STORE m.uValue TO ('THIS.' + m.cProperty)
		  ENDCASE
		
	ENDPROC

	PROCEDURE setvalue		&& Set the textbox control's value
		LPARAMETERS cNewValue
		*++
		*>>Set the textbox control's value
		*--
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  THISFORM.cmBindingManager.InitBinding(THIS)
		  RETURN THISFORM.cmBindingManager.SetValue(THIS, m.cNewValue)
		
	ENDPROC

	PROCEDURE showcontrol		&& Re-evaluate security access, and update textbox display to reflect current state.
		*++
		*>>Re-evaluate security access, and update textbox display to reflect current state.
		* Called by Init and refresh methods. Checking security is a little slow, so it is optional.
		*--
		LOCAL lOldWriteLock
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  m.lOldWriteLock = THIS.lWriteLock
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * Check for no data or Write-Protect (explicit edit mode).
		  IF NOT THIS.lWriteLock AND NOT EMPTY(THIS.cValueSource) ;
		  AND (NOT EMPTY(THIS.cWorkarea) OR NOT THISFORM.lIgnoreBoundProperties)
		    IF EMPTY(THIS.cWorkarea)
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed()  && Only pass workarea parameter if non-empty
		    ELSE
		      THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea, SUBSTR(THIS.cValueSource, RAT('.', THIS.cValueSource) + 1))
		    ENDIF
		  ENDIF
		
		  * Apply or remove readonly display effect if read-only condition changed.
		  IF m.lOldWriteLock != THIS.lWriteLock
		    IF 'DIM' $ THIS.cReadOnlyDisplay
		      IF THIS.lWriteLock
		        IF ISNULL(THIS.nBackColor)
		          THIS.nBackColor = THIS.BackColor
		        ENDIF
		        IF ISNULL(THIS.nReadOnlyBackColor)
		          THIS.nReadOnlyBackColor = THIS.Parent.BackColor
		        ENDIF
		        THIS.BackColor = THIS.nReadOnlyBackColor
		      ELSE
		        IF NOT ISNULL(THIS.nBackColor)
		          THIS.BackColor = THIS.nBackColor
		        ENDIF
		      ENDIF
		    ENDIF
		    THIS.MousePointer = IIF(THIS.lWriteLock, 1, 0)  && Change cursor to arrow while read-only.
		  ENDIF
		
		  * Control is Disabled if readonly (optionaly), or if datasource is EOF().
		  IF THIS.lWriteLock AND 'DISABLE' $ THIS.cReadOnlyDisplay
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
		  * Update linked label control, if any.
		  IF NOT EMPTY(THIS.cLinkedLabel)
		    LOCAL oLabel
		    m.oLabel = EVALUATE('THIS.Parent.' + THIS.cLinkedLabel)
		    m.oLabel.Visible = THIS.Visible
		    m.oLabel.Refresh()
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the textbox.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT   && Don't process native help if using Codemine context help
		
		      * Customize class help keys for optional features in this instance of the control.
		      IF NOT EMPTY(THIS.cHelpClassKey)  && If no class help, leave it empty
		        THIS.cHelpClassKey = LOWER(THIS.cHelpClassKey)
		        IF THIS.lAllowZoom AND NOT '%hlpzoomedit' $ THIS.cHelpClassKey
		          THIS.cHelpClassKey = THIS.cHelpClassKey + ',%hlpzoomedit'
		        ENDIF
		        IF THIS.lValueMemory AND NOT '%hlpvaluememory' $ THIS.cHelpClassKey
		          THIS.cHelpClassKey = THIS.cHelpClassKey + ',%hlpvaluememory'
		        ENDIF
		      ENDIF
		      THISFORM.DisplayHelp(THIS)    && And display the help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE storememory		&& Save current value in system registry for later use.
		*++
		*>>Save current value in system registry for later use.
		*--
		  RETURN THISFORM.cmBindingManager.StoreMemory(THIS, THIS.GetValue())
		
	ENDPROC

	PROCEDURE storetranslation		&& Translate control value into a format suitable for storage in bound data source.
		LPARAMETERS uValue
		*++
		*>>Translate control value into a format suitable for storage in bound data source.
		*--
		  IF NOT EMPTY(this.cEncryptionkey)
		     * If we've set an encryption key on a textbox, replace it with the global encryption key
		     this.cEncryptionkey = m.goApp.cEncryptionKey
		  ENDIF 
		  IF NOT EMPTY(THIS.cEncryptionKey) AND VARTYPE(m.uValue) = 'C'
		    RETURN cmEncrypt(m.uValue, THIS.cEncryptionKey)
		  ENDIF
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE storevalue		&& Write textbox value back to data source using table or memvar syntax as appropriate.
		LPARAMETERS uValue
		*++
		*>>Write textbox value back to data source using table or memvar syntax as appropriate.
		*--
		  RETURN THISFORM.cmBindingManager.StoreValue(THIS, IIF(PCOUNT() > 0, m.uValue, THIS.GetValue()))
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnableEvent
		*++
		* Controls in a page need to be refreshed when the page activates
		* because they miss refresh events when their page is inactive.
		*--
		  * Pages in Forms instaniated from a VCX trigger UIenable events for the initial active
		  * page, before the form is visible. We ignore these events, as they can mess up lNoInitData.
		  IF m.lEnableEvent AND THISFORM.Visible
		    IF PEMSTATUS(THIS, 'nControlFlags', 5)
		      THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_VALUE_LOADED)
		      THIS.Refresh()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE undochanges		&& Undo changes to the current textbox, and restore original value.
		*++
		*>>Undo changes to the current textbox, and restore original value.
		*--
		  IF EMPTY(THIS.cValueSource)
		    THIS.Value = THIS.uOriginalValue
		  ELSE
		    THIS.LoadValue()
		  ENDIF
		  THIS.lChanged = .F.
		
	ENDPROC

	PROCEDURE Valid
		*++
		*>>If value has changed, call the FieldValid() event, and store value to datasource on success.
		*--
		  IF THISFORM.cmBindingManager.ValidNeeded(THIS)
		    * Convert to proper capitalization if desired
		    IF THIS.lPropercase AND VARTYPE(THIS.Value) $ 'CM'
		      IF ISNULL(THISFORM.oString)
		        THIS.Value = PROPER(THIS.Value)
		      ELSE
		        THIS.Value = THISFORM.oString.ProperCase(THIS.Value)
		      ENDIF
		    ENDIF
		
		    * Call binding manager for the remaining common control valid() processing.
		    RETURN THISFORM.cmBindingManager.Valid(THIS)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE When
		*++
		* Determine when the textbox control is allowed to receive focus.
		*--
		  IF TYPE('THISFORM') = 'O'
		    RETURN THISFORM.cmBindingManager.When(THIS)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE
