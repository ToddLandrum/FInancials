*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmregkey.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cmbinarykeyeditorabstract AS cmserviceabstract OF "..\common\cmdataa.vcx" 		&& Class abstract for custom binary key editors.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: comments
		*m: defaultkeyproperties		&& Establish default key properties when datatype is changed. Called from keyedit only.
		*m: editvalue		&& Call editor form to edit a key value. Called from regedit only. Returns .T. if value changed.
		*m: omessage_access
		*m: ondeletekey		&& Called before key is deleted. Return .T. if ok to delete.
		*m: oregistry_access
		*m: osecurity_access
		*m: validatekeyproperties		&& Validate key properties. Called from keyedit only, to validate a key being created or edited.
		*p: crequiredcategory		&& If this key type must be added under a specific category, specify the category here.
		*p: ladministrator		&& Set to .T. if key protection must be Administrator or Developer access only.
		*p: lnoreplicate		&& If user key replication is not allowed for this key type, set lNoReplicate to .T.
		*p: omessage		&& Runtime object reference to the Message Manager
		*p: oregistry		&& Runtime object reference to the App Registry Manager
		*p: osecurity		&& Runtime object reference to the Security Manager
	*</DefinedPropArrayMethod>

	crequiredcategory = 		&& If this key type must be added under a specific category, specify the category here.
	ladministrator = .F.		&& Set to .T. if key protection must be Administrator or Developer access only.
	lnoreplicate = .F.		&& If user key replication is not allowed for this key type, set lNoReplicate to .T.
	Name = "cmbinarykeyeditorabstract"
	omessage = .NULL.		&& Runtime object reference to the Message Manager
	oregistry = .NULL.		&& Runtime object reference to the App Registry Manager
	osecurity = .NULL.		&& Runtime object reference to the Security Manager
	
	PROCEDURE comments
		*++
		* CodeMine application registry binary key editor support classes. These are used by other classes
		* who define custom binary key formats to pack unpack, and edit their key values. For example, the 
		* security and message objects define classes based on these.
		*
		* Copyright 1997-2002 Soft Classics, Ltd.
		*--
		
	ENDPROC

	PROCEDURE defaultkeyproperties		&& Establish default key properties when datatype is changed. Called from keyedit only.
		LPARAMETERS oKey
		*++
		*>>Establish default key properties when datatype is changed. Called from keyedit only.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE editvalue		&& Call editor form to edit a key value. Called from regedit only. Returns .T. if value changed.
		LPARAMETERS oKey
		*++
		*>>Call editor form to edit a key value. Called from regedit only. Returns .T. if value changed.
		*--
		  RETURN .F.
		
	ENDPROC

	PROCEDURE omessage_access
		  IF ISNULL(THIS.oMessage)
		    THIS.oMessage = FindGlobalObject('cmMessage')
		  ENDIF
		  RETURN THIS.oMessage
		
	ENDPROC

	PROCEDURE ondeletekey		&& Called before key is deleted. Return .T. if ok to delete.
		LPARAMETERS oKey
		*++
		*>>Called before key is deleted. Return .T. if ok to delete. 
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE oregistry_access
		  IF ISNULL(THIS.oRegistry)
		    THIS.oRegistry = FindGlobalObject('cmRegistry')
		  ENDIF
		  RETURN THIS.oRegistry
		
	ENDPROC

	PROCEDURE osecurity_access
		  IF ISNULL(THIS.oSecurity)
		    THIS.oSecurity = FindGlobalObject('cmSecurity')
		  ENDIF
		  RETURN THIS.oSecurity
		
	ENDPROC

	PROCEDURE validatekeyproperties		&& Validate key properties. Called from keyedit only, to validate a key being created or edited.
		LPARAMETERS oKey
		*++
		*>>Validate key properties. Called from keyedit only, to validate a key being created or edited.
		* Return .T. if ok.
		*--
		LOCAL cError
		  DO CASE
		    CASE m.oKey.oOldVal.Type == KEY_TYPE_BINARY AND (m.oKey.nType != KEY_TYPE_BINARY ;
		         OR NOT TRIM(m.oKey.cExternalType) == TRIM(m.oKey.oOldVal.shortValue))
		      m.cError = m.oKey.cKeyPath + ' - You cannot change the data type of an External Binary key after it has been created.'
		
		    CASE NOT EMPTY(THIS.cRequiredCategory) AND RIGHT(THIS.cRequiredCategory, 1) = '.' ;
		         AND AT(UPPER(THIS.cRequiredCategory), UPPER(m.oKey.cCategory)) != 1
		      m.cError = TRIM(m.oKey.cExternalType) + ' keys may only be created under the appropriate subcategory of "' + THIS.cRequiredCategory + '"'
		
		    CASE NOT EMPTY(THIS.cRequiredCategory) AND NOT RIGHT(THIS.cRequiredCategory, 1) = '.' ;
		         AND NOT UPPER(THIS.cRequiredCategory) == UPPER(m.oKey.cCategory)
		      m.cError = TRIM(m.oKey.cExternalType) + ' keys may only be created under the "' + THIS.cRequiredCategory + '" category'
		
		    CASE THIS.lNoReplicate AND m.oKey.nReplicationType != KEY_REPLICATE_NONE
		      m.cError = TRIM(m.oKey.cExternalType) + ' keys cannot have Replication enabled'
		
		    CASE THIS.lAdministrator AND m.oKey.nAccess > KEY_ACCESS_ADMIN
		      m.cError = TRIM(m.oKey.cExternalType) + ' keys must be set to Administrator or Developer Access only'
		  ENDCASE
		
		  IF NOT EMPTY(m.cError)
		    THIS.oMessage.Warning(m.cError, 48, 'Invalid ' + TRIM(m.oKey.cExternalType) + ' Key Property')
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmbinarykeyvalueabstract AS cmdatatransport OF "cmdataa.vcx" 		&& Pack and unpack binary app registry key values.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: cname		&& Name of this value, set by the Scatter method for values that have names (such as groups, usernames, etc)
	*</DefinedPropArrayMethod>

	cname = BinaryKeyValue		&& Name of this value, set by the Scatter method for values that have names (such as groups, usernames, etc)
	Name = "cmbinarykeyvalueabstract"
	
	PROCEDURE comments
		*++
		* Pack and unpack binary app registry key values.
		*
		* These are used by other classes who define custom binary key formats to pack unpack,
		* and edit their key values. For example, the security and message objects define classes 
		* based on these.
		*
		* Copyright 1997-2005 Soft Classics, Ltd.
		*--
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmhelpkeyeditor AS cmbinarykeyeditorabstract OF "cmregkey.vcx" 		&& External Binary key value editor class for "Help" keys
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	crequiredcategory = Message.Help Messages
	lnoreplicate = .T.
	Name = "cmhelpkeyeditor"
	
	PROCEDURE defaultkeyproperties
		LPARAMETERS oKey
		*++
		*>>Establish default key properties when datatype is changed.
		* Called from keyedit only.
		*--
		  * Default to administrator access for messages
		  m.oKey.nAccess = KEY_ACCESS_ADMIN
		  IF EMPTY(m.oKey.cDescription)
		    m.oKey.cDescription = 'Help Message'
		  ENDIF
		
	ENDPROC

	PROCEDURE editvalue
		LPARAMETERS oKey
		*++
		*>>Call editor form to edit key value.
		* Called from regedit only. Returns .T. if value changed.
		*--
		LOCAL oEditor
		
		  * The key value contains packed help text properties. Pass it along with the 
		  * key name and description to the editor form.
		  m.oEditor = CreateLocalized('frmHelpKeyEditor', ;
		                m.oKey.cValue, m.oKey.cLocName, m.oKey.cDescription)
		  m.oEditor.Show(1)
		
		  * Retrieve modified properties from the editor form, and release it.
		  IF VARTYPE(m.oEditor) = 'O' AND m.oEditor.uValue
		    m.oKey.cValue = m.oEditor.cKeyValue
		    m.oKey.cDescription = m.oEditor.cDescription
		    m.oEditor.Release()
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmlanguagekeyeditor AS cmbinarykeyeditorabstract OF "cmregkey.vcx" 		&& External Binary key value editor class for Language keys
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	crequiredcategory = Message.Languages
	lnoreplicate = .T.
	Name = "cmlanguagekeyeditor"
	
	PROCEDURE defaultkeyproperties
		LPARAMETERS oKey
		*++
		*>>Establish default key properties when datatype is changed.
		* Called from keyedit only.
		*--
		  * Default to administratorr only access for languages
		  m.oKey.nAccess = KEY_ACCESS_ADMIN
		
	ENDPROC

	PROCEDURE editvalue
		LPARAMETERS oKey
		*++
		*>>Call editor form to edit key value.
		* Called from regedit only. Returns .T. if value changed.
		*--
		LOCAL oEditor
		
		  m.oEditor = CreateLocalized('frmLanguageKeyEditor', ;
		                                  m.oKey.cValue, m.oKey.cLocName)
		  m.oEditor.Show(1)
		
		  * Retrieve modified properties from the editor form, and release it.
		  IF VARTYPE(m.oEditor) = 'O' AND m.oEditor.uValue
		    m.oKey.cValue = m.oEditor.cKeyValue
		    m.oEditor.Release()
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE ondeletekey
		LPARAMETERS oKey
		*++
		*>>Delete all message translations before deleting the language definition key.
		*--
		LOCAL ix, cLangID, cName, cLocName, cValue, oLanguage, oValue
		
		  * Dont't allow deletion of the current active language.
		  m.oLanguage = CreateNewObject('cmLanguageValue')
		  m.oLanguage.Scatter(m.oKey.cValue)
		  m.cLangID = m.oLanguage.cLanguageID
		  IF NOT EMPTY(m.cLangID)
		    IF m.cLangID == THIS.oMessage.cLanguageID
		      THIS.oMessage.Warning('You cannot delete "\c" because it is the current language', m.oKey.cLocName)
		      RETURN .F.
		    ENDIF
		
		    * Make sure no other language is based on this one.
		    DO WHILE THIS.oRegistry.EnumKeys('%Local.Message.Languages', 'Language', @m.ix, , @m.cLocName, @m.cValue) > 0
		      m.oLanguage.Scatter(m.cValue)
		      IF m.oLanguage.cParentLanguageID == m.cLangID
		        THIS.oMessage.Warning('You cannot delete "\c" because "\c" is based on it.', ;
		              m.oKey.cLocName, m.cLocName)
		        RETURN .F.
		      ENDIF
		    ENDDO
		    
		    * Delete all message key translations for this language.
		    m.oValue = CreateNewObject('cmMessageValue')
		    m.ix = 0
		    DO WHILE THIS.oRegistry.EnumKeys('%Local.Message.**', 'Message', @m.ix, @m.cName,, @m.cValue) > 0
		      m.oValue.Scatter(m.cValue)
		      m.oValue.DeleteText(m.cLangID)
		      THIS.oRegistry.SetKeyValue('%Local.Message.' + m.cName, m.oValue.Gather())
		    ENDDO
		
		    * Process all Help keys too
		    m.oValue = CreateNewObject('cmHelpValue')
		    m.ix = 0
		    DO WHILE THIS.oRegistry.EnumKeys('%Local.Message.**', 'Helptext', @m.ix, @m.cName,, @m.cValue) > 0
		      m.oValue.Scatter(m.cValue)
		      m.oValue.DeleteText(m.cLangID)
		      THIS.oRegistry.SetKeyValue('%Local.Message.' + m.cName, m.oValue.Gather())
		    ENDDO
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmmessagekeyeditor AS cmbinarykeyeditorabstract OF "cmregkey.vcx" 		&& External Binary key value editor class for Message keys
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	crequiredcategory = Message.
	lnoreplicate = .T.
	Name = "cmmessagekeyeditor"
	
	PROCEDURE defaultkeyproperties
		LPARAMETERS oKey
		*++
		*>>Establish default key properties when datatype is changed.
		* Called from keyedit only.
		*--
		  * Default to administrator access for messages
		  m.oKey.nAccess = KEY_ACCESS_ADMIN
		
	ENDPROC

	PROCEDURE editvalue
		LPARAMETERS oKey
		*++
		*>>Call editor form to edit a message key value.
		* Called from regedit only. Returns .T. if value changed.
		*--
		LOCAL oEditor
		
		  * The key value contains packed group properties. Pass it along with the 
		  * key name and description to the editor form.
		  m.oEditor = CreateLocalized('frmMessageKeyEditor', m.oKey.cValue, ;
		                   m.oKey.cLocName, m.oKey.cDescription, m.oKey.cCategory)
		  m.oEditor.Show(1)
		
		  * Retrieve modified properties from the editor form, and release it.
		  IF VARTYPE(m.oEditor) = 'O' AND m.oEditor.uValue
		    m.oKey.cValue = m.oEditor.cKeyValue
		    m.oKey.cDescription = m.oEditor.cDescription
		    m.oEditor.Release()
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmregcursor AS cmcursor OF "cmdata.vcx" 		&& PRGTOVCX.CONVERT converted from c:\codemine\common\cmregkey.prg, 02/28/2004 03:50:46 PM
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: createcounter		&& Create a new counter with the specified properties, and return a reference to the key obejct.
		*m: deleteallreplicatedvalues		&& Delete all user replications for the specified key. Does not delete the base (default) value for the key.
		*m: deletekey		&& Delete the specified key, and any value replications for it. If it is a category key, all sub-keys are also deleted.
		*m: deletereplicatedvalue		&& Delete the current user replication for the specified key. Does not delete the base (default) value for the key.
		*m: deleteuserreplications		&& Delete all key value replications for the specified user ID. Usually called when a user is deleted from the security system.
		*m: getkey		&& Fill in the specified Key Properties object with details of the specified key.
		*m: getreplicatedvalue		&& Format and return the user-specific value for the current registry record.
		*m: getvalue		&& Format and return value of current registry record.
		*m: localize		&& Localize registry key names and description to the specified language, using the specified translation table.
		*m: lockcounter		&& Find or Create a counter object, lock the associated record, and return a reference to the counter object.
		*m: newkey		&& Create and return a new empty key properties object.
		*m: newwithcategories		&& Given a full key name path, add the key record along with any missing category records necessary to complete the full path.
		*m: renamekey		&& Rename the specified key to the specified name, propogating changes to all replications and subordinate keys.
		*m: selectkeys		&& Load the matching key records into the local cursor.
		*m: setcategoryaccess		&& Set the access level for all keys under the specified category.
		*m: setkey		&& Gather all the key properties and store them back in the registry record.
		*m: setreplicatedvalue		&& Replicate record if needed, and Store specified value.
		*m: setvalue		&& Store specified value in appropriate format to current registry record.
		*m: stringtodate		&& Convert a universal date string to VFP internal date format.
		*m: _findreplicatedrecord		&& Search the local recordset for the current user's replicated value for the current base record.
	*</DefinedPropArrayMethod>

	corder = keyName
	lnodataonload = .T.
	lrecyclerecords = .T.
	Name = "cmregcursor"
	nbuffermode = 5
	
	PROCEDURE comments
		*++
		* Custom cursor object subclass for application registry table access.
		*
		* This subclass impliments the details for accessing and maintaining discreet
		* key values for user-replicated keys. It also takes care of differences between 
		* appreg tables stored localy or in remote views.
		*
		* Copyright 2002 Soft Classics, Ltd. All Rights Reserved Worldwide.
		*--
		
	ENDPROC

	PROCEDURE create
		*++
		*>>Create a new registry table in the specified DBC
		*--
		LOCAL cDBFname
		
		  SET DATABASE TO (THIS.cDatabase)
		  m.cDBFname = FULLPATH(JUSTSTEM(DBC()) + '_' + PROPER(THIS.cSource) + '.dbf', DBC())
		
		  THIS.nLastError = 0
		  CREATE TABLE (m.cDBFname) NAME (THIS.cSource) ( ;
		     KeyName     C(70) NOT NULL, ;
		     LocName     C(80) NOT NULL, ;
		     RepKey      C(4)  NULL, ;
		     RepType     I NOT NULL, ;
		     Type        I NOT NULL, ;
		     Access      I NOT NULL, ;
		     Shortvalue  C(30) NULL, ;
		     Value       Memo NULL, ;
		     Properties  Memo NULL, ;
		     Comment     Memo NULL  )
		
		  IF (THIS.nLastError = 0)
		    INDEX ON DELETED() TAG Deleted
		    INDEX ON UPPER(keyname)+repkey TAG KeyName
		    INDEX ON OCCURS(".", keyname) TAG Level
		
		    * Leave the new table closed, so it can be opened normally (shared) later.
		    USE
		  ENDIF
		  RETURN (THIS.nLastError = 0)
		
	ENDPROC

	PROCEDURE createcounter		&& Create a new counter with the specified properties, and return a reference to the key obejct.
		LPARAMETERS cKeyPath, nLength, nFormat, nReset, nInitialValue
		*++
		*>>Create a new counter with the specified properties, and return a reference to the key obejct.
		*--
		LOCAL oKey
		  * Apply default values to parameters
		  IF EMPTY(m.nLength)
		    m.nLength = 4
		  ENDIF
		  IF NOT VARTYPE(m.nFormat) $ 'NI'   && 0 Is a valid type, so can't test for empty
		    m.nFormat = COUNTER_TYPE_NUMERIC
		  ENDIF
		  IF EMPTY(m.nReset)
		    m.nReset = COUNTER_RESET_WRAP
		  ENDIF
		
		  * Create a new registry key record for the counter.
		  IF THIS.NewKey(m.cKeyPath, @m.oKey)
		    WITH m.oKey
		      .nType = KEY_TYPE_COUNTER
		      .nAccess = KEY_ACCESS_DEVELOPER
		      .cDescription = 'Primary Key Counter'
		      .nCounterLength = m.nLength
		      .nCounterFormat = m.nFormat
		      .nCounterReset = m.nReset
		      .nValue = IIF(EMPTY(m.nInitialValue), 0, m.nInitialValue)
		      .dValue = {}
		    ENDWITH
		
		    * Write the new key record to the appreg table, and return reference to the key object.
		    IF THIS.SetKey(m.oKey)
		      RETURN m.oKey
		    ENDIF
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE deleteallreplicatedvalues		&& Delete all user replications for the specified key. Does not delete the base (default) value for the key.
		LPARAMETERS cKeyPath
		*++
		*>>Delete all user replications for the specified key. Does not delete the base (default) value for the key.
		* Needed when the replication type of a key is changed from USER to NONE.
		*--
		  * Note that the key name passed must match exactly (is expected to be padded to full length).
		  SELECT (THIS.cWorkarea)
		  RETURN THIS.DeleteWhere("UPPER(RTRIM(keyName)) == '" +  UPPER(RTRIM(m.cKeyPath)) + "' AND repKey > '" + SPACE(LEN(repKey)) + "'", ;
		                   UPDATEMASK_COMMIT + UPDATEMASK_REQUERY)
		
	ENDPROC

	PROCEDURE deletekey		&& Delete the specified key, and any value replications for it. If it is a category key, all sub-keys are also deleted.
		LPARAMETERS cKeyPath, nFlags
		*++
		*>>Delete the specified key, and any value replications for it. If it is a category key, all sub-keys are also deleted.
		*
		* nFlags parameter bits:
		*   REGMASK_LOG        - Record the change in the event log.
		*--
		LOCAL oKey, cExternalClass, oExternalEditor
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  m.oKey = CREATEOBJECT('cmRegProperties')
		  IF NOT THIS.GetKey(m.cKeyPath, m.oKey)
		    RETURN .F.    && Key not found
		  ENDIF
		
		  * If this is an external binary key, and there is an external class editor for it, call its OnDelete() method.
		  IF m.oKey.nType = KEY_TYPE_BINARY
		    m.cExternalClass = THIS.Parent.GetExternalEditorClass(m.oKey.cExternalType)
		    IF NOT EMPTY(m.cExternalClass)
		      m.oExternalEditor = CREATEOBJECT(m.cExternalClass)
		      IF NOT m.oExternalEditor.OnDeleteKey(m.oKey)
		        RETURN .F.
		      ENDIF
		    ENDIF
		  ENDIF
		
		  THIS.DeleteWhere("UPPER(LEFT(keyName, " + STR(LEN(m.cKeyPath)) + ")) = '" + UPPER(m.cKeyPath) + "'", ;
		                   UPDATEMASK_COMMIT + UPDATEMASK_REQUERY)
		
		  * Write an event log message describing the key change, if requested.
		  IF NOT EMPTY(BITAND(m.nFlags, REGMASK_LOG)) AND NOT ISNULL(THIS.oSecurity)
		    THIS.oSecurity.RecordEvent(EVENT_REG_DELETE, EVENT_TYPE_REGISTRY, m.cKeyPath)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE deletereplicatedvalue		&& Delete the current user replication for the specified key. Does not delete the base (default) value for the key.
		LPARAMETERS cKeyPath
		*++
		*>>Delete the current user replication for the specified key. Does not delete the base (default) value for the key.
		*--
		LOCAL nRecno
		
		  SELECT (THIS.cWorkarea)
		  m.nRecno = THIS._FindReplicatedRecord(.T.)
		  IF NOT EMPTY(repKey)
		    THIS.Delete(UPDATEMASK_COMMIT)
		  ENDIF
		  GOTO (m.nRecno)    && Always leave record pointer on the original base record.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE deleteuserreplications		&& Delete all key value replications for the specified user ID. Usually called when a user is deleted from the security system.
		LPARAMETERS cReplicationID
		*++
		*>>Delete all key value replications for the specified user ID. Usually called when a user is deleted from the security system.
		*--
		  SELECT (THIS.cWorkarea)
		  RETURN THIS.DeleteWhere("repKey = '" + PADR(m.cReplicationID, LEN(repKey)) + "'", UPDATEMASK_COMMIT)
		
	ENDPROC

	PROCEDURE find
		LPARAMETERS eFor, lContinue
		*++
		*>>Find the first record in the cursor that matches the specified expression. If lContinue parameter is .T. the search begins with the current record.
		*--
		  IF THIS.RecordReadyToMove()
		    IF THIS.cmDataAccess.Find(@m.eFor, m.lContinue)
		*!*	ACTIVATE SCREEN
		*!*	SELECT (this.cWorkarea)
		*!*	GO (RECNO())
		*!*	?'Found key:',TRIM(EVALUATE(THIS.cWorkarea + '.keyname')), EVALUATE(THIS.cWorkarea + '.ShortValue')
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getkey		&& Fill in the specified Key Properties object with details of the specified key.
		LPARAMETERS cKeyPath, oKey
		*++
		*>>Fill in the specified Key Properties object with details of the specified key.
		*--
		  * Create the key object, if none was passed to us.
		  IF VARTYPE(m.oKey) != 'O'
		    m.oKey = CREATEOBJECT('cmRegProperties')
		  ENDIF
		
		  * Load the appropriate records into the cursor. Return failure if record cannot be found.
		  IF THIS.SelectKeys(m.cKeyPath,, 'User')
		    WITH m.oKey
		      * Remember the appreg cursor we loaded data from.
		      .cWorkarea = THIS.cWorkarea
		      .lReadonly = THIS.IsReadOnly()
		
		      * For native VFP tables, we can use RECNO as a fast way to return to this record later.
		      .nRecno = IIF(THIS.cmDataAccess.lSelectByRequery, 0, THIS.Recno())
		
		      * Store a copy of original values for easy comparisons when testing for changes.
		      SCATTER MEMO NAME .oOldVal
		
		      * Load the value (possibly user-replicated) and leave default (base) record current.
		      DO CASE
		        CASE type = KEY_TYPE_LOGICAL
		          .lValue = THIS.GetReplicatedValue()
		        CASE type = KEY_TYPE_NUMERIC
		          .nValue = THIS.GetReplicatedValue()
		        CASE type = KEY_TYPE_COUNTER
		          .nValue = INT(VAL(LEFT(shortValue, 16)))
		          IF THIS.IsField('date')
		            .dValue = NVL(date, {})
		          ELSE
		            .dValue = THIS.StringToDate(SUBSTR(shortValue, 17, 8))
		          ENDIF
		        OTHERWISE
		          .cValue = THIS.GetReplicatedValue()
		      ENDCASE
		
		      * Load remaining property values from original (oOldVal) values
		      .Load()
		    ENDWITH
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getreplicatedvalue		&& Format and return the user-specific value for the current registry record.
		*++
		*>>Format and return the user-specific value for the current registry record.
		*--
		LOCAL uValue, nRecno, nType
		
		  * Type is only stored in base record, so get it before moving to replicated value record.
		  m.nType = type
		
		  * Find correct replication, get value, and return to base record.
		  m.nRecno = THIS._FindReplicatedRecord()
		  m.uValue = THIS.GetValue(m.nType)
		  GOTO (m.nRecno)    && Always leave record pointer on the original base record.
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE getvalue		&& Format and return value of current registry record.
		LPARAMETERS nType
		*++
		*>>Format and return value of current registry record.
		*--
		LOCAL uValue
		
		  * If no type specified, use the type from the current record. Type must
		  * be passed to us for replicated value records.
		  SELECT (THIS.cWorkarea)
		  IF EMPTY(m.nType)
		    m.nType = type
		  ENDIF
		
		  DO CASE
		    CASE INLIST(m.nType, KEY_TYPE_MEMO, KEY_TYPE_BINARY, KEY_TYPE_PATH)
		      m.uValue = Value
		
		    CASE m.nType = KEY_TYPE_NUMERIC
		      m.uValue = VAL(shortValue)
		
		    CASE m.nType = KEY_TYPE_LOGICAL
		      IF ISNULL(shortValue)
		        m.uValue = .NULL.
		      ELSE
		        m.uValue = NOT EMPTY(shortValue)
		      ENDIF
		
		    OTHERWISE
		      m.uValue = TRIM(shortValue)
		  ENDCASE
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE import
		LPARAMETERS cCategory, cFromPath, lOverwrite
		*++
		*>>Import the specified registry key(s) from the specified source table.
		*--
		LOCAL oSource, lStatus
		
		  * No category, or wildcard (*) means to include all categories in the source table.
		  IF EMPTY(m.cCategory) OR '*' $ m.cCategory
		    m.cCategory = '*'
		  ELSE
		    m.cCategory = UPPER(m.cCategory) + '*'
		  ENDIF
		
		  * If only a path is specified, default to the same name as the target table, if it is a dbf.
		  IF EMPTY(JUSTFNAME(m.cFromPath))
		    DO CASE
		      CASE '.DBF' $ DBF(THIS.cWorkarea)
		        * For native VFP table, default to import source of the same table name.
		        m.cFromPath = FORCEPATH(DBF(THIS.cWorkarea), m.cFromPath)
		      CASE THIS.GetProp('SourceType') = 2
		        * If we are a remote table, default to an import source the same as the remote table name.
		        m.cFromPath = FORCEPATH(THIS.GetProp('Table') + '.dbf', m.cFromPath)
		    ENDCASE
		  ENDIF
		
		  m.oSource = CREATEOBJECT('cmCursor', m.cFromPath, 'cmImportSource', 'Readonly')
		  IF VARTYPE(m.oSource) != 'O'
		    RETURN .F.
		  ENDIF
		
		  m.lStatus = .T.
		  SELECT cmImportSource
		  SCAN FOR NOT DELETED() AND LIKE(m.cCategory, UPPER(TRIM(KeyName)))
		    IF THIS.SelectKeys(TRIM(cmImportSource.KeyName),, 'Global')
		      IF NOT m.lOverwrite
		        LOOP
		      ENDIF
		    ELSE
		      * Add the new record, along with any missing category records in the path.
		      THIS.NewWithCategories(cmImportSource.KeyName, cmImportSource.LocName, ;
		                             cmImportSource.Type, cmImportSource.Access)
		    ENDIF
		
		    SELECT (THIS.cWorkarea)
		    REPLACE RepType WITH cmImportSource.RepType, ;
		            RepKey WITH '', ;
		            Type WITH cmImportSource.Type, ;
		            Access WITH cmImportSource.Access, ;
		            ShortValue WITH cmImportSource.ShortValue, ;
		            Value WITH cmImportSource.Value, ;
		            Properties WITH cmImportSource.Properties, ;
		            Comment WITH cmImportSource.Comment
		
		    * If we have a separate date field, and source record is a counter we need to
		    * convert date storage format between packed in shortValue, or separate field.
		    IF THIS.IsField('Date')
		      IF m.oSource.IsField('Date')
		        REPLACE Date WITH cmImportSource.Date
		      ELSE
		        IF cmImportSource.Type = KEY_TYPE_COUNTER
		          REPLACE Date WITH THIS.StringToDate(SUBSTR(shortValue, 17, 8))
		        ENDIF
		      ENDIF
		    ENDIF
		    
		    * Commit the changes for each record as we go, since each call to SelectKeys() may result in a requery.
		    m.lStatus = THIS.Update()
		    IF NOT m.lStatus
		      THIS.Revert()
		      EXIT
		    ENDIF
		  ENDSCAN
		
		  m.oSource.Close()
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE localize		&& Localize registry key names and description to the specified language, using the specified translation table.
		LPARAMETERS cCategory, cTable, cLanguage
		*++
		*>>Localize registry key names and description to the specified language, using the specified translation table.
		*--
		LOCAL lStatus, oSource, oProperties, nLevel, cLocalizedName
		
		  * Open the source table containing the localized translations for the various keys.
		  m.oSource = CREATEOBJECT('cmCursor', m.cTable, 'cmLocalize', 'Readonly')
		  IF VARTYPE(m.oSource) = 'O'
		    m.oSource.SetOrder('KeyName')
		
		    * Pull down all keys and subordinates in the specified category.
		    m.cCategory = UPPER(TRIM(m.cCategory))
		    IF THIS.SelectKeys(m.cCategory + '**') 
		      SELECT cmLocalize
		      SCAN FOR UPPER(Language) = PADR(UPPER(m.cLanguage), LEN(Language)) ;
		               AND UPPER(cmLocalize.KeyName) = m.cCategory AND NOT DELETED()
		
		        * Find the correct record. use an expression that can be optimized when using native tables.
		        SELECT (THIS.cWorkarea)
		        IF THIS.Find('UPPER(keyName) + RepKey == "' + PADR(UPPER(cmLocalize.keyname), LEN(keyName + repKey)) + '"')
		
		          * Localize comment and specialize fields in the base record only.
		          IF NOT EMPTY(cmLocalize.comment)
		            REPLACE comment WITH TRIM(cmLocalize.comment) IN (THIS.cWorkarea)
		          ENDIF
		
		          * Process special translations for specific fields in certain key types.
		          DO CASE
		            CASE type = KEY_TYPE_LOGICAL AND NOT EMPTY(cmLocalize.String1)
		              * For logical key types, localize the true and false value strings
		              m.oProperties = CREATEOBJECT('cmRegProperties')
		              WITH m.oProperties
		                .nType = type
		                .Scatter(properties)
		                .cLogTrue = TRIM(cmLocalize.String1)
		                .cLogFalse = TRIM(cmLocalize.String2)
		                REPLACE properties WITH .Gather() IN (THIS.cWorkarea)
		              ENDWITH
		
		            CASE type = KEY_TYPE_CHAR AND NOT EMPTY(cmLocalize.String1)
		              REPLACE shortValue WITH TRIM(cmLocalize.String1) IN (THIS.cWorkarea)
		
		            CASE type = KEY_TYPE_MEMO AND NOT EMPTY(cmLocalize.String1)
		              REPLACE value WITH TRIM(cmLocalize.String1) IN (THIS.cWorkarea)
		          ENDCASE
		
		          * Replace the localized name in all replications and subkeys. Ensure new name has same depth as original.
		          SELECT (THIS.cWorkarea)
		          IF OCCURS('.', locName ) == OCCURS('.', cmLocalize.locName)
		            m.cLocalizedName = TRIM(cmLocalize.locname)
		            m.nLevel = OCCURS('.', m.cLocalizedName)
		            REPLACE locName WITH STUFF(locName, 1, AT('.', locname, m.nLevel), m.cLocalizedName) ;
		                    FOR UPPER(LEFT(keyName, LEN(TRIM(cmLocalize.keyname)))) == UPPER(TRIM(cmLocalize.keyname))
		          ENDIF
		        ENDIF
		      ENDSCAN
		      
		      * Commit changes when category localization is complete.
		      m.lStatus = THIS.Update()
		      IF NOT m.lStatus
		        THIS.Revert()
		      ENDIF
		    ENDIF
		
		    m.oSource.Close()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE lockcounter		&& Find or Create a counter object, lock the associated record, and return a reference to the counter object.
		LPARAMETERS cKeyPath, nLength, nFormat, nInitialValue
		*++
		*>>Find or Create a counter object, lock the associated record, and return a reference to the counter object.
		*
		* If nLength/nFormat parameters are specified, and the counter does not exist,
		* then a new counter is created automaticaly.
		*--
		LOCAL oKey
		
		  * Find or create the specified counter, as appropriate.
		  IF NOT THIS.GetKey(m.cKeyPath, @m.oKey)
		    IF NOT VARTYPE(m.nLength) $ 'NI'
		      ERROR 'Counter "' + m.cKeyPath + '" is not found.'
		      RETURN .NULL.
		    ENDIF
		
		    * If counter not found, and length/format were specified, create a new counter.
		    m.oKey = THIS.CreateCounter(m.cKeyPath, m.nLength, m.nFormat, 0, m.nInitialValue)
		  ENDIF
		
		  * Make sure the key type is a counter. Fatal error if not.
		  IF ISNULL(m.oKey) OR m.oKey.nType != KEY_TYPE_COUNTER
		    ERROR 'Key "' + m.cKeyPath + '" is not a Counter.'
		    RETURN .NULL.
		  ENDIF
		
		  * Now current cursor record has the key we need. Lock it, an load values into key object.
		  IF THIS.LockRecord()
		    * ReLoad current counter value after the record is locked.
		    m.oKey.nValue = INT(VAL(LEFT(shortValue, 16)))
		    m.oKey.oOldVal.ShortValue = ShortValue
		    RETURN m.oKey
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE new
		LPARAMETERS cKeyName, cLocName, uType
		*++
		*>>Add a new registry key. cKeyName and cLocName parameters must be fully formed, including terminating period.
		*--
		  IF DODEFAULT()
		    REPLACE keyName WITH m.cKeyName, locName WITH m.cLocName, ;
		            access  WITH KEY_ACCESS_DEVELOPER, ;
		            repType WITH KEY_REPLICATE_NONE, repKey WITH ''
		
		    * Store key data type, in one of two formats.
		    IF NOT EMPTY(m.uType)
		      IF VARTYPE(m.uType) = 'C'
		        REPLACE type WITH KEY_TYPE_BINARY, shortValue WITH PROPER(m.uType)
		      ELSE
		        REPLACE type WITH m.uType
		      ENDIF
		    ENDIF
		
		    * Remote server tables have a separate Level field. If present, set its value.
		    IF THIS.IsField('KeyLevel')
		      THIS.Replace('KeyLevel', OCCURS('.', m.cKeyName))
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE newkey		&& Create and return a new empty key properties object.
		LPARAMETERS cKeyPath, oKey
		*++
		*>>Create and return a new empty key properties object.
		*--
		  * Need at least 4 characters (plus 2 for the '.'s) to add a new key.
		  IF LEN(TRIM(m.cKeyPath)) > LEN(keyName)
		    THIS.DisplayMessage('%msgKeyTooLong')
		    RETURN .F.
		  ENDIF
		
		  * Create a key object if none was passed to us.
		  IF VARTYPE(m.oKey) != 'O'
		    m.oKey = CREATEOBJECT('cmRegProperties')
		  ENDIF
		
		  SELECT (THIS.cWorkarea)
		  WITH m.oKey
		    .cWorkarea = THIS.cWorkarea
		
		    * A new key has no old value for any properties.
		    SCATTER MEMO NAME .oOldVal BLANK
		
		    * Clear initial property values.
		    .Clear()
		
		    * Localized name & category defaults to the same as key. When key is saved via 
		    * SetKey(), then actual localized category of any pre-existing categories will be used.
		    STORE m.cKeyPath TO .cKeyPath, .cLocPath
		  ENDWITH
		  RETURN .T.
		
	ENDPROC

	PROCEDURE newwithcategories		&& Given a full key name path, add the key record along with any missing category records necessary to complete the full path.
		LPARAMETERS cKeyPath, cLocPath, uType, nAccess
		*++
		*>>Given a full key name path, add the key record along with any missing category records necessary to complete the full path.
		*--
		LOCAL cKey, cKeyName, cLocName, cLocKey, cKeyCategory, cLocCategory, cName, cCatAccess
		
		  ASSERT NOT ',' $ m.cKeyPath AND NOT '"' $ m.cKeyPath MESSAGE 'Invalid character in key name ' + m.cKeyPath
		  m.cKeyPath = CHRTRAN(m.cKeyPath, ',"', '')
		
		  * KeyPath and uType are required. Generate defaults for remaining optional parameters.
		  SELECT (THIS.cWorkarea)
		  IF EMPTY(m.cLocPath)
		    m.cLocPath = m.cKeyPath
		  ENDIF
		  m.cCatAccess = KEY_ACCESS_DEVELOPER
		
		  * Standardize name formats to include terminating periods.
		  IF RIGHT(TRIM(m.cKeyPath), 1) != '.'
		    m.cKeyPath = m.cKeyPath + '.'
		  ENDIF
		  IF RIGHT(TRIM(m.cLocPath), 1) != '.'
		    m.cLocPath = m.cLocPath + '.'
		  ENDIF
		
		  * Strip of key name, leaving only the category heierarchy.
		  m.cKeyCategory = LTRIM(LEFT(m.cKeyPath, RAT('.', m.cKeyPath, 2) - 1))
		  m.cLocCategory = LTRIM(LEFT(m.cLocPath, RAT('.', m.cLocPath, 2) - 1))
		  m.cKeyName = SUBSTR(m.cKeyPath, RAT('.', m.cKeyPath, 2) + 1)
		  m.cLocName = SUBSTR(m.cLocPath, RAT('.', m.cLocPath, 2) + 1)
		
		  * If this is a top level key, there are no categories to test for.
		  IF NOT EMPTY(m.cKeyCategory)
		    STORE '' TO m.cKey, m.cLocKey
		
		    * Load all the existing category records for this path into the local cursor.
		    THIS.SelectKeys(GetToken(m.cKeyCategory, '.') + '.**', KEY_TYPE_CATEGORY)
		    DO WHILE NOT EMPTY(m.cKeyCategory)
		      m.cName = GetToken(@m.cKeyCategory, '.')
		      m.cKey = m.cKey + m.cName + '.'
		
		      * Test for empty here, in case localized path passed to us was incomplete.
		      IF EMPTY(m.cLocCategory)
		        m.cLocKey = m.cLocKey + m.cName + '.'
		      ELSE
		        m.cLocKey = m.cLocKey + GetToken(@m.cLocCategory, '.') + '.'
		      ENDIF
		
		      * Look for the current level category record in the local result cursor.
		      IF THIS.Find('UPPER(keyName)+repkey == "' + PADR(UPPER(m.cKey), LEN(keyName+repKey)) + '"')
		        * Apply spelling and case from existing categories in the key path.
		        m.cKey = TRIM(keyName)
		        m.cLocKey = TRIM(locName)
		
		        * Use access of lowest category found as default for new key
		        m.cCatAccess = Access
		      ELSE
		        * If not found, we need to add it now.
		        THIS.New(m.cKey, m.cLocKey, KEY_TYPE_CATEGORY)
		        REPLACE access WITH IIF(EMPTY(m.nAccess), m.cCatAccess, m.nAccess)
		      ENDIF
		    ENDDO
		
		    * Update category path names from existing records.
		    m.cKeyCategory = m.cKey
		    m.cLocCategory = m.cLocKey
		  ENDIF
		
		  * Now that we are sure all category records exist, we add the key record itself.
		  THIS.New(m.cKeyCategory + m.cKeyName, m.cLocCategory + m.cLocName, m.uType)
		  REPLACE access WITH IIF(EMPTY(m.nAccess), m.cCatAccess, m.nAccess)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE renamekey		&& Rename the specified key to the specified name, propogating changes to all replications and subordinate keys.
		LPARAMETERS cKeypath, cNewKeyPath, cNewLocPath
		*++
		*>>Rename the specified key to the specified name, propogating changes to all replications and subordinate keys.
		*--
		LOCAL cOrder, nKeyDelta, nLocDelta, cCategory, cNewCategory
		
		  * Make sure key name is correctly specified
		  m.cKeyPath = UPPER(TRIM(m.cKeyPath))
		  IF EMPTY(m.cKeyPath) OR NOT RIGHT(m.cKeyPath, 1) = '.'
		    RETURN .F.   && Should never happen, but check just to be sure.
		  ENDIF
		
		  * If category is different, it must be an existing category in the same table. Localized category 
		  * cannot be changed here, since it is always inherited from the parent category record.
		  IF NOT EMPTY(m.cNewKeyPath)
		    m.cCategory = LEFT(m.cKeyPath, RAT('.', m.cKeyPath, 2))
		    m.cNewCategory =  LEFT(m.cNewKeyPath, RAT('.', m.cNewKeyPath, 2))
		    IF NOT UPPER(m.cCategory) == UPPER(m.cNewCategory)  
		      * Need to rebuild localized category name from the new category record.
		      IF NOT EMPTY(m.cNewLocPath)
		        m.cNewLocPath = SUBSTR(m.cNewLocPath, RAT('.', m.cNewLocPath, 2) + 1)
		      ELSE
		        m.cNewLocPath = SUBSTR(m.cNewKeyPath, RAT('.', m.cNewKeyPath, 2) + 1)
		      ENDIF
		
		      * Load the new category record, if there is one. Fail if not found.
		      IF NOT EMPTY(m.cNewCategory)
		        IF NOT THIS.SelectKeys(m.cNewCategory) OR type != KEY_TYPE_CATEGORY
		          RETURN THIS.oMessage.Warning('New Category ("\c") was not found.', m.cNewCategory)
		        ENDIF
		
		        * Pick up the case and spelling of category names from the existing record.
		        m.cNewKeyPath = TRIM(keyName) + SUBSTR(m.cNewKeyPath, RAT('.', m.cNewKeyPath, 2) + 1)
		        m.cNewLocPath = TRIM(locName) + m.cNewLocPath
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Load the affected keys into local cursor.
		  SELECT (THIS.cWorkarea)
		  IF THIS.SelectKeys(m.cKeyPath + '**')
		    m.nKeyDelta = LEN(TRIM(m.cNewKeyPath)) - LEN(TRIM(keyName))
		    m.nLocDelta = LEN(TRIM(m.cNewLocPath)) - LEN(TRIM(locName))
		
		    IF m.nKeyDelta > 0 OR m.nLocDelta > 0
		      IF LEN(TRIM(keyName)) + m.nKeyDelta > LEN(keyName)
		        RETURN THIS.oMessage.Warning('New Key Path is too long.')
		      ENDIF
		      IF LEN(TRIM(locName)) + m.nLocDelta > LEN(locName)
		        RETURN THIS.oMessage.Warning('New Localized Key Path is too long.')
		      ENDIF
		
		      * For a category rename, we also need to check length of all subordinate keys.
		      IF type = KEY_TYPE_CATEGORY
		        SCAN FOR UPPER(LEFT(keyName, LEN(m.cKeyPath))) == m.cKeyPath
		          IF LEN(TRIM(keyName)) + m.nKeyDelta > LEN(keyName)
		            RETURN THIS.oMessage.Warning('New Category name is too long for current subordinate keys.')
		          ENDIF
		          IF LEN(TRIM(locName)) + m.nLocDelta > LEN(locName)
		            RETURN THIS.oMessage.Warning('New Localized category name is too long for current subordinate keys.')
		          ENDIF
		        ENDSCAN
		      ENDIF
		    ENDIF
		
		    m.cOrder = ORDER()
		    SET ORDER TO 0
		
		    * Update localized names in all replications and subordinate records.
		    IF NOT EMPTY(m.cNewLocPath)
		      * Use STUFF() here, as it is a little more robust in patching category names where originals were of 
		      * different lengths (would only occur if table were manually edited incorrectly).
		      REPLACE locName WITH STUFF(locName, 1, AT('.', locname, OCCURS('.', m.cKeyPath)), m.cNewLocPath) ;
		              FOR UPPER(LEFT(keyName, LEN(m.cKeyPath))) == m.cKeyPath IN (THIS.cWorkarea)
		    ENDIF
		
		    * Then rename actual key name in all replications and subordinate records.
		    IF NOT EMPTY(m.cNewKeyPath)
		      REPLACE keyName WITH m.cNewKeyPath + SUBSTR(keyName, LEN(m.cKeyPath) + 1) ;
		              FOR UPPER(LEFT(keyName, LEN(m.cKeyPath))) == m.cKeyPath NOOPTIMIZE IN (THIS.cWorkarea)
		
		      * Remote server tables have a separate Level field. If present, update its value.
		      IF THIS.IsField('KeyLevel')
		        REPLACE KeyLevel WITH OCCURS('.', keyName) ;
		              FOR UPPER(LEFT(keyName, LEN(m.cKeyPath))) == m.cKeyPath NOOPTIMIZE IN (THIS.cWorkarea)
		      ENDIF
		    ENDIF
		
		    IF NOT EMPTY(m.cOrder)
		      SET ORDER TO TAG &cOrder
		    ENDIF
		
		    * Commit changes and return.
		    IF THIS.Update()
		      RETURN .T.
		    ENDIF
		    THIS.Revert()  && Something went wrong. Discard changes and fail.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE selectkeys		&& Load the matching key records into the local cursor.
		LPARAMETERS cKeyName, uType, cUser
		*++
		*>>Load the matching key records into the local cursor. 
		*
		* Parameters:
		*   cKeyName - Name of the key to load. 
		*                    End with '*' for wildcard match.
		*                    End with '**' to include all subordinate levels in wildcard.
		*   uType -    Type filter for wildcard keyNames. Empty (default), Numeric or char type code.
		*   cUser -    Empty (pull all user replications), 'Global' or 'User' (pull base & current user rep).
		*
		* For replicated key values, the global record is always retrieved. The matching replicated 
		* value record is also retrieved if one exists. The record pointer is left on the first 
		* matching global record.
		*--
		LOCAL lWildcard, lAllSubordinates, cUserFilter, cTypeFilter
		
		  * Process the key name string to ensure it is in standardized format, with trailing period.
		  m.cKeyName = UPPER(ALLTRIM(m.cKeyName))
		  IF RIGHT(m.cKeyName, 1) = '*'
		    m.lWildcard = .T.
		    m.lAllSubordinates = RIGHT(m.cKeyName, 2) = '**'
		    m.cKeyName = STRTRAN(m.cKeyName, '*', '')
		  ENDIF
		  IF NOT EMPTY(m.cKeyName) AND RIGHT(m.cKeyName, 1) != '.'
		    m.cKeyName = m.cKeyName + '.'
		  ENDIF
		
		  * Build the appropriate where/filter expression
		  SELECT (THIS.cWorkarea)
		  m.cTypeFilter = ''
		  m.cUserFilter = ''
		
		  IF NOT EMPTY(m.cUser)
		    * Caching keys can cause obsolete data to be used, so disable it for now.
		*      * If looking for a specific User or Global key, we can sometimes optimize out 
		*      * unnecessary requeries by seeing if the record is already loaded in local cursor.
		*      IF NOT m.lWildcard
		*        LOCATE FOR UPPER(keyName) + repkey = PADR(m.cKeyName, LEN(keyname) + LEN(repKey))
		*        IF NOT EOF()
		*          RETURN .T.
		*        ENDIF
		*      ENDIF
		
		    * If "Global" or "User" is specified, we always pull base and current replicated record.
		    * Note that we only need to pull user record down explicitly if using a remote query.
		    m.cUserFilter = "repKey = '" + SPACE(LEN(repKey)) + "'"
		    IF NOT ISNULL(THIS.oSecurity) AND THIS.cmDataAccess.lSelectByRequery
		      m.cUserFilter = "(" + m.cUserFilter + " OR repKey = '" + PADR(THIS.oSecurity.cReplicationID, LEN(repKey)) + "')"
		    ENDIF
		  ENDIF
		
		  * Type filter parameter only applies for wildcard (multi-key) selects.
		  IF m.lWildcard AND NOT EMPTY(m.uType)
		    IF VARTYPE(m.uType) = 'N'
		      m.cTypeFilter = 'type = ' + STR(m.uType)
		    ELSE
		      m.cTypeFilter = '(type = ' + STR(KEY_TYPE_BINARY) + " AND RTRIM(shortvalue) = '" + PROPER(m.uType) + "')"
		    ENDIF
		  ENDIF
		
		  IF THIS.cmDataAccess.lSelectByRequery
		    m.cKeyName = LEFT(m.cKeyName + IIF(m.lWildcard, '%', ' '), LEN(keyName))
		    THIS.cWhere = 'KeyName LIKE ?pcKeyname'
		
		    * If this is a category (wildcard search), return only immediate records under 
		    * the category, including the category record itself.
		    IF m.lWildCard AND NOT m.lAllSubordinates
		      THIS.cWhere = THIS.cWhere + ' AND KeyLevel <= ' + LTRIM(STR(OCCURS('.', m.cKeyname) + 1))
		    ENDIF
		
		    * Add type and replication filters to the WHERE clause
		    IF NOT EMPTY(m.cTypeFilter)
		      THIS.cWhere = THIS.cWhere + ' AND ' + m.cTypeFilter
		    ENDIF
		    IF NOT EMPTY(m.cUserFilter)
		      THIS.cWhere = THIS.cWhere + ' AND ' + m.cUserFilter
		    ENDIF
		    THIS.Requery(m.cKeyName)
		
		    * Cursor is left at EOF if no matching records found
		    RETURN NOT THIS.IsEmpty()
		  ELSE
		    * This depends on SET EXACT OFF for wildcard matches to work correctly.
		    m.cKeyName = LEFT(m.cKeyName + IIF(m.lWildcard, '', ' '), LEN(keyName))
		    RETURN THIS.Find([UPPER(KeyName)+repKey = "] + m.cKeyname + [" AND EMPTY(repKey)] + IIF(EMPTY(m.cTypeFilter), '', ' AND ' + m.cTypeFilter))
		  ENDIF
		
	ENDPROC

	PROCEDURE setcategoryaccess		&& Set the access level for all keys under the specified category.
		LPARAMETERS cKeypath, nAccess
		*++
		*>>Set the access level for all keys under the specified category.
		*--
		  * Make sure key name is correctly specified
		  m.cKeyPath = UPPER(TRIM(m.cKeyPath))
		  IF EMPTY(m.cKeyPath) OR NOT RIGHT(m.cKeyPath, 1) = '.'
		    RETURN .F.
		  ENDIF
		
		  * Load the affected keys into local cursor.
		  IF THIS.SelectKeys(m.cKeypath + '**',, 'Global')
		
		    * Update Access level in subordinates if changed in category.
		    REPLACE access WITH m.nAccess ;
		          FOR UPPER(LEFT(keyName, LEN(m.cKeypath))) == m.cKeyPath IN (THIS.cWorkarea)
		
		    * Commit changes and return.
		    IF THIS.Update()
		      RETURN .T.
		    ENDIF
		    THIS.Revert()  && Something went wrong. Discard changes and fail.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setkey		&& Gather all the key properties and store them back in the registry record.
		LPARAMETERS oKey, nFlags
		*++
		*>>Gather all the key properties and store them back in the registry record.
		*
		* nFlags parameter bits:
		*   REGMASK_BROADCAST  - Broadcast a RegistryUpdate() event after the change.
		*   REGMASK_LOG        - Record the change in the event log.
		*--
		LOCAL cNewKeyName, cNewLocName, cProperties, lTypeWasChanged, lAccessWasChanged 
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  WITH m.oKey
		    m.cNewKeyName = .cCategory + IIF(EMPTY(.cCategory), '', '.') + .cName + '.'
		    m.cNewLocName = .cLocCategory + IIF(EMPTY(.cLocCategory), '', '.') + .cLocName + '.'
		
		    * Find or create the key, as appropriate.
		    SELECT (THIS.cWorkarea)
		    IF EMPTY(.oOldVal.KeyName)
		      IF THIS.SelectKeys(.cKeyPath,, 'User')
		        THIS.DisplayMessage('Cannot create duplicate key for \c', .cKeyPath)
		        RETURN .F.
		      ENDIF
		
		      * Create the new record, and fill in the name fields. 
		      THIS.NewWithCategories(m.cNewKeyName, m.cNewLocName, .nType, .nAccess)
		    ELSE
		      * For external key types, validate the key properties via external class associated with the type.
		      IF m.oKey.nType = KEY_TYPE_BINARY
		        * If there is an external editor class for the key, call its ValidateKeyProperties() method.
		        m.cExternalClass = THIS.Parent.GetExternalEditorClass(m.oKey.cExternalType)
		        IF NOT EMPTY(m.cExternalClass)
		          m.oExternalEditor = CREATEOBJECT(m.cExternalClass)
		          IF NOT m.oExternalEditor.ValidateKeyProperties(m.oKey)
		            RETURN .F.
		          ENDIF
		        ENDIF
		      ENDIF
		
		      * Find and load the table/view record for the specified key.
		      IF THIS.cmDataAccess.lSelectByRequery OR EMPTY(.nRecno)
		        IF NOT THIS.SelectKeys(.cKeyPath,, 'User')
		          RETURN .F.  && Existing key must have been deleted by somebody else...
		        ENDIF
		      ELSE
		        * For native VFP tables, we can use RECNO as a fast way to return to the original record.
		        GOTO (.nRecno) IN (THIS.cWorkarea)
		      ENDIF
		    ENDIF
		
		    * Update properties only in the base record (repID = '')
		    REPLACE access  WITH .nAccess, ;
		            type    WITH .nType, ;
		            repType WITH .nReplicationType
		
		    * Replace external type in base record only if this is a Binary type key, since
		    * the external type is stored in the shortValue field used by other type records.
		    IF .nType = KEY_TYPE_BINARY
		      REPLACE shortValue WITH .cExternalType
		    ENDIF
		
		    * Description and Properties are stored only in the master record (replication 0).
		    * We only replace these memo fields if data actually changed, to reduce memo bloat.
		    IF NOT NVL(comment,'') == .cDescription
		      REPLACE comment WITH .cDescription
		    ENDIF
		    m.cProperties = .Gather()
		    IF NOT NVL(properties,'') == m.cProperties
		      REPLACE properties WITH m.cProperties
		    ENDIF
		
		    * Value may be stored in the master record (as a default value), or 
		    * in appropriate replication. Record pointer is left on base record.
		    DO CASE
		      CASE type = KEY_TYPE_LOGICAL
		        THIS.SetReplicatedValue(.lValue)
		      CASE type = KEY_TYPE_NUMERIC
		        THIS.SetReplicatedValue(.nValue)
		      CASE type = KEY_TYPE_COUNTER
		        IF THIS.IsField('date')
		          * A counter with a reset period cannot have an empty/null last-reset date
		          IF .nCounterReset != COUNTER_RESET_WRAP AND EMPTY(.dValue)
		            .dValue = DATE()
		          ENDIF
		          REPLACE date WITH IIF(EMPTY(.dValue), .NULL., .dValue)
		          REPLACE shortValue WITH STR(.nValue, 16)
		        ELSE
		          REPLACE shortValue WITH STR(.nValue, 16) + DTOS(.dValue)
		        ENDIF
		      OTHERWISE
		        THIS.SetReplicatedValue(.cValue)
		    ENDCASE
		
		    * Commit key changes to source table. Need to commit now, since the next
		    * operations may require a requery for remote source tables.
		    IF NOT THIS.Update()
		      THIS.Revert()
		      RETURN .F.
		    ENDIF
		
		    * For native VFP tables, we maintain current record pointer for fast return to this record later.
		    .nRecno = IIF(THIS.cmDataAccess.lSelectByRequery, 0, THIS.Recno())
		
		    * Need to test these now, before updating stored oldVal values.
		    m.lTypeWasChanged = (.nReplicationType != .oOldVal.repType AND .oOldVal.repType != 0)
		    m.lAccessWasChanged = (.oOldVal.access != .nAccess)
		
		    * Once changes are saved, current values become the OldVal. Reload data into oOldVal obejct.
		    SCATTER MEMO NAME .oOldVal
		
		    * For modified keys, changing certain fields may require additional followup actions.
		    IF NOT EMPTY(.cKeyPath)
		      * If replication type was changed, delete any previous replicated records.
		      IF m.lTypeWasChanged
		        THIS.DeleteValueReplications(.cKeyPath)
		      ENDIF
		
		      * For a Category record, apply changes of access to all subordinate key records.
		      IF .nType = KEY_TYPE_CATEGORY AND m.lAccessWasChanged
		        THIS.SetCategoryAccess(.cKeyPath, .nAccess)
		      ENDIF
		
		      * If name or localized name have changed, we rename the key, rather than simply 
		      * updating the name field, so changes propogate to replications and/or subordinate keys.
		      IF NOT TRIM(.cKeyPath) == m.cNewKeyName OR NOT TRIM(.cLocPath) == m.cNewLocName
		        THIS.RenameKey(.cKeyPath, m.cNewKeyName, m.cNewLocName)
		      ENDIF
		    ENDIF
		
		    * Write an event log message describing the key change, if requested.
		    IF NOT EMPTY(BITAND(m.nFlags, REGMASK_LOG)) AND NOT ISNULL(THIS.oSecurity)
		      THIS.oSecurity.RecordEvent(IIF(EMPTY(.cKeyPath), EVENT_REG_CREATE, EVENT_REG_EDIT), ;
		                                 EVENT_TYPE_REGISTRY, ;
		                                 LEFT(m.cNewLocName, LEN(m.cNewLocName) - 1))
		    ENDIF
		
		  ENDWITH
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setreplicatedvalue		&& Replicate record if needed, and Store specified value.
		LPARAMETERS uValue
		*++
		*>>Replicate record if needed, and Store specified value.
		*--
		LOCAL nRecno, nType
		
		  * Type is only stored in base record, so get it before moving to replicated value record.
		  m.nType = type
		
		  * Find (or create) correct replication, store value, and return to base record.
		  m.nRecno = THIS._FindReplicatedRecord(.T.)
		  THIS.SetValue(m.uValue, m.nType)
		  GOTO (m.nRecno)    && Always leave record pointer on the original base record.
		
	ENDPROC

	PROCEDURE setvalue		&& Store specified value in appropriate format to current registry record.
		LPARAMETERS uValue, nType
		*++
		*>>Store specified value in appropriate format to current registry record.
		*--
		  * If no type specified, use the type from the current record. Type must
		  * be passed to us for replicated value records.
		  SELECT (THIS.cWorkarea)
		  IF EMPTY(m.nType)
		    m.nType = type
		  ENDIF
		
		  DO CASE
		    CASE INLIST(m.nType, KEY_TYPE_MEMO, KEY_TYPE_BINARY, KEY_TYPE_PATH)
		      REPLACE Value WITH IIF(EMPTY(m.uValue), '', m.uValue)
		
		    CASE m.nType = KEY_TYPE_NUMERIC
		      REPLACE shortValue WITH STR(m.uValue, 18, 5)
		
		    CASE m.nType = KEY_TYPE_LOGICAL
		      IF ISNULL(m.uValue)
		        REPLACE shortValue WITH .NULL.
		      ELSE
		        REPLACE shortValue WITH IIF(m.uValue, 'True', '')
		      ENDIF
		
		    CASE m.nType = KEY_TYPE_CATEGORY 
		      IF VARTYPE(m.uValue) = 'C'     && Ignore any value other than a character key type name.
		        REPLACE shortValue WITH m.uValue
		      ENDIF
		
		    OTHERWISE
		      REPLACE shortValue WITH m.uValue
		  ENDCASE
		
	ENDPROC

	PROCEDURE stringtodate		&& Convert a universal date string to VFP internal date format.
		LPARAMETERS cDate
		*++
		*>>Convert a universal date string to VFP internal date format.
		* Implemented localy so Import() can use it when String object is not available
		*++
		LOCAL dDate
		  IF VARTYPE(m.cDate) = 'C' AND LEN(m.cDate) >= 8 AND NOT EMPTY(m.cDate)
		    m.dDate = DATE(VAL(LEFT(m.cDate,4)), VAL(SUBSTR(m.cDate,5,2)), VAL(SUBSTR(m.cDate,7,2)))
		  ELSE
		    m.dDate = {}
		  ENDIF
		  RETURN m.dDate
		
	ENDPROC

	PROCEDURE _findreplicatedrecord		&& Search the local recordset for the current user's replicated value for the current base record.
		LPARAMETERS lCreate
		*++
		*>>Search the local recordset for the current user's replicated value for the current base record.
		*--
		LOCAL cReplicationID, cKeyName, nRecno
		
		  SELECT (THIS.cWorkarea)
		  m.nRecno = RECNO()
		  m.cKeyName = keyName
		
		  * This depends on the base record being current on entry.
		  IF NOT EMPTY(repType) AND NOT ISNULL(THIS.oSecurity)
		    * Pad with spaces to exact length.
		    m.cReplicationID = PADR(THIS.oSecurity.cReplicationID, LEN(repKey))
		    IF NOT EMPTY(m.cReplicationID)
		      LOCATE FOR keyname = m.cKeyName AND TRIM(repKey) == m.cReplicationID AND NOT DELETED()
		      IF EOF()
		        GOTO (m.nRecno)   && No replicated record found. Return to the base record.
		        IF m.lCreate
		          THIS.New(keyName, locName)
		          REPLACE repKey WITH m.cReplicationID
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN m.nRecno   && Return recno of base record, for easy restore of record pointer.
		
	ENDPROC

	PROCEDURE _settypefromdbc
		*++
		*>>Set the type for a cursor based on the DBC definition of the cursor.
		*--
		  IF DODEFAULT()
		    IF THIS.cType = 'Rview'
		      * If it is a remote view, use SQL passthrough for the cursor
		      THIS.cType = 'SQLPT'
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmregistry AS cmdataenvironment OF "cmdata.vcx" 		&& CodeMine Application Registry Manager global service object.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: cancelupdatemessages		&& Remove an object from the list of objects that receive registry update events.
		*m: countervalidated		&& Maintain a list of counter keys that have been confirmed as in-sync with the primary key of tha table they are used for.
		*m: createcounter		&& Create a new counter key with the specified properties.
		*m: csharedprefixmap_access		&& Return current or default value for cSharedPrefixMap property.
		*m: csharedprefixmap_assign		&& Make sure cSharedPrefixMap property is either blank, or has the full table/view name with DBC prefix.
		*m: csharedregname_assign		&& Make sure cSharedRegName property value is a valid DBC table/view object name.
		*m: deleteglobalkey		&& Deletes specified registry key, and all replications of it. If the key is a category, then delete it and all subordinate keys.
		*m: deletekey		&& Delete current replication of specified key. If the key is a category, then delete it and all subordinate keys.
		*m: deleteuserkey		&& Delete current user replication of specified registry key.
		*m: deleteuserreplications		&& Internal method to Delete all user key replications with the specified user ID.
		*m: enumkeys		&& Enumerate all keys in the specified category, returning deatials for each individual key in succession. Returns a positive number if there are more keys to process, or -1 if there are no more matching keys.
		*m: enumkeystoarray		&& Fill the passed arrays with names of all keys contained in the specified category.
		*m: enumkeystostring		&& Fill the passed strings with comma separated list of names of all keys contained in the specified category. Return the total number of matching keys found.
		*m: get		&& Return information about the registry tables.
		*m: getcounter		&& Increment the current counter value and return it to caller for evaluation.
		*m: getdate		&& Return the current system date. If the shared registry is on a remote data server, the date from the server is returned. Otherwise, the local system date is returned.
		*m: getdatetime		&& Return the current system date and time. If the shared registry is on a remote data server, the time from the server is returned. Otherwise, the local system time is returned.
		*m: getexternaleditorclass		&& Return the external editor class name, if any, associated with the specified external key type.
		*m: getglobalkeyvalue		&& Return current value for specified global registry key, or the default value for a replicated key.
		*m: getkey		&& Return an object ref in the oKey parameter of a cmRegProperties object for the specified key. Returns .F. if the key was not found.
		*m: getkeyvalue		&& Return current value for specified registry key.
		*m: getkeyvalueex		&& Get extended information about the specified key. Returns .T. if key was found, or .F. otherwise.
		*m: getregistrypath		&& For backward compatability only, return DBC path.
		*m: getrootcursor		&& Internal method to determine which registry cursor the specified key resides in, and strip off any registry indentifier prefix from the key name.
		*m: getuserkeyvalue		&& Return current value for specified user-replicated registry key. Currently this is the same as GetKeyValue()
		*m: import		&& Import the specified registry key(s) from the specified source table.
		*m: incrementcounter		&& Increment and return the value for the specified Counter key. Create a new counter if specified one is not found.
		*m: isreadonly		&& Return .T. if the specified registry root category is Read-only.
		*m: localize		&& Localize registry key names and description, and set default language.
		*m: lockcounter		&& Find or Create the specified counter, and lock the associated record. Returns a reference to the counter key object.
		*m: newkey		&& Fill in the specified Key object with initial blank values for a new key. If no key object is specified, one is created.
		*m: ostatemanager_access		&& Fill in the reference to the message display service object on first reference.
		*m: ostring_access		&& Fill in the reference to the message display service object on first reference.
		*m: packall		&& Pack all registry tables based on native VFP tables. This will fail if other users have the tables open.
		*m: renamekey		&& Rename the specified key to the specified name, propogating changes to all replications and subordinate keys.
		*m: requestupdatemessages		&& Add an object to list of subscribers to registry update events. The cUpdateType parameter can be either "Local" or "Shared"
		*m: sendupdatemessages		&& Send RegistryUpdate messages to all registered objects. Normaly called by the registry editor to notify objects of registry value changes.
		*m: setcounter		&& Sets the value of a locked Counter Key object. Can be used to recover from sync errors.
		*m: setglobalkeyvalue		&& Set the default value of a user-replicated registry key. If the key does not exist,
		*m: setkey		&& Store properties of specified cmKeyProperties object to appropriate table.
		*m: setkeyvalue		&& Set the value of an existing registry key. Fails if the key does not already exist.
		*m: setkeyvalueex		&& Set extended information for a key. Create the key if it does not already exist.
		*m: setuserkeyvalue		&& Set the value of a registry key. If the key does not exist, create one with the specified name and a type derived from the value datatype.
		*m: unlockcounter		&& Unlocks the key record associated with the specified counter.
		*m: updatecounter		&& Writes current Counter Key properties back to the appropriate key table.
		*m: _checkkeytype		&& Internal method to Check that the key type of the current record in current workarea matches the type specified by caller.
		*m: _defaultkeytype		&& Internal method to Determine default key type from datatype of value.
		*m: _getrootalias		&& Return the cursors alias to use, based on the key path root prefix.
		*m: _standardizekeyname		&& Force key path to a consistent format, with trailing period terminator.
		*p: cdbcpath		&& Full path to the Main DBC
		*p: clocalregpath		&& Local registry file path. May be a table name, or full free table path.
		*p: csharedprefixmap		&& Appreg table/view name mapped to the %Shared prefix. Leave blank to default to the cSharedRegName value.
		*p: csharedregname		&& Shared registry table name. Must be a valid DBC table object name.
		*p: cversion
		*p: lonlyoneshared		&& If .T. map all appreg key prefixes (except %Local) to the default shared appreg table (appreg01.dbf). Use for backward compatibility only.
		*p: ostatemanager
		*p: ostring
	*</DefinedPropArrayMethod>

	cconnectionmanagerclass = cmConnectionManager
	cdbcpath = appdata.dbc		&& Full path to the Main DBC
	clocalregpath = appReg02.dbf		&& Local registry file path. May be a table name, or full free table path.
	csharedprefixmap = 		&& Appreg table/view name mapped to the %Shared prefix. Leave blank to default to the cSharedRegName value.
	csharedregname = appReg01		&& Shared registry table name. Must be a valid DBC table object name.
	cversion = 7.0.0
	lonlyoneshared = .F.		&& If .T. map all appreg key prefixes (except %Local) to the default shared appreg table (appreg01.dbf). Use for backward compatibility only.
	lprivatedatasession = .T.
	Name = "cmregistry"
	nerrormode = 8
	ostatemanager = .NULL.
	ostring = .NULL.
	
	PROCEDURE cancelupdatemessages		&& Remove an object from the list of objects that receive registry update events.
		LPARAMETERS oRequestor
		*++
		*>>Remove an object from the list of objects that receive registry update events.
		*--
		  IF NOT ISNULL(m.oRequestor) AND NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.UnSubscribe('Registry Update Local', m.oRequestor)
		    THIS.oStateManager.UnSubscribe('Registry Update Shared', m.oRequestor)
		  ENDIF
		
	ENDPROC

	PROCEDURE countervalidated		&& Maintain a list of counter keys that have been confirmed as in-sync with the primary key of tha table they are used for.
		LPARAMETERS cCounter, lSet
		*++
		*>>Maintain a list of counter keys that have been confirmed as in-sync with the primary key of tha table they are used for. 
		* Call with the lSet parameter set to .T. to mark a counter as validated.
		*
		* If the lSet parameter is ommitted, then the method returns .T. if the counter was 
		* previously validated, or .F. otherwise.
		*--
		  m.cCounter = PROPER(m.cCounter) + '%'  && Add terminator so SET EXACT setting wont affect ASCAN()
		  IF ASCAN(THIS.aValidatedCounters, m.cCounter) > 0
		    RETURN .T.
		  ENDIF
		  IF m.lSet
		    IF NOT EMPTY(THIS.aValidatedCounters[1])
		      DIMENSION THIS.aValidatedCounters[ALEN(THIS.aValidatedCounters) + 1]
		    ENDIF
		    THIS.aValidatedCounters[ALEN(THIS.aValidatedCounters)] = m.cCounter
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE createcounter		&& Create a new counter key with the specified properties.
		LPARAMETERS cKeyName, nLength, nFormat, nReset, nInitialValue
		*++
		*>>Create a new counter key with the specified properties.
		*   nLength defaults to 4 bytes.
		*   nFormat defaults to decimal.
		*   nReset defaults to never.
		*   nInitialValue defaults to 1.
		*--
		LOCAL oCursor, oKey, lStatus
		
		  m.oCursor = THIS.GetRootCursor(@m.cKeyname)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.CreateCounter(m.cKeyName, m.nLength, m.nFormat, m.nReset, m.nInitialValue)
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE csharedprefixmap_access		&& Return current or default value for cSharedPrefixMap property.
		*++
		*>>Return current or default value for cSharedPrefixMap property.
		*--
		  IF EMPTY(THIS.cSharedPrefixMap)
		    RETURN THIS.cDBCpath + '!' + THIS.cSharedRegName
		  ENDIF
		  RETURN THIS.cSharedPrefixMap
		
	ENDPROC

	PROCEDURE csharedprefixmap_assign		&& Make sure cSharedPrefixMap property is either blank, or has the full table/view name with DBC prefix.
		LPARAMETERS cValue
		*++
		*>>Make sure cSharedPrefixMap property is either blank, or has the full table/view name with DBC prefix.
		*--
		LOCAL cDBCprefix
		  IF EMPTY(m.cValue)
		    THIS.cSharedPrefixMap = ''
		  ELSE
		    m.cDBCprefix = PROPER(JUSTSTEM(THIS.cDBCpath) + '!')
		    IF NOT LEFT(PROPER(m.cValue), LEN(m.cDBCprefix)) == m.cDBCprefix
		      m.cValue = m.cDBCprefix + m.cValue
		    ENDIF
		    THIS.cSharedPrefixMap = m.cValue
		  ENDIF
		
	ENDPROC

	PROCEDURE csharedregname_assign		&& Make sure cSharedRegName property value is a valid DBC table/view object name.
		LPARAMETERS cValue
		*++
		*>>Make sure cSharedRegName property value is a valid DBC table/view object name.
		*--
		  IF NOT CHRTRAN(m.cValue, '.\:/', '') == m.cValue
		    ASSERT .F. MESSAGE 'cSharedRegName property must be a valid DBC object name'
		    RETURN
		  ENDIF
		  THIS.cSharedRegName = m.cValue
		
	ENDPROC

	PROCEDURE deleteglobalkey		&& Deletes specified registry key, and all replications of it. If the key is a category, then delete it and all subordinate keys.
		LPARAMETERS cKeyName, nFlags
		*++
		*>>Deletes specified registry key, and all replications of it. If the key is a category, then delete it and all subordinate keys.
		*--
		LOCAL oCursor
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKeyName)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.DeleteKey(m.cKeyName, m.nFlags)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE deletekey		&& Delete current replication of specified key. If the key is a category, then delete it and all subordinate keys.
		LPARAMETERS cKeyName, nFlags
		*++
		*>>Delete current replication of specified key. If the key is a category, then delete it and all subordinate keys.
		*--
		LOCAL oCursor
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKeyName)
		
		  * Find the record so we can check the replication type.
		  IF NOT ISNULL(m.oCursor) AND m.oCursor.SelectKeys(m.cKeyName,, 'User')
		    IF type = KEY_TYPE_CATEGORY OR EMPTY(repType)
		      RETURN m.oCursor.DeleteKey(m.cKeyName, m.nFlags)
		    ELSE
		      * For replicated records, delete only the current replication, if any.
		      RETURN m.oCursor.DeleteReplicatedValue()
		    ENDIF
		  ENDIF
		  RETURN .F.  && Key was not found.
		
	ENDPROC

	PROCEDURE deleteuserkey		&& Delete current user replication of specified registry key.
		LPARAMETERS cKeyName
		*++
		*>>Delete current user replication of specified registry key.
		*--
		LOCAL oCursor
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKeyName)
		
		  * Find the record so we can check the replication type.
		  IF NOT ISNULL(m.oCursor) AND m.oCursor.SelectKeys(m.cKeyName,, 'User')
		    IF NOT EMPTY(repType)
		      RETURN m.oCursor.DeleteReplicatedValue()
		    ENDIF
		  ENDIF
		  RETURN .F.  && Key was not found, or not a replicated key.
		
	ENDPROC

	PROCEDURE deleteuserreplications		&& Internal method to Delete all user key replications with the specified user ID.
		LPARAMETERS cReplicationKey
		*++
		*>>Internal method to Delete all user key replications with the specified user ID.
		* Typicaly called when a user is deleted.
		*
		* Records must be deleted from both local and shared registry tables.
		*--
		LOCAL ix, oCursor
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor) > 0
		    m.oCursor.DeleteUserReplications(m.cReplicationKey)
		  ENDDO
		  RETURN .T.
		
	ENDPROC

	PROCEDURE enumkeys		&& Enumerate all keys in the specified category, returning deatials for each individual key in succession. Returns a positive number if there are more keys to process, or -1 if there are no more matching keys.
		LPARAMETERS cCategory, uType, nIndex, cKeyName, cLocName, uValue, cDescription, nAccess
		*++
		*>>Enumerate all keys in the specified category, returning deatials for each individual key in succession. Returns a positive number if there are more keys to process, or -1 if there are no more matching keys.
		* If optional uTypeMatch parameter is specified, only keys matching that type are returned.
		* To return the first matching key, set nIndex to 0. On return nIndex will
		* be set to a value > 0 if there are more keys, or -1 if no more.
		*
		* Input parameters are: cCategory, nIndex
		* Input/Output parameters are: uType - Input when Index=0, and output for type of each record returned.
		* Output parameters are: cKeyName, cLocName, uValue, cDescription, nAccess, and uType.
		*--
		LOCAL oCursor, nCount, nLevel, lAllSubordinates
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cCategory)
		
		  IF NOT ISNULL(m.oCursor)
		    IF EMPTY(m.nIndex) OR m.nIndex < 0
		      * If no wildcard explicitly specified, default to all immediate subkeys
		      IF NOT '*' $ m.cCategory
		        m.cCategory = m.cCategory + '*'
		      ENDIF
		      m.oCursor.SelectKeys(m.cCategory, m.uType, 'User')
		      THIS.AddProperty('uEnumTypeMatch', m.uType)
		    ELSE
		      IF RECNO() != m.nIndex
		        GOTO (m.nIndex)
		      ENDIF
		      SKIP 1
		    ENDIF
		
		    * Decide how deep caller wants to accept, and strip wildcard characters off category name for matching.
		    m.nLevel = OCCURS('.', m.cCategory)
		    m.lAllSubordinates = '**' $ m.cCategory
		    m.cCategory = UPPER(STRTRAN(m.cCategory, '*', ''))
		
		    m.nIndex = -1
		    DO WHILE NOT EOF() AND UPPER(LEFT(keyName, LEN(m.cCategory))) == m.cCategory
		      * Exclude replications, subkeys below the current level, and keys that don't match specified type.
		      IF DELETED() OR NOT EMPTY(repKey) ;
		      OR IIF(m.lAllSubordinates, OCCURS('.', keyName) <= m.nLevel, OCCURS('.', keyName) != m.nLevel + 1) ;
		      OR NOT THIS._CheckKeyType(THIS.uEnumTypeMatch)
		        SKIP 1
		        LOOP
		      ENDIF
		
		      * Found the next matching key, return its info.
		      m.nIndex = RECNO()
		      m.cKeyName = TRIM(SUBSTR(keyName, IIF(m.nLevel = 0, 0, AT('.', keyName, m.nLevel)) + 1))
		      m.cKeyName = LEFT(m.cKeyName, LEN(m.cKeyName) - 1)
		      m.uType = type
		      IF PCOUNT() >= 5
		        m.cLocName = TRIM(SUBSTR(locName, IIF(m.nLevel = 0, 0, AT('.', locName, m.nLevel)) + 1))
		        m.cLocName = LEFT(m.cLocName, LEN(m.cLocName) - 1)
		        IF PCOUNT() >= 6
		          m.uValue = m.oCursor.GetValue()
		          IF PCOUNT() >= 7
		            m.cDescription = NVL(comment, '')
		            m.nAccess = access
		          ENDIF
		        ENDIF
		      ENDIF
		      EXIT
		    ENDDO
		  ELSE
		    m.nIndex = -1   && Error opening specified registry table.
		  ENDIF
		  RETURN m.nIndex
		
	ENDPROC

	PROCEDURE enumkeystoarray		&& Fill the passed arrays with names of all keys contained in the specified category.
		LPARAMETERS cCategory, uTypeMatch, aKeyName, aLocName, nAccessFilter
		*++
		*>>Fill the passed arrays with names of all keys contained in the specified category.
		* Return the total number of matching keys found.
		*--
		LOCAL nCount, nIndex, cKeyName, cLocName, lKeyType, lLocType 
		
		  * Default to considering all keys if access level is not specified.
		  IF EMPTY(m.nAccessFilter)
		    m.nAccessFilter = KEY_ACCESS_DEVELOPER
		  ENDIF
		
		  * If a 2-dimensional array is passed, we return name and type. Otherwise, just name.
		  THIS.SetErrorMode(ERRMASK_SILENT_ALL)
		  m.lKeyType = ALEN(aKeyName, 2) > 1
		  m.lLocType = ALEN(aLocName, 2) > 1
		  THIS.SetErrorMode()
		
		  STORE 0 TO m.nIndex, m.nCount
		  DIMENSION aKeyName[1], aLocName[1]
		  STORE '' TO aKeyName, aLocName
		  DO WHILE THIS.EnumKeys(m.cCategory, m.uTypeMatch, @m.nIndex, @m.cKeyName, @m.cLocName) > 0
		    IF access >= m.nAccessFilter  && Only include matches of the desired access level or below.
		      * Found the next matching key, return its info.
		      m.nCount = m.nCount + 1
		      DIMENSION aKeyName[m.nCount, IIF(m.lKeyType, 2, 1)]
		      aKeyName[m.nCount, 1] = m.cKeyName
		      IF m.lKeyType
		        aKeyName[m.nCount, 2] = type
		      ENDIF
		      IF PCOUNT() > 3
		        DIMENSION aLocName[m.nCount, IIF(m.lLocType, 2, 1)]
		        aLocName[m.nCount, 1] = m.cLocName
		        IF m.lLocType
		          aLocName[m.nCount, 2] = type
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDDO
		  RETURN m.nCount
		
	ENDPROC

	PROCEDURE enumkeystostring		&& Fill the passed strings with comma separated list of names of all keys contained in the specified category. Return the total number of matching keys found.
		LPARAMETERS cCategory, uTypeMatch, cKeyNameList, cLocNameList, nAccessFilter
		*++
		*>>Fill the passed strings with comma separated list of names of all keys contained in the specified category. Return the total number of matching keys found.
		*--
		LOCAL nCount, nIndex, cKeyName, cLocName
		
		  * Default to considering all keys if access level is not specified.
		  IF EMPTY(m.nAccessFilter)
		    m.nAccessFilter = KEY_ACCESS_DEVELOPER
		  ENDIF
		
		  STORE 0 TO m.nIndex, m.nCount
		  STORE '' TO m.cKeyNameList, m.cLocNameList
		  DO WHILE THIS.EnumKeys(m.cCategory, m.uTypeMatch, @m.nIndex, @m.cKeyName, @m.cLocName) > 0
		    IF access >= m.nAccessFilter  && Only include matches of the desired access level or below.
		      * Found the next matching key, return its info.
		      m.nCount = m.nCount + 1
		      m.cKeyNameList = m.cKeyNameList + IIF(m.nCount > 1, ',', '') + m.cKeyName
		      IF PCOUNT() > 3
		        m.cLocNameList = m.cLocNameList + IIF(m.nCount > 1, ',', '') + m.cLocName
		      ENDIF
		    ENDIF
		  ENDDO
		  RETURN m.nCount
		
	ENDPROC

	PROCEDURE get		&& Return information about the registry tables.
		LPARAMETERS cWhich
		*++
		*>>Return information about the registry tables.
		*
		* Parameter cWhich:
		*        'DBCPATH'          - return full main DBC path
		*     'DBCNAME'          - return main DBC name
		*        'SHARED'           - return shared registry DBF path
		*        'LOCAL'            - return local registry DBF path
		*        <appregPathPrefix> - return path to that table
		*--
		LOCAL oCursor
		  DO CASE
		    CASE UPPER(LEFT(m.cWhich,4)) = 'DBCP'
		      RETURN THIS.cDBCpath
		    CASE UPPER(LEFT(m.cWhich,4)) = 'DBCN'
		      RETURN THIS.cDBCname
		    OTHERWISE
		      IF LEFT(m.cWhich, 1) != '%'
		        m.cWhich = '%' + m.cWhich
		      ENDIF
		      m.oCursor = THIS.GetRootCursor(m.cWhich)
		      IF NOT ISNULL(m.oCursor)
		        IF CURSORGETPROP("SourceType", m.oCursor.cWorkarea) = 3
		          RETURN DBF(m.oCursor.cWorkarea)
		        ELSE
		          RETURN m.oCursor.cWorkarea
		        ENDIF
		      ENDIF
		  ENDCASE
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE getcounter		&& Increment the current counter value and return it to caller for evaluation.
		LPARAMETERS oKey
		*++
		*>>Increment the current counter value and return it to caller for evaluation.
		*--
		LOCAL nValue, nDigit, cResult
		
		  * Reset counter value on appropriate period change.
		  WITH m.oKey
		    DO CASE
		      CASE .nCounterReset = COUNTER_RESET_DAY
		        IF .dValue <  DATE()
		          .nValue = 0
		          .dValue = DATE()
		        ENDIF
		
		      CASE .nCounterReset = COUNTER_RESET_WEEK
		        IF DATE() - .dValue >= 7 OR WEEK(.dValue) != WEEK(DATE())
		          .nValue = 0
		          .dValue = DATE()
		        ENDIF
		
		      CASE .nCounterReset = COUNTER_RESET_MONTH
		        IF YEAR(.dValue) < YEAR(DATE()) OR MONTH(.dValue) < MONTH(DATE())
		          .nValue = 0
		          .dValue = DATE()
		        ENDIF
		
		      CASE .nCounterReset = COUNTER_RESET_YEAR
		        IF YEAR(.dValue) < YEAR(DATE())
		          .nValue = 0
		          .dValue = DATE()
		        ENDIF
		    ENDCASE
		
		    * Increment the value, wrapping when result byte size is exceeded.
		    * First value returned is 1, a zero is never returned.
		    IF .nValue < (MAX(10, .nCounterFormat) ^ .nCounterLength) - 1
		      .nValue = .nValue + .nCounterIncr
		    ELSE
		      .nValue = 1
		    ENDIF
		    
		    * Convert value to appropriate string format for caller
		    IF .nCounterFormat = COUNTER_TYPE_INT
		      RETURN INT(.nValue)
		    ENDIF
		    RETURN THIS.oString.NumToString(.nValue, .nCounterLength, .nCounterFormat)
		  ENDWITH
		
	ENDPROC

	PROCEDURE getdate		&& Return the current system date. If the shared registry is on a remote data server, the date from the server is returned. Otherwise, the local system date is returned.
		*++
		*>>Return the current system date. If the shared registry is on a remote data server, the date from the server is returned. Otherwise, the local system date is returned.
		*--
		  RETURN TTOD(THIS.GetDateTime())
		
	ENDPROC

	PROCEDURE getdatetime		&& Return the current system date and time. If the shared registry is on a remote data server, the time from the server is returned. Otherwise, the local system time is returned.
		*++
		*>>Return the current system date and time. If the shared registry is on a remote data server, the time from the server is returned. Otherwise, the local system time is returned.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetRootCursor('%Shared')
		  IF NOT ISNULL(m.oCursor) AND NOT EMPTY(m.oCursor.nConnID)
		    RETURN m.oCursor.oConnMan.Execute(m.oCursor.nConnID, 'SELECT GETDATE()')
		  ELSE
		    RETURN DATETIME()
		  ENDIF
		
	ENDPROC

	PROCEDURE getexternaleditorclass		&& Return the external editor class name, if any, associated with the specified external key type.
		LPARAMETERS cExternalType
		*++
		*>>Return the external editor class name, if any, associated with the specified external key type.
		* The class name is stored as a registry key value in the category "External Key Types".
		*--
		LOCAL cExternalEditorClass
		  m.cExternalEditorClass = ''
		  IF NOT EMPTY(m.cExternalType)
		    m.cExternalEditorClass = THIS.GetKeyValue('%Local.External Key Types.' + TRIM(m.cExternalType),, '')
		    IF VARTYPE(m.cExternalEditorClass) != 'C'
		      m.cExternalEditorClass = ''
		      ERROR 'Invalid External Key editor class name for ' + m.cExternalType
		    ENDIF
		  ENDIF
		  RETURN m.cExternalEditorClass
		
	ENDPROC

	PROCEDURE getglobalkeyvalue		&& Return current value for specified global registry key, or the default value for a replicated key.
		LPARAMETERS cKey, uTypeMatch, uDefault
		*++
		*>>Return current value for specified global registry key, or the default value for a replicated key.
		*--
		LOCAL oCursor
		
		  * Return null on errors if no default value.
		  IF PCOUNT() < 3
		    m.uDefault = .NULL.
		  ENDIF
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKey)
		  IF NOT ISNULL(m.oCursor)
		    IF m.oCursor.SelectKeys(m.cKey,, 'Global') 
		      IF THIS._CheckKeyType(m.uTypeMatch, PROGRAM())
		        m.uDefault = m.oCursor.GetValue()
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN m.uDefault
		
	ENDPROC

	PROCEDURE getkey		&& Return an object ref in the oKey parameter of a cmRegProperties object for the specified key. Returns .F. if the key was not found.
		LPARAMETERS cKeyPath, oKey
		*++
		*>>Return an object ref in the oKey parameter of a cmRegProperties object for the specified key. Returns .F. if the key was not found.
		*--
		LOCAL oCursor
		
		  * Determine which registry cursor this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKeyPath)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.GetKey(m.cKeyPath, @m.oKey)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getkeyvalue		&& Return current value for specified registry key.
		LPARAMETERS cKey, uTypeMatch, uDefault
		*++
		*>>Return current value for specified registry key.
		*--
		LOCAL oCursor
		
		  * Return null on errors if no default value.
		  IF PCOUNT() < 3
		    m.uDefault = .NULL.
		  ENDIF
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKey)
		  IF NOT ISNULL(m.oCursor)
		    IF m.oCursor.SelectKeys(m.cKey,, 'User')
		      IF THIS._CheckKeyType(m.uTypeMatch, PROGRAM())
		        m.uDefault = m.oCursor.GetReplicatedValue()
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN m.uDefault
		
	ENDPROC

	PROCEDURE getkeyvalueex		&& Get extended information about the specified key. Returns .T. if key was found, or .F. otherwise.
		LPARAMETERS cKey, cLocName, uType, uValue, cDescription, nAccess, cProperties
		*++
		*>>Get extended information about the specified key. Returns .T. if key was found, or .F. otherwise.
		*--
		LOCAL oCursor
		
		  * Determine which registry cursor this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKey)
		  IF NOT ISNULL(m.oCursor)
		    IF m.oCursor.SelectKeys(m.cKey,, 'User')
		      * Get the value (possibly replicated by user) and leave cursor pointing on base record.
		      m.uValue = m.oCursor.GetReplicatedValue()
		
		      * Use direct cursor access to read remaining fields, for fastest operation.
		      m.cLocName = LEFT(locName, LEN(TRIM(locName)) - 1)   && Remove trailing dot
		      m.cDescription = NVL(comment, '')
		      m.nAccess = access
		      m.cProperties = properties
		      m.uType = IIF(type = KEY_TYPE_BINARY AND NOT EMPTY(shortValue), ;
		                    TRIM(shortValue), type)
		      RETURN .T.
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getregistrypath		&& For backward compatability only, return DBC path.
		*++
		*>>For backward compatability only, return DBC path.
		*--
		  RETURN THIS.Get('DBCpath')
		
	ENDPROC

	PROCEDURE getrootcursor		&& Internal method to determine which registry cursor the specified key resides in, and strip off any registry indentifier prefix from the key name.
		LPARAMETERS cKeyName, lCreate
		*++
		*>>Internal method to determine which registry cursor the specified key resides in, and strip off any registry indentifier prefix from the key name.
		*
		* Key root naming convention:
		*        %Local.key           - use THIS.cLocalRegPath as a free table
		*        %Shared.key          - use THIS.cSharedRegName in main DBC
		*        %database!table.key  - table or view Alias of source in the specified DBC
		*        %%Alias.key          - table or view Alias of an open registry table.
		*
		* Returns cursor object reference to the correct registry table to use, NULL on error.
		*--
		LOCAL oCursor, cSource, cDBC, nWild
		
		  * Force key path to a consistent format, with trailing period terminator.
		  m.cKeyName = THIS._StandardizeKeyName(m.cKeyName)
		
		  * A Leading percent means the first token is the registry root table alias.
		  IF LEFT(m.cKeyName, 1) = '%'
		    m.cSource = GetToken(@m.cKeyName, '.')
		  ELSE
		    m.cSource = '%Shared'
		  ENDIF
		
		  IF LEFT(m.cSource, 2) = '%%'
		    * Double-percent prefix means it is an existing workarea name.
		    m.oCursor = THIS.GetCursor(SUBSTR(m.cSource, 3))
		    IF ISNULL(m.oCursor)
		      RETURN .NULL.
		    ENDIF
		  ELSE
		    * Find cursor, or create one if it doesn't already exist.
		    m.cAlias = THIS._GetRootAlias(@m.cSource, @m.cDBC)
		    m.oCursor = THIS.GetCursor(m.cAlias)
		    IF ISNULL(m.oCursor)
		      IF '!' $ m.cSource
		        m.cDBC = GetToken(@m.cSource, '!')
		      ENDIF
		      m.oCursor = THIS.AddCursor(m.cAlias, 'cmRegCursor')
		      WITH m.oCursor
		        .cDatabase = IIF(VARTYPE(m.cDBC) = 'C', m.cDBC, THIS.cDBCpath)
		        .cSource = m.cSource
		      ENDWITH
		    ENDIF
		  ENDIF
		
		  * Open the cursor, if not already open.
		  IF NOT m.oCursor.IsOpen()
		    WITH m.oCursor
		      * We can auto-create an empty appreg01 table if necessary
		      IF m.lCreate AND NOT EMPTY(.cDatabase) AND PROPER(.cSource) == PROPER(THIS.cSharedRegName)
		        * Database (DBC) files cross datasession boundries, so it should already be open here.
		        IF NOT .OpenDatabase()
		          RETURN .NULL.
		        ENDIF
		        IF NOT ISREADONLY(0) AND NOT INDBC(.cSource, 'TABLE')
		          IF NOT .Create()
		            RETURN .NULL.
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDWITH
		
		    IF NOT m.oCursor.Open()
		      * This must be outside of the WITH/ENDWITH oCursor, since the cursor will be released.
		      THIS.RemoveCursor(m.oCursor.cWorkarea)
		      RETURN .NULL.
		    ENDIF
		  ENDIF
		
		  * Make it the current workarea, and return.
		  SELECT (m.oCursor.cWorkarea)
		  RETURN m.oCursor
		
	ENDPROC

	PROCEDURE getuserkeyvalue		&& Return current value for specified user-replicated registry key. Currently this is the same as GetKeyValue()
		LPARAMETERS cKey, uTypeMatch, uDefault
		*++
		*>>Return current value for specified user-replicated registry key. Currently this is the same as GetKeyValue()
		*--
		  IF PCOUNT() < 3
		    RETURN THIS.GetKeyValue(@cKey, @uTypeMatch)
		  ENDIF
		  RETURN THIS.GetKeyValue(@cKey, @uTypeMatch, @uDefault)
		
	ENDPROC

	PROCEDURE import		&& Import the specified registry key(s) from the specified source table.
		LPARAMETERS cCategory, cFromPath, lOverwrite
		*++
		*>>Import the specified registry key(s) from the specified source table.
		*--
		LOCAL oCursor
		
		  * Get target cursor for the import
		  m.oCursor = THIS.GetRootCursor(@m.cCategory)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Import(m.cCategory, m.cFromPath, m.lOverwrite)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE incrementcounter		&& Increment and return the value for the specified Counter key. Create a new counter if specified one is not found.
		LPARAMETERS cKeyPath, nLength, nFormat, nInitialValue
		*++
		*>>Increment and return the value for the specified Counter key. Create a new counter if specified one is not found.
		*
		* If nLength/nFormat parameters are specified, and the counter does not exist,
		* then a new counter is created automaticaly.
		*--
		LOCAL cValue, oCursor, oKey
		
		  * Determine which registry cursor this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKeyPath, .T.)   && Create appreg01 if necessary
		  IF NOT ISNULL(m.oCursor)
		    IF m.oCursor.GetProp('SourceType') = 2
		      LOCAL cSQL, nConnect
		      PRIVATE pnValue, pnLength, pnFormat
		
		      STORE 0 TO m.pnValue, m.pnLength, m.pnFormat
		      m.nConnect = m.oCursor.GetProp('ConnectHandle')
		      m.cSQL = [Execute sp_cm_IncrementCounter '] + TRIM(m.cKeyPath) + [', ?@pnValue, ?@pnLength, ?@pnFormat]
		      * Counter is in a remote server appreg table. Increment using stored procedure.
		      IF SQLEXEC(m.nConnect, m.cSQL) < 0
		        THIS.SqlError(m.cSQL)   && Probably means SP was not defined in the database
		        RETURN .NULL.
		      ENDIF
		
		      * Older versions of the SP return NULL on failure, newer ones return -1.
		      IF NVL(m.pnValue, -1) < 0      && If counter key was not found, create a new one.
		        m.oCursor.CreateCounter(m.cKeyPath, m.nLength, m.nFormat, 0, m.nInitialValue)
		        IF SQLEXEC(m.nConnect, m.cSQL) < 0
		          THIS.SqlError(m.cSQL)
		          RETURN .NULL.
		        ENDIF
		      ENDIF
		
		      IF NOT NVL(m.pnValue, -1) < 0
		        * Convert value to appropriate string format for caller
		        IF m.pnFormat = COUNTER_TYPE_INT
		          RETURN INT(m.pnValue)
		        ELSE
		          RETURN THIS.oString.NumToString(m.pnValue, m.pnLength, m.pnFormat)
		        ENDIF
		      ENDIF
		    ELSE
		      * Find (or create if necessary) and lock the counter.
		      m.oKey = m.oCursor.LockCounter(m.cKeyPath, m.nLength, m.nFormat, m.nInitialValue)
		      IF NOT ISNULL(m.oKey)
		        * Get the next value, store it back to the key table, and unlock.
		        m.cValue = THIS.GetCounter(m.oKey)
		        *****************************************************************
		        *** Modifications for SherWare Batch Number
		        *** Prend the 2 right most characters of year to batch
		        *****************************************************************
		        IF 'BATCH' $ UPPER(m.cKeyPath)
		           lnDays = date() - ctod('01/01/'+transform(year(date()))) + 1
		           lcdays = padl(transform(lnDays),3,'0')
		           lcyear = RIGHT(TRANSFORM(YEAR(DATE())),2)
		           m.cValue = lcYear+lcDays + right(m.cvalue,3)
		        ENDIF 
		        THIS.SetKey(m.oKey)
		        THIS.UnlockCounter(m.oKey)
		        RETURN m.cValue
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS cDBCpath, cLocalReg, cSharedReg
		*++
		* Parameters:
		*   cDBCpath - Optional. Registry database path.
		*   cLocalRegPath - Optional. Name of (local) registry table (appreg02.dbf by default).
		*   cSharedRegName - Optional. Name of shared registry table (appreg01 by default).
		*
		* Note that since this registry object is used by the CodeMine CreateGlobalObject()
		* function, this Init method should not create any global objects itself.
		*
		* Copyright 1997-2002 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.Name = 'cmAppRegistryManager'
		
		  * Create runtime internal-use-only properties now. These are not available at design time.
		  THIS.AddProperty('cDBCname', '')               && Shared registry DBC name.
		  THIS.AddProperty('aValidatedCounters[1]', '')
		
		  * Determine the full path to the database containing the shared registry.
		  IF EMPTY(m.cDBCpath)
		    m.cDBCpath = THIS.cDBCpath
		  ENDIF
		  IF NOT '.' $ m.cDBCpath
		    m.cDBCpath = m.cDBCpath + '.dbc'
		  ENDIF
		  THIS.cDBCpath = LOWER(FULLPATH(m.cDBCpath))
		  THIS.cDBCname = JUSTSTEM(m.cDBCpath)           && Strip off and store the DBC name separately.
		
		  * Now Process optional file name parameters
		  IF NOT EMPTY(m.cLocalReg)
		    THIS.cLocalRegPath = m.cLocalReg
		  ENDIF
		  IF NOT EMPTY(m.cSharedReg)
		    THIS.cSharedRegName = m.cSharedReg
		  ENDIF
		
		  * If application object exists (which it always should), point %Shared prefix to the desired security source.
		  IF VARTYPE(m.goApp) = 'O'
		    THIS.cSharedPrefixMap = m.GoApp.cSecuritySource
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE initsession
		*++
		*>>Initialize data session settings
		*--
		  SET MEMOWIDTH TO 2048
		  SET DECIMALS TO 6
		  SET EXACT OFF
		
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE isreadonly		&& Return .T. if the specified registry root category is Read-only.
		LPARAMETERS cKeyRoot
		*++
		*>>Return .T. if the specified registry root category is Read-only.
		*--
		LOCAL oCursor
		  IF NOT LEFT(m.cKeyRoot, 1) = '%'
		    m.cKeyRoot = '%' + m.cKeyRoot
		  ENDIF
		
		  m.oCursor = THIS.GetRootCursor(cKeyRoot)
		  RETURN ISNULL(m.oCursor) OR m.oCursor.IsReadOnly()
		
	ENDPROC

	PROCEDURE localize		&& Localize registry key names and description, and set default language.
		LPARAMETERS cCategory, cTable, cLanguage
		*++
		*>>Localize registry key names and description, and set default language.
		*--
		LOCAL oCursor
		
		  * Get language from registry if not specified as a parameter
		  IF EMPTY(m.cLanguage)
		    m.cLanguage = THIS.GetKeyValue('%Local.Message.Preferences.Default Language',,'')
		  ELSE
		    * If a language was specified, make it the new default (only if it is a valid defined language).
		    IF THIS.GetKeyValueEx('%Local.Message.Languages.' + m.cLanguage)
		      THIS.SetKeyValue('%Local.Message.Preferences.Default Language', m.cLanguage)
		    ENDIF
		  ENDIF
		
		  * If still no language, or no source language table, then fail.
		  IF NOT EMPTY(m.cCategory) AND NOT EMPTY(m.cLanguage) AND NOT EMPTY(m.cTable) AND FILE(m.cTable)
		    * Get target cursor to localize, and localize it.
		    m.oCursor = THIS.GetRootCursor(@m.cCategory)
		    IF NOT ISNULL(m.oCursor)
		      RETURN m.oCursor.Localize(m.cCategory, m.cTable, m.cLanguage)
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE lockcounter		&& Find or Create the specified counter, and lock the associated record. Returns a reference to the counter key object.
		LPARAMETERS cKeyPath, nLength, nFormat, nInitialValue
		*++
		*>>Find or Create the specified counter, and lock the associated record. Returns a reference to the counter key object.
		*--
		LOCAL oCursor
		
		  m.oCursor = THIS.GetRootCursor(@m.cKeyPath, .T.)  && Create appreg01 table if necessary
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.LockCounter(m.cKeyPath, m.nLength, m.nFormat, m.nInitialValue)
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE newkey		&& Fill in the specified Key object with initial blank values for a new key. If no key object is specified, one is created.
		LPARAMETERS cKeyPath, oKey
		*++
		*>>Fill in the specified Key object with initial blank values for a new key. If no key object is specified, one is created.
		*--
		LOCAL oCursor
		
		  * Determine which registry cursor this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKeyPath)
		  IF NOT ISNULL(m.oCursor)
		    IF m.oCursor.NewKey(m.cKeyPath, @m.oKey)
		      WITH m.oKey
		        * Set default key type and access to the one specified in the category record, if any.
		        .nType = KEY_TYPE_CHAR
		        IF NOT EMPTY(.cCategory)
		          IF m.oCursor.SelectKeys(.cCategory,, 'Global') AND THIS._CheckKeyType(KEY_TYPE_CATEGORY)
		            .cType = m.oCursor.GetValue()
		            .nAccess = m.oCursor.FieldValue('Access')
		          ENDIF
		        ENDIF
		      ENDWITH
		      RETURN .T.
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE ostatemanager_access		&& Fill in the reference to the message display service object on first reference.
		*++
		*>>Fill in the reference to the message display service object on first reference.
		*--
		  IF ISNULL(THIS.oStateManager)
		    THIS.oStateManager = FindGlobalObject('cmStateManager')
		  ENDIF
		  RETURN THIS.oStateManager
		
	ENDPROC

	PROCEDURE ostring_access		&& Fill in the reference to the message display service object on first reference.
		*++
		*>>Fill in the reference to the message display service object on first reference.
		*--
		  IF ISNULL(THIS.oString)
		    THIS.oString = FindGlobalObject('cmStringTools')
		  ENDIF
		  RETURN THIS.oString
		
	ENDPROC

	PROCEDURE packall		&& Pack all registry tables based on native VFP tables. This will fail if other users have the tables open.
		*++
		*>>Pack all registry tables based on native VFP tables. This will fail if other users have the tables open.
		*--
		LOCAL ix, oCursor
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor) > 0
		    IF NOT m.oCursor.Pack()
		      RETURN .F.
		    ENDIF
		  ENDDO
		  RETURN .T.
		
	ENDPROC

	PROCEDURE renamekey		&& Rename the specified key to the specified name, propogating changes to all replications and subordinate keys.
		LPARAMETERS cKeypath, cNewKeyName, cNewLocName
		*++
		*>>Rename the specified key to the specified name, propogating changes to all replications and subordinate keys.
		*--
		LOCAL oCursor
		
		  * Get target cursor for the import
		  m.oCursor = THIS.GetRootCursor(@m.cKeypath)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.RenameKey(m.cKeypath, ;
		                               THIS._StandardizeKeyName(m.cNewKeyName), ;
		                               THIS._StandardizeKeyName(m.cNewLocName) )
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE requestupdatemessages		&& Add an object to list of subscribers to registry update events. The cUpdateType parameter can be either "Local" or "Shared"
		LPARAMETERS oRequestor, cUpdateType
		*++
		*>>Add an object to list of subscribers to registry update events. The cUpdateType parameter can be either "Local" or "Shared"
		*--
		  * If state manager doesn't exist (or requestor is NULL), dont do anything.
		  IF NOT ISNULL(THIS.oStateManager) AND VARTYPE(m.oRequestor) = 'O' AND NOT ISNULL(m.oRequestor)
		    m.cUpdateType = IIF(EMPTY(m.cUpdateType), 'LOCAL', UPPER(CHRTRAN(m.cUpdateType, '%', '')))
		    IF m.cUpdateType = 'LOCAL' OR m.cUpdateType = 'BOTH'
		      THIS.oStateManager.Subscribe('Registry Update Local', m.oRequestor)
		    ENDIF
		    IF m.cUpdateType = 'SHARED' OR m.cUpdateType = 'BOTH'
		      THIS.oStateManager.Subscribe('Registry Update Shared', m.oRequestor)
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE sendupdatemessages		&& Send RegistryUpdate messages to all registered objects. Normaly called by the registry editor to notify objects of registry value changes.
		LPARAMETERS cUpdateType
		*++
		*>>Send RegistryUpdate messages to all registered objects. Normaly called by the registry editor to notify objects of registry value changes.
		*
		* Parameter:
		*       cUpdateType - BOTH, LOCAL, or SHARED. Objects can request notification for
		*                     each registry individually, or both.
		*--
		  m.cUpdateType = UPPER(ALLTRIM(m.cUpdateType))
		  IF NOT ISNULL(THIS.oStateManager)
		    * If an object has subscribed to both events, its RegistryUpdate() method will be called
		    * twice. This is a bit inefficient, but it is also a rare case, so shouldnt be a problem.
		    IF m.cUpdateType = 'LOCAL' OR m.cUpdateType = 'BOTH'
		      THIS.oStateManager.Broadcast('Registry Update Local')
		    ENDIF
		    IF m.cUpdateType = 'SHARED' OR m.cUpdateType = 'BOTH'
		      THIS.oStateManager.Broadcast('Registry Update Shared')
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE setcounter		&& Sets the value of a locked Counter Key object. Can be used to recover from sync errors.
		LPARAMETERS oKey, uValue
		*++
		*>>Sets the value of a locked Counter Key object. Can be used to recover from sync errors.
		* Note that the new value is not written to the appreg table until you call UpdateCounter().
		*--
		  * Convert value from string format back to numeric format before storing.
		  WITH m.oKey
		    IF VARTYPE(m.uValue) $ 'NI'
		      .nValue = INT(m.uValue)
		    ELSE
		      .nValue = THIS.oString.StringToNum(m.uValue, .nCounterFormat)
		    ENDIF
		  ENDWITH
		
	ENDPROC

	PROCEDURE setglobalkeyvalue		&& Set the default value of a user-replicated registry key. If the key does not exist,
		LPARAMETERS cKey, uValue, cTypeMemo
		*++
		*>>Set the default value of a user-replicated registry key. If the key does not exist,
		* create one with the specified name and a type derived from the value datatype.
		*
		* cTypeMemo:  'Memo', or empty
		*--
		LOCAL oCursor
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKey)
		
		  * Load the record(s) and set the value.
		  IF NOT m.oCursor.SelectKeys(m.cKey,, 'Global')
		    m.oCursor.NewWithCategories(m.cKey,, THIS._DefaultKeyType(@m.uValue, m.cTypeMemo))
		  ENDIF
		  m.oCursor.SetValue(m.uValue)
		
		  * Commit the change to the source table and return.
		  IF m.oCursor.Update()
		    RETURN .T.
		  ENDIF
		  m.oCursor.Revert()
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setkey		&& Store properties of specified cmKeyProperties object to appropriate table.
		LPARAMETERS oKey, nFlags
		*++
		*>>Store properties of specified cmKeyProperties object to appropriate table.
		*--
		LOCAL oCursor
		 
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  m.oCursor = THIS.GetCursor(m.oKey.cWorkarea)
		  IF NOT ISNULL(m.oCursor) AND m.oCursor.SetKey(m.oKey, m.nFlags)
		    * Send RegistryUpdate() messages to all registered objects, if requested.
		    IF NOT EMPTY(BITAND(m.nFlags, REGMASK_BROADCAST))
		      DO CASE
		        CASE UPPER(m.oCursor.cWorkarea) == UPPER(THIS._GetRootAlias('%Local'))
		          THIS.SendUpdateMessages('Local')
		        CASE UPPER(m.oCursor.cWorkarea) == UPPER(THIS._GetRootAlias('%Shared'))
		          THIS.SendUpdateMessages('Shared')
		      ENDCASE
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setkeyvalue		&& Set the value of an existing registry key. Fails if the key does not already exist.
		LPARAMETERS cKey, uValue
		*++
		*>>Set the value of an existing registry key. Fails if the key does not already exist.
		*--
		LOCAL oCursor
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKey)
		
		  * Find the record and set the value.
		  IF m.oCursor.SelectKeys(m.cKey,, 'User')
		    m.oCursor.SetReplicatedValue(m.uValue)
		
		    * Commit the change to the source table.
		    IF m.oCursor.Update()
		      RETURN .T.
		    ENDIF
		    m.oCursor.Revert()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setkeyvalueex		&& Set extended information for a key. Create the key if it does not already exist.
		LPARAMETERS cKey, nReplicationType, cLocName, uType, uValue, cDescription, nAccess, cProperties
		*++
		*>>Set extended information for a key. Create the key if it does not already exist.
		* If key already exists, uType must match key type or error is signaled.
		*--
		LOCAL oCursor
		
		  * A type is required one way or another. If none is specified, generate default from value datatype.
		  m.uType = IIF(EMPTY(m.uType), THIS._DefaultKeyType(@m.uValue), m.uType)
		
		  m.oCursor = THIS.GetRootCursor(@m.cKey)
		  IF NOT ISNULL(m.oCursor)
		    IF m.oCursor.SelectKeys(m.cKey,, 'User')
		      * Key already exists, make sure type (required parameter) is correct.
		      IF NOT THIS._CheckKeyType(m.uType, PROGRAM())
		        RETURN .F.
		      ENDIF
		
		      * Update access level in existing key, if a new level is specified.
		      IF VARTYPE(m.nAccess) $ 'NI'
		        REPLACE access WITH m.nAccess
		      ENDIF
		    ELSE
		      * Key does not exist, create a new one.
		      m.oCursor.NewWithCategories(m.cKey, m.cLocName, m.uType, m.nAccess)
		
		      REPLACE repType WITH IIF(EMPTY(m.nReplicationType), KEY_REPLICATE_NONE, KEY_REPLICATE_USER)
		 
		      * For keys with user replication enabled, the value becomes the current user's 
		      * value and the default value for all other users.
		      IF NOT EMPTY(m.nReplicationType)
		        m.oCursor.SetValue(m.uValue)
		      ENDIF
		    ENDIF
		
		    * Replace remaining property fields. We use direct cursor access commands here, rather
		    * than using the cmRegProperties object in order to get the fastest execution speed.
		    IF VARTYPE(m.cProperties) = 'C'
		      REPLACE properties WITH m.cProperties
		    ENDIF
		
		    * Store key description if it was specified.
		    IF VARTYPE(m.cDescription) = 'C'
		      REPLACE comment WITH m.cDescription
		    ENDIF
		
		    * And finally store the value for the key, and commit the change.
		    m.oCursor.SetReplicatedValue(m.uValue)
		    IF m.oCursor.Update()
		      RETURN .T.
		    ENDIF
		    m.oCursor.Revert()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setuserkeyvalue		&& Set the value of a registry key. If the key does not exist, create one with the specified name and a type derived from the value datatype.
		LPARAMETERS cKey, uValue, cTypeMemo
		*++
		*>>Set the value of a registry key. If the key does not exist, create one with the specified name and a type derived from the value datatype.
		* The created key will have user replication enabled.
		*
		* cTypeMemo:  'Memo', or empty
		*--
		LOCAL oCursor
		
		  * Determine which registry workarea this key resides in.
		  m.oCursor = THIS.GetRootCursor(@m.cKey)
		
		  * Find the record and set the value.
		  IF NOT m.oCursor.SelectKeys(m.cKey,, 'User')
		    m.oCursor.NewWithCategories(m.cKey,, THIS._DefaultKeyType(@m.uValue, m.cTypeMemo))
		
		    * This value also becomes the default value for the new key.
		    m.oCursor.SetValue(m.uValue)
		    REPLACE repType WITH KEY_REPLICATE_USER
		  ENDIF
		  m.oCursor.SetReplicatedValue(m.uValue)
		
		  * Commit the change to the source table and return.
		  IF m.oCursor.Update()
		    RETURN .T.
		  ENDIF
		  m.oCursor.Revert()
		  RETURN .F.
		
	ENDPROC

	PROCEDURE unlockcounter		&& Unlocks the key record associated with the specified counter.
		LPARAMETERS oKey
		*++
		*>>Unlocks the key record associated with the specified counter.
		*--
		LOCAL oCursor
		  * Counter locks currently only apply to keys stored in native VFP tables.
		  IF NOT EMPTY(m.oKey.nRecno)
		    m.oCursor = THIS.GetCursor(m.oKey.cWorkarea)
		    RETURN m.oCursor.UnlockRecord(m.oKey.nRecno)
		  ENDIF
		
	ENDPROC

	PROCEDURE updatecounter		&& Writes current Counter Key properties back to the appropriate key table.
		LPARAMETERS oKey
		*++
		*>>Writes current Counter Key properties back to the appropriate key table.
		*--
		  THIS.SetKey(m.oKey)
		
	ENDPROC

	PROCEDURE _checkkeytype		&& Internal method to Check that the key type of the current record in current workarea matches the type specified by caller.
		LPARAMETERS uType, cCaller
		*++
		*>>Internal method to Check that the key type of the current record in current workarea matches the type specified by caller.
		*--
		LOCAL lStatus
		
		  DO CASE
		    CASE EMPTY(m.uType)
		      m.lStatus = .T.
		    CASE VARTYPE(m.uType) = 'N'    && Native key types
		      IF m.uType = type ;
		      OR (m.uType = KEY_TYPE_CHAR AND INLIST(type, KEY_TYPE_MEMO, KEY_TYPE_POPUP, KEY_TYPE_ENUM))
		        m.lStatus = .T.
		      ENDIF
		    CASE VARTYPE(m.uType) = 'C'   && External key types
		      m.lStatus = (type = KEY_TYPE_BINARY) AND UPPER(TRIM(shortValue)) == UPPER(m.uType)
		  ENDCASE
		
		  * Display diagnostic error dialog if a caller name was supplied.
		  IF NOT m.lStatus AND NOT EMPTY(m.cCaller)
		    ERROR PROPER(m.cCaller) + ': Wrong key datatype for ' + TRIM(keyName)
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE _defaultkeytype		&& Internal method to Determine default key type from datatype of value.
		LPARAMETERS uValue, cType
		*++
		*>>Internal method to Determine default key type from datatype of value.
		*--
		  m.cType = IIF(EMPTY(m.cType), '', PROPER(m.cType))
		  DO CASE
		    CASE VARTYPE(m.uValue) = 'C' AND (LEN(m.uValue) > LEN(shortValue) OR m.cType = 'Memo')
		      RETURN KEY_TYPE_MEMO
		    CASE VARTYPE(m.uValue) = 'C'
		      RETURN KEY_TYPE_CHAR
		    CASE VARTYPE(m.uValue) $ 'NI'
		      RETURN KEY_TYPE_NUMERIC
		    CASE VARTYPE(m.uValue) = 'L'
		      RETURN KEY_TYPE_LOGICAL
		    OTHERWISE
		      ERROR 11  && Programming error - Invalid type
		  ENDCASE
		
	ENDPROC

	PROCEDURE _getrootalias		&& Return the cursors alias to use, based on the key path root prefix.
		LPARAMETERS cSource, cDBC
		*++
		*>>Return the cursors alias to use, based on the key path root prefix.
		*--
		LOCAL cAlias
		  m.cSource = LOWER(m.cSource)
		  DO CASE
		    CASE m.cSource == '%local'
		      * Alias will be <filename_dbf>
		      m.cSource = THIS.cLocalRegPath 
		      m.cDBC = ''                       && Local is a free table, so no DBC
		    CASE m.cSource == '%shared' OR THIS.lOnlyOneShared
		      * Alias will be <tablename>
		      m.cSource = THIS.cSharedPrefixMap
		    OTHERWISE
		      * Alias will be <DBC_TableName>
		      m.cSource = PROPER(SUBSTR(m.cSource, 2))  && Strip off leading %
		      IF NOT '!' $ m.cSource
		        m.cSource = JUSTSTEM(THIS.cDBCpath) + '!' + m.cSource
		      ENDIF
		  ENDCASE
		
		  * Return an alias name, based on filename and extension, but dont include .dbc extension on DBC spec.
		  m.cAlias = STRTRAN(LOWER(m.cSource), '.dbc!', '!')
		  RETURN CHRTRAN(JUSTFNAME(m.cAlias), '!.', '__')
		
	ENDPROC

	PROCEDURE _standardizekeyname		&& Force key path to a consistent format, with trailing period terminator.
		LPARAMETERS cKeyName
		*++
		*>>Force key path to a consistent format, with trailing period terminator.
		*--
		LOCAL nWild
		  * We allow wildcard asterisk characters at the end. Single wildcard means 
		  * include imediate subkeys. Double wildard car means to include all subkeys 
		  * at all subordinate levels.
		  IF NOT EMPTY(m.cKeyName)
		    m.nWild = MIN(OCCURS('*', m.cKeyName), 2)
		    m.cKeyName = STRTRAN(ALLTRIM(m.cKeyName), '*', '')
		    IF NOT EMPTY(m.cKeyName) AND RIGHT(m.cKeyName, 1) != '.'
		      m.cKeyName = m.cKeyName + '.'
		    ENDIF
		    RETURN m.cKeyName + REPLICATE('*', m.nWild)
		  ENDIF
		  RETURN ''
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmregproperties AS cmserviceabstract OF "..\common\cmdataa.vcx" 		&& CodeMine Registry Key data properties object.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: ckeypath_assign
		*m: clear		&& Clear all properties to original empty values.
		*m: clearproperties		&& Reset extended key definition properties to initial default (blank) values.
		*m: clocpath_assign
		*m: comments		&& Application Registry Key value and extended properties object.
		*m: ctype_access
		*m: ctype_assign
		*m: gather		&& Build a properties value string from individual property values.
		*m: load		&& Load all properties (except values) from the oOldVal property settings.
		*m: scatter		&& Parse packed properties string into individual property values.
		*p: ccategory
		*p: cdescription
		*p: cenumcategory
		*p: cexternaltype
		*p: cformat
		*p: ckeypath
		*p: cloccategory
		*p: clocname
		*p: clocpath
		*p: clogfalse
		*p: clognull
		*p: clogtrue
		*p: cname
		*p: cpicture
		*p: cpopupvalues
		*p: ctabextensionlist
		*p: ctype
		*p: cvalue
		*p: cworkarea
		*p: dvalue
		*p: lallowlinebreak
		*p: lallownull
		*p: lalpha
		*p: lreadonly
		*p: ltaballowappend
		*p: ltaballowbrowse
		*p: ltaballowdelete
		*p: ltaballowedit
		*p: ltabfullpath
		*p: luppercase
		*p: lvalue
		*p: naccess
		*p: ncounterformat
		*p: ncounterincr
		*p: ncounterlength
		*p: ncounterreset
		*p: nmaxlength
		*p: nrecno
		*p: nreplicationtype
		*p: nspnhighvalue
		*p: nspnincrement
		*p: nspnlowvalue
		*p: ntabpathtype
		*p: ntype
		*p: nvalue
		*p: ooldval
		*p: uenumtype
	*</DefinedPropArrayMethod>

	ccategory = 
	cdescription = 
	cenumcategory = 
	cexternaltype = 
	cformat = 
	ckeypath = 
	cloccategory = 
	clocname = 
	clocpath = 
	clogfalse = False
	clognull = Unknown
	clogtrue = True
	cname = 
	cpicture = 
	cpopupvalues = 
	ctabextensionlist = dbf
	ctype = 
	cvalue = 
	cworkarea = 
	dvalue = ({})
	lallowlinebreak = .F.
	lallownull = .F.
	lalpha = .F.
	lreadonly = .F.
	ltaballowappend = .F.
	ltaballowbrowse = .F.
	ltaballowdelete = .F.
	ltaballowedit = .F.
	ltabfullpath = .T.
	luppercase = .F.
	lvalue = .F.
	naccess = 0
	Name = "cmregproperties"
	ncounterformat = 0
	ncounterincr = 1
	ncounterlength = 0
	ncounterreset = 0
	nmaxlength = 0
	nrecno = 0
	nreplicationtype = 0
	nspnhighvalue = 0
	nspnincrement = 0
	nspnlowvalue = 0
	ntabpathtype = (KEY_PATH_TABLE)
	ntype = 0
	nvalue = 0
	ooldval = .NULL.
	uenumtype = 
	
	PROCEDURE ckeypath_assign
		LPARAMETERS cPath
		  * Break the full key path down into category and name components.
		  IF RIGHT(TRIM(m.cPath), 1) = '.'
		    m.cPath = LEFT(m.cPath, LEN(m.cPath) - 1)
		  ENDIF
		
		  m.nIndex = RAT('.', m.cPath)
		  THIS.cKeyPath = m.cPath + IIF(EMPTY(m.cPath), '', '.')
		  THIS.cCategory = LEFT(m.cPath, m.nIndex - 1)
		  THIS.cName = TRIM(SUBSTR(m.cPath, m.nIndex + 1))
		
	ENDPROC

	PROCEDURE clear		&& Clear all properties to original empty values.
		*++
		*>>Clear all properties to original empty values.
		*--
		  WITH THIS
		    * Original full key path used to locate record in source tables.
		    * Assign methods on keyPath and locPath set cKeyCategory and cKeyName properties.
		    .cKeyPath = ''
		    .cLocPath = ''
		
		    .lValue = .F.
		    .nValue = 0
		    .cValue = ''
		
		    .nType = 0
		    .cExternalType = ''
		    .nAccess = 0
		    .nReplicationType = 0
		    .cDescription = ''
		
		    * Clear key definition properties also
		    .ClearProperties()
		  ENDWITH
		
	ENDPROC

	PROCEDURE clearproperties		&& Reset extended key definition properties to initial default (blank) values.
		*++
		*>>Reset extended key definition properties to initial default (blank) values.
		*--
		  * Properties packed into the Properties memo field of registry table.
		  THIS.lAllowNull = .F.
		  THIS.lAllowLineBreak = .F.
		  THIS.lUpperCase = .F.
		  THIS.lAlpha = .F.
		  THIS.cPicture = ''
		  THIS.cFormat = ''
		  THIS.nMaxLength = 0
		  THIS.cPopupValues = ''
		  THIS.cEnumCategory = ''
		  THIS.uEnumType = ''
		  THIS.cTabExtensionList = 'dbf'
		  THIS.nTabPathType = KEY_PATH_TABLE
		  THIS.lTabAllowBrowse = .F.
		  THIS.lTabAllowEdit = .F.
		  THIS.lTabAllowAppend = .F.
		  THIS.lTabAllowDelete = .F.
		  THIS.lTabFullPath = .T.
		  THIS.cLogTrue = 'True'
		  THIS.cLogFalse = 'False'
		  THIS.cLogNull = 'Unknown'
		  THIS.nSpnLowValue = -2147483647
		  THIS.nSpnHighValue = 2147483647
		  THIS.nSpnIncrement = 1
		  THIS.nCounterLength = 4
		  THIS.nCounterFormat = 10
		  THIS.nCounterReset = 0
		  THIS.nCounterIncr = 1
		
	ENDPROC

	PROCEDURE clocpath_assign
		LPARAMETERS cPath
		  * Break the full key path down into category and name components.
		  IF RIGHT(TRIM(m.cPath), 1) = '.'
		    m.cPath = LEFT(m.cPath, LEN(m.cPath) - 1)
		  ENDIF
		
		  m.nIndex = RAT('.', m.cPath)
		  THIS.cLocPath = m.cPath + '.'
		  THIS.cLocCategory = LEFT(m.cPath, m.nIndex - 1)
		  THIS.cLocName = TRIM(SUBSTR(m.cPath, m.nIndex + 1))
		
	ENDPROC

	PROCEDURE comments		&& Application Registry Key value and extended properties object.
		*++
		*>>Application Registry Key value and extended properties object.
		*
		* Copyright 1997-2002 Soft Classics, Ltd. All rights reserved.
		*--
		
	ENDPROC

	PROCEDURE ctype_access
		  DO CASE
		    CASE EMPTY(THIS.nType)
		      RETURN ''
		    CASE THIS.nType = KEY_TYPE_CHAR
		      RETURN 'Character'
		    CASE THIS.nType  = KEY_TYPE_MEMO
		      RETURN  'Memo'
		    CASE THIS.nType  = KEY_TYPE_POPUP
		      RETURN  'Dropdown List'
		    CASE THIS.nType  = KEY_TYPE_ENUM
		      RETURN 'Enumerated Dropdown'
		    CASE THIS.nType  = KEY_TYPE_LOGICAL
		      RETURN 'Logical'
		    CASE THIS.nType  = KEY_TYPE_NUMERIC
		      RETURN 'Numeric'
		    CASE THIS.nType  = KEY_TYPE_COUNTER
		      RETURN 'Sequential Counter'
		    CASE THIS.nType  = KEY_TYPE_PATH
		      RETURN  'File Path'
		    CASE THIS.nType  = KEY_TYPE_BINARY
		      RETURN IIF(EMPTY(THIS.cExternalType), 'Binary', THIS.cExternalType)
		  ENDCASE
		  RETURN ''
		
	ENDPROC

	PROCEDURE ctype_assign
		LPARAMETERS cType
		* Manage the relationship between nType and cExternalType properties
		  m.cType = PROPER(m.cType)
		  THIS.cExternalType = ''
		  DO CASE
		    CASE EMPTY(m.cType)
		    CASE m.cType = 'Character'
		      THIS.nType = KEY_TYPE_CHAR
		    CASE m.cType  = 'Memo'
		      THIS.nType = KEY_TYPE_MEMO
		    CASE m.cType  = 'Dropdown List'
		      THIS.nType = KEY_TYPE_POPUP
		    CASE m.cType  = 'Enumerated Dropdown'
		      THIS.nType = KEY_TYPE_ENUM
		    CASE m.cType  = 'Logical'
		      THIS.nType = KEY_TYPE_LOGICAL
		    CASE m.cType  = 'Numeric'
		      THIS.nType = KEY_TYPE_NUMERIC
		    CASE m.cType  = 'Sequential Counter'
		      THIS.nType = KEY_TYPE_COUNTER
		    CASE m.cType  = 'File Path'
		      THIS.nType = KEY_TYPE_PATH
		    CASE m.cType  = 'Binary'
		      THIS.nType = KEY_TYPE_BINARY
		    OTHERWISE
		      THIS.nType = KEY_TYPE_BINARY
		      THIS.cExternalType = m.cType
		  ENDCASE
		
	ENDPROC

	PROCEDURE gather		&& Build a properties value string from individual property values.
		*++
		*>>Build a properties value string from individual property values.
		*--
		LOCAL cProperties
		
		  m.cProperties = ''
		  IF INLIST(THIS.nType, KEY_TYPE_CHAR, KEY_TYPE_NUMERIC)
		    IF NOT EMPTY(THIS.cPicture)
		      m.cProperties = m.cProperties + '%Picture=' + THIS.cPicture + CR_LF
		    ENDIF
		    IF THIS.lUpperCase OR THIS.lAlpha 
		      m.cProperties = m.cProperties + '%Format=' ;
		                + IIF(THIS.lUpperCase,'!','') + IIF(THIS.lAlpha,'A','') + CR_LF
		    ENDIF
		  ENDIF
		
		  IF THIS.lAllowNull
		    m.cProperties = m.cProperties + '%AllowNull' + CR_LF
		  ENDIF
		
		  DO CASE
		    CASE THIS.nType = KEY_TYPE_MEMO
		      IF NOT EMPTY(THIS.nMaxLength)
		        m.cProperties = m.cProperties + '%MaxLength=' + STR(THIS.nMaxLength) + CR_LF
		      ENDIF
		      IF THIS.lAllowLineBreak
		        m.cProperties = m.cProperties + '%AllowLineBreak' + CR_LF
		      ENDIF
		
		    CASE THIS.nType = KEY_TYPE_PATH
		      m.cProperties = m.cProperties + '%PathType=' + STR(THIS.nTabPathType,1) + CR_LF
		      IF NOT THIS.lTabFullPath
		        m.cProperties = m.cProperties + '%RelativePath' + CR_LF
		      ENDIF
		      IF THIS.nTabPathType = KEY_PATH_TABLE
		        IF THIS.lTabAllowBrowse 
		          m.cProperties = m.cProperties + '%AllowBrowse' + CR_LF
		          IF NOT THIS.lTabAllowEdit 
		            m.cProperties = m.cProperties + '%NoEdit' + CR_LF
		          ENDIF
		          IF NOT THIS.lTabAllowAppend 
		            m.cProperties = m.cProperties + '%NoAppend' + CR_LF
		          ENDIF
		          IF NOT THIS.lTabAllowDelete 
		            m.cProperties = m.cProperties + '%NoDelete' + CR_LF
		          ENDIF
		        ENDIF
		      ENDIF
		      IF THIS.nTabPathType = KEY_PATH_FILE
		        IF NOT EMPTY(THIS.cTabExtensionList)
		          m.cProperties = m.cProperties + '%ExtensionList=' + THIS.cTabExtensionList + CR_LF
		        ENDIF
		      ENDIF
		
		    CASE THIS.nType = KEY_TYPE_POPUP
		      IF NOT EMPTY(THIS.cPopupValues)
		        m.cProperties = m.cProperties + '%PopupValues=' + THIS.cPopupValues + CR_LF
		      ENDIF
		
		    CASE THIS.nType = KEY_TYPE_ENUM
		      IF NOT EMPTY(THIS.cEnumCategory)
		        m.cProperties = m.cProperties + '%EnumCategory=' + THIS.cEnumCategory + CR_LF
		      ENDIF
		      IF TYPE('THIS.uEnumType') = 'N'
		        m.cProperties = m.cProperties + '%EnumType=' + LTRIM(STR(THIS.uEnumType, 2)) + CR_LF
		      ELSE
		        m.cProperties = m.cProperties + '%EnumExtType=' + THIS.uEnumType + CR_LF
		      ENDIF
		
		    CASE THIS.nType = KEY_TYPE_LOGICAL
		      IF NOT EMPTY(THIS.cLogTrue)
		        m.cProperties = m.cProperties + '%TrueString=' + THIS.cLogTrue + CR_LF
		      ENDIF
		      IF NOT EMPTY(THIS.cLogFalse)
		        m.cProperties = m.cProperties + '%FalseString=' + THIS.cLogFalse + CR_LF
		      ENDIF
		      IF NOT EMPTY(THIS.cLogNull)
		        m.cProperties = m.cProperties + '%NullString=' + THIS.cLogNull + CR_LF
		      ENDIF
		
		    CASE THIS.nType = KEY_TYPE_NUMERIC
		      m.cProperties = m.cProperties + '%LowLimit=' + STR(THIS.nSpnLowValue,18,5) + CR_LF
		      m.cProperties = m.cProperties + '%HighLimit=' + STR(THIS.nSpnHighValue,18,5) + CR_LF
		      IF NOT EMPTY(THIS.nSpnIncrement)
		        m.cProperties = m.cProperties + '%Increment=' + STR(THIS.nSpnIncrement,18,5) + CR_LF
		      ENDIF
		
		    CASE THIS.nType = KEY_TYPE_COUNTER
		      m.cProperties = m.cProperties + '%Length=' + STR(THIS.nCounterLength, 2) + CR_LF
		      m.cProperties = m.cProperties + '%Radix=' + STR(THIS.nCounterFormat, 3) + CR_LF
		      m.cProperties = m.cProperties + '%Reset=' + STR(THIS.nCounterReset, 2) + CR_LF
		      m.cProperties = m.cProperties + '%Incr=' + STR(THIS.nCounterIncr, 3) + CR_LF
		  ENDCASE
		  RETURN m.cProperties
		
	ENDPROC

	PROCEDURE load		&& Load all properties (except values) from the oOldVal property settings.
		*++
		*>>Load all properties (except values) from the oOldVal property settings.
		*--
		  WITH THIS
		    * Original full key path used to locate record in source tables.
		    * Assign methods on keyPath and locPath set cKeyCategory and cKeyName properties.
		    .cKeyPath = TRIM(.oOldVal.keyName)
		    .cLocPath = TRIM(.oOldVal.locName)
		
		    .nType = .oOldVal.Type
		    .cExternalType = IIF(.oOldVal.Type = KEY_TYPE_BINARY, TRIM(.oOldVal.shortValue), '')
		    .nAccess = .oOldVal.Access
		    .nReplicationType = .oOldVal.repType 
		    .cDescription = NVL(.oOldVal.Comment, '')
		
		    .Scatter(.oOldVal.properties)
		  ENDWITH
		
	ENDPROC

	PROCEDURE scatter		&& Parse packed properties string into individual property values.
		LPARAMETERS cProperties
		*++
		*>>Parse packed properties string into individual property values.
		*--
		LOCAL nIndex, cLine, cToken
		
		  _MLINE = 0
		  THIS.ClearProperties()
		  FOR nIndex = 1 TO MEMLINES(m.cProperties)
		    m.cLine = MLINE(m.cProperties, 1, _MLINE)
		    IF NOT EMPTY(m.cLine)
		      m.cToken = GetToken(@m.cLine, '=')
		      DO CASE
		        CASE THIS.nType = KEY_TYPE_COUNTER
		          DO CASE
		            CASE m.cToken == '%Length'
		              THIS.nCounterLength = VAL(m.cLine)
		            CASE m.cToken == '%Radix'
		              THIS.nCounterFormat = VAL(m.cLine)
		            CASE m.cToken == '%Reset'
		              THIS.nCounterReset = VAL(m.cLine)
		            CASE m.cToken == '%Incr'
		              THIS.nCounterIncr = VAL(m.cLine)
		          ENDCASE
		
		        CASE m.cToken == '%Picture'
		          THIS.cPicture = m.cLine
		
		        CASE m.cToken == '%Format'
		          THIS.cFormat = m.cLine
		          THIS.lUpperCase = '!' $ m.cLine
		          THIS.lAlpha = 'A' $ m.cLine
		
		        CASE m.cToken == '%AllowNull'
		          THIS.lAllowNull = .T.
		
		        CASE m.cToken == '%AllowLineBreak'
		          THIS.lAllowLineBreak = .T.
		
		        CASE THIS.nType = KEY_TYPE_MEMO
		          DO CASE
		            CASE m.cToken == '%MaxLength'
		              THIS.nMaxLength = VAL(m.cLine)
		          ENDCASE
		
		        CASE THIS.nType = KEY_TYPE_POPUP
		          DO CASE
		            CASE m.cToken == '%PopupValues'
		              THIS.cPopupValues = m.cLine
		          ENDCASE
		
		        CASE THIS.nType = KEY_TYPE_ENUM
		          DO CASE
		            CASE m.cToken == '%EnumCategory'
		              THIS.cEnumCategory = m.cLine
		            CASE m.cToken == '%EnumType'
		              THIS.uEnumType = VAL(m.cLine)
		            CASE m.cToken == '%EnumExtType'
		              THIS.uEnumType = m.cLine
		          ENDCASE
		
		        CASE THIS.nType = KEY_TYPE_PATH
		          DO CASE
		            CASE m.cToken == '%PathType'
		              THIS.nTabPathType = VAL(m.cLine)
		              IF THIS.nTabPathType = KEY_PATH_TABLE
		                THIS.cTabExtensionList = 'dbf'
		              ELSE
		                THIS.cTabExtensionList = 'txt'
		              ENDIF
		            CASE m.cToken == '%RelativePath'
		              THIS.lTabFullPath = .F.
		            CASE m.cToken == '%AllowBrowse'
		              THIS.lTabAllowBrowse = .T.
		              THIS.lTabAllowEdit = .T.
		              THIS.lTabAllowAppend = .T.
		              THIS.lTabAllowDelete = .T.
		            CASE m.cToken == '%NoEdit'
		              THIS.lTabAllowEdit = .F.
		            CASE m.cToken == '%NoAppend'
		              THIS.lTabAllowAppend = .F.
		            CASE m.cToken == '%NoDelete'
		              THIS.lTabAllowDelete = .F.
		            CASE m.cToken == '%ExtensionList'
		              THIS.cTabExtensionList = m.cLine
		          ENDCASE
		
		        CASE THIS.nType = KEY_TYPE_LOGICAL
		          DO CASE
		            CASE m.cToken == '%TrueString'
		              THIS.cLogTrue = m.cLine
		            CASE m.cToken == '%FalseString'
		              THIS.cLogFalse = m.cLine
		            CASE m.cToken == '%NullString'
		              THIS.cLogNull = m.cLine
		          ENDCASE
		
		        CASE THIS.nType = KEY_TYPE_NUMERIC
		          DO CASE
		            CASE m.cToken == '%LowLimit'
		              THIS.nSpnLowValue = VAL(m.cLine)
		            CASE m.cToken == '%HighLimit'
		              THIS.nSpnHighValue = VAL(m.cLine)
		            CASE m.cToken == '%Increment'
		              THIS.nSpnIncrement = VAL(m.cLine)
		          ENDCASE
		
		        OTHERWISE
		          =MESSAGEBOX('Registry Parameter Parse Error: ' + m.cToken)
		      ENDCASE
		    ENDIF
		  ENDFOR
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmstringtools AS cmserviceabstract OF "cmdataa.vcx" 		&& CodeMine String conversion and manipulation utilities.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addquotes		&& Add quotes to the passes string if needed.
		*m: chartovalue		&& Convert character representation of a value to the specified datatype.
		*m: defaultcentury		&& If century is not specified in the passed date, generate a default.
		*m: formatdate		&& Format a date for display in the current language.
		*m: loadmonthnames		&& Initialize month names for the current language.
		*m: matchwildcardc		&& Case-independent wildcard match.
		*m: matchwildcardn		&& Case-independent normalized wildcard match.
		*m: monospacestring		&& Remove leading and trailing space/tabs from a string, and replace multiple embedded spaces/tabs with a single space.
		*m: nearmatch		&& Match without regard to case, spacing or punctuation.
		*m: numtostring		&& Convert a numeric value to a byte-encoded string of the specified radix.
		*m: parsedate		&& Parse a freeform string date in the current language.
		*m: propercase		&& Method to properly capitalize proper name strings.
		*m: registryupdate		&& Called on initialization and whenever the registry database is updated.
		*m: stringtoarray		&& Convert comma seperated list of items into an array, one item per row.
		*m: stringtodate		&& Convert a universal date string to VFP internal date format.
		*m: stringtonum		&& Convert byte encoded value from string format back to numeric.
		*m: stringtotime		&& Convert a universal date/time string to VFP internal time format.
		*m: valuetochar		&& Convert any type variable to a character format representation.
		*p: ccaseexceptions		&& Default list of proper case exception words.
		*p: cdelimiters		&& Default string of word-break punctuation for the ProperCase() method.
		*p: cversion		&& Internal codemine version string for this object.
		*p: lstopafterfirst		&& Determines whether or not Proper-casing stops after encountering the first capitalized word in a string.
	*</DefinedPropArrayMethod>

	ccaseexceptions = ([Mc*,O'*,D'*,of,a,in,the,de,der,USA,RR,POB,II,III,IV])		&& Default list of proper case exception words.
	cdelimiters = ",.?!/-%#()[]{}\+=~@^*		&& Default string of word-break punctuation for the ProperCase() method.
	cversion = 7.0.0		&& Internal codemine version string for this object.
	lstopafterfirst = .F.		&& Determines whether or not Proper-casing stops after encountering the first capitalized word in a string.
	Name = "cmstringtools"
	
	PROCEDURE addquotes		&& Add quotes to the passes string if needed.
		LPARAMETERS cValue
		*++
		*>>Add quotes to the passes string if needed.
		*--
		LOCAL cLeft, cQuote
		  m.cLeft = LEFT(m.cValue, 1)
		  IF (m.cLeft $ ['"] AND RIGHT(m.cValue, 1) = m.cLeft) ;
		  OR (m.cLeft = '[' AND RIGHT(m.cValue, 1) = ']')
		    RETURN m.cValue
		  ENDIF
		
		  m.cQuote = IIF('"' $ m.cValue, "'", '"')
		  IF m.cQuote $ m.cValue
		    RETURN '[' + m.cValue + ']'
		  ENDIF
		  RETURN m.cQuote + m.cValue + m.cQuote
		
	ENDPROC

	PROCEDURE chartovalue		&& Convert character representation of a value to the specified datatype.
		LPARAMETERS cSource, cType
		*++
		*>>Convert character representation of a value to the specified datatype.
		*--
		  DO CASE
		    CASE m.cType = 'N' OR m.cType = 'Y'
		      RETURN IIF(SET('POINT') $ m.cSource, VAL(m.cSource), INT(VAL(m.cSource)))
		    CASE m.cType = 'L'
		      RETURN (m.cSource = '.T.')
		    CASE m.cType = 'D'
		      RETURN THIS.StringToDate(@m.cSource)
		    CASE m.cType = 'T'
		      RETURN THIS.StringToTime(@m.cSource)
		  ENDCASE
		  RETURN m.cSource
		
	ENDPROC

	PROCEDURE defaultcentury		&& If century is not specified in the passed date, generate a default.
		LPARAMETERS nYear, nMonth, nDay, cMethod
		*++
		*>>If century is not specified in the passed date, generate a default.
		* 4 methods for default: Assume past, Assume Future, Rollover, Assume Current
		*--
		  m.cMethod = IIF(EMPTY(m.cMethod), 'Rollover', PROPER(m.cMethod))
		  IF m.nYear < 100
		    DO CASE
		      CASE PROPER(m.cMethod) = 'Rollover'
		        * If Year is below the rollover year, assume next century.
		        m.nYear = (m.nYear % 100) + (SET('CENTURY', 1) * 100)
		        IF (m.nYear % 100) < SET('CENTURY', 2)
		          m.nYear = m.nYear + 100
		        ENDIF
		      CASE PROPER(m.cMethod) = 'Future'
		        * Date is supposed to be in the future, assume next century.
		        m.nYear = (m.nYear % 100) + INT(YEAR(DATE())/100)*100
		        DO WHILE m.nYear < YEAR(DATE()) ;
		        OR (m.nYear = YEAR(DATE()) AND (m.nMonth * 100 + m.nDay) < (MONTH(DATE()) * 100 + DAY(DATE())))
		          m.nYear = m.nYear + 100
		        ENDDO
		      CASE PROPER(m.cMethod) = 'Past'
		        * Date is supposed to be in the past, assume previous century.
		        m.nYear = (m.nYear % 100) + INT(YEAR(DATE())/100)*100
		        DO WHILE m.nYear > YEAR(DATE()) ;
		        OR (m.nYear = YEAR(DATE()) AND (m.nMonth * 100 + m.nDay) > (MONTH(DATE()) * 100 + DAY(DATE())))
		          m.nYear = m.nYear - 100
		        ENDDO
		    ENDCASE
		  ENDIF
		  RETURN m.nYear
		
	ENDPROC

	PROCEDURE formatdate		&& Format a date for display in the current language.
		LPARAMETERS dValue, cFormat
		*++
		*>>Format a date for display in the current language.
		*--
		LOCAL cDate, cMonth
		
		  m.cDate = ''
		  m.cFormat = IIF(EMPTY(m.cFormat), 'MDY', UPPER(m.cFormat))
		  THIS.LoadMonthNames()
		
		  IF NOT EMPTY(NVL(m.dValue, {}))
		    m.cMonth = PROPER(IIF('SHORT' $ m.cFormat, THIS.aShort[MONTH(m.dValue)], THIS.aMonths[MONTH(m.dValue)]))
		    IF 'MONTH' $ m.cFormat
		      IF 'CHAR' $ m.cFormat
		        m.cDate = m.cMonth + ' ' + ALLTRIM(STR(YEAR(m.dValue)))
		      ELSE
		        m.cDate = ALLTRIM(STR(MONTH(m.dValue))) + '/' + ALLTRIM(STR(YEAR(m.dValue)))
		      ENDIF
		    ELSE
		      DO CASE
		        CASE 'DMY' $ m.cFormat
		          m.cDate = LTRIM(STR(DAY(m.dValue))) + ' ' + m.cMonth + ' ' + LTRIM(STR(YEAR(m.dValue)))
		        CASE 'MDY' $ m.cFormat
		          m.cDate = m.cMonth + ' ' + LTRIM(STR(DAY(m.dValue))) + ', ' + LTRIM(STR(YEAR(m.dValue)))
		        OTHERWISE
		          m.cDate = DTOC(m.dValue)
		      ENDCASE
		    ENDIF
		  ENDIF
		  RETURN m.cDate
		
	ENDPROC

	PROCEDURE Init
		*++
		*>>Initialize the tools object, and get a pointer to the registry.
		*--
		  THIS.AddProperty('aExceptions[1]')                && Array of Proper case exception words
		  THIS.AddProperty('aMonths[1]')
		  THIS.AddProperty('aShort[1]')
		  THIS.AddProperty('oRegistry', FindGlobalObject('cmRegistry'))
		
		  * Registry is optional. If not found, then initialize from internal defaults.
		  IF ISNULL(THIS.oRegistry)
		    THIS.RegistryUpdate
		  ELSE
		    THIS.oRegistry.RequestUpdateMessages(THIS)
		  ENDIF
		
	ENDPROC

	PROCEDURE loadmonthnames		&& Initialize month names for the current language.
		*++
		*>>Initialize month names for the current language.
		*--
		LOCAL ix, oMessage, cShortMonth, cLongMonth
		
		  IF EMPTY(THIS.aMonths[1]) OR ALEN(THIS.aMonths) < 12
		    DIMENSION THIS.aMonths[12], THIS.aShort[12]
		
		    * Get month name strings from current language, or use defaults if no message object.
		    m.oMessage = FindGlobalObject('cmMessage')
		    IF NOT ISNULL(m.oMessage)
		      m.cShortMonth = m.oMessage.cmLanguageValue.cShortMonth
		      m.cLongMonth = m.oMessage.cmLanguageValue.cLongMonth
		      FOR ix = 1 TO 12
		        THIS.aMonths[m.ix] = UPPER(GetToken(@m.cLongMonth, ','))
		        THIS.aShort[m.ix] = UPPER(GetToken(@m.cShortMonth, ','))
		      ENDFOR
		    ELSE
		      * Generate default month names from whatever names this version of VFP is using.
		      FOR ix = 1 TO 12
		        THIS.aMonths[m.ix] = UPPER(CMONTH(DATE(2000, m.ix, 1)))
		        THIS.aShort[m.ix] = LEFT(THIS.aMonths[m.ix], 3)
		      ENDFOR
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE matchwildcardc		&& Case-independent wildcard match.
		LPARAMETERS cSource, cExpression
		*++
		*>>Case-independent wildcard match.
		*--
		  RETURN LIKE(UPPER(m.cExpression), UPPER(m.cSource))
		
	ENDPROC

	PROCEDURE matchwildcardn		&& Case-independent normalized wildcard match.
		LPARAMETERS cSource, cExpression
		*++
		*>>Case-independent normalized wildcard match.
		*--
		  RETURN LIKE(UPPER(CHRTRAN(m.cExpression, ',. ', '')), UPPER(CHRTRAN(m.cSource, ',. ', '')))
		
	ENDPROC

	PROCEDURE monospacestring		&& Remove leading and trailing space/tabs from a string, and replace multiple embedded spaces/tabs with a single space.
		LPARAMETERS cInString
		*++
		*>>Remove leading and trailing space/tabs from a string, and replace multiple embedded spaces/tabs with a single space.
		*--
		LOCAL cOutString
		  m.cOutString = ALLTRIM(STRTRAN(m.cInString,CHR(9), ' '))
		
		  * Replace multiple spaces with a single space.
		  DO WHILE '  ' $ m.cOutString
		    m.cOutString = STRTRAN(m.cOutString,'  ', ' ')
		  ENDDO
		  RETURN m.cOutString
		
	ENDPROC

	PROCEDURE nearmatch		&& Match without regard to case, spacing or punctuation.
		LPARAMETERS cStr1, cStr2
		*++
		*>>Match without regard to case, spacing or punctuation.
		* Current state of SET EXACT affects outcome.
		*--
		  RETURN NormalizeString(m.cStr1) = NormalizeString(m.cStr2)
		
	ENDPROC

	PROCEDURE numtostring		&& Convert a numeric value to a byte-encoded string of the specified radix.
		LPARAMETERS nValue, nLength, nRadix
		*++
		*>>Convert a numeric value to a byte-encoded string of the specified radix.
		*
		* Supported radix ranges:
		*  10 = Standard decimal string
		*  11-36 = digits 0-9 and letters A-Z as needed
		*  37-62 = digits 0-9 and letters A-Z and a-z as needed
		*  63-95 = Character encoded, digits use characters ' ' thru '~' (Space is 0)
		*  96-256 = Binary encoded bytes, CHR(0) is 0
		*--
		LOCAL cResult, nDigit
		
		  IF EMPTY(m.nRadix)
		    m.nRadix = 10
		  ENDIF
		
		  * Convert value to appropriate string format for caller
		  m.cResult = ''
		  DO CASE
		    CASE m.nRadix = 10
		      m.cResult = PADL(RIGHT(LTRIM(STR(m.nValue, 15)), m.nLength), m.nLength, '0')
		
		    CASE m.nRadix > 10 AND m.nRadix <= 36
		      DO WHILE m.nValue > 0
		        m.nDigit = m.nValue % m.nRadix
		        m.nValue = m.nValue / m.nRadix
		        m.cResult = IIF(m.nDigit < 10, CHR(ASC('0') + m.nDigit), CHR(ASC('A') + m.nDigit-10) ) + m.cResult
		      ENDDO
		      m.cResult = PADL(RIGHT(m.cResult, m.nLength), m.nLength, '0')
		
		    CASE m.nRadix > 36 AND m.nRadix <= 62
		      DO WHILE m.nValue > 0
		        m.nDigit = m.nValue % m.nRadix
		        m.nValue = m.nValue / m.nRadix
		        m.cResult = IIF(m.nDigit < 10, CHR(ASC('0') + m.nDigit), IIF(m.nDigit < 36, CHR(ASC('A') + m.nDigit-10), CHR(ASC('a') + m.nDigit-36)) ) + m.cResult
		      ENDDO
		      m.cResult = PADL(RIGHT(m.cResult, m.nLength), m.nLength, '0')
		
		    CASE m.nRadix > 62 AND m.nRadix <= 95
		      DO WHILE m.nValue > 0
		        m.cResult = CHR(ASC(' ') + m.nValue % m.nRadix) + m.cResult
		        m.nValue = m.nValue / m.nRadix
		      ENDDO
		      m.cResult = PADL(RIGHT(m.cResult, m.nLength), m.nLength, ' ')
		
		    CASE m.nRadix > 95 AND m.nRadix <= 256
		      * Generic binary byte encoding, usualy base 256
		      DO WHILE m.nValue > 0
		        m.cResult = CHR(m.nValue % m.nRadix) + m.cResult
		        m.nValue = m.nValue / m.nRadix
		      ENDDO
		      m.cResult = PADL(RIGHT(m.cResult, m.nLength), m.nLength, CHR(0))
		
		    OTHERWISE
		      ERROR 'Invalid Radix'
		  ENDCASE
		  RETURN m.cResult
		
	ENDPROC

	PROCEDURE parsedate		&& Parse a freeform string date in the current language.
		LPARAMETERS cDate, cDefaultMethod, nDefaultDay
		*++
		*>>Parse a freeform string date in the current language.
		* Supported date formats are: 
		*   nn/nn/nn  (current SET DATE order)
		*   Month dd, ccyy
		*      dd Month, ccyy
		*   Month ccyy
		*      mm/ccyy
		*
		* Return .NULL. on parse errors
		*--
		LOCAL cToken, dDate, nYear, nMonth, nDay, lExact, cCmd, cDateType, nStrict
		
		  * Assign default values to optional parameters
		  IF EMPTY(m.cDefaultMethod)
		    m.cDefaultMethod = 'Rollover'
		  ENDIF
		  IF EMPTY(m.nDefaultDay)
		    m.nDefaultDay = 1
		  ENDIF
		
		  * Process empty & NULL date values first
		  IF ISNULL(m.cDate)
		    RETURN .NULL.
		  ENDIF
		  
		  IF VARTYPE(m.cDate) = 'D'
		     m.cDate = DTOC(m.cDate)
		  ENDIF 
		  m.cDate = ALLTRIM(UPPER(CHRTRAN(m.cDate, ',-.', '///')))
		  IF EMPTY(STRTRAN(m.cDate, '/', ''))
		    RETURN {}
		  ENDIF
		  THIS.LoadMonthNames()
		
		  * Test results of CTOD to determine date order in effect. This allows correct
		  * detection when SET DATE SHORT or LONG is in effect. Use macro so STRICTDATE = 2
		  * wont complain about this, since we are explicitly testing the ambiguous date format.
		  m.nStrict = SET('STRICT')
		  SET STRICTDATE TO 0
		  m.cCmd = 'm.dDate = CTOD("1/2/3")'
		  &cCmd
		  DO CASE
		    CASE DAY(m.dDate) = 1
		      m.cDateType = 'DMY'
		    CASE DAY(m.dDate) = 2
		      m.cDateType = 'MDY'
		    CASE DAY(m.dDate) = 3
		      m.cDateType = 'YMD'
		  ENDCASE
		
		  * Use macro so STRICTDATE set to 2 won't complain about this.
		  m.cCmd = 'm.dDate = CTOD(m.cDate)'
		  &cCmd
		  SET STRICTDATE TO (m.nStrict)
		  
		  * If Foxpro could parse the date, it is a numeric-only format.
		  * Process it according to the current SET DATE setting in effect.
		  IF OCCURS('/', m.cDate) = 2 AND NOT EMPTY(m.dDate)
		    IF m.cDateType = 'YMD'    && Year is first
		      m.nYear = VAL(m.cDate)
		    ELSE
		      FOR ix = LEN(m.cDate) TO 1 STEP -1
		        IF ASC(SUBSTR(m.cDate, m.ix, 1)) < ASC('0')
		          EXIT
		        ENDIF
		      ENDFOR
		      m.nYear = VAL(SUBSTR(m.cDate, MIN(LEN(m.cDate), m.ix + 1)))
		    ENDIF
		    m.nDay = DAY(m.dDate)
		    m.nMonth = MONTH(m.dDate)
		  ELSE
		    m.cDate = CHRTRAN(m.cDate, '/', ' ')
		    m.cToken1 = GetToken(@m.cDate)
		    m.cToken2 = GetToken(@m.cDate)
		    m.cToken3 = ALLTRIM(m.cDate)
		
		    DO CASE
		      CASE EMPTY(m.cToken3)     && Month/Year format
		        IF EMPTY(m.nDefaultDay) && If empty, day must be specified
		          RETURN .NULL.
		        ENDIF
		        m.nMonth = IIF(ISDIGIT(m.cToken1), VAL(m.cToken1), ASCAN(THIS.aMonths, m.cToken1))
		        m.nYear = IIF(TYPE(m.cToken2) = 'N', VAL(m.cToken2), -1)
		
		        * nDefaultDay of -1 means last day of month. Select 1st of next month, then back up 1 day.
		        m.nDay = IIF(m.nDefaultDay > 0, m.nDefaultDay, 1)
		        IF m.nDefaultDay < 0 AND m.nMonth > 0
		          m.nMonth = m.nMonth + 1
		          IF m.nMonth = 13
		            m.nMonth = 1
		            m.nYear = m.nYear + 1
		          ENDIF
		        ENDIF
		      CASE ISDIGIT(m.cToken1)
		        m.nDefaultDay = 0
		        m.nDay = VAL(m.cToken1)
		        m.nMonth = ASCAN(THIS.aMonths, m.cToken2)
		        m.nYear = IIF(TYPE(m.cToken3) = 'N', VAL(m.cToken3), -1)
		      OTHERWISE
		        m.lExact = SET('EXACT') == 'ON'
		        SET EXACT OFF    && For correct operation of ASCAN()
		        m.nDefaultDay = 0
		        m.nDay = VAL(m.cToken2)
		        m.nMonth = IIF(LEN(m.cToken1) < 3, 0, ASCAN(THIS.aMonths, m.cToken1))
		        m.nYear = IIF(TYPE(m.cToken3) = 'N', VAL(m.cToken3), -1)
		        IF m.lExact
		          SET EXACT ON
		        ENDIF
		    ENDCASE
		  ENDIF
		
		  * Return .NULL. on parse errors
		  IF EMPTY(m.nMonth) OR m.nYear < 0
		    RETURN .NULL.
		  ENDIF
		  m.nYear = THIS.DefaultCentury(m.nYear, m.nMonth, m.nDay, m.cDefaultMethod)
		  m.dDate = DATE(m.nYear, m.nMonth, m.nDay)
		  IF m.nDefaultDay < 0 AND NOT EMPTY(m.dDate)
		    m.dDate = m.dDate - 1
		  ENDIF
		  RETURN IIF(EMPTY(m.dDate), .NULL., m.dDate)
		
	ENDPROC

	PROCEDURE propercase		&& Method to properly capitalize proper name strings.
		LPARAMETERS cInString
		*++
		*>>Method to properly capitalize proper name strings.
		*
		*     The rules are:
		*       1. Change each word only if the first character is a lower case letter.
		*       If initial char is uppercase, we assume the user entered capitalization 
		*       the way they wanted it. A word in a proper name should "never" start with
		*       lower case, so that's our cue to go to work. IF THIS.lStopAfterFirst is
		*       set .T., then we stop if first word is caps, else we treat each word 
		*       individualy.
		*       2. Recognize word breaks on certain punctuation characters.
		*    3. Apply exceptions contained in exceptions registry entry.
		*--
		LOCAL char, ix, ix2, cOutString, nStartWord, nWords, cWord
		
		  m.nWords = 0
		  m.nStartWord = 1
		  m.cOutString = THIS.MonoSpaceString(m.cInString) + CHR(0)
		
		  FOR ix = 1 to LEN(m.cOutString)
		    m.char = SUBSTR(m.cOutString, m.ix, 1)
		
		    IF m.char $ THIS.cDelimiters
		      m.cWord = SUBSTR(m.cOutString, m.nStartWord, m.ix - m.nStartWord)
		
		      IF ISALPHA(m.cWord)
		        m.nWords = m.nWords + 1
		      ENDIF
		
		      IF THIS.lStopAfterFirst AND ISUPPER(m.cWord) AND m.nWords = 1
		        EXIT
		      ENDIF
		
		      IF ISLOWER(m.cWord)
		        * Found a word starting with lower case - fix it up.
		        m.cWord = PROPER(m.cWord)
		
		        * Apply exceptions from list.
		        FOR m.ix2 = 1 TO ALEN(THIS.aExceptions,1)
		          IF RIGHT(THIS.aExceptions[m.ix2], 1) = '*'
		            m.cException = STRTRAN(THIS.aExceptions[m.ix2], '*', '')
		            IF LEFT(m.cWord, LEN(m.cException)) == PROPER(m.cException)
		              m.cWord = m.cException + IIF(LEN(m.cWord) > LEN(m.cException), ;
		                                  PROPER(SUBSTR(m.cWord, LEN(m.cException) + 1)), '')
		              EXIT
		            ENDIF
		          ELSE
		            IF m.cWord == PROPER(THIS.aExceptions[m.ix2])
		              * Don't apply lower case exceptions if first word of sentence.
		              IF ISUPPER(THIS.aExceptions[m.ix2]) OR m.nWords > 1
		                m.cWord = THIS.aExceptions[m.ix2]
		              ENDIF
		              EXIT
		            ENDIF
		          ENDIF
		        ENDFOR
		
		        * Put fixed up word back in output string.
		        m.cOutString = STUFF(m.cOutString, m.nStartWord, m.ix - m.nStartWord, m.cWord)
		      ENDIF
		
		      m.nStartWord = m.ix + 1
		    ENDIF
		  ENDFOR
		  RETURN LEFT(m.cOutString, LEN(m.cOutString) - 1)
		
	ENDPROC

	PROCEDURE registryupdate		&& Called on initialization and whenever the registry database is updated.
		*++
		*>>Called on initialization and whenever the registry database is updated.
		*--
		LOCAL cValue
		
		  * Cannot pass properties by reference, so use an intermediate local variable.
		  * If value from registry is NULL (not found) then leave original values unchanged.
		  IF ISNULL(THIS.oRegistry)
		    m.cValue = THIS.cCaseExceptions
		  ELSE
		    m.cValue = THIS.oRegistry.GetKeyValue(KEYNAME_CASE_EXCEPTIONS, KEY_TYPE_CHAR, THIS.cCaseExceptions)
		    THIS.lStopAfterFirst = THIS.oRegistry.GetKeyValue(KEYNAME_CASE_STOPONUPPER, KEY_TYPE_LOGICAL, THIS.lStopAfterFirst)
		    THIS.cDelimiters = CHR(0) + THIS.oRegistry.GetKeyValue(KEYNAME_CASE_DELIMITERS, KEY_TYPE_CHAR, THIS.cDelimiters)
		  ENDIF
		  THIS.StringToArray(m.cValue, THIS, 'aExceptions')
		
	ENDPROC

	PROCEDURE release
		*++
		*>>Cancel registry update requests and release ourself.
		*--
		  IF NOT ISNULL(THIS.oRegistry)
		    THIS.oRegistry.CancelUpdateMessages(THIS)
		  ENDIF
		  THIS.oRegistry = .NULL.
		  RELEASE THIS
		
	ENDPROC

	PROCEDURE stringtoarray		&& Convert comma seperated list of items into an array, one item per row.
		LPARAMETERS cString, uObject, cArrayName
		*++
		*>>Convert comma seperated list of items into an array, one item per row.
		* Since object properties cannot be passed as an array, if the destination array is
		* a property, we accept it as an object reference and string name, and use macro 
		* expansion to reference the array.
		*--
		LOCAL nIndex, cItem, nItems
		  m.nItems = OCCURS(',', m.cString) + 1
		  IF TYPE('m.uObject') = 'O' AND TYPE('m.cArrayName') = 'C'
		    LOCAL cArrayProperty , aTemp[m.nItems]
		    FOR nIndex = 1 TO m.nItems
		      aTemp[m.nIndex] = GetToken(@cString, ',')
		    ENDFOR
		    m.cArrayProperty = 'm.uObject.' + cArrayName
		
		    * Copy temporary array to final destination.
		    DIMENSION &cArrayProperty[m.nItems]
		    =ACOPY(aTemp,&cArrayProperty)
		  ELSE
		    DIMENSION uObject[m.nItems]
		    FOR nIndex = 1 TO m.nItems
		      uObject[m.nIndex] = GetToken(@m.cString, ',')
		    ENDFOR
		  ENDIF
		  RETURN m.nItems
		
	ENDPROC

	PROCEDURE stringtodate		&& Convert a universal date string to VFP internal date format.
		LPARAMETERS cDate
		*++
		*>>Convert a universal date string to VFP internal date format.
		* This is the reverse of the DTOS() function.
		*++
		LOCAL dDate
		  IF VARTYPE(m.cDate) = 'C' AND LEN(m.cDate) >= 8 AND NOT EMPTY(m.cDate)
		    m.dDate = DATE(VAL(LEFT(m.cDate,4)), VAL(SUBSTR(m.cDate,5,2)), VAL(SUBSTR(m.cDate,7,2)))
		  ELSE
		    m.dDate = {}
		  ENDIF
		  RETURN m.dDate
		
	ENDPROC

	PROCEDURE stringtonum		&& Convert byte encoded value from string format back to numeric.
		LPARAMETERS cValue, nRadix
		*++
		*>>Convert byte encoded value from string format back to numeric.
		* Same special encoding methods as NumToString() are used.
		*--
		LOCAL ix, nValue, cDigit
		
		  IF EMPTY(m.nRadix)
		    m.nRadix = 10
		  ENDIF
		
		  m.nValue = 0
		  DO CASE
		    CASE m.nRadix = 10
		      m.nValue = VAL(m.cValue)
		
		    CASE m.nRadix > 10 AND m.nRadix <= 36
		      m.cValue = ALLTRIM(m.cValue)
		      FOR ix = 1 TO LEN(m.cValue)
		        m.cDigit = UPPER(SUBSTR(m.cValue, m.ix, 1))
		        m.nValue = m.nValue * m.nRadix + (ASC(m.cDigit) - IIF(m.cDigit <= '9', ASC('0'), ASC('A') - 10))
		      ENDFOR
		
		    CASE m.nRadix > 36 AND m.nRadix <= 62
		      m.cValue = ALLTRIM(m.cValue)
		      FOR ix = 1 TO LEN(m.cValue)
		        m.cDigit = SUBSTR(m.cValue, m.ix, 1)
		        m.nValue = m.nValue * m.nRadix + (ASC(m.cDigit) ;
		                 - IIF(m.cDigit <= '9', ASC('0'), IIF(m.cDigit > 'Z', ASC('a') - 36, ASC('A') - 10)))
		      ENDFOR
		
		    CASE m.nRadix > 62 AND m.nRadix <= 95
		      FOR ix = 1 TO LEN(m.cValue)
		        m.cDigit = SUBSTR(m.cValue, m.ix, 1)
		        m.nValue = m.nValue * m.nRadix + (ASC(m.cDigit) - ASC(' '))
		      ENDFOR
		
		    CASE m.nRadix > 95 AND m.nRadix <= 256
		      FOR ix = 1 TO LEN(m.cValue)
		        m.cDigit = SUBSTR(m.cValue, m.ix, 1)
		        m.nValue = m.nValue * m.nRadix + ASC(m.cDigit)
		      ENDFOR
		  ENDCASE
		  RETURN m.nValue
		
	ENDPROC

	PROCEDURE stringtotime		&& Convert a universal date/time string to VFP internal time format.
		LPARAMETERS cTime
		*++
		*>>Convert a universal date/time string to VFP internal time format.
		* This is the reverse of the TTOC() function.
		*++
		LOCAL tTime
		  IF VARTYPE(m.cTime) = 'C' AND LEN(m.cTime) >= 14 AND NOT EMPTY(STRTRAN(m.cTime, '0', ''))
		    m.tTime = DATETIME(VAL(LEFT(m.cTime,4)), VAL(SUBSTR(m.cTime,5,2)), VAL(SUBSTR(m.cTime,7,2)), ;
		                       VAL(SUBSTR(m.cTime,9,2)), VAL(SUBSTR(m.cTime,11,2)), VAL(SUBSTR(m.cTime,13,2)))
		  ELSE
		    m.tTime = {//::}
		  ENDIF
		  RETURN m.tTime
		
	ENDPROC

	PROCEDURE valuetochar		&& Convert any type variable to a character format representation.
		LPARAMETERS uValue, lQuote
		*++
		*>>Convert any type variable to a character format representation.
		*--
		LOCAL cType
		
		  m.cType = VARTYPE(m.uValue, .T.)
		  DO CASE
		    CASE ISNULL(m.uValue)
		      RETURN '.NULL.'
		    CASE m.cType = 'C' OR m.cType = 'M'
		      RETURN IIF(m.lQuote, THIS.AddQuotes(m.uValue), m.uValue)
		    CASE m.cType = 'N' OR m.cType = 'Y'
		      IF m.uValue % 1 = 0
		        RETURN LTRIM(STR(m.uValue))
		      ELSE
		        RETURN LTRIM(STR(m.uValue, 15, 5))
		      ENDIF
		    CASE m.cType = 'L'
		      RETURN IIF(m.uValue, '.T.', '.F.')
		    CASE m.cType = 'D'
		      RETURN IIF(m.lQuote, '{' + DTOC(m.uValue) + '}', DTOS(m.uValue))
		    CASE m.cType = 'T'
		      RETURN IIF(m.lQuote, '{' + TTOC(m.uValue) + '}', TTOC(m.uValue, 1))
		    CASE m.cType = 'O'
		      RETURN '<Object: ' + m.uValue.Name + '>'
		    CASE m.cType = 'G'
		      RETURN '<General>'
		  ENDCASE
		  RETURN '??Unknown??'
		
	ENDPROC

ENDDEFINE
