*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmdataa.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cmconnectionabstract AS cmdataabstract OF "cmdataa.vcx" 		&& Codemine Remote Data Connection class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_Connection.bmp" ClassIcon="..\graphics\_Connection.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: begintrans		&& Begin a new transaction on the connection.
		*m: close		&& Close an open connection.
		*m: committrans		&& Commit the current transaction.
		*m: execute		&& Execute the specified SQL statement on the connection.
		*m: getprop		&& Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		*m: nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*m: nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		*m: open		&& Open the connection.
		*m: rollbacktrans		&& Roll back the current transaction.
		*m: setprop		&& Set connection properties, using the same property names as the VFP SQLSETPROP() function.
		*p: cclass
		*p: csharename		&& Connection name (or string) used to compare against for connection sharing.
		*p: ctype		&& Connection Type: VFP or ADO
		*p: nconnid		&& Internal connection ID assigned to this connection
		*p: nusecount		&& Number of cursors currently using this connection. Connection is usually closed when this count reaches zero.
	*</DefinedPropArrayMethod>

	cclass = cmConnection
	csharename = 		&& Connection name (or string) used to compare against for connection sharing.
	ctype = 		&& Connection Type: VFP or ADO
	Name = "cmconnectionabstract"
	nconnid = 0		&& Internal connection ID assigned to this connection
	nusecount = 0		&& Number of cursors currently using this connection. Connection is usually closed when this count reaches zero.
	
	PROCEDURE begintrans		&& Begin a new transaction on the connection.
		*++
		*>>Begin a new transaction on the connection.
		*--
		
	ENDPROC

	PROCEDURE close		&& Close an open connection.
		*++
		*>>Close an open connection.
		*--
		
	ENDPROC

	PROCEDURE committrans		&& Commit the current transaction.
		*++
		*>>Commit the current transaction.
		*--
		
	ENDPROC

	PROCEDURE execute		&& Execute the specified SQL statement on the connection.
		LPARAMETERS cSql
		*++
		*>>Execute the specified SQL statement on the connection.
		*--
		
	ENDPROC

	PROCEDURE getprop		&& Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		LPARAMETERS cProperty
		*++
		*>>Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		*--
		
	ENDPROC

	PROCEDURE init
		LPARAMETERS cString, cUsername, cPassword
		  DODEFAULT()
		  IF NOT EMPTY(m.cString)
		    THIS.Open(@m.cString, @m.cUsername, @m.cPassword)
		  ENDIF
		
	ENDPROC

	PROCEDURE nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*++
		*>>Return the nErrorMode value from the highest level available container.
		*--
		  * Connection object uses the Conenction Manager's property, when available.
		  IF TYPE('THIS.Parent.nErrorMode') = 'N'
		    RETURN THIS.Parent.nErrorMode
		  ELSE
		    RETURN THIS.nErrorMode
		  ENDIF
		
	ENDPROC

	PROCEDURE nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		LPARAMETERS nValue
		*++
		*>>Set the nErrorMode property in the highest level available container.
		*--
		  * Connection object uses the Conenction Manager's property, when available.
		  IF TYPE('THIS.Parent.nErrorMode') = 'N'
		    THIS.Parent.nErrorMode = m.nValue
		  ELSE
		    THIS.nErrorMode = m.nValue
		  ENDIF
		
	ENDPROC

	PROCEDURE open		&& Open the connection.
		LPARAMETERS cString, cUsername, cPassword
		*++
		*>>Open the connection.
		*--
		
	ENDPROC

	PROCEDURE rollbacktrans		&& Roll back the current transaction.
		*++
		*>>Roll back the current transaction.
		*--
		
	ENDPROC

	PROCEDURE setprop		&& Set connection properties, using the same property names as the VFP SQLSETPROP() function.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set connection properties, using the same property names as the VFP SQLSETPROP() function.
		*--
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmconnectionmanager AS cmdataabstract OF "..\common\cmdataa.vcx" 		&& Codemine Remote Data Connection and Transaction management class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_ConnManager.bmp" ClassIcon="..\graphics\_ConnManager.bmp" />

	#INCLUDE "datadefs.h"
	*<DefinedPropArrayMethod>
		*m: addconnection		&& Add an existing VFP connection handle to the pool of managed connections. Typically used to add connections opened by VFP remote views.
		*m: begintrans		&& Start a transaction. If nConnection parameter is specified, add it to list of connections with outstanding remote transactions at the current level.
		*m: committrans		&& End the current transaction level by committing changes.
		*m: connect		&& Return a Codemine Connection ID to a new or existing instance of the specified connection.
		*m: disconnect		&& Decrement use count of the specified connection, and close it when count reaches 0.
		*m: execute		&& Execute the specified SQL statement on the Specifed connection.
		*m: getprop		&& Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		*m: inspectordetails		&& Display object-specific debugging information in the Codemine object inspector.
		*m: nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*m: nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		*m: rollbacktrans		&& Abort the current VFP level transaction.
		*m: setprop		&& Set connection properties, using the same property names as the VFP SQLGETPROP() function.
		*m: _addconnection		&& Internal method to add a connection to our collection of managed connection objects.
		*m: _getconn		&& Return object reference to the connection object identified by nConnID.
		*m: _removeconnection		&& Remove the specified connection object.
		*p: cclass		&& Foundation class name for this class. Do not change this value in any subclass.
		*p: lglobalshare		&& If .T. shared connections can be shared accross Data Sessions. If .F. they are only shared among clients in the same Data Session.
		*p: ntransactionmode		&& 0 = No Transactions, 1 = Remote Transactions Only, 3 = Remote and local transaction as needed (default).
	*</DefinedPropArrayMethod>

	backcolor = 192,255,255
	cclass = cmConnectionManager		&& Foundation class name for this class. Do not change this value in any subclass.
	height = 22
	lglobalshare = .T.		&& If .T. shared connections can be shared accross Data Sessions. If .F. they are only shared among clients in the same Data Session.
	Name = "cmconnectionmanager"
	ntransactionmode = 3		&& 0 = No Transactions, 1 = Remote Transactions Only, 3 = Remote and local transaction as needed (default).
	width = 36
	
	PROCEDURE addconnection		&& Add an existing VFP connection handle to the pool of managed connections. Typically used to add connections opened by VFP remote views.
		LPARAMETERS cConnection, lShared, nVFPhandle
		*++
		*>>Add an existing VFP connection handle to the pool of managed connections. Typically used to add connections opened by VFP remote views.
		*--
		LOCAL ix, oConn, cShareName
		
		  * If a shared connection, look for existing one of same name and type.
		  * Use a separate suffix for View connections, so SQLPT cursors will not share them.
		  * Need to enhance ConnMan to share PT connections across data sessions to share with view connections.
		  m.cShareName = PROPER(ALLTRIM(m.cConnection)) + '.VFP.view'
		  IF m.lShared
		    FOR EACH oConn IN THIS.Controls
		      * Even if the view is marked to share connections, it may not have been able to.
		      * So, we need to also test that the VFP connection handle is the same as the 
		      * existing connection before we can consider it a match.
		      IF m.oConn.cShareName == m.cShareName AND m.oConn.nVFPhandle = m.nVFPhandle
		        * Increment reference count, and return index of existing connection.
		        m.oConn.Open()
		        RETURN m.oConn.nConnID
		      ENDIF
		    ENDFOR
		  ELSE
		    * Add a suffix to non-shared connection names, so it wont match original name.
		    m.cShareName = m.cShareName + '.Private'
		  ENDIF
		
		  * Create a new connection object, and bind it to the VFP connection handle.
		  m.oConn = THIS._AddConnection(m.cShareName, 'cmConnectionVFP')
		  WITH m.oConn
		    .Open()                && Open with no parameters simply increments use count.
		    .nVFPhandle = m.nVFPhandle
		    .lNoDisconnect = .T.   && Opened by a view, so let view disconnect it.
		    RETURN .nConnID
		  ENDWITH
		
	ENDPROC

	PROCEDURE begintrans		&& Start a transaction. If nConnection parameter is specified, add it to list of connections with outstanding remote transactions at the current level.
		LPARAMETERS nConnId, nFlags
		*++
		*>>Start a transaction. If nConnection parameter is specified, add it to list of connections with outstanding remote transactions at the current level.
		* 
		* If nFlags TRANMASK_FORCENEW is true, an actual nested tranaction level will be started. Otherwise, 
		* the connection will be added to the list of connections involved with the current 
		* transaction level.
		*
		* If no remote connection is involved, pass a 0 for the value of nConnId.
		*--
		LOCAL oConn
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF THIS.nTransactionMode > 0
		    THIS.nMergelevel = THIS.nMergelevel + 1
		    IF (THIS.nTranLevel = 0 OR NOT EMPTY(BITAND(m.nFlags, TRANMASK_FORCENEW)))
		      THIS.nTranLevel = THIS.nTranLevel + 1
		      DIMENSION THIS.aRemoteTransactions[THIS.nTranLevel, 2]
		      THIS.aRemoteTransactions[THIS.nTranLevel, 1] = ''
		      THIS.aRemoteTransactions[THIS.nTranLevel, 2] = THIS.nMergelevel
		
		      IF THIS.nTransactionMode >= 2 AND EMPTY(BITAND(m.nFlags, TRANMASK_REMOTEONLY))
		        BEGIN TRANSACTION
		        THIS.aRemoteTransactions[THIS.nTranLevel, 1] = CHR(0)
		      ENDIF
		    ENDIF
		
		    * If nConnId parameter is specified add it to list 
		    * of connections with outstanding remote transactions at this level.
		    IF NOT EMPTY(m.nConnId) AND NOT CHR(m.nConnId) $ THIS.aRemoteTransactions[THIS.nTranLevel,1]
		      THIS.aRemoteTransactions[THIS.nTranLevel,1] = THIS.aRemoteTransactions[THIS.nTranLevel,1] + CHR(m.nConnId)
		
		      m.oConn = THIS._GetConn(m.nConnID)
		      IF NOT m.oConn.BeginTrans()
		        RETURN .F.   && Error message will already have been stored/displayed, if appropriate
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE committrans		&& End the current transaction level by committing changes.
		*++
		*>>End the current transaction level by committing changes.
		*--
		LOCAL ix, oConn, nConnId, cConnList
		
		  IF (THIS.nMergelevel > 0)
		    IF (THIS.aRemoteTransactions[THIS.nTranLevel, 2] == THIS.nMergelevel)
		      * End the transaction on each remote connection that was part of this level.
		      m.cConnList = THIS.aRemoteTransactions[THIS.nTranLevel, 1]
		      FOR ix = 1 TO LEN(m.cConnList)
		        m.nConnId = ASC(SUBSTR(m.cConnList, m.ix, 1))
		        IF m.nConnId > 0
		          m.oConn = THIS._GetConn(m.nConnID)
		          IF NOT ISNULL(m.oConn) AND NOT m.oConn.CommitTrans()
		            RETURN .F.  && Error message will already have been stored/displayed, if appropriate
		          ENDIF
		        ENDIF
		      ENDFOR
		
		      * End VFP transaction and Force to disk, for increased reliability with native tables.
		      IF LEFT(m.cConnList, 1) == CHR(0)
		        END TRANSACTION
		        FLUSH   && Helps prevent memo damage during system crashes
		      ENDIF
		      THIS.nTranLevel = THIS.nTranLevel - 1
		    ENDIF
		    THIS.nMergelevel = THIS.nMergelevel - 1
		  ENDIF
		
	ENDPROC

	PROCEDURE connect		&& Return a Codemine Connection ID to a new or existing instance of the specified connection.
		LPARAMETERS cConnection, lShared, cType
		*++
		*>>Return a Codemine Connection ID to a new or existing instance of the specified connection.
		*
		* cType - Parameter can be "VFP" or "ADO"
		*--
		LOCAL ix, oConn, cShareName
		
		  IF EMPTY(m.cType)    && Default to a native VFP connection type
		    m.cType = 'VFP'
		  ENDIF
		
		  * If a shared connection, look for existing one of same name and type.
		  m.cShareName = PROPER(ALLTRIM(m.cConnection)) + '.' + UPPER(ALLTRIM(m.cType))
		
		  * If not sharing globally, append a data-session suffix.
		  IF NOT THIS.lGlobalShare
		    m.cShareName = m.cShareName + '.' + LTRIM(STR(SET('DataSesion')))
		  ENDIF
		  IF m.lShared
		    FOR EACH oConn IN THIS.Controls
		      IF m.oConn.cShareName == m.cShareName
		        * Increment reference count, and return index of existing connection.
		        m.oConn.Open()
		        RETURN m.oConn.nConnID
		      ENDIF
		    ENDFOR
		  ELSE
		    * Add a suffix to non-shared connection names, so it wont match original name.
		    m.cShareName = m.cShareName + '.Private'
		  ENDIF
		
		  * Create a new connection if no existing connection was found.
		  m.oConn = THIS._AddConnection(m.cShareName, 'cmConnection' + m.cType)
		  IF m.oConn.Open(m.cConnection)
		    RETURN m.oConn.nConnID
		  ENDIF
		
		  * Error opening connection. Remove it from our collection and return 0.
		  THIS._RemoveConnection(m.oConn)
		  RETURN 0
		
	ENDPROC

	PROCEDURE destroy
		  * If (due to an error/cancel) we are destroyed with outstanding transactions, roll them back.
		  DO WHILE THIS.nTranLevel > 0
		    THIS.RollbackTrans()
		  ENDDO
		
	ENDPROC

	PROCEDURE disconnect		&& Decrement use count of the specified connection, and close it when count reaches 0.
		LPARAMETERS nConnId
		*++
		*>>Decrement use count of the specified connection, and close it when count reaches 0.
		*--
		LOCAL oConn
		  m.oConn = THIS._GetConn(m.nConnID)
		
		  * Close the connection (or decrement use count). Returns T when use count is 0.
		  IF NOT ISNULL(m.oConn) AND m.oConn.Close()
		    THIS._RemoveConnection(m.oConn)
		  ENDIF
		
	ENDPROC

	PROCEDURE execute		&& Execute the specified SQL statement on the Specifed connection.
		LPARAMETERS nConnId, cSql, cResultCursor
		*++
		*>>Execute the specified SQL statement on the Specifed connection.
		*--
		LOCAL oCursor, uResult, oConn
		
		  * Return discrete value only if no result output cursor specified.
		  m.oConn = THIS._GetConn(m.nConnID)
		  IF EMPTY(m.cResultCursor)
		    RETURN m.oConn.Execute(@m.cSql)
		  ENDIF
		
		  * Return cursor object for result recordset, which may be a VFP cursor, or ADO recordset.
		  m.uResult = m.oConn.Execute(@m.cSql, m.cResultCursor)
		  IF NOT ISNULL(m.uResult)
		    m.oCursor = CreateNewObject('cmCursor')
		    m.oCursor.BindToRecordSet(m.uResult)
		    RETURN m.oCursor
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE getprop		&& Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		LPARAMETERS nConnId, cProperty
		*++
		*>>Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		*--
		LOCAL oConn
		  m.oConn = THIS._GetConn(m.nConnID)
		  RETURN m.oConn.GetProp(PROPER(m.cProperty))
		
	ENDPROC

	PROCEDURE init
		  DODEFAULT()
		
		  THIS.AddProperty('nConnections', 0)
		  THIS.AddProperty('aRemoteTransactions[1,2]')
		  THIS.AddProperty('nTranLevel', 0)
		  THIS.AddProperty('nMergelevel', 0)
		  THIS.AddProperty('nFirstFreeConnID', 1)
		
	ENDPROC

	PROCEDURE inspectordetails		&& Display object-specific debugging information in the Codemine object inspector.
		LPARAMETERS oNodes, cRoot
		*++
		*>>Display object-specific debugging information in the Codemine object inspector.
		*--
		LOCAL cDetail, oConn
		
		  m.oNodes.Add(m.cRoot, 4, 'ConnMan', 'Managed Connections')
		  FOR EACH oConn IN THIS.Controls
		    WITH m.oConn
		      m.cDetail = 'Connection' + LTRIM(STR(.nConnID))
		      m.oNodes.Add('ConnMan', 4, m.cDetail, '(' + LTRIM(STR(.nConnID)) + ') ' + .cShareName )
		      m.oNodes.Add(m.cDetail, 4, , 'Use Count = ' + LTRIM(STR(.nUseCount)))
		      IF PEMSTATUS(m.oConn, 'nVFPhandle', 5)
		        m.oNodes.Add(m.cDetail, 4, , 'VFP Handle = ' + LTRIM(STR(.nVFPhandle)))
		      ENDIF
		    ENDWITH
		  ENDFOR
		
	ENDPROC

	PROCEDURE nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*++
		*>>Return the nErrorMode value from the highest level available container.
		*--
		  * Connection Manager uses the parent CDE value, when available.
		  IF TYPE('THIS.Parent.nErrorMode') = 'N'
		    RETURN THIS.Parent.nErrorMode
		  ELSE
		    RETURN THIS.nErrorMode
		  ENDIF
		
	ENDPROC

	PROCEDURE nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		LPARAMETERS nValue
		*++
		*>>Set the nErrorMode property in the highest level available container.
		*--
		  * Connection Manager uses the parent CDE value, when available.
		  IF TYPE('THIS.Parent.nErrorMode') = 'N'
		    THIS.Parent.nErrorMode = m.nValue
		  ELSE
		    THIS.nErrorMode = m.nValue
		  ENDIF
		
	ENDPROC

	PROCEDURE rollbacktrans		&& Abort the current VFP level transaction.
		*++
		*>>Abort the current VFP level transaction.
		*--
		LOCAL ix, oConn, nConnId, cConnList
		
		  IF (THIS.nMergelevel > 0)
		    IF (THIS.aRemoteTransactions[THIS.nTranLevel, 2] == THIS.nMergelevel)
		
		      * Roll back the transaction on each remote connection that was part of this level.
		      m.cConnList = THIS.aRemoteTransactions[THIS.nTranLevel, 1]
		      FOR ix = 1 TO LEN(m.cConnList)
		        m.nConnId = ASC(SUBSTR(m.cConnList, m.ix, 1))
		        IF m.nConnId > 0
		          m.oConn = THIS._GetConn(m.nConnID)
		          m.oConn.RollbackTrans()
		        ENDIF
		      ENDFOR
		      IF LEFT(m.cConnList, 1) == CHR(0)
		        ROLLBACK   && Rollback the VFP level transaction as well
		      ENDIF
		      THIS.nTranLevel = THIS.nTranLevel - 1
		    ENDIF
		    THIS.nMergelevel = THIS.nMergelevel - 1
		  ENDIF
		
	ENDPROC

	PROCEDURE setprop		&& Set connection properties, using the same property names as the VFP SQLGETPROP() function.
		LPARAMETERS nConnId, cProperty, uValue
		*++
		*>>Set connection properties, using the same property names as the VFP SQLGETPROP() function.
		*--
		LOCAL oConn
		  m.oConn = THIS._GetConn(m.nConnID)
		  RETURN m.oConn.SetProp(PROPER(m.cProperty), m.uValue)
		
	ENDPROC

	PROCEDURE _addconnection		&& Internal method to add a connection to our collection of managed connection objects.
		LPARAMETERS cShareName, cClass
		*++
		*>>Internal method to add a connection to our collection of managed connection objects.
		* Returns object reference to the newly added connection.
		*--
		LOCAL ix, cObjName, oConn
		
		  FOR ix = THIS.nFirstFreeConnID TO 255   && We only support up to 255 connections.
		    m.cObjName = 'Connection' + LTRIM(STR(m.ix))
		    IF NOT PEMSTATUS(THIS, m.cObjName, 5)
		      THIS.AddObject(m.cObjName, m.cClass)
		      THIS.nConnections = THIS.nConnections + 1
		
		      m.oConn = EVALUATE('THIS.' + m.cObjName)
		      WITH m.oConn
		        .nConnID = m.ix               && This is the ID number used to identify the connection externally.
		        .cShareName = m.cShareName    && Name used to compare against for connection sharing
		      ENDWITH
		
		      * Maintain nFirstFreeConnID to optimize the search for free conn IDs
		      THIS.nFirstFreeConnID = m.ix + 1
		      RETURN m.oConn
		    ENDIF
		  ENDFOR
		
		  ERROR THIS.Name + ' - Maximum number of connections exceeded'
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE _getconn		&& Return object reference to the connection object identified by nConnID.
		LPARAMETERS nConnId
		*++
		*>>Return object reference to the connection object identified by nConnID.
		*--
		LOCAL cObjName
		  m.cObjName = 'Connection' + LTRIM(STR(m.nConnID))
		  IF PEMSTATUS(THIS, m.cObjName, 5)
		    RETURN EVALUATE('THIS.' + m.cObjName)
		  ENDIF
		  ERROR THIS.Name + ' - Invalid Connection ID ' + LTRIM(STR(m.nConnID))
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE _removeconnection		&& Remove the specified connection object.
		LPARAMETERS oConn
		*++
		*>>Remove the specified connection object.
		*--
		  IF m.oConn.nConnID < THIS.nFirstFreeConnID
		    THIS.nFirstFreeConnID = m.oConn.nConnID
		  ENDIF
		  THIS.RemoveObject(m.oConn.Name)
		  THIS.nConnections = THIS.nConnections - 1
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmconnectionvfp AS cmconnectionabstract OF "cmdataa.vcx" 		&& Codemine Remote Data Connection class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_connection.bmp" ClassIcon="..\graphics\_connection.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: lnodisconnect		&& Set to .T. if connection should be left open when UseCount goes to 0. Used for connections opened by VFP remote views.
		*p: nvfphandle		&& Native VFP connection handle of an open connection.
	*</DefinedPropArrayMethod>

	ctype = VFP
	lnodisconnect = .F.		&& Set to .T. if connection should be left open when UseCount goes to 0. Used for connections opened by VFP remote views.
	Name = "cmconnectionvfp"
	nvfphandle = (-1)		&& Native VFP connection handle of an open connection.
	
	PROCEDURE begintrans
		*++
		*>>Begin a new transaciton on a native VFP connection
		*--
		  IF SQLGETPROP(THIS.nVFPhandle, 'Transactions') = 1  && VFP Auto mode (means Server is SET AUTOTRANS OFF)
		    IF SQLEXEC(THIS.nVFPhandle, 'BEGIN TRANSACTION') < 0
		      THIS.SqlError('Begin Transaction')
		      RETURN .F.
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE close
		LPARAMETERS lForceAll
		*++
		*>>Close an open connection, or decrement use count if it is shared by multiple users. Returns .T. when use count reaches 0 and connection is closed.
		*--
		  IF THIS.nUseCount > 0 AND THIS.nVFPhandle > 0
		    THIS.nUseCount = THIS.nUseCount - 1
		    IF THIS.nUseCount = 0 OR m.lForceAll
		      * If the connection was opened by a VFP view, then we let the view close it.
		      THIS.nUseCount = 0
		      IF NOT THIS.lNoDisconnect
		        SQLDISCONNECT(THIS.nVFPhandle)
		        THIS.nVFPhandle = -1
		      ENDIF
		      RETURN .T.
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE committrans
		*++
		*>>End (commit) the current transaciton on a native VFP connection
		*--
		LOCAL nStatus
		  IF SQLGETPROP(THIS.nVFPhandle, 'Transactions') = 1  && VFP Auto mode (means Server is SET AUTOTRANS OFF)
		    m.nStatus = SQLEXEC(THIS.nVFPhandle, 'IF @@TRANCOUNT > 0 COMMIT TRANSACTION')
		  ELSE
		    m.nStatus = SQLCOMMIT(THIS.nVFPhandle)
		  ENDIF
		  IF m.nStatus < 0
		    THIS.SqlError('Commit Transaction')
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Destroy
		  * Close all connections when we are destroyed.
		  THIS.Close(.T.)
		
	ENDPROC

	PROCEDURE execute
		LPARAMETERS cSql, cResultCursor
		*++
		*>>Execute the specified SQL statement on the connection.
		* Returns t/f for non-cursor results, or cursor alias name for cursor results.
		*--
		LOCAL nSelect
		  m.nSelect = SELECT()
		
		  * Make sure nothing is open in the current workarea.
		  IF USED()
		    SELECT 0
		  ENDIF
		
		  IF PCOUNT() = 1
		    * Execute a statement that returns no result recordset.
		    * This will be either a simple success/failure code, or a single descrete value.
		    IF SQLEXEC(THIS.nVFPhandle, m.cSQL) > 0
		      IF USED()
		        * If the command returned a value, VFP puts it in a temp cursor with 1 field & 1 record.
		        * Return the value from that field to the caller, and close the cursor.
		        m.uValue = EVALUATE(FIELD(1))
		        USE
		      ELSE
		        m.uValue = .T.
		      ENDIF
		      SELECT (m.nSelect)
		      RETURN m.uValue
		    ENDIF
		  ELSE
		    * Execute a statement that returns a result cursor.
		    IF SQLEXEC(THIS.nVFPhandle, m.cSQL, m.cResultCursor) > 0
		      * Return alias of the result set cursor. We do this for compatibility with
		      * the ADO version, which needs to return the ADO recordset object ref on success.
		      RETURN m.cResultCursor
		    ENDIF
		  ENDIF
		
		  THIS.SqlError(m.cSQL)
		  RETURN IIF(PCOUNT() = 1, .F., .NULL.)
		
	ENDPROC

	PROCEDURE getprop
		LPARAMETERS uProperty
		*++
		*>>Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		*--
		
		  * If uProperty is numeric, this is a custom property implemented via a call to SQLGetInfo().
		  IF VARTYPE(m.uProperty) = 'N'
		    LOCAL nOdbcHandle, cResult, nLength
		    DECLARE SHORT SQLGetInfo IN odbc32 INTEGER  ConnectionHandle, ;
		                                         SHORT    nInfoType, STRING   @InfoValuePtr, ;
		                                         INTEGER  BufferLength, INTEGER  @StringLengthPtr
		    m.nLength = 0
		    m.cResult = SPACE(64)
		    m.nOdbcHandle = SQLGETPROP(THIS.nVFPhandle, 'ODBChdbc')
		    IF SQLGetInfo(m.nOdbcHandle, m.uProperty, @m.cResult, LEN(m.cResult), @m.nLength) <= 1
		      RETURN TRIM(CHRTRAN(m.cResult,CHR(0),''))
		    ENDIF
		    RETURN .NULL.  && Return null on any error
		  ENDIF
		
		  * Additional properties "Connection" returns the VFP conn handle.
		  DO CASE
		    CASE PROPER(m.uProperty) = 'Connection'
		      RETURN THIS.nVFPhandle
		    CASE PROPER(m.uProperty) = 'Usecount'
		      RETURN THIS.nUseCount
		  ENDCASE
		  RETURN SQLGETPROP(MAX(0, THIS.nVFPhandle), m.uProperty)
	ENDPROC

	PROCEDURE open
		LPARAMETERS cString, cUsername, cPassword
		*++
		*>>Open the connection if  a conneciton string is specified. If no string, just increment use count.
		*--
		  IF THIS.nUseCount = 0 AND NOT EMPTY(m.cString)
		    DO CASE
		      CASE '=' $ m.cString
		        * DSN Connection string: [DSN=MyDSN;UID=MyUID;Pwd=MyPassword]
		        THIS.nVFPhandle = SQLSTRINGCONNECT(m.cString)
		        IF THIS.nVFPhandle > 0
		          SQLSETPROP(THIS.nVFPhandle, 'DispLogin', 3)
		          SQLSETPROP(THIS.nVFPhandle, 'DispWarnings', .F.)
		        ENDIF
		
		      CASE NOT EMPTY(m.cUsername)
		        * Connection name, with username and password override.
		        THIS.nVFPhandle = SQLCONNECT(m.cString, m.cUsername, m.cPassword)
		
		      OTHERWISE
		        * Simple DBC connection name
		        THIS.nVFPhandle = SQLCONNECT(m.cString)
		    ENDCASE
		
		    IF THIS.nVFPhandle < 0
		      LOCAL cMsg, aInfo[1]
		      =AERROR(aInfo)
		      * Don't include full connection string in error message, as this could display passwords and be a security risk.
		      THIS.cDisplayName = GetToken(m.cString, ';')   && Use connection name, or first token (DSN) of conn string.
		      IF aInfo[1] = 1526
		        m.cMsg = aInfo[3]
		        m.cMsg = '(' + ALLTRIM(STR(aInfo[5])) + ') ' + LEFT(SUBSTR(m.cMsg, RAT(']', m.cMsg, 2) + 1), 235)
		      ELSE
		        m.cMsg = aInfo[2]
		      ENDIF
		      THIS.DisplayMessage('%msgConnectionFailed', m.cMsg)
		      RETURN .F.
		    ENDIF
		  ENDIF
		  THIS.nUseCount = THIS.nUseCount + 1
		  RETURN .T.
		
	ENDPROC

	PROCEDURE rollbacktrans
		*++
		*>>Roll back a transaciton on a native VFP connection
		*--
		LOCAL nStatus
		  IF SQLGETPROP(THIS.nVFPhandle, 'Transactions') = 1  && VFP Auto mode (means Server is SET AUTOTRANS OFF)
		    m.nStatus = SQLEXEC(THIS.nVFPhandle, 'IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION')
		  ELSE
		    m.nStatus = SQLROLLBACK(THIS.nVFPhandle)
		  ENDIF
		  IF m.nStatus < 0
		    THIS.SqlError('Rollback Transaction')
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setprop
		LPARAMETERS cProperty, uValue
		*++
		*>>Set connection properties, using the same property names as the VFP SQLGETPROP() function.
		*--
		  RETURN SQLSETPROP(MAX(0, THIS.nVFPhandle), m.cProperty, m.uValue)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataabstract AS container 		&& Common data object foundation class for Codemine cursor and access objects.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*m: afterinit		&& Custom developer code to execute after the default object initialization code.
		*m: cdisplayname_access		&& Fill in a default value for display name if no explicit value is set.
		*m: comments		&& Developer can place object comments in this method, enclosed in #if .F. #endif directives, or standard comment indicators.
		*m: displaymessage		&& Use the Message Manager service to display an error message, or store it for return to caller if no UI available.
		*m: oapp_access		&& Fill in the reference to the Application Object on first reference.
		*m: omessage_access		&& Fill in the reference to the message display service object on first reference.
		*m: osecurity_access		&& Fill in the reference to the security service object on first reference.
		*m: seterrormode		&& Set or restore the error mode flags.
		*m: sqlerror		&& Get and display the details of the last SQL passthough level error. Optional cDetails parameter specifies text for the "Explain..." window in error dialog.
		*p: cclass		&& Foundation class name. You should not change this value in any subclasses.
		*p: cdisplayname		&& A user-friendly name to use for this object in system messages.
		*p: nerrormode		&& Determines what types of errors should be handled silently. 0=Display All,1=Non-Fatal Silent,2=Fatal Silent,3=All Silent.
		*p: oapp		&& Runtime object reference to the applicaiton object.
		*p: omessage		&& Runtime reference to message manager object. Leave NULL at design time.
		*p: osecurity		&& Runtime object reference to the cmSecurity global service object.
	*</DefinedPropArrayMethod>

	cclass = 		&& Foundation class name. You should not change this value in any subclasses.
	cdisplayname = 		&& A user-friendly name to use for this object in system messages.
	Height = 15
	Name = "cmdataabstract"
	nerrormode = 0		&& Determines what types of errors should be handled silently. 0=Display All,1=Non-Fatal Silent,2=Fatal Silent,3=All Silent.
	oapp = .NULL.		&& Runtime object reference to the applicaiton object.
	omessage = .NULL.		&& Runtime reference to message manager object. Leave NULL at design time.
	osecurity = .NULL.		&& Runtime object reference to the cmSecurity global service object.
	TabStop = .F.
	Visible = .F.
	Width = 20
	
	PROCEDURE addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		LPARAMETERS cName, cClassAlias, uP1, uP2, uP3, uP4, uP5, uP6, uP7, uP8, uP9
		*++
		*>>Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*--
		LOCAL ix, cParams, cLibrary
		
		  * Translate class alias into actual class name, and extract class library prefix if present.
		  m.cLibrary = .NULL.
		  IF PEMSTATUS(_SCREEN, 'cmGlobalObjectManager', 5)
		    m.cClassAlias = _SCREEN.cmGlobalObjectManager.GetClassName(m.cClassAlias, @m.cLibrary)
		  ENDIF
		
		  m.cParams = ''
		  FOR ix = 1 TO PCOUNT() - 2
		    m.cParams = m.cParams + ', @m.uP' + STR(m.ix,1)
		  ENDFOR
		  RETURN THIS.NewObject(m.cName, m.cClassAlias, m.cLibrary, '' &cParams)
		
	ENDPROC

	PROCEDURE afterinit		&& Custom developer code to execute after the default object initialization code.
		*++
		*>>Custom developer code to execute after the default object initialization code.
		*--
		
	ENDPROC

	PROCEDURE cdisplayname_access		&& Fill in a default value for display name if no explicit value is set.
		*++
		*>>Fill in a default value for display name if no explicit value is set.
		*--
		  IF EMPTY(THIS.cDisplayName)
		    RETURN THIS.Name
		  ENDIF
		  RETURN THIS.cDisplayName
		
	ENDPROC

	PROCEDURE comments		&& Developer can place object comments in this method, enclosed in #if .F. #endif directives, or standard comment indicators.
		*++
		*>>Developer can place object comments in this method, enclosed in #if .F. #endif directives, or standard comment indicators.
		*--
		
	ENDPROC

	PROCEDURE displaymessage		&& Use the Message Manager service to display an error message, or store it for return to caller if no UI available.
		LPARAMETERS cMsg, uP1, uP2, uP3
		*++
		*>>Use the Message Manager service to display an error message, or store it for return to caller if no UI available.
		*--
		LOCAL nSelect
		  * Messages displayed from code inside grid events may cause unexpected default workarea changes,
		  * because of the way grids are implemented in VFP. Preserving workarea across message display
		  * seems to minimize the side effects of this problem.
		  m.nSelect = SELECT()
		  IF NOT EMPTY(BITAND(THIS.nErrorMode, ERRMASK_SILENT_MESSAGE))
		    IF NOT ISNULL(THIS.oMessage)
		      THIS.oMessage.SetLastMessage(m.cMsg, m.uP1, m.uP2, m.uP3)
		    ENDIF
		  ELSE
		    IF NOT ISNULL(THIS.oMessage)
		      THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_OK, MSG_SEVERITY_WARNING, m.cMsg, ;
		                         '', THIS.cDisplayName, m.uP1, m.uP2, m.uP3)
		    ELSE
		      MESSAGEBOX(m.cMsg, 48, THIS.name)
		    ENDIF
		  ENDIF
		  SELECT (m.nSelect)
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Handle open errors,
		* Provide custom processing for the following VFP error numbers:
		*  1         - file not found
		*  202       - Invalid path or filename
		*  3, 108, 1705, 1995 - file in use
		*  109       - Record in use
		*  1526      - ODBC connectivity error
		*  15        - Not a table
		*  41        - memo missing
		*  19, 114   - damaged index
		*  1707      - Structural CDX not found
		*--
		LOCAL cMsg, cVFPMessage, cArg1, cArg2, cDetails, oCursor
		
		  * Save these before any other code clobbers them
		  m.cVFPMessage = MESSAGE()
		  m.cArg1 = SYS(2018)
		  THIS.AddProperty('nLastError', m.nError)
		
		  * Process open errors that we can recover from gracefully.
		  DO CASE
		    CASE INLIST(m.nError, 1581, 1582, 1583, 1881, 1884)   && DBC or property rule violations
		      * The value returned by MESSAGE() will contain the error text for the rule specified in the DBC.
		      m.cMsg = MESSAGE()
		    CASE INLIST(m.nError, 1, 202) AND NOT '.PRG' $ SYS(2018)  && A prg file not found is a fatal error
		      m.cMsg = '%msgFileNotFound'
		    CASE INLIST(m.nError, 3, 108, 1705, 1995)
		      m.cMsg = '%msgFileInUse'
		    CASE INLIST(m.nError, 109)
		      m.cMsg = '%msgLockedByAnother'
		    CASE INLIST(m.nError, 15, 19, 41, 114, 1707, 1542, 1543, 1544, 1984, 2004)
		      IF 'appdata' $ LOWER(m.cVFPMessage)
		         ErrorLOG(m.cMethod,m.nLine,'cmdatabstract',m.nError,m.cVFPMessage,'DBC Was Fixed',.null.,.f.,.t.)
		         UpdateDBC(m.goapp.cDataFilePath)
		         RETRY 
		      ELSE 
		         m.cMsg = '%msgFileDamaged'
		         m.cArg2 = '(#' + LTRIM(STR(m.nError)) + ') ' + m.cVFPMessage
		      ENDIF    
		    CASE INLIST(m.nError, 1523)   && User cancelled system requery parameter prompt, or other dialog.
		      RETURN .T.                  && Ignore silently, with nLastError flag set.
		    CASE INLIST(m.nError, 1541)
		      m.cMsg = '%msgConnectionBusy'
		    CASE INLIST(m.nError, 1526)
		      LOCAL aInfo[1]
		      m.cMsg = '%msgConnectivityError'
		      m.cArg1 = ''
		      =AERROR(aInfo)
		      m.cDetails = '(' + ALLTRIM(STR(aInfo[5])) + ') ' + aInfo[3]
		    CASE INLIST(m.nError, 1552, 2091)
		         ErrorLOG(m.cMethod,m.nLine,'cmdatabstract',m.nError,m.cVFPMessage,'DBC Was Fixed',.null.,.f.,.t.)
		         UpdateDBC(m.goapp.cDataFilePath)
		         RETRY 
		    CASE INLIST(m.nError, 1104, 1105)
		      this.omessage.warning('The connection to the server holding the data was terminated. This is caused by hardware or other network issues. To re-connecto to the data, exit the software and then re-start it. Click CANCEL on any subsequent error messages to exit.')
		      TRY 
		         CLOSE DATABASES all
		         m.goApp.Shutdown(.T.)         
		      CATCH
		         QUIT
		      ENDTRY   
		
		    OTHERWISE
		      * Not an error we handle. Pass on for Fatal Error handling.
		      IF NOT EMPTY(BITAND(THIS.nErrorMode, ERRMASK_SILENT_FATAL))
		        IF NOT ISNULL(THIS.oMessage)
		          THIS.oMessage.SetLastMessage(m.cVFPmessage)
		        ENDIF
		      ELSE
		        IF NOT ISNULL(THIS.oMessage) AND EMPTY(BITAND(THIS.nErrorMode, ERRMASK_NOMSGMAN))
		          THIS.oMessage.FatalError(m.cVFPmessage, m.cMethod, m.nLine)
		
		          * If the cursor is accessed as part of the error display (as in the case where a registry
		          * cursor caused the error), then nLastError may have been cleared so need to reset here.
		          THIS.nLastError = m.nError
		        ELSE
		          * No message handler object, resignal the error to VFP.
		          ERROR 'Error ' + LTRIM(STR(m.nError)) + ' at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cVFPMessage
		        ENDIF
		      ENDIF
		      RETURN
		  ENDCASE
		
		  * Process non-fatal errors here.
		  IF NOT EMPTY(m.cArg1)
		    m.cArg1 = THIS.cDisplayName + ' (' + m.cArg1 + ')'
		  ELSE
		    m.cArg1 = THIS.cDisplayName
		    * We might be a cursor, or its dataAccess object. If so, get full cursor file path.
		    IF PROPER(THIS.cClass) $ 'Cmcursor,Cmdataaccess'
		      m.oCursor = IIF(PROPER(THIS.cClass) == 'Cmcursor', THIS, THIS.Parent)
		      IF PEMSTATUS(m.oCursor, 'cmDataAccess', 5)
		        IF NOT EMPTY(m.oCursor.cmDataAccess.cFilepath)
		          m.cArg1 = m.cArg1 + ' (' + m.oCursor.cmDataAccess.cFilepath + ')'
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  IF NOT EMPTY(BITAND(THIS.nErrorMode, ERRMASK_SILENT_WARNING))
		    IF NOT ISNULL(THIS.oMessage)
		      THIS.oMessage.SetLastMessageEx(m.cMsg, m.cDetails, m.cArg1, m.cArg2)
		    ENDIF
		  ELSE
		    IF ISNULL(THIS.oMessage) OR NOT EMPTY(BITAND(THIS.nErrorMode, ERRMASK_NOMSGMAN))
		      * No Codemine Message handler object is available, or we are not allowed to use it.
		      MESSAGEBOX(m.cVFPMessage, 48, THIS.Name)
		    ELSE
		      THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_OK, MSG_SEVERITY_WARNING, m.cMsg, m.cDetails,, m.cArg1, m.cArg2)
		
		      * If the cursor is accessed as part of the error display (as in the case where a registry
		      * cursor caused the error), then nLastError may have been cleared so need to reset here.
		      THIS.nLastError = m.nError
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine foundation data object class.
		* Copyright 2000-2001 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		  * VFP has screen update bugs that try to draw a blank square in the shape of this container,
		  * Even though it is not part of _SCREEN and is not Visible. Moving position above top seems 
		  * to avoid the problem.
		  IF NOT PEMSTATUS(THIS, 'Top', 1)   && Is ReadOnly if contained in a toolbar
		    THIS.Top = -1000
		  ENDIF
		
		  * Create runtime internal-use-only properties now. These are not available at design time.
		  THIS.AddProperty('nLastError', 0)              && flag set when a handled error or DBC rule violation occurs.
		  THIS.AddProperty('nLastSqlError', 0)           && Error number of last remote server error returned.
		  THIS.AddProperty('aErrorModeStack[1]')         && Value stack for the SetErrorMode() method
		
		  RETURN THIS.AfterInit()
		
	ENDPROC

	PROCEDURE oapp_access		&& Fill in the reference to the Application Object on first reference.
		*++
		*>>Fill in the reference to the Application Object on first reference.
		*--
		  IF ISNULL(THIS.oApp)
		    THIS.oApp= FindGlobalObject('appApplication')
		  ENDIF
		  RETURN THIS.oApp
		
	ENDPROC

	PROCEDURE omessage_access		&& Fill in the reference to the message display service object on first reference.
		*++
		*>>Fill in the reference to the message display service object on first reference.
		*--
		  IF ISNULL(THIS.oMessage)
		    THIS.oMessage = FindGlobalObject('cmMessage')
		  ENDIF
		  RETURN THIS.oMessage
		
	ENDPROC

	PROCEDURE osecurity_access		&& Fill in the reference to the security service object on first reference.
		*++
		*>>Fill in the reference to the security service object on first reference.
		*--
		  IF ISNULL(THIS.oSecurity)
		    THIS.oSecurity = FindGlobalObject('cmSecurity')
		  ENDIF
		  RETURN THIS.oSecurity
		
	ENDPROC

	PROCEDURE seterrormode		&& Set or restore the error mode flags.
		LPARAMETERS nFlags
		*++
		*>>Set or restore the error mode flags.
		*--
		  m.nOldMode = THIS.nErrorMode
		  IF VARTYPE(m.nFlags) $ 'NI'
		    * Save current value on stack, and Set new flags value.
		    DIMENSION THIS.aErrorModeStack[ALEN(THIS.aErrorModeStack) + 1]
		    THIS.aErrorModeStack[ALEN(THIS.aErrorModeStack)] = THIS.nErrorMode
		    THIS.nErrorMode = m.nFlags
		
		    * Clear last-error flag whenever setting error mode to an explicit value.
		    THIS.nLastError = 0
		  ELSE
		    * Restore previous value.
		    IF ALEN(THIS.aErrorModeStack) > 1
		      THIS.nErrorMode = THIS.aErrorModeStack[ALEN(THIS.aErrorModeStack)]
		      DIMENSION THIS.aErrorModeStack[ALEN(THIS.aErrorModeStack) - 1]
		    ELSE
		      THIS.nErrorMode = 0
		    ENDIF
		  ENDIF
		
		  * This method always returns the original nErrorMode state value.
		  RETURN m.nOldMode
		
	ENDPROC

	PROCEDURE sqlerror		&& Get and display the details of the last SQL passthough level error. Optional cDetails parameter specifies text for the "Explain..." window in error dialog.
		LPARAMETERS cDetails, cMsg
		*++
		*>>Get and display the details of the last SQL passthough level error. Optional cDetails parameter specifies text for the "Explain..." window in error dialog.
		*--
		LOCAL aInfo[1], ix
		
		  =AERROR(aInfo)
		  THIS.AddProperty('nLastSqlError', aInfo[5])
		
		  IF NOT ISNULL(THIS.oMessage)
		    * Default message is last ODBC error, but caller can specify an override message.
		    IF EMPTY(m.cMsg)
		      m.cMsg = NVL(aInfo[3], '??NULL ODBC Error Information.')
		      m.cMsg = LEFT(SUBSTR(m.cMsg, RAT(']', m.cMsg, 2) + 1), 240)
		      m.cMsg = '(' + ALLTRIM(STR(NVL(aInfo[5],0))) + ') ' + m.cMsg
		    ENDIF
		
		    * ODBC errors may have multiple entries.
		    FOR ix = 2 TO ALEN(aInfo,1)
		      m.cMsg = m.cMsg + CR_LF + NVL(aInfo[m.ix, 3], '')
		    ENDFOR
		
		    * Disable msg argument escape char, in case message text contains backslashes
		    m.cMsg = '\-' + m.cMsg
		\
		
		    IF NOT EMPTY(BITAND(THIS.nErrorMode, ERRMASK_SILENT_WARNING))
		      THIS.oMessage.SetLastMessageEx(m.cMsg, m.cDetails)
		    ELSE
		      * The SQL command executed will show up under the "Explain" panel in the dialog.
		      THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_OK, MSG_SEVERITY_WARNING, m.cMsg, ;
		                         @m.cDetails, THIS.cDisplayName)
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataaccessabstract AS cmdataabstract OF "cmdataa.vcx" 		&& Codemine low-level data access class, use by cursor classes to access physical cursor data.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: bindtorecordset		&& Load cursor properties from the current cursor.
		*m: clone		&& Create a duplicate context for this recordset. For VFP cursors, this is essentially a USE AGAIN command.
		*m: close		&& Close the currently open cursor.
		*m: curvalue		&& Return the current value of the specified field
		*m: delete		&& Delete the current record in this cursor.
		*m: deletewhere		&& Delete records matching the specified Where expression.
		*m: extractfieldname		&& Given a generic expression, extract the first field name it is based on.
		*m: fieldtype		&& Return the data type of the specified field
		*m: fieldvalue		&& Return the current value of the specified field
		*m: find		&& Find the first record in the cursor that matches the specified expression.
		*m: getbuffermode		&& Return the buffering mode for this cursor as a numeric code. The return values match those of the VFP CURSORGETPROP("Buffering") function.
		*m: getfilter		&& Return the current record filter expression for the cursor.
		*m: getforeignkeyfield		&& Return the foreign key field for this cursor, when it is a child in a relation.
		*m: getorder		&& Return the sort order to the specified tag/field.
		*m: getposition		&& Return the current record position - by record number for tables.
		*m: getprimarykeyfield		&& Return the Primary key field for this cursor, if one can be found.
		*m: getprop		&& Return various property setting about the cursor.
		*m: getviewparameters		&& Return a string describing all the parameters used by a parameterized view.
		*m: gobottom		&& Go to the last record in the cursor
		*m: goto		&& Go to the specified record number in the cursor
		*m: gotop		&& Go to the first record in the cursor
		*m: ischanged		&& Returns true if any record in the cursor contains uncommited changes.
		*m: isdeleted		&& Determine if the current record has been marked deleted.
		*m: isempty		&& Determine whether or not the cursor has any non-deleted records.
		*m: iseof		&& Determine whether or not the cursor is at EOF.
		*m: isexclusive		&& Return the current exclusive setting.
		*m: isfield		&& Return true if the specified field name is present in this cursor
		*m: isfieldchanged		&& Returns true if the specified field in the current record has been changed.
		*m: isnew		&& Determine if the current record is a Newly buffered record; existing only in the local update buffer.
		*m: isopen		&& Return true if the cursor is Open.
		*m: isprimarykeyupdateable		&& Determine if primary key field is updateable. Always true for native VFP tables.
		*m: isreadonly		&& Determine if the cursor is read-only.
		*m: isrecordchanged		&& Returns true if the current record contains uncommited changes.
		*m: localtransclear		&& Clear all local transaction rollback buffers for levels at or above the specified level.
		*m: localtransjoin		&& Add the current table/view record to a local transaction at the specified level.
		*m: localtransrollback		&& Roll back the current local transaction level. Supports both row and table buffer modes.
		*m: lockrecord		&& Obtain network Lock for the specified record.
		*m: nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*m: nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		*m: new		&& Add a new record to the record set.
		*m: oldvalue		&& Return the old value of the specified field
		*m: open		&& Open the cursor, and leave it as the current workarea (for native VFP cursors).
		*m: openconnection		&& Open the connection specified in the parent's cConnection property. Returns the conneciton handle.
		*m: openoptions		&& Return a list of USE command clauses to apply to the cursor about to be opened.
		*m: pack		&& Pack the table, removing deleted records. Applies to native VFP tables only.
		*m: parentkeychanged		&& Update the FK for all records related to current parent recored, after the parent's PK was changed.
		*m: primarykeychanged		&& Reset child foriegn keys. A No-op for all but native VFP tables.
		*m: reccount		&& Return the total number of records in the cursor
		*m: recno		&& Return the current record number, or 0 if there is no current record (EOF).
		*m: refreshdata		&& Refresh data in the current row of the cursor.
		*m: reindex		&& Regenerate all existing indexes. Applies to native VFP tables only.
		*m: replace		&& Set the value of the specified field.
		*m: requery		&& Requery the view.
		*m: restoreposition		&& Restore record pointer to the last saved value if possible.
		*m: revert		&& Discard all buffered changes to this cursor.
		*m: revertrecord		&& Discard all buffered changes to this cursor.
		*m: saveposition		&& Save current record pointer position.
		*m: seek		&& Seek the record matching the specified key in the cursor.
		*m: select		&& Restrict our recordset to only those matching the current parent record
		*m: setbuffermode		&& Set the buffering mode for this cursor
		*m: setdefault		&& Set this cursor as the curernt VFP workarea (if it is a native VFP cursor).
		*m: setexclusive		&& Set the exclusive acces mode to exclusive or shared.
		*m: setfilter		&& Set the record filter expression for the cursor.
		*m: setorder		&& Set the sort order to the specified tag/field.
		*m: setposition		&& Set the current record position - by record number for tables.
		*m: setpositionflags		&& Set record position flags for a cursor.
		*m: setprop		&& Set various properties for the cursor.
		*m: setrelation		&& Set a relation between two cursors, and set default RI options. A no-op for views and any other non-table cursors.
		*m: skip		&& Skip the specified number of records forward or backwards.
		*m: tableupdate		&& Write changes to source tables via the TABLEUPDATE() function.
		*m: unlockrecord		&& Release network lock on the current (or specified) record. Use record number 0 to unlock the header, or -1 to unlock all records.
		*m: update		&& Write all buffered changes for Native VFP Table or Local View to disk.
		*m: updaterecord		&& Write buffered changes to the current record back to the source.
		*m: zap		&& Delete all the local cursor records.
		*m: _extractparameters		&& Return a string describing all the parameters used in the SQL statement.
		*m: _getkeyfilter		&& Internal method to return the current SET KEY expression in a format that can easily be re-applied.
		*m: _getkeyvalue		&& Internal method to return the current SET KEY expression value, in the correct data type.
		*m: _insertparamvalue		&& Replace a parameter placeholder with the value for the parameter in an SQL statement.
		*m: _isequal		&& Compare two values, not counting trailing spaces for character types.
		*m: _setkeyfilter		&& Internal method to re-apply a saved SET KEY expression, from the values returned by _GetKeyFilter()
		*m: _setwhere		&& Set the WHERE clasue of the specified SQL SELECT statement to the specified expression.
		*m: _valuetochar		&& Convert any type value to a character literal format valid for use in SQL server expressions.
		*m: _waitforlock		&& Display an informational message, and wait a random amount of time to retry after a lock failure. Return .F. to stop attempting the lock.
		*p: lselectbyrequery		&& Set to True if recordset selection for this cursor type is done via Requery(). False for native VFP tables, True for most other cursor types.
	*</DefinedPropArrayMethod>

	cclass = cmDataAccess
	lselectbyrequery = .T.		&& Set to True if recordset selection for this cursor type is done via Requery(). False for native VFP tables, True for most other cursor types.
	Name = "cmdataaccessabstract"
	
	PROCEDURE bindtorecordset		&& Load cursor properties from the current cursor.
		LPARAMETERS uRecordSet
		*++
		*>>Load cursor properties from the current cursor.
		*--
		  WITH THIS.Parent
		    .cSource = DBF(THIS.cWorkarea)
		    .cDatabase = CURSORGETPROP('Database', THIS.cWorkarea)
		    .cOrder = ORDER(THIS.cWorkarea)
		    .cFilter = FILTER(THIS.cWorkarea)
		    .lReadOnly = ISREADONLY(THIS.cWorkarea)
		  ENDWITH
		
	ENDPROC

	PROCEDURE cdisplayname_access
		*++
		*>>Fill in a default value for the parent display name if no explicit value is set.
		*--
		  RETURN THIS.Parent.cDisplayName
		
	ENDPROC

	PROCEDURE clone		&& Create a duplicate context for this recordset. For VFP cursors, this is essentially a USE AGAIN command.
		LPARAMETERS cNewAlias, nFlags
		*++
		*>>Create a duplicate context for this recordset. For VFP cursors, this is essentially a USE AGAIN command.
		*--
		LOCAL nSelect, cSetKey, lDescending
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		  m.lDescending = DESCENDING()
		  m.cSetKey = THIS._GetKeyFilter()
		
		  * Open another workarea context for the table/view cursor, with the desired alias name.
		  SELECT 0
		  USE (DBF(THIS.cWorkarea)) AGAIN SHARED ALIAS (m.cNewAlias)
		  IF NOT EMPTY(ORDER(THIS.cWorkarea))
		    IF m.lDescending
		      SET ORDER TO (ORDER(THIS.cWorkarea)) DESCENDING
		    ELSE
		      SET ORDER TO (ORDER(THIS.cWorkarea))
		    ENDIF
		  ENDIF
		
		  * Clone gets the same buffering mode as the original
		  IF NOT BITTEST(m.nFlags, CLONEMASK_NOBUFFER)
		    CURSORSETPROP('Buffering', THIS.GetBufferMode(), m.cNewAlias)
		  ENDIF
		
		  * Apply SET KEY filter from original workarea
		  THIS._SetKeyFilter(m.cSetKey)
		
		  * Apply SET FILTER filter from original workarea
		  IF NOT EMPTY(FILTER(THIS.cWorkarea))
		    m.cFilter = FILTER(THIS.cWorkarea)
		    SET FILTER TO &cFilter
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN m.cNewAlias
		
	ENDPROC

	PROCEDURE close		&& Close the currently open cursor.
		*++
		*>>Close the currently open cursor.
		*--
		  IF NOT EMPTY(THIS.cWorkarea) AND USED(THIS.cWorkarea)
		    USE IN (THIS.cWorkarea)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE curvalue		&& Return the current value of the specified field
		LPARAMETERS cField
		*++
		*>>Return the current value of the specified field
		*--
		  RETURN CURVAL(m.cField, THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE delete		&& Delete the current record in this cursor.
		*++
		*>>Delete the current record in this cursor.
		*--
		LOCAL nLockRetries
		
		  SET REPROCESS TO 1
		  IF NOT EOF(THIS.cWorkarea) AND NOT ISREADONLY(THIS.cWorkarea)
		    DO WHILE .T.
		      THIS.nLastError = 0
		      DELETE IN (THIS.cWorkarea)                                && Mark record deleted
		      IF THIS.nLastError = 109 AND THIS._WaitForLock(@m.nLockRetries)
		        LOOP
		      ENDIF
		      EXIT   && Exit loop on all cases but 
		    ENDDO
		    IF NOT EMPTY(m.nLockRetries) AND NOT ISNULL(THIS.oMessage)
		      THIS.oMessage.StatusClear()
		    ENDIF
		    RETURN (THIS.nLastError = 0)
		  ENDIF      
		  RETURN .F.   && Should never happen unless calling code is broken...
		
	ENDPROC

	PROCEDURE deletewhere		&& Delete records matching the specified Where expression.
		LPARAMETERS cWhereExpression, nFlags
		*++
		*>>Delete records matching the specified Where expression.
		*--
		  * Cursor-type-specific code
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		IF nError <> 5 AND nError <> 1938  &&  Bogus out of range error, so ignore it
		   DODEFAULT(nerror,cmethod,nline)
		endif
	ENDPROC

	PROCEDURE extractfieldname		&& Given a generic expression, extract the first field name it is based on.
		LPARAMETERS cExpression
		*++
		*>>Given a generic expression, extract the first field name it is based on.
		*--
		  m.cField = CHRTRAN(m.cExpression, ')+,', '    ') + ' '
		  m.cField = LEFT(m.cField , AT(' ', m.cField ) - 1)
		  DO WHILE '(' $ m.cField
		    m.cField = SUBSTR(m.cField, AT('(', m.cField) + 1)
		  ENDDO
		  RETURN m.cField
		
	ENDPROC

	PROCEDURE fieldtype		&& Return the data type of the specified field
		LPARAMETERS cField, nLength, nDecimals
		*++
		*>>Return the data type of the specified field
		*--
		LOCAL cType
		  IF PCOUNT() > 1   && Use custom FLL function if length and decimal places are required.
		    m.cType = cmFieldInfo(EVALUATE(IIF('.' $ m.cField, m.cField, ;
		                          THIS.cWorkarea + '.' + m.cField)), @m.nLength, @m.nDecimals)
		  ELSE
		    m.cType = TYPE(IIF('.' $ m.cField, m.cField, THIS.cWorkarea + '.' + m.cField))
		  ENDIF
		  RETURN m.cType
		
	ENDPROC

	PROCEDURE fieldvalue		&& Return the current value of the specified field
		LPARAMETERS cField
		*++
		*>>Return the current value of the specified field
		*--
		LOCAL nSelect, uValue
		  * Note that this also allows for simple expressions too, when using VFP based cursors.
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		 
		  * "Null" as a field name is a special case, since it is also a predefined VFP constant.
		  * We don't force the workarea prefix on all fieldnames to allow for the posibility of compound expressions.
		  IF UPPER(m.cField) == 'NULL'
		    m.uValue = EVALUATE(THIS.cWorkarea + '.Null')
		  ELSE
		    m.uValue = EVALUATE(m.cField)
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE find		&& Find the first record in the cursor that matches the specified expression.
		LPARAMETERS cFor, lContinue
		*++
		*>>Find the first record in the cursor that matches the specified expression.
		*--
		LOCAL nRecno, nSelect
		
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		  m.nRecno = RECNO()  && Restore on failure
		
		  m.cFor = IIF(EMPTY(m.cFor), '', 'FOR ' + m.cFor)
		  IF m.lContinue
		    m.cFor = 'REST ' + m.cFor
		  ENDIF
		
		  LOCATE &cFor
		  SELECT (m.nSelect)
		  IF NOT EOF(THIS.cWorkarea)
		    RETURN .T.
		  ENDIF
		
		  * Restore original record position on error
		  IF m.nRecno <= RECCOUNT(THIS.cWorkarea)
		    GOTO (m.nRecno) IN (THIS.cWorkarea)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getbuffermode		&& Return the buffering mode for this cursor as a numeric code. The return values match those of the VFP CURSORGETPROP("Buffering") function.
		*++
		*>>Return the buffering mode for this cursor as a numeric code. The return values match those of the VFP CURSORGETPROP("Buffering") function.
		*--
		  RETURN CURSORGETPROP('Buffering', THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE getfilter		&& Return the current record filter expression for the cursor.
		*++
		*>>Return the current record filter expression for the cursor.
		*--
		  RETURN FILTER(THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE getforeignkeyfield		&& Return the foreign key field for this cursor, when it is a child in a relation.
		*++
		*>>Return the foreign key field for this cursor, when it is a child in a relation.
		*--
		LOCAL nSelect, cField
		
		  * If no FK specified, Extract default field name from current index expression, if possible
		  m.cField = ''
		  IF NOT EMPTY(ORDER(THIS.cWorkarea))
		    m.nSelect = SELECT()
		    SELECT (THIS.cWorkarea)
		    m.cField = THIS.ExtractFieldname(KEY())
		    SELECT(m.nSelect)
		  ENDIF
		  RETURN m.cField
		
	ENDPROC

	PROCEDURE getorder		&& Return the sort order to the specified tag/field.
		*++
		*>>Return the sort order to the specified tag/field.
		*--
		  RETURN ORDER(THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE getposition		&& Return the current record position - by record number for tables.
		*++
		*>>Return the current record position - by record number for tables.
		*--
		  RETURN THIS.Recno()
		
	ENDPROC

	PROCEDURE getprimarykeyfield		&& Return the Primary key field for this cursor, if one can be found.
		*++
		*>>Return the Primary key field for this cursor, if one can be found.
		*--
		LOCAL ix, nSelect, cField
		
		  m.cField = ''
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		
		  * Field name defaults to the field of the primary index tag.
		  FOR ix = 1 TO TAGCOUNT(STRTRAN(DBF(), '.DBF', '.CDX'))
		    IF PRIMARY(m.ix)
		      m.cField = NORMALIZE(KEY(m.ix))
		      EXIT
		    ENDIF
		  ENDFOR
		  SELECT (m.nSelect)
		  RETURN m.cField
		
	ENDPROC

	PROCEDURE getprop		&& Return various property setting about the cursor.
		LPARAMETERS cProperty
		*++
		*>>Return various property setting about the cursor.
		*--
		  m.cProperty = PROPER(m.cProperty)
		  DO CASE
		    CASE m.cProperty = 'Connecthandle'
		      * Return the remote connection handle, if this is a remote view. Otherwise, 0.
		      IF CURSORGETPROP('SourceType', THIS.cWorkarea) = 2
		        RETURN CURSORGETPROP(m.cProperty, THIS.cWorkarea)
		      ENDIF
		      RETURN 0
		
		    CASE m.cProperty = 'Connectname'
		      * Return the remote connection name, if this is a remote view. Otherwise, empty string.
		      IF CURSORGETPROP('SourceType', THIS.cWorkarea) = 2
		        RETURN CURSORGETPROP(m.cProperty, THIS.cWorkarea)
		      ENDIF
		      RETURN ''
		
		    OTHERWISE
		      RETURN CURSORGETPROP(m.cProperty, THIS.cWorkarea)
		  ENDCASE
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getviewparameters		&& Return a string describing all the parameters used by a parameterized view.
		*++
		*>>Return a string describing all the parameters used by a parameterized view.
		*--
		LOCAL cDBC, cOldDBC, cView, cParamList
		
		  m.cParamList = ''
		  IF USED(THIS.cWorkarea) AND CURSORGETPROP('SourceType', THIS.cWorkarea) < 3
		    m.cOldDBC = SET('DATABASE')
		    SET DATABASE TO (JUSTSTEM(THIS.Parent.cDatabase))
		    m.cView = CURSORGETPROP('SourceName', THIS.cWorkarea)
		
		    IF INDBC(m.cView, 'View')
		      m.cParamList = DBGETPROP(m.cView, 'View', 'ParameterList')
		    ENDIF
		    SET DATABASE TO &cOldDBC
		  ENDIF
		  RETURN m.cParamList
		
	ENDPROC

	PROCEDURE gobottom		&& Go to the last record in the cursor
		LPARAMETERS lEof
		*++
		*>>Go to the last record in the cursor
		*--
		  THIS.nLastError = 0
		  IF USED(THIS.cWorkarea)
		    * Used optimized navigation for filtered cursors with indexes.
		    IF NOT EMPTY(FILTER(THIS.cWorkarea)) AND NOT EMPTY(ORDER(THIS.cWorkarea))
		      LOCAL nSelect, lWasDescending
		      m.nSelect = SELECT()
		      SELECT (THIS.cWorkarea)
		      m.lWasDescending = DESCENDING()
		      SET ORDER TO (ORDER()) DESCENDING
		      LOCATE
		      IF NOT m.lWasDescending
		        SET ORDER TO (ORDER()) ASCENDING
		      ENDIF
		      SELECT (m.nSelect)
		    ELSE
		      GOTO BOTTOM IN (THIS.cWorkarea)
		    ENDIF
		
		    * Move to EOF if caller wants to.
		    IF m.lEof AND NOT EOF(THIS.cWorkarea) AND EMPTY(THIS.nLastError)
		      SKIP 1 IN (THIS.cWorkarea)
		    ENDIF
		    RETURN EMPTY(THIS.nLastError)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE goto		&& Go to the specified record number in the cursor
		LPARAMETERS nRecord
		*++
		*>>Go to the specified record number in the cursor
		*--
		  THIS.nLastError = 0
		  IF USED(THIS.cWorkarea)
		    IF m.nRecord != 0 AND m.nRecord <= RECCOUNT(THIS.cWorkarea)
		      * Don't physically move the record pointer if the desired record is already current.
		      * This prevents unexpected movement of related child records in native VFP related tables.
		      IF m.nRecord != RECNO(THIS.cWorkarea) AND m.nRecord <= RECCOUNT(this.cWorkarea)  &&  Added last part to ensure it doesn't try to go to a larger record # than really exists - BH 10/08/2007
		        GOTO (m.nRecord) IN (THIS.cWorkarea)
		      ENDIF
		      RETURN EMPTY(THIS.nLastError)
		    ELSE
		      IF m.nRecord == 0
		        RETURN THIS.GoBottom(.T.)  && Goto EOF on 0 record number
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE gotop		&& Go to the first record in the cursor
		*++
		*>>Go to the first record in the cursor
		*--
		  THIS.nLastError = 0
		  IF USED(THIS.cWorkarea)
		    IF NOT EMPTY(FILTER(THIS.cWorkarea)) AND NOT EMPTY(ORDER(THIS.cWorkarea))
		      * Used optimized navigation for filtered cursors with indexes.
		      LOCAL nSelect
		      m.nSelect = SELECT()
		      SELECT (THIS.cWorkarea)
		      LOCATE
		      SELECT (m.nSelect)
		    ELSE
		      GOTO TOP IN (THIS.cWorkarea)
		    ENDIF
		    RETURN EMPTY(THIS.nLastError)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Init
		*++
		*>>Codemine Data Access class.
		*
		* Copyright 2000-2002 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		  * Create runtime internal-use-only properties now. These are not available at design time.
		  THIS.AddProperty('cFilePath', '')                    && Full path of cursor file, used for error messages.
		  THIS.AddProperty('uSavedPosition', .NULL.)           && Saved record position accross multi-record operations.
		  THIS.AddProperty('lSavedByRecno')                    && Saved position is a record number
		  THIS.AddProperty('cWorkarea', THIS.Parent.cWorkarea) && Workarea alias this access object operates on
		
		  DODEFAULT()
		
	ENDPROC

	PROCEDURE ischanged		&& Returns true if any record in the cursor contains uncommited changes.
		*++
		*>>Returns true if any record in the cursor contains uncommited changes.
		*--
		  IF USED(THIS.cWorkarea) AND CURSORGETPROP('Buffering', THIS.cWorkarea) > 1
		    * Check for changes in direct tables and updateable views. Any changes to non-updateable 
		    * views don't count for anything, since they cannot be saved.
		    IF CURSORGETPROP('SourceType', THIS.cWorkarea) == 3 ;
		    OR CURSORGETPROP('SendUpdates', THIS.cWorkarea) OR THIS.Parent.nNonUpdateableMode == 2
		      IF NOT EOF(THIS.cWorkarea) ;
		      AND (GETFLDSTATE(0, THIS.cWorkarea) > 1 OR '2' $ GETFLDSTATE(-1, THIS.cWorkarea))
		        IF FILE('fieldname.cfg')
		           lcfields = GETFLDSTATE(-1,this.cworkarea)
		           lnField  = ATC('2',lcfields)
		           IF lnField = 0
		              lnfield = ATC('4',lcfields)
		           ENDIF 
		           lcfield = FIELD(lnfield-1,this.cworkarea)
		           WAIT WINDOW 'Changed Field = ' + ALLTRIM(this.cworkarea)+':'+lcfield
		        ENDIF 
		        RETURN .T.
		      ENDIF
		
		      * If table buffered, check other records for outstanding changes
		      IF CURSORGETPROP('Buffering', THIS.cWorkarea) > 3 AND GETNEXTMODIFIED(0, THIS.cWorkarea) != 0
		         IF FILE('fieldname.cfg')
		            WAIT WINDOW 'Changed Record #: ' + TRANSFORM(GETNEXTMODIFIED(0,this.cworkarea))
		         ENDIF    
		        RETURN .T.
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isdeleted		&& Determine if the current record has been marked deleted.
		*++
		*>>Determine if the current record has been marked deleted.
		*--
		  RETURN DELETED(THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE isempty		&& Determine whether or not the cursor has any non-deleted records.
		*++
		*>>Determine whether or not the cursor has any non-deleted records.
		*--
		  * If a filter or SET KEY is in effect, eof() and bof() should both be set if no records match.
		  * Unfortunately, this is not alway true, as VFP only *sometimes* sets BOF()...
		  IF USED(THIS.cWorkarea)
		    IF EOF(THIS.cWorkarea)
		      LOCAL lEmpty
		      IF BOF(THIS.cWorkarea)
		        RETURN .T.
		      ENDIF
		      SKIP -1 IN THIS.cWorkarea
		      IF EOF(THIS.cWorkarea)
		        RETURN .T.
		      ENDIF
		      SKIP 1 IN THIS.cWorkarea
		    ENDIF
		    RETURN .F.  && If not at EOF(), then there is at least one undeleted record.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE iseof		&& Determine whether or not the cursor is at EOF.
		*++
		*>>Determine whether or not the cursor is at EOF.
		*--
		  RETURN NOT USED(THIS.cWorkarea) OR EOF(THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE isexclusive		&& Return the current exclusive setting.
		*++
		*>>Return the current exclusive setting.
		*--
		  RETURN USED(THIS.cWorkarea) AND ISEXCLUSIVE(THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE isfield		&& Return true if the specified field name is present in this cursor
		LPARAMETERS cField
		*++
		*>>Return true if the specified field name is present in this cursor
		*--
		  RETURN NOT EMPTY(m.cField) AND FSIZE(m.cField, THIS.cWorkarea) > 0
		
	ENDPROC

	PROCEDURE isfieldchanged		&& Returns true if the specified field in the current record has been changed.
		LPARAMETERS cField
		*++
		*>>Returns true if the specified field in the current record has been changed.
		*--
		  IF CURSORGETPROP('Buffering', THIS.cWorkarea) > 1
		    RETURN NOT EVALUATE(THIS.cWorkarea + '.' + m.cField) == OLDVAL(m.cField, THIS.cWorkarea) ;
		        OR ISNULL(EVALUATE(THIS.cWorkarea + '.' + m.cField)) != ISNULL(OLDVAL(m.cField, THIS.cWorkarea))
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isnew		&& Determine if the current record is a Newly buffered record; existing only in the local update buffer.
		*++
		*>>Determine if the current record is a Newly buffered record; existing only in the local update buffer.
		*--
		  IF NOT EOF(THIS.cWorkarea) AND THIS.GetBufferMode() > 1
		    RETURN (GETFLDSTATE(0, THIS.cWorkarea) > 2 ;
		        OR (THIS.Parent.lRecycleRecords AND GETFLDSTATE(0, THIS.cWorkarea) > 1))
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isopen		&& Return true if the cursor is Open.
		*++
		*>>Return true if the cursor is Open.
		*--
		  RETURN USED(THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE isprimarykeyupdateable		&& Determine if primary key field is updateable. Always true for native VFP tables.
		*++
		*>>Determine if primary key field is updateable. Always true for native VFP tables.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE isreadonly		&& Determine if the cursor is read-only.
		*++
		*>>Determine if the cursor is read-only.
		*--
		  IF NOT USED(THIS.cWorkarea) OR ISREADONLY(THIS.cWorkarea)
		    RETURN .T.
		  ENDIF
		
		  IF THIS.Parent.nNonUpdateableMode = 0 AND CURSORGETPROP('SourceType', THIS.cWorkarea) < 3 ;
		  AND NOT CURSORGETPROP('SendUpdates', THIS.cWorkarea)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isrecordchanged		&& Returns true if the current record contains uncommited changes.
		*++
		*>>Returns true if the current record contains uncommited changes.
		*--
		  IF USED(THIS.cWorkarea) AND CURSORGETPROP('Buffering', THIS.cWorkarea) > 1
		    * Check for changes in direct tables and updateable views. Any changes to non-updateable 
		    * views don't count for anything, since they cannot be saved.
		    IF CURSORGETPROP('SourceType', THIS.cWorkarea) == 3 ;
		    OR CURSORGETPROP('SendUpdates', THIS.cWorkarea) OR THIS.Parent.nNonUpdateableMode = 2
		      IF NOT EOF(THIS.cWorkarea) ;
		      AND (GETFLDSTATE(0, THIS.cWorkarea) > 1 OR '2' $ GETFLDSTATE(-1, THIS.cWorkarea))
		        RETURN .T.
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE localtransclear		&& Clear all local transaction rollback buffers for levels at or above the specified level.
		LPARAMETERS nTranLevel, nRecno
		*++
		*>>Clear all local transaction rollback buffers for levels at or above the specified level.
		*--
		LOCAL ix
		  IF PEMSTATUS(THIS, 'nLocalTransCount', 5)
		    IF NOT EMPTY(m.nRecno)
		      * Clear rollback data for the specified record only.
		      FOR ix = 1 TO THIS.nLocalTransCount
		        IF THIS.aLocalTrans[m.ix, 3] >= CHR(m.nTranLevel) AND THIS.aLocalTrans[m.ix, 1] = m.nRecno
		          THIS.aLocalTrans[m.ix, 1] = 0
		          THIS.aLocalTrans[m.ix, 2] = .NULL.
		        ENDIF
		      ENDFOR
		    ELSE
		      * Rollback data is added to the array with lowest levels first, so once we find the
		      * first row at desired level, all remaining rows are sure to match also.
		      FOR ix = 1 TO THIS.nLocalTransCount
		        IF THIS.aLocalTrans[m.ix, 3] >= CHR(m.nTranLevel)
		          THIS.nLocalTransCount = m.ix - 1
		          EXIT
		        ENDIF
		      ENDFOR
		
		      IF THIS.nLocalTransCount > 0
		        DIMENSION THIS.aLocalTrans[THIS.nLocalTransCount, 3]
		      ELSE
		        DIMENSION THIS.aLocalTrans[1, 3]    && Col1=Recno, Col2=DataRef, Col3=Tranlevel
		        THIS.aLocalTrans = .F.
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE localtransjoin		&& Add the current table/view record to a local transaction at the specified level.
		LPARAMETERS nTranLevel, nFlags
		*++
		*>>Add the current table/view record to a local transaction at the specified level.
		*--
		LOCAL ix, nRecno
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  m.nRecno = RECNO(THIS.cWorkarea)
		  IF PEMSTATUS(THIS, 'nLocalTransCount', 5)
		    * See if there is already an entry for this record at this transaction level.
		    m.ix = 1
		    DO WHILE .T.
		      m.ix = ASCAN(THIS.aLocalTrans, m.nRecno, m.ix)
		      IF m.ix = 0 OR THIS.aLocalTrans[m.ix + 2] == CHR(m.nTranLevel)
		        EXIT           && No match, or Recno and transLevel both match
		      ENDIF
		      m.ix = m.ix + 1  && Recno matches, but level doesn't. Keep looking.
		    ENDDO
		  ELSE
		    THIS.AddProperty('aLocalTrans[1,3]')       && Col1=Recno, Col2=DataRef, Col3=Tranlevel
		    THIS.AddProperty('nLocalTransCount', 0)    && Total Number of rows defined in aLocalTrans[]
		  ENDIF
		
		  * If ix is not empty, then the current record's rollback info is already stored in the array.
		  IF NOT EMPTY(m.ix)
		    * The RevertOnRollback flag bit means clear any previous rollback info saved for the record.
		    * Used for new buffered records appended within a local transaction.
		    IF NOT EMPTY(BITAND(m.nFlags, LOCALTRANS_REVERT_ON_ROLLBACK))
		      THIS.aLocalTrans[m.ix + 1] = .NULL.
		    ENDIF
		
		    * A buffered new record was reverted. Need to re-Create the new record on rollback.
		    IF NOT EMPTY(BITAND(m.nFlags, LOCALTRANS_NO_RECORD))
		      THIS.aLocalTrans[m.ix] = 0
		    ENDIF
		  ELSE
		    * Row modes reuse single row for each level. Table buffered modes use multiple rows.
		    IF THIS.nLocalTransCount = 0 OR CURSORGETPROP('Buffering', THIS.cWorkarea) >= 4 ;
		    OR NOT THIS.aLocalTrans[THIS.nLocalTransCount, 3] == CHR(m.nTranLevel)
		      THIS.nLocalTransCount = THIS.nLocalTransCount + 1   && Add a new row
		      DIMENSION THIS.aLocalTrans[THIS.nLocalTransCount, 3]
		    ENDIF
		
		    IF NOT EMPTY(BITAND(m.nFlags, LOCALTRANS_NO_RECORD))
		      * A buffered new record was reverted. Need to re-Create the new record on rollback.
		      THIS.aLocalTrans[THIS.nLocalTransCount, 1] = 0
		    ELSE
		      THIS.aLocalTrans[THIS.nLocalTransCount, 1] = m.nRecno
		    ENDIF
		    THIS.aLocalTrans[THIS.nLocalTransCount, 2] = .NULL.
		    THIS.aLocalTrans[THIS.nLocalTransCount, 3] = CHR(m.nTranLevel)
		
		    IF EMPTY(BITAND(m.nFlags, LOCALTRANS_REVERT_ON_ROLLBACK))
		      IF (CURSORGETPROP('Buffering', THIS.cWorkarea) = 1 ;
		      OR GETFLDSTATE(0, THIS.cWorkarea) > 2 OR '2' $ GETFLDSTATE(-1, THIS.cWorkarea))
		        m.nSelect = SELECT()
		        SELECT (THIS.cWorkarea)
		        SCATTER NAME THIS.aLocalTrans[THIS.nLocalTransCount, 2] MEMO
		        SELECT (m.nSelect)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE localtransrollback		&& Roll back the current local transaction level. Supports both row and table buffer modes.
		LPARAMETERS nTranLevel
		*++
		*>>Roll back the current local transaction level. Supports both row and table buffer modes.
		*--
		LOCAL ix, nSelect
		  IF PEMSTATUS(THIS, 'nLocalTransCount', 5)
		    FOR ix = 1 TO THIS.nLocalTransCount
		      IF THIS.aLocalTrans[m.ix, 3] == CHR(m.nTranLevel)
		        * For table-buffered cursors (mode >=4), find the record, and re-create if gone.
		        IF CURSORGETPROP('Buffering', THIS.cWorkarea) >= 4
		          IF EMPTY(THIS.aLocalTrans[m.ix, 1]) ;
		          OR NOT (THIS.aLocalTrans[m.ix, 1] == RECNO(THIS.cWorkarea) OR THIS.Goto(THIS.aLocalTrans[m.ix, 1]))
		            * A buffered new record existed before transaction started, and was since reverted.
		            * Re-create the record here. Contents of record will be restored by GATHER below.
		            IF ISNULL(THIS.aLocalTrans[m.ix, 2])
		              LOOP   && Nothing to restore here. Move on to next row.
		            ELSE
		              APPEND BLANK IN (THIS.cWorkarea)
		            ENDIF
		          ENDIF
		        ELSE
		          IF NOT THIS.aLocalTrans[m.ix, 1] = RECNO(THIS.cWorkarea)
		            EXIT   && Somebody moved record in row-buffered mode, so restore is no longer possible.
		          ENDIF
		        ENDIF
		
		        IF ISNULL(THIS.aLocalTrans[m.ix, 2])
		          THIS.RevertRecord()
		        ELSE
		          m.nSelect = SELECT()
		          SELECT (THIS.cWorkarea)
		          GATHER NAME THIS.aLocalTrans[m.ix, 2] MEMO
		          SELECT (m.nSelect)
		        ENDIF
		      ENDIF
		    ENDFOR
		
		    * Release saved record state information once we are done with it.
		    THIS.LocalTransClear(m.nTranLevel)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE lockrecord		&& Obtain network Lock for the specified record.
		LPARAMETERS nRecno
		*++
		*>>Obtain network Lock for the specified record.
		*--
		LOCAL lStatus, nLockRetries, cRecordList
		
		  * Process the record number parameter.
		  IF VARTYPE(m.nRecno) $ 'NI'
		    m.cRecordList = LTRIM(STR(m.nRecno))
		  ELSE
		    m.cRecordList = LTRIM(STR(RECNO(THIS.cWorkarea)))    && Default to current record
		  ENDIF
		
		  SET REPROCESS TO 1
		  DO WHILE NOT m.lStatus
		    m.lStatus = RLOCK(m.cRecordList, THIS.cWorkarea)
		    IF NOT m.lStatus AND NOT THIS._WaitForLock(@m.nLockRetries)
		      EXIT
		    ENDIF
		  ENDDO
		  IF NOT EMPTY(m.nLockRetries) AND NOT ISNULL(THIS.oMessage)
		    THIS.oMessage.StatusClear()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*++
		*>>Return the nErrorMode value from the highest level available container.
		*--
		  * Access object always uses the parent cursor's property
		  RETURN THIS.Parent.nErrorMode
		
	ENDPROC

	PROCEDURE nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		LPARAMETERS nValue
		*++
		*>>Set the nErrorMode property in the highest level available container.
		*--
		  * Access object always uses the parent cursor's property
		  THIS.Parent.nErrorMode = m.nValue
		
	ENDPROC

	PROCEDURE new		&& Add a new record to the record set.
		*++
		*>>Add a new record to the record set.
		*--
		LOCAL ix, nSelect, lRecycled, cDeleted, cKey
		
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		
		  * Save record pointer to restore to if this neword is discarded before being saved.
		  IF NOT EOF()
		    THIS.Parent.nOldRecord = RECNO()
		  ENDIF
		
		  IF THIS.Parent.lRecycleRecords AND CURSORGETPROP('SourceType') = 3
		    * See if there is an existing index for DELETED()
		    m.ix = 1
		    m.cDeleted = SET('DELETED')
		
		    IF NOT EMPTY(ORDER())
		      m.cKey = THIS._GetKeyFilter()
		      SET KEY TO
		    ENDIF
		    DO WHILE NOT EMPTY(KEY(m.ix))
		      IF NORMALIZE(KEY(m.ix)) == 'DELETED()'
		        SET DELETED OFF
		        SCAN FOR DELETED()
		          * Only consider records not modified in current table buffer.
		          * Try to lock it, but only once. If can't lock deleted record someone else
		          * is in the process of recalling it.
		          IF GETFLDSTATE(0) = 1 AND RLOCK()
		            m.lRecycled = .T.
		            EXIT
		          ENDIF
		        ENDSCAN
		      ENDIF
		      m.ix = m.ix + 1
		    ENDDO
		    SET DELETED &cDeleted
		
		    * Re-Apply original SET KEY filter, if any
		    THIS._SetKeyFilter(m.cKey)
		  ENDIF
		
		  IF m.lRecycled
		    LOCAL nFields, aInfo[1]
		
		    * Blank out entire contents of recycled record before using it.
		    * Un-delete the record, after blanking is committed, so a cancel will leave record deleted.
		    BLANK
		    =TABLEUPDATE(0, .T.)
		    RECALL    && Undelete record, which also leaves it marked as modified.
		
		    * Apply DBC level field defaults to the recalled record, just as if it were newly appended.
		    m.nFields = AFIELDS(aInfo)
		    FOR ix = 1 TO m.nFields
		      IF NOT EMPTY(aInfo[m.ix, 9])
		        REPLACE (aInfo[m.ix, 1]) WITH EVALUATE(aInfo[m.ix, 9])
		      ENDIF
		    ENDFOR
		  ELSE
		    APPEND BLANK
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE oldvalue		&& Return the old value of the specified field
		LPARAMETERS cField
		*++
		*>>Return the old value of the specified field
		*--
		  RETURN OLDVAL(m.cField, THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE open		&& Open the cursor, and leave it as the current workarea (for native VFP cursors).
		LPARAMETERS cFile, nBufferMode
		*++
		*>>Open the cursor, and leave it as the current workarea (for native VFP cursors).
		*--
		LOCAL cOptions
		
		    THIS.nLastError = 0
		    THIS.nLastSqlError = 0
		    THIS.cFilePath = m.cFile
		
		    IF NOT EMPTY(THIS.cWorkarea) AND USED(THIS.cWorkarea)
		      * If cursor is already open, we just select the existing alias
		      SELECT (THIS.cWorkarea)
		    ELSE
		      SELECT 0
		      m.cOptions = THIS.OpenOptions()
		
		      * Check for an "included" table embedded in a plugin app file.
		      IF '::' $ m.cFile
		        LOCAL oPlugin, cPluginApp
		        m.cPluginApp = LEFT(m.cFile, AT('::', m.cFile) - 1)
		        m.cFile = SUBSTR(m.cFile, AT('::', m.cFile) + 2)
		        m.oPlugin = FindGlobalObject('cmPluginManager')
		        IF NOT ISNULL(m.oPlugin) AND m.oPlugin.IsPluginLoaded(m.cPluginApp)
		          IF EMPTY(THIS.cWorkarea)
		            THIS.cWorkarea = JUSTSTEM(m.cFile)
		          ENDIF
		          DO ('OpenTable') IN (m.cPluginApp) WITH m.cFile, THIS.cWorkarea
		          IF NOT USED(THIS.cWorkarea)
		            RETURN .F.
		          ENDIF
		          m.cFile = ''   && Clear file name to indicate already opened.
		        ENDIF
		      ENDIF
		
		      IF NOT EMPTY(m.cFile)
		        * If specified, add the database prefix to the table name to ensure we
		        * get the correct table. Otherwise, we might find a different copy of 
		        * a table with the same name that is not part of the specified DBC.
		        IF NOT EMPTY(THIS.Parent.cDatabase)
		          m.cFile = THIS.Parent.cDatabase + '!' + JUSTSTEM(m.cFile)
		        ENDIF
		
		        * Need to enclose in quotes to allow for path elements that might contain spaces.
		        m.cFile = ["] + m.cFile + ["]
		        IF NOT EMPTY(THIS.cWorkarea)
		          USE &cFile AGAIN &cOptions ALIAS (THIS.cWorkarea)
		        ELSE
		          USE &cFile AGAIN &cOptions
		          STORE PROPER(ALIAS()) TO THIS.cWorkarea, THIS.Parent.cWorkarea
		        ENDIF
		      ENDIF
		    ENDIF
		
		    * Set the specified index order and filter, if any.
		    IF USED(THIS.cWorkarea)
		      THIS.cFilePath = DBF()
		      IF CURSORGETPROP('SourceType', THIS.cWorkarea) = 3
		        * cOrder property only applies to native tables - not to views.
		        IF NOT EMPTY(THIS.Parent.cOrder)
		          SET ORDER TO (THIS.Parent.cOrder)
		        ENDIF
		      ENDIF
		      IF NOT EMPTY(THIS.Parent.cFilter)
		        THIS.SetFilter(THIS.Parent.cFilter)
		      ELSE
		        THIS.GoTop()
		      ENDIF
		
		      * Set the desired buffering mode, and return.
		      THIS.SetBufferMode(m.nBufferMode)
		    ENDIF
		    RETURN EMPTY(THIS.nLastError)
		
	ENDPROC

	PROCEDURE openconnection		&& Open the connection specified in the parent's cConnection property. Returns the conneciton handle.
		*++
		*>>Open the connection specified in the parent's cConnection property. Returns the conneciton handle.
		*--
		  WITH THIS.Parent
		    ASSERT NOT EMPTY(.cConnection) ;
		               MESSAGE 'Cannot Connect - The cConnection property must be set for ' + .cDisplayName
		
		    IF NOT EMPTY(.cConnection)
		      * Create a default instance of the connection manager if none exists already.
		      IF ISNULL(.oConnMan)
		        .oConnMan = CreateNewObject('cmConnectionManager')
		      ENDIF
		      RETURN .oConnMan.Connect(.cConnection, .lShareConnection)
		    ENDIF
		  ENDWITH
		  RETURN 0   && Zero return on error.
		
	ENDPROC

	PROCEDURE openoptions		&& Return a list of USE command clauses to apply to the cursor about to be opened.
		*++
		*>>Return a list of USE command clauses to apply to the cursor about to be opened.
		*--
		LOCAL cOptions
		
		  m.cOptions = IIF(THIS.Parent.lExclusive, 'EXCLUSIVE ', 'SHARED ')
		  IF THIS.Parent.lReadonly
		    m.cOptions = m.cOptions + 'NOUPDATE '
		  ENDIF
		  IF THIS.Parent.lNoDataOnLoad
		    m.cOptions = m.cOptions + 'NODATA '
		  ENDIF
		  RETURN m.cOptions
		
	ENDPROC

	PROCEDURE pack		&& Pack the table, removing deleted records. Applies to native VFP tables only.
		LPARAMETERS cOption
		*++
		*>>Pack the table, removing deleted records. Applies to native VFP tables only.
		*--
		  RETURN .F.
		
	ENDPROC

	PROCEDURE parentkeychanged		&& Update the FK for all records related to current parent recored, after the parent's PK was changed.
		*++
		*>>Update the FK for all records related to current parent recored, after the parent's PK was changed.
		*--
		LOCAL nRecno, nTmpRecno
		
		  * This cursor (child) must be table-buffered to make any changes to the FK.
		  IF THIS.GetBuffermode() > 3
		    * Save original record pointer, and move to first child record to change.
		    m.nRecno = THIS.Recno()
		
		    * Since key is changing, and record set is filtered by key, normal SCAN loops aren't reliable.
		    THIS.GoTop()  && Use access level call to avoid affecting related grandchildren
		    DO WHILE NOT THIS.IsEof()
		      THIS.Parent.SetForeignKey()
		
		      * Once key has changed, current record will be filtered out, so next top record becomes current.
		      m.nTmpRecno = THIS.Recno()
		      THIS.GoTop()
		      IF m.nTmpRecno = THIS.Recno()
		        EXIT   && If we are still on the same record, key hasn't changed, so exit now.
		      ENDIF
		    ENDDO
		    THIS.Goto(m.nRecno)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE primarykeychanged		&& Reset child foriegn keys. A No-op for all but native VFP tables.
		*++
		*>>Reset child foriegn keys. A No-op for all but native VFP tables.
		*--
		  RETURN .F.
		
	ENDPROC

	PROCEDURE reccount		&& Return the total number of records in the cursor
		*++
		*>>Return the total number of records in the cursor
		*--
		  RETURN RECCOUNT(THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE recno		&& Return the current record number, or 0 if there is no current record (EOF).
		*++
		*>>Return the current record number, or 0 if there is no current record (EOF).
		*--
		  RETURN IIF(EOF(THIS.cWorkarea), 0, RECNO(THIS.cWorkarea))
		
	ENDPROC

	PROCEDURE refreshdata		&& Refresh data in the current row of the cursor.
		*++
		*>>Refresh data in the current row of the cursor.
		*--
		  * This only works for views...
		  RETURN REFRESH(1, 0, THIS.cWorkarea) != 0
		
	ENDPROC

	PROCEDURE reindex		&& Regenerate all existing indexes. Applies to native VFP tables only.
		*++
		*>>Regenerate all existing indexes. Applies to native VFP tables only.
		*--
		LOCAL nBuffer
		  SELECT (THIS.cWorkarea)
		  IF THIS.IsExclusive()
		    m.nBuffer = THIS.GetBufferMode()
		    IF m.nBuffer > 3
		      THIS.SetBufferMode(3)
		    ENDIF
		    REINDEX
		    THIS.SetBufferMode(m.nBuffer)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE replace		&& Set the value of the specified field.
		LPARAMETERS cField, uValue
		*++
		*>>Set the value of the specified field.
		*--
		LOCAL uOriginal
		  THIS.nLastError = 0
		
		  * Save original value in case we need to fall back.
		  m.uOriginal = EVALUATE(THIS.cWorkarea + '.' + m.cField)
		
		  * This may trigger a field's DBC validation rule.
		  REPLACE (m.cField) WITH (m.uValue) IN (THIS.cWorkarea)
		
		  * Restore original value and return failure on DBC rule violation.
		  IF NOT EMPTY(THIS.nLastError)
		    * If original value is the same as the value that triggered the error, there's nothing we can do.
		    IF NOT THIS._IsEqual(m.uValue, m.uOriginal)
		      REPLACE (m.cField) WITH (m.uOriginal) IN (THIS.cWorkarea)
		    ENDIF
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE requery		&& Requery the view.
		*++
		*>>Requery the view.
		* All parameter variables for parameterized views should be defined as PRIVATE
		* before calling this method, so they will be in scope for the REQUERY() function.
		*--
		LOCAL lStatus, lAutoYield
		
		  THIS.nLastError = 0
		  IF CURSORGETPROP('SourceType', THIS.cWorkarea) < 3
		    m.lAutoYield = _VFP.AutoYield
		    IF NVL(THIS.Parent.lAllowAbort, .F.)
		      _VFP.AutoYield = .T.  && Allow escape to interrupt query, if desired.
		    ENDIF
		    m.lStatus = (REQUERY(THIS.cWorkarea) != 0)
		    _VFP.AutoYield = m.lAutoYield
		    THIS.GoTop()
		    RETURN m.lStatus AND EMPTY(THIS.nLastError)  && Returns .F. if requery fails
		  ENDIF
		  RETURN .T.   && If its a native table, then requery() is a no-op.
		
	ENDPROC

	PROCEDURE restoreposition		&& Restore record pointer to the last saved value if possible.
		*++
		*>>Restore record pointer to the last saved value if possible.
		*--
		  LOCAL lStatus
		  IF NOT ISNULL(THIS.uSavedPosition)
		    IF THIS.lSavedByRecno
		      IF THIS.uSavedPosition <= RECCOUNT(THIS.cWorkarea)
		        THIS.SetErrorMode(ERRMASK_SILENT_FATAL)   && Don't display error if the record doesnt exist.
		        IF NOT THIS.uSavedPosition == RECNO(THIS.cWorkarea)
		          GOTO THIS.uSavedPosition IN (THIS.cWorkarea)
		        ENDIF
		        m.lStatus = EMPTY(THIS.nLastError)
		        THIS.SetErrorMode()                       && Back to displaying all errors.
		      ENDIF
		    ELSE
		      LOCAL cPriKey, nSelect, lDeletedOn 
		      * Restore record by primary key expression.
		      IF RECCOUNT(THIS.cWorkarea) > 0   && LOCATE will error on an empty recordset
		        m.nSelect = SELECT()
		        m.lDeletedOn = SET('DELETE') == 'ON'
		        SELECT (THIS.cWorkarea)
		        SET DELETED OFF
		        m.cPriKey = THIS.Parent.cPrimaryKeyField
		        IF NOT &cPriKey == THIS.uSavedPosition
		          LOCATE FOR &cPriKey == THIS.uSavedPosition
		        ENDIF
		        m.lStatus = NOT EOF()
		        IF m.lDeletedOn
		          SET DELETED ON
		        ENDIF
		        SELECT (m.nSelect)
		      ENDIF
		    ENDIF
		    THIS.uSavedPosition = .NULL.
		
		    IF NOT m.lStatus    && If Couldn't find original record. 
		      IF NOT THIS.IsEmpty()
		        * Try record position saved before last new record appended. If none, goto top.
		        * Note that nOldRecord may now be invalid, so we need to test for error.
		        THIS.SetErrorMode(ERRMASK_SILENT_FATAL)   && Don't display error if the record doesnt exist.
		        IF EMPTY(THIS.Parent.nOldRecord) OR NOT THIS.Parent.GoTo(THIS.Parent.nOldRecord)
		          THIS.Parent.GoTop()
		        ENDIF
		        THIS.SetErrorMode()                       && Back to displaying all errors.
		      ENDIF
		    ELSE
		      * Found the original record. If it is now deleted, skip to nearest undeleted record.
		      IF DELETED(THIS.cWorkarea)
		        m.lStatus = .F.  && Original record no good any more, so restoration fails
		        THIS.Parent.Skip(1)
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE revert		&& Discard all buffered changes to this cursor.
		LPARAMETERS nFlags
		*++
		*>>Discard all buffered changes to this cursor.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_OBEY_SETKEY     8  For Table-buffered child tables, obey SET KEY restrictions
		*--
		LOCAL nThisRec, lSetKey, nSelect
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF CURSORGETPROP('Buffering', THIS.cWorkarea) > 1
		    * Always revert current record first, to avoid posibility of DBC rule errors on movement
		    THIS.RevertRecord(m.nFlags)
		
		    * If table-buffered, check for other records with outstanding changes
		    IF CURSORGETPROP('Buffering', THIS.cWorkarea) > 3
		      * Determine if this is a child table that should respect SET KEY filter.
		      m.nSelect = SELECT()
		      SELECT (THIS.cWorkarea)
		      m.lSetKey = NOT EMPTY(BITAND(m.nFlags, UPDATEMASK_OBEY_SETKEY)) ;
		        AND NOT ISNULL(THIS.Parent.oParent) AND NOT EMPTY(SET('KEY', 1)) ;
		        AND CURSORGETPROP('SourceType', THIS.cWorkarea) = 3
		
		      m.nThisRec = GETNEXTMODIFIED(0)
		      DO WHILE NOT EMPTY(m.nThisRec)
		        GO m.nThisRec
		        * If ignoring SET KEY filter, or filter matches, revert the record.
		        IF NOT m.lSetKey OR EVALUATE(KEY()) == THIS._GetKeyValue()
		          THIS.RevertRecord(m.nFlags)
		        ENDIF
		        m.nThisRec = GETNEXTMODIFIED(m.nThisRec)
		      ENDDO
		      SELECT (m.nSelect)
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE revertrecord		&& Discard all buffered changes to this cursor.
		LPARAMETERS nFlags
		*++
		*>>Discard all buffered changes to this cursor.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOUNLOCK         16 Don't release any locks
		*--
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF NOT EOF(THIS.cWorkarea)
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOUNLOCK)) AND NOT THIS.Isnew()
		      THIS.UnLockRecord()
		    ENDIF
		    IF CURSORGETPROP('buffering', THIS.cWorkarea) > 1
		      TABLEREVERT(.F., THIS.cWorkarea)
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE saveposition		&& Save current record pointer position.
		*++
		*>>Save current record pointer position.
		*--
		LOCAL cPriKey, nSelect, lSavedNew
		
		  THIS.uSavedPosition = .NULL.
		  m.lSavedNew = THIS.IsNew()
		  m.cPriKey = THIS.Parent.cPrimaryKeyField    && May trigger access method
		  IF NOT EMPTY(m.cPriKey)
		    THIS.lSavedByRecno = .F.
		    m.nSelect = SELECT()
		    SELECT (THIS.cWorkarea)
		    THIS.uSavedPosition = EVALUATE(m.cPriKey)
		    SELECT (m.nSelect)
		  ENDIF
		
		  * If no primary key, or PK value is empty, use record number.
		  IF ISNULL(THIS.uSavedPosition) OR (m.lSavedNew AND EMPTY(THIS.uSavedPosition))
		    THIS.lSavedByRecno = .T.
		    THIS.uSavedPosition = RECNO(THIS.cWorkarea)
		  ENDIF
		  RETURN THIS.uSavedPosition
		
	ENDPROC

	PROCEDURE seek		&& Seek the record matching the specified key in the cursor.
		LPARAMETERS uKey, cIndex
		*++
		*>>Seek the record matching the specified key in the cursor.
		*--
		LOCAL ix, nRecno, nSelect
		  THIS.nLastError = 0
		  m.nRecno = RECNO(THIS.cWorkarea)  && Restore on failure
		
		  * Find a default index tag to use if none specified. PK is default.
		  IF EMPTY(m.cIndex)
		    m.nSelect  = SELECT()
		    SELECT (THIS.cWorkarea)
		    FOR ix = 1 TO TAGCOUNT(STRTRAN(DBF(), '.DBF', '.CDX'))
		      IF PRIMARY(m.ix)
		        m.cIndex = TAG(m.ix)
		        EXIT
		      ENDIF
		      IF EMPTY(m.cIndex) AND CANDIDATE(m.ix)
		        m.cIndex = TAG(m.ix)  && Use candidate only if no PK
		      ENDIF
		    ENDFOR
		    SELECT (m.nSelect)
		  ENDIF
		
		  ASSERT NOT EMPTY(m.cIndex) MESSAGE 'Seek() method requires cIndex Parameter if no Primary Index exists.'
		  IF SEEK(m.uKey, THIS.cWorkarea, m.cIndex)
		    RETURN .T.
		  ENDIF
		
		  * Restore original record position on error
		  IF m.nRecno <= RECCOUNT(THIS.cWorkarea)
		    GOTO (m.nRecno) IN (THIS.cWorkarea)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE select		&& Restrict our recordset to only those matching the current parent record
		*++
		*>>Restrict our recordset to only those matching the current parent record
		*--
		  * Code is in type-specific subclasses
		
	ENDPROC

	PROCEDURE setbuffermode		&& Set the buffering mode for this cursor
		LPARAMETERS nMode
		*++
		*>>Set the buffering mode for this cursor
		*--
		  RETURN CURSORSETPROP('Buffering', MAX(1, m.nMode), THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE setdefault		&& Set this cursor as the curernt VFP workarea (if it is a native VFP cursor).
		*++
		*>>Set this cursor as the curernt VFP workarea (if it is a native VFP cursor).
		*--
		  IF USED(THIS.cWorkarea)
		    SELECT (THIS.cWorkarea)
		  ENDIF
		
	ENDPROC

	PROCEDURE setexclusive		&& Set the exclusive acces mode to exclusive or shared.
		LPARAMETERS lExclusive
		*++
		*>>Set the exclusive acces mode to exclusive or shared.
		*--
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setfilter		&& Set the record filter expression for the cursor.
		LPARAMETERS cFilter
		*++
		*>>Set the record filter expression for the cursor.
		*--
		LOCAL nSelect
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		  SET FILTER TO &cFilter
		
		  * A VFP bug can prevent proper enforcement of filter by GO TOP on newly opened views USEd again. 
		  * Forcing to last record & back to top seems to work around the problem by forcing the cursor to a matching record.
		  LOCATE
		  IF EOF() AND RECNO() < RECCOUNT()
		    GOTO (RECCOUNT())
		    LOCATE
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setorder		&& Set the sort order to the specified tag/field.
		LPARAMETERS cOrder, cDirection
		*++
		*>>Set the sort order to the specified tag/field.
		*--
		  IF EMPTY(m.cDirection)
		    SET ORDER TO TAG (m.cOrder) IN (THIS.cWorkarea)
		  ELSE
		    SET ORDER TO TAG (m.cOrder) IN (THIS.cWorkarea) &cDirection
		  ENDIF
		
	ENDPROC

	PROCEDURE setposition		&& Set the current record position - by record number for tables.
		LPARAMETERS uPosition
		*++
		*>>Set the current record position - by record number for tables.
		*
		* The uPosition parameter is normally a values previously returned by the GetPosition() method.
		*--
		  RETURN THIS.Parent.Goto(m.uPosition)
		
	ENDPROC

	PROCEDURE setpositionflags		&& Set record position flags for a cursor.
		*++
		*>>Set record position flags for a cursor.
		*--
		LOCAL nRecno
		  WITH THIS.Parent
		    m.nRecno = RECNO(THIS.cWorkarea)
		 
		    IF EOF(THIS.cWorkarea)
		      .nCursorFlags = BITSET(.nCursorFlags, CURSORFLAG_BOTTOM)
		    ELSE
		      SKIP 1 IN (THIS.cWorkarea)
		      IF EOF(THIS.cWorkarea)
		        .nCursorFlags = BITSET(.nCursorFlags, CURSORFLAG_BOTTOM)
		      ELSE
		        .nCursorFlags = BITCLEAR(.nCursorFlags, CURSORFLAG_BOTTOM)
		      ENDIF
		      GO (m.nRecno) IN (THIS.cWorkarea)
		    ENDIF
		
		    * Now test for BOF. Note the VFP's BOF() flag is not always 
		    * reliable for an empty recordset, although the SKIP -1 command sems to fix it.
		    IF BOF(THIS.cWorkarea)
		      .nCursorFlags = BITSET(.nCursorFlags, CURSORFLAG_TOP)
		    ELSE
		      SKIP -1 IN (THIS.cWorkarea)
		      IF BOF(THIS.cWorkarea)
		        .nCursorFlags = BITSET(.nCursorFlags, CURSORFLAG_TOP)
		      ELSE
		        .nCursorFlags = BITCLEAR(.nCursorFlags, CURSORFLAG_TOP)
		      ENDIF
		
		      * Goto is the fastest way to restore recpos when possible
		      IF m.nRecno <= RECCOUNT(THIS.cWorkarea)
		        GO (m.nRecno) IN (THIS.cWorkarea)
		      ELSE    && Use skip to restore to EOF position
		        IF NOT EOF(THIS.cWorkarea)
		          SKIP 1 IN (THIS.cWorkarea)
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDWITH
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setprop		&& Set various properties for the cursor.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various properties for the cursor.
		*--
		  RETURN CURSORSETPROP(m.cProperty, m.uValue, THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE setrelation		&& Set a relation between two cursors, and set default RI options. A no-op for views and any other non-table cursors.
		LPARAMETERS oParent, cParentKeyField
		*++
		*>>Set a relation between two cursors, and set default RI options. A no-op for views and any other non-table cursors.
		*--
		  IF NOT EMPTY(m.cParentKeyField)
		    * If not explicity set, determine default relation type
		    WITH THIS.Parent   && This cursor object
		      IF ISNULL(.lRequeryWhenParentMoves)
		        .lRequeryWhenParentMoves = .T.
		      ENDIF
		
		      * If not explicity set, determine default delete setting
		      IF ISNULL(.lDeleteWithParent)
		        .lDeleteWithParent = .T.
		      ENDIF
		    ENDWITH
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE skip		&& Skip the specified number of records forward or backwards.
		LPARAMETERS nRecords
		*++
		*>>Skip the specified number of records forward or backwards.
		* Dont allow past EOF or BOF if possible.
		*--
		LOCAL nOriginalRecno, cWorkarea
		
		  THIS.nLastError = 0
		  m.nOriginalRecno = RECNO(THIS.cWorkarea)
		
		  * Use optimized navigation for filtered cursors with indexes.
		  IF NOT EMPTY(FILTER(THIS.cWorkarea)) AND NOT EMPTY(ORDER(THIS.cWorkarea))
		    LOCAL nSelect, lWasDescending
		
		    m.nSelect = SELECT()
		    SELECT (THIS.cWorkarea)
		    LOCATE REST       && Establish a LOCATE context
		    IF NOT EMPTY(THIS.nLastError)
		      RETURN .F.
		    ENDIF
		
		    IF m.nRecords > 0
		      DO WHILE NOT EOF() AND m.nRecords > 0
		        CONTINUE
		        m.nRecords = m.nRecords - 1
		      ENDDO
		      IF EOF()
		        THIS.GoBottom()
		      ENDIF
		    ELSE
		      m.lWasDescending = DESCENDING()
		      SET ORDER TO (ORDER()) DESCENDING
		      DO WHILE NOT BOF() AND m.nRecords < 0
		        CONTINUE
		        m.nRecords = m.nRecords + 1
		      ENDDO
		      IF NOT m.lWasDescending
		        SET ORDER TO (ORDER()) ASCENDING
		      ENDIF
		      IF BOF()
		        THIS.GoTop()
		      ENDIF
		    ENDIF
		    SELECT (m.nSelect)
		  ELSE
		    * No filter in effect, so just use regular skip
		    IF (m.nRecords > 0 AND NOT EOF(THIS.cWorkarea)) ;
		    OR (m.nRecords < 0 AND NOT BOF(THIS.cWorkarea))
		      SKIP m.nRecords IN (THIS.cWorkarea)
		      IF NOT EMPTY(THIS.nLastError)
		        RETURN .F.
		      ENDIF
		    ENDIF
		    IF EOF(THIS.cWorkarea)
		      GO BOTTOM IN (THIS.cWorkarea)
		    ELSE
		      IF BOF(THIS.cWorkarea)
		        GO TOP IN (THIS.cWorkarea)
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Success return if record pointer was moved, and is not left at EOF.
		  RETURN NOT EOF(THIS.cWorkarea) AND (m.nOriginalRecno != RECNO(THIS.cWorkarea))
		
	ENDPROC

	PROCEDURE tableupdate		&& Write changes to source tables via the TABLEUPDATE() function.
		LPARAMETERS nMode
		*++
		*>>Write changes to source tables via the TABLEUPDATE() function.
		*--
		LOCAL lStatus, nLockRetries, lOverwrite
		
		  SET REPROCESS TO 1
		  IF CURSORGETPROP('Buffering', THIS.cWorkarea) > 1
		    DO WHILE NOT m.lStatus
		      * Note that record pointer may move here unexcpectedly if workarea is displayed
		      * in a VFP grid, and delete state is changed.
		      m.lStatus = TABLEUPDATE(m.nMode, m.lOverwrite OR NVL(THIS.Parent.lOverwrite, .F.), THIS.cWorkarea)
		
		      IF NOT m.lStatus
		        LOCAL lResult, aErrInfo[1]
		        =AERROR(aErrInfo)
		
		        * Give custom developer code a chance to respond to the error before default handling.
		        m.lResult = THIS.Parent._ExecuteRule('BeforeUpdateFailure', RULEMASK_ANDED,, aErrInfo[1])
		        IF NOT m.lResult
		          RETURN .F.           && User code processed error. Return failure code.
		        ELSE
		          IF ISNULL(m.lResult)
		            * User code wants to retry. For update errors, this means force update.
		            IF aErrInfo[1] = 1585
		              m.lOverwrite = .T.   && Force overwrite on next try
		            ENDIF
		            LOOP
		          ENDIF
		        ENDIF
		
		        * Standard default error processing.
		        DO CASE
		          CASE aErrInfo[1] = 109    && Lock error
		            IF NOT THIS._WaitForLock(@m.nLockRetries)
		              RETURN .F.
		            ENDIF
		
		          CASE aErrInfo[1] = 1585    && Overwrite changes by another user
		            IF NOT ISNULL(THIS.Parent.lOverwrite)
		              IF THIS.Parent.IsOverwriteAllowed()
		                m.lOverwrite = .T.   && Force overwrite on next try
		              ELSE
		                * Return silently here, relying on the IsOverwriteAllowed() 
		                * method to have already displayed any necessary error/warning message.
		                RETURN .F.
		              ENDIF
		            ELSE
		              IF NOT ISNULL(THIS.oMessage)
		                THIS.oMessage.Warning('%msgUpdateError', THIS.Parent.cDisplayName, aErrInfo[2])
		              ENDIF
		              RETURN .F.
		            ENDIF
		
		          CASE aErrInfo[1] = 1526     && ODBC Error
		            THIS.Error(aErrInfo[1])   && Error method knows how to display this nicely.
		            RETURN .F.
		
		          OTHERWISE
		            IF NOT ISNULL(THIS.oMessage)
		              LOCAL cMsg
		              m.cMsg = aErrInfo[2]
		              * If a trigger failed (error 1539), aErrInfo[5] contains one of the following numeric values:
		              * 1  Insert trigger failed.2  Update trigger failed.3  Delete trigger failed.
		              IF aErrInfo[1] = 1539
		                DO CASE
		                  CASE aErrInfo[5] = 1
		                    m.cMsg = 'Insert ' + m.cMsg
		                  CASE aErrInfo[5] = 2
		                    m.cMsg = 'Update ' + m.cMsg
		                  CASE aErrInfo[5] = 3
		                    m.cMsg = 'Delete ' + m.cMsg
		                ENDCASE
		              ENDIF
		              THIS.oMessage.Warning('%msgUpdateError', THIS.Parent.cDisplayName, m.cMsg)
		            ENDIF
		            RETURN .F.
		        ENDCASE
		      ENDIF
		    ENDDO
		    IF NOT EMPTY(m.nLockRetries) AND NOT ISNULL(THIS.oMessage)
		      THIS.oMessage.StatusClear()
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE unlockrecord		&& Release network lock on the current (or specified) record. Use record number 0 to unlock the header, or -1 to unlock all records.
		LPARAMETERS nRecord
		*++
		*>>Release network lock on the current (or specified) record. Use record number 0 to unlock the header, or -1 to unlock all records.
		*--
		  IF NOT VARTYPE(m.nRecord) $ 'NI'
		    m.nRecord = RECNO(THIS.cWorkarea)
		  ENDIF
		
		  IF m.nRecord < 0
		    UNLOCK IN (THIS.cWorkarea)
		  ELSE
		    * Remove any explicit record lock after the record is updated.
		    IF NOT THIS.IsNew() AND ISRLOCKED(m.nRecord, THIS.cWorkarea)
		      UNLOCK RECORD (m.nRecord) IN (THIS.cWorkarea)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE update		&& Write all buffered changes for Native VFP Table or Local View to disk.
		LPARAMETERS nFlags
		*++
		*>>Write all buffered changes for Native VFP Table or Local View to disk.
		*    Supported Buffering modes:
		*     1  Row and table buffering is off (we do nothing here in this case)
		*     2  Pessimistic row buffering is on.
		*     3  Optimistic row buffering is on.
		*     4  Pessimistic table buffering is on.
		*     5  Optimistic table buffering is on.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_OBEY_SETKEY     8  For Table-buffered child tables, obey SET KEY restrictions
		*--
		LOCAL nThisRec, lSetKey, lStatus
		
		  * Default status to success for cases where no changes are made.
		  m.lStatus = .T.
		  THIS.nLastError = 0
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF CURSORGETPROP('Buffering', THIS.cWorkarea) > 1
		    IF CURSORGETPROP('Buffering', THIS.cWorkarea) <= 3    && If row buffering
		      * Only update if record has some changes.
		      IF GETFLDSTATE(0, THIS.cWorkarea) > 2 OR '2' $ GETFLDSTATE(-1, THIS.cWorkarea)
		        m.lStatus = THIS.UpdateRecord(m.nFlags)
		      ENDIF
		    ELSE        && Table buffered table
		      * Determine if this is a child table that should respect SET KEY filter.
		      m.nSelect = SELECT()
		      SELECT (THIS.cWorkarea)
		      m.lSetKey = NOT EMPTY(BITAND(m.nFlags, UPDATEMASK_OBEY_SETKEY)) ;
		        AND NOT ISNULL(THIS.Parent.oParent) AND NOT EMPTY(SET('KEY', 1)) ;
		        AND CURSORGETPROP('SourceType', THIS.cWorkarea) = 3
		
		      * In table Buffering mode there are possibly more than one record to update.
		      m.nThisRec = GETNEXTMODIFIED(0, THIS.cWorkarea)
		      m.lStatus = EMPTY(THIS.nLastError)     && Watch for possible DBC rule failure
		
		      DO WHILE m.lStatus AND NOT EMPTY(m.nThisRec)
		        GO m.nThisRec IN (THIS.cWorkarea)
		        * If ignoring SET KEY filter, or filter matches, update the record.
		        IF NOT m.lSetKey OR EVALUATE(KEY()) == THIS._GetKeyValue()
		          m.lStatus = THIS.UpdateRecord(m.nFlags)
		        ENDIF
		        m.nThisRec = GETNEXTMODIFIED(m.nThisRec, THIS.cWorkarea)
		      ENDDO
		      SELECT (m.nSelect)
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE updaterecord		&& Write buffered changes to the current record back to the source.
		LPARAMETERS nFlags
		*++
		*>>Write buffered changes to the current record back to the source.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOUNLOCK         16 Don't release any locks
		*--
		LOCAL nRecno
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  m.nRecno = RECNO(THIS.cWorkarea)
		  IF NOT EOF(THIS.cWorkarea) AND THIS.TableUpdate(0)
		    * Committing a buffered appended record may change the record number even in
		    * row buffered tables if other users have since commited further appends.
		    IF (m.nRecno != RECNO(THIS.cWorkarea))
		      * Set Flag when record number changes, so Nav Ctls (which store rec numbers) can be rebuilt.
		      THIS.Parent.nCursorFlags = BITSET(THIS.Parent.nCursorFlags, CURSORFLAG_RECNO_CHANGED)
		
		      * Update "restore-to" record number if this is the record that was renumbered.
		      IF THIS.lSavedByRecno AND THIS.uSavedPosition == m.nRecno
		        THIS.uSavedPosition = RECNO(THIS.cWorkarea)
		      ENDIF
		    ENDIF
		
		    * Remove any explicit record lock after the record is updated.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOUNLOCK))
		      THIS.UnLockRecord()
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE zap		&& Delete all the local cursor records.
		*++
		*>>Delete all the local cursor records.
		*--
		LOCAL nBuffer, lSafety
		  SELECT (THIS.cWorkarea)
		  IF THIS.IsExclusive()
		    * Discard any uncommitted changes before Zapping.
		    THIS.Revert()
		
		    m.nBuffer = THIS.GetBufferMode()
		    IF m.nBuffer > 3
		      THIS.SetBufferMode(3)
		    ENDIF
		
		    m.lSafety = (SET("Safety") == 'ON')
		    SET SAFETY OFF
		    ZAP
		    IF m.lSafety
		      SET SAFETY ON
		    ENDIF
		
		    THIS.SetBufferMode(m.nBuffer)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE _extractparameters		&& Return a string describing all the parameters used in the SQL statement.
		LPARAMETERS lReturnAll
		*++
		*>>Return a string describing all the parameters used in the SQL statement.
		* Parameters are indicated by the '?' prefix. The name of the parameters must
		* conform the the standard CodeMine naming conventions, since the datatype prefix
		* on the name is the only way we have of knowing the datatype of the variable.
		*--
		LOCAL cSql, cParam, cParamList, cType
		  m.cParamList = ''
		  m.cSql = THIS.Parent.cSource
		
		  * Append the dynamic where clause for SELECT statements, so we can extract any parameters from it.
		  * Syntax of string will be wrong, but its a fast way to build a string with all parameter values in it.
		  * Paremeters in the base SQL string must appear in the list before any in the current cWhere expression.
		  IF UPPER(LEFT(m.cSql, 7)) == 'SELECT '
		    m.cSql = m.cSql + ' WHERE ' + THIS.Parent.cWhere
		    m.cSql = SUBSTR(m.cSQL, AT(' WHERE ', UPPER(m.cSQL)) + 1)
		  ENDIF
		
		  * For EXEC commands, replace comma-space delimeters with a single space for consisent parsing.
		  IF UPPER(LEFT(m.cSql, 5)) == 'EXEC '
		    m.cSql = STRTRAN(m.cSql, ', ', ' ')
		  ENDIF
		
		  * Search the string for parameter variables - tokens beginning with a "?".
		  DO WHILE '?' $ m.cSql
		    m.cSql = SUBSTR(m.cSql, AT('?', m.cSql) + 1)
		    m.cParam = GetToken(@m.cSql, ' ')
		
		    * There might be a closing paren we need to strip off, for cases like:
		    * WHERE (name = ?pcName AND city = ?pcCity)
		    IF RIGHT(m.cParam, 1) == ')' 
		      m.cParam = LEFT(m.cParam, LEN(m.cParam) - MAX(0, OCCURS(')', m.cParam) - OCCURS('(', m.cParam)))
		    ENDIF
		
		    * Normally, we only return parameter values that are simple memvar names. If it is a cursor 
		    * field name, or global object reference (ex goApp.cWarehouseLocation), then as far as the 
		    * cursor object is concerned, it is not a parameter - ie there is no value expected to be 
		    * passed to the Requery() method. However, before we execute the SQL string, we evaluate 
		    * all parameters and insert the resulting values. In this case, the lReturnAll flag
		    * will be set to indicate that we should return all parameters that need to be evaluated.
		    IF m.lReturnAll OR NOT '.' $ STRTRAN(PROPER(m.cParam), 'M.', '')
		      m.cType = UPPER(LEFT(m.cParam, 1))
		      IF m.cType = 'P'  && Names should always have the explicit 'p' prefix, for "Private"
		        m.cType = UPPER(SUBSTR(m.cParam, 2, 1))
		      ENDIF
		      IF NOT m.cType $ 'CNLDT'
		        m.cType = 'C'  && Assume character if no valid prefix found
		      ENDIF
		      m.cParamList = m.cParamList + IIF(NOT EMPTY(m.cParamList), ';', '') + m.cParam + ",'" + m.cType + "'"
		    ENDIF
		  ENDDO
		  RETURN m.cParamList
		
	ENDPROC

	PROCEDURE _getkeyfilter		&& Internal method to return the current SET KEY expression in a format that can easily be re-applied.
		*++
		*>>Internal method to return the current SET KEY expression in a format that can easily be re-applied.
		*--
		LOCAL cSetKey, nSelect
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		  m.cSetKey = SET('KEY', 1)
		  IF LEN(m.cSetKey) > 0
		    m.cSetKey = TYPE(KEY()) + m.cSetKey
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN m.cSetKey
		
	ENDPROC

	PROCEDURE _getkeyvalue		&& Internal method to return the current SET KEY expression value, in the correct data type.
		*++
		*>>Internal method to return the current SET KEY expression value, in the correct data type.
		*--
		LOCAL cSetKey, uValue
		  m.cSetKey = SET('KEY', 1)
		  IF LEN(m.cSetKey) > 0
		    IF TYPE(KEY()) $ 'CM'
		      m.uValue = m.cSetKey
		    ELSE
		      m.uValue = VAL(m.cSetKey)  && If not char, assume numeric
		    ENDIF
		  ELSE
		    m.uValue = NULL              && No SET KEY filter in effect
		  ENDIF
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE _insertparamvalue		&& Replace a parameter placeholder with the value for the parameter in an SQL statement.
		LPARAMETERS cSql, cParam, cValue
		*++
		*>>Replace a parameter placeholder with the value for the parameter in an SQL statement. 
		*--
		LOCAL ix
		  * Parameter expression may only be followed by a space, coma, closing paren, or end of string.
		  m.ix = AT('?' + m.cParam + ' ', m.cSql + ' ')
		  IF EMPTY(m.ix)
		    m.ix = AT('?' + m.cParam + ')', m.cSql)
		    IF EMPTY(m.ix)
		      m.ix = AT('?' + m.cParam + ',', m.cSql)
		      IF EMPTY(m.ix)
		        THIS.SqlError(m.cSql, m.cParam + ' - Parameter expression syntax error')
		        RETURN m.cSql
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Replace the parameter name or expression with the supplied value.
		  RETURN STUFF(m.cSql, m.ix, LEN(m.cParam) + 1, m.cValue)
		
	ENDPROC

	PROCEDURE _isequal		&& Compare two values, not counting trailing spaces for character types.
		LPARAMETERS uValue1, uValue2
		*++
		*>>Compare two values, not counting trailing spaces for character types.
		*--
		  IF VARTYPE(m.uValue1) = 'C'
		    RETURN TRIM(m.uValue1) == TRIM(m.uValue2)
		  ENDIF
		  RETURN m.uValue1 == m.uValue2
		
	ENDPROC

	PROCEDURE _setkeyfilter		&& Internal method to re-apply a saved SET KEY expression, from the values returned by _GetKeyFilter()
		LPARAMETERS cSetKey
		*++
		*>>Internal method to re-apply a saved SET KEY expression, from the values returned by _GetKeyFilter()
		*--
		LOCAL cValue, nSelect
		  IF VARTYPE(m.cSetKey) = 'C' AND LEN(m.cSetKey) > 0
		    m.nSelect = SELECT()
		    SELECT (THIS.cWorkarea)
		    m.cValue = SUBSTR(m.cSetKey, 2)
		    IF LEFT(m.cSetKey, 1) = 'C'
		      SET KEY TO (m.cValue)
		    ELSE
		      SET KEY TO &cValue
		    ENDIF
		    SELECT (m.nSelect)
		  ENDIF
		
	ENDPROC

	PROCEDURE _setwhere		&& Set the WHERE clasue of the specified SQL SELECT statement to the specified expression.
		LPARAMETERS cSql, cWhere, lOverwrite
		*++
		*>>Set the WHERE clasue of the specified SQL SELECT statement to the specified expression.
		*--
		LOCAL cUpperSql, nWhere, nOldWhere
		
		  * Find where to put the WHERE clause...
		  IF NOT EMPTY(m.cWhere)
		    * Perform some standard VFP to SQL Server syntax conversions. This should be moved
		    * to a SQL syntax object in a future version, but do it in-line for now.
		    m.cWhere = STRTRAN(m.cWhere, '==', '=')
		
		    * Convert universal format VFP date literals to SQL server format.
		    DO WHILE '{^' $ m.cWhere
		      LOCAL ix, cDate
		      m.ix = AT('{^', m.cWhere)
		      m.cDate = SUBSTR(m.cWhere, m.ix, 13)
		      IF RIGHT(m.cDate, 1) = '}' AND OCCURS('-', m.cDate) = 2
		        m.cDate = ['] + SUBSTR(m.cDate, 3, 4) + SUBSTR(m.cDate, 8, 2) + SUBSTR(m.cDate, 11, 2) + [']
		        m.cWhere = STUFF(m.cWhere, m.ix, 13, m.cDate)
		      ELSE
		        EXIT
		      ENDIF
		    ENDDO
		
		    m.cUpperSql = UPPER(m.cSql)
		    * Need to make this parser a lot smarter if we are to support subqueries - and also 
		    * would need to have a way to determine which query's WHERE clause we were supposed to use.
		*    ASSERT NOT '(SELECT ' $ STRTRAN(m.cUpperSql, '( ', '(') MESSAGE 'Subqueries are not supported by the _SetWhere() parser for ' + THIS.Parent.Name
		
		    m.nOldWhere = AT(' WHERE ', m.cUpperSql)
		    DO CASE
		      CASE ' GROUP BY ' $ m.cUpperSql
		        m.nWhere = AT(' GROUP BY ', m.cUpperSql)
		      CASE ' HAVING ' $ m.cUpperSql
		        m.nWhere = AT(' HAVING ', m.cUpperSql)
		      CASE ' UNION ' $ m.cUpperSql
		        m.nWhere = AT(' UNION ', m.cUpperSql)
		      CASE ' ORDER BY ' $ m.cUpperSql
		        m.nWhere = AT(' ORDER BY ', m.cUpperSql)
		      OTHERWISE
		        m.nWhere = LEN(m.cUpperSql) + 1
		    ENDCASE
		
		    m.cSql = STUFF(m.cSql, m.nWhere, 0, ;
		                IIF(m.nOldWhere > 0 AND NOT m.lOverwrite, ' AND ', ' WHERE ') + '(' + TRIM(m.cWhere) + ')')
		
		    IF m.nOldWhere > 0
		      IF m.lOverwrite
		        m.cSql = STUFF(m.cSql, m.nOldWhere, m.nWhere - m.nOldWhere, '')
		      ELSE
		        m.cSql = STUFF(m.cSql, m.nOldWhere + 7, 0, '(')
		        m.cSql = STUFF(m.cSql, m.nWhere+1, 0, ')')
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN m.cSql
		
	ENDPROC

	PROCEDURE _valuetochar		&& Convert any type value to a character literal format valid for use in SQL server expressions.
		LPARAMETERS uValue
		*++
		*>>Convert any type value to a character literal format valid for use in SQL server expressions.
		*--
		LOCAL cType
		  m.cType = VARTYPE(m.uValue, .T.)
		  DO CASE
		    CASE ISNULL(m.uValue)
		      RETURN 'NULL'
		    CASE m.cType $ 'CM'
		      RETURN ['] + STRTRAN(m.uValue, ['], ['']) + [']
		    CASE m.cType $ 'INY'
		      IF m.uValue % 1 = 0
		        RETURN LTRIM(STR(m.uValue))
		      ELSE
		        RETURN LTRIM(STR(m.uValue, 15, 5))
		      ENDIF
		    CASE m.cType = 'L'
		      RETURN IIF(m.uValue, '1', '0')
		    CASE m.cType $ 'DT'
		      LOCAL cDate
		      m.cDate = TTOC(m.uValue, 1)
		      m.cDate = LEFT(m.cDate, 4) + '-' + SUBSTR(m.cDate, 5, 2) + '-' + SUBSTR(m.cDate, 7, 2) ;
		              + ' ' + SUBSTR(m.cDate, 9, 2) + ':' + SUBSTR(m.cDate, 11, 2) + ':' + SUBSTR(m.cDate, 13, 2)
		      RETURN "CONVERT(DATETIME, '" + m.cDate + "', 102)"
		  ENDCASE
		  RETURN '?Bad Type?'
		
	ENDPROC

	PROCEDURE _waitforlock		&& Display an informational message, and wait a random amount of time to retry after a lock failure. Return .F. to stop attempting the lock.
		LPARAMETERS nLockRetries
		*++
		*>>Display an informational message, and wait a random amount of time to retry after a lock failure. Return .F. to stop attempting the lock.
		*--
		  IF EMPTY(m.nLockRetries)  && Counter must be passed by reference if count is desired.
		    m.nLockRetries = 1
		  ELSE
		    m.nLockRetries = m.nLockRetries + 1
		  ENDIF
		
		  IF NOT ISNULL(THIS.oMessage)
		    THIS.oMessage.StatusMessage('%msgWaitingForLock', THIS.Parent.cDisplayName)
		  ENDIF
		  IF THIS.Parent.nLockRetry >= 0 AND m.nLockRetries > THIS.Parent.nLockRetry
		    IF NOT ISNULL(THIS.oMessage)
		      THIS.oMessage.Warning('%msgLockedByAnother', THIS.Parent.cDisplayName)
		    ENDIF
		    RETURN .F.
		  ENDIF
		
		  * Wait a random amount of time before retrying lock, abort on escape.
		  IF INKEY(RAND() * .5, 'H') = 27 AND NVL(THIS.Parent.lAllowAbort, .T.)
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataaccesscrosstab AS cmdataaccesstable OF "cmdataa.vcx" 		&& Data Access Class for dynamic crosstab cursors.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_Access.bmp" ClassIcon="..\graphics\_Access.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: lselectbyrequery
	*</DefinedPropArrayMethod>

	lselectbyrequery = .T.
	Name = "cmdataaccesscrosstab"

ENDDEFINE

DEFINE CLASS cmdataaccesslocalview AS cmdataaccessview OF "cmdataa.vcx" 		&& Class for local view data access.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_Access.bmp" ClassIcon="..\graphics\_Access.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: deletewhere		&& Delete Local View records matching the specified Where expression. Records are deleted via direct commands to the VFP source table.
		*m: openoptions		&& Return a list of USE command clauses to apply to the cursor about to be opened.
		*m: _valuetochar		&& Convert any type value to a character literal format valid for use in VFP SQL statement expressions.
	*</DefinedPropArrayMethod>

	Name = "cmdataaccesslocalview"
	
	PROCEDURE deletewhere		&& Delete Local View records matching the specified Where expression. Records are deleted via direct commands to the VFP source table.
		LPARAMETERS cWhereExpression, nFlags
		*++
		*>>Delete Local View records matching the specified Where expression. Records are deleted via direct commands to the VFP source table.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN    4 - Don't process related child cursors.
		*    UPDATEMASK_COMMIT       64 - Commit operation even if not required by buffering mode.
		*    UPDATEMASK_REQUERY     128 - For views, requery the local cursor after deleting records from server.
		*--
		LOCAL oChild, cSourceTable, cResultCursor, cKey, nLockRetries
		
		  * A multi-table view will work ok, as long as only one of the tables has updatable fields.
		  m.cSourceTable = CURSORGETPROP('Tables', THIS.cWorkarea)
		  IF EMPTY(m.cSourceTable) OR ',' $ m.cSourceTable
		    ASSERT .F. MESSAGE THIS.cWorkarea + ': Only updatable views based on a single table can use DeleteWhere()'
		    RETURN .F.
		  ENDIF
		
		  * Delete any related child records first, if enabled for the cursor
		  SELECT 0
		  m.cResultCursor = '__KeyList_' + THIS.cWorkarea
		  USE (m.cSourceTable) AGAIN SHARED ALIAS (m.cResultCursor)
		
		  * Scan each record in the set of existing PKs, and process corresponding children
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		    SCAN FOR NOT DELETED() AND &cWhereExpression
		      FOR EACH oChild IN THIS.Parent.aChildren
		        IF NOT ISNULL(m.oChild) AND m.oChild.lDeleteWithParent
		          * Build WHERE filter expression. Numeric and Character key types are supported.
		          SELECT (m.cResultCursor)
		          m.cKey = EVALUATE(m.oChild.cParentKeyField)
		          m.cKey = IIF(VARTYPE(m.cKey, .T.) = 'C', "'" + m.cKey + "'", LTRIM(STR(m.cKey, 16)) )
		
		          * Delete child records, but do no pass the UPDATEMASK_REQUERY flag along to the child.
		          IF NOT m.oChild.DeleteWhere(m.oChild.cForeignKeyField + ' = ' + m.cKey, BITAND(m.nFlags, BITNOT(UPDATEMASK_REQUERY)))
		            USE IN (m.cResultCursor)
		           RETURN .F.
		          ENDIF
		        ENDIF
		     ENDFOR
		    ENDSCAN
		  ENDIF
		
		  * Delete the records directly in the source table, bypassing the view definition.
		  SET REPROCESS TO 1
		  DO WHILE .T.
		    THIS.nLastError = 0
		    DELETE FOR &cWhereExpression IN (m.cResultCursor)   && Commits as we go
		    IF THIS.nLastError = 109 AND THIS._WaitForLock(@m.nLockRetries)
		      LOOP
		    ENDIF
		    EXIT   && Exit loop on all cases but lock failure
		  ENDDO
		
		  USE IN (m.cResultCursor)
		  IF NOT EMPTY(m.nLockRetries) AND NOT ISNULL(THIS.oMessage)
		    THIS.oMessage.StatusClear()
		  ENDIF
		
		  * Since deleting directly against the source tables may leave the local cursor contents
		  * out-of-sync, caller may want us to requery, using the most recent parameters.
		  IF NOT EMPTY(BITAND(m.nFlags, UPDATEMASK_REQUERY))
		    THIS.Parent.Requery()
		  ENDIF
		  RETURN (THIS.nLastError = 0)
		
	ENDPROC

	PROCEDURE openoptions		&& Return a list of USE command clauses to apply to the cursor about to be opened.
		*++
		*>>Return a list of USE command clauses to apply to the cursor about to be opened.
		*--
		LOCAL cOptions
		
		  * Ignore the lExclusive property for local views, since it 
		  * would also affect the opening of the base VFP table.
		  m.cOptions = IIF(THIS.Parent.lReadonly, 'NOUPDATE ', '')
		  IF THIS.Parent.lNoDataOnLoad
		    m.cOptions = m.cOptions + 'NODATA '
		  ENDIF
		  RETURN m.cOptions
		
	ENDPROC

	PROCEDURE _valuetochar		&& Convert any type value to a character literal format valid for use in VFP SQL statement expressions.
		LPARAMETERS uValue
		*++
		*>>Convert any type value to a character literal format valid for use in VFP SQL statement expressions.
		*--
		LOCAL cType
		  m.cType = VARTYPE(m.uValue, .T.)
		  DO CASE
		    CASE ISNULL(m.uValue)
		      RETURN 'NULL'
		    CASE m.cType $ 'CM'
		      IF ['] $ m.uValue
		        RETURN ["] + m.uValue + ["]
		      ELSE
		        RETURN ['] + m.uValue + [']
		      ENDIF
		    CASE m.cType $ 'INY'
		      IF m.uValue % 1 = 0
		        RETURN LTRIM(STR(m.uValue))
		      ELSE
		        RETURN LTRIM(STR(m.uValue, 15, 5))
		      ENDIF
		    CASE m.cType = 'L'
		      RETURN IIF(m.uValue, '.T.', '.F.')
		    CASE m.cType $ 'DT'
		      LOCAL cDate
		      m.cDate = TTOC(m.uValue, 1)
		      m.cDate = LEFT(m.cDate, 4) + '-' + SUBSTR(m.cDate, 5, 2) + '-' + SUBSTR(m.cDate, 7, 2) ;
		              + ' ' + SUBSTR(m.cDate, 9, 2) + ':' + SUBSTR(m.cDate, 11, 2) + ':' + SUBSTR(m.cDate, 13, 2)
		      RETURN '{^' + m.cDate + '}'
		  ENDCASE
		  RETURN '?Bad Type?'
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataaccesslsqlpt AS cmdataaccesslocalview OF "cmdataa.vcx" 		&& Access Class for Local SQL and View cursors.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_access.bmp" ClassIcon="..\graphics\_access.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: queryformatonly		&& Return the format (column definitions) of the cursor generated by the passed SQL statement, as a recordset with 0 records.
	*</DefinedPropArrayMethod>

	Name = "cmdataaccesslsqlpt"
	
	PROCEDURE getviewparameters
		LPARAMETERS lReturnAll
		*++
		*>>Return a string describing all the parameters used in the SQL statement.
		* Parameters are indicated by the '?' prefix. The name of the parameters must
		* conform the the standard CodeMine naming conventions, since the datatype prefix
		* on the name is the only way we have of knowing the datatype of the variable.
		*--
		  RETURN THIS._ExtractParameters(m.lReturnAll)
		
	ENDPROC

	PROCEDURE Init
		*++
		* Class for Local SQL and View cursors.
		*
		* Copyright 2002 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		  IF NOT PEMSTATUS(THIS.Parent, 'cmSqlProperties', 5)
		    THIS.Parent.AddObject('cmSqlProperties', 'cmSqlProperties')
		
		    * If we had to create the properties object, we don't use its 
		    * values unless we later set them on open from a DBC view definition.
		    THIS.Parent.cmSqlProperties.lUseSavedProperties = .F.
		  ENDIF
		
		  * Need VFP 7 or later to use LSQLPT cursors.
		  IF VERSION(5)/100 < 7
		    ASSERT .F. MESSAGE 'LSQLPT is not supported for this version of VFP'
		    THIS.Parent.lReadonly = .T.
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE new
		*++
		*>>Add a new record to the record set.
		*--
		LOCAL ix, cField, cExpr, nSelect
		  IF DODEFAULT()
		    * Apply default value expression to each field that has one.
		    DO WHILE THIS.Parent.cmSqlProperties.EnumDefaults(@m.ix, @m.cField, @m.cExpr) > 0
		      THIS.Replace(m.cField, THIS.Parent._Evaluate(m.cExpr))
		    ENDDO
		  ENDIF
		
	ENDPROC

	PROCEDURE open
		LPARAMETERS cSource, nBufferMode
		*++
		*>>Custom open code for Local SQL passthrough.
		*
		* The nBufferMode parameter is ignored here, as the actual cursor is not 
		* created until a Requery() is done.
		*
		*  cSource begins with 'SELECT ' -> SQL Passthrough cursor
		*  Otherwise, a Dynamic Local View, based on the view name specified in cSource
		*--
		LOCAL cKeyword
		  WITH THIS.Parent
		    IF EMPTY(.cWorkarea)   && Generate default workarea if non was specified.
		      .cWorkarea = .Name
		    ENDIF
		    THIS.cWorkarea = .cWorkarea
		  ENDWITH
		
		  * Determine if this is an SQL statement,or a view name
		  m.cKeyWord = PROPER(GetToken(m.cSource, ' '))
		  IF NOT ' ' $ ALLTRIM(m.cSource) OR NOT m.cKeyWord $ 'Select'
		    * Not a supported SQL statement, so it must be a view name.
		    IF NOT INDBC(m.cSource, 'View')
		      THIS.DisplayMessage('Source local view ' + m.cSource + ' is not found in database')
		      RETURN .F.
		    ENDIF
		
		    WITH THIS.Parent
		      .cmSqlProperties.SaveProperties(@m.cSource)
		
		      * Replace the source string with the SQL command we use to build the result cursor.
		      STORE .cmSqlProperties.cViewSql TO .cSource
		    ENDWITH
		  ENDIF
		
		  * Force the lNoDataOnLoad flag if the SQL contains client side parameters
		  IF THIS.Parent.lNoDataOnLoad OR NOT EMPTY(THIS.GetViewParameters())  
		    THIS.Parent.lNoDataOnLoad = .T.
		  ENDIF
		
		  DO CASE
		    CASE THIS.Parent.lNoCursorOnLoad
		      * If caller doesn't want the empty cursor result set on open, we're all done now.
		      RETURN .T.
		
		    CASE THIS.Parent.lNoDataOnLoad
		      * Create an empty cursor
		      RETURN THIS.QueryFormatOnly()
		
		    OTHERWISE
		      * Query the cursor for its data set.
		      RETURN THIS.Requery()
		  ENDCASE
		
	ENDPROC

	PROCEDURE queryformatonly		&& Return the format (column definitions) of the cursor generated by the passed SQL statement, as a recordset with 0 records.
		*++
		*>>Return the format (column definitions) of the cursor generated by the passed SQL statement, as a recordset with 0 records.
		*--
		LOCAL cSql, cKeyword
		
		  m.cSql = THIS.Parent.cSource
		  m.cKeyWord = UPPER(GetToken(m.cSql, ' '))
		  IF m.cKeyWord == 'SELECT'
		    * Get rid of the WHERE clause, including all client-side parameters.
		    m.cSql = THIS._SetWhere(m.cSql, '.F.', .T.)
		  ELSE
		    RETURN .F.
		  ENDIF
		
		  * Execute using macro for single line commands, or EXECSCRIPT() for multi-line commands.
		  m.cSql = m.cSql + ' INTO CURSOR ' +  THIS.cWorkarea + IIF(THIS.Parent.lReadOnly, '', ' READWRITE')
		  IF CHR(13) $ m.cSql
		    EXECSCRIPT(m.cSql)
		  ELSE
		    &cSql
		  ENDIF
		  RETURN THIS.Parent.cmSqlProperties.RestoreProperties()
		
	ENDPROC

	PROCEDURE replace
		LPARAMETERS cField, uValue
		*++
		*>>Set the value of the specified field. If cursor is based on a remote view, then apply field valid rules copied from DBC.
		* LSQLPT cursors.
		*--
		LOCAL cMsg, uOriginal, cRule
		
		  * Save original value in case we need to fall back.
		  m.uOriginal = EVALUATE(THIS.cWorkarea + '.' + m.cField)
		  REPLACE (m.cField) WITH m.uValue IN (THIS.cWorkarea)
		
		  WITH THIS.Parent.cmSqlProperties
		    m.cRule = .GetFieldRule(m.cField, @m.cMsg)
		    IF NOT EMPTY(m.cRule)
		      * Evaluate the DBC rule with this cursor selected, in the context of the cursor object.
		      m.lStatus = THIS.Parent._Evaluate(m.cRule)
		
		      IF NOT m.lStatus
		        LOCAL cText
		        * Evaluate error message expression copied from DBC, if any. Otherwise, use generic msg.
		        IF NOT EMPTY(m.cMsg)
		          THIS.SetErrorMode(ERRMASK_SILENT_ALL)        && Ignore any errors
		          m.cText = EVALUATE(m.cMsg)
		          IF NOT EMPTY(THIS.nLastError)
		            m.cText = m.cMsg                           && Eval failed, use un-evaluated expression
		          ENDIF
		          THIS.SetErrorMode()                          && Restore original error mode
		        ELSE
		          m.cText = '%msgFieldValidFailed'
		        ENDIF
		
		        * Display error message, and restore original value.
		        THIS.DisplayMessage(m.cText)
		        IF NOT THIS._IsEqual(m.uValue, m.uOriginal)
		          REPLACE (m.cField) WITH m.uOriginal IN (THIS.cWorkarea)
		        ENDIF
		        RETURN .F.
		      ENDIF
		    ENDIF
		  ENDWITH
		  RETURN .T.
		
	ENDPROC

	PROCEDURE requery
		*++
		*>>Requery on a LSQLPT cursor by re-executing the SELECT statement.
		* If cursor is displayed in a grid, DM level Before/AfterRequery() is needed to reset 
		* grid.recordsource and column Controlsource.
		*--
		LOCAL cSQL, cParam, cParamlist, uValue, lAutoYield
		
		  * Update the WHERE clause if this is a SELECT statement.
		  m.cSQL = THIS.Parent.cSource
		  IF NOT EMPTY(THIS.Parent.cWhere)
		    m.cSQL = THIS._SetWhere(m.cSQL, THIS.Parent.cWhere)
		  ENDIF
		
		  * Evaluate any parameter variables, and insert the values into the SQL statement
		  m.cParamlist = THIS.GetViewParameters(.T.)  && Return all params that need to be evaluated
		  DO WHILE NOT EMPTY(m.cParamlist)
		    m.cParam = GetToken(GetToken(@m.cParamlist, ';'), ',')
		    IF TYPE(m.cParam) = 'U'
		      THIS.DisplayMessage('Query Parameter "\c" is not defined for SQLPT cursor "\c"', m.cParam, THIS.Parent.Name)
		      RETURN .F.
		    ENDIF
		    m.cSql = THIS._InsertParamValue(@m.cSql, m.cParam, THIS._ValueToChar(EVALUATE(m.cParam)))
		  ENDDO
		
		  IF SET('TALK') = 'ON'
		    * ExecScript() defaults to talk-off so no VFP progress is displayed. If caller has it on, force it on.
		    m.cSql = 'SET TALK ON' + CR_LF + m.cSql
		  ENDIF
		  m.lAutoYield = _VFP.AutoYield
		  IF NVL(THIS.Parent.lAllowAbort, .F.)
		    _VFP.AutoYield = .T.  && Allow escape to interrupt query, if desired.
		  ENDIF
		
		  * Execute using macro for single line commands, or EXECSCRIPT() for multi-line commands.
		  m.cSql = m.cSql + ' INTO CURSOR ' +  THIS.cWorkarea + IIF(THIS.Parent.lReadOnly, '', ' READWRITE')
		  IF CHR(13) $ m.cSql
		    EXECSCRIPT(m.cSql)
		  ELSE
		    &cSql
		  ENDIF
		  _VFP.AutoYield = m.lAutoYield
		
		  * If user pressed escape to abort the query, cursor may not exist, so create empty cursor.
		  IF NVL(THIS.Parent.lAllowAbort, .F.) AND NOT USED(THIS.cWorkarea)
		    THIS.QueryFormatOnly()
		  ENDIF
		
		  * Need to re-apply any filter that is supposed to be in effect.
		  IF NOT EMPTY(THIS.Parent.cFilter)
		    THIS.SetFilter(THIS.Parent.cFilter)
		  ENDIF
		  RETURN THIS.Parent.cmSqlProperties.RestoreProperties()
		
	ENDPROC

	PROCEDURE select
		LPARAMETERS uKeyValue
		*++
		*>>Restrict our recordset to only those matching the current parent record
		*--
		  * Add wildcard character to string keys if SET EXACT is off, and comparison is LIKE.
		  * This makes Select() behave the same for views as it does for native VFP tables.
		  IF SET('EXACT') = 'OFF' AND VARTYPE(m.uKeyValue) = 'C' ;
		  AND 'LIKE ?' $ (THIS.Parent.cSource + THIS.Parent.cWhere)
		    m.uKeyValue = m.uKeyValue + '%'
		  ENDIF
		
		  * Requery the parameterized view using parent key value as parameter.
		  RETURN THIS.Parent.Requery(@m.uKeyValue)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataaccessremoteview AS cmdataaccessview OF "cmdataa.vcx" 		&& Class for remote view access and manipulation.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_access.bmp" ClassIcon="..\graphics\_access.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: getlastpk		&& Return the most recent Primary Key value generated by the database server on this connection.
	*</DefinedPropArrayMethod>

	Name = "cmdataaccessremoteview"
	
	PROCEDURE close
		*++
		* Close the remote view, and remove the connection from the Connection Manager.
		*--
		  IF DODEFAULT()
		    WITH THIS.Parent
		      IF NOT ISNULL(.oConnMan) AND .nConnID > 0
		        .oConnMan.Disconnect(.nConnID)
		      ENDIF
		      .nConnID = 0
		    ENDWITH
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE deletewhere
		LPARAMETERS cWhereExpression, nFlags
		*++
		*>>Delete Remote View or SQLPT records matching the specified Where expression. Records are deleted via direct commands to the server database.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN   4 - Don't process related child cursors.
		*    UPDATEMASK_COMMIT      64 - Commit operation even if not required by buffering mode.
		*    UPDATEMASK_REQUERY    128 - For views, requery the local cursor after deleting records from server.
		*--
		LOCAL oChild, cFieldList, cSourceTable
		
		  * Delete any related child records first, if enabled for the cursor
		  * Need to get a list of the parent key field used by each child. Usually this will
		  * be our PK, but not necessarily. Use this as field list to select from server.
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		    m.cFieldList = ''
		    FOR EACH oChild IN THIS.Parent.aChildren
		      IF NOT ISNULL(m.oChild) AND m.oChild.lDeleteWithParent AND NOT PROPER(m.oChild.cParentKeyField) + ',' $ m.cFieldList + ','
		        m.cFieldList = m.cFieldList + IIF(EMPTY(m.cFieldList), '', ',') + PROPER(m.oChild.cParentKeyField)
		      ENDIF
		    ENDFOR
		
		    m.cSourceTable = CURSORGETPROP('Tables', THIS.cWorkarea)
		    IF EMPTY(m.cSourceTable) OR ',' $ m.cSourceTable
		      ASSERT .F. MESSAGE THIS.cWorkarea + ': Only updatable views based on a single table can use DeleteWhere()'
		      RETURN .F.
		    ENDIF
		
		    IF NOT EMPTY(m.cFieldList)  && If there are any children that need to be deleted by us.
		      LOCAL cSql, cResultCursor, cKey
		      * Select list of pk values for each record. This is used to find corresponding child records.
		      m.cResultCursor = '__KeyList_' + THIS.cWorkarea
		
		      m.cSql = THIS._SetWhere('SELECT ' + m.cFieldlist + ' FROM ' + m.cSourceTable, m.cWhereExpression)
		      SQLEXEC(CURSORGETPROP('ConnectHandle', THIS.cWorkarea), m.cSql, m.cResultCursor)
		
		      * Scan each record in the set of existing PKs, and process corresponding children
		      SELECT (m.cResultCursor)
		      SCAN ALL  && Process children for each record that we are deleting.
		        FOR EACH oChild IN THIS.Parent.aChildren
		          IF NOT ISNULL(m.oChild) AND m.oChild.lDeleteWithParent
		            * Build WHERE filter expression. Numeric and Character key types are supported.
		            SELECT (m.cResultCursor)
		            m.cKey = EVALUATE(m.oChild.cParentKeyField)
		            m.cKey = IIF(VARTYPE(m.cKey, .T.) = 'C', "'" + m.cKey + "'", LTRIM(STR(m.cKey, 16)) )
		
		            * Delete child records, but do no pass the UPDATEMASK_REQUERY flag along to the child.
		            IF NOT m.oChild.DeleteWhere(m.oChild.cForeignKeyField + ' = ' + m.cKey, BITAND(m.nFlags, BITNOT(UPDATEMASK_REQUERY)))
		              RETURN .F.
		            ENDIF
		          ENDIF
		        ENDFOR
		      ENDSCAN
		      USE IN (m.cResultCursor)
		    ENDIF
		  ENDIF
		
		  * Bypass view and perform direct delete against source table.
		  m.cSql = THIS._SetWhere('DELETE FROM ' + m.cSourceTable, m.cWhereExpression)
		  IF SQLEXEC(CURSORGETPROP('ConnectHandle', THIS.cWorkarea), m.cSql) < 0
		    THIS.SqlError(m.cSql)
		    RETURN .F.
		  ENDIF
		
		  * Since deleting directly against the source tables may leave the local cursor contents
		  * out-of-sync, caller may want us to requery, using the most recent parameters.
		  IF NOT EMPTY(BITAND(m.nFlags, UPDATEMASK_REQUERY))
		    THIS.Parent.Requery()
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getlastpk		&& Return the most recent Primary Key value generated by the database server on this connection.
		*++
		*>>Return the most recent Primary Key value generated by the database server on this connection.
		*--
		  LOCAL nSelect, cSql, uPK
		  m.nSelect = SELECT()
		  m.cSql = 'SELECT @@IDENTITY AS Pk'
		  IF SQLEXEC(CURSORGETPROP('ConnectHandle', THIS.cWorkarea), m.cSql, '_cmPrimaryKeyResult') < 0
		    THIS.SqlError(m.cSql)
		    RETURN .NULL.
		  ENDIF
		  m.uPK = _cmPrimaryKeyResult.pk
		  USE
		  SELECT (m.nSelect)
		  RETURN m.uPK
		
	ENDPROC

	PROCEDURE open
		LPARAMETERS cFile, nBufferMode
		*++
		* Open the remote view, and add the connection to the Connection Manager.
		*--
		
		  WITH THIS.Parent
		    * If an override connection was specified, use it instead of the one the
		    * view was originally based on. This is only supported for VFP 8.
		    IF NOT EMPTY(.cConnection) AND VERSION(5) >= 800
		      .nConnID = THIS.OpenConnection()
		      IF .nConnID = 0
		        RETURN .F.         && Connection failed
		      ENDIF
		    ENDIF
		
		    IF DODEFAULT(@m.cFile, m.nBufferMode)
		      IF THIS.Parent.lReadonly
		        CURSORSETPROP('SendUpdates', .F., THIS.cWorkarea)
		      ENDIF
		
		      * Add the connection to the connection manager, and store the Connection ID. Use the view 
		      * connection name, or override connection string, as the name for ConnMan connection sharing.
		      * Note that in the case of VFP8 connection override, .nConnId will already be set.
		      IF EMPTY(.nConnID) AND NOT ISNULL(.oConnMan)
		        .nConnID = .oConnMan.AddConnection( ;
			     			IIF('=' $ .cConnection, .cConnection, CURSORGETPROP('ConnectName', THIS.cWorkarea)), ;
					        DBGETPROP(.cSource, 'View', 'ShareConnection'), ;
					        CURSORGETPROP('ConnectHandle', THIS.cWorkarea) )
		      ENDIF
		      RETURN .T.
		    ENDIF
		  ENDWITH
		  RETURN .F.
		
	ENDPROC

	PROCEDURE openoptions
		*++
		*>>Return a list of USE command clauses to apply to the cursor about to be opened.
		*--
		LOCAL cOptions
		
		    * Views don't use Exclusive or ReadOnly open options
		    WITH THIS.Parent
		      m.cOptions = IIF(.lNoDataOnLoad, 'NODATA ', '')
		
		      DO CASE
		        CASE VERSION(5) = 700
		          * If a connection string (which must contain at least one "=") is specified, use it.
		          * Provides no support for connection sharing in this version of VFP
		          IF NOT EMPTY(.cConnection) AND '=' $ .cConnection
		            m.cOptions = m.cOptions + 'CONNSTRING [' + .cConnection + ']'
		          ENDIF
		
		        CASE VERSION(5) >= 800
		          * If an override connection was is specified, pass it on to the USE command.
		          * In VFP8 and later we can open the override connection ourself, and provide sharing.
		          IF NOT EMPTY(.nConnID)
		            m.cOptions = m.cOptions + 'CONNSTRING (' + LTRIM(STR(.oConn.GetProp('Connection'))) + ')'
		          ENDIF
		      ENDCASE
		    ENDWITH
		    RETURN m.cOptions
		
	ENDPROC

	PROCEDURE update
		LPARAMETERS nFlags
		*++
		*>>Write all buffered changes for a remote view to source tables.
		*    Supported Buffering modes:
		*     3  Optimistic row buffering.
		*     5  Optimistic table buffering.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    No options are currently supported for this method
		*--
		LOCAL lStatus, nThisRec
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  m.lStatus = .T.   && Default to true if no changes are pending
		  THIS.nLastError = 0
		  IF CURSORGETPROP('Buffering', THIS.cWorkarea) <= 3    && If row buffering
		    * Only update if record has some changes.
		    IF GETFLDSTATE(0, THIS.cWorkarea) > 2 OR '2' $ GETFLDSTATE(-1, THIS.cWorkarea)
		      m.lStatus = THIS.UpdateRecord(m.nFlags)
		    ENDIF
		  ELSE
		    * For remote PK assignment, we need to make 2 passes. First pass individually 
		    * updates newly appended records, retrieving the PK assigned by the server for 
		    * each one. Second pass bulk updates modified records. Also if we have any related
		    * children, we need to update new records individually, to ensure we can restore the
		    * original record position after - otherwise related child sets could be wrong.
		    IF THIS.Parent.lQueryRemotePK OR THIS.Parent.nChildren > 0
		      * In table Buffering mode there are possibly more than one record to update.
		      m.nThisRec = GETNEXTMODIFIED(0, THIS.cWorkarea)
		      m.lStatus = EMPTY(THIS.nLastError)     && Watch for possible DBC rule failure
		      DO WHILE m.lStatus AND NOT EMPTY(m.nThisRec)
		        GO m.nThisRec IN THIS.cWorkarea
		        IF GETFLDSTATE(0, THIS.cWorkarea) > 2  && If this record is newly appended in buffer
		          m.lStatus = THIS.UpdateRecord(m.nFlags)
		
		          * Committing a new record means record number will change
		          THIS.Parent.nCursorFlags = BITSET(THIS.Parent.nCursorFlags, CURSORFLAG_RECNO_CHANGED)
		        ENDIF
		        m.nThisRec = GETNEXTMODIFIED(m.nThisRec, THIS.cWorkarea)
		      ENDDO
		    ELSE
		      * Assume a recno was changed, since we don't examine every record individually
		      THIS.Parent.nCursorFlags = BITSET(THIS.Parent.nCursorFlags, CURSORFLAG_RECNO_CHANGED)
		    ENDIF
		
		    * If successful so far, commit any remaining changes at once.
		    m.lStatus = m.lStatus AND THIS.TableUpdate(1)
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE updaterecord
		LPARAMETERS nFlags
		*++
		*>>Write changes to the current Remote View record back to the server. 
		*
		* For new records with server-assigned primary key values, query the server 
		* for the key value assigned.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOUNLOCK         16 Don't release any locks
		*--
		LOCAL lNeedPK
		  m.lNeedPK = GETFLDSTATE(0, THIS.cWorkarea) > 2 AND THIS.Parent.lQueryRemotePK
		  IF DODEFAULT(m.nFlags)
		    * Query server for the PK assigned, but only if updates actually were sent to the server.
		    * If this is a non-updatable cursor, updating only clears internal cursor change state.
		    IF m.lNeedPK AND CURSORGETPROP('SendUpdates', THIS.cWorkarea)
		      * Put PK value into the view cursor, and issue another update. Since the pk field is not
		      * updatable, this will only reset the view cursor with the new pk for the record in place.
		      m.uPK = THIS.GetLastPK()
		      IF EMPTY(NVL(m.uPK, 0))
		        ASSERT .F. MESSAGE THIS.cWorkarea + ': Server did not assign a Primary Key value for this new record'
		      ELSE
		        REPLACE (THIS.Parent.cPrimaryKeyField) WITH m.uPK IN (THIS.cWorkarea)
		        TABLEUPDATE(0, .F., THIS.cWorkarea)
		      ENDIF
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataaccesssqlpt AS cmdataaccessremoteview OF "cmdataa.vcx" 		&& Class for SQL PassThrough and Stored Procedure cursors
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_Access.bmp" ClassIcon="..\graphics\_Access.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: close		&& Close the local SQL result cursor, and disconnect the connection.
		*m: getviewparameters		&& Return a string describing all the parameters used in the SQL statement.
		*m: new		&& Add a new record to the record set.
		*m: open		&& Custom open code for SQL passthrough and Stored Procedure cursors.
		*m: queryformatonly		&& Return the format (column definitions) of the cursor generated by the passed SQL statement, as a recordset with 0 records.
		*m: replace		&& Set the value of the specified field. If cursor is based on a remote view, then apply field valid rules copied from DBC.
		*m: requery		&& Requery on a SQLPT cursor. Use SQLEXEC() on the sql if connection is non-empty. Else, execute directly.
	*</DefinedPropArrayMethod>

	Name = "cmdataaccesssqlpt"
	
	PROCEDURE close		&& Close the local SQL result cursor, and disconnect the connection.
		*++
		*>>Close the local SQL result cursor, and disconnect the connection.
		*--
		  IF NOT EMPTY(THIS.cWorkarea) AND USED(THIS.cWorkarea)
		    USE IN (THIS.cWorkarea)
		  ENDIF
		  WITH THIS.Parent
		    IF NOT ISNULL(.oConnMan) AND .nConnID > 0
		      .oConnMan.Disconnect(.nConnID)
		    ENDIF
		    .nConnID = 0
		  ENDWITH
		
	ENDPROC

	PROCEDURE getviewparameters		&& Return a string describing all the parameters used in the SQL statement.
		LPARAMETERS lReturnAll
		*++
		*>>Return a string describing all the parameters used in the SQL statement.
		* Parameters are indicated by the '?' prefix. The name of the parameters must
		* conform the the standard CodeMine naming conventions, since the datatype prefix
		* on the name is the only way we have of knowing the datatype of the variable.
		*--
		  RETURN THIS._ExtractParameters(m.lReturnAll)
		
	ENDPROC

	PROCEDURE init
		*++
		* Class for SQL Passthrough and Stored Procedure cursors.
		*
		* Copyright 2000-2002 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		  THIS.AddProperty('nConnection', 0)   && Connection handle
		
		  IF NOT PEMSTATUS(THIS.Parent, 'cmSqlProperties', 5)
		    THIS.Parent.AddObject('cmSqlProperties', 'cmSqlProperties')
		
		    * If we had to create the properties object, we don't use its 
		    * values unless we later set them on open from a DBC view definition.
		    THIS.Parent.cmSqlProperties.lUseSavedProperties = .F.
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE new		&& Add a new record to the record set.
		*++
		*>>Add a new record to the record set.
		*--
		LOCAL ix, cField, cExpr, nSelect
		  IF DODEFAULT()
		    * Apply default value expression to each field that has one.
		    DO WHILE THIS.Parent.cmSqlProperties.EnumDefaults(@m.ix, @m.cField, @m.cExpr) > 0
		      THIS.Replace(m.cField, THIS.Parent._Evaluate(m.cExpr))
		    ENDDO
		  ENDIF
		
	ENDPROC

	PROCEDURE open		&& Custom open code for SQL passthrough and Stored Procedure cursors.
		LPARAMETERS cSource, nBufferMode
		*++
		*>>Custom open code for SQL passthrough and Stored Procedure cursors.
		*
		* The nBufferMode parameter is ignored here, as the actual cursor is not 
		* created until a Requery() is done.
		*
		*  cSource begins with 'SELECT ' -> SQL Passthrough cursor
		*  cSource begins with 'EXEC ' -> Stored Procedure cursor
		*  Otherwise, a Dynamic View, based on the view name specified in cSource
		*--
		LOCAL cKeyword
		
		  THIS.nLastError = 0
		  THIS.nLastSqlError = 0
		  WITH THIS.Parent
		    IF EMPTY(.cWorkarea)   && Generate default workarea if non was specified.
		      .cWorkarea = .Name
		    ENDIF
		    THIS.cWorkarea = .cWorkarea
		
		    * Determine if this is an SQL statement,or a view name
		    m.cKeyWord = PROPER(GetToken(m.cSource, ' '))
		    IF NOT ' ' $ ALLTRIM(m.cSource) OR NOT m.cKeyWord $ 'Select,Exec'
		      * Not a supported SQL statement, so it must be a view name.
		      IF NOT INDBC(m.cSource, 'View')
		        THIS.DisplayMessage('Source view ' + m.cSource + ' is not found in database')
		        THIS.nLastError = 1   && Ths error counts as FNF is caller queries error code.
		        RETURN .F.
		      ENDIF
		
		      .cmSqlProperties.SaveProperties(@m.cSource)
		
		      * If no connection explicitly specified, use the one the source view is based on
		      IF EMPTY(.cConnection)
		        .cConnection = DBGETPROP(m.cSource, 'View', 'ConnectName')
		      ENDIF
		
		      * Replace the source string with the SQL command we use to build the result cursor.
		      STORE .cmSqlProperties.cViewSql TO .cSource
		    ENDIF
		
		    * Force the lNoDataOnLoad flag if the SQL contains client side parameters
		    IF .lNoDataOnLoad OR NOT EMPTY(THIS.GetViewParameters())  
		      .lNoDataOnLoad = .T.
		    ENDIF
		
		    * Open the connection to the remote data source
		    .nConnID = THIS.OpenConnection()
		    IF .nConnID > 0
		      * Store a copy of the native VFP connection handle for our internal use.
		      THIS.nConnection = .oConnMan.GetProp(.nConnID, 'Connection')
		
		      DO CASE
		        CASE .lNoCursorOnLoad
		          * If caller doesn't want the empty cursor result set on open, we're all done now.
		          RETURN .T.
		        CASE .lNoDataOnLoad
		          * Create an empty cursor
		          RETURN THIS.QueryFormatOnly()
		        OTHERWISE
		          * Query the cursor for its data set.
		          RETURN THIS.Requery()
		      ENDCASE
		    ENDIF
		  ENDWITH
		  RETURN .F.
		
	ENDPROC

	PROCEDURE queryformatonly		&& Return the format (column definitions) of the cursor generated by the passed SQL statement, as a recordset with 0 records.
		*++
		*>>Return the format (column definitions) of the cursor generated by the passed SQL statement, as a recordset with 0 records.
		*--
		LOCAL cSource, cKeyword
		
		  m.cSource = THIS.Parent.cSource
		  m.cKeyWord = UPPER(GetToken(m.cSource, ' '))
		  DO CASE
		    CASE m.cKeyWord == 'SELECT'
		      * Get rid of the WHERE clause, including all client-side parameters.
		      m.cSource = THIS._SetWhere(m.cSource, '1=2', .T.)
		    CASE m.cKeyWord == 'EXEC'
		      LOCAL cParamlist, cParam
		      * Replace any client-side parameters with null, for clean execution
		      m.cParamlist = THIS.GetViewParameters(.T.)  && Force ALL params to NULL for nodata query
		      DO WHILE NOT EMPTY(m.cParamlist)
		        m.cParam = GetToken(GetToken(@m.cParamlist, ';'), ',')
		        m.cSource = THIS._InsertParamValue(@m.cSource, m.cParam, 'NULL')
		      ENDDO
		    OTHERWISE
		      RETURN .F.
		  ENDCASE
		
		  * SET FMTONLY ON is very fast, but Server-specific.
		  IF SQLEXEC(THIS.nConnection, 'SET FMTONLY ON ' + m.cSource + ' SET FMTONLY OFF', THIS.cWorkarea) > 0
		    RETURN THIS.Parent.cmSqlProperties.RestoreProperties()
		  ENDIF
		  THIS.SqlError(m.cSource)
		  RETURN .F.
		
	ENDPROC

	PROCEDURE replace		&& Set the value of the specified field. If cursor is based on a remote view, then apply field valid rules copied from DBC.
		LPARAMETERS cField, uValue
		*++
		*>>Set the value of the specified field. If cursor is based on a remote view, then apply field valid rules copied from DBC.
		* For SQLPT cursors.
		*--
		LOCAL cMsg, uOriginal, cRule
		
		  * Save original value in case we need to fall back.
		  m.uOriginal = EVALUATE(THIS.cWorkarea + '.' + m.cField)
		  REPLACE (m.cField) WITH m.uValue IN (THIS.cWorkarea)
		
		  WITH THIS.Parent.cmSqlProperties
		    m.cRule = .GetFieldRule(m.cField, @m.cMsg)
		    IF NOT EMPTY(m.cRule)
		      * Evaluate the DBC rule with this cursor selected, in the context of the cursor object.
		      m.lStatus = THIS.Parent._Evaluate(m.cRule)
		
		      IF NOT m.lStatus
		        LOCAL cText
		        * Evaluate error message expression copied from DBC, if any. Otherwise, use generic msg.
		        IF NOT EMPTY(m.cMsg)
		          THIS.SetErrorMode(ERRMASK_SILENT_ALL)        && Ignore any errors
		          m.cText = EVALUATE(m.cMsg)
		          IF NOT EMPTY(THIS.nLastError)
		            m.cText = m.cMsg                           && Eval failed, use un-evaluated expression
		          ENDIF
		          THIS.SetErrorMode()                          && Restore original error mode
		        ELSE
		          m.cText = '%msgFieldValidFailed'
		        ENDIF
		
		        * Display error message, and restore original value.
		        THIS.DisplayMessage(m.cText)
		        IF NOT THIS._IsEqual(m.uValue, m.uOriginal)
		          REPLACE (m.cField) WITH m.uOriginal IN (THIS.cWorkarea)
		        ENDIF
		        RETURN .F.
		      ENDIF
		    ENDIF
		  ENDWITH
		  RETURN .T.
		
	ENDPROC

	PROCEDURE requery		&& Requery on a SQLPT cursor. Use SQLEXEC() on the sql if connection is non-empty. Else, execute directly.
		*++
		*>>Requery on a SQLPT cursor. Use SQLEXEC() on the sql if connection is non-empty. Else, execute directly.
		* If cursor is displayed in a grid, DM level Before/AfterRequery() need to reset 
		* grid.recordsource and column Controlsource.
		*--
		LOCAL cSQL, cParam, cParamlist, uValue
		
		  IF NOT EMPTY(THIS.nConnection)
		    * Update the WHERE clause if this is a SELECT statement.
		    m.cSQL = THIS.Parent.cSource
		    IF UPPER(LEFT(m.cSQL, 7)) == 'SELECT ' AND NOT EMPTY(THIS.Parent.cWhere)
		      m.cSQL = THIS._SetWhere(m.cSQL, THIS.Parent.cWhere)
		    ENDIF
		
		    * Evaluate any parameter variables, and insert the values into the SQL statement
		    m.cParamlist = THIS.GetViewParameters(.T.)  && Return all params that need to be evaluated
		    DO WHILE NOT EMPTY(m.cParamlist)
		      m.cParam = GetToken(GetToken(@m.cParamlist, ';'), ',')
		      IF TYPE(m.cParam) = 'U'
		        THIS.DisplayMessage('Query Parameter "\c" is not defined for SQLPT cursor "\c"', m.cParam, THIS.Parent.Name)
		        RETURN .F.
		      ENDIF
		      m.cSql = THIS._InsertParamValue(@m.cSql, m.cParam, THIS._ValueToChar(EVALUATE(m.cParam)))
		    ENDDO
		
		    * Send the command to the server for execution
		    IF SQLEXEC(THIS.nConnection, m.cSQL, THIS.cWorkarea) > 0
		      * Need to re-apply any filter that is supposed to be in affect.
		      IF NOT EMPTY(THIS.Parent.cFilter)
		        THIS.SetFilter(THIS.Parent.cFilter)
		      ENDIF
		      RETURN THIS.Parent.cmSqlProperties.RestoreProperties()
		    ENDIF
		    THIS.SqlError(m.cSQL)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataaccesstable AS cmdataaccessabstract OF "cmdataa.vcx" 		&& Class for table access and manipulation.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_Access.bmp" ClassIcon="..\graphics\_Access.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: deletewhere		&& Delete Native Table records that match the specified expression, and commit as appropriate.
		*m: pack		&& Pack the table, removing deleted records. Applies to native VFP tables only.
		*m: parentkeychanged		&& Update the FK for all records related to current parent recored, after the parent's PK was changed.
		*m: primarykeychanged		&& Reset child foriegn keys in table-buffered children, after the primary key of this cursor has been changed.
		*m: revert		&& Discard all buffered changes to the current record. Custom version for VFP tables.
		*m: select		&& Restrict our recordset to only those matching the current parent record
		*m: setexclusive		&& Reopen (if necessary) a table with exclusive access, and buffering disabled.
		*m: setrelation		&& Set a VFP relationship between 2 tables, and set default RI options.
		*m: _restoreshared		&& Internal method to return a table to shared access.
		*p: lselectbyrequery
	*</DefinedPropArrayMethod>

	lselectbyrequery = .F.
	Name = "cmdataaccesstable"
	
	PROCEDURE deletewhere		&& Delete Native Table records that match the specified expression, and commit as appropriate.
		LPARAMETERS cWhere, nFlags
		*++
		*>>Delete Native Table records that match the specified expression, and commit as appropriate.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN    4 - Don't process related child cursors.
		*    UPDATEMASK_COMMIT       64 - Commit operation even if not required by buffering mode.
		*    UPDATEMASK_REQUERY     128 - For views, requery the local cursor after deleting records from server.
		*                                 For native tables, we only test it to ensure we don't pass it on to child deletes.
		*
		* If row-buffered, each record will be commited as we go, regardless of nFlags.
		*
		* When called to delete child records when a parent record is deleted, the UPDATEMASK_COMMIT flag 
		* bit should only be clear if this is a tablebuffered native table, with a table-buffered parent.
		*--
		LOCAL cFilter, cKeyFilter, lStatus, nSelect
		
		  m.lStatus = .T.
		  IF NOT THIS.IsEmpty()
		    * Need to remove any SET FILTER and SET KEY filter expressions first.
		    m.cFilter = FILTER(THIS.cWorkarea)
		
		    * VFP 6.0 has a parser bug that wont allow the IN clause of SET FILTER TO when no expression is specified.
		    m.nSelect = SELECT()
		    SELECT (THIS.cWorkarea)
		    SET FILTER TO
		    IF NOT EMPTY(ORDER())
		      m.cKeyFilter = THIS._GetKeyFilter()
		      SET KEY TO
		    ENDIF
		    SELECT (m.nSelect)
		
		    DO WHILE m.lStatus AND THIS.Find('NOT DELETED() AND ' + m.cWhere)
		      * Delete the record (and any children). This also triggers AfterDeleteRecord() event for each table record.
		      * Do not pass the UPDATEMASK_REQUERY flag along to any child cursors.
		      m.lStatus = THIS.Parent.DeleteRecord(BITAND(m.nFlags, BITNOT(UPDATEMASK_REQUERY)))
		    ENDDO
		
		    * Restore original filters, in case caller expects them to still be in effect.
		    IF NOT EMPTY(m.cFilter)
		      SET FILTER TO &cFilter IN (THIS.cWorkarea)
		    ENDIF
		    IF NOT EMPTY(m.cKeyFilter)
		      THIS._SetKeyFilter(m.cKeyFilter)
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE pack		&& Pack the table, removing deleted records. Applies to native VFP tables only.
		LPARAMETERS cOption
		*++
		*>>Pack the table, removing deleted records. Applies to native VFP tables only.
		*--
		LOCAL nBuffer
		  SELECT (THIS.cWorkarea)
		  IF THIS.IsExclusive()
		    m.nBuffer = THIS.GetBufferMode()
		    THIS.SetBufferMode(1)
		    IF EMPTY(m.cOption)
		      PACK
		    ELSE
		      PACK &cOption
		    ENDIF
		    THIS.SetBufferMode(m.nBuffer)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE parentkeychanged		&& Update the FK for all records related to current parent recored, after the parent's PK was changed.
		*++
		*>>Update the FK for all records related to current parent recored, after the parent's PK was changed.
		*--
		LOCAL uKeyValue
		
		  * Change all the FK fields to match the new parent.
		  DODEFAULT()
		
		  * Update SET KEY filter for child recordset, and restore original record pointer.
		  * We don't use the cursor.Select() here, because we want to stay on same child record,
		  * and avoid overhead of re-selecting grandchildren caused by Select() moving to top.
		  m.uKeyValue = THIS.Parent.oParent.FieldValue(THIS.Parent.cParentKeyField)
		  SET KEY TO m.uKeyValue IN (THIS.cWorkarea)
		
	ENDPROC

	PROCEDURE primarykeychanged		&& Reset child foriegn keys in table-buffered children, after the primary key of this cursor has been changed.
		*++
		*>>Reset child foriegn keys in table-buffered children, after the primary key of this cursor has been changed.
		*--
		LOCAL oChild
		  FOR EACH oChild IN THIS.Parent.aChildren
		    IF NOT ISNULL(m.oChild) AND m.oChild.lRequeryWhenParentMoves
		      m.oChild.ParentKeyChanged()
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE revert		&& Discard all buffered changes to the current record. Custom version for VFP tables.
		LPARAMETERS nFlags
		*++
		*>>Discard all buffered changes to the current record. Custom version for VFP tables.
		*--
		  IF DODEFAULT(m.nFlags)
		    * If this is a child table, with recordset restricted to those matching the parent, we 
		    * need to reissue SET KEY, in case the PK of the parent was reverted to a previous value.
		    WITH THIS.Parent   && Reference our cursor object
		      * On host object shutdown after errors, a parent cursor might have 
		      * already been closed, so check for that case.
		      IF NOT ISNULL(.oParent) AND .lRequeryWhenParentMoves AND .oParent.IsOpen()
		        m.uKeyValue = .oParent.FieldValue(.cParentKeyField)
		        SET KEY TO m.uKeyValue IN (THIS.cWorkarea)
		      ENDIF
		    ENDWITH
		  ENDIF
		
	ENDPROC

	PROCEDURE select		&& Restrict our recordset to only those matching the current parent record
		LPARAMETERS uKeyValue
		*++
		*>>Restrict our recordset to only those matching the current parent record
		*--
		  SET KEY TO m.uKeyValue IN (THIS.cWorkarea)
		
		  * This will call afternav(), and make recursive calls to Select() if necessary
		  * to process any of our own child cursors.
		  THIS.Parent.GoTop()
		
	ENDPROC

	PROCEDURE setexclusive		&& Reopen (if necessary) a table with exclusive access, and buffering disabled.
		LPARAMETERS lExclusive
		*++
		*>>Reopen (if necessary) a table with exclusive access, and buffering disabled.
		*--
		LOCAL cPath
		  * Fail if the file is currently (or physically) read-only
		  IF NOT USED(THIS.cWorkarea) OR ISREADONLY(THIS.cWorkarea)
		    THIS.Displaymessage('%msgReadonly')
		    RETURN .F.
		  ENDIF
		
		  SELECT (THIS.cWorkarea)
		  IF ISEXCLUSIVE() != m.lExclusive
		    m.cPath = DBF()
		    IF m.lExclusive
		      THIS.AddProperty('cSaveFilter', FILTER())
		      THIS.AddProperty('cSaveKey', THIS._GetKeyFilter())
		      THIS.AddProperty('cSaveOrder', ORDER())
		      THIS.AddProperty('lSaveDescending', DESCENDING())
		
		      THIS.nLastError = 0
		      USE (m.cPath) EXCLUSIVE ALIAS (THIS.cWorkarea)
		      IF EMPTY(THIS.nLastError)
		        RETURN .T.
		      ENDIF
		    ENDIF
		
		    * Reopen as shared, and restore original filters and index order.
		    USE (m.cPath) SHARED AGAIN ALIAS (THIS.cWorkarea)
		
		    * Reapply the same open options as it originally had, if they are saved.
		    IF PEMSTATUS(THIS, 'cSaveFilter', 5)
		      * Order [ascend/Descend], Filter, Key
		      IF NOT EMPTY(THIS.cSaveFilter)
		        LOCAL cFilter
		        m.cFilter = THIS.cSaveFilter
		        SET FILTER TO &cFilter
		      ENDIF
		
		      * Restore original index order and SET KEY filter, if the index tag still exists.
		      IF NOT EMPTY(THIS.cSaveOrder) AND TAGNO(THIS.cSaveOrder) > 0
		        IF THIS.lSaveDescending 
		          SET ORDER TO (THIS.cSaveOrder) DESCENDING
		        ELSE
		          SET ORDER TO (THIS.cSaveOrder)
		        ENDIF
		        THIS._SetKeyFilter(THIS.cSaveKey)
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * We return with this workarea left as the current one.
		  RETURN USED() AND ISEXCLUSIVE() = m.lExclusive
		
	ENDPROC

	PROCEDURE setrelation		&& Set a VFP relationship between 2 tables, and set default RI options.
		LPARAMETERS oParent, cParentKeyField
		*++
		*>>Set a VFP relationship between 2 tables, and set default RI options.
		*
		* If cExpr parameter is empty, then remove any existing relationship into the specified child.
		*--
		LOCAL nSelect
		
		  * Make sure that the parent cursor is also an open VFP cursor. Note that the parent may 
		  * be a local or remote view, with a temporary index created on open.
		  IF USED(m.oParent.cWorkarea)
		    IF NOT USED(THIS.cWorkarea)   && Our table must be open, or fail.
		      RETURN .F.
		    ENDIF
		
		    * A child cursor can only have one relation to one parent, so clear any existing parent.
		    m.nSelect = SELECT()
		    SELECT (THIS.cWorkarea)
		    SET RELATION OFF INTO (THIS.cWorkarea) IN (m.oParent.cWorkarea)
		    IF NOT EMPTY(ORDER())
		      SET KEY TO     && The IN clause does not work for removing a key expression
		    ENDIF
		    SELECT (m.nSelect)
		
		    IF NOT EMPTY(m.cParentKeyField)
		      LOCAL cExpr
		      m.cExpr = m.cParentKeyField
		
		      * Create a matching native VFP relation if there is an index,
		      * and we are not using Requery for child record selection.
		      IF NOT EMPTY(ORDER()) AND NOT THIS.lSelectByRequery
		        SET RELATION TO &cExpr INTO (THIS.cWorkarea) IN (m.oParent.cWorkarea) ADDITIVE
		      ENDIF
		
		      * If not explicity set, determine default relation type
		      WITH m.oParent
		        * If NULL, we see if our cParentKeyField expression matches a PRIMARY 
		        * or CANDIDATE key in the parent table. If a match is found, then we set
		        * lRequeryWhenParentMoves to .T., which results in our recordset being
		        * filtered (via SET KEY) to match the current parent record's key value.
		        IF ISNULL(THIS.Parent.lRequeryWhenParentMoves)
		          LOCAL ix, cKey
		          m.ix = 1
		          m.cKey = NORMALIZE(.cmDataAccess.ExtractFieldname(m.cExpr))
		          THIS.Parent.lRequeryWhenParentMoves = .F.
		          DO WHILE NOT EMPTY(KEY(m.ix, .cWorkarea))
		            * If the main field in the relation expression matches 
		            * the main field of the PK expression, we consider it a match.
		            IF .cmDataAccess.ExtractFieldname(KEY(m.ix, .cWorkarea)) == m.cKey
		              * Only treat as a navigational relation if the relational expression matches
		              * a parent primary or cadidate index.
		              IF PRIMARY(m.ix, .cWorkarea) OR CANDIDATE(m.ix, .cWorkarea)
		                THIS.Parent.lRequeryWhenParentMoves = .T.
		                EXIT
		              ENDIF
		            ENDIF
		            m.ix = m.ix + 1
		          ENDDO
		        ENDIF
		      ENDWITH
		
		      WITH THIS.Parent  && This cursor
		        * If not explicity set, determine default delete setting
		        IF ISNULL(.lDeleteWithParent)
		          .lDeleteWithParent = .lRequeryWhenParentMoves
		        ENDIF
		      ENDWITH
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN DODEFAULT(m.oParent)
		
	ENDPROC

	PROCEDURE _restoreshared		&& Internal method to return a table to shared access.
		LPARAMETERS cPath
		*++
		*>>Internal method to return a table to shared access.
		*--
		  IF THIS.lSaveExclusive
		    * Cursor was originaly exclusive, just need to restore original buffer mode
		    CURSORSETPROP('Buffering', THIS.nSaveBuffer)
		  ELSE
		    IF EMPTY(m.cPath)
		      SELECT (THIS.cWorkarea)
		      m.cPath = DBF()
		    ENDIF
		    USE (m.cPath) SHARED AGAIN ALIAS (THIS.cWorkarea)
		
		    * Reopen the table shared, with the same open options as it originally had.
		    * Order [ascend/Descend], Filter, Key
		    IF NOT EMPTY(THIS.cSaveFilter)
		      SET FILTER TO (THIS.cSaveFilter)
		    ENDIF
		    IF NOT EMPTY(THIS.cSaveOrder)
		      IF THIS.lSaveDescending 
		        SET ORDER TO (THIS.cSaveOrder) DESCENDING
		      ELSE
		        SET ORDER TO (THIS.cSaveOrder)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataaccessview AS cmdataaccessabstract OF "cmdataa.vcx" 		&& Class abstract for local and remote view data access and manipulation.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_Access.bmp" ClassIcon="..\graphics\_Access.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: getforeignkeyfield		&& Try to determine the foreign key field for this view, when it is a child in a relation.
		*m: getposition		&& Return the current record position - by PK value for views/SQLPT. Return NULL if no PK field is available.
		*m: getprimarykeyfield		&& Return the Primary key field for this cursor, if one can be found.
		*m: isprimarykeyupdateable		&& Determine if primary key field is updateable.
		*m: select		&& Restrict our recordset to only those matching the current parent record
		*m: setposition		&& Set the current record position - by PK value for views/SQLPT.
		*m: setrelation		&& Set a parent-child relationship between two cursors, and set default RI options.
	*</DefinedPropArrayMethod>

	Name = "cmdataaccessview"
	
	PROCEDURE getforeignkeyfield		&& Try to determine the foreign key field for this view, when it is a child in a relation.
		*++
		*>>Try to determine the foreign key field for this view, when it is a child in a relation.
		*--
		  * If no FK specified, default to a field with same name as parent field, if one exists.
		  IF NOT EMPTY(THIS.Parent.cParentKeyField) AND THIS.IsField(THIS.Parent.cParentKeyField)
		    RETURN THIS.Parent.cParentKeyField
		  ENDIF
		  RETURN ''
		
	ENDPROC

	PROCEDURE getposition		&& Return the current record position - by PK value for views/SQLPT. Return NULL if no PK field is available.
		*++
		*>>Return the current record position - by PK value for views/SQLPT. Return NULL if no PK field is available.
		*--
		  WITH THIS.Parent
		    IF NOT EMPTY(.cPrimaryKeyField)
		      RETURN THIS.FieldValue(.cPrimaryKeyField)
		    ENDIF
		  ENDWITH
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE getprimarykeyfield		&& Return the Primary key field for this cursor, if one can be found.
		*++
		*>>Return the Primary key field for this cursor, if one can be found.
		*--
		LOCAL nSelect, cField
		
		  m.cField = ''
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		  m.cField = GetToken(CURSORGETPROP('KeyFieldList'), ',')  && Views
		  SELECT (m.nSelect)
		  RETURN m.cField
		
	ENDPROC

	PROCEDURE isprimarykeyupdateable		&& Determine if primary key field is updateable.
		*++
		*>>Determine if primary key field is updateable. 
		*--
		  * Note that return value is only meaningful if cPrimaryKeyField is not empty.
		  RETURN NOT EMPTY(THIS.Parent.cPrimaryKeyField) ;
		         AND CURSORGETPROP('SendUpdates', THIS.cWorkarea);
		         AND ',' + THIS.Parent.cPrimaryKeyField + ',' $ ',' + CURSORGETPROP('UpdatableField', THIS.cWorkarea) + ','
		
	ENDPROC

	PROCEDURE select		&& Restrict our recordset to only those matching the current parent record
		LPARAMETERS uKeyValue
		*++
		*>>Restrict our recordset to only those matching the current parent record
		*--
		  * Add wildcard character to string keys if SET EXACT is off, and comparison is LIKE.
		  * This makes Select() behave the same for views as it does for native VFP tables.
		  IF SET('EXACT') = 'OFF' AND VARTYPE(m.uKeyValue) = 'C' ;
		  AND 'LIKE ?' $ CURSORGETPROP('SQL', THIS.cWorkarea)
		    m.uKeyValue = m.uKeyValue + '%'
		  ENDIF
		
		  * Requery the parameterized view using parent key value as parameter.
		  RETURN THIS.Parent.Requery(@m.uKeyValue)
		
	ENDPROC

	PROCEDURE setposition		&& Set the current record position - by PK value for views/SQLPT.
		LPARAMETERS uPosition
		*++
		*>>Set the current record position - by PK value for views/SQLPT.
		*
		* The uPosition parameter is normally a values previously returned by the GetPosition() method.
		*--
		  WITH THIS.Parent
		    IF NOT EMPTY(.cPrimaryKeyField)
		      RETURN .Find(.cPrimaryKeyField + ' == ' + THIS._ValueToChar(m.uPosition))
		    ENDIF
		  ENDWITH
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setrelation		&& Set a parent-child relationship between two cursors, and set default RI options.
		LPARAMETERS oParent, cParentKeyField
		*++
		*>>Set a parent-child relationship between two cursors, and set default RI options.
		*--
		  * If not explicity set, determine default relation type
		  IF NOT EMPTY(m.cParentKeyField)
		    WITH THIS.Parent  && This cursor object
		      IF ISNULL(.lRequeryWhenParentMoves)
		        .lRequeryWhenParentMoves = .T.
		      ENDIF
		
		      * If not explicity set, default is true for views based on a single updateable table.
		      IF ISNULL(.lDeleteWithParent)
		        LOCAL cSourceTable
		        IF USED(.cWorkarea) && May not be open if SQLPT cursor with lNoCursorOnLoad set.
		          m.cSourceTable = CURSORGETPROP('Tables', .cWorkarea)
		        ENDIF
		        .lDeleteWithParent = NOT EMPTY(m.cSourceTable) AND NOT ',' $ m.cSourceTable
		      ENDIF
		    ENDWITH
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdatatransport AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: afterinit
		*m: comments
		*m: gather
		*m: scatter
	*</DefinedPropArrayMethod>

	Name = "cmdatatransport"
	
	PROCEDURE afterinit
		RETURN .T.
		
	ENDPROC

	PROCEDURE comments
		*++
		* Lightweight class for loading custom properties with record data for each transport 
		* between objects and datasessions.
		*
		* The Scatter() and Gather() methods can be used for custom code to load
		* and unload custom property values from their source data.
		*
		* Copyright 1997-2005 Soft Classics, Ltd.
		*--
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		  *++
		  * Fatal coding error - Pass it on to CodeMine error handler if available.
		  * Returns .T. if user said to ignore error, or if it is an error we handle here.
		  *--
		  LOCAL oMessage
		
		    m.cMsg = MESSAGE()   && Save error message text in case other call clears it.
		    m.oMessage = FindGlobalObject('cmMessage')
		    IF NOT ISNULL(m.oMessage)
		      RETURN m.oMessage.FatalError(@m.cMsg, @m.cMethod, m.nLine)  && Usually .T. if anything
		    ENDIF
		
		    * No Codemine Message handler object is available.
		    ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		    RETURN .F.
		
	ENDPROC

	PROCEDURE gather
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS cValue
		
		  THIS.AfterInit()
		  IF PCOUNT() = 1
		    THIS.Scatter(@m.cValue)
		  ENDIF
		
	ENDPROC

	PROCEDURE scatter
		LPARAMETERS cValue
		
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmglobalconnectionlist AS cmdataabstract OF "..\common\cmdataa.vcx" 		&& Global list of remote data connections shared across different data sessions.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_ConnManager.bmp" ClassIcon="..\graphics\_ConnManager.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addsharedconnection		&& Returns either a VFP connection handle or an ADO connection object ref.
		*m: freesharedconnection		&& Decrement use count on a global shared connection, and return .T. when count reaches 0 so caller can release it.
		*m: usesharedconnection		&& Find a shared connection of the specified name, increment its use count, and return the VFP handle or ADO ref.
		*p: cclass		&& Foundation class name for this class. Do not change this value in any subclass.
	*</DefinedPropArrayMethod>

	cclass = cmGlobalConnectionList		&& Foundation class name for this class. Do not change this value in any subclass.
	Name = "cmglobalconnectionlist"
	
	PROCEDURE addsharedconnection		&& Returns either a VFP connection handle or an ADO connection object ref.
		LPARAMETERS cShareName, uConn
		*++
		*>>Returns either a VFP connection handle or an ADO connection object ref.
		*--
		
	ENDPROC

	PROCEDURE freesharedconnection		&& Decrement use count on a global shared connection, and return .T. when count reaches 0 so caller can release it.
		LPARAMETERS cShareName
		*++
		*>>Decrement use count on a global shared connection, and return .T. when count reaches 0 so caller can release it.
		*--
		
	ENDPROC

	PROCEDURE usesharedconnection		&& Find a shared connection of the specified name, increment its use count, and return the VFP handle or ADO ref.
		LPARAMETERS cShareName, cType
		*++
		*>>Find a shared connection of the specified name, increment its use count, and return the VFP handle or ADO ref.
		*--
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmruleabstract AS cmdataabstract OF "cmdataa.vcx" 		&& Codemine Data Rule abstract class. Foundation for Data Manager and Rule classes.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afteraddchild		&& This event is called after AddChild() successfully adds a child cursor to the parent.
		*m: afterchange		&& This event is called after a field has been updated by the Replace() method.
		*m: afterdelete		&& AfterDelete() event occurs after a record is deleted via the Delete() method.
		*m: afterdeleterecord		&& AfterDeleteRecord() event occurs after every record is deleted, and before the deletion has been committed.
		*m: afternav		&& Called after record pointer moves. Can be used to requery child cursors when parent record moves.
		*m: afternew		&& AfterNew() event occurs after a new record is added to a cursor, but before any child recordsets are selected.
		*m: afternew2		&& AfterNew2() event occurs after a new record is added to a cursor and any child recordsets are selected. You can use this to add new childrecords automatically when the parent is added.
		*m: afteropen		&& Called after a cursor is opened.
		*m: afterrequery		&& AfterRequery occurs after a view cursor is requeried.
		*m: afterrevert		&& AfterRevert rule event occurs after changes are discarded.
		*m: afterupdate		&& AfterUpdate event occurs after all changes have been saved to source tables.
		*m: afterupdatefailure		&& AfterUpdateFailure rule occurs after an error occurs preventing successful completion of UpdateAll().
		*m: beforeclose		&& Called before a cursor is about to be closed.
		*m: beforedelete		&& BeforeDelete() event occurs before a record is deleted. Return .F. to prevent deletion
		*m: beforedeleterecord
		*m: beforenav		&& Called before record pointer moves. Return .F. to prevent record pointer from moving.
		*m: beforenew		&& BeforeNew() event occurs before a new record is added.
		*m: beforerequery		&& BeforeRequery occurs before a view cursor is requeried. Return .F. to prevent the requery.
		*m: beforerevert		&& BeforeRevert rule event occurs before changes are discarded.
		*m: beforeupdate		&& BeforeUpdate event occurs before all changes are saved to source tables. Return .F. to prevent update.
		*m: beforeupdatefailure		&& BeforeUpdateFailure before default error processing when an update error occurs. Return .T. for default processing of the error, .F. to fail silently, or .NULL. to retry.
		*m: cursorvalid		&& Cursor level validation rule code.
		*m: curvalue		&& Return the current value of the specified field
		*m: delete		&& Delete the current record in specified workarea, along with any related child records.
		*m: deleterecord		&& Low level method to Delete a record. Commits if cursor is row-buffered. Does not support related child cursors.
		*m: edit		&& Edit the current record in the cursor, by triggering the EditRule() event for the cursor.
		*m: editrule		&& EditRule() event occurs when the Cursor.Edit() method is called.
		*m: fieldtype		&& Return the data type of the specified field. Length and Decimal places are returned in the 2 optional output parameters.
		*m: fieldvalid		&& Validate the new value for a field before it is applied.
		*m: fieldvalue		&& Return the local buffered value of the specified field
		*m: find		&& Find the first record in the cursor that matches the specified expression. If lContinue parameter is .T. the search begins with the current record.
		*m: getbuffermode		&& Return the buffering mode of the cursor open in the specified workarea
		*m: getchildren		&& Return a comma separated list of all child workareas related to the specified workarea.
		*m: getcursor		&& Return a reference to the named cursor object, based on workarea name.
		*m: getfilter		&& Return the current filter expression for the specifide cursor.
		*m: getparent		&& Return the parent workarea (or empty string) of the specified workarea.
		*m: getprop		&& Return various property settings about the specified cursor.
		*m: gobottom		&& Go to the last record in the cursor
		*m: goto		&& Go to the specified record number in the cursor
		*m: gotop		&& Go to the first record in the cursor
		*m: isbottom		&& Return the "Bottom" state of the current record in the specified workarea.
		*m: ischanged		&& Returns true if any record in the specified list of cursors contains uncommited changes.
		*m: isdeleteallowed		&& Determine whether or not records may be deleted from the specified workarea.
		*m: isdeleteallowedrule		&& Custom developer code to determine whether or not records may be deleted from the cursor via the User Interface.
		*m: isdeleted		&& Return the "Deleted" state of the current record in the specified workarea.
		*m: iseditallowed		&& Determine whether or not the current record may be edited in the specified workarea.
		*m: iseditallowedrule		&& Custom developer code to determine if the specified field may be edited interactively.
		*m: isempty		&& Determine whether or not the specified cursor has any records.
		*m: iseof		&& Determine whether or not the specified cursor is at EOF.
		*m: isexclusive		&& Determine whether or not the specified cursor opened with Exclusive access.
		*m: isfield		&& Return true if the specified field name is present in this cursor
		*m: isfieldchanged		&& Returns true if the specified field in the specified cursor has been modified.
		*m: isnew		&& Return the "New" state of the current record in the specified workarea.
		*m: isnewallowed		&& Determine whether or not records may be added to the specified workarea.
		*m: isnewallowedrule		&& Custom developer code to determine whether or not records may be added to the cursor via the User Interface.
		*m: isopen		&& Return true is the specified cursor alias is currently open in this data session.
		*m: isreadonly		&& Determine whether or not the specified workarea is read-only.
		*m: isreadonlyrule		&& Custom developer code to determine if the cursor is Read-Only.
		*m: isrecordchanged		&& Returns true if the current record in the specified workarea, or any child record, contains uncommited changes.
		*m: isrequired		&& Determine whether or not the specified field is required.
		*m: isrequiredrule		&& Custom developer code to determine if a field is required. Enforced at the interface level only.
		*m: istop		&& Return the "Top" state of the current record in the specified workarea.
		*m: lockforedit		&& Obtain whatever locks are necessary before allowing a change to the current record of the specified cursor.
		*m: lockrecord		&& Obtain network Lock for the current record in specified workarea.
		*m: new		&& Add a new record to the specified cursor.
		*m: nicecursorname		&& Return a user-friendly name for the specified cursor.
		*m: nicefieldname		&& Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		*m: oform_access		&& Find a reference to the form that this object is a part of. Return NULL if not part of a form.
		*m: oldvalue		&& Return the old value of the specified field
		*m: pack		&& Pack the specified table
		*m: primarykeychanged		&& Reset child cursor foriegn keys after the primary key of the parent has been changed.
		*m: recordreadytomove		&& Determine if the record pointer can be moved or not.
		*m: recordwasmoved		&& Re-sync cursor position flags and child recordsets with a cursor moved or modified by direct VFP commands, outside of the cursor object's knowledge.
		*m: refreshdata		&& Refresh data in the current record of the specified cursor.
		*m: reindex		&& Reindex the specified table
		*m: replace		&& Replace the contents of the specified field.
		*m: requery		&& Requery the specified view
		*m: revert		&& Discard changes to all records in the specified workarea
		*m: revertall		&& Discard changes to all records in specified workareas, and revert to original values.
		*m: revertrecord		&& Discard changes to the current record in the specified workarea
		*m: rowvalid		&& Row level validation rule code.
		*m: seek		&& Seek the record matching the specified key in the cursor. On failure, leave record pointer on original record.
		*m: setbuffermode		&& Set the buffering mode of the cursor open in the specified workarea
		*m: setdefault		&& Set the specified cursor as the current VFP workarea, if is is a native cursor.
		*m: setexclusive		&& Set the cursor to Exclusive  or Shared access.
		*m: setfilter		&& Set the record filter expression for the specified cursor.
		*m: setorder		&& Set the sort order for the specified cursor.
		*m: setrelation		&& Establish a relation between the two specified cursors, based on the specified expression.
		*m: skip		&& Skip the specified number of records forward or backwards.
		*m: update		&& Write changes for all records for this cursor back to the source.
		*m: updateall		&& Write all buffered changes in all workareas to disk for the specified workareas.
		*m: updaterecord		&& Write changes to the current record back to the source.
		*m: validatecursor		&& Validate the specified cursor by triggering all CursorValid() events.
		*m: validatefield		&& Validate the specified field in the cursor, by triggering all its FieldValid() events.
		*m: validaterow		&& Validate the current row in the specified cursor, by triggering all its RowValid() events.
		*m: _badworkarea		&& Display a developer error message when an unknown workarea alias is passed to a rule/DM method.
		*p: ocde		&& Runtime object reference to the Codemine Data Environment object we are linked to.
		*p: oform		&& Runtime object reference to the form that this object is a part of, or NULL if not part of a form.
		*p: othiscursor		&& Runtime object reference to the cursor object that triggered the currently executing rule method.
	*</DefinedPropArrayMethod>

	Name = "cmruleabstract"
	ocde = .NULL.		&& Runtime object reference to the Codemine Data Environment object we are linked to.
	oform = .NULL.		&& Runtime object reference to the form that this object is a part of, or NULL if not part of a form.
	othiscursor = .NULL.		&& Runtime object reference to the cursor object that triggered the currently executing rule method.
	
	PROCEDURE afteraddchild		&& This event is called after AddChild() successfully adds a child cursor to the parent.
		LPARAMETERS cWorkarea, oChildCursor
		*++
		*>>This event is called after AddChild() successfully adds a child cursor to the parent.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterchange		&& This event is called after a field has been updated by the Replace() method.
		LPARAMETERS cWorkarea, cField
		*++
		*>>This event is called after a field has been updated by the Replace() method.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterdelete		&& AfterDelete() event occurs after a record is deleted via the Delete() method.
		LPARAMETERS cWorkarea
		*++
		*>>AfterDelete() event occurs after a record is deleted via the Delete() method.
		* Deleted record is still current, and all children have already been deleted, if appropriate.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterdeleterecord		&& AfterDeleteRecord() event occurs after every record is deleted, and before the deletion has been committed.
		LPARAMETERS cWorkarea
		*++
		*>>AfterDeleteRecord() event occurs after every record is deleted, and before the deletion has been committed.
		* Deleted record is locked and current in workarea, and deletion has not been committed.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afternav		&& Called after record pointer moves. Can be used to requery child cursors when parent record moves.
		LPARAMETERS cWorkarea
		*++
		*>>Called after record pointer moves. Can be used to requery child cursors when parent record moves.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afternew		&& AfterNew() event occurs after a new record is added to a cursor, but before any child recordsets are selected.
		LPARAMETERS cWorkarea
		*++
		*>>AfterNew() event occurs after a new record is added to a cursor, but before any child recordsets are selected.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afternew2		&& AfterNew2() event occurs after a new record is added to a cursor and any child recordsets are selected. You can use this to add new childrecords automatically when the parent is added.
		LPARAMETERS cWorkarea
		*++
		*>>AfterNew2() event occurs after a new record is added to a cursor and any child recordsets are selected. You can use this to add new childrecords automatically when the parent is added.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afteropen		&& Called after a cursor is opened.
		LPARAMETERS cWorkarea
		*++
		*>>Called after a cursor is opened.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterrequery		&& AfterRequery occurs after a view cursor is requeried.
		LPARAMETERS cWorkarea
		*++
		*>>AfterRequery occurs after a view cursor is requeried.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterrevert		&& AfterRevert rule event occurs after changes are discarded.
		LPARAMETERS cWorkarea, lCurrentRecordOnly
		*++
		*>>AfterRevert rule event occurs after changes are discarded.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterupdate		&& AfterUpdate event occurs after all changes have been saved to source tables.
		LPARAMETERS cWorkarea, lCurrentRecordOnly
		*++
		*>>AfterUpdate event occurs after all changes have been saved to source tables.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterupdatefailure		&& AfterUpdateFailure rule occurs after an error occurs preventing successful completion of UpdateAll().
		LPARAMETERS cWorkarea, lCurrentRecordOnly
		*++
		*>>AfterUpdateFailure rule occurs after an error occurs preventing successful completion of UpdateAll().
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeclose		&& Called before a cursor is about to be closed.
		LPARAMETERS cWorkarea
		*++
		*>>Called before a cursor is about to be closed.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforedelete		&& BeforeDelete() event occurs before a record is deleted. Return .F. to prevent deletion
		LPARAMETERS cWorkarea
		*++
		*>>BeforeDelete() event occurs before a record is deleted. Return .F. to prevent deletion
		* Make sure its ok to delete.
		*  Example: do not allow an invoice that has shipped to be deleted.
		*  Example: remove or reassign references to this record from other tables before allowing delete.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforedeleterecord
		LPARAMETERS cWorkarea
		*++
		*>>BeforeDeleteRecord() event occurs before every record is deleted.
		*
		* You can use this to implement custom casdading delete code before deleting a parent record.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforenav		&& Called before record pointer moves. Return .F. to prevent record pointer from moving.
		LPARAMETERS cWorkarea
		*++
		*>>Called before record pointer moves. Return .F. to prevent record pointer from moving.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforenew		&& BeforeNew() event occurs before a new record is added.
		LPARAMETERS cWorkarea
		*++
		*>>BeforeNew() event occurs before a new record is added.
		* Make sure its ok to add - example: must enter billing info before adding invoice detail records.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforerequery		&& BeforeRequery occurs before a view cursor is requeried. Return .F. to prevent the requery.
		LPARAMETERS cWorkarea
		*++
		*>>BeforeRequery occurs before a view cursor is requeried. Return .F. to prevent the requery.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforerevert		&& BeforeRevert rule event occurs before changes are discarded.
		LPARAMETERS cWorkarea, lCurrentRecordOnly
		*++
		*>>BeforeRevert rule event occurs before changes are discarded.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeupdate		&& BeforeUpdate event occurs before all changes are saved to source tables. Return .F. to prevent update.
		LPARAMETERS cWorkarea, lCurrentRecordOnly
		*++
		*>>BeforeUpdate event occurs before all changes are saved to source tables. Return .F. to prevent update.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeupdatefailure		&& BeforeUpdateFailure before default error processing when an update error occurs. Return .T. for default processing of the error, .F. to fail silently, or .NULL. to retry.
		LPARAMETERS cWorkarea, nError, nError2
		*++
		*>>BeforeUpdateFailure before default error processing when an update error occurs. Return .T. for default processing of the error, .F. to fail silently, or .NULL. to retry.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE cursorvalid		&& Cursor level validation rule code.
		LPARAMETERS cWorkarea
		*++
		*>>Cursor level validation rule code.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE curvalue		&& Return the current value of the specified field
		LPARAMETERS cWorkArea, cField
		*++
		*>>Return the current value of the specified field
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.CurValue(@m.cField)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE delete		&& Delete the current record in specified workarea, along with any related child records.
		LPARAMETERS cWorkarea
		*++
		*>>Delete the current record in specified workarea, along with any related child records.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(@m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Delete()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE deleterecord		&& Low level method to Delete a record. Commits if cursor is row-buffered. Does not support related child cursors.
		LPARAMETERS cWorkarea
		*++
		*>>Low level method to Delete a record. Commits if cursor is row-buffered. Does not support related child cursors.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(@m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.DeleteRecord()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE displaymessage
		LPARAMETERS cMsg, uP1, uP2, uP3
		*++
		*>>Use the Message Manager service to display an error message, or store it for return to caller in a distributed app.
		*--
		LOCAL cCaption
		  IF NOT ISNULL(THIS.oMessage)
		    * Find the data manager. This may be ourself, or the DM responsible for 
		    * the cursor a rule is attached to.
		    IF NOT ISNULL(THIS.oCDE) AND NOT ISNULL(THIS.oCDE.oDM)
		      m.cCaption = THIS.oCDE.oDM.Parent.Caption
		    ELSE
		      m.cCaption = _SCREEN.Caption
		    ENDIF
		    THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_OK, MSG_SEVERITY_WARNING, m.cMsg, ;
		                         '', m.cCaption, m.uP1, m.uP2, m.uP3)
		  ENDIF
		
	ENDPROC

	PROCEDURE edit		&& Edit the current record in the cursor, by triggering the EditRule() event for the cursor.
		LPARAMETERS cWorkarea
		*++
		*>>Edit the current record in the specified cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(@m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Edit()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE editrule		&& EditRule() event occurs when the Cursor.Edit() method is called.
		LPARAMETERS cWorkarea
		*++
		*>>EditRule() event occurs when the Cursor.Edit() method is called.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE fieldtype		&& Return the data type of the specified field. Length and Decimal places are returned in the 2 optional output parameters.
		LPARAMETERS cWorkarea, cField, nLength, nDecimals
		*++
		*>>Return the data type of the specified field. Length and Decimal places are returned in the 2 optional output parameters.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    IF PCOUNT() = 2
		      RETURN m.oCursor.FieldType(@m.cField)
		    ELSE
		      RETURN m.oCursor.FieldType(@m.cField, @m.nLength, @m.nDecimals)
		    ENDIF
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE fieldvalid		&& Validate the new value for a field before it is applied.
		LPARAMETERS cWorkarea, cField, uValue
		*++
		*>>Validate the new value for a field before it is applied.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE fieldvalue		&& Return the local buffered value of the specified field
		LPARAMETERS cWorkArea, cField
		*++
		*>>Return the local buffered value of the specified field
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.FieldValue(@m.cField)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE find		&& Find the first record in the cursor that matches the specified expression. If lContinue parameter is .T. the search begins with the current record.
		LPARAMETERS eFor, cWorkarea, lContinue
		*++
		*>>Find the first record in the cursor that matches the specified expression. If lContinue parameter is .T. the search begins with the current record.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Find(@m.eFor, m.lContinue)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE getbuffermode		&& Return the buffering mode of the cursor open in the specified workarea
		LPARAMETERS cWorkArea
		*++
		*>>Return the buffering mode of the cursor open in the specified workarea
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.GetBufferMode()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE getchildren		&& Return a comma separated list of all child workareas related to the specified workarea.
		LPARAMETERS cWorkareaList, lGrandChildren
		*++
		*>>Return a comma separated list of all child workareas related to the specified workarea.
		* This function may be called recursively.
		*--
		LOCAL oCursor, cWorkarea, cChildren
		  m.cChildren = ''
		  DO WHILE NOT EMPTY(m.cWorkareaList)
		    m.cWorkarea = PROPER(GetToken(@m.cWorkareaList, ','))
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(m.oCursor)
		      m.cChildren = m.cChildren + m.oCursor.GetChildren(m.lGrandChildren)
		    ENDIF
		  ENDDO
		  RETURN m.cChildren
		
	ENDPROC

	PROCEDURE getcursor		&& Return a reference to the named cursor object, based on workarea name.
		LPARAMETERS cWorkArea
		*++
		*>>Return a reference to the named cursor object, based on workarea name.
		*--
		  IF NOT ISNULL(THIS.oCDE)
		    * Need to use the root CDE, if there is one, so nested rule methods
		    * can consistently find cursors anywhere in the CDE tree.
		    WITH THIS.oCde
		      IF NOT ISNULL(.oRoot)
		        RETURN .oRoot.GetCursor(@m.cWorkarea)
		      ELSE
		        RETURN .GetCursor(@m.cWorkarea)
		      ENDIF
		    ENDWITH
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE getfilter		&& Return the current filter expression for the specifide cursor.
		LPARAMETERS cWorkArea
		*++
		*>>Return the current filter expression for the specifide cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.GetFilter()
		  ENDIF
		  RETURN ''
		
	ENDPROC

	PROCEDURE getparent		&& Return the parent workarea (or empty string) of the specified workarea.
		LPARAMETERS cWorkarea
		*++
		*>>Return the parent workarea (or empty string) of the specified workarea.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor) AND NOT ISNULL(m.oCursor.oParent)
		    RETURN m.oCursor.oParent.cWorkarea
		  ENDIF
		  RETURN ''   && No parent
		
	ENDPROC

	PROCEDURE getprop		&& Return various property settings about the specified cursor.
		LPARAMETERS cProperty, cWorkarea
		*++
		*>>Return various property settings about the specified cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.GetProp(@m.cProperty)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE gobottom		&& Go to the last record in the cursor
		LPARAMETERS cWorkarea, lEof
		*++
		*>>Go to the last record in the cursor
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.GoBottom(m.lEof)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE goto		&& Go to the specified record number in the cursor
		LPARAMETERS nRecord, cWorkarea
		*++
		*>>Go to the specified record number in the cursor
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Goto(m.nRecord)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE gotop		&& Go to the first record in the cursor
		LPARAMETERS cWorkarea
		*++
		*>>Go to the first record in the cursor
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Gotop()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE isbottom		&& Return the "Bottom" state of the current record in the specified workarea.
		LPARAMETERS cWorkArea
		*++
		*>>Return the "Bottom" state of the current record in the specified workarea.
		*--
		LOCAL oCursor
		  IF NOT ISNULL(THIS.oCDE)
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(m.oCursor)
		      RETURN m.oCursor.IsBottom()
		    ENDIF
		    RETURN THIS._BadWorkarea(m.cWorkarea)
		  ENDIF
		
	ENDPROC

	PROCEDURE ischanged		&& Returns true if any record in the specified list of cursors contains uncommited changes.
		LPARAMETERS cWorkareaList, cExclude
		*++
		*>>Returns true if any record in the specified list of cursors contains uncommited changes.
		*--
		  IF NOT ISNULL(THIS.oCDE)
		    RETURN THIS.oCDE.IsChanged(@m.cWorkareaList, @m.cExclude)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isdeleteallowed		&& Determine whether or not records may be deleted from the specified workarea.
		LPARAMETERS cWorkarea
		*++
		*>>Determine whether or not records may be deleted from the specified workarea.
		*
		* This method is used to enable or disable user-interface controls that trigger
		* delete operations.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN NOT THIS.IsReadOnly(@m.cWorkarea) AND m.oCursor.IsDeleteAllowed()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE isdeleteallowedrule		&& Custom developer code to determine whether or not records may be deleted from the cursor via the User Interface.
		LPARAMETERS cWorkarea
		*++
		*>>Custom developer code to determine whether or not records may be deleted from the cursor via the User Interface.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE isdeleted		&& Return the "Deleted" state of the current record in the specified workarea.
		LPARAMETERS cWorkArea
		*++
		*>>Return the "Deleted" state of the current record in the specified workarea.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.IsDeleted()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE iseditallowed		&& Determine whether or not the current record may be edited in the specified workarea.
		LPARAMETERS cWorkarea, cField
		*++
		*>>Determine whether or not the current record may be edited in the specified workarea.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.IsEditAllowed(@m.cField)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE iseditallowedrule		&& Custom developer code to determine if the specified field may be edited interactively.
		LPARAMETERS cWorkarea, cField
		*++
		*>>Custom developer code to determine if the specified field may be edited interactively.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE isempty		&& Determine whether or not the specified cursor has any records.
		LPARAMETERS cWorkarea
		*++
		*>>Determine whether or not the specified cursor has any records.
		*--
		LOCAL oCursor
		  IF NOT ISNULL(THIS.oCDE)
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(m.oCursor)
		      RETURN m.oCursor.IsEmpty()
		    ENDIF
		    RETURN THIS._BadWorkarea(m.cWorkarea)
		  ENDIF
		
	ENDPROC

	PROCEDURE iseof		&& Determine whether or not the specified cursor is at EOF.
		LPARAMETERS cWorkarea
		*++
		*>>Determine whether or not the specified cursor is at EOF.
		*--
		LOCAL oCursor
		  IF NOT ISNULL(THIS.oCDE)
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(m.oCursor)
		      RETURN m.oCursor.IsEof()
		    ENDIF
		    RETURN THIS._BadWorkarea(m.cWorkarea)
		  ENDIF
		
	ENDPROC

	PROCEDURE isexclusive		&& Determine whether or not the specified cursor opened with Exclusive access.
		LPARAMETERS cWorkarea
		*++
		*>>Determine whether or not the specified cursor opened with Exclusive access.
		*--
		LOCAL oCursor
		  IF NOT ISNULL(THIS.oCDE)
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(m.oCursor)
		      RETURN m.oCursor.IsExclusive()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isfield		&& Return true if the specified field name is present in this cursor
		LPARAMETERS cWorkarea, cField
		*++
		*>>Return true if the specified field name is present in this cursor
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.IsField(@m.cField)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE isfieldchanged		&& Returns true if the specified field in the specified cursor has been modified.
		LPARAMETERS cWorkarea, cField
		*++
		*>>Returns true if the specified field in the specified cursor has been modified.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.IsFieldChanged(@m.cField)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE isnew		&& Return the "New" state of the current record in the specified workarea.
		LPARAMETERS cWorkArea
		*++
		*>>Return the "New" state of the current record in the specified workarea.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.IsNew()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE isnewallowed		&& Determine whether or not records may be added to the specified workarea.
		LPARAMETERS cWorkarea
		*++
		*>>Determine whether or not records may be added to the specified workarea.
		*
		* This method is used primarily by interface controls, like the "New" button, to
		* determine when to enable or disable. 
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN NOT THIS.IsReadOnly(@m.cWorkarea) AND m.oCursor.IsNewAllowed()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE isnewallowedrule		&& Custom developer code to determine whether or not records may be added to the cursor via the User Interface.
		LPARAMETERS cWorkarea
		*++
		*>>Custom developer code to determine whether or not records may be added to the cursor via the User Interface.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE isopen		&& Return true is the specified cursor alias is currently open in this data session.
		LPARAMETERS cWorkArea
		*++
		*>>Return true is the specified cursor alias is currently open in this data session.
		*--
		LOCAL oCursor
		  IF NOT ISNULL(THIS.oCDE)
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(m.oCursor)
		      RETURN m.oCursor.IsOpen()
		    ENDIF
		  ENDIF
		  RETURN .F.   && Treat cursor not found as not open
		
	ENDPROC

	PROCEDURE isreadonly		&& Determine whether or not the specified workarea is read-only.
		LPARAMETERS cWorkarea
		*++
		*>>Determine whether or not the specified workarea is read-only.
		*--
		LOCAL oCursor
		  IF NOT ISNULL(THIS.oCDE)
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(m.oCursor)
		      RETURN m.oCursor.IsReadOnly()
		    ENDIF
		    RETURN THIS._BadWorkarea(m.cWorkarea)
		  ENDIF
		
	ENDPROC

	PROCEDURE isreadonlyrule		&& Custom developer code to determine if the cursor is Read-Only.
		LPARAMETERS cWorkarea
		*++
		*>>Custom developer code to determine if the cursor is Read-Only.
		*--
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isrecordchanged		&& Returns true if the current record in the specified workarea, or any child record, contains uncommited changes.
		LPARAMETERS cWorkarea
		*++
		*>>Returns true if the current record in the specified workarea, or any child record, contains uncommited changes.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.IsRecordChanged()  && Include all child records as well.
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE isrequired		&& Determine whether or not the specified field is required.
		LPARAMETERS cWorkarea, cField
		*++
		*>>Determine whether or not the specified field is required.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.IsRequired(@m.cField)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE isrequiredrule		&& Custom developer code to determine if a field is required. Enforced at the interface level only.
		LPARAMETERS cWorkarea, cField
		*++
		*>>Custom developer code to determine if a field is required. Enforced at the interface level only.
		*--
		  RETURN .F.
		
	ENDPROC

	PROCEDURE istop		&& Return the "Top" state of the current record in the specified workarea.
		LPARAMETERS cWorkArea
		*++
		*>>Return the "Top" state of the current record in the specified workarea.
		*--
		LOCAL oCursor
		  IF NOT ISNULL(THIS.oCDE)
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(m.oCursor)
		      RETURN m.oCursor.IsTop()
		    ENDIF
		    RETURN THIS._BadWorkarea(m.cWorkarea)
		  ENDIF
		
	ENDPROC

	PROCEDURE lockforedit		&& Obtain whatever locks are necessary before allowing a change to the current record of the specified cursor.
		LPARAMETERS cWorkArea
		*++
		*>>Obtain whatever locks are necessary before allowing a change to the current record of the specified cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.LockForEdit()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE lockrecord		&& Obtain network Lock for the current record in specified workarea.
		LPARAMETERS cWorkarea
		 *++
		 *>>Obtain network Lock for the current record in specified workarea.
		 *--
		 LOCAL oCursor
		   m.oCursor = THIS.GetCursor(m.cWorkarea)
		   IF NOT ISNULL(m.oCursor)
		     RETURN m.oCursor.LockRecord()
		   ENDIF
		   RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE new		&& Add a new record to the specified cursor.
		LPARAMETERS cWorkarea
		*++
		*>>Add a new record to the specified cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(@m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.New()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE nicecursorname		&& Return a user-friendly name for the specified cursor.
		LPARAMETERS cWorkarea
		*++
		*>>Return a user-friendly name for the specified cursor.
		*--
		LOCAL oCursor
		  * Default to the current workarea
		  m.cWorkarea = IIF(EMPTY(m.cWorkarea), ALIAS(), m.cWorkarea)
		
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.NiceCursorName()
		  ENDIF
		  RETURN m.cWorkarea
		
	ENDPROC

	PROCEDURE nicefieldname		&& Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		LPARAMETERS cWorkarea, cFieldName
		*++
		*>>Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		*--
		LOCAL oCursor
		
		  * Default to the current workarea, or the workarea specified in the field name.
		  IF EMPTY(m.cWorkarea)
		    IF '.' $ m.cFieldName
		      m.cWorkarea = LEFT(m.cFieldName, RAT('.', m.cFieldName) - 1)
		    ELSE
		      m.cWorkarea = ALIAS()
		    ENDIF
		  ENDIF
		
		  m.oCursor = THIS.GetCursor(@m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.NiceFieldName(@m.cFieldName)
		  ENDIF
		  RETURN m.cFieldName
		
	ENDPROC

	PROCEDURE oform_access		&& Find a reference to the form that this object is a part of. Return NULL if not part of a form.
		*++
		*>>Find a reference to the form that this object is a part of. Return NULL if not part of a form.
		*--
		  IF ISNULL(THIS.oForm)
		    * Trace reference every time, rather than storing a hard ref in the oForm property.
		    IF NOT ISNULL(THIS.oCDE) AND NOT ISNULL(THIS.oCDE.oDM)
		      RETURN THIS.oCDE.oDM.Parent
		    ENDIF
		    RETURN .NULL.
		  ENDIF
		  RETURN THIS.oForm
		
	ENDPROC

	PROCEDURE oldvalue		&& Return the old value of the specified field
		LPARAMETERS cWorkArea, cField
		*++
		*>>Return the old value of the specified field
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.OldValue(@m.cField)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE pack		&& Pack the specified table
		LPARAMETERS cWorkarea, cOption
		*++
		*>>Pack the specified table
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(@m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Pack(m.cOption)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE primarykeychanged		&& Reset child cursor foriegn keys after the primary key of the parent has been changed.
		LPARAMETERS cWorkarea
		*++
		*>>Reset child cursor foriegn keys after the primary key of the parent has been changed.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.PrimaryKeyChanged()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkArea)
		
	ENDPROC

	PROCEDURE recordreadytomove		&& Determine if the record pointer can be moved or not.
		LPARAMETERS cWorkarea
		*++
		*>>Determine if the record pointer can be moved or not.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.RecordReadyToMove()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE recordwasmoved		&& Re-sync cursor position flags and child recordsets with a cursor moved or modified by direct VFP commands, outside of the cursor object's knowledge.
		LPARAMETERS cWorkArea
		*++
		*>>Re-sync cursor position flags and child recordsets with a cursor moved or modified by direct VFP commands, outside of the cursor object's knowledge.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.RecordWasMoved()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkArea)
		
	ENDPROC

	PROCEDURE refreshdata		&& Refresh data in the current record of the specified cursor.
		LPARAMETERS cWorkArea
		*++
		*>>Refresh data in the current record of the specified cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.RefreshData()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE reindex		&& Reindex the specified table
		LPARAMETERS cWorkarea
		*++
		*>>Reindex the specified table
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(@m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Reindex()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE replace		&& Replace the contents of the specified field.
		LPARAMETERS cWorkarea, cField, uValue, lRefresh
		*++
		*>>Replace the contents of the specified field.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Replace(@m.cField, @m.uValue, m.lRefresh)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE requery		&& Requery the specified view
		LPARAMETERS cWorkArea, uP1, uP2, uP3, uP4
		*++
		*>>Requery the specified view
		* All parameter variables for parameterized views should be defined as PRIVATE
		* before calling this method, so they will be in scope to the REQUERY() function.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Requery(m.uP1, m.uP2, m.uP3, m.uP4)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE revert		&& Discard changes to all records in the specified workarea
		LPARAMETERS cWorkarea
		*++
		*>>Discard changes to all records in the specified workarea
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Revert()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE revertall		&& Discard changes to all records in specified workareas, and revert to original values.
		LPARAMETERS cWorkareaList
		*++
		*>>Discard changes to all records in specified workareas, and revert to original values.
		*--
		  IF NOT ISNULL(THIS.oCDE)
		    RETURN THIS.oCDE.RevertAll(@m.cWorkareaList)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE revertrecord		&& Discard changes to the current record in the specified workarea
		LPARAMETERS cWorkarea
		*++
		*>>Discard changes to the current record in the specified workarea
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.RevertRecord()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE rowvalid		&& Row level validation rule code.
		LPARAMETERS cWorkarea
		*++
		*>>Row level validation rule code.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE seek		&& Seek the record matching the specified key in the cursor. On failure, leave record pointer on original record.
		LPARAMETERS uKey, cWorkarea, cIndex
		*++
		*>>Seek the record matching the specified key in the cursor. On failure, leave record pointer on original record.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Seek(@m.uKey, @m.cIndex)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE setbuffermode		&& Set the buffering mode of the cursor open in the specified workarea
		LPARAMETERS nMode, cWorkArea
		*++
		*>>Set the buffering mode of the cursor open in the specified workarea
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.SetBufferMode(m.nMode)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE setdefault		&& Set the specified cursor as the current VFP workarea, if is is a native cursor.
		LPARAMETERS cWorkarea
		*++
		*>>Set the specified cursor as the current VFP workarea, if is is a native cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.SetDefault()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE setexclusive		&& Set the cursor to Exclusive  or Shared access.
		LPARAMETERS lExclusive, cWorkarea
		*++
		*>>Set the cursor to Exclusive  or Shared access.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.SetExclusive(@m.lExclusive)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE setfilter		&& Set the record filter expression for the specified cursor.
		LPARAMETERS cFilter, cWorkArea
		*++
		*>>Set the record filter expression for the specified cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.SetFilter(@m.cFilter)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE setorder		&& Set the sort order for the specified cursor.
		LPARAMETERS cOrder, cWorkarea, cDirection
		*++
		*>>Set the sort order for the specified cursor.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.SetOrder(@m.cOrder, @m.cDirection)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE setrelation		&& Establish a relation between the two specified cursors, based on the specified expression.
		LPARAMETERS cParent, cChild, cExpr
		*++
		*>>Establish a relation between the two specified cursors, based on the specified expression.
		* Returns .F. if either cursor alias is not found, or if the relation cannot be set.
		*--
		LOCAL oChild, oParent
		  m.oChild = THIS.GetCursor(@m.cChild)
		  m.oParent = THIS.GetCursor(@m.cParent)
		  IF NOT ISNULL(m.oChild) AND NOT ISNULL(m.oParent)
		    RETURN m.oParent.AddChild(m.oChild, @m.cExpr)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cParent + ',' + m.cChild)
		
	ENDPROC

	PROCEDURE skip		&& Skip the specified number of records forward or backwards.
		LPARAMETERS nRecords, cWorkarea
		*++
		*>>Skip the specified number of records forward or backwards.
		* Dont allow past EOF or BOF if possible.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Skip(m.nRecords)
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE update		&& Write changes for all records for this cursor back to the source.
		LPARAMETERS cWorkarea
		*++
		*>>Write changes for all records for this cursor back to the source.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.Update()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE updateall		&& Write all buffered changes in all workareas to disk for the specified workareas.
		LPARAMETERS cWorkareaList
		*++
		*>>Write all buffered changes in all workareas to disk for the specified workareas.
		* This also trigger the DM level BeforeUpdate() and AfterUpdate() rule events.
		*--
		  IF NOT ISNULL(THIS.oCDE)
		    RETURN THIS.oCDE.UpdateAll(@m.cWorkareaList)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE updaterecord		&& Write changes to the current record back to the source.
		LPARAMETERS cWorkarea
		*++
		*>>Write changes to the current record back to the source.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.UpdateRecord()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE validatecursor		&& Validate the specified cursor by triggering all CursorValid() events.
		LPARAMETERS cWorkarea
		*++
		*>>Validate the specified cursor by triggering all CursorValid() events.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.ValidateCursor()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE validatefield		&& Validate the specified field in the cursor, by triggering all its FieldValid() events.
		LPARAMETERS cWorkarea, cField, uValue
		*++
		*>>Validate the specified field in the cursor, by triggering all its FieldValid() events.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    IF PCOUNT() <= 2
		      RETURN m.oCursor.ValidateField(@m.cField)  && Use current field value
		    ELSE
		      RETURN m.oCursor.ValidateField(@m.cField, @m.uValue)
		    ENDIF
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE validaterow		&& Validate the current row in the specified cursor, by triggering all its RowValid() events.
		LPARAMETERS cWorkarea
		*++
		*>>Validate the current row in the specified cursor, by triggering all its RowValid() events.
		*--
		LOCAL oCursor
		  m.oCursor = THIS.GetCursor(m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    RETURN m.oCursor.ValidateRow()
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE _badworkarea		&& Display a developer error message when an unknown workarea alias is passed to a rule/DM method.
		LPARAMETERS cWorkarea
		*++
		*>>Display a developer error message when an unknown workarea alias is passed to a rule/DM method.
		*--
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = '<none specified>'
		  ENDIF
		  ASSERT .F. MESSAGE 'Unknown cWorkarea parameter "' + m.cWorkarea + '" in ' + PROPER(PROGRAM(PROGRAM(-1)-1)) + '()'
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmserviceabstract AS custom 		&& CodeMine Sevice Object abstract foundation class.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*m: comments		&& Developer can place object comments in this method, enclosed in #if .F. #endif directives, or standard comment indicators.
		*m: release		&& Release this object
	*</DefinedPropArrayMethod>

	Name = "cmserviceabstract"
	
	PROCEDURE addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		LPARAMETERS cName, cClassAlias, uP1, uP2, uP3, uP4, uP5, uP6, uP7, uP8, uP9
		*++
		*>>Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*--
		LOCAL ix, cParams, cLibrary
		
		  * Translate class alias into actual class name, and extract class library prefix if present.
		  m.cLibrary = .NULL.
		  IF PEMSTATUS(_SCREEN, 'cmGlobalObjectManager', 5)
		    m.cClassAlias = _SCREEN.cmGlobalObjectManager.GetClassName(m.cClassAlias, @m.cLibrary)
		  ENDIF
		
		  m.cParams = ''
		  FOR ix = 1 TO PCOUNT() - 2
		    m.cParams = m.cParams + ', @m.uP' + STR(m.ix,1)
		  ENDFOR
		  RETURN THIS.NewObject(m.cName, m.cClassAlias, m.cLibrary, '' &cParams)
		
	ENDPROC

	PROCEDURE comments		&& Developer can place object comments in this method, enclosed in #if .F. #endif directives, or standard comment indicators.
		*++
		*>>Developer can place object comments in this method, enclosed in #if .F. #endif directives, or standard comment indicators.
		*--
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Fatal coding error - Pass it on to CodeMine error handler if available.
		* Returns .T. if user said to ignore error, or if it is an error we handle here.
		*--
		LOCAL oMessage
		
		  m.cMsg = MESSAGE()   && Save error message text in case other call clears it.
		  m.oMessage = FindGlobalObject('cmMessage')
		  IF NOT ISNULL(m.oMessage)
		    RETURN m.oMessage.FatalError(@m.cMsg, @m.cMethod, m.nLine)  && Usually .T. if anything
		  ENDIF
		
		  * No Codemine Message handler object is available.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		  RETURN .F.
		
	ENDPROC

	PROCEDURE release		&& Release this object
		*++
		*>>Release this object
		*--
		  RELEASE THIS
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cusserviceabstract AS custom 		&& CodeMine Custom Sevice Object abstract foundation class.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*m: release		&& Release this object
	*</DefinedPropArrayMethod>

	Name = "cusserviceabstract"
	
	PROCEDURE addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		LPARAMETERS cName, cClassAlias, uP1, uP2, uP3, uP4, uP5, uP6, uP7, uP8, uP9
		*++
		*>>Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*--
		LOCAL ix, cParams, cLibrary
		
		  * Translate class alias into actual class name, and extract class library prefix if present.
		  m.cLibrary = .NULL.
		  IF PEMSTATUS(_SCREEN, 'cmGlobalObjectManager', 5)
		    m.cClassAlias = _SCREEN.cmGlobalObjectManager.GetClassName(m.cClassAlias, @m.cLibrary)
		  ENDIF
		
		  m.cParams = ''
		  FOR ix = 1 TO PCOUNT() - 2
		    m.cParams = m.cParams + ', @m.uP' + STR(m.ix,1)
		  ENDFOR
		  RETURN THIS.NewObject(m.cName, m.cClassAlias, m.cLibrary, '' &cParams)
		
	ENDPROC

	PROCEDURE error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Fatal coding error - Pass it on to CodeMine error handler if available.
		*--
		LOCAL oMessage
		
		  m.cMsg = MESSAGE()   && Save error message text in case other call clears it.
		  m.oMessage = FindGlobalObject('cmMessage')
		  IF NOT ISNULL(m.oMessage)
		    RETURN m.oMessage.FatalError(@m.cMsg, @m.cMethod, m.nLine)  && Usually .T. is anything
		  ENDIF
		
		  * Not in a Codemine form, or no message handler object.
		  ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cMsg
		  RETURN .F.
		
	ENDPROC

	PROCEDURE release		&& Release this object
		*++
		*>>Release this object
		*--
		  RELEASE THIS
		
	ENDPROC

ENDDEFINE
