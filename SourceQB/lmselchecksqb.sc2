*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="lmselchecksqb.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 567
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 829

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "landowner1", ;
		CursorSource = "landowner", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor10", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "landhist", ;
		BufferModeOverride = 5, ;
		CursorSource = "landhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor11", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "landhist1", ;
		CursorSource = "landhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 291, ;
		Name = "Cursor12", ;
		Top = 387, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 415, ;
		Name = "Cursor13", ;
		Top = 25, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "expsusp", ;
		BufferModeOverride = 5, ;
		CursorSource = "expsusp", ;
		Database = ..\appdata.dbc, ;
		Height = 90, ;
		Left = 563, ;
		Name = "Cursor3", ;
		Top = 123, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "land", ;
		CursorSource = "land", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "landopt", ;
		CursorSource = "landopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 169, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Top = 260, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "landowner", ;
		BufferModeOverride = 5, ;
		CursorSource = "landowner", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 439, ;
		Name = "Cursor9", ;
		Top = 233, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formlmselchecks AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cntmoverlistpair" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom6" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: createchks		&& Prints the selected invoices
		*m: updowner		&& Updates the owner file with the last payment info.
		*p: dcheckdate
		*a: aselected[1,0]
	*</DefinedPropArrayMethod>

	Caption = "Select Delay Rental Payments"
	DataSession = 2
	DoCreate = .T.
	Height = 414
	HelpContextID = 110
	Name = "FormLmselchecks"
	Width = 659
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cmdCancel' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Cancel", ;
		FontBold = .T., ;
		Height = 36, ;
		Left = 334, ;
		Name = "cmdCancel", ;
		Top = 376, ;
		Width = 95
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS cmdcommandbuttoncustom WITH ;
		Caption = "C\<reate Checks", ;
		FontBold = .T., ;
		Height = 36, ;
		Left = 230, ;
		Name = "cmdOK", ;
		Top = 376, ;
		Width = 95
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cntmoverlistpair' AS cntmoverlistpair WITH ;
		Height = 349, ;
		Left = 0, ;
		Name = "Cntmoverlistpair", ;
		Top = 24, ;
		Width = 648, ;
		cmdDeselect.Caption = "De-Select", ;
		cmdDeselect.FontBold = .F., ;
		cmdDeselect.Height = 23, ;
		cmdDeselect.Left = 340, ;
		cmdDeselect.Name = "cmdDeselect", ;
		cmdDeselect.Top = 156, ;
		cmdDeselect.Width = 84, ;
		cmdDeselectAll.Caption = "De-Select All", ;
		cmdDeselectAll.FontBold = .F., ;
		cmdDeselectAll.Height = 23, ;
		cmdDeselectAll.Left = 424, ;
		cmdDeselectAll.Name = "cmdDeselectAll", ;
		cmdDeselectAll.Top = 156, ;
		cmdDeselectAll.Width = 84, ;
		cmdSelect.Caption = "Select", ;
		cmdSelect.FontBold = .F., ;
		cmdSelect.Height = 23, ;
		cmdSelect.Left = 172, ;
		cmdSelect.Name = "cmdSelect", ;
		cmdSelect.Top = 156, ;
		cmdSelect.Width = 84, ;
		cmdSelectAll.Caption = "Select All", ;
		cmdSelectAll.FontBold = .F., ;
		cmdSelectAll.Height = 23, ;
		cmdSelectAll.Left = 256, ;
		cmdSelectAll.Name = "cmdSelectAll", ;
		cmdSelectAll.Top = 156, ;
		cmdSelectAll.Width = 84, ;
		lstSelected.FontName = "Courier New", ;
		lstSelected.FontSize = 8, ;
		lstSelected.Height = 132, ;
		lstSelected.Left = 12, ;
		lstSelected.Name = "lstSelected", ;
		lstSelected.Top = 209, ;
		lstSelected.Width = 636, ;
		lstSource.FontName = "Courier New", ;
		lstSource.FontSize = 8, ;
		lstSource.Height = 138, ;
		lstSource.Left = 12, ;
		lstSource.Name = "lstSource", ;
		lstSource.Top = 12, ;
		lstSource.Width = 636
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="container" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Rentals That Are Due", ;
		FontBold = .T., ;
		Left = 12, ;
		Name = "Lbllabelcustom1", ;
		Top = -1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Rentals To Pay", ;
		FontBold = .T., ;
		Left = 12, ;
		Name = "Lbllabelcustom2", ;
		Top = 214
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		Caption = "Pmt Due", ;
		Left = 482, ;
		Name = "Lbllabelcustom3", ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom4' AS lbllabelcustom WITH ;
		Caption = "Amount", ;
		Left = 588, ;
		Name = "Lbllabelcustom4", ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom5' AS lbllabelcustom WITH ;
		Caption = "Lease Name", ;
		Left = 24, ;
		Name = "Lbllabelcustom5", ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom6' AS lbllabelcustom WITH ;
		Caption = "Owner Name", ;
		Left = 280, ;
		Name = "Lbllabelcustom6", ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />
	
	PROCEDURE createchks		&& Prints the selected invoices
		LOCAL m.caddr1, m.caddr2, m.caddr3, m.ccustname, m.shipln1, m.shipln2
		LOCAL m.shipln3, m.shipln4, m.paddr1, m.paddr2, m.paddr3, m.message
		LOCAL lnCount, lnX, lnChecks, oRegistry, oGLMaint
		
		* Check on the existence of the application object
		* if it doesn't exist, we're running in development
		* mode and need to initialize the company address info.
		IF TYPE('m.goApp') = 'O'
		   m.cProducer = m.goApp.cCompanyName
		   m.paddr1    = m.goApp.cAddress1
		   m.paddr2    = m.goApp.cAddress2
		   m.paddr3    = m.goApp.cAddress3
		ELSE
		   m.cProducer = 'SherWare, Inc.'
		   m.paddr1    = 'PO Box 223'
		   m.paddr2    = 'Wooster, OH  44691'
		   m.paddr3    = ''
		ENDIF
		
		oRegistry = FindGlobalObject('cmRegistry')
		
		* Setup the fields for qbpost so we can unpost this allocation if part fails
		m.cidsysctl = oRegistry.incrementcounter('%Shared.Counters.Batch')
		
		IF m.goApp.oQB.lqbactive
		   IF m.goApp.oQB.oqbsm.IsErrorRecoveryInfo()
		*!*	      loresp     = m.goApp.oQB.oqbsm.geterrorrecoverystatus()
		*!*	      lcxml      = loresp.toxmlstring()
		*!*	      loresponse = loresp.responselist.getat(0)
		*!*	      IF loresponse.statuscode = 0
		*!*	         lcreq  = m.goApp.oQB.oqbsm.getsavedmsgsetrequest()
		         m.goApp.oQB.oqbsm.ClearErrorRecovery()
		*!*	      ELSE
		*!*	         MESSAGEBOX(lcxml, 48, 'Error Recovery Info')
		*!*	      ENDIF
		   ENDIF
		
		   * get a message set request object (version 1.1 xml)
		   lorequest = m.goApp.oQB.oQBRequest
		
		   * set the on error attribute for the request
		   lorequest.ATTRIBUTES.onerror = 1
		   lorequest.clearrequests()
		
		   IF m.goApp.oQB.qbfcversion > ' 4.0'
		      lnCheck   = 6
		   ELSE
		      lnCheck   = 11
		   ENDIF
		
		   IF NOT m.goApp.lQBError
		      * set the on error attribute for the request
		      lorequest.ATTRIBUTES.onerror = 1
		      lorequest.clearrequests()
		   ENDIF
		
		   SWSELECT('landopt')
		   SCATTER MEMVAR
		   lcCatCode = cCatCode
		
		   *  If expensing the rentals, use the expense clearing account instead
		   IF m.lExpense
		      SELECT glopt
		      m.cRentAcct = glopt.cQBExpClear
		   ENDIF
		
		   oGLMaint  = CREATEOBJECT('glmaint')
		   oRegistry = FindGlobalObject('cmRegistry')
		   lnCount   = ALEN(THISFORM.aSelected, 1)
		
		   IF lnCount = 1
		      IF EMPTY(THISFORM.aSelected[1])
		         THISFORM.omessage.warning('There were no amounts selected to pay.')
		         RETURN
		      ENDIF
		   ENDIF
		
		   lnChecks = 0
		
		   FOR lnX = 1 TO lnCount
		      SWSELECT('landpmts')
		      LOCATE FOR cLeaseID + '-' + LEFT(cLeaseName, 25) + '  ' + cOwnerID + '-' + LEFT(cOwnName, 15) + '  ' + DTOC(dpmtdate) + '  ' + STR(nPmtAmount, 9, 2) = THISFORM.aSelected[lnX]
		      IF FOUND()
		         REPL lSelected WITH .T.
		      ENDIF
		   ENDFOR
		
		   SELECT cOwnerID, cOwnName, SUM(nPmtAmount) AS nPayment FROM landpmts WHERE lSelected INTO CURSOR temppmt ORDER BY cOwnerID GROUP BY cOwnerID
		
		   SELECT temppmt
		   SCAN
		      SCATTER MEMVAR
		      lcBatch = oRegistry.incrementcounter('%Shared.Counters.Batch')
		
		      oGLMaint.cBatch     = lcBatch
		      oGLMaint.dGLDate    = THISFORM.dCheckDate
		      oGLMaint.cyear      = ' '
		      oGLMaint.cperiod    = ' '
		      oGLMaint.cReference = 'Delay Rental'
		      oGLMaint.cDesc      = m.cOwnName
		      oGLMaint.cAcctNo    = m.cCashAcct
		      oGLMaint.cId        = m.cOwnerID
		      oGLMaint.nAmount    = m.nPayment * -1
		      oGLMaint.cbunch     = ''
		      oGLMaint.cPayee     = m.cOwnName
		      oGLMaint.cId        = m.cOwnerID
		      oGLMaint.cEntryType = 'C'
		      oGLMaint.dPostDate  = THISFORM.dCheckDate
		      oGLMaint.dCheckDate = THISFORM.dCheckDate
		      oGLMaint.cIDType    = 'I'
		      oGLMaint.cSource    = 'LM'
		      oGLMaint.lCleared   = .F.
		      oGLMaint.lPrinted   = .T.
		
		      * Create the register entry
		      oGLMaint.nAmount = m.nPayment
		      oGLMaint.cAcctNo = m.cCashAcct
		      lnChecks         = lnChecks + 1
		      oGLMaint.AddCheck()
		      m.cidchec = oGLMaint.GETKEY()
		
		
		      IF m.goApp.oQB.lqbactive
		
		         SELE investor
		         LOCATE FOR cOwnerID == m.cOwnerID
		         IF FOUND()
		            m.cOwnListID = cListID
		            m.caddr1     = LEFT(investor.cOwnName, 41)
		            m.caddr2     = LEFT(cAddress1a, 41)
		            m.caddr3     = LEFT(cAddress1b, 41)
		            m.cCity      = LEFT(cCity1, 31)
		            m.cState     = cState1
		            m.cZip       = cZip1
		         ELSE
		            LOOP
		         ENDIF
		
		         * Check for problems with synchronization
		         * with QB.
		         IF EMPTY(m.cCashAcct)
		            THIS.omessage.severe('You must specify a valid QuickBooks bank account.')
		            RETURN
		         ENDIF
		         IF EMPTY(m.cRentAcct)
		            THIS.omessage.severe('You must specify a valid QuickBooks rental account.')
		            RETURN
		         ENDIF
		         IF EMPTY(m.cOwnListID)
		            THIS.omessage.severe('Owner: ' + ALLTRIM(m.cOwnerID) + '-' + ALLTRIM(m.cOwnName) + ' has not been synchronized with QuickBooks.')
		            RETURN
		         ENDIF
		
		         loCheck = lorequest.AppendCheckAddRq()
		
		         loCheck.AccountRef.ListID.SetValue(m.cCashAcct)
		         loCheck.PayeeEntityRef.ListID.SetValue(m.cOwnListID)
		         loCheck.TxnDate.SetValue(THISFORM.dCheckDate)
		         IF NOT EMPTY(m.caddr1)
		            loCheck.Address.Addr1.SetValue(m.caddr1)
		         ENDIF
		         IF NOT EMPTY(m.caddr2)
		            loCheck.Address.Addr2.SetValue(m.caddr2)
		         ENDIF
		         IF NOT EMPTY(m.cCity)
		            loCheck.Address.City.SetValue(m.cCity)
		         ENDIF
		         IF NOT EMPTY(m.cState)
		            loCheck.Address.State.SetValue(m.cState)
		         ENDIF
		         IF NOT EMPTY(m.cZip)
		            loCheck.Address.PostalCode.SetValue(m.cZip)
		         ENDIF
		
		         loCheck.IsToBePrinted.SetValue('True')
		
		      ENDIF
		
		      *Create Rental Entry
		      SWSELECT('landpmts')
		      SCAN FOR lSelected AND cOwnerID = m.cOwnerID
		         SCATTER MEMVAR
		
		         IF m.goApp.oQB.lqbactive
		            SELE land
		            LOCATE FOR cLeaseID = landpmts.cLeaseID
		            IF FOUND()
		               m.cLeaseListid = cListID
		               m.cLeaseName   = cLeaseName
		            ELSE
		               LOOP
		            ENDIF
		
		            loCheckDet = loCheck.ExpenseLineAddList.APPEND
		
		            loCheckDet.AccountRef.ListID.SetValue(m.cRentAcct)
		            loCheckDet.Amount.SetValue(m.nPmtAmount)
		            loCheckDet.ClassRef.ListID.SetValue(m.cLeaseListid)
		
		            * Get the payment description from the lease obligation file
		            SWSELECT('landowner')
		            LOCATE FOR cOwnerID == m.cOwnerID AND cLeaseID == landpmts.cLeaseID AND cstatus <> 'I'
		            IF FOUND()
		               IF NOT EMPTY(cpmtdesc)
		                  lcpmtdesc = cpmtdesc
		               ELSE
		                  lcpmtdesc = 'Payment for ' + ALLTRIM(m.cLeaseName)
		               ENDIF
		            ELSE
		               lcpmtdesc = 'Payment for ' + ALLTRIM(m.cLeaseName)
		            ENDIF
		
		            loCheckDet.MEMO.SetValue(lcpmtdesc)
		         ENDIF
		
		         IF landopt.lExpense  &&  Charging the delay rental payments to the wells as expenses
		            SCATTER MEMVAR
		               IF NOT EMPTY(lcCatCode)
		                  m.cCatCode = lcCatCode
		                  swselect('expcat')
		                  SET ORDER TO cCatCode
		                  IF SEEK(m.cCatCode)
		                     m.ccateg    = ccateg
		                     m.cexpclass = cexpclass
		                  ENDIF
		               ELSE
		                  swselect('expcat')
		                  LOCATE FOR 'DELAY RENTAL' $ UPPER(ccateg)
		                  IF FOUND()
		                     m.cCatCode  = expcat.cCatCode
		                     m.ccateg    = ccateg
		                     m.cexpclass = cexpclass
		                  ENDIF
		               ENDIF
		
		               IF m.goApp.lEnhancedLand
		                  SWSELECT('leasewell')
		                  SELECT  cwellid ;
		                     FROM wells ;
		                     WHERE NOT INLIST(wells.cwellstat, 'I', 'S', 'P') ;
		                     AND cwellid IN (SELECT  cwellid ;
		                       FROM leasewell ;
		                       WHERE cLeaseID == m.cLeaseID) ;
		                     INTO CURSOR temp
		                  lnWells    = _TALLY
		                  lnAmount   = swround(m.nPmtAmount / lnWells, 2)
		                  lnTotalAmt = swround(lnAmount * lnWells, 2)
		                  lnDiff     = m.nPmtAmount - lnTotalAmt
		                  SCAN
		                     m.cwellid   = temp.cwellid
		                     m.dexpdate  = THISFORM.dCheckDate
		                     m.nAmount   = lnAmount + lnDiff
		                     m.nAmount   = swNetExp(m.nAmount, m.cwellid, .F., m.cexpclass, 'B')
		                     lnDiff      = 0
		                     m.cPayee    = m.cOwnName
		                     m.cvendorid = m.cOwnerID
		                     m.cOwnerID  = ''
		                     m.laptran   = .T.
		                     m.cPaidByCk = m.cidchec  &&  Store the check key used to pay this expense
		                     m.cidexps   = oRegistry.incrementcounter('%Shared.Counters.Expense')
		                     SET DELETED OFF
		                     SELECT expsusp
		                     SET ORDER TO cidexps
		                     DO WHILE SEEK(m.cidexps)
		                        m.cidexps = oRegistry.incrementcounter('%Shared.Counters.Expense')
		                     ENDDO
		                     SET DELETED ON
		                     INSERT INTO expsusp FROM MEMVAR
		                     m.cOwnerID = temppmt.cOwnerID
		                  ENDSCAN
		               ELSE
		                  SELECT wells
		                  COUNT FOR cLeaseID = m.cLeaseID AND NOT INLIST(wells.cwellstat, 'I', 'S', 'P') TO lnWells
		                  lnAmount   = swround(m.nPmtAmount / lnWells, 2)
		                  lnTotalAmt = swround(lnAmount * lnWells, 2)
		                  lnDiff     = m.nPmtAmount - lnTotalAmt
		
		                  SELECT wells
		                  SCAN FOR cLeaseID = m.cLeaseID AND NOT INLIST(wells.cwellstat, 'I', 'S', 'P')
		                     IF NOT EMPTY(m.cCatCode)
		                        m.cwellid   = wells.cwellid
		                        m.dexpdate  = THISFORM.dCheckDate
		                        m.nAmount   = lnAmount + lnDiff
		                        m.nAmount   = swNetExp(m.nAmount, m.cwellid, .F., m.cexpclass, 'B')
		                        lnDiff      = 0
		                        m.cPayee    = m.cOwnName
		                        m.cvendorid = m.cOwnerID
		                        m.cOwnerID  = ''
		                        m.laptran   = .T.
		                        m.cPaidByCk = m.cidchec  &&  Store the check key used to pay this expense
		                        m.cidexps   = oRegistry.incrementcounter('%Shared.Counters.Expense')
		                        SET DELETED OFF
		                        SELECT expsusp
		                        SET ORDER TO cidexps
		                        DO WHILE SEEK(m.cidexps)
		                           m.cidexps = oRegistry.incrementcounter('%Shared.Counters.Expense')
		                        ENDDO
		                        SET DELETED ON
		                        INSERT INTO expsusp FROM MEMVAR
		                        m.cOwnerID = temppmt.cOwnerID
		                     ENDIF
		                  ENDSCAN
		               
		            ENDIF
		         ENDIF
		
		         m.cidland = oRegistry.incrementcounter('%Shared.Counters.Land History')
		
		         SELECT landhist1
		         SET DELE OFF
		         SET ORDER TO cidland
		         DO WHILE SEEK(m.cidland)
		            m.cidland = oRegistry.incrementcounter('%Shared.Counters.Land History')
		         ENDDO
		         SET DELE ON
		
		         SWSELECT('landhist')
		         INSERT INTO landhist FROM MEMVAR
		      ENDSCAN
		
		      IF m.goApp.oQB.lqbactive
		         IF NOT USED('qbxml')
		            USE (m.goApp.cCommonFolder + 'qbxml') IN 0
		         ENDIF
		         lcxml = lorequest.toxmlstring()
		         INSERT INTO qbxml VALUES(m.cOwnerID, DATETIME(), lcxml)
		         loresponse  = m.goApp.oQB.oqbsm.DoRequests(lorequest)
		         loCheckResp = loresponse.responselist.getat(0)
		
		         IF loCheckResp.statuscode <> 0
		            IF 'object' $ LOWER(loCheckResp.statusmessage)
		               lcListID = SUBSTR(loCheckResp.statusmessage, AT('"', loCheckResp.statusmessage) + 1, AT('"', loCheckResp.statusmessage, 2) - (AT('"', loCheckResp.statusmessage) + 1))
		               llResult = m.goApp.oQB.QBListID(lcListID, THISFORM.DATASESSIONID)
		               IF llResult
		                  SELECT QBListID
		                  IF QBListID.ctype = 'Account'
		                     lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' specified in the ' + ;
		                        'Land Preferences was not found in QuickBooks. Please select a new account ' + ;
		                        'and try to create the check(s) again.'
		                  ELSE
		                     lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' was not found in QuickBooks. ' + ;
		                        'Please synchronize the ' + ALLTRIM(QBListID.ctype) + ' file and try to create the check(s) again.'
		                  ENDIF
		                  THISFORM.omessage.severe(lcMessage)
		               ELSE
		                  THISFORM.omessage.severe(loCheckResp.statusmessage)
		               ENDIF
		            ELSE
		               THISFORM.omessage.severe(loCheckResp.statusmessage)
		            ENDIF
		            * Unpost what got posted so far
		            m.goApp.oQB.csysctlkey = m.cidsysctl
		            m.goApp.oQB.QBUnpostRev()
		            m.goApp.oQB.oqbsm.ClearErrorRecovery()
		            RETURN .F.
		         ELSE
		            loNewCheck = loCheckResp.DETAIL
		            m.ctxnid   = loNewCheck.TxnID.getvalue()
		            SWSELECT('checks')
		            LOCATE FOR cidchec == m.cidchec
		            IF FOUND()
		               REPLACE ctxnid WITH m.ctxnid
		            ENDIF
		            * Save the tranaction so that it can be unposted from QB if any
		            * of the other transactions fail
		            SWSELECT('qbpost')
		            LOCATE FOR cidsysctl = m.cidsysctl AND ntype = lnCheck
		            IF NOT FOUND()
		               m.ntype   = lnCheck
		               m.mtxnids = m.ctxnid
		               INSERT INTO qbpost FROM MEMVAR
		            ELSE
		               IF NOT EMPTY(ALLT(mtxnids))
		                  REPL mtxnids WITH ALLT(mtxnids) + CHR(13) + m.ctxnid
		               ELSE
		                  REPL mtxnids WITH m.ctxnid
		               ENDIF
		            ENDIF
		            lorequest.clearrequests()
		            m.goApp.oQB.oqbsm.ClearErrorRecovery()
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   IF lnChecks > 0
		      THISFORM.updowner()
		      IF lnChecks = 1
		         THISFORM.omessage.DISPLAY('Created ' + ALLTRIM(STR(lnChecks)) + ' Delay Rental Check. It can be printed from QuickBooks.')
		      ELSE
		         THISFORM.omessage.DISPLAY('Created ' + ALLTRIM(STR(lnChecks)) + ' Delay Rental Checks. They can be printed from QuickBooks.')
		      ENDIF
		   ELSE
		      THISFORM.omessage.DISPLAY('No Checks Were Created')
		   ENDIF
		
		   THISFORM.aSelected = ""
		   = TABLEUPDATE(2, .T., 'landowner')
		   = TABLEUPDATE(2, .T., 'landhist')
		   = TABLEUPDATE(2, .T., 'checks')
		   = TABLEUPDATE(2, .T., 'expsusp')
		   SWSELECT('qbpost')
		   REPLACE lPosted WITH .T. FOR cidsysctl = m.cidsysctl
		   THISFORM.RELEASE()
		ELSE
		   THISFORM.omessage.warning('The link to QuickBooks is not active. Delay rental checks cannot be created now.')
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE Init
		LPARA tdDate, tdCheckDate
		LOCAL oLand
		
		thisform.dCheckDate = tdCheckDate
		
		DODEFAULT()
		SET DELETED ON
		
		THISFORM.CAPTION = 'Delay Rental Payments Due As Of ' + DTOC(tdDate)
		
		*
		*  Initialize the arrays
		*
		LOCAL laSelected[1]
		
		oLand = CREATEOBJECT('Land')
		oLand.buildpmts(1,tdDate,tdDate)
		
		SELECT landpmts
		lnCount = RECC()
		IF lnCount > 0
		   DIME laAvailable[lnCount]
		   lnX = 1
		   SCAN
		      SCATTER MEMVAR
		      laAvailable[lnX] = cleaseID + '-'+LEFT(cLeaseName,25) + '  ' + cOwnerID+'-'+LEFT(cOwnName,15) + '  ' + DTOC(dpmtdate) + '  ' + STR(nPmtAmount,9,2)
		      lnX = lnX + 1
		   ENDSCAN
		
		   *  Initialize the aSelected array property
		   THISFORM.aSelected = ""
		
		   *  Call the setvalue method to initialze the listboxes
		   THISFORM.cntMoverListPair.SetValue(@laAvailable,@laSelected)
		ELSE
		   thisform.oMessage.Display('There are no delay rental payments due as of the date given...')
		   RETURN .F.
		ENDIF
		
		
	ENDPROC

	PROCEDURE updowner		&& Updates the owner file with the last payment info.
		lnCount = ALEN(THISFORM.aSelected,1)
		lnChecks = 0
		
		FOR lnX = 1 TO lnCount
		   SELECT landpmts
		   LOCATE FOR cLeaseID + '-'+LEFT(cLeaseName,25) + '  ' + cOwnerID + '-'+LEFT(cOwnName,15) + '  ' + DTOC(dpmtdate) + '  ' + STR(nPmtAmount,9,2) = THISFORM.aSelected[lnX]
		   IF FOUND()
		      SCATTER MEMVAR
		      SELECT landowner
		      LOCATE FOR cidlando = landpmts.cidlando
		      IF FOUND()
		         REPL npmttodate WITH npmttodate + m.nPmtAmount
		         IF NOT EMPTY(landowner.dnextpmt)
		            REPLACE dNextPmt WITH GOMONTH(landowner.dNextPmt,landowner.nPmtFreq)
		         ELSE
		            IF NOT EMPTY(landowner.dstartdate)
		               REPLACE dNextPmt WITH GOMONTH(landowner.dstartdate,landowner.nPmtFreq)   
		            ELSE
		               REPLACE dNextPmt WITH GOMONTH(this.dcheckdate,landowner.nPmtFreq)   
		            ENDIF    
		         ENDIF    
		      ENDIF
		   ENDIF
		ENDFOR
		
		
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		*
		*  Empty the selected array so that nothing is selected
		*
		thisform.aSelected = ""
		thisform.release()
	ENDPROC

	PROCEDURE cmdOK.Click
		LOCAL lnX, lnCount, laSelected[100]
		
		*  Get the selected array
		lnCount = thisform.cntMoverListPair.GetValue(@laSelected)
		
		IF lnCount > 0
		   *  Set the aSelected property to the selected array
		   DIME thisform.aSelected[lnCount]
		   FOR lnX = 1 TO lnCount
		       thisform.aSelected[lnX] = laSelected[lnX]
		   ENDFOR
		ELSE
		   thisform.aSelected = ""   
		ENDIF
		
		*  Create the checks
		thisform.createchks()    
		
	ENDPROC

ENDDEFINE
