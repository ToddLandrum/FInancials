*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="arrecpmtqb.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor18" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor19" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor20" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 619
	InitialSelectedAlias = "arpmthdr"
	Left = -19
	Name = "Dataenvironment"
	Top = 209
	Width = 981

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "arpmthdr", ;
		BufferModeOverride = 3, ;
		CursorSource = "arpmthdr", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 34, ;
		Name = "Cursor1", ;
		Order = "drecdate", ;
		Top = 9, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "invhdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "invhdr", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Filter = "not empty(ccustid)", ;
		Height = 90, ;
		Left = 312, ;
		Name = "Cursor11", ;
		Order = "cbatch", ;
		Top = 250, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "invdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "invdet", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 416, ;
		Name = "Cursor13", ;
		Top = 252, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "arpmtdet1", ;
		CursorSource = "arpmtdet", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 415, ;
		Name = "Cursor14", ;
		Top = 15, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "susaudit", ;
		BufferModeOverride = 5, ;
		CursorSource = "susaudit", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 532, ;
		Name = "Cursor15", ;
		Top = 11, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor18' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 536, ;
		Name = "Cursor18", ;
		Top = 133, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor19' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 105, ;
		Left = 663, ;
		Name = "Cursor19", ;
		Top = 5, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "arpmtdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "arpmtdet", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 35, ;
		Name = "Cursor2", ;
		Top = 130, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor20' AS cursor WITH ;
		Alias = "arpmthdr1", ;
		CursorSource = "arpmthdr", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 415, ;
		Name = "Cursor20", ;
		Top = 132, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 158, ;
		Name = "Cursor3", ;
		Top = 10, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "wellinv", ;
		CursorSource = "wellinv", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 189, ;
		Name = "Cursor4", ;
		Top = 154, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "suspense", ;
		BufferModeOverride = 5, ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 710, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\bonanzabaysdata\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 5, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "disbhist", ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 850, ;
		Name = "Cursor7", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Relation1' AS relation WITH ;
		ChildAlias = "arpmtdet", ;
		ChildOrder = "cbatch", ;
		Name = "Relation1", ;
		ParentAlias = "arpmthdr", ;
		RelationalExpr = "cbatch"
		*< END OBJECT: BaseClass="relation" />

ENDDEFINE

DEFINE CLASS formarrecpmt AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shpshapecustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNapplied" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNunapp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCcustid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCustomer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDrecdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCreference" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCreference" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNpmtamt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNpmtamt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNapplied" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNunapp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtnBalance" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcCustName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column1.Txtdate1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column2.Header2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column2.Txttextboxcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column3.Header3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column3.Txtnumeric1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column4.Header4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column4.Txtnumeric1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column6.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column6.Txtnumeric1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column7.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column7.txtnPayment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboCashAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkNOQBPOST" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDrecdate" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: applypmts		&& Automatically applies the payment amount to outstanding invoices.
		*m: calcapplied
		*m: calctot
		*m: requeryrecordsource
		*p: ccustsave		&& Saves the current customer ID for validation purposes.
		*p: coldacctno
		*p: ctype		&& Type of receivable
		*p: lnewbuild
		*p: lqbpost
	*</DefinedPropArrayMethod>

	Caption = "Receive Payments"
	cbunch = 
	clistexpression = arpmthdr.cbatch
	cnavworkarea = arpmthdr
	cworkarea = arpmthdr
	DoCreate = .T.
	Height = 402
	lexpliciteditmode = .F.
	lrememberposition = .F.
	lremembersize = .F.
	Name = "FormArrecpmt"
	Visible = .T.
	Width = 630
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 1
	cmdatamanager.ZOrderSet = 1
	cmlookupmanager.Name = "cmlookupmanager"
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cboCashAcct' AS qbaccount WITH ;
		ControlSource = "arpmthdr.cacctno", ;
		lbankonly = .T., ;
		Left = 259, ;
		Name = "cboCashAcct", ;
		TabIndex = 4, ;
		Top = 3
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkNOQBPOST' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Don't Post To QuickBooks", ;
		Left = 252, ;
		Name = "chkNOQBPOST", ;
		TabIndex = 8, ;
		Top = 57, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdCustomer' AS cmdcommandbuttoncustom WITH ;
		Caption = "Owner ID", ;
		Height = 20, ;
		Left = 8, ;
		Name = "cmdCustomer", ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 6, ;
		Width = 64
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 9, ;
		Left = 326, ;
		Name = "Glmaint", ;
		Top = 51, ;
		Width = 22
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'grdarpmtdet' AS grdgridcustom WITH ;
		ColumnCount = 6, ;
		cworkarea = arpmtdet, ;
		Height = 277, ;
		lallowdelete = .F., ;
		lallownew = .F., ;
		lcolumnmemory = .F., ;
		Left = 5, ;
		LinkMaster = "", ;
		Name = "grdarpmtdet", ;
		Panel = 1, ;
		RecordSource = "arpmtdet", ;
		RelationalExpr = "", ;
		TabIndex = 19, ;
		Top = 118, ;
		Width = 619, ;
		ZOrderSet = 18, ;
		Column1.Bound = .T., ;
		Column1.ControlSource = "arpmtdet.dinvdate", ;
		Column1.FontSize = 8, ;
		Column1.Name = "Column1", ;
		Column1.Width = 109, ;
		Column2.Bound = .T., ;
		Column2.ControlSource = "arpmtdet.cinvnum", ;
		Column2.FontSize = 8, ;
		Column2.Name = "Column2", ;
		Column2.Width = 139, ;
		Column3.Bound = .T., ;
		Column3.ControlSource = "arpmtdet.ndisctot", ;
		Column3.FontSize = 8, ;
		Column3.Name = "Column3", ;
		Column3.Visible = .F., ;
		Column3.Width = 87, ;
		Column4.Bound = .T., ;
		Column4.ControlSource = "arpmtdet.ndistaken", ;
		Column4.FontSize = 8, ;
		Column4.Name = "Column4", ;
		Column4.Visible = .F., ;
		Column4.Width = 89, ;
		Column5.Bound = .T., ;
		Column5.ColumnOrder = 5, ;
		Column5.ControlSource = "arpmtdet.ninvbal", ;
		Column5.FontSize = 8, ;
		Column5.Name = "Column6", ;
		Column5.Width = 150, ;
		Column6.BackColor = 255,255,128, ;
		Column6.Bound = .T., ;
		Column6.ColumnOrder = 6, ;
		Column6.ControlSource = "arpmtdet.namtapp", ;
		Column6.FontSize = 8, ;
		Column6.Name = "Column7", ;
		Column6.Width = 186
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="grid" />

	ADD OBJECT 'grdarpmtdet.Column1.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Date", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column1.Txtdate1' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		BorderColor = 0,0,0, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 44, ;
		Name = "Txtdate1", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column2.Header2' AS header WITH ;
		Alignment = 2, ;
		Caption = " Well ID", ;
		FontSize = 8, ;
		Name = "Header2"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column2.Txttextboxcustom1' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 38, ;
		Name = "Txttextboxcustom1", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column3.Header3' AS header WITH ;
		Alignment = 2, ;
		Caption = "Disc Avail", ;
		FontSize = 8, ;
		Name = "Header3"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column3.Txtnumeric1' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 34, ;
		Name = "Txtnumeric1", ;
		Top = 30, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column4.Header4' AS header WITH ;
		Alignment = 2, ;
		Caption = "Disc Taken", ;
		FontSize = 8, ;
		Name = "Header4"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column4.Txtnumeric1' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 54, ;
		Name = "Txtnumeric1", ;
		Top = 30, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column6.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Balance", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column6.Txtnumeric1' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 25, ;
		Name = "Txtnumeric1", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column7.Header1' AS header WITH ;
		Alignment = 2, ;
		BackColor = 255,255,128, ;
		Caption = "Payment", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column7.txtnPayment' AS txttextboxcustom WITH ;
		BackColor = 255,255,128, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 45, ;
		Name = "txtnPayment", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'lblCreference' AS lblfieldlabelcustom WITH ;
		Caption = "Check No.", ;
		Height = 16, ;
		Left = 223, ;
		Name = "lblCreference", ;
		TabIndex = 18, ;
		Top = 85, ;
		Width = 51, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDrecdate' AS lblfieldlabelcustom WITH ;
		Caption = "Date", ;
		Height = 16, ;
		Left = 41, ;
		Name = "lblDrecdate", ;
		TabIndex = 6, ;
		Top = 57, ;
		Width = 24, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Balance", ;
		Height = 16, ;
		Left = 478, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 12, ;
		Top = 42, ;
		Width = 41, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Cash Account", ;
		Left = 181, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 20, ;
		Top = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNapplied' AS lblfieldlabelcustom WITH ;
		Caption = "Amount Applied", ;
		Height = 16, ;
		Left = 441, ;
		Name = "lblNapplied", ;
		TabIndex = 14, ;
		Top = 65, ;
		Width = 78, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNpmtamt' AS lblfieldlabelcustom WITH ;
		Caption = "Amount", ;
		Height = 16, ;
		Left = 26, ;
		Name = "lblNpmtamt", ;
		TabIndex = 17, ;
		Top = 83, ;
		Width = 39, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNunapp' AS lblfieldlabelcustom WITH ;
		Caption = "Unapplied Amount", ;
		Height = 16, ;
		Left = 430, ;
		Name = "lblNunapp", ;
		TabIndex = 16, ;
		Top = 89, ;
		Width = 89, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Shpshapecustom1' AS shpshapecustom WITH ;
		Height = 79, ;
		Left = 421, ;
		Name = "Shpshapecustom1", ;
		Top = 34, ;
		Width = 203, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'txtCcustid' AS txtquickfill WITH ;
		clistexpression = cownerid, ;
		clistworkarea = investor, ;
		ControlSource = "arpmthdr.ccustid", ;
		Height = 20, ;
		InputMask = "XXXXXXXXXX", ;
		Left = 75, ;
		lrequired = .T., ;
		MaxLength = 10, ;
		Name = "txtCcustid", ;
		TabIndex = 3, ;
		Top = 6, ;
		Width = 89, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcCustName' AS txttextboxcustom WITH ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 75, ;
		Name = "txtcCustName", ;
		ReadOnly = .T., ;
		TabIndex = 5, ;
		Top = 29, ;
		Width = 233, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCreference' AS txttextboxcustom WITH ;
		ControlSource = "arpmthdr.creference", ;
		Height = 20, ;
		Left = 279, ;
		MaxLength = 10, ;
		Name = "txtCreference", ;
		TabIndex = 10, ;
		Top = 81, ;
		Width = 79, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtDrecdate' AS dpk WITH ;
		ControlSource = "arpmthdr.drecdate", ;
		Height = 20, ;
		Left = 75, ;
		lmorethan90 = .T., ;
		lnocurrentdate = .F., ;
		lrequired = .T., ;
		Name = "txtDrecdate", ;
		TabIndex = 7, ;
		Top = 55, ;
		Visible = .T., ;
		Width = 67
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNapplied' AS txttextboxcustom WITH ;
		ControlSource = "arpmthdr.napplied", ;
		Height = 20, ;
		Left = 524, ;
		Name = "txtNapplied", ;
		TabIndex = 13, ;
		Top = 64, ;
		Width = 89, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtnBalance' AS txttextboxcustom WITH ;
		Comment = "", ;
		ControlSource = "arpmthdr.ncustbalance", ;
		Height = 20, ;
		Left = 524, ;
		Name = "txtnBalance", ;
		TabIndex = 11, ;
		Top = 40, ;
		Width = 89, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNpmtamt' AS txttextboxcustom WITH ;
		Alignment = 3, ;
		ControlSource = "arpmthdr.npmtamt", ;
		Height = 20, ;
		InputMask = "999999999.99", ;
		Left = 75, ;
		lrequired = .F., ;
		Name = "txtNpmtamt", ;
		TabIndex = 9, ;
		Top = 81, ;
		Value = 0, ;
		Width = 104, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNunapp' AS txttextboxcustom WITH ;
		ControlSource = "arpmthdr.nunapp", ;
		Height = 20, ;
		Left = 524, ;
		Name = "txtNunapp", ;
		TabIndex = 15, ;
		Top = 88, ;
		Width = 89, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		*
		*  Look for the owner name 
		*
		lnSelect = SELECT()
		
		SELECT investor
		LOCATE FOR cOwnerID = arpmthdr.cCustID
		IF FOUND()
		   thisform.txtcCustName.value = investor.cownname
		   thisform.txtcCustName.Refresh()
		ELSE
		   thisform.txtcCustName.value = 'Unknown'   
		   thisform.txtcCustName.Refresh()
		ENDIF   
		
		SELECT glopt
		GO TOP
		
		SELECT (lnSelect)
		
		RETURN (DODEFAULT())
	ENDPROC

	PROCEDURE applypmts		&& Automatically applies the payment amount to outstanding invoices.
		*
		*  Automatically applies the payment amount entered to
		*  outstanding invoices.  Tries to match to payment amount
		*  to an outstanding invoice.  If an invoice is found with
		*  the same outstanding balance, the payment is applied to
		*  it.  If an invoice is not found with the same balance as
		*  the payment, the payment is applied to invoices starting
		*  with the oldest invoice.
		*
		LOCAL lcBatch, lnPmtAmt, lnInvBal, lnPmtLeft, lnCount, lnSelect, lnApplied
		
		lnSelect = SELECT()
		
		lcBatch   = arpmthdr.cBatch
		lnPmtAmt  = arpmthdr.nPmtAmt
		lnPmtLeft = lnPmtAmt
		lnApplied = arpmthdr.nApplied
		
		*
		*  If the payment has already been applied, exit
		*
		IF lnPmtAmt = lnApplied
		   RETURN .T.
		ENDIF
		
		* Check to see if pmt amount is same as outstanding balance.
		* If so, apply to all outstanding invoices
		IF lnPmtAmt = arpmthdr.ncustbalance
		   SELE arpmtdet
		   SCAN
		      REPL nAmtApp WITH nInvBal
		   ENDSCAN
		ELSE
		   * 1st look for an exact match
		   SELECT arpmtdet
		   LOCATE FOR cBatch == lcBatch AND nInvBal = lnPmtAmt
		   IF FOUND()
		      REPL nAmtApp WITH lnPmtAmt
		      lnPmtAmt = 0
		   ELSE
		      SELECT arpmtdet
		      SCAN FOR cBatch == lcBatch AND nAmtApp = 0
		         lnInvBal = nInvBal
		
		         DO CASE
		            CASE lnInvBal < 0
		               LOOP 
		            CASE lnInvBal < lnPmtLeft
		               REPL nAmtApp WITH lnInvBal
		               lnPmtLeft = lnPmtLeft - lnInvBal
		
		            CASE lnInvBal > lnPmtLeft
		               REPL nAmtApp WITH lnPmtLeft
		               lnPmtLeft = 0
		               EXIT
		         ENDCASE
		      ENDSCAN
		   ENDIF
		ENDIF
		
		SELECT (lnSelect)
		
	ENDPROC

	PROCEDURE calcapplied
		LOCAL lnSelect, lcBatch, lnApplied, lnUnapp, lnPayment
		*
		*  Calculates the amounts applied to the outstanding
		*  invoices.
		*
		lcBatch = arpmthdr.cBatch
		
		lnSelect = SELECT()
		
		SELECT arpmtdet
		lnRecno = RECNO()
		SUM(nAmtApp) FOR cBatch == lcBatch TO lnApplied
		IF lnRecno <= RECCOUNT()
		   GOTO (lnRecno)
		ENDIF
		
		IF TYPE('thisform.txtnPmtAmt.value') <> 'N'
		   lnPayment = VAL(thisform.txtnPmtAmt.value)
		ELSE   
		   lnPayment = thisform.txtnPmtAmt.value
		ENDIF   
		lnUnapp = lnPayment - lnApplied
		
		IF arpmthdr.napplied <> lnApplied
		   thisform.cmdatamanager.replace('Arpmthdr', 'Napplied', lnApplied)
		   thisform.txtnApplied.refresh()
		ENDIF
		IF arpmthdr.nunapp <> lnUnapp   
		   thisform.cmdatamanager.replace('Arpmthdr', 'Nunapp', lnUnapp)
		   thisform.txtnUnapp.refresh()
		ENDIF   
		
		SELECT (lnSelect)
		
	ENDPROC

	PROCEDURE calctot
		LOCAL lnSelect, lcBatch, lnBalance
		
		lnBalance = 0
		lcBatch   = arpmthdr.cBatch
		lnSelect = SELECT()
		SELECT arpmtdet
		lnRecno = RECNO()
		SUM(nInvBal) FOR cBatch == lcBatch TO lnBalance 
		IF lnRecno <= RECCOUNT()
		   GOTO (lnRecno)
		ENDIF
		*
		*  Don't update the balance unless it's changed.
		*
		IF Arpmthdr.nCustBalance <> lnBalance
		   thisform.cmdatamanager.replace('Arpmthdr','Ncustbalance',lnBalance)
		   thisform.txtnBalance.refresh()
		ENDIF   
		
		SELECT (lnSelect)
		
		UNLOCK
		
	ENDPROC

	PROCEDURE cancelallchanges
		LPARAMETERS cworkarealist
		
		THISFORM.lNewBuild = .f.
		DODEFAULT(cworkarealist)
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   THIS.CAPTION = 'Receive Owner Net Payments'
		   THIS.HELPCONTEXTID = 571
		   SET DELETED ON
		ENDIF
		
	ENDPROC

	PROCEDURE list
		LPARAMETERS cworkarea
		LOCAL lcList
		PRIV llOK
		
		lnSelect = SELECT()
		
		llOK = .T.
		lcList = 'drecdate\Date,ccustid\ID,csortfield\Name,npmtamt\Amount'
		
		SELECT arpmthdr.drecdate, ;
		       arpmthdr.ccustid, ;
		       investor.csortfield, ;
		       arpmthdr.npmtamt, ;
		       arpmthdr.cbatch ;
		  FROM arpmthdr, investor ;
		  WHERE arpmthdr.ccustid = investor.cownerid ;
		  INTO CURSOR temppmt1 ;
		  ORDER BY arpmthdr.drecdate, arpmthdr.ccustid
		  
		IF _tally > 0
		   USE DBF('temppmt1') AGAIN IN 0 ALIAS temppmt EXCL
		   SELECT temppmt
		   INDEX ON drecdate  TAG drecdate
		   INDEX ON ccustid   TAG ccustid
		   INDEX ON csortfield TAG csortfield
		   index on npmtamt tag npmtamt
		
		   DO FORM ..\custom\picklist WITH 'temppmt', lcList, thisform.txtdrecdate.value, 4, .T., .t.
		   
		   IF llOK
		      SELECT arpmthdr
		      SET ORDER TO cbatch
		      SEEK(temppmt.cbatch)
		      THISFORM.cmdatamanager.setrecordposition('arpmthdr')
		      THISFORM.REFRESH()
		   ENDIF
		ELSE
		   thisform.omessage.display('There are no customer payments in the payment file.')
		ENDIF
		
		IF USED('temppmt1')
		   USE IN temppmt1          
		ENDIF
		
		IF USED('temppmt')
		   USE IN temppmt
		ENDIF      
		
		SELECT (lnSelect)
		       
	ENDPROC

	PROCEDURE Load
		IF DODEFAULT()
		   *  Get the cursor of QuickBooks Accounts
		   m.goApp.oQB.qbaccounts('',.F.,.T.,thisform.datasessionid)
		ENDIF
	ENDPROC

	PROCEDURE requeryrecordsource
		LOCAL lcCustId, lcBatch, lnCount, lnSelect
		*
		*  Check for outstanding invoices for the given customer.
		*
		lnSelect = SELECT()
		lcCustId = arpmthdr.cCustId
		lcBatch  = arpmthdr.cBatch
		
		IF THIS.lNewBuild
		   *
		   *  Check for suspense
		   *
		     
		      CREATE CURSOR auditrecs ;
		         (cYear      C(4), ;
		         dSuspDate  D,    ;
		         cTime      C(8), ;
		         cAction    C(1), ;
		         cGroup     C(2), ;
		         nAmount    N(12,2), ;
		         cSuspType  C(1), ;
		         dinvdate   D, ;
		         csuspdesc  C(25), ;
		         cownerid   C(10), ;
		         cwellid    C(10), ;
		         cwellname  C(30), ;
		         cProgCode  C(10), ;
		         cprogname  C(30), ;
		         lProgFlag  L, ;
		         cPeriod    C(2), ;
		         cownname   C(40))
		      INDEX ON cownerid+cwellid TAG ownerwell
		
		      jcount     = 0
		
		      SELECT MAX(hYear) AS cYear, SUM(nNetCheck) AS nAmount, cSuspType, ;
		         suspense.cownerid AS cownerid, suspense.cwellid AS cwellid, ;
		         MAX(hPeriod) AS cPeriod, cGroup, MAX(hdate) AS dinvdate, ;
		         investor.cownname AS cownname ;
		         FROM suspense, investor ;
		         WHERE suspense.cownerid = lcCustId ;
		         AND suspense.cownerid = investor.cownerid ;
		         ORDER BY suspense.cownerid, suspense.cwellid ;
		         GROUP BY suspense.cownerid, suspense.cwellid ;
		         INTO CURSOR temp
		      SELECT auditrecs
		      APPEND FROM DBF('temp')
		      GO TOP
		      SCAN
		         m.cwellid = cwellid
		         SELECT wells
		         SET ORDER TO cwellid
		         SEEK m.cwellid
		         IF FOUND()
		            IF wells.cwellstat = 'I' AND auditrecs.namount = 0
		               SELECT auditrecs
		               DELETE NEXT 1
		               LOOP
		            ENDIF 
		            m.cwellname = cwellname
		            SELECT auditrecs
		            REPLACE cwellname WITH m.cwellname
		         ENDIF
		      ENDSCAN
		
		      SELE auditrecs
		      SCAN
		         SCATTER MEMVAR
		         m.nInvTot   = m.nAmount *-1
		         m.nInvbal   = m.nAmount *-1
		         m.cCustId   = m.cownerid
		         m.cinvnum   = m.cwellid
		         m.cBatch    = lcBatch
		         m.cProdYear = m.cYear
		         m.cProdPrd  = m.cPeriod
		         m.lNetJIB   = .T.
		         m.cInvToken = ''
		         m.cidarpmd  = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		         SET DELETED OFF
		         SELECT arpmtdet1
		         SET ORDER TO cidarpmd
		         DO WHILE INDEXSEEK(m.cidarpmd)
		            m.cidarpmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		         ENDDO
		         SET DELETED ON
		         INSERT INTO arpmtdet FROM MEMVAR
		      ENDSCAN
		
		      SELECT wellinv  &&  Scan through their current interests, and bring in any wells that don't have a balance already, so money can be easily applied to them - BH 9/7/06
		      SCAN FOR cownerid = lcCustID
		         SELECT auditrecs
		         LOCATE FOR cwellid = wellinv.cwellid  &&  If it doesn't exist, insert a zero record
		         IF NOT FOUND()
		            STORE 0 TO m.nInvTot, m.nInvbal
		            m.cCustID = lcCustID
		            m.dInvDate = DATE()  &&  No records, so just use the current date to display
		            m.cinvnum = wellinv.cwellid
		            m.cidarpmd  = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		            m.cBatch    = lcBatch            
		            SET DELETED OFF
		            SELECT arpmtdet1
		            SET ORDER TO cidarpmd
		            DO WHILE INDEXSEEK(m.cidarpmd)
		               m.cidarpmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		            ENDDO
		            SET DELETED ON
		            INSERT INTO arpmtdet FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		      SELECT arpmtdet
		      GO TOP
		      THISFORM.REFRESH()
		
		ENDIF
		SELECT (lnSelect)
		
	ENDPROC

	PROCEDURE save
		LPARAMETERS cworkarealist
		
		thisform.txtccustid.setfocus()
		thisform.setnextcontrol(thisform.txtccustid)
		thisform.activatenextcontrol()
		
		DODEFAULT(cworkarealist)
	ENDPROC

	PROCEDURE cboCashAcct.Init
		IF DODEFAULT() 
		   this.listitemid = 2
		ENDIF    
	ENDPROC

	PROCEDURE chkNOQBPOST.Valid
		THISFORM.lQBPost = NOT this.value
	ENDPROC

	PROCEDURE cmdatamanager.afternav
		LPARAMETERS cworkarea
		
		IF m.cworkarea = 'Arpmthdr'
		   IF THISFORM.lNewBuild
		      THISFORM.requeryrecordsource()
		      THISFORM.calctot()
		      THISFORM.txtcCustid.VALID()
		   ENDIF
		   SELECT glopt
		   GO TOP
		
		   SELECT investor
		   LOCATE FOR cownerid = arpmthdr.ccustid
		   IF FOUND()
		      thisform.txtcCustName.value = cownname
		      thisform.txtcCustName.Refresh()
		   ELSE 
		      thisform.txtcCustName.value = ''
		      thisform.txtcCustName.Refresh()  
		   ENDIF
		ENDIF
		
		SELECT arpmthdr
		
		DODEFAULT(m.cworkarea)
		
	ENDPROC

	PROCEDURE cmdatamanager.afternew
		LPARAMETERS cworkarea
		
		IF m.cworkarea == 'Arpmthdr'
		
		   llSafe = .F.
		   DO WHILE NOT llSafe  &&  Loop through arpmthdr and invhdr to find a mutually safe key, in case of credit invoices
		      lcBatch = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		      SELECT arpmthdr1
		      SET ORDER TO cBatch
		      SET DELE OFF
		      DO WHILE SEEK(lcBatch)
		         lcBatch = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		      ENDDO
		
		      llSafe = .T.
		
		      SELECT invhdr
		      SET ORDER TO cBatch
		      DO WHILE SEEK(lcBatch)
		         lcBatch = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		         llSafe = .F.
		      ENDDO
		      SET DELE ON
		   ENDDO
		   
		   SELECT arpmthdr
		   REPLACE cBatch  WITH lcBatch, ;
		      cAcctNo WITH THISFORM.cbocashacct.VALUE, ;
		      dRecDate WITH DATE()
		
		   THISFORM.lNewBuild = .T.
		   *   THISFORM.txtdRecDate.SET('value',DATE())
		   THISFORM.ccustsave  = ''
		   THISFORM.txtcCustName.VALUE = ''
		   THISFORM.txtcCustID.SetFocus()
		   thisform.setnextcontrol(thisform.txtccustid)
		ENDIF
		
		DODEFAULT(m.cworkarea)
		
		
	ENDPROC

	PROCEDURE cmdatamanager.afterupdate
		LPARAMETERS cworkarealist
		
		*
		*  Turn off the new flag
		*
		thisform.lNewBuild = .F.
		
		RETURN (DODEFAULT(m.cWorkarealist))
	ENDPROC

	PROCEDURE cmdatamanager.beforeupdate
		LPARAMETERS cworkarealist
		LOCAL lcbatch, lcaracct, llreturn, lcselect, lnrecno, lcdefacct
		LOCAL lndiscounts, lcdiscacct, lcidchec, llReceivable, llNoDOI, lcCustID
		LOCAL oSuspense AS 'suspense'
		LOCAL lManual, lcListID, lcMessage, lcMinAcct, lcjibacct, lcownerlistid, lcxml, llDOI, llOwnerHold
		LOCAL llResult, lnrunno, lnselect, loError, lodelresp, loentry, loentryadd, lopayment, lopmtdel
		LOCAL lopmtresp, lorequest, loresponse
		LOCAL cGroup, cRecType, cSuspType, cTypeInt, cTypeInv, cbatch, cidchec, ciddisb, cownerid
		LOCAL cperiod, cprogcode, crunyear, crunyear_in, ctxnid, cwellid, cyear, hDate, nNetCheck, nrunno
		LOCAL nrunno_in
		
		llreturn = .T.
		
		TRY
		   lnselect = SELECT()
		
		   IF arpmthdr.nunapp <> 0  &&  If there are unapplied amounts, don't let them continue - BH 9/7/06
		      THISFORM.omessage.Warning('You must apply the entire amount of the payment to one or more wells.  Please apply the rest of the payment to a well or wells before saving.')
		      llreturn = .F.
		      EXIT
		   ENDIF
		
		   IF NOT THISFORM.chkNOQBPOST.VALUE
		      IF EMPTY(THISFORM.cbocashacct.VALUE)
		         THISFORM.omessage.Warning('A valid bank account must be chosen to deposit this receipt into.')
		         THISFORM.setnextcontrol(THISFORM.cbocashacct)
		         llreturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   lcbatch  = arpmthdr.cbatch
		   lcCustID = arpmthdr.ccustid
		
		   *  Look in disbhist to see if there are entries from this batch in it.  If there are, don't let them save, because those came from suspense
		   *  and have been processed during a run closing.  Otherwise, they'd end up with duplicate entries in suspense.
		   SELECT disbhist
		   LOCATE FOR cbatch = lcbatch
		   IF FOUND()
		      THISFORM.omessage.Warning('You cannot save this payment, because suspense entries created by it have been closed as part of a revenue run.')
		      llreturn = .F.
		      EXIT
		   ENDIF
		
		   *
		   * Get the JIB rcv acct
		   *
		   SELE options
		   GO TOP
		   lcjibacct = cjibacct
		   lcdefacct = cdefacct
		   lcMinAcct = cminacct
		
		   WAIT WINDOW NOWAIT 'Saving Changes, Please Wait.....'
		
		   lcidchec = arpmthdr.cidchec
		
		   lndiscounts = 0
		   SELECT arpmtdet
		   SCAN FOR cbatch == lcbatch AND ndistaken <> 0
		      lndiscounts = lndiscounts + ndistaken
		   ENDSCAN
		
		   *  Remove suspense entries with same batch number
		   swselect('suspense', .T.)
		   SCAN FOR cbatch == lcbatch AND cRecType = 'P'
		      DELETE NEXT 1
		   ENDSCAN
		
		   swselect('disbhist')
		   LOCATE FOR cbatch == lcbatch AND cRecType = 'P'
		   IF FOUND()
		      MESSAGEBOX('This payment has already been processed in a run closing. It cannot be Updated.', 16, 'Update Payment')
		      llreturn = .F.
		      EXIT
		   ENDIF
		
		   ** Do we have an active connection to QuicBooks?
		   IF m.goapp.oQB.lqbactive AND NOT THISFORM.chkNOQBPOST.VALUE
		      IF NOT EMPTY(arpmthdr.ctxnid)
		         * Delete the journal entry for this payment from QB
		         llreturn = m.goapp.oQB.DeleteTxnID(arpmthdr.ctxnid, 15)
		         IF NOT llreturn
		            EXIT 
		         ENDIF
		      ENDIF
		   ENDIF
		
		   *
		   *  Check to see what the last closed run was
		   *
		   m.crunyear = TRANS(YEAR(DATE()))
		   lnrunno    = getrunno(m.crunyear, .F., 'R')
		   IF lnrunno = 0
		      m.crunyear = STR(VAL(m.crunyear) - 1, 4)
		      lnrunno    = getrunno(m.crunyear)
		      IF lnrunno = 0
		         lnrunno = 12
		      ENDIF
		   ENDIF
		
		   m.nrunno  = lnrunno
		   m.cyear   = m.crunyear
		   m.cperiod = PADL(ALLT(STR(lnrunno)), 2, '0')
		
		   oSuspense          = CREATEOBJECT('suspense')
		   oSuspense.crunyear = m.crunyear
		   oSuspense.nrunno   = lnrunno
		   oSuspense.GetLastType()
		
		   SELE arpmtdet
		   SCAN FOR cbatch == lcbatch AND namtapp <> 0
		      *
		      *  Add the payment to the suspense file
		      *
		      m.nNetCheck = arpmtdet.namtapp
		      m.cownerid  = arpmthdr.ccustid
		      m.cprogcode = ''
		      m.cRecType  = 'P'  &&  Payment type - BH 9/7/06
		      m.cidchec   = arpmthdr.cidchec
		      m.cwellid   = PADR(ALLTRIM(arpmtdet.cinvnum),10,' ')
		      m.lManual   = .T.
		      m.cbatch    = lcbatch
		
		      *  Get the owner type to put on the record
		      SELECT suspense
		      LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv = 'W' AND cRecType = 'R'
		      IF FOUND()
		         m.cTypeInv  = suspense.cTypeInv
		         m.cTypeInt  = suspense.cTypeInt
		         m.cprogcode = suspense.cprogcode
		      ELSE
		         LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv # 'W' AND cRecType = 'R'
		         IF FOUND()
		            m.cTypeInv  = suspense.cTypeInv
		            m.cTypeInt  = suspense.cTypeInt
		            m.cprogcode = suspense.cprogcode
		         ELSE
		            swselect('wellinv')
		            LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv = 'W'
		            IF FOUND()
		               m.cTypeInv  = wellinv.cTypeInv
		               m.cTypeInt  = wellinv.cTypeInt
		               m.cprogcode = wellinv.cprogcode
		            ELSE
		               LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv # 'W'
		               IF FOUND()
		                  m.cTypeInv  = wellinv.cTypeInv
		                  m.cTypeInt  = wellinv.cTypeInt
		                  m.cprogcode = wellinv.cprogcode
		               ELSE
		                  swselect('disbhist')
		                  LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv = 'W'
		                  IF FOUND()
		                     m.cTypeInv  = disbhist.cTypeInv
		                     m.cTypeInt  = disbhist.cTypeInt
		                     m.cprogcode = disbhist.cprogcode
		                  ELSE  &&  Punt
		                     LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv # 'W'
		                     IF FOUND()
		                        m.cTypeInv  = disbhist.cTypeInv
		                        m.cTypeInt  = disbhist.cTypeInt
		                        m.cprogcode = disbhist.cprogcode
		                     ELSE
		                        m.cTypeInv  = 'W'
		                        m.cTypeInt  = 'B'
		                        m.cprogcode = ''
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		
		      * If the owner is on hold, mark the suspense type as legal suspense "H"
		      swselect('investor')
		      SET ORDER TO cownerid
		      IF SEEK(lcCustID) AND lHold
		         m.cSuspType = 'H'
		      ELSE
		         * Get the last suspense type per owner/well
		         oSuspense          = CREATEOBJECT('suspense')
		         oSuspense.crunyear = TRANSFORM(YEAR(DATE()))
		         oSuspense.nrunno   = 999
		         oSuspense.GetLastType(.F., .T.)
		         SELECT curlastsusptype
		         LOCATE FOR cownerid == lcCustID AND cwellid == m.cwellid
		         IF FOUND()
		            m.cSuspType  = curlastsusptype.cSuspType  &&  Suspense type - PS 3/31/07
		         ELSE
		            * Shouldn't get here
		            m.cSuspType = 'D'
		         ENDIF
		      ENDIF
		
		
		      * Find the current well group, so we can find the last closing for that group, and put that on the suspense entry
		      SELECT wells
		      LOCATE FOR ALLTRIM(cwellid) == ALLTRIM(m.cwellid)
		      IF FOUND()
		         m.cGroup = wells.cGroup
		         SELECT sysctl
		         SET ORDER TO YearRun DESCENDING
		         GO TOP
		         LOCATE FOR cGroup = m.cGroup AND cTypeClose = 'R' AND nrunno # 9999  &&  Locate last closing
		         IF FOUND()
		            m.crunyear    = crunyear
		            m.nrunno      = nrunno
		            m.crunyear_in = crunyear
		            m.nrunno_in   = nrunno
		            m.hDate       = dAcctDate
		         ELSE  &&  No closings found, so set it to a very early date, to avoid any data overlap problems that may arise down the road
		            m.crunyear    = '1980'
		            m.nrunno      = 1
		            m.crunyear_in = crunyear
		            m.nrunno_in   = nrunno
		            m.hDate       = {12/31/1980}
		         ENDIF
		      ELSE  &&  Can't find the chosen well, so set some defaults - should never get here
		         m.cGroup      = '00'
		         m.crunyear    = '1980'
		         m.nrunno      = 1
		         m.crunyear_in = crunyear
		         m.nrunno_in   = nrunno
		         m.hDate       = {12/31/1980}
		      ENDIF
		
		      SELECT suspense
		      SET ORDER TO ciddisb
		      m.ciddisb    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Suspense')
		      SET DELE OFF
		      DO WHILE SEEK(m.ciddisb)
		         m.ciddisb    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Suspense')
		      ENDDO
		      SET DELE ON
		      INSERT INTO suspense FROM MEMVAR
		
		   ENDSCAN
		
		   IF m.goapp.oQB.lqbactive AND NOT THISFORM.chkNOQBPOST.VALUE
		       * get a message set request object (version 1.1 xml)
		      lorequest = m.goapp.oQB.oQBRequest
		
		      * set the on error attribute for the request
		      lorequest.ATTRIBUTES.onerror = 1
		      lorequest.ClearRequests()
		
		      * Check to see if the deficit account is a receivable acct
		      * The posting will have to be changed to group deficits by
		      * owner if the account is a receivable acct.
		      llReceivable = .F.
		      m.goapp.oQB.QBAccounts('', .F., .T., .F.)
		      SELECT accounts
		      LOCATE FOR cListID = lcdefacct
		      IF FOUND()
		         IF 'receivable' $ LOWER(cAcctType)
		            llReceivable = .T.
		         ELSE
		            llReceivable = .F.
		         ENDIF
		      ELSE
		         MESSAGEBOX('No owner deficit account was specified. Please choose a cash account and save the payment again.', 16, 'No Deficit Account')
		         llreturn = .F.
		         EXIT
		      ENDIF
		
		      loentryadd = lorequest.appendjournalentryaddrq()
		      loentryadd.txndate.setvalue(arpmthdr.drecdate)
		      *   loentryadd.MEMO.setvalue('** DO NOT CHANGE OR DELETE THIS ENTRY IN QUICKBOOKS **')
		      loentryadd.refnumber.setvalue(arpmthdr.creference)
		
		      SELE investor
		      LOCATE FOR cownerid = arpmthdr.ccustid
		      IF FOUND()
		         lcownerlistid = cListID
		         llOwnerHold   = lHold
		      ELSE
		         WAIT WIND NOWAIT 'Owner Not Found...'
		         llreturn = .F.
		         EXIT
		      ENDIF
		
		      IF m.goapp.oQB.QBFCVersion > ' 4.0'
		         loentry = loentryadd.ORJournalLineList.APPEND.journaldebitline
		      ELSE
		         loentry = loentryadd.journaldebitlinelist.APPEND
		      ENDIF
		
		      loentry.MEMO.setvalue('Net Payment')
		      loentry.amount.setvalue(ABS(arpmthdr.npmtamt))
		      loentry.entityref.listid.setvalue(lcownerlistid)
		      loentry.accountref.listid.setvalue(THISFORM.cbocashacct.VALUE)
		
		      IF NOT llReceivable
		         SELE arpmtdet
		         SCAN FOR cbatch == lcbatch AND namtapp <> 0
		            IF arpmtdet.namtapp > 0
		               IF m.goapp.oQB.QBFCVersion > ' 4.0'
		                  loentry = loentryadd.ORJournalLineList.APPEND.journalcreditline
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ELSE
		               IF m.goapp.oQB.QBFCVersion > ' 4.0'
		                  loentry = loentryadd.ORJournalLineList.APPEND.journaldebitline
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ENDIF
		            loentry.MEMO.setvalue('Net Payment')
		            loentry.amount.setvalue(ABS(arpmtdet.namtapp))
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            IF NOT llOwnerHold
		               loentry.accountref.listid.setvalue(lcdefacct)
		            ELSE
		               loentry.accountref.listid.setvalue(lcMinAcct)
		            ENDIF
		
		            SELECT wells
		            LOCATE FOR ALLTRIM(cwellid) == ALLTRIM(arpmtdet.cinvnum)
		            IF FOUND()
		               loentry.classref.listid.setvalue(wells.cListID)
		            ENDIF
		         ENDSCAN
		      ELSE
		         IF arpmthdr.npmtamt > 0
		            IF m.goapp.oQB.QBFCVersion > ' 4.0'
		               loentry = loentryadd.ORJournalLineList.APPEND.journalcreditline
		            ELSE
		               loentry = loentryadd.journalcreditlinelist.APPEND
		            ENDIF
		         ELSE
		            IF m.goapp.oQB.QBFCVersion > ' 4.0'
		               loentry = loentryadd.ORJournalLineList.APPEND.journaldebitline
		            ELSE
		               loentry = loentryadd.journaldebitlinelist.APPEND
		            ENDIF
		         ENDIF
		         loentry.MEMO.setvalue('Net Payment')
		         loentry.amount.setvalue(ABS(arpmthdr.npmtamt))
		         loentry.entityref.listid.setvalue(lcownerlistid)
		         IF NOT llOwnerHold
		            loentry.accountref.listid.setvalue(lcdefacct)
		         ELSE
		            loentry.accountref.listid.setvalue(lcMinAcct)
		         ENDIF
		      ENDIF
		
		
		      lcxml = lorequest.toxmlstring()
		
		      TRY
		         IF NOT USED('qbxml')
		            USE qbxml IN 0
		         ENDIF
		         INSERT INTO qbxml VALUES(arpmthdr.ccustid, DATETIME(), lcxml)
		      CATCH
		      ENDTRY
		
		      loresponse = m.goapp.oQB.oQBSM.dorequests(lorequest)
		      lopmtresp  = loresponse.responselist.getat(0)
		
		      IF lopmtresp.statuscode <> 0
		         IF 'object' $ LOWER(lopmtresp.statusmessage)
		            lcListID = SUBSTR(lopmtresp.statusmessage, AT('"', lopmtresp.statusmessage) + 1, AT('"', lopmtresp.statusmessage, 2) - (AT('"', lopmtresp.statusmessage) + 1))
		            llResult = m.goapp.oQB.QBListID(lcListID, THISFORM.DATASESSIONID)
		            IF llResult
		               SELECT QBListID
		               IF QBListID.ctype = 'Account'
		                  lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' specified in the ' + ;
		                     'QB Posting Preferences was not found in QuickBooks. Please select a new account ' + ;
		                     'and try to save the payment again.'
		               ELSE
		                  lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' was not found in QuickBooks. ' + ;
		                     'Please synchronize the ' + ALLTRIM(QBListID.ctype) + ' file and try to save the payment again.'
		               ENDIF
		               THISFORM.omessage.severe(lcMessage)
		            ELSE
		               THISFORM.omessage.severe(lopmtresp.statusmessage)
		            ENDIF
		         ELSE
		            THISFORM.omessage.severe(lopmtresp.statusmessage)
		         ENDIF
		         m.goapp.oQB.oQBSM.ClearErrorRecovery()
		         llreturn = .F.
		         EXIT
		      ELSE
		         lopayment = lopmtresp.DETAIL
		         m.ctxnid  = lopayment.txnid.getvalue()
		         SELE arpmthdr
		         REPL ctxnid WITH m.ctxnid
		         m.goapp.oQB.oQBSM.ClearErrorRecovery()
		      ENDIF
		   ENDIF
		
		   *  If they paid off a well's entire balance, check the DOI to see if they have an interest in that well yet.
		   *  If they don't, then warn them that they'll need to clear the balance to move it over to disbhist.
		   llDOI = .F.
		
		   CREATE CURSOR BalTemp  ;
		      (cownerid   c(10),  ;
		      cwellid    c(10))
		
		   SELECT arpmtdet
		   SCAN FOR cbatch = lcbatch AND nInvBal <> 0 AND namtapp <> 0
		      IF nInvBal - namtapp = 0
		         m.cownerid = ccustid
		         m.cwellid  = cinvnum
		         INSERT INTO BalTemp FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELECT BalTemp
		   SCAN
		      SCATTER MEMVAR
		      SELECT wellinv
		      LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid
		      IF NOT FOUND()
		         llDOI = .T.
		      ENDIF
		   ENDSCAN
		
		   *  We found a zero suspense balance, but no corresponding DOI, so give them a warning
		   IF llDOI
		      THISFORM.omessage.Warning("One or more wells have had their balance paid completely. This owner no longer has an interest in the well, so the suspense won't be moved to Owner History unless you use Utilities >> Clear Owner Suspense to clear that well(s) balance.")
		   ENDIF
		
		
		   SELECT suspense
		   *=TABLEUPDATE(.T.)
		   WAIT WINDOW NOWAIT 'Changes Saved....' TIMEOUT 2
		
		   SELECT (lnselect)
		
		CATCH TO loError
		   llreturn = .F.
		   DO errorlog WITH 'BeforeUpdate', loError.LINENO, 'Receive Payments', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the payment at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llreturn
		
		
		
		
		
		
	ENDPROC

	PROCEDURE cmdatamanager.delete
		LPARAMETERS cworkarea
		LOCAL lcBatch, lcPmtBatch, lcAmount
		
		lcBatch = arpmthdr.cbatch
		
		swselect('disbhist')
		LOCATE FOR cbatch == lcBatch AND crectype = 'P'
		IF FOUND()
		   MESSAGEBOX('This payment has already been processed in a run closing. It cannot be Deleted.',16,'Delete Payment')
		   RETURN .F.
		ENDIF
		
		IF m.goapp.oQB.lqbactive
		   IF NOT EMPTY(arpmthdr.ctxnid)
		      * Delete the journal entry for this payment from QB
		      llReturn = m.goapp.oQB.DeleteTxnID(arpmthdr.ctxnid, 15)
		   ENDIF
		ENDIF
		
		IF llReturn
		   SELE suspense
		   SCAN FOR cbatch == lcBatch AND crectype='P'
		      DELE NEXT 1
		   ENDSCAN
		
		   =TABLEUPDATE(.T.)
		
		   RETURN DODEFAULT(cworkarea)
		ENDIF
		
		
		
		
	ENDPROC

	PROCEDURE cmdCustomer.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		lcList = 'cownerid,csortfield'
		
		
		DO FORM ..\CUSTOM\picklist WITH 'Investor', lcList, thisform.txtccustid.value, 2
		
		IF llOK
		   THISFORM.cmdatamanager.REPLACE('Arpmthdr','Ccustid',investor.cownerid)
		   THISFORM.txtcCustID.REFRESH()
		   THISFORM.txtcCustName.VALUE = investor.cownname
		   THISFORM.txtcCustName.REFRESH()
		   IF THISFORM.lNewBuild
		      SELECT arpmtdet
		      DELETE FOR cBatch == arpmthdr.cBatch
		      THISFORM.requeryrecordsource()
		      THISFORM.calctot()
		   ENDIF
		
		ENDIF
		
		THISFORM.txtcCustID.SetFocus()
		
	ENDPROC

	PROCEDURE cmdCustomer.When
		* Don't allow entry into this field when the
		* record is not a new record
		RETURN thisform.lNewBuild
	ENDPROC

	PROCEDURE grdarpmtdet.AfterRowColChange
		LPARAMETERS ncol
		
		if ncol <> 7
		   this.column7.txtnpayment.setfocus()
		endif
		   
		IF thisform.lChanged
		   thisform.calcapplied()
		ENDIF
		   
		RETURN DODEFAULT(ncol)
		   
		
	ENDPROC

	PROCEDURE grdarpmtdet.Column7.txtnPayment.DblClick
		IF EMPTY(THIS.VALUE)
		   REPLACE arpmtdet.nAmtApp WITH arpmtdet.nInvBal
		ELSE
		   REPLACE arpmtdet.nAmtApp WITH 0
		ENDIF
		
		THIS.REFRESH()
		
		THISFORM.calctot()
		thisform.calcapplied()
	ENDPROC

	PROCEDURE txtCcustid.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdCustomer.Click()
		RETURN DODEFAULT()
	ENDPROC

	PROCEDURE txtCcustid.InteractiveChange
		IF DODEFAULT()
		   SELECT investor
		   LOCATE FOR cownerid == this.Value
		   IF FOUND()
		      thisform.txtcCustName.set('value',investor.cOwnName)
		   ELSE
		      thisform.txtcCustName.set('value','')
		   ENDIF 
		ENDIF    
	ENDPROC

	PROCEDURE txtCcustid.LostFocus
		IF THISFORM.lNewBuild
		   IF THISFORM.cCustSave <> THIS.VALUE
		      THISFORM.cmdatamanager.REPLACE('Arpmthdr','Ccustid',investor.cownerid)
		      SELECT arpmtdet
		      DELETE FOR cBatch == arpmthdr.cBatch
		      THISFORM.requeryrecordsource()
		      THISFORM.calctot()
		   ENDIF
		ENDIF
		
		ON KEY LABEL F2 *
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE txtCcustid.When
		*
		*  Don't allow entry in this field when we're just editing the record
		*
		thisform.cCustSave = this.value
		RETURN thisform.lNewBuild
	ENDPROC

	PROCEDURE txtcCustName.Init
		THISFORM.txtcCustid.VALID()
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcCustName.When
		RETURN .F.
	ENDPROC

	PROCEDURE txtDrecdate.Valid
		ldDate = arpmthdr.dRecDate
		
		DODEFAULT()
		
		*  If the value is changed, re-calc the outstanding balances, b/c it may be affecting discounts available.
		*  Don't re-calc anything if it's not a new record.
		IF THIS.VALUE <> ldDate AND THISform.cmdatamanager.isnew('arpmthdr')
		   SELECT arpmtdet
		   DELETE FOR cBatch == arpmthdr.cBatch
		   THISFORM.lNewBuild = .T.
		   THISFORM.requeryrecordsource()
		   THISFORM.calctot()
		ENDIF
		
		
	ENDPROC

	PROCEDURE txtNapplied.When
		RETURN .F.
	ENDPROC

	PROCEDURE txtnBalance.When
		RETURN .F.
	ENDPROC

	PROCEDURE txtNpmtamt.LostFocus
		thisform.applypmts()
		thisform.calcapplied()
		RETURN DODEFAULT()
	ENDPROC

	PROCEDURE txtNunapp.When
		RETURN .F.
	ENDPROC

ENDDEFINE
