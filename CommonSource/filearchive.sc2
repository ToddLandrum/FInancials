*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="filearchive.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
#INCLUDE "..\source\appdefs.h"

DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 418
	Left = 43
	Name = "Dataenvironment"
	Top = 201
	Width = 857

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\indianhillsdata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "invhdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "invhdr", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 580, ;
		Name = "Cursor10", ;
		Top = 21, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "invdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "invdet", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor11", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "arpmtdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "arpmtdet", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 710, ;
		Name = "Cursor12", ;
		Top = 141, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "arpmthdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "arpmthdr", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 711, ;
		Name = "Cursor13", ;
		Top = 260, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "sysctl", ;
		BufferModeOverride = 5, ;
		CursorSource = "sysctl", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 392, ;
		Name = "Cursor14", ;
		Top = 266, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "disbhist", ;
		BufferModeOverride = 5, ;
		CursorSource = "disbhist", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 427, ;
		Name = "Cursor15", ;
		Top = 19, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "wellhist", ;
		BufferModeOverride = 5, ;
		CursorSource = "wellhist", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 146, ;
		Name = "Cursor5", ;
		Top = 139, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "appurchd", ;
		BufferModeOverride = 5, ;
		CursorSource = "appurchd", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 217, ;
		Name = "Cursor6", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "appurchh", ;
		BufferModeOverride = 5, ;
		CursorSource = "appurchh", ;
		Database = ..\..\dmpro_rv\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor7", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formfilearchive AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Lbltextcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swyear1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkOwnerHistory" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkWellHistory" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkInvoices" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkBills" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkGLMaster" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: archive
		*m: backup
		*m: reindex
		*p: oprogress
	*</DefinedPropArrayMethod>

	Caption = "Archive Data"
	DoCreate = .T.
	Height = 342
	HelpContextID = 478
	lcloseonescape = .T.
	lnonewask = .T.
	Name = "Formfilearchive"
	Visible = .T.
	Width = 418
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 1
	cmlookupmanager.Name = "cmlookupmanager"
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'chkBills' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Payable Bills", ;
		Height = 17, ;
		Left = 260, ;
		Name = "chkBills", ;
		TabIndex = 8, ;
		Top = 200, ;
		Value = .T., ;
		Width = 89
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkGLMaster' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "G/L Master", ;
		Height = 17, ;
		Left = 168, ;
		Name = "chkGLMaster", ;
		TabIndex = 9, ;
		Top = 228, ;
		Value = .T., ;
		Width = 77
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkInvoices' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Receivable Invoices", ;
		Height = 17, ;
		Left = 48, ;
		Name = "chkInvoices", ;
		TabIndex = 7, ;
		Top = 200, ;
		Value = .T., ;
		Width = 127
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkOwnerHistory' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Owner History", ;
		Height = 17, ;
		Left = 48, ;
		Name = "chkOwnerHistory", ;
		TabIndex = 5, ;
		Top = 168, ;
		Value = .T., ;
		Width = 95
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkWellHistory' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Well History", ;
		Height = 17, ;
		Left = 260, ;
		Name = "chkWellHistory", ;
		TabIndex = 6, ;
		Top = 168, ;
		Value = .T., ;
		Width = 83
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdClose' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Archive", ;
		FontSize = 8, ;
		Height = 33, ;
		Left = 120, ;
		Name = "cmdClose", ;
		TabIndex = 10, ;
		Top = 289, ;
		Width = 80
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Exit", ;
		Default = .T., ;
		FontSize = 8, ;
		Height = 33, ;
		Left = 212, ;
		Name = "cmdExit", ;
		TabIndex = 11, ;
		Top = 289, ;
		Width = 80
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 216, ;
		Name = "Glmaint", ;
		Top = 0
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbltextcustom1' AS lbltextcustom WITH ;
		Caption = "Archive Calendar Year:", ;
		FontSize = 8, ;
		Left = 126, ;
		Name = "Lbltextcustom1", ;
		TabIndex = 3, ;
		Top = 100
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom2' AS lbltextcustom WITH ;
		AutoSize = .F., ;
		Caption = "Archiving removes detailed information from the data, leaving only summarized information behind.  Once archived, detailed information CANNOT be retrieved for the chosen calendar year.", ;
		FontSize = 10, ;
		Height = 72, ;
		Left = 19, ;
		Name = "Lbltextcustom2", ;
		TabIndex = 4, ;
		Top = 24, ;
		Width = 375, ;
		WordWrap = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Shape1' AS shape WITH ;
		Height = 120, ;
		Left = 24, ;
		Name = "Shape1", ;
		Top = 144, ;
		Width = 372
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'Swyear1' AS swyear WITH ;
		Left = 249, ;
		Name = "Swyear1", ;
		TabIndex = 2, ;
		Top = 98
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE archive
		LOCAL lcbatch, lcidglma, lcidwhst, lciddisb, lcYear
		LOCAL ldisbman, llReturn, llok, lnMax, loError
		*:Global cbatch, cdesc, cgroup, ciddisb, cidglma, cidsysctl, cidwhst, cref, crunyear, ctypeclose
		*:Global cyear, dAcctdate, dpostdate, nrunno, oProgress
		
		llReturn = .T.
		
		TRY
		    lcYear = ALLTRIM(THISFORM.Swyear1.VALUE)
		
		    SET SAFETY OFF
		
		    swclose('gltemp')
		    swclose('gltemp1')
		    swclose('gltemp2')
		    swclose('whisttemp')
		    swclose('whisttemp1')
		    swclose('ownhisttemp')
		    swclose('ownhisttemp1')
		    swclose('aptemp')
		    swclose('aptemp1')
		    swclose('aptemp2')
		    swclose('aptemp3')
		    swclose('artemp')
		    swclose('artemp1')
		    swclose('artemp2')
		    swclose('artemp3')
		    swclose('artemp4')
		
		    IF NOT m.goapp.lQBVersion
		        SWSELECT('appmtdet', TABLEBUFFER)
		    ENDIF
		
		    SWSELECT('glmaster', TABLEBUFFER)
		    SWSELECT('wellhist', TABLEBUFFER)
		    SWSELECT('disbhist', TABLEBUFFER)
		    SWSELECT('appurchh', TABLEBUFFER)
		    SWSELECT('appurchd', TABLEBUFFER)
		    SWSELECT('invhdr', TABLEBUFFER)
		    SWSELECT('invdet', TABLEBUFFER)
		    SWSELECT('arpmthdr', TABLEBUFFER)
		    SWSELECT('arpmtdet', TABLEBUFFER)
		    SWSELECT('sysctl', TABLEBUFFER)
		    SWSELECT('ownhistold', TABLEBUFFER)
		    SWSELECT('ownpctsold', TABLEBUFFER)
		
		    SET DELETED ON
		
		    oProgress = THISFORM.omessage.progressbarex('Archiving Data for Year: ' + lcYear)
		
		    lnMax = 0
		
		    IF THISFORM.chkBills.VALUE
		        lnMax = lnMax + 4
		    ENDIF
		    IF THISFORM.chkInvoices.VALUE
		        lnMax = lnMax + 4
		    ENDIF
		    IF THISFORM.chkGLMaster.VALUE
		        lnMax = lnMax + 1
		    ENDIF
		    IF THISFORM.chkownerHistory.VALUE
		        lnMax = lnMax + 1
		    ENDIF
		    IF THISFORM.chkwellHistory.VALUE
		        lnMax = lnMax + 1
		    ENDIF
		
		    oProgress.setprogressrange(0, lnMax)
		
		**************************************************
		*  Archive the GLMASTER file
		**************************************************
		    IF m.goapp.lAMVersion AND THISFORM.chkGLMaster.VALUE
		        oProgress.setprogressmessage('Processing GL Master File')
		        oProgress.updateprogress(1)
		
		        SELECT *, .F. AS junk FROM glmaster WHERE ALLTRIM(STR(YEAR(ddate))) = lcYear INTO CURSOR gltemp
		
		        SELECT gltemp  &&  Warn if the archived file already exists, and don't let them do it again
		        IF NOT DIRECTORY(ALLTRIM(m.goapp.cdatafilepath) + 'archive')
		            MD ALLTRIM(m.goapp.cdatafilepath) + 'archive'
		        ENDIF
		        COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCGLMASTER' + lcYear
		
		
				SELECT  cacctno,  ;  &&  Create summary by acctno, by source, for each period
						cyear,  ;
						cperiod,  ;
						{} AS ddate,  ;
						csource,  ;
						SUM(ndebits) AS ndebits,  ;
						SUM(ncredits) AS ncredits,  ;
						SUM(ndebits - ncredits) AS namount  ;
					FROM glmaster  ;
					INTO CURSOR gltemp1  ;
					WHERE ALLTRIM(STR(YEAR(ddate))) = lcYear ;
					GROUP BY cacctno, cyear, cperiod, csource  ;
					ORDER BY cacctno
		
		        SELECT gltemp1
		        USE DBF('gltemp1') AGAIN IN 0 ALIAS gltemp2
		
		        SELECT gltemp2  &&  Scan and plug in the date for the entry as the last-used date for that account
		        SCAN
		            SWSELECT('glmaster')
		            SET ORDER TO gldate DESC
		            LOCATE FOR cyear + cperiod = gltemp2.cyear + gltemp2.cperiod AND cacctno = gltemp2.cacctno AND csource = gltemp2.csource
		            IF FOUND()
		                REPLACE gltemp2.ddate WITH glmaster.ddate
		            ELSE
		                WAIT WINDOW 'Bad scan problem'  &&  Should never get here
		            ENDIF
		        ENDSCAN
		
		        SELECT gltemp2  &&  Insert summary records into glmaster
		        SCAN
		            SCATTER MEMVAR
		
		            lcbatch = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')  &&  Get next available batch
		            SWSELECT('glmaster')
		            SET DELE OFF
		            SET ORDER TO glbatch
		            DO WHILE INDEXSEEK(lcbatch)
		                lcbatch = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		            ENDDO
		
		            lcidglma = THISFORM.oregistry.incrementcounter('%Shared.Counters.GLMASTER')  &&  Get next available glmaster primary key
		            SWSELECT('glmaster')
		            SET ORDER TO cidglma
		            DO WHILE INDEXSEEK(lcidglma)
		                lcidglma = THISFORM.oregistry.incrementcounter('%Shared.Counters.GLMASTER')
		            ENDDO
		            SET DELE ON
		            m.cidglma = lcidglma
		            m.cbatch  = lcbatch
		            m.cref    = 'Archived Data Totals'
		            m.cdesc   = 'Archived Data Totals for ' + lcYear
		            INSERT INTO glmaster FROM MEMVAR
		        ENDSCAN
		
		        SWSELECT('glmaster')  &&  Delete everything for that year, except the summary records we just added
		        DELETE FROM glmaster WHERE  ALLTRIM(STR(YEAR(ddate))) = lcYear AND NOT 'ARCHIVED DATA' $ UPPER(cdesc)
		    ENDIF
		
		**************************************************
		*  Archive the WELLHIST file
		**************************************************
		    IF THISFORM.chkwellHistory.VALUE
		        oProgress.setprogressmessage('Processing Well History File')
		        oProgress.updateprogress(2)
		
		        SELECT *, .F. AS junk FROM wellhist INTO CURSOR whisttemp WHERE ALLTRIM(STR(YEAR(hdate))) = lcYear
		
		        SELECT whisttemp  &&  Warn if the archived file already exists, and don't let them do it again
		        IF NOT DIRECTORY(ALLTRIM(m.goapp.cdatafilepath) + 'archive')
		            MD ALLTRIM(m.goapp.cdatafilepath) + 'archive'
		        ENDIF
		        COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCWELLHIST' + lcYear
		
		
				SELECT  cwellid,  ;  &&  Build summary info
						crectype,  ;
						lcYear AS hyear,  ;
						'12' AS hperiod,  ;
						999 AS nrunno,  ;
						crunyear,  ;
						CTOD('12/31/' + lcYear) AS hdate,  ;
						SUM(ngasinc) AS ngasinc,  ;
						SUM(ngrossgas) AS ngrossgas,  ;
						SUM(noilinc) AS noilinc,  ;
						SUM(ngrossoil) AS ngrossoil,  ;
						SUM(nothinc) AS nothinc,  ;
						SUM(ntrpinc) AS ntrpinc,  ;
						SUM(nmiscinc1) AS nmiscinc1,  ;
						SUM(nmiscinc2) AS nmiscinc2,  ;
						SUM(ntotale) AS ntotale,  ;
						SUM(nexpcl1) AS nexpcl1,  ;
						SUM(nexpcl2) AS nexpcl2,  ;
						SUM(nexpcl3) AS nexpcl3,  ;
						SUM(nexpcl4) AS nexpcl4,  ;
						SUM(nexpcl5) AS nexpcl5,  ;
						SUM(nexpcla) AS nexpcla,  ;
						SUM(nexpclb) AS nexpclb,  ;
						SUM(ntotmcf) AS ntotmcf,  ;
						SUM(ntotbbl) AS ntotbbl,  ;
						SUM(ntotprod) AS ntotprod,  ;
						SUM(ntotsalt) AS ntotsalt,  ;
						cgroup,  ;
						SUM(ngrossmcf) AS ngrossmcf,  ;
						SUM(ngrossbbl) AS ngrossbbl,  ;
						SUM(ndayson) AS ndayson,  ;
						SUM(nflatgas) AS nflatgas,  ;
						SUM(nflatoil) AS nflatoil,  ;
						SUM(ngather) AS ngather,  ;
						SUM(ncompress) AS ncompress,  ;
						SUM(ntotmcftxr) AS ntotmcftxr,  ;
						SUM(ntotmcftxw) AS ntotmcftxw,  ;
						SUM(ntotbbltxr) AS ntotbbltxr,  ;
						SUM(ntotbbltxw) AS ntotbbltxw,  ;
						SUM(ntotbbltx1) AS ntotbbltx1,  ;
						SUM(ntotmcftx1) AS ntotmcftx1,  ;
						SUM(ntotothtx1) AS ntotothtx1,  ;
						SUM(ntotbbltx2) AS ntotbbltx2,  ;
						SUM(ntotmcftx2) AS ntotmcftx2,  ;
						SUM(ntotothtx2) AS ntotothtx2,  ;
						SUM(ntotbbltx3) AS ntotbbltx3,  ;
						SUM(ntotmcftx3) AS ntotmcftx3,  ;
						SUM(ntotothtx3) AS ntotothtx3,  ;
						SUM(ntotbbltx4) AS ntotbbltx4,  ;
						SUM(ntotmcftx4) AS ntotmcftx4,  ;
						SUM(ntotothtx4) AS ntotothtx4,  ;
						SUM(ngbbltax1) AS ngbbltax1,  ;
						SUM(ngmcftax1) AS ngmcftax1,  ;
						SUM(ngothtax1) AS ngothtax1,  ;
						SUM(ngbbltax2) AS ngbbltax2,  ;
						SUM(ngmcftax2) AS ngmcftax2,  ;
						SUM(ngothtax2) AS ngothtax2,  ;
						SUM(ngbbltax3) AS ngbbltax3,  ;
						SUM(ngmcftax3) AS ngmcftax3,  ;
						SUM(ngothtax3) AS ngothtax3,  ;
						SUM(ngbbltax4) AS ngbbltax4,  ;
						SUM(ngmcftax4) AS ngmcftax4,  ;
						SUM(ngothtax4) AS ngothtax4,  ;
						SUM(nnetexp) AS nnetexp  ;
					FROM wellhist  ;
					INTO CURSOR whisttemp1  ;
					WHERE ALLTRIM(STR(YEAR(hdate))) = lcYear  ;
					GROUP BY cwellid, crectype, cgroup
		
		        SWSELECT('wellhist')  &&  Delete archived entries
		        DELETE FROM wellhist WHERE  ALLTRIM(STR(YEAR(hdate))) = lcYear
		
		        SELECT whisttemp1  &&  Insert new summarized entries
		        SCAN
		            SCATTER MEMVAR
		            lcidwhst = THISFORM.oregistry.incrementcounter('%Shared.Counters.Well History')  &&  Get next available wellhist primary key
		            SELECT wellhist
		            SET DELE OFF
		            SET ORDER TO cidwhst
		            DO WHILE INDEXSEEK(lcidwhst)
		                lcidwhst = THISFORM.oregistry.incrementcounter('%Shared.Counters.Well History')
		            ENDDO
		            SET DELE ON
		
		            m.cidwhst = 'A' + SUBSTR(lcidwhst, 2)  &&  Since there's no notes or description field, the only way to tell these are archived is to mark the PK somehow.
		
		            INSERT INTO wellhist FROM MEMVAR
		        ENDSCAN
		    ENDIF
		
		**************************************************
		*  Archive the DISBHIST file
		**************************************************
		    IF THISFORM.chkownerHistory.VALUE
		        oProgress.setprogressmessage('Processing Owner History File')
		        oProgress.updateprogress(3)
		
		        SELECT * FROM disbhist WITH (BUFFERING = .F.) WHERE ALLTRIM(STR(YEAR(hdate))) = lcYear INTO CURSOR ownhisttemp
		        SELECT * FROM ownpcts WITH (BUFFERING = .F.)  WHERE ciddisb IN (SELECT ciddisb FROM ownhisttemp) INTO CURSOR ownpctstemp
		
		        SELECT ownhistold
		        APPEND FROM DBF('ownhisttemp')
		        SELECT ownpctsold
		        APPEND FROM DBF('ownpctstemp')
		
		        IF NOT DIRECTORY(ALLTRIM(m.goapp.cdatafilepath) + 'archive')
		            MD ALLTRIM(m.goapp.cdatafilepath) + 'archive'
		        ENDIF
		        COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCDISBHIST' + lcYear
		
				SELECT  cownerid,  ;  &&  Build summary info
						cwellid,  ;
						lcYear AS hyear,  ;
						'12' AS hperiod,  ;
						999 AS nrunno,  ;
						IIF(NOT EMPTY(crunyear), crunyear, lcYear) AS crunyear,  ;
						CTOD('12/31/' + lcYear) AS hdate,  ;
						ctypeinv,  ;
						ctypeint,  ;
						cgroup,  ;
						cdirect,  ;
						SUM(nincome) AS nincome,  ;
						SUM(nexpense) AS nexpense,  ;
						SUM(nsevtaxes) AS nsevtaxes,  ;
						SUM(nnetcheck) AS nnetcheck,  ;
						SUM(ntotale1) AS ntotale1,  ;
						SUM(ntotale2) AS ntotale2,  ;
						SUM(ntotale3) AS ntotale3,  ;
						SUM(ntotale4) AS ntotale4,  ;
						SUM(ntotale5) AS ntotale5,  ;
						SUM(ntotalea) AS ntotalea,  ;
						SUM(ntotaleb) AS ntotaleb,  ;
						SUM(nflatrate) AS nflatrate,  ;
						SUM(noilrev) AS noilrev,  ;
						SUM(ngasrev) AS ngasrev,  ;
						SUM(nothrev) AS nothrev,  ;
						SUM(ntrprev) AS ntrprev,  ;
						lprogram,  ;
						cprogcode,  ;
						lprognet,  ;
						SUM(nmiscrev1) AS nmiscrev1,  ;
						SUM(nmiscrev2) AS nmiscrev2,  ;
						ljib,  ;
						SUM(ngather) AS ngather,  ;
						SUM(ncompress) AS ncompress,  ;
						lsevpurch,  ;
						crectype,  ;
						cacctyr,  ;
						cacctprd,  ;
						lflat,  ;
						nflatfreq,  ;
						cflatstart,  ;
						SUM(noiltax1) AS noiltax1,  ;
						SUM(ngastax1) AS ngastax1,  ;
						SUM(nothtax1) AS nothtax1,  ;
						SUM(noiltax2) AS noiltax2,  ;
						SUM(ngastax2) AS ngastax2,  ;
						SUM(nothtax2) AS nothtax2,  ;
						SUM(noiltax3) AS noiltax3,  ;
						SUM(ngastax3) AS ngastax3,  ;
						SUM(nothtax3) AS nothtax3,  ;
						SUM(noiltax4) AS noiltax4,  ;
						SUM(ngastax4) AS ngastax4,  ;
						SUM(nothtax4) AS nothtax4,  ;
						SUM(ntaxwith) AS ntaxwith,  ;
						SUM(nbackwith) AS nbackwith  ;
					FROM disbhist  ;
					INTO CURSOR ownhisttemp1  ;
					WHERE ALLTRIM(STR(YEAR(hdate))) = lcYear  ;
					GROUP BY cownerid, cwellid, crunyear, ctypeinv, crectype
		
		        SWSELECT('disbhist')  &&  Delete entries that have been archived
		        DELETE FROM disbhist WHERE ALLTRIM(STR(YEAR(hdate))) = lcYear
		
		        SELECT ownhisttemp1
		        SCAN
		            SCATTER MEMVAR
		            lciddisb = THISFORM.oregistry.incrementcounter('%Shared.Counters.Owner History')  &&  Get next available disbhist primary key
		            SELECT disbhist
		            SET DELE OFF
		            SET ORDER TO ciddisb
		            DO WHILE INDEXSEEK(lciddisb)
		                lciddisb = THISFORM.oregistry.incrementcounter('%Shared.Counters.Owner History')
		            ENDDO
		            SET DELE ON
		
		            m.ciddisb = 'A' + SUBSTR(lciddisb, 2)  &&  Since there's no notes or description field, the only way to tell these are archived is to mark the PK somehow.
		
		            INSERT INTO disbhist FROM MEMVAR
		        ENDSCAN
		    ENDIF
		
		**************************************************
		*  Archive the APPURCHH and APPURCHD files
		**************************************************
		    IF THISFORM.chkBills.VALUE
		        IF NOT m.goapp.lQBVersion
		            oProgress.setprogressmessage('Processing Bills File')
		            oProgress.updateprogress(4)
		
		            SELECT *, 0000000.00 AS npmts FROM appurchh WHERE ALLTRIM(STR(YEAR(dinvdate))) = lcYear INTO CURSOR aptemp
		            USE DBF('aptemp') AGAIN IN 0 ALIAS aptemp1
		
		            SELECT aptemp1  &&  Scan all the bills from the year, and add up the payments.  Only archive the bill if it has been completely paid.
		            SCAN
		                SELECT appmtdet
		                SCAN FOR cbilltoken = aptemp1.cbatch
		                    REPLACE aptemp1.npmts WITH aptemp1.npmts + appmtdet.namtpaid
		                ENDSCAN
		            ENDSCAN
		
		            SELECT aptemp1
		            DELETE FOR ninvtot <> npmts  &&  Get rid of the paid bills
		            IF NOT DIRECTORY(ALLTRIM(m.goapp.cdatafilepath) + 'archive')
		                MD ALLTRIM(m.goapp.cdatafilepath) + 'archive'
		            ENDIF
		            COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCAPPURCHH' + lcYear FOR NOT DELETED()  &&  Only copy the zeroed out records
		
		            oProgress.updateprogress(5)
		            SELECT * FROM appurchd INTO CURSOR aptemp2 WHERE cbatch IN(SELECT cbatch FROM aptemp1) &&  Pull all payments that apply to the remaining recs in the aptemp1 cursor
		            SELECT aptemp2
		            COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCAPPURCHD' + lcYear
		
		            SELECT aptemp1  &&  Delete the archived entries from the APPURCHH table.  This will also take care of the detail recs, too.
		            SCAN FOR NOT DELETED()
		                SELECT appurchh
		                SET ORDER TO cbatch
		                IF SEEK(aptemp1.cbatch)
		                    DELETE NEXT 1
		                ENDIF
		            ENDSCAN
		
		**************************************************
		*  Archive the APPMTDET files
		**************************************************
		
		            oProgress.setprogressmessage('Processing Bill Payments File')
		            oProgress.updateprogress(6)
		
		            SELECT * FROM appmtdet INTO CURSOR aptemp3 WHERE cbilltoken IN(SELECT cbatch FROM aptemp1)  &&  Only pull out the payment detail records for the bills that are being archived
		            SELECT aptemp3
		            COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCAPPMTDET' + lcYear
		
		            SELECT aptemp3  &&  Scan and delete the archived recs from the APPMTDET file
		            SCAN
		                SELECT appmtdet
		                SET ORDER TO cidarpmd
		                IF SEEK(aptemp3.cidappmd)
		                    DELETE NEXT 1
		                ELSE
		                    WAIT WIND 'Bad scan error - APPMTDET'  &&  Should never get here
		                ENDIF
		            ENDSCAN
		        ENDIF
		    ENDIF
		
		**************************************************
		*  Archive the INVHDR and INVDET files
		**************************************************
		    IF THISFORM.chkInvoices.VALUE
		        oProgress.setprogressmessage('Processing Invoice File')
		        oProgress.updateprogress(7)
		
		        SELECT *, 0000000.00 AS npmts FROM invhdr WHERE ALLTRIM(STR(YEAR(dinvdate))) = lcYear INTO CURSOR artemp
		        USE DBF('artemp') AGAIN IN 0 ALIAS artemp1
		
		        SELECT artemp1  &&  Scan all the invoices from the year, and add up the payments.  Only archive the invoice if it has been completely paid.
		        SCAN
		            SELECT arpmtdet
		            SCAN FOR cinvtoken = artemp1.cbatch
		                REPLACE artemp1.npmts WITH artemp1.npmts + arpmtdet.namtapp
		            ENDSCAN
		        ENDSCAN
		
		        SELECT artemp1
		        DELETE FOR ninvtot <> npmts  &&  Get rid of the unpaid invoices
		
		        IF NOT DIRECTORY(ALLTRIM(m.goapp.cdatafilepath) + 'archive')
		            MD ALLTRIM(m.goapp.cdatafilepath) + 'archive'
		        ENDIF
		        COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCINVHDR' + lcYear FOR NOT DELETED()  &&  Only copy the zeroed out records
		
		        oProgress.updateprogress(8)
		        SELECT * FROM invdet INTO CURSOR artemp2 WHERE cbatch IN(SELECT cbatch FROM artemp1) &&  Pull all payments that apply to the remaining recs in the artemp1 cursor
		        SELECT artemp2
		        COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCINVDET' + lcYear
		
		        SELECT artemp1  &&  Delete the archived entries from the INVHDR table.  This will also take care of the detail recs, too.
		        SCAN FOR NOT DELETED()
		            SELECT invhdr
		            SET ORDER TO cbatch
		            IF SEEK(artemp1.cbatch)
		                DELETE NEXT 1
		            ENDIF
		        ENDSCAN
		
		
		**************************************************
		*  Archive the ARPMTDET files
		**************************************************
		        oProgress.setprogressmessage('Processing Invoice Payments File')
		        oProgress.updateprogress(9)
		
		        SELECT * FROM arpmtdet INTO CURSOR artemp3 WHERE cinvtoken IN(SELECT cbatch FROM artemp1)  &&  Only pull oWut the payment detail records for the invoices that are being archived
		        SELECT artemp3
		        COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCARPMTDET' + lcYear
		
		        SELECT artemp3  &&  Scan and delete the archived recs from the ARPMTDET file
		        SCAN
		            SELECT arpmtdet
		            SET ORDER TO cidarpmd
		            IF SEEK(artemp3.cidarpmd)
		                DELETE NEXT 1
		            ELSE
		                WAIT WIND 'Bad scan error - ARPMTDET'  &&  Should never get here
		            ENDIF
		        ENDSCAN
		
		**************************************************
		*  Archive the ARPMTHDR files
		**************************************************
		        SET DELETED ON
		        oProgress.updateprogress(10)
		        SELECT * FROM arpmthdr INTO CURSOR artemp4 WHERE cbatch NOT IN(SELECT cbatch FROM arpmtdet)  &&  Only pull out the payment header records for the invoices that are being archived
		        SELECT artemp4
		        COPY TO ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCARPMTHDR' + lcYear
		
		        SELECT artemp4  &&  Scan and delete the archived recs from the ARPMTHDR file
		        SCAN
		            SELECT arpmthdr
		            SET ORDER TO cbatch
		            IF SEEK(artemp4.cbatch)
		                DELETE NEXT 1
		            ELSE
		                WAIT WIND 'Bad scan error - ARPMTHDR'  &&  Should never get here
		            ENDIF
		        ENDSCAN
		    ENDIF
		
		    WAIT CLEAR
		
		**************************************************
		*  Insert sysctl record
		**************************************************
		    oProgress.setprogressmessage('Finishing Up...')
		    oProgress.updateprogress(11)
		
		    m.cidsysctl = THISFORM.oregistry.incrementcounter('%Shared.Counters.sysctl')
		
		    SET DELE OFF
		    SELE sysctl
		    SET ORDER TO cidsysctl
		    DO WHILE INDEXSEEK(m.cidsysctl)
		        m.cidsysctl = THISFORM.oregistry.incrementcounter('%Shared.Counters.sysctl')
		    ENDDO
		    SET DELE ON
		
		    m.nrunno     = 999
		    m.crunyear   = lcYear
		    m.cyear      = lcYear
		    m.dAcctdate  = CTOD('12/31/' + lcYear)
		    m.dpostdate  = m.dAcctdate
		    m.cgroup     = '00'
		    m.ctypeclose = 'R'
		    m.ldisbman   = .T.
		    INSERT INTO sysctl FROM MEMVAR
		    m.cidsysctl  = THISFORM.oregistry.incrementcounter('%Shared.Counters.sysctl')
		    m.ctypeclose = 'J'
		    INSERT INTO sysctl FROM MEMVAR
		
		    llok = .F.
		    BEGIN TRANSACTION
		    IF m.goapp.lAMVersion
		        SELE glmaster
		        llok = TABLEUPDATE(.T.)
		    ELSE
		        llok = .T.
		    ENDIF
		    IF llok
		        SELE wellhist
		        llok = TABLEUPDATE(.T.)
		        IF llok
		            SELE disbhist
		            llok = TABLEUPDATE(.T.)
		            IF llok
		                SELE appurchh
		                llok = TABLEUPDATE(.T.)
		                IF llok
		                    SELE appurchd
		                    llok = TABLEUPDATE(.T.)
		                    IF llok
		                        IF NOT m.goapp.lQBVersion
		                            SELE appmtdet
		                            llok = TABLEUPDATE(.T.)
		                        ENDIF
		                        IF llok
		                            SELE invhdr
		                            llok = TABLEUPDATE(.T.)
		                            IF llok
		                                SELE invdet
		                                llok = TABLEUPDATE(.T.)
		                                IF llok
		                                    SELE arpmtdet
		                                    llok = TABLEUPDATE(.T.)
		                                    IF llok
		                                        SELE arpmthdr
		                                        llok = TABLEUPDATE(.T.)
		                                        IF llok
		                                            SELE sysctl
		                                            llok = TABLEUPDATE(.T.)
		                                        ENDIF
		                                    ENDIF
		                                ENDIF
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		    oProgress.closeprogress()
		    RELEASE oProgress
		    IF llok
		        END TRANSACTION
		        THISFORM.omessage.DISPLAY(lcYear + ' was successfully archived.  Reindexing and packing all files will now take place for full ' ;
		              + 'performance benefits to be seen.')
		        THISFORM.REINDEX()
		        THISFORM.omessage.DISPLAY('Archive of year: ' + lcYear + ' successful.')
		    ELSE
		        ROLLBACK
		        THISFORM.omessage.severe('Unable to Archive Data. All Files have been reset.')
		    ENDIF
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'Archive', loError.LINENO, 'File Archive', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the archive at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE backup
		LOCAL lcDataPath, lcFileName, lcFolderName, lcYear, oRegistry, oProgress
		LOCAL lcBackupPath, lcFolder, lcSavePath, llReturn, lnError, loError
		
		llReturn = .T.
		
		TRY
		   lcYear = ALLTRIM(THISFORM.Swyear1.VALUE)
		
		   IF FILE(ALLTRIM(m.goapp.cdatafilepath) + 'ARCHIVE\ARCGLMASTER' + lcYear + '.dbf')
		      THISFORM.omessage.warning('This year has already been archived.')
		      llReturn =  .F.
		      EXIT 
		   ENDIF
		
		   IF TYPE('m.goApp') = 'O'
		      lcDataPath = ALLT(m.goapp.cdatafilepath)
		      IF NOT ':' $ lcDataPath AND NOT '\\' $ lcDataPath AND LEFT(lcDataPath, 1) <> '\'
		         lcSavePath = ALLT(CURDIR())
		         lcDataPath = SYS(5) + CURDIR() + lcDataPath
		      ENDIF
		      lcBackupPath = lcDataPath
		      lcFolderName = lcDataPath
		      lcDataPath   = '"' + lcDataPath + '*.*' + '"'
		   ELSE
		      lcBackupPath = ALLTRIM(GETDIR())
		      lcDataPath   = lcBackupPath + '*.*'
		   ENDIF
		
		   IF NOT '\' $ lcDataPath
		      lcDataPath = 'Data\*.*'
		   ENDIF
		
		* Create the backup folders if needed
		   IF NOT DIRECTORY(lcBackupPath + 'Backups')
		      MD (lcBackupPath + 'Backups')
		   ENDIF
		   lcBackupPath = lcBackupPath + 'Backups\'
		   lcFolder     = 'Archive'
		   IF NOT DIRECTORY(lcBackupPath + lcFolder)
		      MD (lcBackupPath + lcFolder)
		   ENDIF
		   lcBackupPath = lcBackupPath + lcFolder
		   lcFileName   = 'ARC' + THISFORM.Swyear1.VALUE + '-' + STRTRAN(m.goapp.cCompanyName, ' ', '')
		   lcFileName   = ALLTRIM(SUBSTR(lcFileName, RAT('\', lcFileName) + 1)) + '.zip'
		   lcBackupPath = ADDBS(lcBackupPath)
		
		* Create the backup
		   lnError = swbackup('B', lcFolderName, ALLTRIM(lcFileName), lcBackupPath)
		
		   DO CASE
		      CASE lnError = 0
		         WAIT WIND NOWAIT 'Backup Completed'
		         SET DATASESSION TO &lnSession
		         llReturn = .T.
		      CASE lnError = 4
		         THISFORM.omessage.DISPLAY('Backup Encountered Errors. Unable to create backup file.')
		         llReturn = .F.
		      CASE lnError = 6
		         THISFORM.omessage.DISPLAY('Backup Encountered Errors. Unable to compress file.')
		         llReturn = .F.
		   ENDCASE
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Backup', loError.LINENO, 'Archive Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the archive at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		
		IF txnlevel() > 0
		   ROLLBACK
		ENDIF
		
		DODEFAULT(nerror,cmethod,nline)   
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   _VFP.AutoYield = .F.
		   IF m.goApp.lAMVersion
		      thisform.chkgLMaster.Value = .t.
		   ELSE
		      thisform.chkglMaster.Value = .f.
		      thisform.chkglMaster.Visible = .f.
		      IF m.goapp.lQBVersion
		         thisform.chkbills.Visible = .f.
		      ENDIF 
		   ENDIF 
		ENDIF   
		
	ENDPROC

	PROCEDURE reindex
		LOCAL lcDataBase, llReturn, loError
		llReturn = .T.
		
		TRY
		   lcDataBase = TRIM(m.goApp.cDataFilePath) + 'AppData'
		
		   m.goApp.closealldata()
		   OPEN DATABASE (lcDataBase)
		   m.goApp.opensdt()
		
		   oMeta.SetDatabase(DBC())
		
		   IF THISFORM.chkGLMaster.VALUE
		      oMeta.oSDTMgr.REINDEX('glmaster', .T.)
		   ENDIF
		
		   IF THISFORM.chkwellHistory.VALUE
		      oMeta.oSDTMgr.REINDEX('wellhist', .T.)
		   ENDIF
		
		   IF THISFORM.chkownerHistory.VALUE
		      oMeta.oSDTMgr.REINDEX('disbhist', .T.)
		   ENDIF
		
		   IF THISFORM.chkBills.VALUE
		      oMeta.oSDTMgr.REINDEX('appurchh', .T.)
		      oMeta.oSDTMgr.REINDEX('appurchd', .T.)
		      oMeta.oSDTMgr.REINDEX('appmthdr', .T.)
		      oMeta.oSDTMgr.REINDEX('appmtdet', .T.)
		   ENDIF
		
		   IF THISFORM.chkInvoices.VALUE
		      oMeta.oSDTMgr.REINDEX('invhdr', .T.)
		      oMeta.oSDTMgr.REINDEX('invdet', .T.)
		      oMeta.oSDTMgr.REINDEX('arpmthdr', .T.)
		      oMeta.oSDTMgr.REINDEX('arpmtdet', .T.)
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Re-index', loError.LINENO, 'File Archive', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the archive at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE save
		LPARAMETERS cworkarealist
		
		* Do nothing
	ENDPROC

	PROCEDURE Unload
		_VFP.AutoYield = .T.
		
		DODEFAULT()
	ENDPROC

	PROCEDURE cmdClose.Click
		LOCAL lcYear, llReturn, loError
		llReturn = .T.
		
		TRY
		   lcYear = ALLTRIM(THISFORM.Swyear1.VALUE)
		
		   *  Check to see if the year is already archived
		   swselect('sysctl')
		   LOCATE FOR cYear = lcYear AND nrunno = 999 AND dAcctDate = CTOD('12/31/' + lcYear)
		   IF FOUND()
		      THISFORM.oMessage.Warning('This year has already been archived. It cannot be archived again.')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   *
		   *  Check to see if the year is closed
		   *
		   IF m.goApp.lAMVersion
		      swselect('sysctl')
		      SET ORDER TO yearclose
		      IF NOT SEEK(lcYear + 'Y')
		         THISFORM.oMessage.Warning('Fiscal Year ' + lcYear + ' is not closed. The Fiscal Year MUST be closed before it can be archived.')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   *
		   *  Ask to make sure the user wants to close this fiscal year.
		   *
		   IF NOT THISFORM.oMessage.CONFIRM('Are you sure you want to archive year ' + lcYear + '?')
		      WAIT WIND NOWAIT 'Archive of year ' + lcYear + ' cancelled...'
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   IF THISFORM.backup()
		      THISFORM.Archive()
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Archive_Click', loError.LINENO, 'File Archive', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

ENDDEFINE
