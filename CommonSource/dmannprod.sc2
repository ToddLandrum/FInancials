*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="dmannprod.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 717
	Left = 26
	Name = "Dataenvironment"
	Top = 515
	Width = 767

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "fields", ;
		CursorSource = "fields", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor10", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor11", ;
		Top = 380, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 404, ;
		Name = "Cursor12", ;
		Top = 261, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "suspense", ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor13", ;
		Top = 260, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "ownpcts", ;
		CursorSource = "ownpcts", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 559, ;
		Name = "Cursor14", ;
		Top = 20, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "annprod1", ;
		CursorSource = "annprod", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor15", ;
		Top = 260, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "appurchd", ;
		CursorSource = "appurchd", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 580, ;
		Name = "Cursor16", ;
		Top = 393, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "appurchh", ;
		CursorSource = "appurchh", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 575, ;
		Name = "Cursor17", ;
		Top = 139, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "wellhist", ;
		CursorSource = "wellhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "welldays", ;
		CursorSource = "welldays", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "disbhist", ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "annprod", ;
		BufferModeOverride = 5, ;
		CursorSource = "annprod", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "form6s", ;
		BufferModeOverride = 5, ;
		CursorSource = "form6s", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 396, ;
		Name = "Cursor7", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "revsrc", ;
		CursorSource = "revsrc", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "wellinv", ;
		CursorSource = "wellinv", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 399, ;
		Name = "Cursor9", ;
		Top = 141, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formdmannprod AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Txtdate1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBuildYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBuild" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcOwnerNo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblOwnerNo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkActive" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDate2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblHyphen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAssumeFullYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBuildRange" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkNoProd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCompress" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseProducer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseOverride" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: buildfile
		*m: buildpadata		&& Gets the PA waste and disposal data for a Particular PA well
		*m: build_ny		&& Builds the NY Annual return file
		*m: build_oh		&& Builds the Ohio Form 10 file
		*m: build_pa		&& Builds the PA waste water return
		*m: build_wv		&& Builds WV Annual Return File
		*m: build_wv_owners
		*p: cstate
		*p: ctaxyear
		*a: astates[1,0]		&& Array of available states to report on.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "."
	ctaxyear = 
	DataSession = 2
	DoCreate = .T.
	Height = 434
	HelpContextID = 602
	Name = "FormDmannprod"
	Width = 413
	_memberdata = <VFPData>
		<memberdata name="buildpadata" display="BuildPaData"/>
		<memberdata name="build_wv" display="Build_WV"/>
		<memberdata name="build_pa" display="Build_PA"/>
		<memberdata name="build_oh" display="Build_OH"/>
		<memberdata name="build_ny" display="Build_NY"/>
		<memberdata name="ctaxyear" display="cTaxYear"/>
		<memberdata name="build_wv_owners" display="Build_WV_Owners"/>
		</VFPData>		&& XML Metadata for customizable properties
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"
	Mwresize1.TabIndex = 1

	ADD OBJECT 'chkActive' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Include Only Active Wells", ;
		Left = 62, ;
		Name = "chkActive", ;
		TabIndex = 12, ;
		Top = 196, ;
		Value = .F., ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkAssumeFullYear' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Assume Full Year of Production for Wells Not Started This Year", ;
		Left = 62, ;
		Name = "chkAssumeFullYear", ;
		TabIndex = 14, ;
		Top = 254, ;
		Value = .T., ;
		Visible = .T., ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkCompress' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Exclude Compression/Gathering from Reported Revenue", ;
		Left = 62, ;
		Name = "chkCompress", ;
		TabIndex = 17, ;
		Top = 341, ;
		Value = .F., ;
		Visible = .F., ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkNoProd' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Include Wells With No Production During The Year", ;
		Left = 62, ;
		Name = "chkNoProd", ;
		TabIndex = 13, ;
		Top = 225, ;
		Value = .T., ;
		Visible = .T., ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkUseOverride' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = 'Report Overriding Royalty Under "Override Interest"', ;
		Left = 62, ;
		Name = "chkUseOverride", ;
		TabIndex = 16, ;
		Top = 312, ;
		Value = .F., ;
		Visible = .F., ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkUseProducer' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Report Working Interest Under Producer Name", ;
		Left = 62, ;
		Name = "chkUseProducer", ;
		TabIndex = 15, ;
		Top = 283, ;
		Value = .F., ;
		Visible = .F., ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdBuild' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Build File", ;
		Default = .T., ;
		Height = 36, ;
		Left = 108, ;
		Name = "cmdBuild", ;
		TabIndex = 18, ;
		Top = 384, ;
		Width = 75, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 36, ;
		Left = 216, ;
		Name = "cmdExit", ;
		TabIndex = 19, ;
		Top = 384, ;
		Width = 75, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblBuildRange' AS lbllabelcustom WITH ;
		Caption = "Date Range:", ;
		Height = 16, ;
		Left = 59, ;
		Name = "lblBuildRange", ;
		TabIndex = 9, ;
		Top = 126, ;
		Visible = .F., ;
		Width = 61, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblBuildYear' AS lbllabelcustom WITH ;
		Caption = "Year", ;
		Height = 16, ;
		Left = 59, ;
		Name = "lblBuildYear", ;
		TabIndex = 8, ;
		Top = 99, ;
		Width = 26, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblHyphen' AS lbllabelcustom WITH ;
		Caption = "-", ;
		FontSize = 12, ;
		Left = 225, ;
		Name = "lblHyphen", ;
		TabIndex = 5, ;
		Top = 124, ;
		Visible = .F., ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Base File On:", ;
		Left = 59, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 3, ;
		Top = 22, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblOwnerNo' AS lbltextcustom WITH ;
		Caption = "Owner Number:", ;
		Left = 59, ;
		Name = "lblOwnerNo", ;
		TabIndex = 11, ;
		Top = 154, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'opgYear' AS opgoptiongroupcustom WITH ;
		AutoSize = .T., ;
		BorderStyle = 0, ;
		ButtonCount = 3, ;
		Height = 68, ;
		Left = 131, ;
		Name = "opgYear", ;
		TabIndex = 2, ;
		Top = 17, ;
		Width = 142, ;
		ZOrderSet = 5, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Accounting Year", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Width = 100, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Production Year", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 26, ;
		Option2.Width = 96, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "Accounting Date Range", ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 5, ;
		Option3.Name = "Option3", ;
		Option3.Top = 47, ;
		Option3.Width = 132
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtcOwnerNo' AS txttextboxcustom WITH ;
		ControlSource = "options.ccomprptno", ;
		Height = 20, ;
		Left = 139, ;
		Name = "txtcOwnerNo", ;
		TabIndex = 10, ;
		Top = 152, ;
		Width = 84, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcYear' AS txttextboxcustom WITH ;
		Height = 20, ;
		InputMask = "XXXX", ;
		Left = 139, ;
		MaxLength = 4, ;
		Name = "txtcYear", ;
		TabIndex = 4, ;
		Top = 97, ;
		Width = 39, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'Txtdate1' AS gldate WITH ;
		Height = 20, ;
		InputMask = "99/99/9999", ;
		Left = 139, ;
		Name = "Txtdate1", ;
		SelectOnEntry = .T., ;
		TabIndex = 6, ;
		Top = 124, ;
		Visible = .F., ;
		Width = 81, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtDate2' AS gldate WITH ;
		Height = 20, ;
		InputMask = "99/99/9999", ;
		Left = 236, ;
		Name = "txtDate2", ;
		SelectOnEntry = .T., ;
		TabIndex = 7, ;
		Top = 124, ;
		Visible = .F., ;
		Width = 81, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="textbox" />
	
	PROCEDURE buildfile
		LOCAL lnReportOn, ldDate1, ldDate2, llActive, lnCount, lnRecords, lcState, llCompress, lnMultiplier
		LOCAL lnDays, llLeapYr, cTaxYear, cOwnerNo, llUseProducer_for_Working, lcWorkint, llOverride, lnTally
		LOCAL lcWhereW, llDays, llNoProd, llPACodes, llReturn, lnBBLs, lnGasInt, lnMax, lnOilInt, lnTotGas
		LOCAL lnTotOil, lnX, lnpct, loError, oProgress
		
		llReturn = .T.
		
		TRY
		   STORE .F. TO llUseProducer_for_Working, llOverride
		   STORE ' ' TO lcWorkint
		   lnCount      = 0
		   lnRecords    = 0
		   lcState      = THISFORM.cstate
		   m.cwellstate = lcState
		   m.cYear      = ALLTRIM(THISFORM.txtcYear.VALUE)
		
		   IF THISFORM.opgYear.VALUE = 3  &&  Assign year variable based on year of last date if reporting for an accounting date range.
		      m.cYear = ALLT(STR(YEAR(THISFORM.txtDate2.VALUE)))
		   ENDIF
		
		   m.cTaxYear   = STR(VAL(THISFORM.txtcYear.VALUE) + 2, 4)
		   m.cOwnerNo   = ALLTRIM(THISFORM.txtcOwnerNo.VALUE)
		   llActive     = THISFORM.chkactive.VALUE
		   ldDate1      = THISFORM.txtDate1.VALUE
		   ldDate2      = THISFORM.txtDate2.VALUE
		   lnReportOn   = THISFORM.opgYear.VALUE
		   llNoProd     = THISFORM.chkNoProd.VALUE
		   llCompress   = THISFORM.chkCompress.VALUE
		   lnMultiplier = IIF(llCompress, 1, 0)
		
		   SELECT annprod
		   COUNT FOR cYear = m.cYear AND cwellstate = lcState TO lnCount
		   IF lnCount > 0
		      IF NOT THISFORM.oMessage.CONFIRM('Production data already exists for ' + m.cYear + ' Do you want to overwrite it?')
		         WAIT WIND NOWAIT 'File Create Cancelled.'
		         lReturn = .F.
		         EXIT
		      ELSE
		         DELETE FOR cYear = m.cYear AND cwellstate = lcState
		         IF lcState = 'WV'
		            SELECT form6s
		            DELETE FOR cYear = m.cYear AND cstate = lcState
		         ENDIF
		      ENDIF
		   ENDIF
		
		   &&  Updates the royalty oil and gas percentages in the well record based on the current DOI - Needs run to clean up wells set not to calculate NRI  - BH 7/26/2005
		
		   swclose('revwrk')
		   swselect('wells')
		   swselect('wellinv')
		
		   SELECT  cwellid, SUM(nrevgas) AS lnGasPct, SUM(nrevoil) AS lnOilPct ;
		      FROM wellinv ;
		      INTO CURSOR revwrk ;
		      WHERE INLIST(ctypeinv, 'L', 'O') ;
		      AND NOT DELETED()  ;
		      GROUP BY cwellid
		
		   *  Update landowner and override pcts in the well record
		   SELECT revwrk
		   SCAN
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(revwrk.cwellid)
		         IF nOilInt <> revwrk.lnOilPct
		            REPL nOilInt WITH revwrk.lnOilPct
		         ENDIF
		         IF nGasInt <> revwrk.lnGasPct
		            REPL nGasInt WITH revwrk.lnGasPct
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   CREATE CURSOR temp ;
		      (cidannp        C(8), ;
		      cwellid        C(10), ;
		      cwellname      C(30), ;
		      cYear          C(4), ;
		      cTaxYear       C(4), ;
		      crptgroup      C(1), ;
		      ctaxid         C(20), ;
		      cwellstatus    C(1),  ;
		      nwellcount     N(5), ;
		      cpermit        C(20), ;
		      ccounty        C(25), ;
		      ctownship      C(25), ;
		      cparcel        C(30), ;
		      csection       C(10), ;
		      clot           C(30), ;
		      nacres         N(12, 2), ;
		      noilbbl        N(12, 2), ;
		      ngasmcf        N(12, 2), ;
		      nmonths        N(2), ;
		      ndayson        N(3), ;
		      dProdDate      d,  ;
		      nsaltbbl       N(7), ;
		      cOwnerNo       C(10), ;
		      crevbbl        C(8), ;
		      cbblpurch      C(30), ;
		      crevmcf        C(8), ;
		      cmcfpurch      C(30), ;
		      cproducer      C(40), ;
		      cagent         C(40), ;
		      caddress       C(40), ;
		      ccity          C(25), ;
		      cwellstate     C(2), ;
		      cstate         C(2), ;
		      czip           C(10), ;
		      ccontact       C(40), ;
		      cfield         C(30), ;
		      cformation     C(30), ;
		      cmeterid       C(4),  ;
		      ctelephone     C(15), ;
		      cnra           C(20), ;
		      cfacility      C(10), ;
		      cfacpermit     C(10), ;
		      cwastecode     C(5), ;
		      cdispcode      C(4), ;
		      nworkoil       N(12, 2), ;
		      nworkgas       N(12, 2), ;
		      noilinc        N(12, 2), ;
		      ngasinc        N(12, 2), ;
		      nflatgas       N(12, 2), ;
		      nflatoil       N(12, 2), ;
		      nworkint       N(12, 2), ;
		      lhousegas      L, ;
		      cqtrtwp        C(10), ;
		      cprodyr        C(4))
		
		   SET DELETED ON
		
		   DO CASE
		      CASE lnReportOn = 1  &&  Accounting Year
		         lcWhereW  = "YEAR(wellhist.hdate) = VAL(m.cYear)"
		      CASE lnReportOn = 2  &&  Production Year
		         lcWhereW = "wellhist.hyear  = m.cYear"
		      CASE lnReportOn = 3  &&  Accounting Date Range
		         lcWhereW = "BETWEEN(wellhist.hdate, ldDate1, ldDate2)"
		   ENDCASE
		
		   IF llLeapYr
		      IF THISFORM.chkAssumeFullYear.VALUE
		         lnDays = 366
		         llDays = .T.
		      ELSE
		         lnDays = 366
		         llDays = .F.
		      ENDIF
		   ELSE
		      IF THISFORM.chkAssumeFullYear.VALUE
		         lnDays = 365
		         llDays = .T.
		      ELSE
		         lnDays = 365
		         llDays = .F.
		      ENDIF
		   ENDIF
		
		   DO CASE
		      CASE INLIST(lcState, 'OH', 'PA', 'NY')  &&  Pretty much everyone else besides WV
		         * Determine if the year is a leap year
		         llLeapYr = swLeapYear(m.cYear)
		
		         SELECT  wellhist.cwellid, ;
		            wells.cwellname, ;
		            m.cYear AS cYear, ;
		            wells.cpermit1, ;
		            wells.cpermit2, ;
		            wells.cpermit3, ;
		            wells.cpermit4, ;
		            wells.cpermit5, ;
		            wells.cpermit6, ;
		            wells.ccounty, ;
		            wells.cuser1 AS tankno, ;
		            wells.cuser2 AS tankcap, ;
		            wells.ctownship, ;
		            wells.cparcel, ;
		            wells.csection, ;
		            wells.ctnr AS cqtrtwp, ;
		            wells.clot AS clot, ;
		            IIF(EMPTY(wells.cnra), '@' + wells.cwellid + SPACE(10), wells.cnra) AS cnra, ;  &&  Pick up the well ID with @ before it if blank, to make it unique - report will filter this out with a print when - BH 07/28/2008
		            wells.nOilInt, ;
		            wells.nGasInt, ;
		            wells.dProdDate, ;
		            wells.lhousegas, ;
		            LEFT(wells.mwellnote, 20) AS NOTE, ;
		            m.cOwnerNo AS cOwnerNo, ;
		            wells.nacres,  ;
		            wells.cfieldid AS cfield, ;
		            wells.cformation, ;
		            0 AS nmonths, ;
		            wells.crevbbl, ;
		            wells.crevmcf, ;
		            wells.cwellstat AS cwellstatus, ;
		            wells.nwellcount, ;
		            wells.cstate AS cwellstate, ;
		            SUM(wellhist.nwrkint) AS nworkint, ;
		            SUM(wellhist.ndayson) AS ndayson, ;
		            SUM(wellhist.ntotbbl) AS noilbbl, ;
		            SUM(wellhist.ntotmcf) AS ngasmcf, ;
		            SUM(wellhist.ntotsalt) AS nsaltbbl, ;
		            SUM(wellhist.ngrossgas) AS ngasinc, ;
		            SUM(wellhist.ngrossoil) AS noilinc, ;
		            SUM(wellhist.nflatgas) AS nflatgas, ;
		            SUM(wellhist.nflatoil) AS nflatoil, ;
		            000000000.00 AS nworkoil, ;
		            000000000.00 AS nworkgas, ;
		            wells.cmeterid ;
		            FROM wellhist, wells ;
		            WHERE wellhist.cwellid = wells.cwellid ;
		            AND &lcWhereW ;
		            AND wells.cstate     = lcState ;
		            AND wells.lthird_prty <> .T. ;
		            AND IIF(llActive, wells.cwellstat = 'A', .T.) ;
		            INTO CURSOR wellann1 ;
		            ORDER BY wells.cwellid ;
		            GROUP BY wells.cwellid
		
		         SELECT  wells.cwellid, ;
		            wells.cwellname, ;
		            m.cYear AS cYear, ;
		            wells.cpermit1, ;
		            wells.cpermit2, ;
		            wells.cpermit3, ;
		            wells.cpermit4, ;
		            wells.cpermit5, ;
		            wells.cpermit6, ;
		            wells.cuser1 AS tankno, ;
		            wells.cuser2 AS tankcap, ;
		            wells.ccounty, ;
		            wells.ctownship, ;
		            wells.cparcel AS cparcel, ;
		            wells.csection, ;
		            wells.ctnr AS cqtrtwp, ;
		            wells.clot AS clot, ;
		            IIF(EMPTY(wells.cnra), '@' + wells.cwellid + SPACE(10), wells.cnra) AS cnra, ;  &&  Pick up the well ID with @ before it if blank, to make it unique - report will filter this out with a print when - BH 07/28/2008
		         wells.nOilInt, ;
		            wells.nGasInt, ;
		            wells.dProdDate, ;
		            LEFT(wells.mwellnote, 20) AS NOTE, ;
		            m.cOwnerNo AS cOwnerNo, ;
		            wells.nacres,  ;
		            wells.cfieldid AS cfield, ;
		            wells.cformation, ;
		            0 AS nmonths, ;
		            000000000.00 AS noilinc, ;
		            000000000.00 AS ngasinc, ;
		            000000000.00 AS nworkoil, ;
		            000000000.00 AS nworkgas, ;
		            000000000.00 AS nflatgas, ;
		            000000000.00 AS nflatoil, ;
		            wells.crevbbl, ;
		            wells.crevmcf, ;
		            wells.cwellstat AS cwellstatus, ;
		            wells.nwellcount, ;
		            wells.cstate AS cwellstate, ;
		            wells.lhousegas, ;
		            0 AS ndayson, ;
		            0 AS noilbbl, ;
		            0 AS ngasmcf, ;
		            0 AS nsaltbbl, ;
		            wells.cmeterid ;
		            FROM wells ;
		            WHERE wells.cstate   = lcState ;
		            AND wells.cwellid NOT IN (SELECT  cwellid ;
		            FROM wellhist ;
		            WHERE &lcWhereW) ;
		            AND wells.lthird_prty <> .T. ;
		            AND IIF(llActive, wells.cwellstat = 'A', .T.) ;
		            AND NOT DELETED() ;
		            INTO CURSOR wellann2 ;
		            ORDER BY wells.cwellid ;
		            GROUP BY wells.cwellid
		
		
		      CASE lcState = 'WV'
		         THISFORM.Build_WV()
		   ENDCASE
		
		   * Check on the existence of the application object
		   * if it doesn't exist, we're running in development
		   * mode and need to initialize the company address info.
		   IF TYPE('m.goApp') = 'O'
		      m.cproducer  = m.goapp.ccompanyname
		      m.cagent     = m.goapp.cAgentname
		      m.caddress   = m.goapp.cAddress1
		      m.ctaxid     = m.goapp.ctaxid
		      m.ccity      = m.goapp.ccity
		      m.cstate     = m.goapp.cstate
		      m.czip       = m.goapp.czip
		      m.ccontact   = m.goapp.ccontact
		      m.ctelephone = m.goapp.cPhoneNo
		   ELSE
		      m.cproducer  = 'SherWare, Inc.'
		      m.cagent     = 'SherWare, Inc.'
		      m.caddress   = 'PO Box 223'
		      m.ctaxid     = '99-9999999'
		      m.ccontact   = 'Phil Sherwood'
		      m.ctelephone = '3302623115'
		      m.ccity      = 'Wooster'
		      m.cstate     = 'OH'
		      m.czip       = '44691'
		   ENDIF
		
		   SELECT wellann1
		   lnMax = RECC()
		   SELECT wellann2
		   lnMax     = lnMax + RECC()
		   lnCount   = 0
		   lnRecords = 0
		
		   oProgress = THISFORM.oMessage.ProgressBar('Building Annual Statement of Production File For ' + m.cYear)
		   oProgress.SetProgressRange(0, lnMax)
		
		
		   SELECT wellann1
		   SCAN
		      SCATTER MEMVAR
		
		      oProgress.UpdateProgress(lnCount)
		      lnCount = lnCount + 1
		      IF m.nwellcount = 0
		         m.nwellcount = 1
		      ENDIF
		      m.cprodyr = TRANSFORM(YEAR(m.dProdDate))
		      IF ALLTRIM(m.cprodyr) = '0'
		         m.cprodyr = ''
		      ENDIF
		      m.crevbbl = crevbbl
		      m.crevmcf = crevmcf
		      IF m.noilbbl + m.ngasmcf > 0
		         IF llDays
		            * We chose to use the full year (365 or 366 days)
		            IF m.cprodyr < m.cYear OR EMPTY(m.dProdDate)
		               * Production started before this year
		               * Use the full year as days on
		               m.ndayson = lnDays
		            ELSE
		               * Calculate the days on by subtracting
		               * the production begin date from the end
		               * of the year
		               m.ndayson = DATE(VAL(m.cYear), 12, 31) - m.dProdDate
		            ENDIF
		         ELSE
		            * We didn't choose to use the full year so use the
		            * actual days on unless the days on is zero
		            IF m.ndayson = 0
		               * Check to see if we started production this
		               * year. If so, calculate the actual days on
		               * from the start of production
		               IF m.cprodyr >= m.cYear AND NOT EMPTY(m.dProdDate)
		                  m.ndayson = DATE(VAL(m.cYear), 12, 31) - m.dProdDate
		               ELSE
		                  * Use the full year
		                  m.ndayson = lnDays
		               ENDIF
		            ENDIF
		         ENDIF
		      ELSE
		         * There was no production during the year
		         m.ndayson = 0
		      ENDIF
		      m.nmonths = m.ndayson / 30
		      SELECT revsrc
		      SET ORDER TO crevkey
		      IF SEEK(m.crevbbl)
		         m.cbblpurch = crevname
		      ELSE
		         m.cbblpurch = ' '
		      ENDIF
		      IF SEEK(m.crevmcf)
		         m.cmcfpurch = crevname
		      ELSE
		         m.cmcfpurch = ' '
		      ENDIF
		      lnOilInt = 100 - m.nOilInt
		      lnGasInt = 100 - m.nGasInt
		      IF m.nwellcount > 1
		         m.noilbbl = m.noilbbl / m.nwellcount
		         m.ngasmcf = m.ngasmcf / m.nwellcount
		         m.noilinc = m.noilinc / m.nwellcount
		         m.ngasinc = m.ngasinc / m.nwellcount
		
		         STORE 0 TO m.nworkoil, m.nworkgas
		         
		         SELECT disbhist.*, sysctl.dacctdate FROM disbhist, sysctl ;
		            WHERE cwellid = m.cwellid AND ctypeinv = 'W' ;
		              AND sysctl.crunyear = disbhist.crunyear AND sysctl.nrunno = disbhist.nrunno ;
		            INTO CURSOR tempworkhist 
		
		         SELECT tempworkhist  &&  Calculate the working interest oil/gas from the amounts actually paid
		         *  Since lnReportOn = 1 or 3, we need to look at every W record for this well, and then
		         *  check to see whether it came from suspense and match that against sysctl.
		         SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W'
		            *  Accounting Year
		            IF lnReportOn = 1
		               *  If it didn't come from suspense and the date falls in the right year, include it
		               IF EMPTY(cRunYear_in) 
		                  IF TRANSFORM(YEAR(tempworkhist.dacctdate)) <> m.cYear
		                     LOOP
		                  ENDIF 
		               ENDIF
		               *  Item has been in suspense, so check to see when it was originally earned using the _in values
		               IF NOT EMPTY(cRunYear_in)
		                  SELECT sysctl
		                  LOCATE FOR nRunNo = tempworkhist.nRunNo_In AND cRunYear = tempworkhist.cRunYear_in AND cTypeclose = tempworkhist.cRecType
		                  IF FOUND()
		                     IF YEAR(sysctl.dAcctDate) <> VAL(m.cYear)
		                        *  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                        LOOP
		                     ENDIF
		                     IF tempworkhist.lManual AND EMPTY(sysctl.cVersion)
		                        *  This is a converted suspense entry, so we don't care about it
		                        LOOP
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            *  Production Year
		            IF lnReportOn = 2
		               *  By production year doesn't care about suspense.  If it matches, it gets included
		               IF tempworkhist.hyear <> m.cYear
		                  LOOP
		               ENDIF
		            ENDIF
		
		            *  Accounting Date Range
		            IF lnReportOn = 3
		               *  If it didn't come from suspense and the date falls in the right range, include it
		               IF EMPTY(cRunYear_in) AND NOT BETWEEN(hdate, ldDate1, ldDate2)
		                  LOOP
		               ENDIF
		               *  Item has been in suspense, so check to see when it was originally earned using the _in values
		               IF NOT EMPTY(cRunYear_in)
		                  SELECT sysctl
		                  LOCATE FOR nRunNo = tempworkhist.nRunNo_In AND cRunYear = tempworkhist.cRunYear_in AND cTypeclose = tempworkhist.cRecType
		                  IF FOUND()
		                     IF YEAR(dAcctDate) <> VAL(m.cYear)
		                        *  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                        LOOP
		                     ENDIF
		                     IF tempworkhist.lManual AND EMPTY(sysctl.cVersion)
		                        *  This is a converted suspense entry, so we don't care about it
		                        LOOP
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            m.nworkoil = m.nworkoil + tempworkhist.nOilRev
		            m.nworkgas = m.nworkgas + tempworkhist.nGasRev - ((tempworkhist.nCompress + tempworkhist.nGather) * lnMultiplier)
		         ENDSCAN
		
		         *  Now on to suspense.  Same basic logic as above.  Check all W records.
		         SELECT suspense
		         SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W'
		
		            IF lnReportOn = 1
		               *  Item has been in suspense, so check to see when it was originally earned using the _in values
		               IF NOT EMPTY(cRunYear_in)
		                  SELECT sysctl
		                  LOCATE FOR nRunNo = suspense.nRunNo_In AND cRunYear = suspense.cRunYear_in AND cTypeclose = suspense.cRecType
		                  IF FOUND()
		                     IF YEAR(dAcctDate) <> VAL(m.cYear)
		                        *  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                        LOOP
		                     ENDIF
		                     IF suspense.lManual AND EMPTY(sysctl.cVersion)
		                        *  This is a converted suspense entry, so we don't care about it
		                        LOOP
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            *  Production Year
		            IF lnReportOn = 2
		               *  By production year doesn't care about suspense dates.  If it matches, it gets included
		               IF suspense.hyear <> m.cYear
		                  LOOP
		               ENDIF
		            ENDIF
		
		            *  Accounting Date Range
		            IF lnReportOn = 3
		               *  Item has been in suspense, so check to see when it was originally earned using the _in values
		               IF NOT EMPTY(cRunYear_in)
		                  SELECT sysctl
		                  LOCATE FOR nRunNo = suspense.nRunNo_In AND cRunYear = suspense.cRunYear_in AND cTypeclose = suspense.cRecType
		                  IF FOUND()
		                     IF NOT BETWEEN(sysctl.dAcctDate, ldDate1, ldDate2)
		                        *  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                        LOOP
		                     ENDIF
		                     IF suspense.lManual AND EMPTY(sysctl.cVersion)
		                        *  This is a converted suspense entry, so we don't care about it
		                        LOOP
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            m.nworkoil = m.nworkoil + suspense.nOilRev
		            m.nworkgas = m.nworkgas + suspense.nGasRev - ((suspense.nCompress + suspense.nGather) * lnMultiplier)
		         ENDSCAN
		
		         m.nsaltbbl   = m.nsaltbbl / m.nwellcount
		         m.nworkgas   = m.nworkgas / m.nwellcount
		         m.nworkoil   = m.nworkoil / m.nwellcount
		         m.cfacility  = m.tankno
		         m.cfacpermit = m.tankcap
		         FOR lnX = 1 TO m.nwellcount
		            DO CASE
		               CASE lnX = 1
		                  m.cpermit  = m.cpermit1
		                  m.cpermit1 = ' '
		               CASE lnX = 2
		                  m.cpermit  = m.cpermit2
		                  m.cpermit2 = ' '
		               CASE lnX = 3
		                  m.cpermit  = m.cpermit3
		                  m.cpermit3 = ' '
		               CASE lnX = 4
		                  m.cpermit  = m.cpermit4
		                  m.cpermit4 = ' '
		               CASE lnX = 5
		                  m.cpermit  = m.cpermit5
		                  m.cpermit5 = ' '
		               CASE lnX = 6
		                  m.cpermit  = m.cpermit6
		                  m.cpermit6 = ' '
		            ENDCASE
		            m.cwellstate = lcState
		            m.crptgroup  = 'A'
		            m.nworkoil   = ROUND(m.nworkoil, 0)
		            m.nworkgas   = ROUND(m.nworkgas, 0)
		            m.noilinc    = ROUND(m.noilinc, 0)
		            m.ngasinc    = ROUND(m.ngasinc, 0)
		
		            m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		            SELECT annprod1
		            SET ORDER TO cidannp
		            SET DELETED OFF
		            DO WHILE SEEK(m.cidannp)
		               m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		            ENDDO
		            SET DELETED ON
		
		            INSERT INTO temp FROM MEMVAR
		         ENDFOR
		      ELSE
		
		         STORE 0 TO m.nworkoil, m.nworkgas
		         
		         SELECT disbhist.*, sysctl.dacctdate FROM disbhist, sysctl ;
		            WHERE cwellid = m.cwellid AND ctypeinv = 'W' ;
		              AND sysctl.crunyear = disbhist.crunyear AND sysctl.nrunno = disbhist.nrunno ;
		            INTO CURSOR tempworkhist 
		
		
		         SELECT tempworkhist  &&  Calculate the working interest oil/gas from the amounts actually paid
		         *  Since lnReportOn = 1 or 3, we need to look at every W record for this well, and then
		         *  check to see whether it came from suspense and match that against sysctl.
		         SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W'
		            *  Accounting Year
		            IF lnReportOn = 1
		               *  If it didn't come from suspense and the date falls in the right year, include it
		               IF EMPTY(cRunYear_in) AND TRANSFORM(YEAR(tempworkhist.dacctdate)) <> m.cYear
		                  LOOP
		               ENDIF
		               *  Item has been in suspense, so check to see when it was originally earned using the _in values
		               IF NOT EMPTY(cRunYear_in)
		                  SELECT sysctl
		                  LOCATE FOR nRunNo = tempworkhist.nRunNo_In AND cRunYear = tempworkhist.cRunYear_in AND cTypeclose = tempworkhist.cRecType
		                  IF FOUND()
		                     IF YEAR(dAcctDate) <> VAL(m.cYear)
		                        *  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                        LOOP
		                     ENDIF
		                     IF tempworkhist.lManual AND EMPTY(sysctl.cVersion)
		                        *  This is a converted suspense entry, so we don't care about it
		                        LOOP
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            *  Production Year
		            IF lnReportOn = 2
		               *  By production year doesn't care about suspense.  If it matches, it gets included
		               IF tempworkhist.hyear <> m.cYear
		                  LOOP
		               ENDIF
		            ENDIF
		
		            *  Accounting Date Range
		            IF lnReportOn = 3
		               *  If it didn't come from suspense and the date falls in the right range, include it
		               IF EMPTY(cRunYear_in) AND NOT BETWEEN(hdate, ldDate1, ldDate2)
		                  LOOP
		               ENDIF
		               *  Item has been in suspense, so check to see when it was originally earned using the _in values
		               IF NOT EMPTY(cRunYear_in)
		                  SELECT sysctl
		                  LOCATE FOR nRunNo = tempworkhist.nRunNo_In AND cRunYear = tempworkhist.cRunYear_in AND cTypeclose = tempworkhist.cRecType
		                  IF FOUND()
		                     IF NOT BETWEEN(sysctl.dAcctDate, ldDate1, ldDate2)
		                        *  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                        LOOP
		                     ENDIF
		                     IF tempworkhist.lManual AND EMPTY(sysctl.cVersion)
		                        *  This is a converted suspense entry, so we don't care about it
		                        LOOP
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            m.nworkoil = m.nworkoil + tempworkhist.nOilRev
		            m.nworkgas = m.nworkgas + tempworkhist.nGasRev - ((tempworkhist.nCompress + tempworkhist.nGather) * lnMultiplier)
		         ENDSCAN
		
		         *  Now on to suspense.  Same basic logic as above.  Check all W records.
		         SELECT suspense
		         SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W'
		
		            IF lnReportOn = 1
		               *  Item has been in suspense, so check to see when it was originally earned using the _in values
		               IF NOT EMPTY(cRunYear_in)
		                  SELECT sysctl
		                  LOCATE FOR nRunNo = suspense.nRunNo_In AND cRunYear = suspense.cRunYear_in AND cTypeclose = suspense.cRecType
		                  IF FOUND()
		                     IF YEAR(dAcctDate) <> VAL(m.cYear)
		                        *  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                        LOOP
		                     ENDIF
		                     IF suspense.lManual AND EMPTY(sysctl.cVersion)
		                        *  This is a converted suspense entry, so we don't care about it
		                        LOOP
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            *  Production Year
		            IF lnReportOn = 2
		               *  By production year doesn't care about suspense dates.  If it matches, it gets included
		               IF suspense.hyear <> m.cYear
		                  LOOP
		               ENDIF
		            ENDIF
		
		            *  Accounting Date Range
		            IF lnReportOn = 3
		               *  Item has been in suspense, so check to see when it was originally earned using the _in values
		               IF NOT EMPTY(cRunYear_in)
		                  SELECT sysctl
		                  LOCATE FOR nRunNo = suspense.nRunNo_In AND cRunYear = suspense.cRunYear_in AND cTypeclose = suspense.cRecType
		                  IF FOUND()
		                     IF NOT BETWEEN(sysctl.dAcctDate, ldDate1, ldDate2)
		                        *  We've found that the run when it went into suspense wasn't originally in this year, so loop
		                        LOOP
		                     ENDIF
		                     IF suspense.lManual AND EMPTY(sysctl.cVersion)
		                        *  This is a converted suspense entry, so we don't care about it
		                        LOOP
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            m.nworkoil = m.nworkoil + suspense.nOilRev
		            m.nworkgas = m.nworkgas + suspense.nGasRev - ((suspense.nCompress + suspense.nGather) * lnMultiplier)
		         ENDSCAN
		
		         *!*  Commented out 9/5/13 by pws
		         *!*       The flat rates seem to already be included in the wellhist ngasrev or noilrev fields
		         *!*       so this was duplicating it.
		         *!*	      m.noilinc    = m.noilinc + m.nflatoil
		         *!*	      m.ngasinc    = m.ngasinc + m.nflatgas
		         m.cpermit    = m.cpermit1
		         m.cfacility  = m.tankno
		         m.cfacpermit = m.tankcap
		         m.crptgroup  = 'A'
		         m.nworkoil   = ROUND(m.nworkoil, 0)
		         m.nworkgas   = ROUND(m.nworkgas, 0)
		         m.noilinc    = ROUND(m.noilinc, 0)
		         m.ngasinc    = ROUND(m.ngasinc, 0)
		
		         m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		         SELECT annprod1
		         SET ORDER TO cidannp
		         SET DELETED OFF
		         DO WHILE SEEK(m.cidannp)
		            m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		         ENDDO
		         SET DELETED ON
		
		         m.cwellstate = lcState
		
		         INSERT INTO temp FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELECT wellann2
		   IF RECC() > 0
		      SCAN
		         SCATTER MEMVAR
		         oProgress.UpdateProgress(lnCount)
		         lnCount = lnCount + 1
		         IF m.nwellcount = 0
		            m.nwellcount = 1
		         ENDIF
		         lnOilInt  = 100 - m.nOilInt
		         lnGasInt  = 100 - m.nGasInt
		         m.cprodyr = STR(YEAR(m.dProdDate), 4)
		         IF ALLTRIM(m.cprodyr) = '0'
		            m.cprodyr = ''
		         ENDIF
		         m.crevbbl = crevbbl
		         m.crevmcf = crevmcf
		         IF m.noilbbl + m.ngasmcf > 0
		            IF llDays
		               m.ndayson = lnDays
		            ELSE
		               IF m.ndayson = 0
		                  m.ndayson = lnDays
		               ENDIF
		            ENDIF
		         ELSE
		            m.ndayson = 0
		         ENDIF
		         m.nmonths = m.ndayson / 30
		         SELECT revsrc
		         SET ORDER TO crevkey
		         IF SEEK(m.crevbbl)
		            m.cbblpurch = crevname
		         ELSE
		            m.cbblpurch = ' '
		         ENDIF
		         IF SEEK(m.crevmcf)
		            m.cmcfpurch = crevname
		         ELSE
		            m.cmcfpurch = ' '
		         ENDIF
		         IF m.nwellcount > 1
		            m.noilinc = m.noilinc / m.nwellcount
		            m.ngasinc = m.ngasinc / m.nwellcount
		            STORE 0 TO m.nworkoil, m.nworkgas
		            SELECT disbhist  &&  Calculate the working interest oil/gas from the amounts actually paid
		            SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W' AND IIF(lnReportOn = 1, ALLT(STR(YEAR(hdate))) = m.cYear, IIF(lnReportOn = 2, hyear = m.cYear, BETWEEN(hdate, ldDate1, ldDate2))) AND NOT lManual
		               m.nworkoil = m.nworkoil + nOilRev
		               m.nworkgas = m.nworkgas + nGasRev - ((disbhist.nCompress + disbhist.nGather) * lnMultiplier)
		            ENDSCAN
		            SELECT suspense  &&  Calculate the working interest oil/gas from the amounts actually paid
		            SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W' AND IIF(lnReportOn = 1, ALLT(STR(YEAR(hdate))) = m.cYear, IIF(lnReportOn = 2, hyear = m.cYear, BETWEEN(hdate, ldDate1, ldDate2))) AND NOT lManual
		               m.nworkoil = m.nworkoil + nOilRev
		               m.nworkgas = m.nworkgas + nGasRev - ((suspense.nCompress + suspense.nGather) * lnMultiplier)
		            ENDSCAN
		
		            m.noilinc    = m.noilinc + m.nflatoil
		            m.ngasinc    = m.ngasinc + m.nflatgas
		            m.cfacility  = m.tankno
		            m.cfacpermit = m.tankcap
		            m.nsaltbbl   = m.nsaltbbl / m.nwellcount
		            m.nworkgas   = m.nworkgas / m.nwellcount
		            m.nworkoil   = m.nworkoil / m.nwellcount
		            FOR lnX = 1 TO m.nwellcount
		               DO CASE
		                  CASE lnX = 1
		                     m.cpermit  = m.cpermit1
		                     m.cpermit1 = ' '
		                  CASE lnX = 2
		                     m.cpermit  = m.cpermit2
		                     m.cpermit2 = ' '
		                  CASE lnX = 3
		                     m.cpermit  = m.cpermit3
		                     m.cpermit3 = ' '
		                  CASE lnX = 4
		                     m.cpermit  = m.cpermit4
		                     m.cpermit4 = ' '
		                  CASE lnX = 5
		                     m.cpermit  = m.cpermit5
		                     m.cpermit5 = ' '
		                  CASE lnX = 6
		                     m.cpermit  = m.cpermit6
		                     m.cpermit6 = ' '
		               ENDCASE
		               m.cwellstate = lcState
		               m.crptgroup  = 'A'
		               m.nworkoil   = ROUND(m.nworkoil, 0)
		               m.nworkgas   = ROUND(m.nworkgas, 0)
		               m.noilinc    = ROUND(m.noilinc, 0)
		               m.ngasinc    = ROUND(m.ngasinc, 0)
		
		               m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		               SELECT annprod1
		               SET ORDER TO cidannp
		               SET DELETED OFF
		               DO WHILE SEEK(m.cidannp)
		                  m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		               ENDDO
		               SET DELETED ON
		
		               INSERT INTO temp FROM MEMVAR
		            ENDFOR
		         ELSE
		            STORE 0 TO m.nworkoil, m.nworkgas
		            SELECT disbhist  &&  Calculate the working interest oil/gas from the amounts actually paid
		            SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W' AND IIF(lnReportOn = 1, ALLT(STR(YEAR(hdate))) = m.cYear, IIF(lnReportOn = 2, hyear = m.cYear, BETWEEN(hdate, ldDate1, ldDate2))) AND NOT lManual
		               m.nworkoil = m.nworkoil + nOilRev
		               m.nworkgas = m.nworkgas + nGasRev - ((disbhist.nCompress + disbhist.nGather) * lnMultiplier)
		            ENDSCAN
		            SELECT suspense  &&  Calculate the working interest oil/gas from the amounts actually paid
		            SCAN FOR cwellid = m.cwellid AND ctypeinv = 'W' AND IIF(lnReportOn = 1, ALLT(STR(YEAR(hdate))) = m.cYear, IIF(lnReportOn = 2, hyear = m.cYear, BETWEEN(hdate, ldDate1, ldDate2))) AND NOT lManual
		               m.nworkoil = m.nworkoil + nOilRev
		               m.nworkgas = m.nworkgas + nGasRev - ((suspense.nCompress + suspense.nGather) * lnMultiplier)
		            ENDSCAN
		
		            m.cpermit    = m.cpermit1
		            m.crptgroup  = 'A'
		            m.cfacility  = m.tankno
		            m.cfacpermit = m.tankcap
		
		            m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		            SELECT annprod1
		            SET ORDER TO cidannp
		            SET DELETED OFF
		            DO WHILE SEEK(m.cidannp)
		               m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		            ENDDO
		            SET DELETED ON
		
		            m.nworkoil   = ROUND(m.nworkoil, 0)
		            m.nworkgas   = ROUND(m.nworkgas, 0)
		            m.cwellstate = lcState
		            INSERT INTO temp FROM MEMVAR
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		   llPACodes = .F.
		
		   IF lcState = 'PA'
		      llPACodes = THIS.BuildPaData(m.cYear, lnReportOn, ldDate1, ldDate2)
		   ENDIF
		
		   SELECT temp
		   SCAN
		      SCATTER MEMVAR
		      lnTotOil = noilbbl
		      lnTotGas = ngasmcf
		      * Fill in wastecode and dispcode
		      IF llPACodes
		
		         SELECT SUM(nbbl) AS ntotbbl FROM tempcodes WHERE cunitno = m.cwellid INTO CURSOR temptot
		         SELECT temptot
		         lnBBLs = ntotbbl
		         IF lnBBLs = 0
		            lnBBLs = 1
		         ENDIF
		         SELECT tempcodes
		         LOCATE FOR cunitno = m.cwellid
		         IF FOUND()
		            SCAN FOR cunitno = m.cwellid
		               m.cfacility  = cfacility
		               m.cwastecode = cwastecode
		               m.cdispcode  = cdispcode
		               m.cfacpermit = cfacpermit
		               m.nsaltbbl   = nbbl
		               IF m.nsaltbbl <> lnBBLs
		                  lnpct = ROUND(m.nsaltbbl / lnBBLs, 2)
		               ELSE
		                  lnpct = 1
		               ENDIF
		               IF lnpct <> 0
		                  m.noilbbl = ROUND(lnTotOil * lnpct, 0)
		                  m.ngasmcf = ROUND(lnTotGas * lnpct, 0)
		               ENDIF
		               m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		               SELECT annprod1
		               SET ORDER TO cidannp
		               SET DELETED OFF
		               DO WHILE SEEK(m.cidannp)
		                  m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		               ENDDO
		               SET DELETED ON
		               IF NOT llNoProd
		                  IF m.noilbbl > 0 OR m.ngasmcf > 0 OR m.nsaltbbl > 0 OR m.noilinc > 0 OR m.ngasinc > 0
		                     INSERT INTO annprod FROM MEMVAR
		                     lnRecords = lnRecords + 1
		                  ENDIF
		               ELSE
		                  INSERT INTO annprod FROM MEMVAR
		                  lnRecords = lnRecords + 1
		               ENDIF
		
		            ENDSCAN
		         ELSE
		            m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		            SELECT annprod1
		            SET ORDER TO cidannp
		            SET DELETED OFF
		            DO WHILE SEEK(m.cidannp)
		               m.cidannp = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AnnProd')
		            ENDDO
		            SET DELETED ON
		            IF NOT llNoProd
		               IF m.noilbbl > 0 OR m.ngasmcf > 0 OR m.nsaltbbl > 0 OR m.noilinc > 0 OR m.ngasinc > 0
		                  INSERT INTO annprod FROM MEMVAR
		                  lnRecords = lnRecords + 1
		               ENDIF
		            ELSE
		               INSERT INTO annprod FROM MEMVAR
		               lnRecords = lnRecords + 1
		            ENDIF
		         ENDIF
		      ELSE
		         IF NOT llNoProd
		            IF m.noilbbl > 0 OR m.ngasmcf > 0 OR m.nsaltbbl > 0 OR m.noilinc > 0 OR m.ngasinc > 0
		               INSERT INTO annprod FROM MEMVAR
		               lnRecords = lnRecords + 1
		            ENDIF
		         ELSE
		            INSERT INTO annprod FROM MEMVAR
		            lnRecords = lnRecords + 1
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   oProgress.CloseProgress()
		
		   * Build the owner file if we're doing the WV annual return
		   IF THISFORM.cstate = 'WV'
		      THISFORM.Build_WV_Owners()
		   ENDIF
		   *
		   *  See how many records were created
		   *
		   lnCount = 0
		   SELECT annprod
		   COUNT FOR cYear = m.cYear AND cstate = lcState TO lnCount
		   SET ORDER TO cwellid
		
		   WAIT WINDOW NOWAIT 'Finishing up calculations...'
		   SELECT annprod
		   TABLEUPDATE(.T.)
		   SELECT form6s
		   TABLEUPDATE(.T., .T.)
		
		   * Zero out the days on unless the well was started during the year.
		   IF lcState = 'WV'
		      swselect('annprod')
		      UPDATE annprod SET ndayson = 0 WHERE cYear = m.cYear AND YEAR(dProdDate) # VAL(m.cyear) 
		   ENDIF
		   
		   WAIT CLEAR 
		
		   IF lnRecords = 0
		      THISFORM.oMessage.DISPLAY('There were no records found for the given range for this state.')
		      llReturn = .F.
		      EXIT
		   ELSE
		      THISFORM.oMessage.DISPLAY('Created ' + ALLTRIM(STR(lnRecords)) + ' Production Records')
		   ENDIF
		
		   swclose('wellann1')
		   swclose('wellann2')
		   swclose('temp')
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildFile', loError.LINENO, 'Annual Prod Rpt', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE buildpadata		&& Gets the PA waste and disposal data for a Particular PA well
		*
		* Gets the waste code and disposal code data for the passed PA well
		*
		LPARAMETERS tcYear, tnYearType, tdDate1, tdDate2
		LOCAL llReturn, loError
		
		#DEFINE DATERANGE 3
		#DEFINE ACCTYEAR  1
		#DEFINE PRODYEAR  2
		
		llReturn = .T.
		
		TRY
		   DO CASE
		      CASE tnYearType = 1 OR tnYearType = 2
		         IF EMPTY(tcYear)
		            llReturn = .F.
		            EXIT
		         ENDIF
		      CASE tnYearType = 3
		         IF EMPTY(tdDate1) OR EMPTY(tdDate2)
		            llReturn = .F.
		            EXIT
		         ENDIF
		   ENDCASE
		
		   swselect('appurchh')
		   swselect('appurchd')
		   swselect('disposal')
		   SET ORDER TO permit
		
		   DO CASE
		      CASE tnYearType = DATERANGE
				 SELECT  appurchd.cunitno, ;
				         wells.cwellname, ;
				         appurchd.cdisperm, ;
				         cwastecode, ;
				         cdispcode, ;
				         SUM(nsaltbbl) AS nbbl, ;
				         SPACE(20) AS cfacility, ;
						 SPACE(10) AS cfacpermit ;
					 FROM appurchd, appurchh, wells ;
					 WHERE appurchd.cbatch == appurchh.cbatch ;
						 AND appurchd.cunitno == wells.cwellid ;
						 AND wells.cstate == 'PA' ;
						 AND BETWEEN(appurchh.dpostdate, tdDate1, tdDate2) ;
					 INTO CURSOR tempcodes READWRITE ;
					 ORDER BY cunitno, cwastecode, appurchd.cdisperm ;
					 GROUP BY cunitno, cwastecode, appurchd.cdisperm
		
		      CASE tnYearType = ACCTYEAR
				 SELECT  appurchd.cunitno, ;
				         wells.cwellname, ;
				         appurchd.cdisperm, ;
				         cwastecode, ;
				         cdispcode, ;
				         SUM(nsaltbbl) AS nbbl, ;
				         SPACE(20) AS cfacility, ;
						 SPACE(10) AS cfacpermit ;
					 FROM appurchd, appurchh, wells ;
					 WHERE appurchd.cbatch == appurchh.cbatch ;
						 AND appurchd.cunitno == wells.cwellid ;
						 AND wells.cstate = 'PA' ;
						 AND YEAR(dpostdate) = VAL(tcYear) ;
					 INTO CURSOR tempcodes READWRITE ;
					 ORDER BY cunitno, cwastecode, appurchd.cdisperm ;
					 GROUP BY cunitno, cwastecode, appurchd.cdisperm
		
		      CASE tnYearType = PRODYEAR
				 SELECT  appurchd.cunitno, ;
				         wells.cwellname, ;
				         appurchd.cdisperm, ;
				         cwastecode, ;
				         cdispcode, ;
				         SUM(nsaltbbl) AS nbbl, ;
				         SPACE(20) AS cfacility, ;
						 SPACE(10) AS cfacpermit ;
					 FROM appurchd, wells ;
					 WHERE appurchd.cprodyear  == tcYear ;
					     AND appurchd.cunitno == wells.cwellid ;
						 AND wells.cstate == 'PA' ;
					 INTO CURSOR tempcodes READWRITE ;
					 ORDER BY cunitno, cwastecode, appurchd.cdisperm ;
					 GROUP BY cunitno, cwastecode, appurchd.cdisperm
		   ENDCASE
		
		   IF _TALLY > 0
		      SELECT * FROM tempcodes INTO CURSOR tempcodes1 
		      SELECT tempcodes
		      SCAN
		         m.cdisperm = cdisperm
		         IF EMPTY(m.cdisperm) AND nbbl = 0
		            SELECT tempcodes1
		            LOCATE FOR cunitno = tempcodes.cunitno AND NOT EMPTY(cdisperm)
		            IF FOUND()
		               SELECT tempcodes
		               DELETE NEXT 1
		               LOOP 
		            ENDIF    
		         ENDIF 
		         SELECT disposal
		         IF SEEK(LEFT(m.cdisperm, 6))
		            m.cfacility  = cdispsite
		            m.cfacpermit = cpermit1
		            SELECT tempcodes
		            REPLACE cfacility WITH m.cfacility, ;
		               cfacpermit WITH m.cfacpermit
		         ENDIF
		      ENDSCAN
		      llReturn = .T.
		   ELSE
		      llReturn = .F.
		   ENDIF
		
		   swclose('tempcodes1')
		   
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildPAData', loError.LINENO, 'Annual Rpt of Prod', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
	ENDPROC

	PROCEDURE build_ny		&& Builds the NY Annual return file
	ENDPROC

	PROCEDURE build_oh		&& Builds the Ohio Form 10 file
	ENDPROC

	PROCEDURE build_pa		&& Builds the PA waste water return
	ENDPROC

	PROCEDURE build_wv		&& Builds WV Annual Return File
		LOCAL lnReportOn, ldDate1, ldDate2, llActive, lnCount, lnRecords, lcState, llCompress, lnMultiplier
		LOCAL llLeapYr, cTaxYear, cOwnerNo, llUseProducer_for_Working, lcWorkint, llOverride, lnTally, oProgress
		LOCAL  llNoProd, llPACodes, lnBBLs, lnGasInt, lnMax, lnOilInt, lnTotGas, lnTotOil, lnX, lnpct
		LOCAL lcWhereW, llReturn, loError
		
		llReturn = .T.
		
		TRY
		   STORE .F. TO llUseProducer_for_Working, llOverride
		   STORE ' ' TO lcWorkint
		   lnCount      = 0
		   lnRecords    = 0
		   lcState      = THISFORM.cstate
		   m.cwellstate = lcState
		   m.cYear      = ALLTRIM(THISFORM.txtcYear.VALUE)
		
		   IF THISFORM.opgYear.VALUE = 3  &&  Assign year variable based on year of last date if reporting for an accounting date range.
		      m.cYear = ALLT(STR(YEAR(THISFORM.txtDate2.VALUE)))
		   ENDIF
		
		   m.cTaxYear   = STR(VAL(THISFORM.txtcYear.VALUE) + 2, 4)
		   m.cOwnerNo   = ALLTRIM(THISFORM.txtcOwnerNo.VALUE)
		   llActive     = THISFORM.chkactive.VALUE
		   ldDate1      = THISFORM.txtDate1.VALUE
		   ldDate2      = THISFORM.txtDate2.VALUE
		   lnReportOn   = THISFORM.opgYear.VALUE
		   llNoProd     = THISFORM.chkNoProd.VALUE
		   llCompress   = THISFORM.chkCompress.VALUE
		   lnMultiplier = IIF(llCompress, 1, 0)
		
		* Check on the existence of the application object
		* if it doesn't exist, we're running in development
		* mode and need to initialize the company address info.
		   IF TYPE('m.goApp') = 'O'
		      m.cproducer  = m.goapp.ccompanyname
		      m.cagent     = m.goapp.cAgentname
		      m.caddress   = m.goapp.cAddress1
		      m.ctaxid     = m.goapp.ctaxid
		      m.ccity      = m.goapp.ccity
		      m.cstate     = m.goapp.cstate
		      m.czip       = m.goapp.czip
		      m.ccontact   = m.goapp.ccontact
		      m.ctelephone = m.goapp.cPhoneNo
		   ELSE
		      m.cproducer  = 'SherWare, Inc.'
		      m.cagent     = 'SherWare, Inc.'
		      m.caddress   = 'PO Box 223'
		      m.ctaxid     = '99-9999999'
		      m.ccontact   = 'Phil Sherwood'
		      m.ctelephone = '3302623115'
		      m.ccity      = 'Wooster'
		      m.cstate     = 'OH'
		      m.czip       = '44691'
		   ENDIF
		
		   SELECT annprod
		   COUNT FOR cYear = m.cYear AND cwellstate = lcState TO lnCount
		   IF lnCount > 0
		      IF NOT THISFORM.oMessage.CONFIRM('Production data already exists for ' + m.cYear + ' Do you want to overwrite it?')
		         WAIT WIND NOWAIT 'File Create Cancelled.'
		         llReturn = .F.
		         EXIT 
		      ELSE
		         DELETE FOR cYear = m.cYear AND cwellstate = lcState
		            SELECT form6s
		            DELETE FOR cYear = m.cYear AND cstate = lcState
		      ENDIF
		   ENDIF
		
		* Determine if the year is a leap year
		   llLeapYr = swLeapYear(m.cYear)
		
		
		   DO CASE
		      CASE lnReportOn = 1  &&  Accounting Year
		         lcWhereW  = "crunyear+PADL(TRANSFORM(nrunno),3,'0') in " + ;
		                     "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE YEAR(dacctdate)=VAL(m.cYear))"
		      CASE lnReportOn = 2  &&  Production Year
		         lcWhereW = "wellhist.hyear  = m.cYear"
		      CASE lnReportOn = 3  &&  Accounting Date Range
		         lcWhereW = "crunyear+PADL(TRANSFORM(nrunno),3,'0') in " + ;
		                     "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE BETWEEN(dacctdate,ldDate1,ldDate2))"
		   ENDCASE
		
		   SET DELETED ON
		   SET TALK ON
		   
		
		   SELECT  wellhist.cwellid, ;
				   wells.cwellname, ;
				   m.cYear AS cYear, ;
				   wells.cpermit1, ;
				   wells.cpermit2, ;
				   wells.cpermit3, ;
				   wells.cpermit4, ;
				   wells.cpermit5, ;
				   wells.cpermit6, ;
				   wells.ccounty, ;
				   wells.ctownship, ;
				   wells.cparcel, ;
				   wells.csection, ;
				   wells.clot AS clot, ;
				   IIF(EMPTY(wells.cnra), '@' + wells.cwellid + SPACE(10), wells.cnra) AS cnra, ;  &&  Pick up the well ID with @ before it if blank, to make it unique - report will filter this out with a print when - BH 07/28/2008
				   wells.cuser1 AS tankno, ;
				   wells.cuser2 AS tankcap, ;
				   wells.nOilInt, ;
				   wells.nGasInt, ;
				   wells.dProdDate, ;
				   PADR(MLINE(wells.mwellnote, 1), 20, ' ') AS NOTE, ;
				   m.cOwnerNo AS cOwnerNo, ;
				   wells.nacres,  ;
				   wells.cfieldid AS cfield, ;
				   wells.cformation, ;
				   0 AS nmonths, ;
				   wells.crevbbl, ;
				   wells.crevmcf, ;
				   wells.cwellstat AS cwellstatus, ;
				   wells.nwellcount, ;
				   wells.cstate AS cwellstate, ;
				   SUM(wellhist.nwrkint) AS nworkint, ;
				   SUM(wellhist.ndayson) AS ndayson, ;
				   SUM(wellhist.ntotbbl) AS noilbbl, ;
				   SUM(wellhist.ntotmcf) AS ngasmcf, ;
				   SUM(wellhist.ntotsalt) AS nsaltbbl, ;
				   SUM(wellhist.ngrossgas - ((wellhist.nCompress + wellhist.nGather) * lnMultiplier)) AS ngasinc, ;  &&  lnMultiplier is either going to be 0 or 1, depending whether comp/gathering is excluded
				   SUM(wellhist.ngrossoil) AS noilinc, ;
				   SUM(wellhist.nflatgas) AS nflatgas, ;
				   SUM(wellhist.nflatoil) AS nflatoil, ;
				   000000000.00 AS nworkoil, ;
				   000000000.00 AS nworkgas, ;
				   wells.cmeterid ;
			   FROM wellhist, wells ;
			   WHERE wellhist.cwellid = wells.cwellid ;
				   AND &lcWhereW ;
				   AND wells.cstate     = lcState ;
				   AND wells.lthird_prty <> .T. ;
				   AND IIF(llActive, wells.cwellstat = 'A', wells.cwellstat # 'S') ; && Don't include sold wells
			   INTO CURSOR wellann1 readwrite  ;
			   ORDER BY wells.cnra, wells.cwellid ;
			   GROUP BY wells.cnra, wells.cwellid
		
		   SELECT  wells.cwellid, ;
				   wells.cwellname, ;
				   m.cYear AS cYear, ;
				   wells.cpermit1, ;
				   wells.cpermit2, ;
				   wells.cpermit3, ;
				   wells.cpermit4, ;
				   wells.cpermit5, ;
				   wells.cpermit6, ;
				   wells.ccounty, ;
				   wells.ctownship, ;
				   wells.cparcel, ;
				   wells.csection, ;
				   wells.clot AS clot, ;
				   IIF(EMPTY(wells.cnra), '@' + wells.cwellid + SPACE(10), wells.cnra) AS cnra, ;  &&  Pick up the well ID with @ before it if blank, to make it unique - report will filter this out with a print when - BH 07/28/2008
				   wells.cuser1 AS tankno, ;
				   wells.cuser2 AS tankcap, ;
				   wells.nOilInt, ;
				   wells.nGasInt, ;
				   wells.dProdDate, ;
				   PADR(MLINE(wells.mwellnote, 1), 20, ' ') AS NOTE, ;
				   m.cOwnerNo AS cOwnerNo, ;
				   wells.nacres,  ;
				   wells.cfieldid AS cfield, ;
				   wells.cformation, ;
				   0 AS nmonths, ;
				   000000000.00 AS noilinc, ;
				   000000000.00 AS ngasinc, ;
				   000000000.00 AS nworkoil, ;
				   000000000.00 AS nworkgas, ;
				   000000000.00 AS nflatgas, ;
				   000000000.00 AS nflatoil, ;
				   wells.crevbbl, ;
				   wells.crevmcf, ;
				   wells.cwellstat AS cwellstatus, ;
				   wells.nwellcount, ;
				   wells.cstate AS cwellstate, ;
				   0 AS ndayson, ;
				   0 AS noilbbl, ;
				   0 AS ngasmcf, ;
				   0 AS nsaltbbl, ;
				   wells.cmeterid ;
			   FROM wells ;
			   WHERE wells.cstate   = lcState ;
				   AND wells.cwellid NOT IN (SELECT  cwellid ;
												 FROM wellhist ;
												 WHERE &lcWhereW) ;
				   AND wells.lthird_prty <> .T. ;
				   AND IIF(llActive, wells.cwellstat = 'A', wells.cwellstat # 'S') ; && Don't include sold wells
			   INTO CURSOR wellann2 readwrite ;
			   ORDER BY wells.cnra, wells.cwellid ;
			   GROUP BY wells.cnra, wells.cwellid
		
		      * make sure we only have the last 5 digits of the api number
		      SELECT wellann1
		      SCAN
		         REPLACE cpermit1 WITH RIGHT(STRTRAN(allt(cpermit1),'-',''),5), ;
		                 cpermit2 WITH RIGHT(STRTRAN(allt(cpermit2),'-',''),5), ;
		                 cpermit3 WITH RIGHT(STRTRAN(allt(cpermit3),'-',''),5), ;
		                 cpermit4 WITH RIGHT(STRTRAN(allt(cpermit4),'-',''),5), ;
		                 cpermit5 WITH RIGHT(STRTRAN(allt(cpermit5),'-',''),5), ;
		                 cpermit6 WITH RIGHT(STRTRAN(allt(cpermit6),'-',''),5)
		      ENDSCAN            
		      SELECT wellann2
		      SCAN
		         REPLACE cpermit1 WITH RIGHT(STRTRAN(allt(cpermit1),'-',''),5), ;
		                 cpermit2 WITH RIGHT(STRTRAN(allt(cpermit2),'-',''),5), ;
		                 cpermit3 WITH RIGHT(STRTRAN(allt(cpermit3),'-',''),5), ;
		                 cpermit4 WITH RIGHT(STRTRAN(allt(cpermit4),'-',''),5), ;
		                 cpermit5 WITH RIGHT(STRTRAN(allt(cpermit5),'-',''),5), ;
		                 cpermit6 WITH RIGHT(STRTRAN(allt(cpermit6),'-',''),5)
		      ENDSCAN            
		         
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Build_WV', loError.LINENO, 'Annual WV Return', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE build_wv_owners
		LPARAMETERS lnRecords
		LOCAL lcWhere, lcWhereS, ldDate1, ldDate2, llActive, llCompress, llNoProd, lnCount
		LOCAL lnMax, lnMultiplier, lnReportOn, llUseProducer_for_Working, llOverride, lcWorkInt
		LOCAL lcState, llContinue, llReturn, loError
		LOCAL cOwnerNo, cTaxYear, cYear, cidstown, cpermit, cstate, ctypeinv, cwellname, cwellstate
		LOCAL nGasInt, nOilInt, ndiff, ngasval, noilval, ntotalval, oProgress
		
		
		
		TRY
		   m.cYear      = ALLTRIM(THISFORM.txtcYear.VALUE)
		
		   IF THISFORM.opgYear.VALUE = 3  &&  Assign year variable based on year of last date if reporting for an accounting date range.
		      m.cYear = ALLT(STR(YEAR(THISFORM.txtDate2.VALUE)))
		   ENDIF
		
		   lcState      = THISFORM.cstate
		   m.cwellstate = lcState
		
		   m.cTaxYear   = STR(VAL(THISFORM.txtcYear.VALUE) + 2, 4)
		   m.cOwnerNo   = ALLTRIM(THISFORM.txtcOwnerNo.VALUE)
		   llActive     = THISFORM.chkactive.VALUE
		   ldDate1      = THISFORM.txtDate1.VALUE
		   ldDate2      = THISFORM.txtDate2.VALUE
		   lnReportOn   = THISFORM.opgYear.VALUE
		   llNoProd     = THISFORM.chkNoProd.VALUE
		   llCompress   = THISFORM.chkCompress.VALUE
		   lnMultiplier = IIF(llCompress, 1, 0)
		
		   llUseProducer_for_Working = THISFORM.chkUseProducer.VALUE
		   llOverride                = THISFORM.chkUseOverride.VALUE
		
		   IF llUseProducer_for_Working
		      lcWorkInt  = m.goapp.ccompanyname
		   ELSE
		      lcWorkInt  = 'Working Interest'
		   ENDIF
		
		   DO CASE
		      CASE lnReportOn = 1
		         lcWhere1  = "EMPTY(csusptype) and crunyear+PADL(TRANSFORM(nrunno),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE YEAR(dacctdate)=VAL(m.cYear) and ctypeclose='R')"
		         lcWhere2 = "not EMPTY(csusptype) and crunyear_in+PADL(TRANSFORM(nrunno_in),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE YEAR(dacctdate)=VAL(m.cYear) and ctypeclose='R')"
		         lcWhereS = "crunyear_in+PADL(TRANSFORM(nrunno_in),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE YEAR(dacctdate)=VAL(m.cYear) and ctypeclose='R')"
		      CASE lnReportOn = 2
		         lcWhere1 = 'empty(csusptype) and disbhist.hyear = m.cYear'
		         lcWhere2 = "not EMPTY(csusptype) and disbhist.hyear = m.cYear"
		         lcWhereS = 'suspense.hyear = m.cYear'
		      CASE lnReportOn = 3
		         lcWhere1 = "EMPTY(csusptype) and crunyear+PADL(TRANSFORM(nrunno),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE BETWEEN(dacctdate,ldDate1,ldDate2) and ctypeclose='R')"
		         lcWhere2 =  "not EMPTY(csusptype) and crunyear_in+PADL(TRANSFORM(nrunno_in),3,'0') in " + ;
		            "(SELECT crunyear+PADL(TRANSFORM(nrunno),3,'0') FROM sysctl WHERE BETWEEN(dacctdate,ldDate1,ldDate2) and ctypeclose='R')"
		         lcWhereS = "suspense.cRunYear_in+PADL(TRANSFORM(suspense.nRunNo_In),3,'0') IN " + ;
		            "(SELECT cRunYear+PADL(TRANSFORM(nRunNo),3,'0') FROM sysctl WHERE BETWEEN(dAcctDate,ldDate1,ldDate2) AND cTypeclose = 'R')"
		   ENDCASE
		
		   * Make a cursor copy of Form6s for this year's records
		   llContinue =  make_copy('Form6s', 'Temp6s')
		
		   IF NOT llContinue
		      MESSAGEBOX('Unable to create the temp owner file.', 16, 'File Creation Error')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   SELECT temp6s
		   INDEX ON cownerid + cwellid TAG ownwell
		
		   *
		   *  Build Temp6s file  (This is only for WV wells.)
		   *
		
		   SELE cnra, cwellid, cYear, SUM(noilinc) AS noilinc, SUM(ngasinc) AS ngasinc, cpermit ;
		      FROM annprod WITH (BUFFERING = .T.) ;
		      WHERE annprod.cYear = m.cYear INTO CURSOR tempann1 READWRITE ORDER BY cnra, cwellid, cYear GROUP BY cnra, cwellid, cYear
		   SELE cnra, cYear, SUM(noilinc) AS noilinc, SUM(ngasinc) AS ngasinc, cpermit ;
		      FROM annprod WITH (BUFFERING = .T.) ;
		      WHERE annprod.cYear = m.cYear INTO CURSOR tempann READWRITE ORDER BY cnra, cYear GROUP BY cnra, cYear
		   lnMax = _TALLY
		
		   swselect('wells')
		   SET ORDER TO cwellid
		
		   lcYear = m.cYear
		   swselect('form6s')
		   SCATTER MEMVAR BLANK
		   m.cYear = lcYear
		   lnCount   = 0
		   oProgress = THISFORM.oMessage.ProgressBarEx('Building Owner Records for WV Annual Return....')
		   oProgress.SetProgressRange(0, lnMax)
		   SET TALK ON
		
		   * Build Royalty Owners
		   WAIT WINDOW NOWAIT 'Building Royalty Interest Owners Totals'
		   SELECT  disbhist.cwellid, ;
		      disbhist.cownerid, ;
		      investor.csortfield AS cRoyName, ;
		      investor.caddress1a AS cRoyAddr1, ;
		      investor.caddress1b AS cRoyAddr2, ;
		      MAX(ownpcts.nrevoil) AS nOilInt, MAX(ownpcts.nrevgas) AS nGasInt, ;
		      TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		      SUM(disbhist.nOilRev) AS noilval, ;
		      SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval, ;
		      wells.cnra, ;
		      disbhist.ctypeinv ;
		      FROM disbhist ;
		      JOIN ownpcts ;
		      ON disbhist.ciddisb = ownpcts.ciddisb ;
		      JOIN wells ;
		      ON disbhist.cwellid = wells.cwellid ;
		      JOIN investor ;
		      ON disbhist.cownerid = investor.cownerid ;
		      WHERE INLIST(disbhist.ctypeinv, 'L', 'O') ;
		      AND disbhist.lFlat = .F. ;
		      AND &lcWhere1 ;
		      AND (disbhist.lManual = .F. ;
		      OR (disbhist.lManual = .T. ;
		      AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		      (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		      FROM sysctl ;
		      WHERE EMPTY(cVersion) ;
		      AND cTypeclose = 'R'))) ;
		      INTO CURSOR tmpinv READWRITE ;
		      ORDER BY wells.cnra, investor.csortfield, disbhist.ctypeinv ;
		      GROUP BY wells.cnra, investor.csortfield, disbhist.ctypeinv
		
		   INDEX ON cownerid + cwellid + ctypeinv TAG owntype
		
		*      AND (disbhist.nOilRev # 0 OR disbhist.nGasRev # 0) ;
		
		   SELECT  disbhist.cwellid, ;
		      disbhist.cownerid, ;
		      investor.csortfield AS cRoyName, ;
		      investor.caddress1a AS cRoyAddr1, ;
		      investor.caddress1b AS cRoyAddr2, ;
		      MAX(ownpcts.nrevoil) AS nOilInt, MAX(ownpcts.nrevgas) AS nGasInt, ;
		      TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		      SUM(disbhist.nOilRev) AS noilval, ;
		      SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval, ;
		      wells.cnra, ;
		      disbhist.ctypeinv ;
		      FROM disbhist ;
		      JOIN ownpcts ;
		      ON disbhist.ciddisb = ownpcts.ciddisb ;
		      JOIN wells ;
		      ON disbhist.cwellid = wells.cwellid ;
		      JOIN investor ;
		      ON disbhist.cownerid = investor.cownerid ;
		      WHERE investor.cownerid == disbhist.cownerid ;
		      AND INLIST(disbhist.ctypeinv, 'L', 'O') ;
		      AND disbhist.lFlat = .F. ;
		      AND &lcWhere2 ;
		      AND (disbhist.lManual = .F. ;
		      OR (disbhist.lManual = .T. ;
		      AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		      (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		      FROM sysctl ;
		      WHERE EMPTY(cVersion) ;
		      AND cTypeclose = 'R'))) ;
		      INTO CURSOR tmpinv1 ;
		      ORDER BY wells.cnra, investor.csortfield, disbhist.ctypeinv ;
		      GROUP BY wells.cnra, investor.csortfield, disbhist.ctypeinv
		
		   SELECT  suspense.cwellid, ;
		      suspense.cownerid, ;
		      investor.csortfield AS cRoyName, ;
		      investor.caddress1a AS cRoyAddr1, ;
		      investor.caddress1b AS cRoyAddr2, ;
		      MAX(suspense.nrevoil) AS nOilInt, MAX(suspense.nrevgas) AS nGasInt, ;
		      TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		      SUM(suspense.nOilRev) AS noilval, ;
		      SUM(suspense.nGasRev - ((suspense.nGather + suspense.nCompress) * lnMultiplier)) AS ngasval, ;
		      wells.cnra, ;
		      suspense.ctypeinv ;
		      FROM suspense ;
		      JOIN investor ;
		      ON suspense.cownerid = investor.cownerid ;
		      JOIN wells ;
		      ON suspense.cwellid = wells.cwellid ;
		      WHERE INLIST(suspense.ctypeinv, 'L', 'O') ;
		      AND suspense.lFlat = .F. ;
		      AND &lcWhereS ;
		      AND (suspense.lManual = .F. ;
		      OR (suspense.lManual = .T. ;
		      AND suspense.cRunYear_in + PADL(TRANSFORM(suspense.nRunNo_In), 3, '0') NOT IN ;
		      (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		      FROM sysctl ;
		      WHERE EMPTY(cVersion) ;
		      AND cTypeclose = 'R'))) ;
		      INTO CURSOR tmpinv2 ;
		      ORDER BY wells.cnra, investor.csortfield, suspense.ctypeinv ;
		      GROUP BY wells.cnra, investor.csortfield, suspense.ctypeinv
		
		*      AND (suspense.nOilRev # 0 OR suspense.nGasRev # 0) ;
		
		   SELECT cwellid, cownerid, ctypeinv, SUM(nrevoil) AS nOilInt, SUM(nrevgas) AS nGasInt ;
		      FROM wellinv ;
		      INTO CURSOR tmproy READWRITE;
		      WHERE NOT lFlat ;
		      ORDER BY cwellid, cownerid, ctypeinv ;
		      GROUP BY cwellid, cownerid, ctypeinv
		   INDEX ON cwellid+cownerid+ctypeinv TAG welltype
		
		   SELECT tmpinv1
		   SCAN
		      SCATTER MEMVAR
		      SELECT tmpinv
		      IF SEEK(m.cownerid + m.cwellid + m.ctypeinv)
		         REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval
		      ELSE
		         INSERT INTO tmpinv FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELECT tmpinv2
		   SCAN
		      SCATTER MEMVAR
		      SELECT tmpinv
		      IF SEEK(m.cownerid + m.cwellid + m.ctypeinv)
		         REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval
		      ELSE
		         INSERT INTO tmpinv FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		
		   *  Look for flat-rate royalties
		   WAIT WINDOW NOWAIT 'Building Flat Rate Owners Totals'
		   SELECT  disbhist.cwellid, ;
		      disbhist.cownerid, ;
		      investor.csortfield AS cRoyName, ;
		      investor.caddress1a AS cRoyAddr1, ;
		      investor.caddress1b AS cRoyAddr2, ;
		      TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		      disbhist.ctypeinv, ;
		      SUM(disbhist.nflatrate) AS nflatrate, ;
		      wells.cnra, ;
		      disbhist.nflatfreq ;
		      FROM disbhist ;
		      JOIN investor ;
		      ON disbhist.cownerid = investor.cownerid ;
		      JOIN wells ;
		      ON disbhist.cwellid = wells.cwellid ;
		      WHERE &lcWhere1 ;
		      AND disbhist.lFlat = .T. ;
		      AND disbhist.nflatrate # 0 ;
		      AND (disbhist.lManual = .F. ;
		      OR (disbhist.lManual = .T. ;
		      AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		      (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		      FROM sysctl ;
		      WHERE EMPTY(cVersion) ;
		      AND cTypeclose = 'R'))) ;
		      INTO CURSOR flatowner READWRITE ;
		      ORDER BY wells.cnra, investor.csortfield, disbhist.ctypeinv ;
		      GROUP BY wells.cnra, investor.csortfield, disbhist.ctypeinv
		
		   INDEX ON cwellid+cownerid+ctypeinv TAG welltype
		
		   SELECT  disbhist.cwellid, ;
		      disbhist.cownerid, ;
		      investor.csortfield AS cRoyName, ;
		      investor.caddress1a AS cRoyAddr1, ;
		      investor.caddress1b AS cRoyAddr2, ;
		      TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		      disbhist.ctypeinv, ;
		      SUM(disbhist.nflatrate) AS nflatrate, ;
		      wells.cnra, ;
		      disbhist.nflatfreq ;
		      FROM disbhist ;
		      JOIN investor ;
		      ON disbhist.cownerid = investor.cownerid ;
		      JOIN wells ;
		      ON disbhist.cwellid = wells.cwellid ;
		      WHERE &lcWhere2 ;
		      AND disbhist.lFlat = .T. ;
		      AND disbhist.nflatrate # 0 ;
		      AND (disbhist.lManual = .F. ;
		      OR (disbhist.lManual = .T. ;
		      AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		      (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		      FROM sysctl ;
		      WHERE EMPTY(cVersion) ;
		      AND cTypeclose = 'R'))) ;
		      INTO CURSOR flatowner1 READWRITE ;
		      ORDER BY wells.cnra, investor.csortfield, disbhist.ctypeinv ;
		      GROUP BY wells.cnra, investor.csortfield, disbhist.ctypeinv
		
		   SELECT  suspense.cwellid, ;
		      suspense.cownerid, ;
		      investor.csortfield AS cRoyName, ;
		      investor.caddress1a AS cRoyAddr1, ;
		      investor.caddress1b AS cRoyAddr2, ;
		      TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		      suspense.ctypeinv, ;
		      SUM(suspense.nflatrate) AS nflatrate, ;
		      wells.cnra, ;
		      suspense.nflatfreq ;
		      FROM suspense ;
		      JOIN investor ;
		      ON suspense.cownerid = investor.cownerid ;
		      JOIN wells ;
		      ON suspense.cwellid = wells.cwellid ;
		      WHERE &lcWhereS ;
		      AND suspense.lFlat = .T. ;
		      AND (suspense.lManual = .F. ;
		      OR (suspense.lManual = .T. ;
		      AND suspense.cRunYear_in + PADL(TRANSFORM(suspense.nRunNo_In), 3, '0') NOT IN ;
		      (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		      FROM sysctl ;
		      WHERE EMPTY(cVersion) ;
		      AND cTypeclose = 'R'))) ;
		      INTO CURSOR flatowner2 ;
		      ORDER BY wells.cnra, investor.csortfield, suspense.ctypeinv ;
		      GROUP BY wells.cnra, investor.csortfield, suspense.ctypeinv
		
		
		   WAIT WINDOW NOWAIT 'Building Working Interest Owners Totals'
		   IF llUseProducer_for_Working   && Use producer name for working interests
		      SELECT  disbhist.cwellid, ;
		         '**********' AS cownerid, ;
		         lcWorkInt AS cRoyName, ;
		         m.caddress AS cRoyAddr1, ;
		         SPACE(40)   AS cRoyAddr2, ;
		         ALLTRIM(m.ccity) + ' ' + m.cstate + ' ' + m.czip AS cRoyAddr3, ;
		         AVG(ownpcts.nrevoil) AS nOilInt, AVG(ownpcts.nrevgas) AS nGasInt, ;
		         SUM(disbhist.nOilRev) AS noilval, ;
		         wells.cnra, ;
		         SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval ;
		         FROM disbhist ;
		         JOIN ownpcts ;
		         ON disbhist.ciddisb = ownpcts.ciddisb ;
		         JOIN wells ;
		         ON disbhist.cwellid = wells.cwellid  ;
		         WHERE disbhist.ctypeinv = 'W' ;
		         AND &lcWhere1 ;
		         AND (disbhist.lManual = .F. ;
		         OR (disbhist.lManual = .T. ;
		         AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		         (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		         FROM sysctl ;
		         WHERE EMPTY(cVersion) ;
		         AND cTypeclose = 'R'))) ;
		         INTO CURSOR tmpwrk READWRITE ;
		         ORDER BY wells.cnra ;
		         GROUP BY wells.cnra
		
		      INDEX ON cnra TAG nra
		
		      SELECT  disbhist.cwellid, ;
		         '**********' AS cownerid, ;
		         lcWorkInt AS cRoyName, ;
		         m.caddress AS cRoyAddr1, ;
		         SPACE(40)   AS cRoyAddr2, ;
		         wells.cnra, ;
		         ALLTRIM(m.ccity) + ' ' + m.cstate + ' ' + m.czip AS cRoyAddr3, ;
		         AVG(ownpcts.nrevoil) AS nOilInt, AVG(ownpcts.nrevgas) AS nGasInt, ;
		         SUM(disbhist.nOilRev) AS noilval, ;
		         SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval ;
		         FROM disbhist ;
		         JOIN ownpcts ;
		         ON disbhist.ciddisb = ownpcts.ciddisb ;
		         JOIN wells ;
		         ON disbhist.cwellid = wells.cwellid  ;
		         WHERE disbhist.ctypeinv = 'W' ;
		         AND &lcWhere2 ;
		         AND (disbhist.lManual = .F. ;
		         OR (disbhist.lManual = .T. ;
		         AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		         (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		         FROM sysctl ;
		         WHERE EMPTY(cVersion) ;
		         AND cTypeclose = 'R'))) ;
		         INTO CURSOR tmpwrk1 READWRITE ;
		         ORDER BY wells.cnra ;
		         GROUP BY wells.cnra
		
		
		      SELECT  suspense.cwellid, ;
		         '**********' AS cownerid, ;
		         lcWorkInt AS cRoyName, ;
		         m.caddress AS cRoyAddr1, ;
		         SPACE(40)   AS cRoyAddr2, ;
		         ALLTRIM(m.ccity) + ' ' + m.cstate + ' ' + m.czip AS cRoyAddr3, ;
		         AVG(suspense.nrevoil) AS nOilInt, AVG(suspense.nrevgas) AS nGasInt, ;
		         SUM(suspense.nOilRev) AS noilval, ;
		         wells.cnra, ;
		         SUM(suspense.nGasRev - ((suspense.nGather + suspense.nCompress) * lnMultiplier)) AS ngasval ;
		         FROM suspense, wells ;
		         WHERE suspense.cwellid = wells.cwellid  ;
		         AND suspense.ctypeinv = 'W' ;
		         AND &lcWhereS ;
		         AND (suspense.lManual = .F. ;
		         OR (suspense.lManual = .T. ;
		         AND suspense.cRunYear_in + PADL(TRANSFORM(suspense.nRunNo_In), 3, '0') NOT IN ;
		         (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		         FROM sysctl ;
		         WHERE EMPTY(cVersion) ;
		         AND cTypeclose = 'R'))) ;
		         INTO CURSOR tmpwrk2 ;
		         ORDER BY wells.cnra ;
		         GROUP BY wells.cnra
		
		      SELECT  wellinv.cwellid, '**********' AS cownerid, ;
		         SUM(wellinv.nrevoil) AS nOilInt, ;
		         SUM(wellinv.nrevgas) AS nGasInt, ;
		         wells.cnra ;
		         FROM wellinv ;
		         JOIN wells ;
		         ON wellinv.cwellid = wells.cwellid ;
		         WHERE wellinv.ctypeinv = 'W' ;
		         INTO CURSOR tmpwork ;
		         ORDER BY wells.cnra ;
		         GROUP BY wells.cnra
		
		      INDEX ON cnra TAG nra
		
		      SELECT tmpwrk1
		      SCAN
		         SCATTER MEMVAR
		         SELECT tmpwrk
		         IF SEEK(m.cnra)
		            REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval
		         ELSE
		            INSERT INTO tmpwrk FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		      SELECT tmpwrk2
		      SCAN
		         SCATTER MEMVAR
		         SELECT tmpwrk
		         IF SEEK(m.cnra)
		            REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval
		         ELSE
		            INSERT INTO tmpwrk FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		      SELECT tmpwrk
		      SCAN
		         m.cnra = cnra
		         SELECT SUM(nrevgas) AS nGasInt, SUM(nrevoil) AS nOilInt ;
		            FROM wellinv ;
		            WHERE cwellid IN (SELECT cwellid FROM wells WHERE cnra = m.cnra) ;
		            AND ctypeinv = 'W' INTO CURSOR tempdoi
		         SELECT tmpwrk
		         REPLACE nOilInt WITH tempdoi.nOilInt, nGasInt WITH tempdoi.nGasInt
		      ENDSCAN
		
		   ELSE
		      SELECT  disbhist.cwellid, ;
		         disbhist.cownerid, ;
		         investor.csortfield AS cRoyName, ;
		         investor.caddress1a AS cRoyAddr1, ;
		         investor.caddress1b AS cRoyAddr2, ;
		         TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		         SUM(disbhist.nOilRev) AS noilval, ;
		         wells.cnra, ;
		         MAX(ownpcts.nrevoil) AS nOilInt, MAX(ownpcts.nrevgas) AS nGasInt, ;
		         SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval ;
		         FROM disbhist ;
		         JOIN ownpcts ;
		         ON disbhist.ciddisb = ownpcts.ciddisb ;
		         JOIN wells ;
		         ON disbhist.cwellid = wells.cwellid  ;
		         JOIN investor ;
		         ON disbhist.cownerid = investor.cownerid ;
		         WHERE disbhist.ctypeinv = 'W' ;
		         AND &lcWhere1 ;
		         AND (disbhist.lManual = .F. ;
		         OR (disbhist.lManual = .T. ;
		         AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		         (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		         FROM sysctl ;
		         WHERE EMPTY(cVersion) ;
		         AND cTypeclose = 'R'))) ;
		         INTO CURSOR tmpwrk READWRITE ;
		         ORDER BY wells.cnra, disbhist.cownerid ;
		         GROUP BY wells.cnra, disbhist.cownerid
		
		      INDEX ON cnra+cownerid TAG nraown
		
		      SELECT  disbhist.cwellid, ;
		         disbhist.cownerid, ;
		         investor.csortfield AS cRoyName, ;
		         investor.caddress1a AS cRoyAddr1, ;
		         investor.caddress1b AS cRoyAddr2, ;
		         wells.cnra, ;
		         TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		         MAX(ownpcts.nrevoil) AS nOilInt, MAX(ownpcts.nrevgas) AS nGasInt, ;
		         SUM(disbhist.nOilRev) AS noilval, ;
		         SUM(disbhist.nGasRev - ((disbhist.nGather + disbhist.nCompress) * lnMultiplier)) AS ngasval ;
		         FROM disbhist ;
		         JOIN ownpcts ;
		         ON disbhist.ciddisb = ownpcts.ciddisb ;
		         JOIN wells ;
		         ON disbhist.cwellid = wells.cwellid  ;
		         JOIN investor ;
		         ON disbhist.cownerid = investor.cownerid ;
		         WHERE disbhist.ctypeinv = 'W' ;
		         AND &lcWhere2 ;
		         AND (disbhist.lManual = .F. ;
		         OR (disbhist.lManual = .T. ;
		         AND disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nRunNo_In), 3, '0') NOT IN ;
		         (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		         FROM sysctl ;
		         WHERE EMPTY(cVersion) ;
		         AND cTypeclose = 'R'))) ;
		         INTO CURSOR tmpwrk1 READWRITE ;
		         ORDER BY wells.cnra, disbhist.cownerid ;
		         GROUP BY wells.cnra, disbhist.cownerid
		
		
		      SELECT  suspense.cwellid, ;
		         suspense.cownerid, ;
		         investor.csortfield AS cRoyName, ;
		         investor.caddress1a AS cRoyAddr1, ;
		         investor.caddress1b AS cRoyAddr2, ;
		         MAX(suspense.nrevoil) AS nOilInt, MAX(suspense.nrevgas) AS nGasInt, ;
		         TRIM(investor.ccity1) + ' ' + investor.cstate1 + ' ' + investor.czip1 AS cRoyAddr3, ;
		         SUM(suspense.nOilRev) AS noilval, ;
		         wells.cnra, ;
		         SUM(suspense.nGasRev - ((suspense.nGather + suspense.nCompress) * lnMultiplier)) AS ngasval ;
		         FROM suspense ;
		         JOIN investor ;
		         ON suspense.cownerid = investor.cownerid ;
		         JOIN wells ;
		         ON suspense.cwellid = wells.cwellid  ;
		         WHERE suspense.ctypeinv = 'W' ;
		         AND &lcWhereS ;
		         AND (suspense.lManual = .F. ;
		         OR (suspense.lManual = .T. ;
		         AND suspense.cRunYear_in + PADL(TRANSFORM(suspense.nRunNo_In), 3, '0') NOT IN ;
		         (SELECT  cRunYear + PADL(TRANSFORM(nRunNo), 3, '0') ;
		         FROM sysctl ;
		         WHERE EMPTY(cVersion) ;
		         AND cTypeclose = 'R'))) ;
		         INTO CURSOR tmpwrk2 ;
		         ORDER BY wells.cnra, suspense.cownerid ;
		         GROUP BY wells.cnra, suspense.cownerid
		
		      SELECT  wellinv.cwellid, wellinv.cownerid, ;
		         SUM(wellinv.nrevoil) AS nOilInt, ;
		         SUM(wellinv.nrevgas) AS nGasInt, ;
		         wells.cnra ;
		         FROM wellinv ;
		         JOIN wells ;
		         ON wellinv.cwellid = wells.cwellid ;
		         WHERE wellinv.ctypeinv = 'W' ;
		         INTO CURSOR tmpwork ;
		         ORDER BY wells.cnra, wellinv.cwellid, wellinv.cownerid ;
		         GROUP BY wells.cnra, wellinv.cwellid, wellinv.cownerid
		
		      INDEX ON cnra+cwellid+cownerid TAG nrawell
		
		      SELECT tmpwrk1
		      SCAN
		         SCATTER MEMVAR
		         SELECT tmpwrk
		         IF SEEK(m.cnra+m.cownerid)
		            REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval
		         ELSE
		            INSERT INTO tmpwrk FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		      SELECT tmpwrk2
		      SCAN
		         SCATTER MEMVAR
		         SELECT tmpwrk
		         IF SEEK(m.cnra+m.cownerid)
		            REPLACE noilval WITH noilval + m.noilval, ngasval WITH ngasval + m.ngasval
		         ELSE
		            INSERT INTO tmpwrk FROM MEMVAR
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		   WAIT CLEAR
		
		   SELECT tempann
		   SCAN
		      SCATTER MEMVAR
		
		      m.cnra = PADR(ALLTRIM(m.cnra),15,' ')
		
		      oProgress.SetProgressMessage('Preparing Return for NRA: ' + m.cnra)
		      oProgress.UpdateProgress(lnCount)
		      lnCount = lnCount + 1
		
		      * Change interests to decimal interests
		      IF RECCOUNT('tmpinv') > 0
		
		         SELECT tmpinv
		         SCAN FOR cnra == m.cnra
		            SCATTER MEMVAR
		
		            m.nOilInt = nOilInt / 100
		            m.nGasInt = nGasInt / 100
		
		            SELE wells
		            IF SEEK(m.cwellid)
		               m.cwellname = cwellname
		            ELSE
		               m.cwellname = 'Unknown'
		            ENDIF
		            SELE tmproy
		            IF SEEK( m.cwellid + m.cownerid + m.ctypeinv )
		               m.nOilInt = nOilInt / 100
		               m.nGasInt = nGasInt / 100
		            ENDIF
		            IF m.ctypeinv = 'L'
		               m.ctypeinv = 'RI'
		            ELSE
		               m.ctypeinv = 'ORRI*'
		               IF llOverride
		                  m.cRoyName = 'Override Interest'
		               ENDIF
		            ENDIF
		            m.ntotalval = m.ngasval + m.noilval
		
		            m.cidstown = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.form6s')
		            SELECT form6s
		            SET DELETED OFF
		            SET ORDER TO cidstown
		            DO WHILE SEEK(m.cidstown)
		               m.cidstown = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.form6s')
		            ENDDO
		            SET DELETED ON
		
		            m.cstate = lcState
		            INSERT INTO temp6s FROM MEMVAR
		         ENDSCAN
		      ENDIF
		
		      * Insert flat rate owners into form6s
		      SELECT flatowner1
		      SCAN FOR cnra == m.cnra
		         SCATTER MEMVAR
		         SELECT flatowner
		         IF SEEK(m.cwellid+m.cownerid+m.ctypeinv)
		            REPLACE nflatrate WITH nflatrate + m.nflatrate
		         ELSE
		            INSERT INTO flatowner FROM MEMVAR
		         ENDIF
		      ENDSCAN
		      SELECT flatowner2
		      SCAN FOR cnra == m.cnra
		         SCATTER MEMVAR
		         SELECT flatowner
		         IF SEEK(m.cwellid+m.cownerid+m.ctypeinv)
		            REPLACE nflatrate WITH nflatrate + m.nflatrate
		         ELSE
		            INSERT INTO flatowner FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		      IF RECCOUNT('flatowner') > 0
		         lnMax     = lnMax + RECCOUNT('flatowner')
		         SELECT flatowner
		         SCAN FOR cnra == m.cnra
		            SCATTER MEMVAR
		            m.ctypeinv  = 'FR'
		            m.nOilInt   = 0
		            m.nGasInt   = 0
		            m.noilval   = 0
		            m.ngasval   = 0
		            m.ntotalval = m.nflatrate
		
		            swselect('Temp6s')
		            IF SEEK(m.cownerid + m.cwellid)
		               REPLACE ntotalval WITH ntotalval + m.ntotalval
		            ELSE
		               m.cidstown = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.form6s')
		               SELECT form6s
		               SET DELETED OFF
		               SET ORDER TO cidstown
		               DO WHILE SEEK(m.cidstown)
		                  m.cidstown = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.form6s')
		               ENDDO
		               SET DELETED ON
		
		               m.cstate = lcState
		               INSERT INTO temp6s FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		         SELECT  cwellid, SUM(ntotalval) AS nflattotal ;
		            FROM temp6s ;
		            WHERE ctypeinv = 'FR' ;
		            AND cnra = m.cnra ;
		            INTO CURSOR tempflat ;
		            ORDER BY cwellid ;
		            GROUP BY cwellid
		      ENDIF
		
		      * Reset variable, since it's getting assigned to the state the report is being build for above - BH 10/09/2008
		      m.cstate = m.goapp.cstate
		
		      IF RECCOUNT('tmpwrk') > 0
		         SELECT tmpwrk
		         SCAN
		            SCATTER MEMVAR
		
		            m.nOilInt = nOilInt / 100
		            m.nGasInt = nGasInt / 100
		
		            m.ctypeinv = 'WI'
		            SELE tmpwork
		            IF NOT llUseProducer_for_Working
		               IF SEEK(m.cnra+m.cwellid+m.cownerid)
		                  m.nOilInt = nOilInt / 100
		                  m.nGasInt = nGasInt / 100
		               ELSE
		                  STORE 0 TO m.nOilInt, m.nGasInt
		               ENDIF
		            ELSE
		               IF SEEK(m.cnra)
		                  m.nOilInt = nOilInt / 100
		                  m.nGasInt = nGasInt / 100
		               ELSE
		                  STORE 0 TO m.nOilInt, m
		               ENDIF
		            ENDIF
		            m.ntotalval = m.ngasval + m.noilval
		            m.cidstown  = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.form6s')
		            SELECT form6s
		            SET DELETED OFF
		            SET ORDER TO cidstown
		            DO WHILE SEEK(m.cidstown)
		               m.cidstown = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.form6s')
		            ENDDO
		            SET DELETED ON
		
		            m.cstate = lcState
		            INSERT INTO temp6s FROM MEMVAR
		         ENDSCAN
		      ENDIF
		   ENDSCAN
		
		   oProgress.CloseProgress()
		
		   SELECT temp6s
		   SCAN
		      REPLACE ntotalval WITH ROUND(ntotalval, 0)
		
		      IF nOilInt = 0
		         REPLACE nOilInt WITH nGasInt
		      ENDIF
		
		      IF nGasInt = 0
		         REPLACE nGasInt WITH nOilInt
		      ENDIF
		   ENDSCAN
		
		   WAIT WINDOW NOWAIT 'Checking Interests...'
		   * Check to make sure the interests add up correctly
		   SELECT  cwellid, SUM(nOilInt) AS oilpct, SUM(nGasInt) AS gaspct, 0.0000000 AS ndiffoil, 0.0000000 AS ndiffgas ;
		      FROM temp6s ;
		      INTO CURSOR temppct1 READWRITE ;
		      ORDER BY cwellid ;
		      GROUP BY cwellid
		
		   SELECT temppct1
		   SCAN
		      SCATTER MEMVAR
		      IF m.oilpct > 1
		         m.ndiff = m.oilpct - 1
		         REPLACE ndiffoil WITH m.ndiff
		      ENDIF
		      IF m.gaspct > 1
		         m.ndiff = m.gaspct - 1
		         REPLACE ndiffgas WITH m.ndiff
		      ENDIF
		   ENDSCAN
		
		   SELECT temppct1
		   SCAN FOR ndiffgas <> 0 OR ndiffoil <> 0
		      SCATTER MEMVAR
		
		      IF m.ndiffgas <> 0
		         SELECT temp6s
		         LOCATE FOR cwellid = m.cwellid AND ctypeinv = 'WI'
		         IF FOUND()
		            REPLACE nGasInt WITH nGasInt - m.ndiffgas
		         ENDIF
		      ENDIF
		
		      IF m.ndiffoil <> 0
		         SELECT temp6s
		         LOCATE FOR cwellid = m.cwellid AND ctypeinv = 'WI'
		         IF FOUND()
		            REPLACE nOilInt WITH nOilInt - m.ndiffoil
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   WAIT CLEAR
		
		   WAIT WINDOW NOWAIT 'Checking totals...'
		
		   * Check for mismatching totals and fix
		   SELECT  cnra, cwellid, SUM(noilinc + ngasinc) AS nwelltot,  000000000.00 AS nowntot, 000000000.00 AS ndiff ;
		      FROM tempann1 ;
		      INTO CURSOR tempdiff1 READWRITE ;
		      ORDER BY cnra, cwellid ;
		      GROUP BY cnra, cwellid
		
		   SELECT  cnra, cwellid, SUM(ntotalval) AS nval ;
		      FROM temp6s ;
		      WHERE cYear = m.cYear ;
		      INTO CURSOR tempdiff2 ;
		      ORDER BY cnra, cwellid ;
		      GROUP BY cnra, cwellid
		
		   SELECT tempdiff2
		   SCAN
		      SELECT tempdiff1
		      LOCATE FOR cnra == tempdiff2.cnra AND cwellid == tempdiff2.cwellid
		      IF FOUND()
		         REPLACE nowntot WITH tempdiff2.nval
		         REPLACE ndiff WITH nwelltot - nowntot
		      ENDIF
		   ENDSCAN
		
		   SELECT * FROM tempdiff1 INTO CURSOR tempdiff WHERE ndiff # 0
		   SCAN
		      SELECT annprod
		      LOCATE FOR cnra = tempdiff.cnra AND cwellid = tempdiff.cwellid AND cYear = m.cYear
		      IF FOUND()
		         IF ngasinc # 0
		            REPLACE ngasinc WITH ngasinc - tempdiff.ndiff
		         ELSE
		            IF noilinc # 0
		               REPLACE noilinc WITH noilinc - tempdiff.ndiff
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   WAIT CLEAR
		
		   lnMax = RECCOUNT('temp6s')
		   oProgress = THISFORM.oMessage.ProgressBarEx('Inserting Owner Records...')
		   oProgress.SetProgressRange(0, lnMax)
		   lnOwners = 0
		   
		   SELECT form6s
		*   SET ORDER to inskey 
		   SELECT temp6s
		   SCAN
		      SCATTER MEMVAR
		      oProgress.setprogressmessage('NRA: ' + m.cnra)
		      oProgress.UpdateProgress(lnOwners)
		      lnOwners = lnOwners + 1 
		      SELECT form6s
		*      IF NOT SEEK(m.cyear+m.cownerid+m.cnra+m.ctypeinv)
		         INSERT INTO form6s FROM MEMVAR
		*      ENDIF
		   ENDSCAN
		   oProgress.CloseProgress()
		   WAIT CLEAR
		   
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Build_WV_Owners', loError.LINENO, 'Annual WV Return', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE Init
		LPARA tcState
		LOCAL lnX, lnY
		DODEFAULT()
		
		IF TYPE('tcState') <> 'C'
		    tcState = 'OH'
		ENDIF
		
		*  If you're building it during the first 6 months of the year, 
		*  you're probably doing it for the previous year.
		IF BETWEEN(MONTH(DATE()), 1, 6)
		    THISFORM.txtcYear.VALUE = STR(YEAR(DATE()) - 1, 4)
		ELSE
		    THISFORM.txtcYear.VALUE = STR(YEAR(DATE()), 4)
		ENDIF
		
		*
		*  Get info about the state reports that are on disk
		*
		THISFORM.cState = tcState
		
		THISFORM.chkusEOVERRIDE.VISIBLE = .F.
		THISFORM.chkusePRODUCER.VISIBLE = .F.
		
		DO CASE
		    CASE tcState = 'OH'
		        THIS.CAPTION           = 'Create Ohio Form 10 File'
		        THISFORM.HELPCONTEXTID = 602
		    CASE tcState = 'PA'
		        THIS.CAPTION           = 'Create PA Annual Statement of Production'
		        THISFORM.HELPCONTEXTID = 615
		    CASE tcState = 'NY'
		        THIS.CAPTION           = 'Create NY Annual Production File'
		        THISFORM.HELPCONTEXTID = 602
		    CASE tcState = 'WV'
		        THIS.CAPTION                       = 'Create WV Producer/Operator Return'
		        THISFORM.HELPCONTEXTID             = 622
		        THISFORM.chkusEOVERRIDE.VISIBLE    = .T.
		        THISFORM.chkusePRODUCER.VISIBLE    = .T.
		        THISFORM.txtcOwnerNo.VISIBLE       = .F.
		        THISFORM.chkassumeFullYear.VISIBLE = .F.
		        thisform.lblownerNo.Visible        = .f. 
		        thisform.chkActive.Visible         = .f.
		        thisform.chkNoProd.Visible         = .f.
		*  This is always done in the following year, so just set it back a year
		        THISFORM.txtcYear.SET('value', ALLTRIM(STR(YEAR(DATE()) - 1)))
		    OTHERWISE
		        THIS.CAPTION = 'Annual Statement of Production'
		ENDCASE
		
		THIS.oRegistry = FindGlobalObject('cmRegistry')
		THIS.oMessage  = FindGlobalObject('cmMessage')
	ENDPROC

	PROCEDURE cmdBuild.Click
		*!*	IF thisform.cstate = 'WV' AND EMPTY(thisform.txtcOwnerNo.Value)
		*!*	   thisform.oMessage.Warning('You must specify an owner number before the file can be built.')
		*!*	   thisform.setnextcontrol(thisform.txtcOwnerNo)
		*!*	   RETURN .f.
		*!*	ENDIF 
		
		thisform.buildfile()
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE opgYear.Click
		DODEFAULT()
		
		IF THIS.VALUE = 3  &&  Accounting Date Range
		   THISFORM.lblBuildRange.CAPTION = 'Date Range:'
		   thisform.lblBUILDRANGE.Visible = .t. 
		   thisform.txtDate1.visible = .t.
		   thisform.txtDate2.visible = .t.
		   thisform.lblHyphen.visible = .t.
		ELSE
		   THISFORM.lblBuildYear.CAPTION = 'Year:'
		   thisform.lblBuildRange.Visible = .f.
		   thisform.txtDate1.visible = .f.
		   thisform.txtDate2.visible = .f.
		   thisform.lblHyphen.visible = .f.   
		ENDIF
		
		
	ENDPROC

	PROCEDURE opgYear.Init
		IF DODEFAULT()
		   THIS.VALUE = 1
		ENDIF
		
	ENDPROC

	PROCEDURE Txtdate1.checkforclosed
		*
	ENDPROC

	PROCEDURE Txtdate1.Init
		this.value = date()
		
		dodefault()
	ENDPROC

	PROCEDURE Txtdate1.Valid
		*
	ENDPROC

	PROCEDURE txtDate2.checkforclosed
		*
	ENDPROC

	PROCEDURE txtDate2.Init
		this.value = date()
		
		dodefault()
	ENDPROC

	PROCEDURE txtDate2.Valid
		*
	ENDPROC

ENDDEFINE
