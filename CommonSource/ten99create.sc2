*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="ten99create.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor18" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor19" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor20" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor21" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 775
	Left = 50
	Name = "Dataenvironment"
	Top = 9
	Width = 941

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "checks", ;
		CursorSource = "checks", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "susaudit", ;
		BufferModeOverride = 5, ;
		CursorSource = "susaudit", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 94, ;
		Left = 419, ;
		Name = "Cursor10", ;
		Top = 15, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "glmaster", ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 300, ;
		Name = "Cursor11", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 557, ;
		Name = "Cursor12", ;
		Top = 261, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "tax10991", ;
		CursorSource = "tax1099", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 669, ;
		Name = "Cursor13", ;
		Top = 143, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "programs", ;
		CursorSource = "programs", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 105, ;
		Left = 680, ;
		Name = "Cursor14", ;
		Top = 266, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "tax1099det", ;
		BufferModeOverride = 5, ;
		CursorSource = "tax1099det", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 63, ;
		Left = 13, ;
		Name = "Cursor15", ;
		Top = 563, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "tax1099det1", ;
		CursorSource = "tax1099det", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 164, ;
		Name = "Cursor16", ;
		Top = 393, ;
		Width = 105
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "suspense", ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor17", ;
		Top = 158, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor18' AS cursor WITH ;
		Alias = "tax1099st", ;
		CursorSource = "tax1099st", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 372, ;
		Name = "Cursor18", ;
		Top = 230, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor19' AS cursor WITH ;
		Alias = "tax1099st1", ;
		CursorSource = "tax1099st", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 367, ;
		Name = "Cursor19", ;
		Top = 381, ;
		Width = 104
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "disbhist", ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 93, ;
		Left = 149, ;
		Name = "Cursor2", ;
		Top = 17, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor20' AS cursor WITH ;
		Alias = "tax1099states", ;
		CursorSource = "tax1099states", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 291, ;
		Name = "Cursor20", ;
		Top = 534, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor21' AS cursor WITH ;
		Alias = "tax1099corrections", ;
		CursorSource = "tax1099corrections", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 641, ;
		Name = "Cursor21", ;
		Top = 434, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "wellinv", ;
		CursorSource = "wellinv", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 546, ;
		Name = "Cursor3", ;
		Top = 15, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "options", ;
		BufferModeOverride = 3, ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 666, ;
		Name = "Cursor5", ;
		Top = 13, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "tax1099", ;
		CursorSource = "tax1099", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 77, ;
		Left = 269, ;
		Name = "Cursor6", ;
		Top = 158, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 553, ;
		Name = "Cursor8", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 17, ;
		Name = "Cursor9", ;
		Top = 397, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS form1099create AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCreate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chklByWell" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkExclTrans" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTaxID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkExcludeSusp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkAdvanced" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkGross" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtMin1099" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMin1099" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtnMin1099Roy" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lblfieldlabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkFlatRates" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addprioryearsuspcovered		&& Calculates suspense that was released in the 1099 year that came from before the 1099 year. Then it adds this income to the 1099.
		*m: archive		&& Archive prior year's 1099s
		*m: builddata
		*m: checkforerrors		&& Checks the 1099s for errors and gives a report if any were found.
		*m: checkformats
		*m: cleanoldsusp		&& Cleanup gross income totals in old susaudit and any converted suspense entries in suspense or disbhist
		*m: cleanupdetail
		*m: createauditrecs		&& Creates the auditrecs cursor of suspense from susaudit that hasn't been zeroed out.  These totals should be what was converted.
		*m: fixaudit
		*m: makefile		&& Create the 1099 file
		*m: makefilebywell		&& Creates the 1099 file by well instead of company. Each well reports its own 1099s.  Crazy, I know
		*m: makefiledet
		*m: makefiledetearned		&& Reports only what was earned during the year.
		*m: makefileearned		&& Reports the amounts earned during the year excluding suspense from prior years.
		*m: makefileearnedbywell
		*m: make_state_1099s
		*m: oldsuspproc		&& Old removecuryearsuspense
		*m: plugcosts		&& Calculate and insert plugging fund charges
		*m: plughdate		&& Plugs the correct hdate on released suspense
		*m: processoldsuspense		&& Processes the old susaudit suspense records that were converted.
		*m: qbvendor1099		&& Creates the vendor 1099s by calling QuickBooks to get the data.
		*m: removecuryearsuspense		&& Removes suspense released in the 1099 year that came from the 1099 year since those amounts are already in disbhist.
		*p: cyearapproved
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Create 1099 File"
	cyearapproved = 
	DataSession = 2
	DoCreate = .T.
	Height = 392
	HelpContextID = 245
	lcloseonescape = .T.
	Name = "Form1099create"
	Width = 425
	_memberdata = <VFPData>
		<memberdata name="processoldsuspense" display="ProcessOldSuspense"/>
		<memberdata name="createauditrecs" display="CreateAuditRecs"/>
		<memberdata name="make_state_1099s" display="Make_State_1099s"/>
		<memberdata name="cleanoldsusp" display="CleanOldSusp"/>
		<memberdata name="makefile" display="MakeFile"/>
		<memberdata name="makefiledet" display="MakeFileDet"/>
		<memberdata name="makefiledetearned" display="MakeFileDetEarned"/>
		<memberdata name="makefileearned" display="MakeFileEarned"/>
		<memberdata name="plughdate" display="PlugHDate"/>
		<memberdata name="qbvendor1099" display="QBVendor1099"/>
		<memberdata name="makefilebywell" display="MakeFileByWell"/>
		<memberdata name="makefileearnedbywell" display="MakeFileEarnedByWell"/>
		<memberdata name="checkforerrors" display="CheckForErrors"/>
		<memberdata name="cyearapproved" display="cYearApproved"/>
		<memberdata name="cleanupdetail" display="CleanUpDetail"/>
		<memberdata name="checkformats" display="CheckFormats"/>
		</VFPData>		&& XML Metadata for customizable properties
	MWRESIZE1.lblHighLight.Name = "lblHighLight"
	MWRESIZE1.lblShading.Name = "lblShading"
	MWRESIZE1.Left = 408
	MWRESIZE1.Name = "MWRESIZE1"
	MWRESIZE1.TabIndex = 13
	MWRESIZE1.Top = 300

	ADD OBJECT 'chkAdvanced' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Show Advanced Options", ;
		Left = 142, ;
		Name = "chkAdvanced", ;
		TabIndex = 3, ;
		Top = 60, ;
		Value = .F., ;
		Visible = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkExclTrans' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Exclude Transportation Revenue", ;
		Left = 25, ;
		Name = "chkExclTrans", ;
		TabIndex = 7, ;
		Top = 187, ;
		Value = .F., ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkExcludeSusp' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Only Include Revenue Earned This Year", ;
		Left = 25, ;
		Name = "chkExcludeSusp", ;
		TabIndex = 5, ;
		Top = 131, ;
		Value = .F., ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkFlatRates' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Report Flat Rate Royalties as Rents", ;
		Left = 25, ;
		Name = "chkFlatRates", ;
		TabIndex = 8, ;
		Top = 216, ;
		Value = .F., ;
		Visible = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkGross' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Create 1099s Based on Gross Revenue Instead of Net", ;
		Left = 25, ;
		Name = "chkGross", ;
		TabIndex = 4, ;
		Top = 103, ;
		Value = .F., ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chklByWell' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Build 1099s by Well", ;
		Left = 25, ;
		Name = "chklByWell", ;
		TabIndex = 9, ;
		Top = 246, ;
		Value = .F., ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkTaxID' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Create 1099s by Tax ID Instead of Owner ID", ;
		Left = 25, ;
		Name = "chkTaxID", ;
		TabIndex = 6, ;
		Top = 159, ;
		Value = .F., ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdCreate' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Create", ;
		Height = 36, ;
		Left = 124, ;
		Name = "cmdCreate", ;
		TabIndex = 15, ;
		Top = 96, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 36, ;
		Left = 227, ;
		Name = "cmdExit", ;
		TabIndex = 16, ;
		Top = 96, ;
		Width = 72
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Lblfieldlabelcustom1' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Minimum Royalty Int 1099 Amount:", ;
		Height = 16, ;
		Left = 91, ;
		Name = "Lblfieldlabelcustom1", ;
		TabIndex = 12, ;
		Top = 273, ;
		Width = 165
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Create 1099 file for year:", ;
		FontBold = .T., ;
		Height = 16, ;
		Left = 117, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 2, ;
		Top = 22, ;
		Width = 135
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblMin1099' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Minimum Working Int 1099 Amount:", ;
		Height = 16, ;
		Left = 91, ;
		Name = "lblMin1099", ;
		TabIndex = 14, ;
		Top = 295, ;
		Width = 168
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'txtcYear' AS swyear WITH ;
		Height = 20, ;
		Left = 267, ;
		MaxLength = 4, ;
		Name = "txtcYear", ;
		TabIndex = 1, ;
		Top = 20, ;
		Width = 39
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtMin1099' AS txttextboxcustom WITH ;
		ControlSource = "options.nmin1099non", ;
		Height = 20, ;
		InputMask = "9999.99", ;
		Left = 271, ;
		Name = "txtMin1099", ;
		TabIndex = 11, ;
		Top = 293, ;
		Width = 65
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtnMin1099Roy' AS txttextboxcustom WITH ;
		ControlSource = "options.nmin1099roy", ;
		Height = 20, ;
		InputMask = "9999.99", ;
		Left = 271, ;
		Name = "txtnMin1099Roy", ;
		TabIndex = 10, ;
		Top = 271, ;
		Width = 65
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE addprioryearsuspcovered		&& Calculates suspense that was released in the 1099 year that came from before the 1099 year. Then it adds this income to the 1099.
	ENDPROC

	PROCEDURE archive		&& Archive prior year's 1099s
	ENDPROC

	PROCEDURE builddata
		LOCAL llReturn, loError
		
		llReturn = .T.
		
		TRY
		    IF THISFORM.chkExcludeSusp.VALUE = .T.
		        IF THISFORM.chklByWell.VALUE = .T.
		            llReturn = THISFORM.MakeFileEarnedByWell()
		        ELSE
		            llReturn = THISFORM.MakeFileEarned()
		        ENDIF
		    ELSE
		        IF THISFORM.chklByWell.VALUE = .T.
		            llReturn = THISFORM.MakeFileByWell()
		        ELSE
		            llReturn = THISFORM.MakeFile()
		        ENDIF
		    ENDIF
		    
		    IF m.goapp.lPluggingModule
		       thisform.PlugCosts()
		    ENDIF 
		    
		    IF llReturn
		       thisform.CheckForErrors()
		    ENDIF    
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'Method', loError.LINENO, 'FormName', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE checkforerrors		&& Checks the 1099s for errors and gives a report if any were found.
		check_1099_Errors(thisform.txtcYear.Value,.f.,.f.,.t.)
	ENDPROC

	PROCEDURE checkformats
		LPARAMETERS tcYear, tlIgnoreSupport
		
		LOCAL lcCopy1, lcCopy2, lcCopyB, lcCopyC
		LOCAL llReturn, llUpdate
		
		lcCopy1 = m.goApp.cRptsFolder+'1099s\f1099_Copy1_' + tcYear + '.jpg'
		lcCopy2 = m.goApp.cRptsFolder+'1099s\f1099_Copy2_' + tcYear + '.jpg'
		lcCopyB = m.goApp.cRptsFolder+'1099s\f1099_CopyB_' + tcYear + '.jpg'
		lcCopyC = m.goApp.cRptsFolder+'1099s\f1099_CopyC_' + tcYear + '.jpg'
		
		llReturn = .T.
		llUpdate = .F.
		
		DO CASE
		   CASE NOT FILE(lcCopy1)
		      llUpdate = .T.
		   CASE NOT FILE(lcCopy2)
		      llUpdate = .T.
		   CASE NOT FILE(lcCopyB)
		      llUpdate = .T.
		   CASE NOT FILE(lcCopyC)
		      llUpdate = .T.
		ENDCASE
		
		IF llUpdate
		   llReturn = .f.
		ENDIF 
		
		RETURN llReturn   
	ENDPROC

	PROCEDURE cleanoldsusp		&& Cleanup gross income totals in old susaudit and any converted suspense entries in suspense or disbhist
	ENDPROC

	PROCEDURE cleanupdetail
		lcYear	  = THISFORM.txtcYear.VALUE
		llByTaxID  = THISFORM.chkTaxID.VALUE
		SELECT options
		GO TOP
		lnMin1099Non	= nmin1099Non    && Get the minimum 1099 amount for working interest owners
		lnMin1099Roy	= nmin1099Roy    && Get the minimum 1099 amount for royalty owners
		glHideComp	= lHideComp
		llGross1099	= lGross1099
		SELECT temp1099det
		SCAN FOR cYear = lcYear
		   IF nincome = 0 AND nexpense = 0 AND nsevtaxes = 0 AND nnetcheck = 0
		      DELETE NEXT 1
		   ELSE
		      IF (nincome - nexpense - nrents - nsevtaxes # nnetcheck) AND nnetcheck = 0
		         * Only doing the adjustment if calculating on gross
		         IF llGross1099
		            SELECT tax1099
		            IF llByTaxID
		               LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(temp1099det.cTaxID) AND cYear = lcYear
		            ELSE
		               LOCATE FOR cID = temp1099det.cID AND cYear = lcYear
		            ENDIF
		            IF FOUND()
		               IF temp1099det.cRptGroup = 'W'
		                  REPLACE nNonEmp WITH nNonEmp - temp1099det.nincome
		               ELSE
		                  REPLACE nroyalty WITH nroyalty - temp1099det.nincome
		               ENDIF
		               SELECT temp1099det
		               DELETE NEXT 1
		            ENDIF
		         ELSE
		            DELETE NEXT 1
		         ENDIF
		      ENDIF
		   ENDIF
		ENDSCAN
		
	ENDPROC

	PROCEDURE createauditrecs		&& Creates the auditrecs cursor of suspense from susaudit that hasn't been zeroed out.  These totals should be what was converted.
		LOCAL tcYear, tnRunNo, tlByWell, tlZeroBal, tlSummary
		LOCAL lcOwner, lcProg, lcWell, llReturn, lnBal, lnCount, lnExpenses, lnIncome, lnTaxes, loError
		*:Global csuspdesc, jcount
		
		llReturn = .T.
		
		TRY
		   tcYear    = THISFORM.txtcYear.VALUE
		   tnRunNo   = 99999999
		   tlZeroBal = .T.
		   tlSummary = .F.
		   tlByWell  = .T.
		
		***
		*** Pair down the susaudit table to just records that make up the balance at the time of conversion
		*** so we can match them to the converted records.  We do this so the converted records can be
		*** cleaned up too
		***
		   CREATE CURSOR auditrecs ;
		      (cYear      C(4), ;
		        dSuspDate  D,    ;
		        cTime      C(8), ;
		        cAction    C(1), ;
		        cGroup     C(2), ;
		        nAmount    N(12, 2), ;
		        nBal       N(12, 2), ;
		        nIncome    N(12, 2), ;
		        nExpenses  N(12, 2), ;
		        nTaxes     N(12, 2), ;
		        cSuspType  C(1), ;
		        cTypeInv   C(1), ;
		        csuspdesc  C(25), ;
		        cownerid   C(10), ;
		        cwellid    C(10), ;
		        cwellname  C(30), ;
		        cProgCode  C(10), ;
		        cprogname  C(30), ;
		        lProgFlag  L, ;
		        cPeriod    C(2), ;
		        nrunno     I, ;
		        crunyear   C(4), ;
		        ctaxid     C(20), ;
		        ntaxwith   N(12, 2), ;
		        nbackwith  N(12, 2), ;
		        cownname   C(40))
		   INDEX ON cownerid + cwellid + DTOS(dSuspDate) + cTime TAG ownerwell
		   INDEX ON cownerid + cwellid + DTOS(dSuspDate) + cTime DESC TAG ownerwelld
		   INDEX ON cownerid + cProgCode + DTOS(dSuspDate) + cTime TAG ownerprog
		   INDEX ON cownerid + cProgCode + DTOS(dSuspDate) + cTime DESC TAG ownerprogd
		   INDEX ON cownerid + DTOS(dSuspDate) + cTime TAG owner
		   INDEX ON cownerid + DTOS(dSuspDate) + cTime DESC TAG ownerd
		
		   CREATE CURSOR auditrecs1 ;
		      (cYear      C(4), ;
		        dSuspDate  D,    ;
		        cTime      C(8), ;
		        cAction    C(1), ;
		        cGroup     C(2), ;
		        nAmount    N(12, 2), ;
		        nIncome    N(12, 2), ;
		        nExpenses  N(12, 2), ;
		        nTaxes     N(12, 2), ;
		        cSuspType  C(1), ;
		        cTypeInv   C(1), ;
		        csuspdesc  C(25), ;
		        cownerid   C(10), ;
		        cwellid    C(10), ;
		        cwellname  C(30), ;
		        cProgCode  C(10), ;
		        cprogname  C(30), ;
		        lProgFlag  L, ;
		        cPeriod    C(2), ;
		        nrunno     I, ;
		        crunyear   C(4), ;
		        ctaxid     C(20), ;
		        ntaxwith   N(12, 2), ;
		        nbackwith  N(12, 2), ;
		        cownname   C(40))
		   INDEX ON cownerid + cwellid + DTOS(dSuspDate) + cTime TAG ownerwell
		   INDEX ON cownerid + cProgCode + DTOS(dSuspDate) + cTime TAG ownerprog
		   INDEX ON cownerid + DTOS(dSuspDate) + cTime TAG owner
		
		   jcount     = 0
		
		   SELECT  crunyear AS cYear, crunyear, nrunno, dSuspDate, cTime, IIF(cProgCode = 'NONE', ' ', cProgCode) AS cProgCode, .F. AS lProgFlag, ;
				   cAction AS cAction, nAmount AS nAmount, cTypeInv, cSuspType, cGroup, ;
				   nIncome, nExpenses, nTaxes, ntaxwith, nbackwith, investor.ctaxid, ;
				   susaudit.cownerid AS cownerid, susaudit.cwellid AS cwellid, ;
				   PADL(ALLT(STR(nrunno)), 2, '0') AS cPeriod ;
			   FROM susaudit, investor ;
			   WHERE crunyear + PADL(TRANSFORM(nrunno), 3, '0') <= tcYear + PADL(TRANSFORM(tnRunNo), 3, '0') ;
				   AND susaudit.cownerid = investor.cownerid ;
			   ORDER BY susaudit.cownerid, susaudit.cProgCode, susaudit.dSuspDate, susaudit.cTime ;
			   INTO CURSOR temp
		   SELECT auditrecs
		   APPEND FROM DBF('temp')
		
		   SELECT auditrecs
		   DELETE FOR nAmount = 0
		   COUNT FOR NOT DELETED() TO lnCount
		
		   lcWell  = ''
		   lcProg  = ''
		   lcOwner = ''
		   STORE 0 TO lnBal, lnIncome, lnExpenses, lnTaxes
		
		   SELE auditrecs
		   SET ORDER TO ownerwell
		   SCAN
		      SCATTER MEMVAR
		      IF lcOwner <> m.cownerid
		         STORE 0 TO lnBal, lnIncome, lnExpenses, lnTaxes
		         lcOwner = m.cownerid
		      ENDIF
		      IF tlByWell
		         IF lcWell <> m.cwellid
		            STORE 0 TO lnBal, lnIncome, lnExpenses, lnTaxes
		            lcWell = m.cwellid
		         ENDIF
		      ENDIF
		      DO CASE
		         CASE m.cAction = 'I'
		            lnBal      = lnBal + m.nAmount
		            lnIncome   = lnIncome + m.nIncome
		            lnExpenses = lnExpenses + m.nExpenses
		            lnTaxes    = lnTaxes + m.nTaxes
		         CASE m.cAction = 'O'
		            lnBal = lnBal + (m.nAmount * -1)
		*!*	         REPLACE nIncome WITH lnIncome, ;
		*!*	                 nExpenses WITH lnExpenses, ;
		*!*	                 nTaxes    WITH lnTaxes
		      ENDCASE
		
		      REPL nBal WITH lnBal
		
		      DO CASE
		         CASE cSuspType = 'I'
		            m.csuspdesc = 'Investor On Hold'
		         CASE cSuspType = 'B'
		            m.csuspdesc = 'Backup Withholding'
		         CASE cSuspType = 'A'
		            m.csuspdesc = 'Annual Pays'
		         CASE cSuspType = 'Q'
		            m.csuspdesc = 'Quarterly Pays'
		         CASE cSuspType = 'S'
		            m.csuspdesc = 'Semi-Annual Pays'
		         CASE cSuspType = 'T'
		            m.csuspdesc = 'Tax Withholding'
		         OTHERWISE
		            m.csuspdesc = ' '
		      ENDCASE
		      REPLACE csuspdesc WITH m.csuspdesc
		   ENDSCAN
		
		   SELE auditrecs
		   SET ORDER TO ownerwelld
		   SELE cownerid, cwellid FROM auditrecs INTO CURSOR temp ORDER BY cownerid, cwellid GROUP BY cownerid, cwellid
		   SELE temp
		   SCAN
		      SCATTER MEMVAR
		      SELE auditrecs
		      LOCATE FOR cownerid = m.cownerid AND cwellid = m.cwellid AND nBal = 0
		      IF FOUND()
		         DELE REST FOR cownerid = m.cownerid AND cwellid = m.cwellid
		      ENDIF
		   ENDSCAN
		   WAIT CLEAR
		   SELE auditrecs
		   SET ORDER TO ownerwell
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'CreateAuditRecs', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		 
	ENDPROC

	PROCEDURE fixaudit
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		this.Height = 162
		
		IF NOT m.goapp.oSecurity.HasPrivilege('Tax Ids')
		    MESSAGEBOX('You must have Tax IDs privilege to create 1099s',16,'Create 1099s')
		    RETURN .f.
		ENDIF 
		
		* Check the gross option
		swselect('options')
		GO top
		IF NOT options.lGross1099
		   IF MESSAGEBOX('The option to create 1099s based on gross revenue ' + ;
		                 'is not enabled. Normally, 1099s should be reporting ' + ;
		                 'gross revenue instead of net. Do you want to change ' + ;
		                 'the option to create the 1099s based on gross revenue?',36,thisform.Caption) = 6
		      REPLACE lgross1099 WITH .t.
		      TABLEUPDATE()
		      thisform.chkgross.Value = .t.
		   ENDIF 
		ELSE
		   thisform.chkgross.Value = .T.
		ENDIF 
		
		*
		*  Initialize the Year textbox
		*
		thisform.txtcYear.value = STR(YEAR(DATE())-1,4)
		thisform.chklbywell.value = .f.
		
		*
		*  Find the Registry object
		*
		THIS.oRegistry = FindGlobalObject('cmRegistry')
		
		
	ENDPROC

	PROCEDURE makefile		&& Create the 1099 file
		LOCAL lnAdj
		LOCAL oLink AS 'hyperlink'
		LOCAL lByWell, lcGroupByO, lcGroupByV, lcYear1, llGross1099, llReturn, llTranExp, lnCountD, lnDiff
		LOCAL lnMax, lnMin1099Non, lnMin1099Roy, lnProgress, loError
		LOCAL lnCount, lcYear, oProgress, lcYear, m.lByWell, llByTaxID, llQBVendor1099
		SET DELETED ON
		*
		*  Creates the 1099 file for the given year
		*
		llReturn	   = .T.
		llQBVendor1099 = .T.
		
		TRY
		   lcYear	  = THISFORM.txtcYear.VALUE
		   llByTaxID  = THISFORM.chkTaxID.VALUE
		   llFlatRent = THISFORM.chkflatRates.VALUE
		   lnCount	  = 0
		   llDetailOnly = .F.
		
		   IF llDetailOnly
		      DELETE FROM tax1099det WHERE cYear = lcYear
		      llReturn = THISFORM.MakeFileDet()
		      thisform.CleanUpDetail()
		      IF llReturn
		         SELECT tax1099det 
		         APPEND FROM DBF('temp1099det')
		         TABLEUPDATE(.t.,.t.,'tax1099det')
		      ENDIF 
		      MESSAGEBOX('The owner 1099 reconciliation file has been created successfully.',64,'1099 Processing')
		      EXIT
		   ENDIF
		
		
		   IF m.goApp.lQBVersion
		      IF NOT m.goApp.lQBActive
		         IF MESSAGEBOX("The QB connection is not active, so the vendor 1099 information could not be retrieved." + ;
		               "To have the QB vendor information included on the 1099s, connect to QB, and then re-create the 1099 file." + CHR(10) + CHR(10) + ;
		               "Do you want to continue without Vendor 1099s being created?", 36, 'Vendor 1099s') = 7
		            llReturn = .F.
		            EXIT
		         ELSE
		            llQBVendor1099 = .F.
		         ENDIF
		      ENDIF
		   ENDIF
		
		   *  Eliminate blank programs, which invariable cause all WI owners to get skipped for someone each year.
		   swselect('programs')
		   SCAN FOR EMPTY(cprogcode)
		      DELETE NEXT 1
		   ENDSCAN
		
		   IF THIS.CheckFormats(lcYear, .t.) = .F.
		      IF NOT THISFORM.oMessage.CONFIRM('The selected year has not yet been approved for 1099 processing by SherWare, Inc. ' + ;
		            'Creating the 1099 file for this year could lead to inaccurate processing and reporting.  Continue?')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   *
		   *   Fix 1099s with negative amounts and delete zero amounts and 1099's less
		   *   than the minimum
		   *
		   SELECT options
		   GO TOP
		   lnMin1099Non	= nmin1099Non    && Get the minimum 1099 amount for working interest owners
		   lnMin1099Roy	= nmin1099Roy    && Get the minimum 1099 amount for royalty owners
		   glHideComp	= lHideComp
		   llGross1099	= lGross1099
		   llTranExp	= THISFORM.chkExclTrans.VALUE    && Option to remove transportation revenue when used as marketing costs.
		
		   IF lnMin1099Non = 0
		      lnMin1099Non = .01
		   ENDIF
		   IF lnMin1099Roy = 0
		      lnMin1099Roy = .01
		   ENDIF
		
		   SELECT tax1099
		   COUNT FOR cYear = lcYear TO lnCount
		   SELECT tax1099det
		   COUNT FOR cYear = lcYear TO lnCountD
		   SELECT tax1099corrections
		   COUNT FOR cYear = lcYear TO lnCountC
		   llDelete = .F.
		   IF lnCount > 0
		      IF lnCountC > 0
		         IF NOT THISFORM.oMessage.CONFIRM('The 1099 file for tax year ' + TRIM(lcYear) + ;
		               ' already exists and there have been corrected ' + ;
		               '1099s created. Do you want to overwrite it?  ' + ;
		               'This will eliminate any manual changes already made ' + ;
		               'to the 1099 file for this year.')
		            WAIT WIND NOWAIT 'The 1099 process was cancelled...'
		            llReturn = .F.
		            EXIT
		         ELSE
		            llDelete = .T.
		         ENDIF
		      ELSE
		         IF NOT THISFORM.oMessage.CONFIRM('The 1099 file for tax year ' + TRIM(lcYear) + ' already exists. Do you want to overwrite it?  This will eliminate any manual changes already made to the 1099 file for this year.')
		            WAIT WIND NOWAIT 'The 1099 process was cancelled...'
		            llReturn = .F.
		            EXIT
		         ELSE
		            llDelete = .T.
		         ENDIF
		      ENDIF
		      IF llDelete
		         lnProgress	= 0
		         oProgress	= THISFORM.oMessage.ProgressBar('')
		         oProgress.SetProgressRange(0, lnCount + lnCountD)
		         oProgress.SetProgressMessage('Deleting Existing 1099 Records for ' + lcYear + '....')
		
		         DELETE FROM tax1099 WHERE cYear = lcYear
		         oProgress.SetProgressMessage('Deleting Existing 1099 Detail Records for ' + lcYear + '....')
		         DELETE FROM tax1099det WHERE cYear = lcYear
		         oProgress.SetProgressMessage('Deleting Existing 1099 Correction Records for ' + lcYear + '....')
		         DELETE FROM tax1099corrections WHERE cYear = lcYear
		         IF TYPE('oProgress') = 'O'
		            oProgress.CloseProgress()
		         ENDIF
		      ENDIF
		   ELSE
		      IF NOT THISFORM.oMessage.CONFIRM('Are you sure you want to create the 1099 file for ' + ALLTRIM(lcYear) + '?')
		         llReturn = .F.
		         EXIT
		      ENDIF
		
		   ENDIF
		
		   WAIT WIND NOWAIT 'Performing 1099 setup process...'
		
		   IF llByTaxID  &&  If creating by tax ID, scan the investor file and plug in the owner ID as the tax ID, so it's unique, and can be grouped correctly.
		      WAIT WINDOW NOWAIT 'Processing blank tax ID records'
		      SELECT investor
		      SCAN FOR EMPTY(cTaxID) AND lInv1099
		         REPLACE cTaxID WITH cOwnerID
		      ENDSCAN
		      = TABLEUPDATE(.T.)
		   ENDIF
		
		   IF llByTaxID
		      lcGroupByO = 'investor.ctaxid'
		      lcGroupByV = 'vendor.ctaxid'
		   ELSE
		      lcGroupByO = 'investor.cownerid'
		      lcGroupByV = 'vendor.cvendorid'
		   ENDIF
		
		   * Correct the hdate field on released suspense
		   *   THIS.plughdate()
		
		   WAIT WINDOW NOWAIT 'Querying owner 1099s...'
		   SET TALK ON
		   DO CASE
		      CASE llGross1099  && Gross Revenue
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, disbhist.nincome)))) AS nNonEmp, ;
		            0000000.00 AS nrents, ;
		            0000000.00 AS nroyalty ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		              AND investor.lInv1099 = .T.  ;
		              AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
		               OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0') + disbhist.cgroup IN ;
		                  (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') + cgroup ;
		                    FROM sysctl ;
		                    WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		                      AND cTypeClose = 'R'))  ;
		               AND cTypeInv = 'W'  ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		                                FROM programs ;
		                                WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		                    disbhist.lManual = .T. ;
		                    AND EMPTY(disbhist.csusptype) OR ;
		                   (disbhist.lManual = .T. ;
		                   AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0') + disbhist.cgroup ;
		                       NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') + cgroup ;
		                           FROM sysctl ;
		                           WHERE EMPTY(cversion) ;
		                                   AND cTypeClose = 'R'))) ;
		            ORDER BY &lcGroupByO ;
		            GROUP BY &lcGroupByO ;
		            INTO CURSOR wrk1099w READWRITE
		
		         * Get both the entries with a valid hdate on them,
		         * plus any entry with a run that had a valid date
		         * on it from this year, which would include previous
		         * year suspense released during this year
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            IIF(llFlatRent,SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		            (disbhist.nincome - disbhist.nflatrate))))), ;
		            SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev ), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev ), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		            (disbhist.nincome )))))) AS nroyalty, ;
		            SUM(IIF(llFlatRent,IIF(disbhist.lflat, disbhist.nflatrate,000000.00),000000.00)) AS nrents, ;
		            0000000.00 AS nNonEmp  ;
		            FROM disbhist, investor  ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
		            OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0') + disbhist.cgroup IN ;
		            (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') + cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		            AND cTypeClose = 'R'))  ;
		            AND (cTypeInv = 'L'  ;
		            OR cTypeInv = 'O')  ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		                                FROM programs ;
		                                WHERE lprog1099 = .F.) ;
		            AND (disbhist.lManual = .F. OR ;
		            disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype) OR ;
		            (disbhist.lManual = .T. ;
		            AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0') + disbhist.cgroup ;
		            NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') + cgroup ;
		            FROM sysctl ;
		            WHERE EMPTY(cversion) ;
		            AND cTypeClose = 'R'))) ;
		            ORDER BY &lcGroupByO ;
		            GROUP BY &lcGroupByO ;
		            INTO CURSOR wrk1099r READWRITE
		         SELECT wrk1099r
		         INDEX ON cID TAG cID
		
		      CASE NOT llGross1099   && Net Revenue
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'N' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            0.00 AS ncompgath, ;
		            SUM(disbhist.nnetcheck) AS nNonEmp, ;
		            disbhist.cprogcode, ;
		            0000000.00 AS nrents, ;
		            0000000.00 AS nroyalty ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
		            OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0') IN ;
		            (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		            FROM sysctl ;
		            WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		            AND cTypeClose = 'R'))  ;
		            AND disbhist.cTypeInv # 'L'  ;
		            AND disbhist.cTypeInv # 'O' ;
		            AND NOT DELETED() ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (disbhist.lManual = .F. OR ;
		            disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype) OR ;
		            (disbhist.lManual = .T. ;
		            AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0') + disbhist.cgroup ;
		            NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') + cgroup ;
		            FROM sysctl ;
		            WHERE EMPTY(cversion) ;
		            AND cTypeClose = 'R'))) ;
		            ORDER BY &lcGroupByO ;
		            GROUP BY &lcGroupByO ;
		            INTO CURSOR wrk1099w READWRITE
		
		         *
		         *  Get royalty owner's net distribution
		         *
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'N' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            IIF(llFlatRent,SUM(disbhist.nnetcheck-disbhist.nflatrate),SUM(disbhist.nnetcheck)) AS nroyalty, ;
		            IIF(llFlatRent,SUM(IIF(disbhist.lflat, disbhist.nflatrate,000000.00)),000000.00) AS nrents, ;
		            disbhist.cprogcode, ;
		            0.00 AS ncompgath, ;
		            0000000.00 AS nNonEmp  ;
		            FROM disbhist, investor  ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		                                FROM programs ;
		                                WHERE lprog1099 = .F.) ;
		            AND NOT DELETED() ;
		            AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
		            OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0') IN ;
		            (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		            FROM sysctl ;
		            WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		            AND cTypeClose = 'R'))  ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND (disbhist.cTypeInv = 'L'  ;
		            OR disbhist.cTypeInv = 'O') ;
		            AND (disbhist.lManual = .F. OR ;
		            disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype) OR ;
		            (disbhist.lManual = .T. ;
		            AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0') + disbhist.cgroup ;
		            NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') + cgroup ;
		            FROM sysctl ;
		            WHERE EMPTY(cversion) ;
		            AND cTypeClose = 'R'))) ;
		            ORDER BY &lcGroupByO ;
		            GROUP BY &lcGroupByO ;
		            INTO CURSOR wrk1099r READWRITE
		         SELECT wrk1099r
		         INDEX ON cID TAG cID
		   ENDCASE
		   SET TALK OFF
		   WAIT CLEAR
		
		   *
		   *  Create vendor 1099s
		   *
		   IF NOT m.goApp.lQBVersion
		      WAIT WINDOW NOWAIT 'Querying vendor 1099s....'
		      SELECT  MAX(vendor.cVendorID)  AS cID, ;
		         checks.cidtype AS cidtype, ;
		         vendor.cvendname AS cName, ;
		         SPACE(1) AS cName2,  ;
		         lcYear AS cYear, ;
		         'N' AS cType, ;
		         SUM(checks.nAmount) AS nNonEmp, ;
		         IIF(NOT EMPTY(vendor.cbaddr1),cbaddr1,caddress1) AS caddr1, ;
		         IIF(NOT EMPTY(vendor.cbaddr2),cbaddr2,caddress2) AS caddr2, ;
		         vendor.cTaxID  AS cTaxID, ;
		         IIF(NOT EMPTY(vendor.cbaddr1),vendor.cbcity,vendor.ccity)  AS ccity, ;
		         IIF(NOT EMPTY(vendor.cbaddr1),vendor.cbstate, vendor.cstate) AS cstate, ;
		         IIF(NOT EMPTY(vendor.cbaddr1),vendor.cbzip, vendor.czip)   AS czip, ;
		         IIF(NOT EMPTY(vendor.cbaddr1),vendor.cbcountry, vendor.ccountry) AS ccountry, ;
		         0000000.00 AS nroyalty, ;
		         0000000.00 AS nrents ;
		         FROM checks, vendor ;
		         WHERE vendor.lsend1099 = .T. ;
		         AND vendor.cVendorID = checks.cID  ;
		         AND checks.cidtype   = 'V' ;
		         AND checks.lvoid     = .F. ;
		         AND YEAR(checks.dcheckdate) = VAL(lcYear) ;
		         INTO CURSOR wrk1099v ;
		         GROUP BY &lcGroupByV
		      WAIT CLEAR
		   ELSE
		      IF m.goApp.oQB.QBFCVersion < ' 5.0'
		         IF THIS.oMessage.CONFIRM('You must update your QuickBooks interface in order for vendor 1099s to be processed. ' + ;
		               'QBFC needs to be at least version 5. Your version is: ' + ALLTRIM(m.goApp.oQB.QBFCVersion) + '. Download and install: support.sherware.com/download/qbfc5.exe?')
		            oLink = CREATEOBJECT('hyperlink')
		            oLink.NAVIGATETO('support.sherware.com/download/qbfc5.exe')
		         ENDIF
		      ENDIF
		
		      IF llQBVendor1099 = .T.
		         llReturn = THIS.qbvendor1099()
		         IF NOT llReturn
		            EXIT
		         ENDIF
		      ENDIF
		   ENDIF
		
		   SELE wrk1099w
		   lnMax = RECC()
		   SELE wrk1099r
		   lnMax = lnMax + RECC()
		
		   IF USED('wrk1099v')
		      SELE wrk1099v
		      lnMax = lnMax + RECC()
		   ENDIF
		
		   lnProgress = 0
		   oProgress  = THISFORM.oMessage.ProgressBar('')
		   oProgress.SetProgressRange(0, lnMax)
		
		   oProgress.SetProgressMessage('Creating Working Interest 1099 Records for ' + lcYear + '....')
		   SELE wrk1099w
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      IF llTranExp
		         m.nNonEmp = m.nNonEmp - m.ntrprev
		      ENDIF
		      m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		      SET DELE OFF
		      SELE tax10991
		      SET ORDER TO cidtax1
		      DO WHILE SEEK(m.cidtax1)
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		      ENDDO
		      SET DELE ON
		      IF glHideComp
		         m.nNonEmp = m.nNonEmp - m.ncompgath
		      ENDIF
		      INSERT INTO tax1099 FROM MEMVAR
		   ENDSCAN
		
		   USE IN wrk1099w
		
		
		   *
		   *  Insert Royalty records into work cursor
		   *
		   oProgress.SetProgressMessage('Creating Royalty Interest 1099 Records for ' + lcYear + '....')
		   SELECT wrk1099r
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      SELECT tax1099
		      IF llByTaxID
		         LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID) AND cYear = lcYear
		         IF FOUND()
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            REPLACE nroyalty WITH nroyalty + m.nroyalty
		            REPLACE nrents WITH nrents + m.nrents
		            *  If the royalty owner ID is higher than the WI owner ID, replace it.
		            *  The detail processing will get out of sync if we don't, since it's merging to the highest
		            *  ID code, regardless of owner type.
		            IF m.cID > tax1099.cID
		               REPLACE tax1099.cID WITH m.cID
		            ENDIF
		         ELSE
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            SET DELE OFF
		            SELE tax10991
		            SET ORDER TO cidtax1
		            DO WHILE SEEK(m.cidtax1)
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            ENDDO
		            SET DELE ON
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            INSERT INTO tax1099 FROM MEMVAR
		         ENDIF
		      ELSE
		         LOCATE FOR cID == m.cID AND cYear = lcYear
		         IF FOUND()
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		               nrents   WITH nrents + m.nrents
		         ELSE
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            SET DELE OFF
		            SELE tax10991
		            SET ORDER TO cidtax1
		            DO WHILE SEEK(m.cidtax1)
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            ENDDO
		            SET DELE ON
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            INSERT INTO tax1099 FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Processing federal backup withholding...')
		   *
		   *  Look for tax withholding and backup withholding
		   *
		   SELECT  disbhist.cOwnerID, SUM(nBackWith) AS nAmount, ;
		      investor.cTaxID ;
		      FROM disbhist, investor ;
		      WHERE nBackWith # 0 ;
		      AND disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0') IN ;
		      (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		      AND cTypeClose = 'R') ;
		      AND investor.cOwnerID = disbhist.cOwnerID ;
		      INTO CURSOR tback ;
		      ORDER BY &lcGroupByO ;
		      GROUP BY &lcGroupByO
		
		
		   SELECT tback
		   SCAN
		      SCATTER MEMVAR
		      SELECT tax1099
		      IF llByTaxID
		         LOCATE FOR cYear = lcYear AND ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID)
		      ELSE
		         LOCATE FOR cYear = lcYear AND cID = m.cOwnerID
		      ENDIF
		      IF FOUND()
		         REPL nFedTax WITH m.nAmount
		      ENDIF
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Processing state tax withholding...')
		
		   SELECT  disbhist.cOwnerID, SUM(nincome) AS nStateIncome, SUM(nTaxWith) AS nAmount, wells.cstate AS cTaxState,  ;
		      investor.cTaxID ;
		      FROM  disbhist, investor, wells ;
		      WHERE nTaxWith # 0 ;
		      AND disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0') IN ;
		      (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		      AND cTypeClose = 'R') ;
		      AND disbhist.cwellid = wells.cwellid  ;
		      AND disbhist.cOwnerID = investor.cOwnerID ;
		      INTO CURSOR ttax ;
		      ORDER BY &lcGroupByO, wells.cstate ;
		      GROUP BY &lcGroupByO, wells.cstate
		
		   SELECT ttax
		   SCAN FOR nAmount # 0
		      SCATTER MEMVAR
		      swselect('tax1099states')
		      LOCATE FOR cstate == m.cTaxState
		      IF FOUND()
		         m.cPayerNo = cPayerNo
		      ELSE
		         m.cPayerNo = ''
		      ENDIF
		      SELECT tax1099
		      IF llByTaxID
		         LOCATE FOR cYear = lcYear AND ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID)
		      ELSE
		         LOCATE FOR cYear = lcYear AND cID = m.cOwnerID
		      ENDIF
		      IF FOUND()
		         IF nStateTax1 = 0
		            REPL nStateTax1 WITH m.nAmount, ;
		               cTaxState1 WITH m.cTaxState, ;
		               cStatePayerNo1 WITH m.cPayerNo, ;
		               nStateIncome1 WITH m.nStateIncome
		         ELSE
		            REPL nStateTax2 WITH m.nAmount, ;
		               cTaxState2 WITH m.cTaxState, ;
		               cStatePayerNo2 WITH m.cPayerNo, ;
		               nStateIncome2 WITH m.nStateIncome
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   IF NOT llReturn
		      EXIT
		   ENDIF
		
		   SELECT tax1099
		   SCAN FOR cYear = lcYear
		      REPL cwellid WITH ''
		   ENDSCAN
		
		
		   SELECT tax1099
		   SET ORDER TO primkey
		
		   lcYear1 = STR(VAL(lcYear) + 1, 4)
		
		   IF USED('wrk1099v')
		      oProgress.SetProgressMessage('Creating Vendor 1099 Records for ' + lcYear + '....')
		      SELECT wrk1099v
		      SCAN
		         SCATTER MEMVAR
		         oProgress.UpdateProgress(lnProgress)
		         lnProgress	 = lnProgress + 1
		         m.cidtax1	 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         m.cwellid	 = ''
		         m.cwellname = ''
		         m.cWellTax	 = ''
		         m.cYear	 = lcYear
		         STORE '' TO m.cTaxState1, m.cTaxState2, m.cStatePayerNo1, m.cStatePayerNo2
		         STORE 0  TO m.nStateTax1, m.nFedTax, m.nStateTax2
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         INSERT INTO tax1099 FROM MEMVAR
		         SET DELE ON
		      ENDSCAN
		   ENDIF
		
		   IF TYPE('oProgress') = 'O'
		      oProgress.CloseProgress()
		   ENDIF
		
		   swselect('susaudit', .T.)
		
		   ** Cleanup the old susaudit table to make sure the gross income numbers aren't bogus
		   *  THIS.CleanOldSusp()
		
		   * Create the 1099DET file with the detail for the reconciliation report
		   llReturn = THISFORM.MakeFileDet()
		   IF NOT llReturn
		      EXIT
		   ENDIF
		
		   * Process suspense created before conversion
		   llReturn = THIS.ProcessOldSuspense()
		   IF NOT llReturn
		      EXIT
		   ENDIF
		
		   *
		   *  Check to see if we're integrated with the Accounting Manager
		   *  If so, we need to check the coa table for a rent account
		   *
		   IF m.goApp.lAMVersion
		      WAIT WIND NOWAIT 'Processing rental 1099s...'
		
		      * Get the landopt account to ignore for rentals
		      swselect('landopt')
		      GO TOP
		      lcRentAcct = landopt.crentacct
		
		      SELECT  cID, cacctno, ndebits, ncredits ;
		         FROM glmaster ;
		         INTO CURSOR tempgl ;
		         WHERE YEAR(ddate) = VAL(lcYear)
		
		      SELECT  cID, SUM(ndebits - ncredits) AS nAmount ;
		         FROM tempgl ;
		         WHERE cacctno IN (SELECT  cacctno ;
		         FROM coa ;
		         WHERE lrent1099) ;
		         AND cacctno # lcRentAcct ;
		         INTO CURSOR temprent ;
		         ORDER BY cID ;
		         GROUP BY cID
		
		      IF RECCOUNT('temprent') > 0
		         SELECT tax1099
		         SET ORDER TO primkey
		         SELECT temprent
		         SCAN FOR nAmount > 0
		            STORE 000000.00 TO m.nroyalty, m.nrents, m.nNonEmp
		            SCATTER MEMVAR
		
		            SELECT tax1099
		            IF SEEK(lcYear + m.cID)
		               REPLACE nrents WITH nrents + m.nAmount
		               IF cidtype = 'V'
		                  REPLACE nNonEmp WITH nNonEmp - m.nAmount
		               ENDIF
		            ELSE
		               m.nNonEmp  = 0
		               m.nroyalty = 0
		               SELECT vendor
		               SET ORDER TO cVendorID
		               IF SEEK(m.cID) AND lsend1099
		                  m.cName	  = cvendname
		                  m.cName2	  = ''
		                  m.caddr1	  = cbaddr1
		                  m.caddr2	  = cbaddr2
		                  m.ccity	  = cbcity
		                  m.cstate	  = cbstate
		                  m.czip	  = cbzip
		                  m.ccountry  = cbcountry
		                  m.cTaxID	  = cTaxID
		                  m.nrents	  = m.nAmount
		                  m.cYear	  = lcYear
		                  m.cidtype	  = 'V'
		                  m.cwellid	  = ''
		                  m.cwellname = ''
		                  m.cType	  = IIF(llGross1099, 'G', 'N')
		                  m.cidtax1	  = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  SET DELE OFF
		                  SELE tax10991
		                  SET ORDER TO cidtax1
		                  DO WHILE SEEK(m.cidtax1)
		                     m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  ENDDO
		                  SET DELE ON
		                  INSERT INTO tax1099 FROM MEMVAR
		               ELSE
		                  SELECT investor
		                  SET ORDER TO cOwnerID
		                  IF SEEK(m.cID) AND lInv1099
		                     m.cName	 = cOwnName
		                     m.cName2	 = cOwnName1
		                     m.caddr1	 = caddress1a
		                     m.caddr2	 = caddress1b
		                     m.ccity	 = ccity1
		                     m.cstate	 = cstate1
		                     m.czip		 = czip1
		                     m.ccountry	 = ccountry1
		                     m.cTaxID	 = cTaxID
		                     m.nrents	 = m.nAmount
		                     m.cYear	 = lcYear
		                     m.cwellid	 = ''
		                     m.cwellname = ''
		                     m.cidtype	 = 'I'
		                     m.cType	 = IIF(llGross1099, 'G', 'N')
		                     m.cidtax1	 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     SET DELE OFF
		                     SELE tax10991
		                     SET ORDER TO cidtax1
		                     DO WHILE SEEK(m.cidtax1)
		                        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     ENDDO
		                     SET DELE ON
		                     INSERT INTO tax1099 FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDSCAN
		      ENDIF
		
		      SELECT  checks.cID  AS cID, ;
		         checks.cidtype  AS cidtype, ;
		         checks.cpayee   AS cName, ;
		         lcYear          AS cYear, ;
		         IIF(llGross1099, 'G', 'N') AS cType, ;
		         SUM(checks.nAmount) AS nrents, ;
		         investor.caddress1a AS caddr1, ;
		         investor.caddress1b AS caddr2, ;
		         investor.cOwnName1 AS cName2,  ;
		         investor.cTaxID     AS cTaxID, ;
		         investor.ccity1  AS ccity, ;
		         investor.cstate1 AS cstate, ;
		         investor.czip1   AS czip, ;
		         investor.ccountry1 AS ccountry, ;
		         0000000.00 AS nroyalty, ;
		         0000000.00 AS nNonEmp  ;
		         FROM checks, investor ;
		         WHERE investor.cOwnerID = checks.cID  ;
		         AND checks.cidtype   = 'I' ;
		         AND checks.csource   = 'LM' ;
		         AND checks.lvoid     = .F. ;
		         AND investor.lInv1099 = .T. ;
		         AND investor.ldummy = .F. ;
		         AND YEAR(dcheckdate) = VAL(lcYear) ;
		         INTO CURSOR wrk1099 ;
		         GROUP BY cID
		
		      IF _TALLY > 0
		         SELE wrk1099
		         SCAN
		            SCATTER MEMVAR
		            m.cwellid	= ''
		            m.cwellname	= ''
		            m.nNonEmp	= 0
		            m.nroyalty	= 0
		            SELECT tax1099
		            SET ORDER TO primkey
		            SEEK (lcYear + m.cID)
		            IF FOUND()
		               REPLACE nrents WITH nrents + m.nrents
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               m.cYear = lcYear
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ENDSCAN
		      ENDIF
		   ELSE
		      SELECT  checks.cID  AS cID, ;
		         checks.cidtype  AS cidtype, ;
		         checks.cpayee   AS cName, ;
		         lcYear          AS cYear, ;
		         IIF(llGross1099, 'G', 'N') AS cType, ;
		         SUM(checks.nAmount) AS nrents, ;
		         investor.caddress1a AS caddr1, ;
		         investor.caddress1b AS caddr2, ;
		         investor.cOwnName1 AS cName2,  ;
		         investor.cTaxID     AS cTaxID, ;
		         investor.ccity1  AS ccity, ;
		         investor.cstate1 AS cstate, ;
		         investor.czip1   AS czip, ;
		         investor.ccountry1 AS ccountry, ;
		         0000000.00 AS nroyalty, ;
		         0000000.00 AS nNonEmp  ;
		         FROM checks, investor ;
		         WHERE investor.cOwnerID = checks.cID  ;
		         AND checks.cidtype   = 'I' ;
		         AND checks.csource   = 'LM' ;
		         AND checks.lvoid     = .F. ;
		         AND investor.lInv1099 = .T. ;
		         AND investor.ldummy = .F. ;
		         AND YEAR(dcheckdate) = VAL(lcYear) ;
		         INTO CURSOR wrk1099 ;
		         GROUP BY cID
		
		      IF _TALLY > 0
		         SELE wrk1099
		         SCAN
		            SCATTER MEMVAR
		            m.cwellid	= ''
		            m.cwellname	= ''
		            m.nNonEmp	= 0
		            m.nroyalty	= 0
		            SELECT tax1099
		            SET ORDER TO primkey
		            SEEK (lcYear + m.cID)
		            IF FOUND()
		               REPLACE nrents WITH nrents + m.nrents
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               m.cYear = lcYear
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ENDSCAN
		      ENDIF
		   ENDIF
		
		
		   lnProgress = 1
		   SELECT tax1099
		   COUNT FOR cYear = lcYear TO lnMax
		   lnMax	 = lnMax + 8
		   oProgress = THISFORM.oMessage.ProgressBarex('Performing 1099 Cleanup...')
		   oProgress.SetProgressRange(0, lnMax)
		
		   oProgress.SetProgressMessage('Step 1...')
		   oProgress.UpdateProgress(lnProgress)
		   lnProgress = lnProgress + 1
		   
		   thisform.CleanUpDetail()
		
		   *  Clean up the 1099 file.  There should be no "Dummy"
		   *  owners in the file,  There should also not be any
		   *  negative numbers.  If any are found, deleted them.
		   *
		   SELECT temp1099det
		   SET ORDER TO cID   && CYEAR+CID
		   SELECT tax1099
		   SCAN FOR cYear = lcYear
		      SCATTER MEMVAR
		      oProgress.SetProgressMessage('Step 2... ID: ' + m.cID)
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      IF m.nroyalty < 0
		         REPLACE nroyalty WITH 0
		      ENDIF
		      IF m.nrents < 0
		         REPLACE nrents WITH 0
		      ENDIF
		      IF m.nNonEmp < 0
		         REPLACE nNonEmp WITH 0
		      ENDIF
		      IF m.nFedTax < 0
		         REPLACE nFedTax WITH 0
		      ENDIF
		      IF m.nStateTax1 < 0
		         REPLACE nStateTax1 WITH 0
		      ENDIF
		      IF m.nStateTax2 < 0
		         REPLACE nStateTax2 WITH 0
		      ENDIF
		      REPLACE cwellid WITH '', cwellname WITH ''
		      IF nroyalty = 0 AND nrents = 0 AND nFedTax = 0 AND nStateTax1 = 0 AND nStateTax2 = 0 AND nNonEmp  = 0
		         DELETE NEXT 1
		         IF m.cidtype = 'I'
		            SELECT temp1099det
		            IF SEEK(lcYear + m.cID)
		               DELETE NEXT 1
		            ENDIF
		            LOOP
		         ENDIF
		      ENDIF
		      IF lnMin1099Non > 0
		         SELECT tax1099
		         IF m.nNonEmp < lnMin1099Non AND m.nroyalty < lnMin1099Roy AND m.nrents < lnMin1099Non
		            IF m.nFedTax = 0  && Don't subject to minimum if there is backup withholding - pws 11/25/18
		               DELETE NEXT 1
		            ENDIF
		         ENDIF
		         IF m.nrents < lnMin1099Non AND m.nroyalty < lnMin1099Roy AND m.nNonEmp < lnMin1099Non
		            IF m.nFedTax = 0 && Don't subject to minimum if there is backup withholding - pws 11/25/18
		               DELETE NEXT 1
		            ENDIF
		         ENDIF
		      ENDIF
		      IF lnMin1099Roy > 0
		         SELECT tax1099
		         IF m.nroyalty < lnMin1099Roy AND m.nrents < lnMin1099Non AND m.nNonEmp < lnMin1099Non
		            IF m.nFedTax = 0 && Don't subject to minimum if there is backup withholding - pws 11/25/18
		               DELETE NEXT 1
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		
		   **  If we're not building by tax ID, compare cid between tax1099 and temp1099det and delete any detail records
		   **  without a corresponding 1099.  Otherwise, compare ctaxid
		   oProgress.SetProgressMessage('Step 3...')
		   oProgress.UpdateProgress(lnProgress)
		   lnProgress = lnProgress + 1
		   IF NOT llByTaxID
		      SELECT temp1099det
		      DELETE FROM temp1099det WHERE cID NOT IN (SELECT cID FROM tax1099 WHERE cYear == lcYear)
		
		      oProgress.SetProgressMessage('Step 4...')
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		
		   ELSE
		      **  By tax ID, so compare ctaxid fields to determine whether to remove the temp1099det records
		      SELECT temp1099det
		      DELETE FROM temp1099det WHERE cTaxID NOT IN (SELECT cTaxID FROM tax1099 WHERE cYear == lcYear)
		
		      *  Make sure the temp1099det file has names/addresses that match tax1099.  Since we're grouping by tax ID,
		      *  the detail records have the name/address that corresponds with that specific interest
		      WAIT WINDOW NOWAIT 'Cleaning up 1099 Detail File by Tax ID'
		      SELECT tax1099
		      SCAN FOR cYear = lcYear AND cidtype = 'I'
		         SCATTER MEMVAR
		         SELECT temp1099det
		         SCAN FOR cTaxID == m.cTaxID AND cYear = lcYear
		            REPLACE cID WITH m.cID, cName WITH m.cName, cName2 WITH m.cName2, caddr1 WITH m.caddr1,  ;
		               caddr2 WITH m.caddr2, ccity WITH m.ccity, cstate WITH m.cstate, czip WITH m.czip
		         ENDSCAN
		      ENDSCAN
		      WAIT CLEAR
		   ENDIF
		
		   oProgress.SetProgressMessage('Step 5...')
		   oProgress.UpdateProgress(lnProgress)
		   lnProgress = lnProgress + 1
		   ** Clean up expense to make sure the records foot across
		   SELECT temp1099det
		   SCAN FOR cYear == lcYear
		      lnDiff = (nincome - nexpense - nsevtaxes - nStateTax - nFedTax - ncompgath + nrents) - nnetcheck
		      IF  lnDiff # 0
		         IF lnDiff > 0
		            IF nexpense - lnDiff < 0
		               REPLACE nexpense WITH 0
		               IF nsevtaxes - lnDiff < 0
		                  REPLACE nincome WITH nincome - lnDiff
		               ELSE
		                  REPLACE nsevtaxes WITH nsevtaxes - lnDiff
		               ENDIF
		            ELSE
		               REPLACE nexpense WITH nexpense - lnDiff
		            ENDIF
		         ELSE
		            IF nexpense + lnDiff < 0
		               REPLACE nexpense WITH 0
		               IF nsevtaxes + lnDiff < 0
		                  REPLACE nincome WITH nincome + lnDiff
		               ELSE
		                  REPLACE nsevtaxes WITH nsevtaxes + lnDiff
		               ENDIF
		            ELSE
		               REPLACE nexpense WITH nexpense + lnDiff
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Step 6...')
		   oProgress.UpdateProgress(lnProgress)
		   lnProgress = lnProgress + 1
		   SELECT tax1099
		   SCAN FOR cTaxID = cID AND cYear = lcYear
		      REPLACE cTaxID WITH ''
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Step 7...')
		   oProgress.UpdateProgress(lnProgress)
		   lnProgress = lnProgress + 1
		   SELECT temp1099det
		   SCAN FOR cTaxID = cID
		      REPLACE cTaxID WITH ''
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Step 8...')
		   oProgress.UpdateProgress(lnProgress)
		   lnProgress = lnProgress + 1
		   SELECT tax1099
		   TABLEUPDATE(.T.)
		   SELECT tax1099det
		   APPEND FROM DBF('temp1099det')
		   TABLEUPDATE(.T.)
		   TABLEUPDATE(.T.,.T.,'tax1099corrections')
		
		   oProgress.SetProgressMessage('Step 9...')
		   oProgress.UpdateProgress(lnProgress)
		   lnProgress = lnProgress + 1
		   IF llByTaxID  &&  If creating by tax ID, scan the investor file and plug in the owner ID as the tax ID, so it's unique, and can be grouped correctly.
		      WAIT WINDOW NOWAIT 'Cleaning up blank tax ID records'
		      SELECT investor
		      SCAN FOR cTaxID = cOwnerID AND lInv1099
		         REPLACE cTaxID WITH ''
		      ENDSCAN
		      TABLEUPDATE(.T.)
		   ENDIF
		
		   oProgress.CloseProgress()
		
		   WAIT WINDOW NOWAIT 'Processing State 1099s...'
		   lnState = THISFORM.Make_State_1099s()
		   IF VARTYPE(lnState) # 'N'
		      lnState = 0
		      EXIT
		   ENDIF
		
		   WAIT CLEAR
		
		   SELECT tax1099
		   COUNT FOR cYear = lcYear ;
		      AND (nroyalty # 0 OR nother # 0 OR nattorney # 0 OR nrents # 0) AND NOT DELETED() TO lnCount
		   COUNT FOR cYear = lcYear ;
		      AND nNonEmp # 0 AND NOT DELETED() TO lnNonEmpCount
		
		   *  Display the total number of 1099 records created.
		   MESSAGEBOX('Finished Processing 1099s for ' + lcYear + CHR(10) + CHR(10) + ;
		      'Created ' + ALLTRIM(TRANSFORM(lnCount, '999,999')) + ' Federal 1099-Misc 1099s ' + ;
		      ' and ' + ALLTRIM(TRANSFORM(lnNonEmpCount, '999,999')) + ' Federal 1099-NEC 1099s ' + ;
		      IIF(lnState # 0, ' and ' + ALLTRIM(TRANSFORM(lnState, '999,999')) + ' State 1099s ', ''), 64, '1099 Processing Counts')
		   swclose('temprent')
		   swclose('tmp1')
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildData', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		   IF VARTYPE(oProgress) = 'O'
		      oProgress.CloseProgress()
		   ENDIF
		   MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		oProgress = .NULL.
		RETURN llReturn
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE makefilebywell		&& Creates the 1099 file by well instead of company. Each well reports its own 1099s.  Crazy, I know
		LOCAL lnAdj
		LOCAL oLink AS 'hyperlink'
		LOCAL lByWell, lcGroupByO, lcGroupByV, lcYear1, llGross1099, llReturn, llTranExp, lnCountD, lnDiff
		LOCAL lnMax, lnMin1099Non, lnMin1099Roy, lnProgress, loError
		LOCAL lnCount, lcYear, oProgress, lcYear, m.lByWell, llByTaxID, llQBVendor1099
		SET DELETED ON
		*
		*  Creates the 1099 file for the given year
		*
		
		llReturn       = .T.
		llQBVendor1099 = .T.
		
		TRY
		   lcYear    = THISFORM.txtcYear.VALUE
		   llByTaxID = THISFORM.chkTaxID.VALUE
		   llFlatRent = THISFORM.chkflatRates.VALUE
		   lnCount   = 0
		
		   IF NOT THISFORM.oMessage.CONFIRM('Are you sure you want to create the 1099 file for ' + ALLTRIM(lcYear) + '?')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   IF m.goApp.lQBVersion
		      IF NOT m.goApp.lQBActive
		         IF MESSAGEBOX("The QB connection is not active, so the vendor 1099 information could not be retrieved." + ;
		               "To have the QB vendor information included on the 1099s, connect to QB, and then re-create the 1099 file." + CHR(10) + CHR(10) + ;
		               "Do you want to continue without Vendor 1099s being created?", 36, 'Vendor 1099s') = 7
		            llReturn = .F.
		            EXIT
		         ELSE
		            llQBVendor1099 = .F.
		         ENDIF
		      ENDIF
		   ENDIF
		
		   *  Eliminate blank programs, which invariable cause all WI owners to get skipped for someone each year.
		   swselect('programs')
		   SCAN FOR EMPTY(cprogcode)
		      DELETE NEXT 1
		   ENDSCAN
		
		   IF lcYear > THISFORM.cYearApproved
		      IF NOT THISFORM.oMessage.CONFIRM('The selected year has not yet been approved for 1099 processing by SherWare, Inc. ' + ;
		            'Creating the 1099 file for this year could lead to inaccurate processing and reporting.  Continue?')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   *
		   *   Fix 1099s with negative amounts and delete zero amounts and 1099's less
		   *   than the minimum
		   *
		   SELECT options
		   GO TOP
		   lnMin1099Non = nmin1099Non    && Get the minimum 1099 amount for working interest owners
		   lnMin1099Roy = nmin1099Roy    && Get the minimum 1099 amount for royalty owners
		   glHideComp   = lHideComp
		   llGross1099  = lGross1099
		   llTranExp    = THISFORM.chkExclTrans.VALUE    && Option to remove transportation revenue when used as marketing costs.
		
		   IF lnMin1099Non = 0
		      lnMin1099Non = .01
		   ENDIF
		   IF lnMin1099Roy = 0
		      lnMin1099Roy = .01
		   ENDIF
		
		   SELECT tax1099
		   COUNT FOR cYear = lcYear TO lnCount
		   SELECT tax1099det
		   COUNT FOR cYear = lcYear TO lnCountD
		   IF lnCount > 0
		      IF NOT THISFORM.oMessage.CONFIRM('The 1099 file for tax year ' + TRIM(lcYear) + ' already exists. Do you want to overwrite it?  This will eliminate any manual changes already made to the 1099 file for this year.')
		         WAIT WIND NOWAIT 'The 1099 process was cancelled...'
		         llReturn = .F.
		         EXIT
		      ELSE
		         lnProgress = 0
		         oProgress  = THISFORM.oMessage.ProgressBar('')
		         oProgress.SetProgressRange(0, lnCount + lnCountD)
		         oProgress.SetProgressMessage('Deleting Existing 1099 Records for ' + lcYear + '....')
		
		         SELECT tax1099
		         SET ORDER TO cYear   && CYEAR
		         SCAN FOR cYear = lcYear
		            oProgress.UpdateProgress(lnProgress)
		            lnProgress = lnProgress + 1
		            DELETE NEXT 1
		         ENDSCAN
		         oProgress.SetProgressMessage('Deleting Existing 1099 Detail Records for ' + lcYear + '....')
		         SELECT tax1099det
		         SET ORDER TO cYear
		         SCAN FOR cYear = lcYear
		            oProgress.UpdateProgress(lnProgress)
		            lnProgress = lnProgress + 1
		            DELETE NEXT 1
		         ENDSCAN
		         IF TYPE('oProgress') = 'O'
		            oProgress.CloseProgress()
		         ENDIF
		      ENDIF
		   ENDIF
		
		   WAIT WIND NOWAIT 'Performing 1099 setup process...'
		
		   IF llByTaxID  &&  If creating by tax ID, scan the investor file and plug in the owner ID as the tax ID, so it's unique, and can be grouped correctly.
		      WAIT WINDOW NOWAIT 'Processing blank tax ID records'
		      SELECT investor
		      SCAN FOR EMPTY(cTaxID) AND lInv1099
		         REPLACE cTaxID WITH cOwnerID
		      ENDSCAN
		      = TABLEUPDATE(.T.)
		   ENDIF
		
		   IF llByTaxID
		      lcGroupByO = 'investor.ctaxid'
		      lcGroupByV = 'vendor.ctaxid'
		   ELSE
		      lcGroupByO = 'investor.cownerid'
		      lcGroupByV = 'vendor.cvendorid'
		   ENDIF
		
		   * Correct the hdate field on released suspense
		   THIS.plughdate()
		   SET TALK ON
		   DO CASE
		      CASE llGross1099  && Gross Revenue
		         *  Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year,
		         *  which would include previous year suspense released during this year
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, (disbhist.nincome))))) AS nNonEmp, ;
		            0000000.00 AS nroyalty ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
		            OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0') IN ;
		            (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		            FROM sysctl ;
		            WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		            AND cTypeClose = 'R'))  ;
		            AND cTypeInv <> 'L'  ;
		            AND cTypeInv <> 'O' ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN ;
		            (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (disbhist.lManual = .F. OR ;
		            disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype) OR ;
		            (disbhist.lManual = .T. ;
		            AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup ;
		            NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE EMPTY(cversion) ;
		            AND cTypeClose = 'R'))) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099w READWRITE
		
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            IIF(llFlatRent,SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		            (disbhist.nincome - disbhist.nflatrate))))), ;
		            SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev ), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev ), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		            (disbhist.nincome )))))) AS nroyalty, ;
		            SUM(IIF(llFlatRent,IIF(disbhist.lflat, disbhist.nflatrate,000000.00),000000.00)) AS nrents, ;
		            0000000.00 AS nNonEmp  ;
		            FROM disbhist, investor  ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
		            OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		            AND cTypeClose = 'R'))  ;
		            AND (cTypeInv = 'L'  ;
		            OR cTypeInv = 'O')  ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND (disbhist.lManual = .F. OR ;
		            disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype) OR ;
		            (disbhist.lManual = .T. ;
		            AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup ;
		            NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE EMPTY(cversion) ;
		            AND cTypeClose = 'R'))) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099r READWRITE
		         SELECT wrk1099r
		         INDEX ON cwellid + cID TAG cID
		
		      CASE NOT llGross1099   && Net Revenue
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'N' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nnetcheck) AS nNonEmp, ;
		            disbhist.cprogcode, ;
		            0.00 AS ncompgath, ;
		            0000000.00 AS nroyalty ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T. ;
		            AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
		            OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		            AND cTypeClose = 'R'))  ;
		            AND disbhist.cTypeInv <> 'L'  ;
		            AND disbhist.cTypeInv <> 'O' ;
		            AND NOT DELETED() ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (disbhist.lManual = .F. OR ;
		            disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype) OR ;
		            (disbhist.lManual = .T. ;
		            AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup ;
		            NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE EMPTY(cversion) ;
		            AND cTypeClose = 'R'))) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099w READWRITE
		         *
		         *  Get royalty owner's net distribution
		         *
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'N' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            IIF(llFlatRent,SUM(disbhist.nnetcheck-disbhist.nflatrate),SUM(disbhist.nnetcheck)) AS nroyalty, ;
		            IIF(llFlatRent,SUM(IIF(disbhist.lflat, disbhist.nflatrate,0)),0) AS nrents, ;
		            disbhist.cprogcode, ;
		            0.00 AS ncompgath, ;
		            0000000.00 AS nNonEmp  ;
		            FROM disbhist, investor  ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND (YEAR(disbhist.hdate) = VAL(lcYear) OR ;
		            disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup ;
		            IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dAcctDate) = VAL(lcYear) ;
		            AND cTypeClose = 'R'))  ;
		            AND (disbhist.cTypeInv = 'L'  ;
		            OR disbhist.cTypeInv = 'O') ;
		            AND (disbhist.lManual = .F. OR ;
		            disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype) OR ;
		            (disbhist.lManual = .T. ;
		            AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup ;
		            NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE EMPTY(cversion) ;
		            AND cTypeClose = 'R'))) ;
		            AND NOT DELETED() ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099r READWRITE
		         SELECT wrk1099r
		         INDEX ON cwellid + cID TAG cID
		   ENDCASE
		   SET TALK OFF
		   WAIT CLEAR
		
		   *
		   *  Create vendor 1099s
		   *
		   IF NOT m.goApp.lQBVersion
		      SELECT  MAX(vendor.cVendorID)  AS cID, ;
		         checks.cidtype AS cidtype, ;
		         vendor.cvendname AS cName, ;
		         SPACE(1) AS cName2,  ;
		         lcYear AS cYear, ;
		         'N' AS cType, ;
		         SUM(checks.nAmount) AS nNonEmp, ;
		         vendor.cbaddr1 AS caddr1, ;
		         vendor.cbaddr2 AS caddr2, ;
		         vendor.cTaxID  AS cTaxID, ;
		         vendor.cbcity  AS ccity, ;
		         vendor.cbstate AS cstate, ;
		         vendor.cbzip   AS czip, ;
		         vendor.cbcountry AS ccountry, ;
		         0000000.00 AS nroyalty, ;
		         0000000.00 AS nrents ;
		         FROM checks, vendor ;
		         WHERE vendor.cVendorID = checks.cID  ;
		         AND checks.cidtype   = 'V' ;
		         AND checks.lvoid     = .F. ;
		         AND vendor.lsend1099 = .T. ;
		         AND YEAR(dcheckdate) = VAL(lcYear) ;
		         INTO CURSOR wrk1099v ;
		         GROUP BY &lcGroupByV
		   ELSE
		      IF m.goApp.oQB.QBFCVersion < ' 5.0'
		         IF THIS.oMessage.CONFIRM('You must update your QuickBooks interface in order for vendor 1099s to be processed. ' + ;
		               'QBFC needs to be at least version 5. Your version is: ' + ALLTRIM(m.goApp.oQB.QBFCVersion) + '. Download and install: support.sherware.com/download/qbfc5.exe?')
		            oLink = CREATEOBJECT('hyperlink')
		            oLink.NAVIGATETO('support.sherware.com/download/qbfc5.exe')
		         ENDIF
		      ENDIF
		
		      IF llQBVendor1099 = .T.
		         llReturn = THIS.qbvendor1099()
		         IF NOT llReturn
		            EXIT
		         ENDIF
		      ENDIF
		   ENDIF
		
		   SELE wrk1099w
		   lnMax = RECC()
		   SELE wrk1099r
		   lnMax = lnMax + RECC()
		
		   IF USED('wrk1099v')
		      SELE wrk1099v
		      lnMax = lnMax + RECC()
		   ENDIF
		
		   lnProgress = 0
		   oProgress  = THISFORM.oMessage.ProgressBar('')
		   oProgress.SetProgressRange(0, lnMax)
		
		   oProgress.SetProgressMessage('Creating Working Interest 1099 Records for ' + lcYear + '....')
		
		   SELE wrk1099w
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      IF llTranExp
		         m.nNonEmp = m.nNonEmp - m.ntrprev
		      ENDIF
		      m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		      SET DELE OFF
		      SELE tax10991
		      SET ORDER TO cidtax1
		      DO WHILE SEEK(m.cidtax1)
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		      ENDDO
		      SET DELE ON
		      IF glHideComp
		         m.nNonEmp = m.nNonEmp - m.ncompgath
		      ENDIF
		      INSERT INTO tax1099 FROM MEMVAR
		   ENDSCAN
		
		   USE IN wrk1099w
		
		
		   *
		   *  Insert Royalty records into work cursor
		   *
		   oProgress.SetProgressMessage('Creating Royalty Interest 1099 Records for ' + lcYear + '....')
		   SELECT wrk1099r
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      SELECT tax1099
		      SET ORDER TO yearwell
		      SEEK (lcYear + m.cwellid + m.cID)
		      IF FOUND()
		         IF llTranExp
		            m.nroyalty = m.nroyalty - m.ntrprev
		         ENDIF
		         REPLACE nroyalty WITH nroyalty + m.nroyalty
		      ELSE
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         SET DELE ON
		         IF llTranExp
		            m.nroyalty = m.nroyalty - m.ntrprev
		         ENDIF
		         INSERT INTO tax1099 FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Processing tax and backup withholding...')
		   *
		   *  Look for tax withholding and backup withholding
		   *
		   SELECT  cwellid, cOwnerID, SUM(nBackWith) AS nAmount ;
		      FROM disbhist ;
		      WHERE YEAR(hdate) = VAL(lcYear) ;
		      AND nBackWith <> 0;
		      INTO CURSOR tback ;
		      ORDER BY cwellid, cOwnerID ;
		      GROUP BY cwellid, cOwnerID
		
		   SELECT  disbhist.cwellid, disbhist.cOwnerID, SUM(nincome) AS nStateIncome, SUM(nTaxWith) AS nAmount, wells.cstate AS cTaxState  ;
		      FROM  disbhist, wells ;
		      WHERE YEAR(hdate) = VAL(lcYear) ;
		      AND nTaxWith <> 0 ;
		      AND disbhist.cwellid = wells.cwellid ;
		      INTO CURSOR ttax ;
		      ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		      GROUP BY disbhist.cwellid, disbhist.cOwnerID
		   SELECT tback
		   SCAN
		      SCATTER MEMVAR
		      SELECT tax1099
		      LOCATE FOR cYear = lcYear AND cwellid = m.cwellid AND cID = m.cOwnerID
		      IF FOUND()
		         REPL nFedTax WITH m.nAmount
		      ENDIF
		   ENDSCAN
		
		   SELECT ttax
		   SCAN FOR nAmount # 0
		      SCATTER MEMVAR
		      swselect('tax1099states')
		      LOCATE FOR cstate == m.cTaxState
		      IF FOUND()
		         m.cPayerNo = cPayerNo
		      ELSE
		         llReturn = .F.
		         MESSAGEBOX("There are state withholding taxes for " + m.cTaxState + " but there isn't a payer number setup for that state. " + ;
		            "Go to State Payer No Setup in the 1099 Process menu to set it up and then create the file again.", 16, 'Missing State Payer No')
		         EXIT
		      ENDIF
		      SELECT tax1099
		      IF llByTaxID
		         LOCATE FOR cYear = lcYear AND ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID) AND cwellid == m.cwellid
		      ELSE
		         LOCATE FOR cYear = lcYear AND cID = m.cOwnerID AND cwellid == m.cwellid
		      ENDIF
		      IF FOUND()
		         IF nStateTax1 = 0
		            REPL nStateTax1 WITH m.nAmount, ;
		               cTaxState1 WITH m.cTaxState, ;
		               cStatePayerNo1 WITH m.cPayerNo, ;
		               nStateIncome1 WITH m.nStateIncome
		         ELSE
		            REPL nStateTax2 WITH m.nAmount, ;
		               cTaxState2 WITH m.cTaxState, ;
		               cStatePayerNo2 WITH m.cPayerNo, ;
		               nStateIncome2 WITH m.nStateIncome
		         ENDIF
		      ENDIF
		   ENDSCAN
		   SELECT tax1099
		   SCAN FOR cYear = lcYear
		      m.cwellid = cwellid
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(m.cwellid)
		         m.cWellTax  = cwelltaxid
		         m.cwellname = cwellname
		      ELSE
		         m.cWellTax  = 'Not known'
		         m.cwellname = 'Not known'
		      ENDIF
		      SELECT tax1099
		      REPL cWellTax  WITH m.cWellTax, ;
		         cwellname WITH m.cwellname
		   ENDSCAN
		
		
		   SELECT tax1099
		   SET ORDER TO primkey
		
		   lcYear1 = STR(VAL(lcYear) + 1, 4)
		
		   IF USED('wrk1099v')
		      oProgress.SetProgressMessage('Creating Vendor 1099 Records for ' + lcYear + '....')
		      SELECT wrk1099v
		      SCAN
		         SCATTER MEMVAR
		         oProgress.UpdateProgress(lnProgress)
		         lnProgress  = lnProgress + 1
		         m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         m.cwellid   = ''
		         m.cwellname = ''
		         m.cWellTax  = ''
		         m.cYear     = lcYear
		         STORE '' TO m.cTaxState1, m.cTaxState2, m.cStatePayerNo1, m.cStatePayerNo2
		         STORE 0  TO m.nStateTax1, m.nFedTax, m.nStateTax2
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         INSERT INTO tax1099 FROM MEMVAR
		         SET DELE ON
		      ENDSCAN
		   ENDIF
		
		   IF TYPE('oProgress') = 'O'
		      oProgress.CloseProgress()
		   ENDIF
		
		   * Create the 1099DET file with the detail for the reconciliation report
		   llReturn = THISFORM.MakeFileDet()
		   IF NOT llReturn
		      EXIT
		   ENDIF
		
		   *
		   *  Check to see if we're integrated with the Accounting Manager
		   *  If so, we need to check the coa table for a rent account
		   *
		   IF TYPE('m.goApp') = 'O'
		      IF m.goApp.lAMVersion
		         WAIT WIND NOWAIT 'Processing rental 1099s...'
		         *
		         *  Calculate the rental 1099 amounts
		         *
		         CREATE CURSOR rents ;
		            (cID       C(10), ;
		            nAmount   N(12, 2))
		         SELECT coa
		         SCAN FOR lRent1099
		            m.cacctno = cacctno
		
		            SELECT  cID, SUM(nDebits - nCredits) AS nAmount ;
		               FROM glmaster ;
		               WHERE YEAR(ddate) = VAL(lcYear) ;
		               AND cacctno = m.cacctno ;
		               INTO CURSOR tmp1 ;
		               ORDER BY cID ;
		               GROUP BY cID
		
		            IF _TALLY > 0
		               SELECT rents
		               APPEND FROM DBF('tmp1')
		            ENDIF
		         ENDSCAN
		
		         SELECT  cID, SUM(nAmount) AS nAmount ;
		            FROM rents ;
		            INTO CURSOR temprent ;
		            ORDER BY cID ;
		            GROUP BY cID
		
		         SELECT tax1099
		         SET ORDER TO primkey
		         SELECT temprent
		         SCAN FOR nAmount > 0
		            STORE 0 TO m.nroyalty, m.nrents, m.nNonEmp
		            SCATTER MEMVAR
		
		            SELECT tax1099
		            IF SEEK(lcYear + m.cID)
		               REPLACE nrents WITH nrents + m.nAmount
		               IF cidtype = 'V'
		                  REPLACE nNonEmp WITH nNonEmp - m.nAmount
		               ENDIF
		            ELSE
		               m.nNonEmp  = 0
		               m.nroyalty = 0
		               SELECT vendor
		               SET ORDER TO cVendorID
		               IF SEEK(m.cID) AND lsend1099
		                  m.cName     = cvendname
		                  m.cName2    = ''
		                  m.caddr1    = cbaddr1
		                  m.caddr2    = cbaddr2
		                  m.ccity     = cbcity
		                  m.cstate    = cbstate
		                  m.czip      = cbzip
		                  m.ccountry  = cbcountry
		                  m.cTaxID    = cTaxID
		                  m.nrents    = m.nAmount
		                  m.cYear     = lcYear
		                  m.cidtype   = 'V'
		                  m.cwellid   = ''
		                  m.cwellname = ''
		                  m.cType     = IIF(llGross1099, 'G', 'N')
		                  m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  SET DELE OFF
		                  SELE tax10991
		                  SET ORDER TO cidtax1
		                  DO WHILE SEEK(m.cidtax1)
		                     m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  ENDDO
		                  SET DELE ON
		                  INSERT INTO tax1099 FROM MEMVAR
		               ELSE
		                  SELECT investor
		                  SET ORDER TO cOwnerID
		                  IF SEEK(m.cID) AND lInv1099
		                     m.cName     = cOwnName
		                     m.cName2    = cOwnName1
		                     m.caddr1    = caddress1a
		                     m.caddr2    = caddress1b
		                     m.ccity     = ccity1
		                     m.cstate    = cstate1
		                     m.czip      = czip1
		                     m.ccountry  = ccountry1
		                     m.cTaxID    = cTaxID
		                     m.nrents    = m.nAmount
		                     m.cYear     = lcYear
		                     m.cwellid   = ''
		                     m.cwellname = ''
		                     m.cidtype   = 'I'
		                     m.cType     = IIF(llGross1099, 'G', 'N')
		                     m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     SET DELE OFF
		                     SELE tax10991
		                     SET ORDER TO cidtax1
		                     DO WHILE SEEK(m.cidtax1)
		                        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     ENDDO
		                     SET DELE ON
		                     INSERT INTO tax1099 FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDSCAN
		      ELSE
		         SELECT  checks.cID  AS cID, ;
		            checks.cidtype  AS cidtype, ;
		            checks.cpayee   AS cName, ;
		            lcYear          AS cYear, ;
		            IIF(llGross1099, 'G', 'N') AS cType, ;
		            SUM(checks.nAmount) AS nrents, ;
		            investor.caddress1a AS caddr1, ;
		            investor.caddress1b AS caddr2, ;
		            investor.cOwnName1 AS cName2,  ;
		            investor.cTaxID     AS cTaxID, ;
		            investor.ccity1  AS ccity, ;
		            investor.cstate1 AS cstate, ;
		            investor.czip1   AS czip, ;
		            investor.ccountry1 AS ccountry, ;
		            0000000.00 AS nroyalty, ;
		            0000000.00 AS nNonEmp  ;
		            FROM checks, investor ;
		            WHERE investor.cOwnerID = checks.cID  ;
		            AND checks.cidtype   = 'I' ;
		            AND checks.csource   = 'LM' ;
		            AND checks.lvoid     = .F. ;
		            AND investor.lInv1099 = .T. ;
		            AND investor.ldummy = .F. ;
		            AND YEAR(dcheckdate) = VAL(lcYear) ;
		            INTO CURSOR wrk1099 ;
		            GROUP BY cID
		
		         IF _TALLY > 0
		            SELE wrk1099
		            SCAN
		               SCATTER MEMVAR
		               m.cwellid   = ''
		               m.cwellname = ''
		               m.nNonEmp   = 0
		               m.nroyalty  = 0
		               SELECT tax1099
		               SET ORDER TO yearwell
		               SEEK (lcYear + m.cwellid + m.cID)
		               IF FOUND()
		                  REPLACE nrents WITH nrents + m.nrents
		               ELSE
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  SET DELE OFF
		                  SELE tax10991
		                  SET ORDER TO cidtax1
		                  DO WHILE SEEK(m.cidtax1)
		                     m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  ENDDO
		                  SET DELE ON
		                  m.cYear = lcYear
		                  INSERT INTO tax1099 FROM MEMVAR
		               ENDIF
		            ENDSCAN
		         ENDIF
		      ENDIF
		   ENDIF
		
		   WAIT WINDOW NOWAIT 'Cleaning Up 1099 Detail File...'
		   SELECT temp1099det
		   SCAN FOR cYear = lcYear
		      IF nincome = 0 AND nexpense = 0 AND nsevtaxes = 0
		         DELETE NEXT 1
		      ELSE
		         IF (nincome - nexpense - nrents - nsevtaxes <> nnetcheck) AND nnetcheck = 0
		            * Only doing the adjustment if calculating on gross
		            IF llGross1099
		               SELECT tax1099
		               IF llByTaxID
		                  LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(temp1099det.cTaxID) AND cYear = lcYear
		               ELSE
		                  LOCATE FOR cID = temp1099det.cID AND cYear = lcYear
		               ENDIF
		               IF FOUND()
		                  IF temp1099det.cRptGroup = 'W'
		                     REPLACE nNonEmp WITH nNonEmp - temp1099det.nincome
		                  ELSE
		                     REPLACE nroyalty WITH nroyalty - temp1099det.nincome
		                  ENDIF
		                  SELECT temp1099det
		                  DELETE NEXT 1
		               ENDIF
		            ELSE
		               DELETE NEXT 1
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   *  Clean up the 1099 file.  There should be no "Dummy"
		   *  owners in the file,  There should also not be any
		   *  negative numbers.  If any are found, deleted them.
		   *
		   WAIT WIND NOWAIT 'Performing 1099 cleanup...'
		   SELECT tax1099
		   SCAN FOR cYear = lcYear
		      SCATTER MEMVAR
		      IF m.nroyalty < 0
		         REPLACE nroyalty WITH 0
		      ENDIF
		      IF m.nrents < 0
		         REPLACE nrents WITH 0
		      ENDIF
		      IF m.nNonEmp < 0
		         REPLACE nNonEmp WITH 0
		      ENDIF
		      IF m.nFedTax < 0
		         REPLACE nFedTax WITH 0
		      ENDIF
		      IF m.nStateTax1 < 0
		         REPLACE nStateTax1 WITH 0
		      ENDIF
		      IF m.nStateTax2 < 0
		         REPLACE nStateTax2 WITH 0
		      ENDIF
		      IF m.nroyalty = 0 AND m.nrents = 0 AND m.nFedTax = 0 AND m.nStateTax1 = 0 AND m.nStateTax2 = 0 AND m.nNonEmp  = 0
		         DELETE NEXT 1
		         IF m.cidtype = 'I'
		            SELECT temp1099det
		            DELETE FOR cID == m.cID AND cYear == m.cYear AND cwellid = m.cwellid
		         ENDIF
		      ENDIF
		      IF lnMin1099Non > 0
		         SELECT tax1099
		         IF m.nNonEmp < lnMin1099Non AND m.nroyalty < lnMin1099Roy AND m.nrents < lnMin1099Non
		            DELETE NEXT 1
		            IF m.cidtype = 'I'
		               SELECT temp1099det
		               DELETE FOR cID == m.cID AND cYear == m.cYear AND cwellid = m.cwellid
		            ENDIF
		         ENDIF
		         IF m.nrents < lnMin1099Non AND m.nroyalty < lnMin1099Roy AND m.nNonEmp < lnMin1099Non
		            DELETE NEXT 1
		            IF m.cidtype = 'I'
		               SELECT temp1099det
		               DELETE FOR cID == m.cID AND cYear == m.cYear AND cwellid = m.cwellid
		            ENDIF
		         ENDIF
		      ENDIF
		      IF lnMin1099Roy > 0
		         SELECT tax1099
		         IF m.nroyalty < lnMin1099Roy AND m.nrents < lnMin1099Non AND m.nNonEmp < lnMin1099Non
		            DELETE NEXT 1
		            IF m.cidtype = 'I'
		               SELECT temp1099det
		               DELETE FOR cID == m.cID AND cYear == m.cYear AND cwellid = m.cwellid
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		
		   **  If we're not building by tax ID, compare cid between tax1099 and temp1099det and delete any detail records
		   **  without a corresponding 1099.  Otherwise, compare ctaxid
		   IF NOT llByTaxID
		      SELECT  cID ;
		         FROM temp1099det WITH (BUFFERING = .T.) ;
		         WHERE cYear = lcYear  ;
		         AND cID NOT IN (SELECT  cID ;
		         FROM tax1099 ;
		         WHERE cYear = lcYear) ;
		         INTO CURSOR no1099 ;
		         ORDER BY cID ;
		         GROUP BY cID
		
		      ** Remove detail records for owners with no 1099
		      SELECT no1099
		      SCAN
		         m.cID = cID
		         SELECT temp1099det
		         SCAN FOR cYear + cID == lcYear + m.cID
		            DELETE NEXT 1
		         ENDSCAN
		      ENDSCAN
		   ELSE
		      **  By tax ID, so compare ctaxid fields to determine whether to remove the temp1099det records
		      SELECT  cTaxID ;
		         FROM temp1099det WITH (BUFFERING = .T.) ;
		         WHERE cYear = lcYear  ;
		         AND cTaxID NOT IN (SELECT  cTaxID ;
		         FROM tax1099 ;
		         WHERE cYear = lcYear) ;
		         INTO CURSOR no1099 ;
		         ORDER BY cTaxID ;
		         GROUP BY cTaxID
		
		      ** Remove detail records for owners with no 1099
		      SELECT no1099
		      SCAN
		         m.cTaxID = ALLTRIM(cTaxID)
		         SELECT temp1099det
		         SCAN FOR cYear + ALLTRIM(cTaxID) == lcYear + ALLTRIM(m.cTaxID)
		            DELETE NEXT 1
		         ENDSCAN
		      ENDSCAN
		
		      *  Make sure the temp1099det file has names/addresses that match tax1099.  Since we're grouping by tax ID,
		      *  the detail records have the name/address that corresponds with that specific interest
		      WAIT WINDOW NOWAIT 'Cleaning up 1099 Detail File by Tax ID'
		      SELECT tax1099
		      SCAN FOR cYear = lcYear AND cidtype = 'I'
		         SCATTER MEMVAR
		         SELECT temp1099det
		         SCAN FOR cTaxID == m.cTaxID AND cYear = lcYear
		            REPLACE cID WITH m.cID, cName WITH m.cName, cName2 WITH m.cName2, caddr1 WITH m.caddr1,  ;
		               caddr2 WITH m.caddr2, ccity WITH m.ccity, cstate WITH m.cstate, czip WITH m.czip
		         ENDSCAN
		      ENDSCAN
		      WAIT CLEAR
		   ENDIF
		
		   ** Clean up expense to make sure the records foot across
		   SELECT temp1099det
		   SCAN FOR cYear == lcYear
		      lnDiff = (nincome - nexpense - nsevtaxes - nRents - nStateTax1 - nStateTax2 - nFedTax - ncompgath) - nnetcheck
		      IF  lnDiff <> 0
		         IF lnDiff > 0
		            IF nexpense - lnDiff < 0
		               REPLACE nexpense WITH 0
		               IF nsevtaxes - lnDiff < 0
		                  REPLACE nincome WITH nincome - lnDiff
		               ELSE
		                  REPLACE nsevtaxes WITH nsevtaxes - lnDiff
		               ENDIF
		            ELSE
		               REPLACE nexpense WITH nexpense - lnDiff
		            ENDIF
		         ELSE
		            IF nexpense + lnDiff < 0
		               REPLACE nexpense WITH 0
		               IF nsevtaxes + lnDiff < 0
		                  REPLACE nincome WITH nincome + lnDiff
		               ELSE
		                  REPLACE nsevtaxes WITH nsevtaxes + lnDiff
		               ENDIF
		            ELSE
		               REPLACE nexpense WITH nexpense + lnDiff
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   SELECT tax1099
		   SCAN FOR cTaxID = cID AND cYear = lcYear
		      REPLACE cTaxID WITH ''
		   ENDSCAN
		
		   SELECT temp1099det
		   SCAN FOR cTaxID = cID
		      REPLACE cTaxID WITH ''
		   ENDSCAN
		
		   SELECT tax1099
		   TABLEUPDATE(.T.)
		   SELECT tax1099det
		   APPEND FROM DBF('temp1099det')
		   TABLEUPDATE(.T.)
		
		   IF llByTaxID  &&  If creating by tax ID, scan the investor file and plug in the owner ID as the tax ID, so it's unique, and can be grouped correctly.
		      WAIT WINDOW NOWAIT 'Cleaning up blank tax ID records'
		      SELECT investor
		      SCAN FOR cTaxID = cOwnerID AND lInv1099
		         REPLACE cTaxID WITH ''
		      ENDSCAN
		      TABLEUPDATE(.T.)
		   ENDIF
		
		   lnState = 0
		
		   WAIT CLEAR
		
		   SELECT tax1099
		   COUNT FOR cYear = lcYear AND NOT DELETED() TO lnCount
		
		   *  Display the total number of 1099 records created.
		   MESSAGEBOX('Finished Processing 1099s for ' + lcYear + CHR(10) + CHR(10) + ;
		      'Created ' + ALLTRIM(TRANSFORM(lnCount, '999,999')) + ' Federal 1099s ' + ;
		      IIF(lnState # 0, ' and ' + ALLTRIM(TRANSFORM(lnState, '999,999')) + ' State 1099s ', ''), 64, '1099 Processing Counts')
		   swclose('temprent')
		   swclose('tmp1')
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildData', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		   IF VARTYPE(oProgress) = 'O'
		      oProgress.CloseProgress()
		   ENDIF
		   MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		oProgress = .NULL.
		
		RETURN llReturn
		
		
		
		
		
		
	ENDPROC

	PROCEDURE makefiledet
		LOCAL lnCount, lcYear, oProgress, lcYear, llByWell
		LOCAL lcGroupByO, lcID, lcScanFor, lcYear1, llFound, llGross1099, llReturn, llTranExp, lnDiff, lnMax
		LOCAL lnMin1099Non, lnMin1099Roy, lnProgress, lnRecNo, loError
		
		llReturn = .T.
		
		TRY
		    lcYear   = THISFORM.txtcYear.VALUE
		    lnCount  = 0
		    llByWell = THISFORM.chklByWell.VALUE
		
		    make_copy('tax1099det','temp1099det')
		    SELECT temp1099det
		    INDEX on CYEAR+CID+CWELLID+crptgroup TAG yrowngrp 
		    INDEX on cyear+ctaxid+cwellid+crptgroup TAG yrtaxgrp
		    INDEX on cyear+cid+cwellid TAG primkey
		    INDEX on cyear TAG cyear
		    INDEX on cyear+cid TAG cid
		    
		    SELECT options
		    GO TOP
		    lnMin1099Non = nmin1099Non    && Get the minimum 1099 amount for working interest owners
		    lnMin1099Roy = nmin1099Roy    && Get the minimum 1099 amount for royalty owners
		    glHideComp   = lHideComp
		    llGross1099  = lGross1099
		    llTranExp    = THISFORM.chkExclTrans.VALUE    && Option to remove transportation revenue when used as marketing costs.
		    llFlatRent = THISFORM.chkflatRates.VALUE
		
		    IF lnMin1099Non = 0
		        lnMin1099Non = .01
		    ENDIF
		    IF lnMin1099Roy = 0
		        lnMin1099Roy = .01
		    ENDIF
		
		    IF THISFORM.chkTaxID.VALUE
		        lcGroupByO = 'investor.ctaxid,disbhist.cwellid'
		    ELSE
		        lcGroupByO = 'investor.cownerid,disbhist.cwellid'
		    ENDIF
		
		    WAIT WIND NOWAIT 'Building Working Interest Detail File...'
		    SET TALK ON
			SELECT  MAX(disbhist.cOwnerID) AS cID, ;
					disbhist.cwellid, ;
					'I' AS cidtype, ;
					lcYear AS cYear, ;
					IIF(llGross1099, 'G', 'N') AS cType, ;
					cWellName,  ;
					wells.cstate AS ctaxstate, ;
					investor.cOwnName AS cName, ;
					investor.cOwnName1 AS cName2,  ;
					IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
					IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
					IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
					IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
					IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
					investor.ctaxid, ;
					disbhist.cprogcode, ;
					'W' AS cRptGroup,  ;
					SUM(disbhist.nothrev) AS nothrev, ;
					SUM(disbhist.ntrprev) AS ntrprev, ;
					SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
					SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
						  IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
							IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, (disbhist.nincome))))) AS nincome, ;
					SUM(nExpense + nTotalE1 + nTotalE2 + nTotalE3 + nTotalE4 + nTotalE5 + nTotaleB + nTotaleA + nMktgExp) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					0000000.00 as nrents, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nTaxWith) AS nStateTax,  ;
					SUM(nBackWith) AS nFedTax,  ;
					SUM(nNetCheck) AS nNetCheck  ;
			   FROM disbhist, investor, wells ;
			   WHERE disbhist.cOwnerID = investor.cOwnerID   ;
				   AND disbhist.cwellid = wells.cwellid  ;
				   AND investor.linv1099 = .T.  ;
				   AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
					 OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
					 (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
						 FROM sysctl ;
						 WHERE YEAR(dAcctDate) = VAL(lcYear) ;
							 AND cTypeClose = 'R'))  ;
				   AND cTypeInv = 'W'  ;
				   AND crectype = 'R' ;
				   AND investor.ldummy = .F. ;
				   AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
													 FROM programs ;
													 WHERE lprog1099 = .F.) ;
				   AND (disbhist.lManual = .F. OR ;
					 disbhist.lManual = .T. ;
					 AND EMPTY(disbhist.csusptype) OR ;
					 (disbhist.lManual = .T. ;
					   AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup ;
					   NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
								  FROM sysctl ;
								  WHERE EMPTY(cversion) ;
									  AND cTypeClose = 'R'))) ;
			   ORDER BY &lcGroupByO  ;
			   GROUP BY &lcGroupByO  ;
			   INTO CURSOR temp READWRITE
		
		    WAIT WINDOW NOWAIT 'Building Royalty Interest Detail File'
			SELECT  MAX(disbhist.cOwnerID) AS cID, ;
					disbhist.cwellid, ;
					'I' AS cidtype, ;
					lcYear AS cYear, ;
					IIF(llGross1099, 'G', 'N') AS cType, ;
					cWellName,  ;
					wells.cstate AS ctaxstate, ;
					investor.cOwnName AS cName, ;
					investor.cOwnName1 AS cName2,  ;
					IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
					IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
					IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
					IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
					IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
					investor.ctaxid, ;
					disbhist.cprogcode, ;
					'R' AS cRptGroup,  ;
					SUM(disbhist.nothrev) AS nothrev, ;
					SUM(disbhist.ntrprev) AS ntrprev, ;
					SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
					SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
						  IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
							IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
							   (disbhist.nincome ))))) AS nincome, ;
		            SUM(IIF(disbhist.lflat, disbhist.nflatrate,000000.00)) as nRents, ;					   
					SUM(nExpense + nTotalE1 + nTotalE2 + nTotalE3 + nTotalE4 + nTotalE5 + nTotaleB + nTotaleA + nMktgExp) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nTaxWith) AS nStateTax,  ;
					SUM(nBackWith) AS nFedTax,  ;
					SUM(nNetCheck) AS nNetCheck  ;
			   FROM disbhist, investor, wells  ;
			   WHERE disbhist.cOwnerID = investor.cOwnerID   ;
				   AND disbhist.cwellid = wells.cwellid  ;
				   AND (YEAR(disbhist.hdate) = VAL(lcYear) ;
					 OR disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
					 (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
						 FROM sysctl ;
						 WHERE YEAR(dAcctDate) = VAL(lcYear) ;
							 AND cTypeClose = 'R'))  ;
				   AND cTypeInv # 'W'  ;
				   AND crectype = 'R' ;
				   AND investor.ldummy = .F. ;
				   AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
													 FROM programs ;
													 WHERE lprog1099 = .F.) ;
				   AND (disbhist.lManual = .F. OR ;
					 disbhist.lManual = .T. ;
					 AND EMPTY(disbhist.csusptype) OR ;
					 (disbhist.lManual = .T. ;
					   AND disbhist.crunyear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+Disbhist.cgroup ;
					   NOT IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
								  FROM sysctl ;
								  WHERE EMPTY(cversion) ;
									  AND cTypeClose = 'R'))) ;
			   ORDER BY &lcGroupByO  ;
			   GROUP BY &lcGroupByO  ;
			   INTO CURSOR wrk1099r READWRITE
		    SELECT wrk1099r
		    INDEX ON cwellid + cID TAG cID
		
		*  In these cursors, even though they're grouped by ctaxid, there could be multiple owner IDs.
		*  If an owner has the same tax ID as another, but the first owner is the only one in a specific
		*  well, then there's no way it could have the other ID code on it.  They'll need cleaned up
		*  and merged by tax ID.
		
		    IF THISFORM.chkTaxID.VALUE
		*  Get a unique list of the tax IDs and the ID code we want associated with it
		        WAIT WINDOW NOWAIT 'Summarizing Data by Tax ID...'
				SELECT  ctaxid, MAX(cID) AS cID  ;
				   FROM temp  ;
				   INTO CURSOR temp1 READWRITE  ;
				   GROUP BY ctaxid
		
				SELECT  ctaxid, MAX(cID) AS cID  ;
				   FROM wrk1099r  ;
				   INTO CURSOR wrk1099r1  ;
				   GROUP BY ctaxid
		
		*  We want a master list of the tax IDs and the ID code to associate with it in one place.
		*  Now we can scan both cursors and update the ID code
		        SELECT temp1
		        APPEND FROM DBF('wrk1099r1')
		
		*  In case the owner ID in wrk1099r1 cursor was higher than the one in the WI cursor,
		*  we need to re-merge them from the master list
				SELECT  ctaxid, MAX(cID) AS cID ;
				   FROM temp1  ;
				   INTO CURSOR temp2  ;
				   GROUP BY ctaxid
		
		        SELECT temp2
		        SCAN
		            SCATTER MEMVAR
		            SELECT temp
		            SCAN FOR ALLTRIM(ctaxid) = ALLTRIM(m.ctaxid)
		                REPLACE cID WITH m.cID
		            ENDSCAN
		            SELECT wrk1099r
		            SCAN FOR ALLTRIM(ctaxid) = ALLTRIM(m.ctaxid)
		                REPLACE cID WITH m.cID
		            ENDSCAN
		        ENDSCAN
		    ENDIF
		
		    SET TALK OFF
		    WAIT CLEAR
		
		    SELE temp
		    lnMax = RECC()
		    SELE wrk1099r
		    lnMax = lnMax + RECC()
		
		    SELECT temp1099det
		
		    lnProgress = 0
		    oProgress  = THISFORM.oMessage.ProgressBar('')
		    oProgress.SetProgressRange(0, lnMax)
		
		    swselect('programs')
		
		    oProgress.SetProgressMessage('Creating Detail 1099 Records for ' + lcYear + '....')
		    SELE temp
		    SCAN
		        SCATTER MEMVAR
		        oProgress.UpdateProgress(lnProgress)
		        lnProgress = lnProgress + 1
		
		* Don't include programs that don't get 1099s
		        IF NOT EMPTY(m.cprogcode)
		            SELECT programs
		            LOCATE FOR cprogcode == m.cprogcode
		            IF FOUND() AND lprog1099 = .F.
		                LOOP
		            ENDIF
		        ENDIF
		
		        IF llTranExp
		            m.nincome  = m.nincome + (m.ntrprev * -1)
		            m.nExpense = m.nExpense + (m.ntrprev * -1)
		        ENDIF
		       
		        IF glHideComp
		            m.nNonEmp = m.nNonEmp - m.ncompgath
		        ENDIF
		        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		        INSERT INTO temp1099det FROM MEMVAR
		    ENDSCAN
		    SELECT temp
		    USE
		
		*
		*  Insert Royalty records into work cursor
		*
		    SELECT temp1099det
		    SET ORDER TO yrowngrp   && CYEAR+CID+CWELLID+crptgroup
		    
		    lcBuffer1 = SYS(3050,1)
		    lcBuffer2 = SYS(3050,2)
		    SYS(3050,1, 16000000)
		    SYS(3050,2, 16000000)
		    oProgress.SetProgressMessage('Creating Royalty Detail 1099 Records for ' + lcYear + '....')
		    SELECT wrk1099r
		    SCAN
		        SCATTER MEMVAR
		        oProgress.UpdateProgress(lnProgress)
		        lnProgress = lnProgress + 1
		
		* Don't include programs that don't get 1099s
		        IF NOT EMPTY(m.cprogcode)
		            SELECT programs
		            LOCATE FOR cprogcode == m.cprogcode
		            IF FOUND() AND lprog1099 = .F.
		                LOOP
		            ENDIF
		        ENDIF
		        
		        SELECT temp1099det
		        IF THISFORM.chkTaxID.VALUE = .T.
		            SET ORDER TO yrtaxgrp   && CYEAR+CTAXID+CWELLID+crptgroup
		            IF SEEK(lcYear + m.ctaxid + m.cwellid + m.cRptGroup)
		                IF llTranExp
		                    m.nincome  = m.nincome + (m.ntrprev * -1)
		                    m.nExpense = m.nExpense + (m.ntrprev * -1)
		                ENDIF
		                
		                IF NOT llFlatRent
		                   m.nIncome = m.nIncome + m.nRents
		                   m.nRents = 0
		                ELSE
		                   m.nIncome = m.nIncome - m.nRents
		                ENDIF 
		                REPLACE nincome WITH m.nincome, ;
		                    nExpense WITH m.nExpense, ;
		                    nRents   WITH m.nRents
		            ELSE
		                IF llTranExp
		                    m.nincome  = m.nincome + (m.ntrprev * -1)
		                    m.nExpense = m.nExpense + (m.ntrprev * -1)
		                ENDIF
		                IF NOT llFlatRent
		                   m.nIncome = m.nIncome + m.nRents
		                   m.nRents = 0
		                ELSE
		                   m.nIncome = m.nIncome - m.nRents   
		                ENDIF 
		                m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                INSERT INTO temp1099det FROM MEMVAR
		            ENDIF
		        ELSE
		            SELECT temp1099det
		            IF SEEK(lcYear + m.cID + m.cwellid + m.cRptGroup)
		                IF llTranExp
		                    m.nincome  = m.nincome + (m.ntrprev * -1)
		                    m.nExpense = m.nExpense + (m.ntrprev * -1)
		                ENDIF
		                IF NOT llFlatRent
		*                   m.nIncome = m.nIncome + m.nRents
		                   m.nRents = 0
		                ELSE
		                   m.nIncome = m.nIncome - m.nRents   
		                ENDIF 
		                REPLACE nincome WITH m.nincome, ;
		                    nExpense WITH m.nExpense, ;
		                    nRents   WITH m.nRents
		            ELSE
		                IF llTranExp
		                    m.nincome  = m.nincome + (m.ntrprev * -1)
		                    m.nExpense = m.nExpense + (m.ntrprev * -1)
		                ENDIF
		                IF NOT llFlatRent
		*                   m.nIncome = m.nIncome + m.nRents
		                   m.nRents = 0
		                ELSE
		                   m.nIncome = m.nIncome - m.nRents   
		                ENDIF 
		                m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                INSERT INTO temp1099det FROM MEMVAR
		            ENDIF
		        ENDIF
		    ENDSCAN
		
		    oProgress.CloseProgress()
		    lcYear1 = STR(VAL(lcYear) + 1, 4)
		
		    IF m.goapp.lAMVersion
		        WAIT WIND NOWAIT 'Processing Detail Rental 1099s...'
		
		*  Calculate the rental 1099 amounts
		        swclose('rents')
		        SET TALK ON
				SELECT  cID, cacctno, cunitno, ndebits, ncredits ;
				   FROM glmaster ;
				   INTO CURSOR tempgl READWRITE ;
				   WHERE cYear = lcYear
		        INDEX ON cacctno TAG cacctno
		
				SELECT  cID, cunitno, SUM(ndebits - ncredits) AS nAmount ;
				   FROM tempgl ;
				   WHERE cacctno IN (SELECT  cacctno ;
										FROM coa ;
										WHERE lrent1099) ;
				   INTO CURSOR temprent READWRITE ;
				   ORDER BY cID, cunitno ;
				   GROUP BY cID, cunitno
		        SET TALK OFF
		
		        lnProgress = 0
		        oProgress  = THISFORM.oMessage.ProgressBar('')
		        oProgress.SetProgressRange(0, RECCOUNT('temprent'))
		        oProgress.SetProgressMessage('Creating Rental Detail Records for ' + lcYear + '....')
		
		        SELECT vendor
		        SET ORDER TO cVendorID
		        SELECT investor
		        SET ORDER TO cOwnerID
		
		        IF RECCOUNT('temprent') > 0
		            SELECT temp1099det
		            SET ORDER TO PRIMKEY
		            SELECT temprent
		            SCAN FOR nAmount > 0
		                STORE 0 TO m.nroyalty, m.nRents, m.nNonEmp
		                SCATTER MEMVAR
		
		                oProgress.UpdateProgress(lnProgress)
		                lnProgress = lnProgress + 1
		
		                SELECT vendor
		                IF SEEK(m.cID) AND lsend1099
		                    m.cName   = cvendname
		                    m.cName2  = ''
		                    m.caddr1  = cbaddr1
		                    m.caddr2  = cbaddr2
		                    m.ccity   = cbcity
		                    m.cstate  = cbstate
		                    m.czip    = cbzip
		                    m.ctaxid  = ctaxid
		                    m.nincome = m.nAmount
		                    m.nRents  = m.nAmount
		                    STORE 0 TO m.nExpense, m.ntrprev, m.ncompgath, m.nSevTaxes, m.nStateTax, m.nBackWith, m.nFedTax
		                    m.nNetCheck = m.nAmount
		                    m.cYear     = lcYear
		                    m.cidtype   = 'V'
		                    swselect('wells')
		                    SET ORDER TO cwellid
		                    IF SEEK(m.cwellid)
		                        m.cWellName = cWellName
		                        m.ctaxstate = cstate
		                    ELSE
		                        swselect('land')
		                        SET ORDER TO cleaseid
		                        IF SEEK(m.cwellid)
		                            m.cWellName = cLeaseName
		                            m.ctaxstate = cstate
		                        ELSE
		                            m.cWellName = ''
		                            m.ctaxstate = ''
		                        ENDIF
		                    ENDIF
		                    m.cRptGroup = 'N'
		                    m.cType     = IIF(llGross1099, 'G', 'N')
		                    m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                    INSERT INTO temp1099det FROM MEMVAR
		                ELSE
		                    SELECT investor
		                    IF SEEK(m.cID) AND linv1099
		                        m.cName   = cOwnName
		                        m.cName2  = cOwnName1
		                        m.caddr1  = caddress1a
		                        m.caddr2  = caddress1b
		                        m.ccity   = ccity1
		                        m.cstate  = cstate1
		                        m.czip    = czip1
		                        m.ctaxid  = ctaxid
		                        m.nincome = m.nAmount
		                        m.nRents  = m.nAmount
		                        STORE 0 TO m.nExpense, m.ntrprev, m.ncompgath, m.nSevTaxes, m.nStateTax, m.nBackWith, m.nFedTax
		                        m.nNetCheck = m.nAmount
		                        m.cYear     = lcYear
		                        swselect('wells')
		                        SET ORDER TO cwellid
		                        IF SEEK(m.cwellid)
		                            m.cWellName = cWellName
		                            m.ctaxstate = cstate
		                        ELSE
		                            swselect('land')
		                            SET ORDER TO cleaseid
		                            IF SEEK(m.cwellid)
		                                m.cWellName = cLeaseName
		                                m.ctaxstate = cstate
		                            ELSE
		                                m.cWellName = ''
		                                m.ctaxstate = ''
		                            ENDIF
		                        ENDIF
		                        m.cidtype   = 'I'
		                        m.cRptGroup = 'N'
		                        m.cType     = IIF(llGross1099, 'G', 'N')
		                        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                        INSERT INTO temp1099det FROM MEMVAR
		                    ENDIF
		                ENDIF
		            ENDSCAN
		        ENDIF
		    ENDIF
		
		    WAIT CLEAR
		
		    IF TYPE('oProgress') = 'O'
		*  Some people get an error here.  Can't re-create, so just trap it and move on.
		        TRY
		            oProgress.CloseProgress()
		        CATCH
		        ENDTRY
		    ENDIF
		
		*  If by well, plug in the well tax ID
		    IF llByWell
		        SELECT wells
		        SET ORDER TO cwellid
		        SELECT temp1099det
		        SCAN
		            SELECT wells
		            IF SEEK(temp1099det.cwellid)
		                SELECT temp1099det
		                REPLACE cWellTax WITH wells.cwelltaxid
		            ENDIF
		        ENDSCAN
		    ENDIF
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'MakeFileDet', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		    IF VARTYPE(oProgress) = 'O'
		        oProgress.CloseProgress()
		    ENDIF
		    MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		oProgress = .NULL.
		RETURN llReturn
	ENDPROC

	PROCEDURE makefiledetearned		&& Reports only what was earned during the year.
		LOCAL lnCount, lcYear, oProgress, lcYear, llByWell
		LOCAL lcGroupByO, lcGroupByOS, lcID, lcScanFor, lcYear1, llFound, llGross1099, llReturn, llTranExp
		LOCAL lnDiff, lnMax, lnMin1099Non, lnMin1099Roy, lnProgress, lnRecNo, loError
		
		llReturn = .T.
		
		TRY
		    lcYear   = THISFORM.txtcYear.VALUE
		    lnCount  = 0
		    llByWell = THISFORM.chklByWell.VALUE
		    
		    make_copy('tax1099det','temp1099det')
		    SELECT temp1099det
		    INDEX on CYEAR+CID+CWELLID+crptgroup TAG yrowngrp 
		    INDEX on cyear+ctaxid+cwellid+crptgroup TAG yrtaxgrp
		    INDEX on cyear+cid+cwellid TAG primkey
		    INDEX on cyear TAG cyear
		    INDEX on cyear+cid TAG cid
		     
		    SELECT options
		    GO TOP
		    lnMin1099Non = nmin1099Non    && Get the minimum 1099 amount for working interest owners
		    lnMin1099Roy = nmin1099Roy    && Get the minimum 1099 amount for royalty owners
		    glHideComp   = lHideComp
		    llGross1099  = lGross1099
		    llTranExp    = THISFORM.chkExclTrans.VALUE    && Option to remove transportation revenue when used as marketing costs.
		
		    IF lnMin1099Non = 0
		        lnMin1099Non = .01
		    ENDIF
		    IF lnMin1099Roy = 0
		        lnMin1099Roy = .01
		    ENDIF
		
		    IF THISFORM.chkTaxID.VALUE
		        lcGroupByO  = 'investor.ctaxid,disbhist.cwellid'
		        lcGroupByOS = 'investor.ctaxid,suspense.cwellid'
		    ELSE
		        lcGroupByO  = 'investor.cownerid,disbhist.cwellid'
		        lcGroupByOS = 'investor.cownerid,suspense.cwellid'
		    ENDIF
		
		    WAIT WIND NOWAIT 'Building Working Interest Detail File...'
		    SET TALK ON
			SELECT  disbhist.cOwnerID, ;
					disbhist.cwellid, ;
					'I' AS cidtype, ;
					lcYear AS cYear, ;
					IIF(llGross1099, 'G', 'N') AS cType, ;
					cWellName,  ;
					investor.cOwnName AS cName, ;
					investor.cOwnName1 AS cName2,  ;
					IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
					IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
					IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
					IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
					IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
					investor.ctaxid + SPACE(5) AS ctaxid, ;
					disbhist.cprogcode, ;
					'W' AS cRptGroup,  ;
					SUM(disbhist.ntrprev) AS ntrprev, ;
					SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
					SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
						  IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
							IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, (disbhist.nincome))))) AS nincome, ;
					SUM(nExpense + nTotalE1 + nTotalE2 + nTotalE3 + nTotalE4 + nTotalE5 + nTotaleB + nTotaleA + nMktgExp) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nTaxWith) AS nStateTax,  ;
					SUM(nBackWith) AS nBackWith,  ;
					000000.00 as nrents, ;
					SUM(nNetCheck) AS nNetCheck  ;
			   FROM disbhist, investor, wells ;
			   WHERE disbhist.cOwnerID = investor.cOwnerID   ;
				   AND disbhist.cwellid = wells.cwellid  ;
				   AND investor.linv1099 = .T.  ;
				   AND (disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup ;
					 IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
							FROM sysctl ;
							WHERE YEAR(dAcctDate) = VAL(lcYear) ;
								AND cTypeClose = 'R'))  ;
				   AND EMPTY(csusptype) ;
				   AND cTypeInv <> 'L'  ;
				   AND cTypeInv <> 'O' ;
				   AND investor.ldummy = .F. ;
				   AND cRecType = 'R'  ;
				   AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
													 FROM programs ;
													 WHERE lprog1099 = .F.) ;
				   AND (disbhist.lManual = .F. OR ;
					 (disbhist.lManual = .T. ;
					   AND EMPTY(disbhist.csusptype) ;
					   AND cRecType # 'P')) ;
				   AND (disbhist.nrunno # 0 OR ;
					 (disbhist.nrunno = 0 ;
					   AND disbhist.hdate IN (SELECT  dcheckdate ;
												 FROM checks ;
												 WHERE cID = disbhist.cOwnerID))) ;
			   ORDER BY &lcGroupByO  ;
			   GROUP BY &lcGroupByO  ;
			   INTO CURSOR temp_work READWRITE
		
			SELECT  disbhist.cOwnerID, ;
					disbhist.cwellid, ;
					'I' AS cidtype, ;
					lcYear AS cYear, ;
					IIF(llGross1099, 'G', 'N') AS cType, ;
					cWellName,  ;
					investor.cOwnName AS cName, ;
					investor.cOwnName1 AS cName2,  ;
					IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
					IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
					IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
					IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
					IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
					investor.ctaxid + SPACE(5) AS ctaxid, ;
					disbhist.cprogcode, ;
					'W' AS cRptGroup,  ;
					SUM(disbhist.ntrprev) AS ntrprev, ;
					SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
					SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
						  IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
							IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, (disbhist.nincome))))) AS nincome, ;
					SUM(nExpense + nTotalE1 + nTotalE2 + nTotalE3 + nTotalE4 + nTotalE5 + nTotaleB + nTotaleA + nMktgExp) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nTaxWith) AS nStateTax,  ;
					SUM(nBackWith) AS nBackWith,  ;
					SUM(nNetCheck) AS nNetCheck,  ;
					000000.00 as nrents ;
			   FROM disbhist, investor, wells ;
			   WHERE disbhist.cOwnerID = investor.cOwnerID   ;
				   AND disbhist.cwellid = wells.cwellid  ;
				   AND investor.linv1099 = .T.  ;
				   AND NOT EMPTY(csusptype) ;
				   AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
					 (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
						 FROM sysctl ;
						 WHERE YEAR(dAcctDate) = VAL(lcYear)));
				   AND cTypeInv <> 'L'  ;
				   AND cTypeInv <> 'O' ;
				   AND investor.ldummy = .F. ;
				   AND cRecType = 'R'  ;
				   AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
													 FROM programs ;
													 WHERE lprog1099 = .F.) ;
				   AND (disbhist.lManual = .F. OR ;
					 (disbhist.lManual = .T. ;
					   AND EMPTY(disbhist.csusptype) ;
					   AND cRecType # 'P')) ;
				   AND (disbhist.nrunno # 0 OR ;
					 (disbhist.nrunno = 0 ;
					   AND disbhist.hdate IN (SELECT  dcheckdate ;
												 FROM checks ;
												 WHERE cID = disbhist.cOwnerID))) ;
			   ORDER BY &lcGroupByO  ;
			   GROUP BY &lcGroupByO  ;
			   INTO CURSOR temp_works1 READWRITE
		
			SELECT  suspense.cOwnerID, ;
					suspense.cwellid, ;
					'I' AS cidtype, ;
					lcYear AS cYear, ;
					IIF(llGross1099, 'G', 'N') AS cType, ;
					cWellName,  ;
					investor.cOwnName AS cName, ;
					investor.cOwnName1 AS cName2,  ;
					IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
					IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
					IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
					IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
					IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
					investor.ctaxid + SPACE(5) AS ctaxid, ;
					suspense.cprogcode, ;
					'W' AS cRptGroup,  ;
					SUM(suspense.ntrprev) AS ntrprev, ;
					SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
					SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev), ;
						  IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev), ;
							IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, (suspense.nincome))))) AS nincome, ;
					SUM(nExpense + nTotalE1 + nTotalE2 + nTotalE3 + nTotalE4 + nTotalE5 + nTotaleB + nTotaleA + nMktgExp) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nTaxWith) AS nStateTax,  ;
					SUM(nBackWith) AS nBackWith,  ;
					SUM(nNetCheck) AS nNetCheck,  ;
					000000.00 as nrents ;
			   FROM suspense, investor, wells ;
			   WHERE suspense.cOwnerID = investor.cOwnerID   ;
				   AND suspense.cwellid = wells.cwellid  ;
				   AND investor.linv1099 = .T.  ;
				   AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
					 (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
						 FROM sysctl ;
						 WHERE YEAR(dAcctDate) = VAL(lcYear)));
				   AND cTypeInv <> 'L'  ;
				   AND cTypeInv <> 'O' ;
				   AND investor.ldummy = .F. ;
				   AND cRecType = 'R'  ;
				   AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
													 FROM programs ;
													 WHERE lprog1099 = .F.) ;
				   AND (suspense.lManual = .F. OR ;
					 (suspense.lManual = .T. ;
					   AND EMPTY(suspense.csusptype) ;
					   AND cRecType # 'P')) ;
				   AND (suspense.nrunno # 0 OR ;
					 (suspense.nrunno = 0 ;
					   AND suspense.hdate IN (SELECT  dcheckdate ;
												 FROM checks ;
												 WHERE cID = suspense.cOwnerID))) ;
			   ORDER BY &lcGroupByOS  ;
			   GROUP BY &lcGroupByOS  ;
			   INTO CURSOR temp_works2 READWRITE
		
		    SELECT temp_works1
		    APPEND FROM DBF('temp_work')
		    APPEND FROM DBF('temp_works2')
		
		    WAIT WINDOW NOWAIT 'Building Royalty Interest Detail File'
			SELECT  disbhist.cOwnerID, ;
					disbhist.cwellid, ;
					'I' AS cidtype, ;
					lcYear AS cYear, ;
					IIF(llGross1099, 'G', 'N') AS cType, ;
					cWellName,  ;
					investor.cOwnName AS cName, ;
					investor.cOwnName1 AS cName2,  ;
					IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
					IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
					IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
					IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
					IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
					investor.ctaxid + SPACE(5) AS ctaxid, ;
					disbhist.cprogcode, ;
					'R' AS cRptGroup,  ;
					SUM(disbhist.ntrprev) AS ntrprev, ;
					SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
					SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
						  IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
							IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
							  (disbhist.nincome - disbhist.nflatrate))))) AS nincome, ;
					SUM(IIF(disbhist.lflat, disbhist.nflatrate,000000.00)) as nRents, ;			  
					SUM(nExpense + nTotalE1 + nTotalE2 + nTotalE3 + nTotalE4 + nTotalE5 + nTotaleB + nTotaleA + nMktgExp) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nTaxWith) AS nStateTax,  ;
					SUM(nBackWith) AS nBackWith,  ;
					SUM(nNetCheck) AS nNetCheck  ;
			   FROM disbhist, investor, wells  ;
			   WHERE disbhist.cOwnerID = investor.cOwnerID   ;
				   AND disbhist.cwellid = wells.cwellid  ;
				   AND cRecType = 'R'  ;
				   AND investor.linv1099 = .T.  ;
				   AND EMPTY(csusptype) ;
				   AND (disbhist.crunyear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup ;
					 IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
							FROM sysctl ;
							WHERE YEAR(dAcctDate) = VAL(lcYear) ;
								AND cTypeClose = 'R'))  ;
				   AND (cTypeInv = 'L'  ;
					 OR cTypeInv = 'O')  ;
				   AND investor.ldummy = .F. ;
				   AND (disbhist.lManual = .F.;
					 OR (disbhist.lManual = .T. ;
					   AND EMPTY(disbhist.csusptype) ;
					   AND cRecType # 'P')) ;
				   AND (disbhist.nrunno # 0 OR ;
					 (disbhist.nrunno = 0 ;
					   AND disbhist.hdate IN (SELECT  dcheckdate ;
												 FROM checks ;
												 WHERE cID = disbhist.cOwnerID))) ;
			   ORDER BY &lcGroupByO  ;
			   GROUP BY &lcGroupByO  ;
			   INTO CURSOR temp_roy READWRITE
		    SELECT temp_roy
		    INDEX ON cwellid + cOwnerID TAG cID
		
			SELECT  disbhist.cOwnerID, ;
					disbhist.cwellid, ;
					'I' AS cidtype, ;
					lcYear AS cYear, ;
					IIF(llGross1099, 'G', 'N') AS cType, ;
					cWellName,  ;
					investor.cOwnName AS cName, ;
					investor.cOwnName1 AS cName2,  ;
					IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
					IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
					IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
					IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
					IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
					investor.ctaxid + SPACE(5) AS ctaxid, ;
					disbhist.cprogcode, ;
					'R' AS cRptGroup,  ;
					SUM(disbhist.ntrprev) AS ntrprev, ;
					SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
					SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
						  IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
							IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
							  (disbhist.nincome - disbhist.nflatrate))))) AS nincome, ;
					SUM(IIF(disbhist.lflat, disbhist.nflatrate,000000.00)) as nRents, ;
					SUM(nExpense + nTotalE1 + nTotalE2 + nTotalE3 + nTotalE4 + nTotalE5 + nTotaleB + nTotaleA + nMktgExp) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nTaxWith) AS nStateTax,  ;
					SUM(nBackWith) AS nBackWith,  ;
					SUM(nNetCheck) AS nNetCheck  ;
			   FROM disbhist, investor, wells  ;
			   WHERE disbhist.cOwnerID = investor.cOwnerID   ;
				   AND disbhist.cwellid = wells.cwellid  ;
				   AND cRecType = 'R'  ;
				   AND investor.linv1099 = .T.  ;
				   AND NOT EMPTY(csusptype) ;
				   AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
					 (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
						 FROM sysctl ;
						 WHERE YEAR(dAcctDate) = VAL(lcYear)));
				   AND (cTypeInv = 'L'  ;
					 OR cTypeInv = 'O')  ;
				   AND investor.ldummy = .F. ;
				   AND (disbhist.lManual = .F.;
					 OR (disbhist.lManual = .T. ;
					   AND EMPTY(disbhist.csusptype) ;
					   AND cRecType # 'P')) ;
				   AND (disbhist.nrunno # 0 OR ;
					 (disbhist.nrunno = 0 ;
					   AND disbhist.hdate IN (SELECT  dcheckdate ;
												 FROM checks ;
												 WHERE cID = disbhist.cOwnerID))) ;
			   ORDER BY &lcGroupByO  ;
			   GROUP BY &lcGroupByO  ;
			   INTO CURSOR temp_roys1 READWRITE
		    SELECT temp_roys1
		    INDEX ON cwellid + cOwnerID TAG cID
		
			SELECT  suspense.cOwnerID, ;
					suspense.cwellid, ;
					'I' AS cidtype, ;
					lcYear AS cYear, ;
					IIF(llGross1099, 'G', 'N') AS cType, ;
					cWellName,  ;
					investor.cOwnName AS cName, ;
					investor.cOwnName1 AS cName2,  ;
					IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
					IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
					IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
					IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
					IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
					investor.ctaxid + SPACE(5) AS ctaxid, ;
					suspense.cprogcode, ;
					'R' AS cRptGroup,  ;
					SUM(suspense.ntrprev) AS ntrprev, ;
					SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
					SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev - suspense.nflatrate), ;
						  IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev - suspense.nflatrate), ;
							IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, ;
							   (suspense.nincome - suspense.nflatrate))))) AS nincome, ;
					SUM(IIF(suspense.lflat, suspense.nflatrate,000000.00)) as nRents, ;
					SUM(nExpense + nTotalE1 + nTotalE2 + nTotalE3 + nTotalE4 + nTotalE5 + nTotaleB + nTotaleA + nMktgExp) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nTaxWith) AS nStateTax,  ;
					SUM(nBackWith) AS nBackWith,  ;
					SUM(nNetCheck) AS nNetCheck  ;
			   FROM suspense, investor, wells  ;
			   WHERE suspense.cOwnerID = investor.cOwnerID   ;
				   AND suspense.cwellid = wells.cwellid  ;
				   AND cRecType = 'R'  ;
				   AND investor.linv1099 = .T.  ;
				   AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
					 (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
						 FROM sysctl ;
						 WHERE YEAR(dAcctDate) = VAL(lcYear)));
				   AND (cTypeInv = 'L'  ;
					 OR cTypeInv = 'O')  ;
				   AND investor.ldummy = .F. ;
				   AND (suspense.lManual = .F.;
					 OR (suspense.lManual = .T. ;
					   AND EMPTY(suspense.csusptype) ;
					   AND cRecType # 'P')) ;
				   AND (suspense.nrunno # 0 OR ;
					 (suspense.nrunno = 0 ;
					   AND suspense.hdate IN (SELECT  dcheckdate ;
												 FROM checks ;
												 WHERE cID = suspense.cOwnerID))) ;
			   ORDER BY &lcGroupByOS  ;
			   GROUP BY &lcGroupByOS  ;
			   INTO CURSOR temp_roys2 READWRITE
		    SELECT temp_roys2
		    INDEX ON cwellid + cOwnerID TAG cID
		
		    SELECT temp_roys1
		    APPEND FROM DBF('temp_roy')
		    APPEND FROM DBF('temp_roys2')
		
		    IF THISFORM.chkTaxID.VALUE
		        lcGroupByO  = 'ctaxid, cwellid'
		        lcGroupByOS = 'ctaxid, cwellid'
		    ELSE
		        lcGroupByO  = 'cownerid, cwellid'
		        lcGroupByOS = 'cownerid, cwellid'
		    ENDIF
		
		* Combine all by either owner id or tax id
			SELECT  MAX(cOwnerID) AS cID, ;
					cwellid, ;
					cidtype, ;
					cYear, ;
					cType, ;
					cWellName,  ;
					cName, cName2, caddr1, caddr2, ccity, cstate, czip, ctaxid, ;
					temp_roys1.cprogcode, ;
					cRptGroup,  ;
					SUM(ntrprev) AS ntrprev, ;
					SUM(ncompgath) AS ncompgath, ;
					SUM(nincome) AS nincome, ;
					SUM(nrents) as nrents, ;
					SUM(nExpense) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nStateTax) AS nStateTax,  ;
					SUM(nBackWith) AS nBackWith,  ;
					SUM(nNetCheck) AS nNetCheck  ;
			   FROM temp_works1 ;
			   ORDER BY &lcGroupByO  ;
			   GROUP BY &lcGroupByO  ;
			   INTO CURSOR temp_work READWRITE
		
			SELECT  MAX(cOwnerID) AS cID, ;
					cwellid, ;
					cidtype, ;
					cYear, ;
					cType, ;
					cWellName,  ;
					cName, cName2, caddr1, caddr2, ccity, cstate, czip, ctaxid, ;
					temp_roys1.cprogcode, ;
					cRptGroup,  ;
					SUM(ntrprev) AS ntrprev, ;
					SUM(ncompgath) AS ncompgath, ;
					SUM(nincome) AS nincome, ;
					SUM(nrents) as nrents, ;
					SUM(nExpense) AS nExpense,  ;
					SUM(nPlugExp) as nPlugExp, ;
					SUM(nSevTaxes) AS nSevTaxes,  ;
					SUM(nStateTax) AS nStateTax,  ;
					SUM(nBackWith) AS nBackWith,  ;
					SUM(nNetCheck) AS nNetCheck  ;
			   FROM temp_roys1 ;
			   ORDER BY &lcGroupByO  ;
			   GROUP BY &lcGroupByO  ;
			   INTO CURSOR temp_roy READWRITE
		
		    SET TALK OFF
		    WAIT CLEAR
		
		    SELE temp_work
		    lnMax = RECC()
		
		    SELE temp_roy
		    lnMax = lnMax + RECC()
		
		    lnProgress = 0
		    oProgress  = THISFORM.oMessage.ProgressBar('')
		    oProgress.SetProgressRange(0, lnMax)
		
		    swselect('programs')
		
		    oProgress.SetProgressMessage('Creating Detail 1099 Records for ' + lcYear + '....')
		    SELE temp_work
		    SCAN
		        SCATTER MEMVAR
		        oProgress.UpdateProgress(lnProgress)
		        lnProgress = lnProgress + 1
		
		* Don't include programs that don't get 1099s
		        IF NOT EMPTY(m.cprogcode)
		            SELECT programs
		            LOCATE FOR cprogcode == m.cprogcode
		            IF FOUND() AND lprog1099 = .F.
		                LOOP
		            ENDIF
		        ENDIF
		
		        IF llTranExp
		            m.nincome = m.nincome - m.ntrprev
		        ENDIF
		        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		        IF glHideComp
		            m.nNonEmp = m.nNonEmp - m.ncompgath
		        ENDIF
		        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		        INSERT INTO temp1099det FROM MEMVAR
		    ENDSCAN
		
		
		    USE IN temp_work
		    USE IN temp_works1
		    USE IN temp_works2
		
		
		*
		*  Insert Royalty records into work cursor
		*
		    oProgress.SetProgressMessage('Creating Royalty Detail 1099 Records for ' + lcYear + '....')
		    SELECT temp_roy
		    SCAN
		        SCATTER MEMVAR
		        oProgress.UpdateProgress(lnProgress)
		        lnProgress = lnProgress + 1
		
		* Don't include programs that don't get 1099s
		        IF NOT EMPTY(m.cprogcode)
		            SELECT programs
		            LOCATE FOR cprogcode == m.cprogcode
		            IF FOUND() AND lprog1099 = .F.
		                LOOP
		            ENDIF
		        ENDIF
		
		        SELECT temp1099det
		        IF THISFORM.chkTaxID.VALUE = .T.
		            SET ORDER TO yrtaxgrp   && CYEAR+CTAXID+CWELLID+crptgroup
		            IF SEEK(lcYear + m.ctaxid + m.cwellid + m.cRptGroup)
		                IF llTranExp
		                    m.nincome = m.nincome - m.ntrprev
		                ENDIF
		                REPLACE nincome WITH nincome + m.nincome
		            ELSE
		                m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                IF llTranExp
		                    m.nincome = m.nincome - m.ntrprev
		                ENDIF
		                m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                INSERT INTO temp1099det FROM MEMVAR
		            ENDIF
		        ELSE
		            SET ORDER TO yrowngrp   && CYEAR+CID+CWELLID+crptgroup
		            IF SEEK(lcYear + m.cID + m.cwellid + m.cRptGroup)
		                IF llTranExp
		                    m.nincome = m.nincome - m.ntrprev
		                ENDIF
		                REPLACE nincome WITH nincome + m.nincome
		            ELSE
		                m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                
		                IF llTranExp
		                    m.nincome = m.nincome - m.ntrprev
		                ENDIF
		                m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                INSERT INTO temp1099det FROM MEMVAR
		            ENDIF
		        ENDIF
		    ENDSCAN
		
		    oProgress.closeprogress()
		    lcYear1 = STR(VAL(lcYear) + 1, 4)
		
		    IF m.goapp.lAMVersion
		        WAIT WIND NOWAIT 'Processing Detail Rental 1099s...'
		*
		*  Calculate the rental 1099 amounts
		*
		        IF USED('rents')
		            USE IN rents
		        ENDIF
		
		        CREATE CURSOR rents ;
		            (cID       C(10), ;
		              cunitno   C(10), ;
		              nAmount   N(12, 2))
		        SELECT coa
		        SCAN FOR lRent1099
		            m.cacctno = cacctno
		
					SELECT  cID, SUM(nDebits - nCredits) AS nAmount ;
					   FROM glmaster ;
					   WHERE YEAR(ddate) = VAL(lcYear) ;
						   AND cacctno = m.cacctno ;
					   INTO CURSOR tmp1 ;
					   ORDER BY cID, cunitno ;
					   GROUP BY cID, cunitno
		
		            IF _TALLY > 0
		                SELECT rents
		                APPEND FROM DBF('tmp1')
		            ENDIF
		        ENDSCAN
		
				SELECT  cID, cunitno AS cwellid, SUM(nAmount) AS nAmount ;
				   FROM rents ;
				   INTO CURSOR temprent ;
				   ORDER BY cID, cunitno ;
				   GROUP BY cID, cunitno
		
		        lnProgress = 0
		        oProgress  = THISFORM.oMessage.ProgressBar('')
		        oProgress.SetProgressRange(0, RECCOUNT('temprent'))
		
		        oProgress.SetProgressMessage('Creating Rental Detail Records for ' + lcYear + '....')
		
		        SELECT temp1099det
		        SET ORDER TO PRIMKEY
		        SELECT temprent
		        SCAN FOR nAmount > 0
		            STORE 0 TO m.nroyalty, m.nRents, m.nincome
		            SCATTER MEMVAR
		
		            oProgress.UpdateProgress(lnProgress)
		            lnProgress = lnProgress + 1
		
		            SELECT temp1099det
		            SELECT vendor
		            SET ORDER TO cVendorID
		            IF SEEK(m.cID) AND lsend1099
		                m.cName   = cvendname
		                m.cName2  = ''
		                m.caddr1  = cbaddr1
		                m.caddr2  = cbaddr2
		                m.ccity   = cbcity
		                m.cstate  = cbstate
		                m.czip    = cbzip
		                m.ctaxid  = ctaxid
		                m.nincome = m.nAmount
		                m.nRents  = m.nAmount
		                STORE 0 TO m.nExpense, m.ntrprev, m.ncompgath, m.nSevTaxes, m.nStateTax, m.nBackWith, m.nFedTax
		                m.nNetCheck = m.nAmount
		                m.cYear     = lcYear
		                m.cidtype   = 'V'
		                swselect('wells')
		                SET ORDER TO cwellid
		                IF SEEK(m.cwellid)
		                    m.cWellName = cWellName
		                ELSE
		                    swselect('land')
		                    SET ORDER TO cleaseid
		                    IF SEEK(m.cwellid)
		                        m.cWellName = cLeaseName
		                    ELSE
		                        m.cWellName = ''
		                    ENDIF
		                ENDIF
		                m.cRptGroup = 'N'
		                m.cType     = IIF(llGross1099, 'G', 'N')
		                m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                INSERT INTO temp1099det FROM MEMVAR
		            ELSE
		                SELECT investor
		                SET ORDER TO cOwnerID
		                IF SEEK(m.cID) AND linv1099
		                    m.cName   = cOwnName
		                    m.cName2  = cOwnName1
		                    m.caddr1  = caddress1a
		                    m.caddr2  = caddress1b
		                    m.ccity   = ccity1
		                    m.cstate  = cstate1
		                    m.czip    = czip1
		                    m.ctaxid  = ctaxid
		                    m.nincome = m.nAmount
		                    m.nRents  = m.nAmount
		                    STORE 0 TO m.nExpense, m.ntrprev, m.ncompgath, m.nSevTaxes, m.nStateTax, m.nBackWith, m.nFedTax
		                    m.nNetCheck = m.nAmount
		                    m.cYear     = lcYear
		                    m.cidtype   = 'V'
		                    swselect('wells')
		                    SET ORDER TO cwellid
		                    IF SEEK(m.cwellid)
		                        m.cWellName = cWellName
		                    ELSE
		                        swselect('land')
		                        SET ORDER TO cleaseid
		                        IF SEEK(m.cwellid)
		                            m.cWellName = cLeaseName
		                        ELSE
		                            m.cWellName = ''
		                        ENDIF
		                    ENDIF
		                    m.cidtype   = 'I'
		                    m.cRptGroup = 'N'
		                    m.cType     = IIF(llGross1099, 'G', 'N')
		                    m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                    INSERT INTO temp1099det FROM MEMVAR
		                ENDIF
		            ENDIF
		        ENDSCAN
		    ENDIF
		
		*  If by well, plug in the well tax ID
		    IF llByWell
		        SELECT wells
		        SET ORDER TO cwellid
		        SELECT temp1099det
		        SCAN
		            SELECT wells
		            IF SEEK(temp1099det.cwellid)
		                SELECT temp1099det
		                REPLACE cWellTax WITH wells.cWellTaxID
		            ENDIF
		        ENDSCAN
		    ENDIF
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'MakeFileDetEarned', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		    IF VARTYPE(oProgress) = 'O'
		        oProgress.closeprogress()
		    ENDIF
		    MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		oProgress = .NULL.
		RETURN llReturn
	ENDPROC

	PROCEDURE makefileearned		&& Reports the amounts earned during the year excluding suspense from prior years.
		LOCAL lnAdj
		LOCAL oLink AS 'hyperlink'
		LOCAL lByWell, lcGroupByO, lcGroupByV, lcYear1, llGross1099, llReturn, llTranExp, lnCountD, lnDiff
		LOCAL lnMax, lnMin1099Non, lnMin1099Roy, lnProgress, loError, llQBVendor1099
		
		llReturn       = .T.
		llQBVendor1099 = .T.
		
		TRY
		   SET DELETED ON
		   *
		   *  Creates the 1099 file for the given year
		   *
		   LOCAL lnCount, lcYear, oProgress, lcYear, m.lByWell, llByTaxID
		
		   lcYear    = THISFORM.txtcYear.VALUE
		   m.lByWell = THISFORM.chklByWell.VALUE
		   llByTaxID = THISFORM.chkTaxID.VALUE
		   llFlatRent = THISFORM.chkflatRates.VALUE
		   lnCount   = 0
		
		   IF NOT THISFORM.oMessage.CONFIRM('Are you sure you want to create the 1099 file for ' + ALLTRIM(lcYear) + '?')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   *  Eliminate blank programs, which invariable cause all WI owners to get skipped for someone each year.
		   swselect('programs')
		   SCAN FOR EMPTY(cprogcode)
		      DELETE NEXT 1
		   ENDSCAN
		
		   IF m.goApp.lQBVersion
		      IF NOT m.goApp.lQBActive
		         IF MESSAGEBOX("The QB connection is not active, so the vendor 1099 information could not be retrieved." + ;
		               "To have the QB vendor information included on the 1099s, connect to QB, and then re-create the 1099 file." + CHR(10) + CHR(10) + ;
		               "Do you want to continue without Vendor 1099s being created?", 36, 'Vendor 1099s') = 7
		            llReturn = .F.
		            EXIT
		         ELSE
		            llQBVendor1099 = .F.
		         ENDIF
		      ENDIF
		   ENDIF
		
		   IF lcYear > THISFORM.cYearApproved
		      IF NOT THISFORM.oMessage.CONFIRM('The selected year has not yet been approved for 1099 processing by SherWare, Inc.  Creating the 1099 file for this year could lead to inaccurate processing and reporting.  Continue?')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   *
		   *   Fix 1099s with negative amounts and delete zero amounts and 1099's less
		   *   than the minimum
		   *
		   SELECT options
		   GO TOP
		   lnMin1099Non = nmin1099Non    && Get the minimum 1099 amount for working interest owners
		   lnMin1099Roy = nmin1099Roy    && Get the minimum 1099 amount for royalty owners
		   glHideComp   = lHideComp
		   llGross1099  = lGross1099
		   llTranExp    = THISFORM.chkExclTrans.VALUE    && Option to remove transportation revenue when used as marketing costs.
		
		   IF lnMin1099Non = 0
		      lnMin1099Non = .01
		   ENDIF
		   IF lnMin1099Roy = 0
		      lnMin1099Roy = .01
		   ENDIF
		
		   SELECT tax1099
		   COUNT FOR cYear = lcYear TO lnCount
		   SELECT tax1099det
		   COUNT FOR cYear = lcYear TO lnCountD
		   IF lnCount > 0
		      IF NOT THISFORM.oMessage.CONFIRM('The 1099 file for tax year ' + TRIM(lcYear) + ' already exists. Do you want to overwrite it?  This will eliminate any manual changes already made to the 1099 file for this year.')
		         WAIT WIND NOWAIT 'The 1099 process was cancelled...'
		         llReturn = .F.
		         EXIT
		      ELSE
		         lnProgress = 0
		         oProgress  = THISFORM.oMessage.ProgressBar('')
		         oProgress.SetProgressRange(0, lnCount + lnCountD)
		         oProgress.SetProgressMessage('Deleting Existing 1099 Records for ' + lcYear + '....')
		
		         SELECT tax1099
		         SET ORDER TO cYear   && CYEAR
		         SCAN FOR cYear = lcYear
		            oProgress.UpdateProgress(lnProgress)
		            lnProgress = lnProgress + 1
		            DELETE NEXT 1
		         ENDSCAN
		         oProgress.SetProgressMessage('Deleting Existing 1099 Detail Records for ' + lcYear + '....')
		         SELECT tax1099det
		         SET ORDER TO cYear
		         SCAN FOR cYear = lcYear
		            oProgress.UpdateProgress(lnProgress)
		            lnProgress = lnProgress + 1
		            DELETE NEXT 1
		         ENDSCAN
		         IF TYPE('oProgress') = 'O'
		            oProgress.CloseProgress()
		         ENDIF
		      ENDIF
		   ENDIF
		
		   WAIT WIND NOWAIT 'Performing 1099 setup process...'
		
		   IF llByTaxID  &&  If creating by tax ID, scan the investor file and plug in the owner ID as the tax ID, so it's unique, and can be grouped correctly.
		      WAIT WINDOW NOWAIT 'Processing blank tax ID records'
		      SELECT investor
		      SCAN FOR EMPTY(cTaxID) AND lInv1099
		         REPLACE cTaxID WITH cOwnerID
		      ENDSCAN
		      = TABLEUPDATE(.T.)
		   ENDIF
		
		   IF llByTaxID
		      lcGroupByO = 'investor.ctaxid'
		      lcGroupByV = 'vendor.ctaxid'
		   ELSE
		      lcGroupByO = 'investor.cownerid'
		      lcGroupByV = 'vendor.cvendorid'
		   ENDIF
		
		   * Correct the hdate field on released suspense
		   THIS.plughdate()
		
		   SET TALK ON
		   DO CASE
		      CASE llGross1099  && Gross Revenue
		         IF NOT m.lByWell
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, disbhist.nincome)))) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND EMPTY(disbhist.csusptype) ;
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype))) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099w READWRITE
		            SELECT wrk1099w
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, disbhist.nincome)))) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(disbhist.csusptype) ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype))) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099ws READWRITE
		            SELECT wrk1099ws
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(suspense.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               suspense.cprogcode, ;
		               IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(suspense.ntrprev) AS ntrprev, ;
		               SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		               SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev), ;
		               IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev), ;
		               IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, suspense.nincome)))) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM suspense, investor ;
		               WHERE suspense.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		                          FROM programs ;
		                          WHERE lprog1099 = .F.) ;
		               AND (suspense.lManual = .F. OR ;
		                    (suspense.lManual = .T. AND EMPTY(suspense.csusptype))) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099wss READWRITE
		            SELECT wrk1099wss
		            INDEX ON cID TAG cID
		
		            * Get both the entries with a valid hdate on them, plus any entry with a run that had a 
		            * valid date on it from this year, which would include previous year suspense released during this year
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
		               IIF(disbhist.cDirect = 'B', disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		               (disbhist.nincome - disbhist.nflatrate))))), ;
		               SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev ), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev ), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		               (disbhist.nincome )))))) AS nroyalty, ;
		               IIF(llFlatRent,SUM(disbhist.nflatrate),000000.00) AS nrents, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nNonEmp ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND EMPTY(disbhist.csusptype) ;
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype))) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099r READWRITE
		            SELECT wrk1099r
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		               (disbhist.nincome - disbhist.nflatrate))))), ;
		               SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev ), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev ), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		               (disbhist.nincome )))))) AS nroyalty, ;
		               IIF(llFlatRent,SUM(disbhist.nflatrate),000000.00) AS nrents, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nNonEmp ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(disbhist.csusptype) ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype))) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099rs READWRITE
		            SELECT wrk1099rs
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(suspense.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               suspense.cprogcode, ;
		               IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(suspense.ntrprev) AS ntrprev, ;
		               SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev - suspense.nflatrate), ;
		               IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev - suspense.nflatrate), ;
		               IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, ;
		               (suspense.nincome - suspense.nflatrate))))), ;
		               SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev ), ;
		               IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev ), ;
		               IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, ;
		               (suspense.nincome )))))) AS nroyalty, ;
		               IIF(llFlatRent,SUM(suspense.nflatrate),000000.00) AS nrents, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nNonEmp ;
		               FROM suspense, investor ;
		               WHERE suspense.cOwnerID = investor.cOwnerID   ;
		                 AND investor.lInv1099 = .T.  ;
		                 AND NOT EMPTY(suspense.csusptype) ;
		                 AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		                       (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		                            FROM sysctl ;
		                            WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		                      FROM programs ;
		                      WHERE lprog1099 = .F.) ;
		               AND (suspense.lManual = .F. OR ;
		                   (suspense.lManual = .T. ;
		               AND EMPTY(suspense.csusptype))) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099rss READWRITE
		            SELECT wrk1099rss
		            INDEX ON cID TAG cID
		
		         ELSE  &&  By Well
		
		            *  Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year, which would include previous year suspense released during this year
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               disbhist.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, disbhist.nincome)))) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		                 AND investor.lInv1099 = .T.  ;
		                 AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		                   (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		                 AND EMPTY(disbhist.csusptype) ;
		                 AND cTypeInv <> 'L'  ;
		                 AND cTypeInv <> 'O' ;
		                 AND crectype = 'R' ;
		                 AND investor.ldummy = .F. ;
		                 AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype))) ;
		               ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		               GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		               INTO CURSOR wrk1099w READWRITE
		            SELECT wrk1099w
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               disbhist.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, disbhist.nincome)))) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(disbhist.csusptype) ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype))) ;
		               ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		               GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		               INTO CURSOR wrk1099ws READWRITE
		            SELECT wrk1099ws
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(suspense.cOwnerID) AS cID, ;
		               suspense.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               suspense.cprogcode, ;
		               IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(suspense.ntrprev) AS ntrprev, ;
		               SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		               SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev), ;
		               IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev), ;
		               IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, suspense.nincome)))) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM suspense, investor ;
		               WHERE suspense.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (suspense.lManual = .F. OR ;
		               (suspense.lManual = .T. ;
		               AND EMPTY(suspense.csusptype))) ;
		               ORDER BY suspense.cwellid, suspense.cOwnerID ;
		               GROUP BY suspense.cwellid, suspense.cOwnerID ;
		               INTO CURSOR wrk1099wss READWRITE
		            SELECT wrk1099wss
		            INDEX ON cID TAG cID
		
		            * Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year, which would include previous year suspense released during this year
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               disbhist.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		               (disbhist.nincome - disbhist.nflatrate))))), ;
		               SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev ), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev ), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		               (disbhist.nincome )))))) AS nroyalty, ;
		               IIF(llFlatRent,SUM(disbhist.nflatrate),000000.00) AS nrents, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nNonEmp ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND EMPTY(disbhist.csusptype) ;
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype))) ;
		               ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		               GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		               INTO CURSOR wrk1099r READWRITE
		            SELECT wrk1099r
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               disbhist.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		               (disbhist.nincome - disbhist.nflatrate))))), ;
		               SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev ), ;
		               IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev ), ;
		               IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		               (disbhist.nincome )))))) AS nroyalty, ;
		               IIF(llFlatRent,SUM(disbhist.nflatrate),000000.00) AS nrents, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nNonEmp ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(disbhist.csusptype) ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype) AND crectype # 'P')) ;
		               ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		               GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		               INTO CURSOR wrk1099rs READWRITE
		            SELECT wrk1099rs
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(suspense.cOwnerID) AS cID, ;
		               suspense.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               suspense.cprogcode, ;
		               IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(suspense.ntrprev) AS ntrprev, ;
		               SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev - suspense.nflatrate), ;
		               IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev - suspense.nflatrate), ;
		               IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, ;
		               (suspense.nincome - suspense.nflatrate))))), ;
		               SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev ), ;
		               IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev ), ;
		               IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, ;
		               (suspense.nincome )))))) AS nroyalty, ;
		               IIF(llFlatRent,SUM(suspense.nflatrate),000000.00) AS nrents, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nNonEmp ;
		               FROM suspense, investor ;
		               WHERE suspense.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(suspense.csusptype) ;
		               AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (suspense.lManual = .F. OR ;
		               (suspense.lManual = .T. ;
		               AND EMPTY(suspense.csusptype) AND crectype # 'P')) ;
		               ORDER BY suspense.cwellid, suspense.cOwnerID ;
		               GROUP BY suspense.cwellid, suspense.cOwnerID ;
		               INTO CURSOR wrk1099rss READWRITE
		            SELECT wrk1099rss
		            INDEX ON cID TAG cID
		         ENDIF
		
		      CASE NOT llGross1099   && Net Revenue
		         IF NOT m.lByWell
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(nNetCheck) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND EMPTY(disbhist.csusptype) ;
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype) AND crectype # 'P')) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099w READWRITE
		            SELECT wrk1099w
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(nNetCheck) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(disbhist.csusptype) ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype) AND crectype # 'P')) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099ws READWRITE
		            SELECT wrk1099ws
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(suspense.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               suspense.cprogcode, ;
		               IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(suspense.ntrprev) AS ntrprev, ;
		               SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		               SUM(nNetCheck) AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               0000000.00 AS nroyalty ;
		               FROM suspense, investor ;
		               WHERE suspense.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (suspense.lManual = .F. OR ;
		               (suspense.lManual = .T. ;
		               AND EMPTY(suspense.csusptype) AND crectype # 'P')) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099wss READWRITE
		            SELECT wrk1099wss
		            INDEX ON cID TAG cID
		
		            * Get both the entries with a valid hdate on them, plus any entry with a run that 
		            * had a valid date on it from this year, which would include previous year suspense released during this year
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(disbhist.nNetCheck-disbhist.nflatrate),SUM(disbhist.nNetCheck)) AS nroyalty, ;
		               IIF(llFlatRent,SUM(disbhist.nflatrate),0) AS nrents, ;
		               0000000.00 AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND EMPTY(disbhist.csusptype) ;
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype) AND crectype # 'P')) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099r READWRITE
		            SELECT wrk1099r
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(disbhist.nNetCheck-disbhist.nflatrate),SUM(disbhist.nNetCheck)) AS nroyalty, ;
		               IIF(llFlatRent,SUM(disbhist.nflatrate),0) AS nrents, ;
		               0000000.00 AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(disbhist.csusptype) ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0') +cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (disbhist.lManual = .F. OR ;
		               (disbhist.lManual = .T. ;
		               AND EMPTY(disbhist.csusptype) AND crectype # 'P')) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099rs READWRITE
		            SELECT wrk1099rs
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(suspense.cOwnerID) AS cID, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               suspense.cprogcode, ;
		               IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(suspense.ntrprev) AS ntrprev, ;
		               SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		               IIF(llFlatRent,SUM(suspense.nNetCheck-suspense.nflatrate),SUM(suspense.nNetCheck)) AS nroyalty, ;
		               IIF(llFlatRent,SUM(suspense.nflatrate),0) AS nrents, ;
		               0000000.00 AS nNonEmp, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax ;
		               FROM suspense, investor ;
		               WHERE suspense.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(suspense.csusptype) ;
		               AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               AND (suspense.lManual = .F. OR ;
		               (suspense.lManual = .T. ;
		               AND EMPTY(suspense.csusptype) AND crectype # 'P')) ;
		               ORDER BY &lcGroupByO ;
		               GROUP BY &lcGroupByO ;
		               INTO CURSOR wrk1099rss READWRITE
		            SELECT wrk1099rss
		            INDEX ON cID TAG cID
		
		         ELSE  &&  By Well
		
		            *  Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year, which would include previous year suspense released during this year
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               disbhist.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(nNetCheck) AS nNonEmp, ;
		               0000000.00 AS nroyalty, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND EMPTY(disbhist.csusptype) ;
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		               GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		               INTO CURSOR wrk1099w READWRITE
		            SELECT wrk1099w
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               disbhist.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               SUM(nNetCheck) AS nNonEmp, ;
		               0000000.00 AS nroyalty ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(disbhist.csusptype) ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0') +cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		               GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		               INTO CURSOR wrk1099ws READWRITE
		            SELECT wrk1099ws
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(suspense.cOwnerID) AS cID, ;
		               suspense.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               suspense.cprogcode, ;
		               IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(suspense.ntrprev) AS ntrprev, ;
		               SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               SUM(nNetCheck) AS nNonEmp, ;
		               0000000.00 AS nroyalty ;
		               FROM suspense, investor ;
		               WHERE suspense.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND cTypeInv <> 'L'  ;
		               AND cTypeInv <> 'O' ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               ORDER BY suspense.cwellid, suspense.cOwnerID ;
		               GROUP BY suspense.cwellid, suspense.cOwnerID ;
		               INTO CURSOR wrk1099wss READWRITE
		            SELECT wrk1099wss
		            INDEX ON cID TAG cID
		
		            * Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year, which would include previous year suspense released during this year
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               disbhist.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               IIF(llFlatRent,SUM(disbhist.nNetCheck-disbhist.nflatrate),SUM(disbhist.nNetCheck)) AS nroyalty, ;
		               IIF(llFlatRent,SUM(disbhist.nflatrate),0) AS nrents, ;
		               0000000.00 AS nNonEmp ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND EMPTY(disbhist.csusptype) ;
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		               GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		               INTO CURSOR wrk1099r READWRITE
		            SELECT wrk1099r
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		               disbhist.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               disbhist.cprogcode, ;
		               IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(disbhist.ntrprev) AS ntrprev, ;
		               SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               IIF(llFlatRent,SUM(disbhist.nNetCheck-disbhist.nflatrate),SUM(disbhist.nNetCheck)) AS nroyalty, ;
		               IIF(llFlatRent,SUM(disbhist.nflatrate),0) AS nrents, ;
		               0000000.00 AS nNonEmp ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(disbhist.csusptype) ;
		               AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0') +disbhist.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		               GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		               INTO CURSOR wrk1099rs READWRITE
		            SELECT wrk1099rs
		            INDEX ON cID TAG cID
		
		            SELECT  MAX(suspense.cOwnerID) AS cID, ;
		               suspense.cwellid, ;
		               'I' AS cidtype, ;
		               lcYear AS cYear, ;
		               'G' AS cType, ;
		               investor.cOwnName AS cName, ;
		               IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		               IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		               IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		               IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		               IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		               IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		               IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		               investor.cTaxID, ;
		               suspense.cprogcode, ;
		               IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		               SUM(suspense.ntrprev) AS ntrprev, ;
		               SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		               SUM(nbackwith) AS nfedtax, ;
		               SUM(ntaxwith) AS nstatetax, ;
		               IIF(llFlatRent,SUM(suspense.nNetCheck-suspense.nflatrate),SUM(suspense.nNetCheck)) AS nroyalty, ;
		               IIF(llFlatRent,SUM(suspense.nflatrate),0) AS nrents, ;
		               0000000.00 AS nNonEmp ;
		               FROM suspense, investor ;
		               WHERE suspense.cOwnerID = investor.cOwnerID   ;
		               AND investor.lInv1099 = .T.  ;
		               AND NOT EMPTY(suspense.csusptype) ;
		               AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		               (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		               FROM sysctl ;
		               WHERE YEAR(dacctdate) = VAL(lcYear)));
		               AND (cTypeInv = 'L' ;
		               OR cTypeInv = 'O') ;
		               AND crectype = 'R' ;
		               AND investor.ldummy = .F. ;
		               AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		               FROM programs ;
		               WHERE lprog1099 = .F.) ;
		               ORDER BY suspense.cwellid, suspense.cOwnerID ;
		               GROUP BY suspense.cwellid, suspense.cOwnerID ;
		               INTO CURSOR wrk1099rss READWRITE
		            SELECT wrk1099rss
		            INDEX ON cID TAG cID
		         ENDIF
		   ENDCASE
		   SET TALK OFF
		   WAIT CLEAR
		
		   *
		   *  Create vendor 1099s
		   *
		   IF NOT m.goApp.lQBVersion
		      SELECT  MAX(vendor.cVendorID)  AS cID, ;
		         checks.cidtype AS cidtype, ;
		         vendor.cvendname AS cName, ;
		         '' AS cName2,  ;
		         lcYear AS cYear, ;
		         'N' AS cType, ;
		         SUM(checks.nAmount) AS nNonEmp, ;
		         00000000.00 AS nrents, ;
		         vendor.cbaddr1 AS caddr1, ;
		         vendor.cbaddr2 AS caddr2, ;
		         vendor.cTaxID  AS cTaxID, ;
		         vendor.cbcity  AS ccity, ;
		         vendor.cbstate AS cstate, ;
		         vendor.cbzip   AS czip, ;
		         vendor.cbcountry AS ccountry, ;
		         0000000.00 AS nroyalty ;
		         FROM checks, vendor ;
		         WHERE vendor.cVendorID = checks.cID  ;
		         AND checks.cidtype   = 'V' ;
		         AND checks.lvoid     = .F. ;
		         AND vendor.lsend1099 = .T. ;
		         AND YEAR(dcheckdate) = VAL(lcYear) ;
		         INTO CURSOR wrk1099v ;
		         GROUP BY &lcGroupByV
		   ELSE
		      IF m.goApp.oQB.QBFCVersion < ' 5.0'
		         IF THIS.oMessage.CONFIRM('You must update your QuickBooks interface in order for vendor 1099s to be processed. ' + ;
		               'QBFC needs to be at least version 5. Your version is: ' + ALLTRIM(m.goApp.oQB.QBFCVersion) + '. Download and install: support.sherware.com/download/qbfc5.exe?')
		            oLink = CREATEOBJECT('hyperlink')
		            oLink.NAVIGATETO('support.sherware.com/download/qbfc5.exe')
		         ENDIF
		      ENDIF
		
		      IF llQBVendor1099
		         llReturn = THIS.qbvendor1099()
		         IF NOT llReturn
		            EXIT
		         ENDIF
		      ENDIF
		   ENDIF
		
		   SELE wrk1099w
		   lnMax = RECC()
		   SELE wrk1099ws
		   lnMax = lnMax + RECCOUNT()
		   SELE wrk1099wss
		   lnMax = lnMax + RECCOUNT()
		   SELE wrk1099r
		   lnMax = lnMax + RECC()
		   SELECT wrk1099rs
		   lnMax = lnMax + RECCOUNT()
		   SELECT wrk1099rss
		   lnMax = lnMax + RECCOUNT()
		
		   IF USED('wrk1099v')
		      SELE wrk1099v
		      lnMax = lnMax + RECC()
		   ENDIF
		
		   lnProgress = 0
		   oProgress  = THISFORM.oMessage.ProgressBar('')
		   oProgress.SetProgressRange(0, lnMax)
		
		   oProgress.SetProgressMessage('Creating Working Interest 1099 Records for ' + lcYear + '....')
		   SELE wrk1099w
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      IF llTranExp
		         m.nNonEmp = m.nNonEmp - m.ntrprev
		      ENDIF
		      m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		      SET DELE OFF
		      SELE tax10991
		      SET ORDER TO cidtax1
		      DO WHILE SEEK(m.cidtax1)
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		      ENDDO
		      SET DELE ON
		      IF glHideComp
		         m.nNonEmp = m.nNonEmp - m.ncompgath
		      ENDIF
		      INSERT INTO tax1099 FROM MEMVAR
		   ENDSCAN
		   SELE wrk1099ws
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		
		      SELECT tax1099
		      IF NOT m.lByWell
		         IF llByTaxID
		            LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID) AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nNonEmp = m.nNonEmp - m.ntrprev
		               ENDIF
		               REPLACE nNonEmp WITH nNonEmp + m.nNonEmp
		               *  If the WI owner ID is higher than the RI owner ID, replace it.
		               *  The detail processing will get out of sync if we don't, since it's merging to the highest
		               *  ID code, regardless of owner type.
		               IF m.cID > tax1099.cID
		                  REPLACE tax1099.cID WITH m.cID
		               ENDIF
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nNonEmp = m.nNonEmp - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ELSE
		            LOCATE FOR cID == m.cID AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nNonEmp = m.nNonEmp - m.ntrprev
		               ENDIF
		               REPLACE nNonEmp WITH nNonEmp + m.nNonEmp
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nNonEmp = m.nNonEmp - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ENDIF
		      ELSE
		         SET ORDER TO yearwell
		         SEEK (lcYear + m.cwellid + m.cID)
		         IF FOUND()
		            IF llTranExp
		               m.nNonEmp = m.nNonEmp - m.ntrprev
		            ENDIF
		            REPLACE nNonEmp WITH nNonEmp + m.nNonEmp
		         ELSE
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            SET DELE OFF
		            SELE tax10991
		            SET ORDER TO cidtax1
		            DO WHILE SEEK(m.cidtax1)
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            ENDDO
		            SET DELE ON
		            IF llTranExp
		               m.nNonEmp = m.nNonEmp - m.ntrprev
		            ENDIF
		            INSERT INTO tax1099 FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDSCAN
		   SELE wrk1099wss
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		
		      SELECT tax1099
		      IF NOT m.lByWell
		         IF llByTaxID
		            LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID) AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nNonEmp = m.nNonEmp - m.ntrprev
		               ENDIF
		               REPLACE nNonEmp WITH nNonEmp + m.nNonEmp
		               *  If the WI owner ID is higher than the RI owner ID, replace it.
		               *  The detail processing will get out of sync if we don't, since it's merging to the highest
		               *  ID code, regardless of owner type.
		               IF m.cID > tax1099.cID
		                  REPLACE tax1099.cID WITH m.cID
		               ENDIF
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nNonEmp = m.nNonEmp - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ELSE
		            LOCATE FOR cID == m.cID AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nNonEmp = m.nNonEmp - m.ntrprev
		               ENDIF
		               REPLACE nNonEmp WITH nNonEmp + m.nNonEmp
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nNonEmp = m.nNonEmp - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ENDIF
		      ELSE
		         SET ORDER TO yearwell
		         SEEK (lcYear + m.cwellid + m.cID)
		         IF FOUND()
		            IF llTranExp
		               m.nNonEmp = m.nNonEmp - m.ntrprev
		            ENDIF
		            REPLACE nNonEmp WITH nNonEmp + m.nNonEmp
		         ELSE
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            SET DELE OFF
		            SELE tax10991
		            SET ORDER TO cidtax1
		            DO WHILE SEEK(m.cidtax1)
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            ENDDO
		            SET DELE ON
		            IF llTranExp
		               m.nNonEmp = m.nNonEmp - m.ntrprev
		            ENDIF
		            INSERT INTO tax1099 FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDSCAN
		   USE IN wrk1099w
		   USE IN wrk1099ws
		   USE IN wrk1099wss
		
		   *
		   *  Insert Royalty records into work cursor
		   *
		   oProgress.SetProgressMessage('Creating Royalty Interest 1099 Records for ' + lcYear + '....')
		   SELECT wrk1099r
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      SELECT tax1099
		      IF NOT m.lByWell
		         IF llByTaxID
		            LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID) AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		               
		               *  If the royalty owner ID is higher than the WI owner ID, replace it.
		               *  The detail processing will get out of sync if we don't, since it's merging to the highest
		               *  ID code, regardless of owner type.
		               IF m.cID > tax1099.cID
		                  REPLACE tax1099.cID WITH m.cID
		               ENDIF
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ELSE
		            LOCATE FOR cID == m.cID AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ENDIF
		      ELSE
		         SET ORDER TO yearwell
		         SEEK (lcYear + m.cwellid + m.cID)
		         IF FOUND()
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		         ELSE
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            SET DELE OFF
		            SELE tax10991
		            SET ORDER TO cidtax1
		            DO WHILE SEEK(m.cidtax1)
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            ENDDO
		            SET DELE ON
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            INSERT INTO tax1099 FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDSCAN
		   SELECT wrk1099rs
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      SELECT tax1099
		      IF NOT m.lByWell
		         IF llByTaxID
		            LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID) AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		               *  If the royalty owner ID is higher than the WI owner ID, replace it.
		               *  The detail processing will get out of sync if we don't, since it's merging to the highest
		               *  ID code, regardless of owner type.
		               IF m.cID > tax1099.cID
		                  REPLACE tax1099.cID WITH m.cID
		               ENDIF
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ELSE
		            LOCATE FOR cID == m.cID AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ENDIF
		      ELSE
		         SET ORDER TO yearwell
		         SEEK (lcYear + m.cwellid + m.cID)
		         IF FOUND()
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		         ELSE
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            SET DELE OFF
		            SELE tax10991
		            SET ORDER TO cidtax1
		            DO WHILE SEEK(m.cidtax1)
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            ENDDO
		            SET DELE ON
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            INSERT INTO tax1099 FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDSCAN
		   SELECT wrk1099rss
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      SELECT tax1099
		      IF NOT m.lByWell
		         IF llByTaxID
		            LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID) AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		               *  If the royalty owner ID is higher than the WI owner ID, replace it.
		               *  The detail processing will get out of sync if we don't, since it's merging to the highest
		               *  ID code, regardless of owner type.
		               IF m.cID > tax1099.cID
		                  REPLACE tax1099.cID WITH m.cID
		               ENDIF
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ELSE
		            LOCATE FOR cID == m.cID AND cYear = lcYear
		            IF FOUND()
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		            ELSE
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               SET DELE OFF
		               SELE tax10991
		               SET ORDER TO cidtax1
		               DO WHILE SEEK(m.cidtax1)
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		               ENDDO
		               SET DELE ON
		               IF llTranExp
		                  m.nroyalty = m.nroyalty - m.ntrprev
		               ENDIF
		               INSERT INTO tax1099 FROM MEMVAR
		            ENDIF
		         ENDIF
		      ELSE
		         SET ORDER TO yearwell
		         SEEK (lcYear + m.cwellid + m.cID)
		         IF FOUND()
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            REPLACE nroyalty WITH nroyalty + m.nroyalty, ;
		                       nrents   WITH nrents + m.nrents
		         ELSE
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            SET DELE OFF
		            SELE tax10991
		            SET ORDER TO cidtax1
		            DO WHILE SEEK(m.cidtax1)
		               m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            ENDDO
		            SET DELE ON
		            IF llTranExp
		               m.nroyalty = m.nroyalty - m.ntrprev
		            ENDIF
		            INSERT INTO tax1099 FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Processing state tax withholding...')
		
		   SELECT  disbhist.cOwnerID, SUM(ntaxwith) AS nAmount, wells.cstate AS cTaxState,  ;
		      investor.cTaxID ;
		      FROM  disbhist, investor, wells ;
		      WHERE ntaxwith <> 0 ;
		      AND disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0') IN ;
		      (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE YEAR(dacctdate) = VAL(lcYear) ;
		      AND cTypeClose = 'R') ;
		      AND disbhist.cwellid = wells.cwellid  ;
		      AND disbhist.cOwnerID = investor.cOwnerID ;
		      INTO CURSOR ttax ;
		      ORDER BY &lcGroupByO, wells.cstate ;
		      GROUP BY &lcGroupByO, wells.cstate
		
		   SELECT ttax
		   SCAN FOR nAmount # 0
		      SCATTER MEMVAR
		      swselect('tax1099states')
		      LOCATE FOR cstate == m.cTaxState
		      IF FOUND()
		         m.cPayerNo = cPayerNo
		      ELSE
		         m.cPayerNo = ''
		      ENDIF
		      SELECT tax1099
		      IF llByTaxID
		         LOCATE FOR cYear = lcYear AND ALLTRIM(cTaxID) = ALLTRIM(m.cTaxID)
		      ELSE
		         LOCATE FOR cYear = lcYear AND cID = m.cOwnerID
		      ENDIF
		      IF FOUND()
		         IF nStateTax1 = 0
		            REPL nStateTax1 WITH m.nAmount, ;
		               cTaxState1 WITH m.cTaxState, ;
		               cStatePayerNo1 WITH m.cPayerNo
		         ELSE
		            REPL nStateTax2 WITH m.nAmount, ;
		               cTaxState2 WITH m.cTaxState, ;
		               cStatePayerNo2 WITH m.cPayerNo
		         ENDIF
		      ENDIF
		   ENDSCAN
		   oProgress.SetProgressMessage('Processing tax and backup withholding...')
		
		   SELECT tax1099
		   SCAN FOR cYear = lcYear
		      REPL cwellid WITH ''
		   ENDSCAN
		
		   SELECT tax1099
		   SET ORDER TO primkey
		
		   lcYear1 = STR(VAL(lcYear) + 1, 4)
		
		   IF USED('wrk1099v')
		      oProgress.SetProgressMessage('Creating Vendor 1099 Records for ' + lcYear + '....')
		      SELECT wrk1099v
		      SCAN
		         SCATTER MEMVAR
		         oProgress.UpdateProgress(lnProgress)
		         lnProgress  = lnProgress + 1
		         m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         m.cwellid   = ''
		         m.cwellname = ''
		         m.cWellTax  = ''
		         m.cName2    = ''
		         m.cYear     = lcYear
		         STORE '' TO m.cTaxState1, m.cTaxState2, m.cStatePayerNo1, m.cStatePayerNo2
		         STORE 0  TO m.nStateTax1, m.nfedtax, m.nStateTax2
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         INSERT INTO tax1099 FROM MEMVAR
		         SET DELE ON
		      ENDSCAN
		   ENDIF
		
		   IF TYPE('oProgress') = 'O'
		      oProgress.CloseProgress()
		   ENDIF
		
		   * Create the 1099DET file with the detail for the reconciliation report
		   llReturn = THISFORM.MakeFileDetEarned()
		   IF NOT llReturn
		      EXIT
		   ENDIF
		
		   *
		   *  Check to see if we're integrated with the Accounting Manager
		   *  If so, we need to check the coa table for a rent account
		   *
		   IF TYPE('m.goApp') = 'O'
		      IF m.goApp.lAMVersion
		         WAIT WIND NOWAIT 'Processing rental 1099s...'
		         *
		         *  Calculate the rental 1099 amounts
		         *
		         CREATE CURSOR rents ;
		            (cID       C(10), ;
		            nAmount   N(12, 2))
		         SELECT coa
		         SCAN FOR lRent1099
		            m.cacctno = cacctno
		
		            SELECT  cID, SUM(nDebits - nCredits) AS nAmount ;
		               FROM glmaster ;
		               WHERE YEAR(ddate) = VAL(lcYear) ;
		               AND cacctno = m.cacctno ;
		               INTO CURSOR tmp1 ;
		               ORDER BY cID ;
		               GROUP BY cID
		
		            IF _TALLY > 0
		               SELECT rents
		               APPEND FROM DBF('tmp1')
		            ENDIF
		         ENDSCAN
		
		         SELECT  cID, SUM(nAmount) AS nAmount ;
		            FROM rents ;
		            INTO CURSOR temprent ;
		            ORDER BY cID ;
		            GROUP BY cID
		
		         SELECT tax1099
		         SET ORDER TO primkey
		         SELECT temprent
		         SCAN FOR nAmount > 0
		            STORE 0 TO m.nroyalty, m.nrents, m.nNonEmp
		            SCATTER MEMVAR
		
		            SELECT tax1099
		            IF SEEK(lcYear + m.cID)
		               REPLACE nrents WITH nrents + m.nAmount
		               IF cidtype = 'V'
		                  REPLACE nNonEmp WITH nNonEmp - m.nAmount
		               ENDIF
		            ELSE
		               m.nNonEmp  = 0
		               m.nroyalty = 0
		               SELECT vendor
		               SET ORDER TO cVendorID
		               IF SEEK(m.cID) AND lsend1099
		                  m.cName     = cvendname
		                  m.cName2    = ''
		                  m.caddr1    = cbaddr1
		                  m.caddr2    = cbaddr2
		                  m.ccity     = cbcity
		                  m.cstate    = cbstate
		                  m.czip      = cbzip
		                  m.ccountry  = cbcountry
		                  m.cTaxID    = cTaxID
		                  m.nrents    = m.nAmount
		                  m.cYear     = lcYear
		                  m.cidtype   = 'V'
		                  m.cwellid   = ''
		                  m.cwellname = ''
		                  m.cType     = IIF(llGross1099, 'G', 'N')
		                  m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  SET DELE OFF
		                  SELE tax10991
		                  SET ORDER TO cidtax1
		                  DO WHILE SEEK(m.cidtax1)
		                     m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  ENDDO
		                  SET DELE ON
		                  INSERT INTO tax1099 FROM MEMVAR
		               ELSE
		                  SELECT investor
		                  SET ORDER TO cOwnerID
		                  IF SEEK(m.cID) AND lInv1099
		                     m.cName     = cOwnName
		                     m.cName2    = cOwnName1
		                     m.caddr1    = caddress1a
		                     m.caddr2    = caddress1b
		                     m.ccity     = ccity1
		                     m.cstate    = cstate1
		                     m.czip      = czip1
		                     m.ccountry  = ccountry1
		                     m.cTaxID    = cTaxID
		                     m.nrents    = m.nAmount
		                     m.cYear     = lcYear
		                     m.cwellid   = ''
		                     m.cwellname = ''
		                     m.cidtype   = 'I'
		                     m.cType     = IIF(llGross1099, 'G', 'N')
		                     m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     SET DELE OFF
		                     SELE tax10991
		                     SET ORDER TO cidtax1
		                     DO WHILE SEEK(m.cidtax1)
		                        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     ENDDO
		                     SET DELE ON
		                     INSERT INTO tax1099 FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDSCAN
		      ELSE
		         SELECT  checks.cID  AS cID, ;
		            checks.cidtype  AS cidtype, ;
		            checks.cpayee   AS cName, ;
		            lcYear          AS cYear, ;
		            IIF(llGross1099, 'G', 'N') AS cType, ;
		            SUM(checks.nAmount) AS nrents, ;
		            investor.caddress1a AS caddr1, ;
		            investor.caddress1b AS caddr2, ;
		            investor.cOwnName1 AS cName2,  ;
		            investor.cTaxID     AS cTaxID, ;
		            investor.ccity1  AS ccity, ;
		            investor.cstate1 AS cstate, ;
		            investor.czip1   AS czip, ;
		            investor.ccountry1 AS ccountry, ;
		            0000000.00 AS nroyalty, ;
		            0000000.00 AS nNonEmp  ;
		            FROM checks, investor ;
		            WHERE investor.cOwnerID = checks.cID  ;
		            AND checks.cidtype   = 'I' ;
		            AND checks.csource   = 'LM' ;
		            AND checks.lvoid     = .F. ;
		            AND investor.lInv1099 = .T. ;
		            AND investor.ldummy = .F. ;
		            AND YEAR(dcheckdate) = VAL(lcYear) ;
		            INTO CURSOR wrk1099 ;
		            GROUP BY cID
		
		         IF _TALLY > 0
		            SELE wrk1099
		            SCAN
		               SCATTER MEMVAR
		               m.cwellid   = ''
		               m.cwellname = ''
		               m.nNonEmp   = 0
		               m.nroyalty  = 0
		               SELECT tax1099
		               IF NOT m.lByWell
		                  SET ORDER TO primkey
		                  SEEK (lcYear + m.cID)
		                  IF FOUND()
		                     REPLACE nrents WITH nrents + m.nrents
		                  ELSE
		                     m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     SET DELE OFF
		                     SELE tax10991
		                     SET ORDER TO cidtax1
		                     DO WHILE SEEK(m.cidtax1)
		                        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     ENDDO
		                     SET DELE ON
		                     m.cYear = lcYear
		                     INSERT INTO tax1099 FROM MEMVAR
		                  ENDIF
		               ELSE
		                  SET ORDER TO yearwell
		                  SEEK (lcYear + m.cwellid + m.cID)
		                  IF FOUND()
		                     REPLACE nrents WITH m.nrents
		                  ELSE
		                     m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     SET DELE OFF
		                     SELE tax10991
		                     SET ORDER TO cidtax1
		                     DO WHILE SEEK(m.cidtax1)
		                        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     ENDDO
		                     SET DELE ON
		                     m.cYear = lcYear
		                     INSERT INTO tax1099 FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDSCAN
		         ENDIF
		      ENDIF
		   ENDIF
		
		
		   WAIT WINDOW NOWAIT 'Cleaning Up 1099 Detail File...'
		   SELECT temp1099det
		   SCAN FOR cYear = lcYear
		      IF nincome = 0 AND nexpense = 0 AND nsevtaxes = 0
		         DELETE NEXT 1
		      ELSE
		         IF (nincome - nexpense - nsevtaxes <> nNetCheck) AND nNetCheck = 0
		            * Only doing the adjustment if calculating on gross
		            IF llGross1099
		               SELECT tax1099
		               IF llByTaxID
		                  LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(temp1099det.cTaxID) AND cYear = lcYear
		               ELSE
		                  LOCATE FOR cID = temp1099det.cID AND cYear = lcYear
		               ENDIF
		               IF FOUND()
		                  IF temp1099det.cRptGroup = 'W'
		                     REPLACE nNonEmp WITH nNonEmp - temp1099det.nincome
		                  ELSE
		                     REPLACE nroyalty WITH nroyalty - temp1099det.nincome
		                  ENDIF
		                  SELECT temp1099det
		                  DELETE NEXT 1
		               ENDIF
		            ELSE
		               DELETE NEXT 1
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   *  Clean up the 1099 file.  There should be no "Dummy"
		   *  owners in the file,  There should also not be any
		   *  negative numbers.  If any are found, deleted them.
		   *
		   WAIT WIND NOWAIT 'Performing 1099 cleanup...'
		   SELECT tax1099
		   GO TOP
		   SCAN FOR cYear = lcYear
		      SCATTER MEMVAR
		      IF nroyalty < 0
		         REPLACE nroyalty WITH 0
		      ENDIF
		      IF nrents < 0
		         REPLACE nrents WITH 0
		      ENDIF
		      IF nNonEmp < 0
		         REPLACE nNonEmp WITH 0
		      ENDIF
		      IF nfedtax < 0
		         REPLACE nfedtax WITH 0
		      ENDIF
		      IF nStateTax1 < 0
		         REPLACE nStateTax1 WITH 0
		      ENDIF
		      IF nStateTax2 < 0
		         REPLACE nStateTax2 WITH 0
		      ENDIF
		      IF NOT m.lByWell
		         REPLACE cwellid WITH '', cwellname WITH ''
		      ENDIF
		      IF nroyalty = 0 AND nrents = 0 AND nfedtax = 0 AND nStateTax1 = 0 AND nStateTax2 = 0 AND nNonEmp  = 0
		         DELETE NEXT 1
		      ENDIF
		      IF lnMin1099Non > 0
		         SELECT tax1099
		         IF nNonEmp < lnMin1099Non AND nroyalty < lnMin1099Roy AND nrents < lnMin1099Non
		            DELETE NEXT 1
		         ENDIF
		         IF nrents < lnMin1099Non AND nroyalty < lnMin1099Roy AND nNonEmp < lnMin1099Non
		            DELETE NEXT 1
		         ENDIF
		      ENDIF
		      IF lnMin1099Roy > 0
		         SELECT tax1099
		         IF nroyalty < lnMin1099Roy AND nrents < lnMin1099Non AND nNonEmp < lnMin1099Non
		            DELETE NEXT 1
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		
		   **  If we're not building by tax ID, compare cid between tax1099 and temp1099det and delete any detail records
		   **  without a corresponding 1099.  Otherwise, compare ctaxid
		   IF NOT llByTaxID
		      SELECT temp1099det
		      DELETE FROM temp1099det WHERE cID NOT IN (SELECT cID FROM tax1099 WHERE cYear == lcYear)
		      *!*		  SELECT  cID ;
		      *!*			  FROM temp1099det WITH (BUFFERING = .T.) ;
		      *!*			  WHERE cYear = lcYear  ;
		      *!*				  AND cID NOT IN (SELECT  cID ;
		      *!*									  FROM tax1099 ;
		      *!*									  WHERE cYear = lcYear) ;
		      *!*			  INTO CURSOR no1099 ;
		      *!*			  ORDER BY cID ;
		      *!*			  GROUP BY cID
		
		      *!*	** Remove detail records for owners with no 1099
		      *!*	      SELECT no1099
		      *!*	      SCAN
		      *!*	         m.cID = cID
		      *!*	         SELECT temp1099det
		      *!*	         SCAN FOR cYear + cID == lcYear + m.cID
		      *!*	            DELETE NEXT 1
		      *!*	         ENDSCAN
		      *!*	      ENDSCAN
		   ELSE
		      **  By tax ID, so compare ctaxid fields to determine whether to remove the temp1099det records
		      SELECT temp1099det
		      DELETE FROM temp1099det WHERE cTaxID NOT IN (SELECT cTaxID FROM tax1099 WHERE cYear == lcYear)
		
		      *!*		  SELECT  cTaxID ;
		      *!*			  FROM temp1099det WITH (BUFFERING = .T.) ;
		      *!*			  WHERE cYear = lcYear  ;
		      *!*				  AND cTaxID NOT IN (SELECT  cTaxID ;
		      *!*										 FROM tax1099 ;
		      *!*										 WHERE cYear = lcYear) ;
		      *!*			  INTO CURSOR no1099 ;
		      *!*			  ORDER BY cTaxID ;
		      *!*			  GROUP BY cTaxID
		
		      *!*	** Remove detail records for owners with no 1099
		      *!*	      SELECT no1099
		      *!*	      SCAN
		      *!*	         m.cTaxID = ALLTRIM(cTaxID)
		      *!*	         SELECT temp1099det
		      *!*	         SCAN FOR cYear + ALLTRIM(cTaxID) == lcYear + ALLTRIM(m.cTaxID)
		      *!*	            DELETE NEXT 1
		      *!*	         ENDSCAN
		      *!*	      ENDSCAN
		   ENDIF
		
		
		   ** Clean up expense to make sure the records foot across
		   SELECT temp1099det
		   SCAN FOR cYear == lcYear
		      lnDiff = (nincome - nexpense - nsevtaxes - nrents - nstatetax - nfedtax - ncompgath) - nNetCheck
		      IF  lnDiff <> 0
		         IF lnDiff > 0
		            IF nexpense + lnDiff < 0
		               lnDiff = nexpense + lnDiff
		               REPLACE nexpense WITH 0
		               IF nsevtaxes + lnDiff < 0
		                  REPLACE nexpense WITH nexpense + lnDiff
		               ELSE
		                  REPLACE nsevtaxes WITH nsevtaxes + lnDiff
		               ENDIF
		            ELSE
		               REPLACE nexpense WITH nexpense + lnDiff
		            ENDIF
		         ELSE
		            IF nexpense - lnDiff < 0
		               lnDiff = nexpense - lnDiff
		               REPLACE nexpense WITH 0
		               IF nsevtaxes - lnDiff < 0
		                  REPLACE nexpense WITH nexpense - lnDiff
		               ELSE
		                  REPLACE nsevtaxes WITH nsevtaxes - lnDiff
		               ENDIF
		            ELSE
		               REPLACE nexpense WITH nexpense + lnDiff
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   SELECT tax1099
		   SCAN FOR cTaxID = cID AND cYear = lcYear
		      REPLACE cTaxID WITH ''
		   ENDSCAN
		
		   SELECT temp1099det
		   SCAN FOR cTaxID = cID
		      REPLACE cTaxID WITH ''
		   ENDSCAN
		
		   SELECT tax1099
		   TABLEUPDATE(.T.)
		   SELECT tax1099det
		   APPEND FROM DBF('temp1099det')
		   TABLEUPDATE(.T.)
		
		   IF llByTaxID  &&  If creating by tax ID, scan the investor file and plug in the owner ID as the tax ID, so it's unique, and can be grouped correctly.
		      WAIT WINDOW NOWAIT 'Cleaning up blank tax ID records'
		      SELECT investor
		      SCAN FOR cTaxID = cOwnerID AND lInv1099
		         REPLACE cTaxID WITH ''
		      ENDSCAN
		      = TABLEUPDATE(.T.)
		   ENDIF
		
		   WAIT WINDOW NOWAIT 'Processing State 1099s...'
		   lnState = THISFORM.Make_State_1099s()
		   IF VARTYPE(lnState) <> 'N'
		      lnState = 0
		      EXIT
		   ENDIF
		
		   WAIT CLEAR
		
		   SELECT tax1099
		   COUNT FOR cYear = lcYear AND NOT DELETED() TO lnCount
		
		   MESSAGEBOX('Finished Processing 1099s for ' + lcYear + CHR(10) + CHR(10) + ;
		      'Created ' + ALLTRIM(TRANSFORM(lnCount, '999,999')) + ' Federal 1099s ' + ;
		      IIF(lnState # 0, ' and ' + ALLTRIM(TRANSFORM(lnState, '999,999')) + ' State 1099s ', ''), 64, '1099 Processing Counts')
		
		   IF USED('temprent')
		      USE IN temprent
		   ENDIF
		   IF USED('tmp1')
		      USE IN tmp1
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'MakeFileEarned', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		   IF VARTYPE(oProgress) = 'O'
		      oProgress.CloseProgress()
		   ENDIF
		   MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		oProgress = .NULL.
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE makefileearnedbywell
		LOCAL lnAdj
		LOCAL oLink AS 'hyperlink'
		LOCAL lByWell, lcGroupByO, lcGroupByV, lcYear1, llGross1099, llReturn, llTranExp, lnCountD, lnDiff
		LOCAL lnMax, lnMin1099Non, lnMin1099Roy, lnProgress, loError, llQBVendor1099
		
		llReturn       = .T.
		llQBVendor1099 = .T.
		
		TRY
		   SET DELETED ON
		   *
		   *  Creates the 1099 file for the given year
		   *
		   LOCAL lnCount, lcYear, oProgress, lcYear, m.lByWell, llByTaxID
		
		   lcYear    = THISFORM.txtcYear.VALUE
		   llByTaxID = THISFORM.chkTaxID.VALUE
		   llFlatRent = THISFORM.chkflatRates.VALUE
		   lnCount   = 0
		
		   IF NOT THISFORM.oMessage.CONFIRM('Are you sure you want to create the 1099 file for ' + ALLTRIM(lcYear) + '?')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   *  Eliminate blank programs, which invariable cause all WI owners to get skipped for someone each year.
		   swselect('programs')
		   SCAN FOR EMPTY(cprogcode)
		      DELETE NEXT 1
		   ENDSCAN
		
		   IF m.goApp.lQBVersion
		      IF NOT m.goApp.lQBActive
		         IF MESSAGEBOX("The QB connection is not active, so the vendor 1099 information could not be retrieved." + ;
		               "To have the QB vendor information included on the 1099s, connect to QB, and then re-create the 1099 file." + CHR(10) + CHR(10) + ;
		               "Do you want to continue without Vendor 1099s being created?", 36, 'Vendor 1099s') = 7
		            llReturn = .F.
		            EXIT
		         ELSE
		            llQBVendor1099 = .F.
		         ENDIF
		      ENDIF
		   ENDIF
		
		   IF lcYear > THISFORM.cYearApproved
		      IF NOT THISFORM.oMessage.CONFIRM('The selected year has not yet been approved for 1099 processing by SherWare, Inc.  Creating the 1099 file for this year could lead to inaccurate processing and reporting.  Continue?')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   *
		   *   Fix 1099s with negative amounts and delete zero amounts and 1099's less
		   *   than the minimum
		   *
		   SELECT options
		   GO TOP
		   lnMin1099Non = nmin1099Non    && Get the minimum 1099 amount for working interest owners
		   lnMin1099Roy = nmin1099Roy    && Get the minimum 1099 amount for royalty owners
		   glHideComp   = lHideComp
		   llGross1099  = lGross1099
		   llTranExp    = THISFORM.chkExclTrans.VALUE    && Option to remove transportation revenue when used as marketing costs.
		
		   IF lnMin1099Non = 0
		      lnMin1099Non = .01
		   ENDIF
		   IF lnMin1099Roy = 0
		      lnMin1099Roy = .01
		   ENDIF
		
		   SELECT tax1099
		   COUNT FOR cYear = lcYear TO lnCount
		   SELECT tax1099det
		   COUNT FOR cYear = lcYear TO lnCountD
		   IF lnCount > 0
		      IF NOT THISFORM.oMessage.CONFIRM('The 1099 file for tax year ' + TRIM(lcYear) + ' already exists. Do you want to overwrite it?  This will eliminate any manual changes already made to the 1099 file for this year.')
		         WAIT WIND NOWAIT 'The 1099 process was cancelled...'
		         llReturn = .F.
		         EXIT
		      ELSE
		         lnProgress = 0
		         oProgress  = THISFORM.oMessage.ProgressBar('')
		         oProgress.SetProgressRange(0, lnCount + lnCountD)
		         oProgress.SetProgressMessage('Deleting Existing 1099 Records for ' + lcYear + '....')
		
		         SELECT tax1099
		         SET ORDER TO cYear   && CYEAR
		         SCAN FOR cYear = lcYear
		            oProgress.UpdateProgress(lnProgress)
		            lnProgress = lnProgress + 1
		            DELETE NEXT 1
		         ENDSCAN
		         oProgress.SetProgressMessage('Deleting Existing 1099 Detail Records for ' + lcYear + '....')
		         SELECT tax1099det
		         SET ORDER TO cYear
		         SCAN FOR cYear = lcYear
		            oProgress.UpdateProgress(lnProgress)
		            lnProgress = lnProgress + 1
		            DELETE NEXT 1
		         ENDSCAN
		         IF TYPE('oProgress') = 'O'
		            oProgress.CloseProgress()
		         ENDIF
		      ENDIF
		   ENDIF
		
		   WAIT WIND NOWAIT 'Performing 1099 setup process...'
		
		   IF llByTaxID  &&  If creating by tax ID, scan the investor file and plug in the owner ID as the tax ID, so it's unique, and can be grouped correctly.
		      WAIT WINDOW NOWAIT 'Processing blank tax ID records'
		      SELECT investor
		      SCAN FOR EMPTY(cTaxID) AND lInv1099
		         REPLACE cTaxID WITH cOwnerID
		      ENDSCAN
		      = TABLEUPDATE(.T.)
		   ENDIF
		
		   IF llByTaxID
		      lcGroupByO = 'investor.ctaxid'
		      lcGroupByV = 'vendor.ctaxid'
		   ELSE
		      lcGroupByO = 'investor.cownerid'
		      lcGroupByV = 'vendor.cvendorid'
		   ENDIF
		
		   * Correct the hdate field on released suspense
		   THIS.plughdate()
		
		   SET TALK ON
		   DO CASE
		      CASE llGross1099  && Gross Revenue
		
		         *  Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year, which would include previous year suspense released during this year
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, disbhist.nincome)))) AS nNonEmp, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            0000000.00 AS nroyalty ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0') +cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND EMPTY(disbhist.csusptype) ;
		            AND cTypeInv <> 'L'  ;
		            AND cTypeInv <> 'O' ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (disbhist.lManual = .F. OR ;
		            (disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype))) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099w READWRITE
		         SELECT wrk1099w
		         INDEX ON cID TAG cID
		
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, disbhist.nincome)))) AS nNonEmp, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            0000000.00 AS nroyalty ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND NOT EMPTY(disbhist.csusptype) ;
		            AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND cTypeInv <> 'L'  ;
		            AND cTypeInv <> 'O' ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (disbhist.lManual = .F. OR ;
		            (disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype))) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099ws READWRITE
		         SELECT wrk1099ws
		         INDEX ON cID TAG cID
		
		         SELECT  MAX(suspense.cOwnerID) AS cID, ;
		            suspense.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            suspense.cprogcode, ;
		            IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(suspense.ntrprev) AS ntrprev, ;
		            SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		            SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev), ;
		            IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev), ;
		            IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, suspense.nincome)))) AS nNonEmp, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            0000000.00 AS nroyalty ;
		            FROM suspense, investor ;
		            WHERE suspense.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND cTypeInv <> 'L'  ;
		            AND cTypeInv <> 'O' ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (suspense.lManual = .F. OR ;
		            (suspense.lManual = .T. ;
		            AND EMPTY(suspense.csusptype))) ;
		            ORDER BY suspense.cwellid, suspense.cOwnerID ;
		            GROUP BY suspense.cwellid, suspense.cOwnerID ;
		            INTO CURSOR wrk1099wss READWRITE
		         SELECT wrk1099wss
		         INDEX ON cID TAG cID
		
		         * Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year, which would include previous year suspense released during this year
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            IIF(llFlatRent,SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		            (disbhist.nincome - disbhist.nflatrate))))), ;
		            SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev ), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev ), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		            (disbhist.nincome )))))) AS nroyalty, ;
		            SUM(IIF(llFlatRent,IIF(disbhist.lflat, disbhist.nflatrate,000000.00),000000.00)) AS nrents, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            0000000.00 AS nNonEmp ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND EMPTY(disbhist.csusptype) ;
		            AND (cTypeInv = 'L' ;
		            OR cTypeInv = 'O') ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (disbhist.lManual = .F. OR ;
		            (disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype))) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099r READWRITE
		         SELECT wrk1099r
		         INDEX ON cID TAG cID
		
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            IIF(llFlatRent,SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev - disbhist.nflatrate), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev - disbhist.nflatrate), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		            (disbhist.nincome - disbhist.nflatrate))))), ;
		            SUM(IIF(disbhist.cDirect = 'O', (disbhist.nincome - disbhist.noilrev ), ;
		            IIF(disbhist.cDirect = 'G', (disbhist.nincome - disbhist.ngasrev ), ;
		            IIF(disbhist.cDirect = 'B', disbhist.ntrprev + disbhist.nothrev + disbhist.nmiscrev1 + disbhist.nmiscrev2, ;
		            (disbhist.nincome )))))) AS nroyalty, ;
		            SUM(IIF(llFlatRent,IIF(disbhist.lflat, disbhist.nflatrate,000000.00),000000.00)) AS nrents, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            0000000.00 AS nNonEmp ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND NOT EMPTY(disbhist.csusptype) ;
		            AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND (cTypeInv = 'L' ;
		            OR cTypeInv = 'O') ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (disbhist.lManual = .F. OR ;
		            (disbhist.lManual = .T. ;
		            AND EMPTY(disbhist.csusptype) ;
		            AND crectype # 'P')) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099rs READWRITE
		         SELECT wrk1099rs
		         INDEX ON cID TAG cID
		
		         SELECT  MAX(suspense.cOwnerID) AS cID, ;
		            suspense.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            suspense.cprogcode, ;
		            IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(suspense.ntrprev) AS ntrprev, ;
		            SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		            IIF(llFlatRent,SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev - suspense.nflatrate), ;
		            IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev - suspense.nflatrate), ;
		            IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, ;
		            (suspense.nincome - suspense.nflatrate))))), ;
		            SUM(IIF(suspense.cDirect = 'O', (suspense.nincome - suspense.noilrev ), ;
		            IIF(suspense.cDirect = 'G', (suspense.nincome - suspense.ngasrev ), ;
		            IIF(suspense.cDirect = 'B', suspense.ntrprev + suspense.nothrev + suspense.nmiscrev1 + suspense.nmiscrev2, ;
		            (suspense.nincome )))))) AS nroyalty, ;
		            SUM(IIF(llFlatRent,IIF(suspense.lflat, suspense.nflatrate,000000.00),000000.00)) AS nrents, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            0000000.00 AS nNonEmp ;
		            FROM suspense, investor ;
		            WHERE suspense.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND NOT EMPTY(suspense.csusptype) ;
		            AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND (cTypeInv = 'L' ;
		            OR cTypeInv = 'O') ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            AND (suspense.lManual = .F. OR ;
		            (suspense.lManual = .T. ;
		            AND EMPTY(suspense.csusptype) ;
		            AND crectype # 'P')) ;
		            ORDER BY suspense.cwellid, suspense.cOwnerID ;
		            GROUP BY suspense.cwellid, suspense.cOwnerID ;
		            INTO CURSOR wrk1099rss READWRITE
		         SELECT wrk1099rss
		         INDEX ON cID TAG cID
		
		      CASE NOT llGross1099   && Net Revenue
		
		         *  Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year, which would include previous year suspense released during this year
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            SUM(nNetCheck) AS nNonEmp, ;
		            0000000.00 AS nroyalty, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND EMPTY(disbhist.csusptype) ;
		            AND cTypeInv <> 'L'  ;
		            AND cTypeInv <> 'O' ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099w READWRITE
		         SELECT wrk1099w
		         INDEX ON cID TAG cID
		
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            SUM(nNetCheck) AS nNonEmp, ;
		            0000000.00 AS nroyalty ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND NOT EMPTY(disbhist.csusptype) ;
		            AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND cTypeInv <> 'L'  ;
		            AND cTypeInv <> 'O' ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099ws READWRITE
		         SELECT wrk1099ws
		         INDEX ON cID TAG cID
		
		         SELECT  MAX(suspense.cOwnerID) AS cID, ;
		            suspense.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            suspense.cprogcode, ;
		            IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(suspense.ntrprev) AS ntrprev, ;
		            SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            SUM(nNetCheck) AS nNonEmp, ;
		            0000000.00 AS nroyalty ;
		            FROM suspense, investor ;
		            WHERE suspense.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND cTypeInv <> 'L'  ;
		            AND cTypeInv <> 'O' ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            ORDER BY suspense.cwellid, suspense.cOwnerID ;
		            GROUP BY suspense.cwellid, suspense.cOwnerID ;
		            INTO CURSOR wrk1099wss READWRITE
		         SELECT wrk1099wss
		         INDEX ON cID TAG cID
		
		         * Get both the entries with a valid hdate on them, plus any entry with a run that had a valid date on it from this year, which would include previous year suspense released during this year
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            IIF(llFlatRent,SUM(disbhist.nNetCheck-disbhist.nflatrate),SUM(disbhist.nNetCheck)) AS nroyalty, ;
		            IIF(llFlatRent,SUM(IIF(disbhist.lflat, disbhist.nflatrate,0)),0) AS nrents, ;
		            0000000.00 AS nNonEmp ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND (disbhist.cRunYear + PADL(TRANSFORM(disbhist.nrunno), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND EMPTY(disbhist.csusptype) ;
		            AND (cTypeInv = 'L' ;
		            OR cTypeInv = 'O') ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099r READWRITE
		         SELECT wrk1099r
		         INDEX ON cID TAG cID
		
		         SELECT  MAX(disbhist.cOwnerID) AS cID, ;
		            disbhist.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            disbhist.cprogcode, ;
		            IIF(disbhist.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(disbhist.ntrprev) AS ntrprev, ;
		            SUM(disbhist.nGATHER + disbhist.nCOMPRESS) AS ncompgath, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            IIF(llFlatRent,SUM(disbhist.nNetCheck-disbhist.nflatrate),SUM(disbhist.nNetCheck)) AS nroyalty, ;
		            IIF(llFlatRent,SUM(disbhist.nflatrate),0) AS nrents, ;
		            0000000.00 AS nNonEmp ;
		            FROM disbhist, investor ;
		            WHERE disbhist.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND NOT EMPTY(disbhist.csusptype) ;
		            AND (disbhist.cRunYear_in + PADL(TRANSFORM(disbhist.nrunno_in), 3, '0')+disbhist.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND (cTypeInv = 'L' ;
		            OR cTypeInv = 'O') ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND disbhist.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            ORDER BY disbhist.cwellid, disbhist.cOwnerID ;
		            GROUP BY disbhist.cwellid, disbhist.cOwnerID ;
		            INTO CURSOR wrk1099rs READWRITE
		         SELECT wrk1099rs
		         INDEX ON cID TAG cID
		
		         SELECT  MAX(suspense.cOwnerID) AS cID, ;
		            suspense.cwellid, ;
		            'I' AS cidtype, ;
		            lcYear AS cYear, ;
		            'G' AS cType, ;
		            investor.cOwnName AS cName, ;
		            IIF(investor.lChkToSec, '', investor.cOwnName1) AS cName2,  ;
		            IIF(investor.lChkToSec, investor.cAddress2a, investor.caddress1a) AS caddr1, ;
		            IIF(investor.lChkToSec, investor.cAddress2b, investor.caddress1b) AS caddr2, ;
		            IIF(investor.lChkToSec, investor.cCity2, investor.ccity1) AS ccity, ;
		            IIF(investor.lChkToSec, investor.cState2, investor.cstate1) AS cstate, ;
		            IIF(investor.lChkToSec, investor.cZip2, investor.czip1) AS czip, ;
		            IIF(investor.lChkToSec, investor.cCountry2, investor.ccountry1) AS ccountry, ;
		            investor.cTaxID, ;
		            suspense.cprogcode, ;
		            IIF(suspense.cTypeInv = 'W', 'W', 'R') AS cRptGroup,  ;
		            SUM(suspense.ntrprev) AS ntrprev, ;
		            SUM(suspense.nGATHER + suspense.nCOMPRESS) AS ncompgath, ;
		            SUM(nbackwith) AS nfedtax, ;
		            SUM(ntaxwith) AS nstatetax, ;
		            IIF(llFlatRent,SUM(suspense.nNetCheck-suspense.nflatrate),SUM(suspense.nNetCheck)) AS nroyalty, ;
		            IIF(llFlatRent,SUM(suspense.nflatrate),0) AS nrents, ;
		            0000000.00 AS nNonEmp ;
		            FROM suspense, investor ;
		            WHERE suspense.cOwnerID = investor.cOwnerID   ;
		            AND investor.lInv1099 = .T.  ;
		            AND NOT EMPTY(suspense.csusptype) ;
		            AND (suspense.cRunYear_in + PADL(TRANSFORM(suspense.nrunno_in), 3, '0')+suspense.cgroup IN ;
		            (SELECT  cRunYear + PADL(TRANSFORM(nrunno), 3, '0')+cgroup ;
		            FROM sysctl ;
		            WHERE YEAR(dacctdate) = VAL(lcYear)));
		            AND (cTypeInv = 'L' ;
		            OR cTypeInv = 'O') ;
		            AND crectype = 'R' ;
		            AND investor.ldummy = .F. ;
		            AND suspense.cprogcode NOT IN (SELECT  cprogcode ;
		            FROM programs ;
		            WHERE lprog1099 = .F.) ;
		            ORDER BY suspense.cwellid, suspense.cOwnerID ;
		            GROUP BY suspense.cwellid, suspense.cOwnerID ;
		            INTO CURSOR wrk1099rss READWRITE
		         SELECT wrk1099rss
		         INDEX ON cID TAG cID
		   ENDCASE
		   SET TALK OFF
		   WAIT CLEAR
		
		   *
		   *  Create vendor 1099s
		   *
		   IF NOT m.goApp.lQBVersion
		      SELECT  MAX(vendor.cVendorID)  AS cID, ;
		         checks.cidtype AS cidtype, ;
		         vendor.cvendname AS cName, ;
		         '' AS cName2,  ;
		         lcYear AS cYear, ;
		         'N' AS cType, ;
		         SUM(checks.nAmount) AS nNonEmp, ;
		         00000000.00 AS nrents, ;
		         vendor.cbaddr1 AS caddr1, ;
		         vendor.cbaddr2 AS caddr2, ;
		         vendor.cTaxID  AS cTaxID, ;
		         vendor.cbcity  AS ccity, ;
		         vendor.cbstate AS cstate, ;
		         vendor.cbzip   AS czip, ;
		         vendor.cbcountry AS ccountry, ;
		         0000000.00 AS nroyalty ;
		         FROM checks, vendor ;
		         WHERE vendor.cVendorID = checks.cID  ;
		         AND checks.cidtype   = 'V' ;
		         AND checks.lvoid     = .F. ;
		         AND vendor.lsend1099 = .T. ;
		         AND YEAR(dcheckdate) = VAL(lcYear) ;
		         INTO CURSOR wrk1099v ;
		         GROUP BY &lcGroupByV
		   ELSE
		      IF m.goApp.oQB.QBFCVersion < ' 5.0'
		         IF THIS.oMessage.CONFIRM('You must update your QuickBooks interface in order for vendor 1099s to be processed. ' + ;
		               'QBFC needs to be at least version 5. Your version is: ' + ALLTRIM(m.goApp.oQB.QBFCVersion) + '. Download and install: support.sherware.com/download/qbfc5.exe?')
		            oLink = CREATEOBJECT('hyperlink')
		            oLink.NAVIGATETO('support.sherware.com/download/qbfc5.exe')
		         ENDIF
		      ENDIF
		
		      IF llQBVendor1099
		         llReturn = THIS.qbvendor1099()
		         IF NOT llReturn
		            EXIT
		         ENDIF
		      ENDIF
		   ENDIF
		
		   SELE wrk1099w
		   lnMax = RECC()
		   SELE wrk1099ws
		   lnMax = lnMax + RECCOUNT()
		   SELE wrk1099wss
		   lnMax = lnMax + RECCOUNT()
		   SELE wrk1099r
		   lnMax = lnMax + RECC()
		   SELECT wrk1099rs
		   lnMax = lnMax + RECCOUNT()
		   SELECT wrk1099rss
		   lnMax = lnMax + RECCOUNT()
		
		   IF USED('wrk1099v')
		      SELE wrk1099v
		      lnMax = lnMax + RECC()
		   ENDIF
		
		   lnProgress = 0
		   oProgress  = THISFORM.oMessage.ProgressBar('')
		   oProgress.SetProgressRange(0, lnMax)
		
		   oProgress.SetProgressMessage('Creating Working Interest 1099 Records for ' + lcYear + '....')
		   SELE wrk1099w
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      IF llTranExp
		         m.nNonEmp = m.nNonEmp - m.ntrprev
		      ENDIF
		      m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		      SET DELE OFF
		      SELE tax10991
		      SET ORDER TO cidtax1
		      DO WHILE SEEK(m.cidtax1)
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		      ENDDO
		      SET DELE ON
		      IF glHideComp
		         m.nNonEmp = m.nNonEmp - m.ncompgath
		      ENDIF
		      INSERT INTO tax1099 FROM MEMVAR
		   ENDSCAN
		   SELE wrk1099ws
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		
		      SELECT tax1099
		      SET ORDER TO yearwell
		      SEEK (lcYear + m.cwellid + m.cID)
		      IF FOUND()
		         IF llTranExp
		            m.nNonEmp = m.nNonEmp - m.ntrprev
		         ENDIF
		         REPLACE nNonEmp WITH nNonEmp + m.nNonEmp
		      ELSE
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         SET DELE ON
		         IF llTranExp
		            m.nNonEmp = m.nNonEmp - m.ntrprev
		         ENDIF
		         INSERT INTO tax1099 FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   SELE wrk1099wss
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		
		      SELECT tax1099
		      SET ORDER TO yearwell
		      SEEK (lcYear + m.cwellid + m.cID)
		      IF FOUND()
		         IF llTranExp
		            m.nNonEmp = m.nNonEmp - m.ntrprev
		         ENDIF
		         REPLACE nNonEmp WITH nNonEmp + m.nNonEmp
		      ELSE
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         SET DELE ON
		         IF llTranExp
		            m.nNonEmp = m.nNonEmp - m.ntrprev
		         ENDIF
		         INSERT INTO tax1099 FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   USE IN wrk1099w
		   USE IN wrk1099ws
		   USE IN wrk1099wss
		
		   *
		   *  Insert Royalty records into work cursor
		   *
		   oProgress.SetProgressMessage('Creating Royalty Interest 1099 Records for ' + lcYear + '....')
		   SELECT wrk1099r
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      SELECT tax1099
		      SET ORDER TO yearwell
		      SEEK (lcYear + m.cwellid + m.cID)
		      IF FOUND()
		         IF llTranExp
		            m.nroyalty = m.nroyalty - m.ntrprev
		         ENDIF
		         REPLACE nroyalty WITH nroyalty + m.nroyalty
		      ELSE
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         SET DELE ON
		         IF llTranExp
		            m.nroyalty = m.nroyalty - m.ntrprev
		         ENDIF
		         INSERT INTO tax1099 FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   SELECT wrk1099rs
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      SELECT tax1099
		      SET ORDER TO yearwell
		      SEEK (lcYear + m.cwellid + m.cID)
		      IF FOUND()
		         IF llTranExp
		            m.nroyalty = m.nroyalty - m.ntrprev
		         ENDIF
		         REPLACE nroyalty WITH nroyalty + m.nroyalty
		      ELSE
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         SET DELE ON
		         IF llTranExp
		            m.nroyalty = m.nroyalty - m.ntrprev
		         ENDIF
		         INSERT INTO tax1099 FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   SELECT wrk1099rss
		   SCAN
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      SELECT tax1099
		      SET ORDER TO yearwell
		      SEEK (lcYear + m.cwellid + m.cID)
		      IF FOUND()
		         IF llTranExp
		            m.nroyalty = m.nroyalty - m.ntrprev
		         ENDIF
		         REPLACE nroyalty WITH nroyalty + m.nroyalty
		      ELSE
		         m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         SET DELE ON
		         IF llTranExp
		            m.nroyalty = m.nroyalty - m.ntrprev
		         ENDIF
		         INSERT INTO tax1099 FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELECT tax1099
		   SET ORDER TO primkey
		
		   lcYear1 = STR(VAL(lcYear) + 1, 4)
		
		   IF USED('wrk1099v')
		      oProgress.SetProgressMessage('Creating Vendor 1099 Records for ' + lcYear + '....')
		      SELECT wrk1099v
		      SCAN
		         SCATTER MEMVAR
		         oProgress.UpdateProgress(lnProgress)
		         lnProgress  = lnProgress + 1
		         m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         m.cwellid   = ''
		         m.cwellname = ''
		         m.cWellTax  = ''
		         m.cName2    = ''
		         m.cYear     = lcYear
		         STORE '' TO m.ctaxstate1, m.ctaxstate2, m.cstatepayerno1, m.cstatepayerno2
		         STORE 0  TO m.nstatetax1, m.nfedtax, m.nstatetax2
		         SET DELE OFF
		         SELE tax10991
		         SET ORDER TO cidtax1
		         DO WHILE SEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		         ENDDO
		         INSERT INTO tax1099 FROM MEMVAR
		         SET DELE ON
		      ENDSCAN
		   ENDIF
		
		   IF TYPE('oProgress') = 'O'
		      oProgress.CloseProgress()
		   ENDIF
		
		   * Create the 1099DET file with the detail for the reconciliation report
		   llReturn = THISFORM.MakeFileDetEarned()
		   IF NOT llReturn
		      EXIT
		   ENDIF
		
		   *
		   *  Check to see if we're integrated with the Accounting Manager
		   *  If so, we need to check the coa table for a rent account
		   *
		   IF TYPE('m.goApp') = 'O'
		      IF m.goApp.lAMVersion
		         WAIT WIND NOWAIT 'Processing rental 1099s...'
		         *
		         *  Calculate the rental 1099 amounts
		         *
		         CREATE CURSOR rents ;
		            (cID       C(10), ;
		            nAmount   N(12, 2))
		         SELECT coa
		         SCAN FOR lRent1099
		            m.cacctno = cacctno
		
		            SELECT  cID, SUM(nDebits - nCredits) AS nAmount ;
		               FROM glmaster ;
		               WHERE YEAR(ddate) = VAL(lcYear) ;
		               AND cacctno = m.cacctno ;
		               INTO CURSOR tmp1 ;
		               ORDER BY cID ;
		               GROUP BY cID
		
		            IF _TALLY > 0
		               SELECT rents
		               APPEND FROM DBF('tmp1')
		            ENDIF
		         ENDSCAN
		
		         SELECT  cID, SUM(nAmount) AS nAmount ;
		            FROM rents ;
		            INTO CURSOR temprent ;
		            ORDER BY cID ;
		            GROUP BY cID
		
		         SELECT tax1099
		         SET ORDER TO primkey
		         SELECT temprent
		         SCAN FOR nAmount > 0
		            STORE 0 TO m.nroyalty, m.nrents, m.nNonEmp
		            SCATTER MEMVAR
		
		            SELECT tax1099
		            IF SEEK(lcYear + m.cID)
		               REPLACE nrents WITH m.nAmount
		               IF cidtype = 'V'
		                  REPLACE nNonEmp WITH nNonEmp - m.nAmount
		               ENDIF
		            ELSE
		               m.nNonEmp  = 0
		               m.nroyalty = 0
		               SELECT vendor
		               SET ORDER TO cVendorID
		               IF SEEK(m.cID) AND lsend1099
		                  m.cName     = cvendname
		                  m.cName2    = ''
		                  m.caddr1    = cbaddr1
		                  m.caddr2    = cbaddr2
		                  m.ccity     = cbcity
		                  m.cstate    = cbstate
		                  m.czip      = cbzip
		                  m.ccountry  = cbcountry
		                  m.cTaxID    = cTaxID
		                  m.nrents    = m.nAmount
		                  m.cYear     = lcYear
		                  m.cidtype   = 'V'
		                  m.cwellid   = ''
		                  m.cwellname = ''
		                  m.cType     = IIF(llGross1099, 'G', 'N')
		                  m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  SET DELE OFF
		                  SELE tax10991
		                  SET ORDER TO cidtax1
		                  DO WHILE SEEK(m.cidtax1)
		                     m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  ENDDO
		                  SET DELE ON
		                  INSERT INTO tax1099 FROM MEMVAR
		               ELSE
		                  SELECT investor
		                  SET ORDER TO cOwnerID
		                  IF SEEK(m.cID) AND lInv1099
		                     m.cName     = cOwnName
		                     m.cName2    = cOwnName1
		                     m.caddr1    = caddress1a
		                     m.caddr2    = caddress1b
		                     m.ccity     = ccity1
		                     m.cstate    = cstate1
		                     m.czip      = czip1
		                     m.ccountry  = ccountry1
		                     m.cTaxID    = cTaxID
		                     m.nrents    = m.nAmount
		                     m.cYear     = lcYear
		                     m.cwellid   = ''
		                     m.cwellname = ''
		                     m.cidtype   = 'I'
		                     m.cType     = IIF(llGross1099, 'G', 'N')
		                     m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     SET DELE OFF
		                     SELE tax10991
		                     SET ORDER TO cidtax1
		                     DO WHILE SEEK(m.cidtax1)
		                        m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                     ENDDO
		                     SET DELE ON
		                     INSERT INTO tax1099 FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDSCAN
		      ELSE
		         SELECT  checks.cID  AS cID, ;
		            checks.cidtype  AS cidtype, ;
		            checks.cpayee   AS cName, ;
		            lcYear          AS cYear, ;
		            IIF(llGross1099, 'G', 'N') AS cType, ;
		            SUM(checks.nAmount) AS nrents, ;
		            investor.caddress1a AS caddr1, ;
		            investor.caddress1b AS caddr2, ;
		            investor.cOwnName1 AS cName2,  ;
		            investor.cTaxID     AS cTaxID, ;
		            investor.ccity1  AS ccity, ;
		            investor.cstate1 AS cstate, ;
		            investor.czip1   AS czip, ;
		            investor.ccountry1 AS ccountry, ;
		            0000000.00 AS nroyalty, ;
		            0000000.00 AS nNonEmp  ;
		            FROM checks, investor ;
		            WHERE investor.cOwnerID = checks.cID  ;
		            AND checks.cidtype   = 'I' ;
		            AND checks.csource   = 'LM' ;
		            AND checks.lvoid     = .F. ;
		            AND investor.lInv1099 = .T. ;
		            AND investor.ldummy = .F. ;
		            AND YEAR(dcheckdate) = VAL(lcYear) ;
		            INTO CURSOR wrk1099 ;
		            GROUP BY cID
		
		         IF _TALLY > 0
		            SELE wrk1099
		            SCAN
		               SCATTER MEMVAR
		               m.cwellid   = ''
		               m.cwellname = ''
		               m.nNonEmp   = 0
		               m.nroyalty  = 0
		               SELECT tax1099
		               SET ORDER TO yearwell
		               SEEK (lcYear + m.cwellid + m.cID)
		               IF FOUND()
		                  REPLACE nrents WITH m.nrents
		               ELSE
		                  m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  SET DELE OFF
		                  SELE tax10991
		                  SET ORDER TO cidtax1
		                  DO WHILE SEEK(m.cidtax1)
		                     m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		                  ENDDO
		                  SET DELE ON
		                  m.cYear = lcYear
		                  INSERT INTO tax1099 FROM MEMVAR
		               ENDIF
		            ENDSCAN
		         ENDIF
		      ENDIF
		   ENDIF
		
		   SELECT temp1099det
		   COUNT FOR cYear == lcYear TO lnMax
		   lnProgress = 1
		   oProgress  = THISFORM.oMessage.ProgressBar('')
		   oProgress.SetProgressRange(0, lnMax)
		   oProgress.SetProgressMessage('Cleaning Up 1099 Detail File...')
		   SELECT temp1099det
		   SCAN FOR cYear = lcYear
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      IF nincome = 0 AND nexpense = 0 AND nsevtaxes = 0
		         DELETE NEXT 1
		      ELSE
		         IF (nincome - nexpense - nrents - nsevtaxes <> nNetCheck) AND nNetCheck = 0
		            * Only doing the adjustment if calculating on gross
		            IF llGross1099
		               SELECT tax1099
		               IF llByTaxID
		                  LOCATE FOR ALLTRIM(cTaxID) = ALLTRIM(temp1099det.cTaxID) AND cYear = lcYear AND cwellid = temp1099det.cwellid
		               ELSE
		                  LOCATE FOR cID = temp1099det.cID AND cYear = lcYear AND cwellid = temp1099det.cwellid
		               ENDIF
		               IF FOUND()
		                  IF temp1099det.cRptGroup = 'W'
		                     REPLACE nNonEmp WITH nNonEmp - temp1099det.nincome
		                  ELSE
		                     REPLACE nroyalty WITH nroyalty - temp1099det.nincome
		                  ENDIF
		                  SELECT temp1099det
		                  DELETE NEXT 1
		               ENDIF
		            ELSE
		               DELETE NEXT 1
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		   oProgress.CloseProgress()
		
		   SELECT tax1099
		   SCAN FOR cYear = lcYear
		      m.cwellid = cwellid
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(m.cwellid)
		         m.cWellTax  = cwelltaxid
		         m.cwellname = cwellname
		      ELSE
		         m.cWellTax  = 'Not known'
		         m.cwellname = 'Not known'
		      ENDIF
		      SELECT tax1099
		      REPL cWellTax  WITH m.cWellTax, ;
		         cwellname WITH m.cwellname
		   ENDSCAN
		
		
		   *  Clean up the 1099 file.  There should be no "Dummy"
		   *  owners in the file,  There should also not be any
		   *  negative numbers.  If any are found, deleted them.
		   *
		   SELECT tax1099
		   COUNT FOR cYear == lcYear AND NOT DELETED() TO lnMax
		   lnProgress = 1
		   oProgress  = THISFORM.oMessage.ProgressBar('')
		   oProgress.SetProgressRange(0, lnMax)
		   oProgress.SetProgressMessage('Performing 1099 Cleanup...')
		   SELECT tax1099
		   GO TOP
		   SCAN FOR cYear = lcYear
		      SCATTER MEMVAR
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      IF nroyalty < 0
		         REPLACE nroyalty WITH 0
		      ENDIF
		      IF nrents < 0
		         REPLACE nrents WITH 0
		      ENDIF
		      IF nNonEmp < 0
		         REPLACE nNonEmp WITH 0
		      ENDIF
		      IF nfedtax < 0
		         REPLACE nfedtax WITH 0
		      ENDIF
		      IF nstatetax1 < 0
		         REPLACE nstatetax1 WITH 0
		      ENDIF
		      IF nstatetax2 < 0
		         REPLACE nstatetax2 WITH 0
		      ENDIF
		      IF nroyalty = 0 AND nrents = 0 AND nfedtax = 0 AND nstatetax1 = 0 AND nstatetax2 = 0 AND nNonEmp  = 0
		         DELETE NEXT 1
		         SELECT temp1099det
		         DELETE FOR cID == m.cID AND cYear == m.cYear AND cwellid = m.cwellid
		      ENDIF
		      IF lnMin1099Non > 0
		         SELECT tax1099
		         IF nNonEmp < lnMin1099Non AND nroyalty < lnMin1099Roy AND nrents < lnMin1099Non
		            DELETE NEXT 1
		            SELECT temp1099det
		            DELETE FOR cID == m.cID AND cYear == m.cYear AND cwellid = m.cwellid
		         ENDIF
		         IF nrents < lnMin1099Non AND nroyalty < lnMin1099Roy AND nNonEmp < lnMin1099Non
		            DELETE NEXT 1
		            SELECT temp1099det
		            DELETE FOR cID == m.cID AND cYear == m.cYear AND cwellid = m.cwellid
		         ENDIF
		      ENDIF
		      IF lnMin1099Roy > 0
		         SELECT tax1099
		         IF nroyalty < lnMin1099Roy AND nrents < lnMin1099Non AND nNonEmp < lnMin1099Non
		            DELETE NEXT 1
		            SELECT temp1099det
		            DELETE FOR cID == m.cID AND cYear == m.cYear AND cwellid = m.cwellid
		         ENDIF
		      ENDIF
		   ENDSCAN
		   oProgress.CloseProgress()
		
		   WAIT WINDOW NOWAIT 'Removing detail records without 1099s...'
		   **  If we're not building by tax ID, compare cid between tax1099 and temp1099det and delete any detail records
		   **  without a corresponding 1099.  Otherwise, compare ctaxid
		   IF NOT llByTaxID
		      SELECT  cID ;
		         FROM temp1099det WITH (BUFFERING = .T.) ;
		         WHERE cYear = lcYear  ;
		         AND cID NOT IN (SELECT  cID ;
		         FROM tax1099 ;
		         WHERE cYear = lcYear) ;
		         INTO CURSOR no1099 ;
		         ORDER BY cID ;
		         GROUP BY cID
		
		      ** Remove detail records for owners with no 1099
		      SELECT no1099
		      SCAN
		         m.cID = cID
		         SELECT temp1099det
		         SCAN FOR cYear + cID == lcYear + m.cID
		            DELETE NEXT 1
		         ENDSCAN
		      ENDSCAN
		   ELSE
		      **  By tax ID, so compare ctaxid fields to determine whether to remove the temp1099det records
		      SELECT  cTaxID ;
		         FROM temp1099det WITH (BUFFERING = .T.) ;
		         WHERE cYear = lcYear  ;
		         AND cTaxID NOT IN (SELECT  cTaxID ;
		         FROM tax1099 ;
		         WHERE cYear = lcYear) ;
		         INTO CURSOR no1099 ;
		         ORDER BY cTaxID ;
		         GROUP BY cTaxID
		
		      ** Remove detail records for owners with no 1099
		      SELECT no1099
		      SCAN
		         m.cTaxID = ALLTRIM(cTaxID)
		         SELECT temp1099det
		         SCAN FOR cYear + ALLTRIM(cTaxID) == lcYear + ALLTRIM(m.cTaxID)
		            DELETE NEXT 1
		         ENDSCAN
		      ENDSCAN
		   ENDIF
		
		
		   ** Clean up expense to make sure the records foot across
		   SELECT temp1099det
		   COUNT FOR cYear == lcYear AND NOT DELETED() TO lnMax
		   lnProgress = 1
		   oProgress  = THISFORM.oMessage.ProgressBar('')
		   oProgress.SetProgressRange(0, lnMax)
		   oProgress.SetProgressMessage('Finalizing 1099s...')
		   SELECT temp1099det
		   SCAN FOR cYear == lcYear
		      oProgress.UpdateProgress(lnProgress)
		      lnProgress = lnProgress + 1
		      lnDiff = (nincome - nexpense - nsevtaxes - nrents - nstatetax1 - nstatetax2 - nfedtax - ncompgath) - nNetCheck
		      IF  lnDiff <> 0
		         IF lnDiff > 0
		            IF nexpense + lnDiff < 0
		               lnDiff = nexpense + lnDiff
		               REPLACE nexpense WITH 0
		               IF nsevtaxes + lnDiff < 0
		                  REPLACE nexpense WITH nexpense + lnDiff
		               ELSE
		                  REPLACE nsevtaxes WITH nsevtaxes + lnDiff
		               ENDIF
		            ELSE
		               REPLACE nexpense WITH nexpense + lnDiff
		            ENDIF
		         ELSE
		            IF nexpense - lnDiff < 0
		               lnDiff = nexpense - lnDiff
		               REPLACE nexpense WITH 0
		               IF nsevtaxes - lnDiff < 0
		                  REPLACE nexpense WITH nexpense - lnDiff
		               ELSE
		                  REPLACE nsevtaxes WITH nsevtaxes - lnDiff
		               ENDIF
		            ELSE
		               REPLACE nexpense WITH nexpense + lnDiff
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		   oProgress.CloseProgress()
		
		   SELECT tax1099
		   SCAN FOR cTaxID = cID AND cYear = lcYear
		      REPLACE cTaxID WITH ''
		   ENDSCAN
		
		   SELECT temp1099det
		   SCAN FOR cTaxID = cID
		      REPLACE cTaxID WITH ''
		   ENDSCAN
		
		   SELECT tax1099
		   = TABLEUPDATE(.T.)
		   SELECT tax1099det
		   APPEND FROM DBF('temp1099det')
		   TABLEUPDATE(.T.)
		
		   IF llByTaxID  &&  If creating by tax ID, scan the investor file and plug in the owner ID as the tax ID, so it's unique, and can be grouped correctly.
		      WAIT WINDOW NOWAIT 'Cleaning up blank tax ID records'
		      SELECT investor
		      SCAN FOR cTaxID = cOwnerID AND lInv1099
		         REPLACE cTaxID WITH ''
		      ENDSCAN
		      = TABLEUPDATE(.T.)
		   ENDIF
		
		   lnState = 0
		
		   WAIT CLEAR
		
		   SELECT tax1099
		   COUNT FOR cYear = lcYear AND NOT DELETED() TO lnCount
		
		   MESSAGEBOX('Finished Processing 1099s for ' + lcYear + CHR(10) + CHR(10) + ;
		      'Created ' + ALLTRIM(TRANSFORM(lnCount, '999,999')) + ' Federal 1099s ' + ;
		      IIF(lnState # 0, ' and ' + ALLTRIM(TRANSFORM(lnState, '999,999')) + ' State 1099s ', ''), 64, '1099 Processing Counts')
		
		   IF USED('temprent')
		      USE IN temprent
		   ENDIF
		   IF USED('tmp1')
		      USE IN tmp1
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'MakeFileEarned', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		   IF VARTYPE(oProgress) = 'O'
		      oProgress.CloseProgress()
		   ENDIF
		   MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		oProgress = .NULL.
		
		RETURN llReturn
		
		
		
		
		
	ENDPROC

	PROCEDURE make_state_1099s
		*  Get all information from the tax1099det file.  That's already had all
		*  the suspense adjustments and processing done to it, so we just need
		*  to pull the data from there and group by well state.
		
		LOCAL lcYear, llGross, lcVendState
		LOCAL llReturn, lnMin1099Non, lnMin1099Roy, lncount, loError
		*:Global cidtax1, nFedTax, nStateTax
		
		llReturn = .T.
		
		TRY
		    lcYear      = THISFORM.txtcYear.VALUE
		    lcVendState = ''
		
		    IF NOT USED('compmast')
		        USE (m.goapp.cCommonFolder + 'compmast') IN 0
		    ENDIF
		    SELECT compmast
		    LOCATE FOR cidcomp == m.goapp.cidcomp
		    IF FOUND()
		        lcVendState = cState
		    ENDIF
		
		    SELECT tax1099st
		    LOCATE FOR cYear = lcYear
		    IF FOUND()
		        SELECT tax1099st
		        SET ORDER TO cYear   && CYEAR
		        SCAN FOR cYear = lcYear
		            DELETE NEXT 1
		        ENDSCAN
		    ENDIF
		
		    SELECT options
		    GO TOP
		    llGross      = options.lGross1099
		    lnMin1099Roy = nMin1099Roy
		    lnMin1099Non = nMin1099Non
		
		*  Pull Royalty entries first, then merge in WI later
			SELECT  temp1099det.*, SUM(nrents) AS nrent, IIF(llGross, SUM(nIncome), SUM(nNetCheck)) AS nRoyalty, 000000.00 AS nNonEmp,  ;
					SUM(nStateTax) AS nStateTax1, SUM(nFedTax) AS nFedTax1, ctaxstate AS c1099State  ;
				FROM temp1099det ;
				WHERE cYear = lcYear  ;
					AND cRptGroup <> 'W'  ;
					AND NOT EMPTY(ctaxstate) ;
				GROUP BY cid, c1099State  ;
				INTO CURSOR state1099tempR READWRITE
		
		*  WI entries
			SELECT  temp1099det.*, SUM(nrents) AS nrent, IIF(llGross, SUM(nIncome), SUM(nNetCheck)) AS nNonEmp,  ;
					SUM(nStateTax) AS nStateTax1, SUM(nFedTax) AS nFedTax1, ctaxstate AS c1099State,  ;
					temp1099det.cState AS cState  ;
				FROM temp1099det ;
				WHERE cYear = lcYear  ;
					AND cRptGroup = 'W'  ;
					AND NOT EMPTY(ctaxstate) ;
				GROUP BY cid, c1099State  ;
				INTO CURSOR state1099tempW
		
		    SELECT state1099tempR
		    SCAN
		        REPLACE nRoyalty WITH nRoyalty - nrent
		    ENDSCAN
		    STORE 0 TO m.nRoyalty, m.nrent, m.nNonEmp, m.nOther, m.nStateTax, m.nFedTax, m.nrent, m.nrents
		*  Merge together
		    SELECT state1099tempW
		    SCAN FOR NOT INLIST(c1099state,'AK','FL','NH','NV','SD','TN','TX','WA','WY')
		        SCATTER MEMVAR
		        m.nNonEmp = m.nNonEmp - m.nrent
		        SELECT state1099tempR
		        LOCATE FOR cYear = m.cYear AND c1099State = m.c1099State AND cid = m.cid
		        IF FOUND()
		            REPLACE nrent WITH nrent + m.nrent, ;
		                nNonEmp WITH nNonEmp + m.nNonEmp,  ;
		                nStateTax1 WITH nStateTax1 + m.nStateTax1,  ;
		                nFedTax1 WITH nFedTax1 + m.nFedTax1
		        ELSE
		            INSERT INTO state1099tempR FROM MEMVAR
		        ENDIF
		    ENDSCAN
		
		    SELECT state1099tempR
		    SCAN FOR NOT INLIST(c1099state,'AK','FL','NH','NV','SD','TN','TX','WA','WY')
		        SCATTER MEMVAR
		
		        m.nStateTax = m.nStateTax1
		        m.nFedTax   = m.nFedTax1
		        m.nrents    = m.nrent
		        m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		        SET DELE OFF
		        SELE tax1099st1
		        SET ORDER TO cidtax1
		        DO WHILE INDEXSEEK(m.cidtax1)
		            m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		        ENDDO
		        SET DELE ON
		        INSERT INTO tax1099st FROM MEMVAR
		    ENDSCAN
		
		*
		*  Clean up the 1099 file.  There should be no "Dummy"
		*  owners in the file,  There should also not be any
		*  negative numbers.  If any are found, deleted them.
		*
		    SELECT tax1099st
		    GO TOP
		    SCAN
		        SCATTER MEMVAR
		        IF nRoyalty < 0
		            REPLACE nRoyalty WITH 0
		        ENDIF
		        IF nrents < 0
		            REPLACE nrents WITH 0
		        ENDIF
		        IF nFedTax < 0
		            REPLACE nFedTax WITH 0
		        ENDIF
		        IF nStateTax < 0
		            REPLACE nStateTax WITH 0
		        ENDIF
		        IF nNonEmp < 0
		            REPLACE nNonEmp WITH 0
		        ENDIF
		        IF nRoyalty = 0 AND nrents = 0 AND nFedTax = 0 AND nStateTax = 0 AND nNonEmp = 0
		            DELETE NEXT 1
		        ENDIF
		        IF lnMin1099Non > 0
		            IF nNonEmp < lnMin1099Non AND nRoyalty = 0 AND nrents = 0
		                DELETE NEXT 1
		                LOOP
		            ENDIF
		        ENDIF
		        IF lnMin1099Roy > 0
		            IF nRoyalty < lnMin1099Roy AND nrents = 0 AND nNonEmp = 0
		                DELETE NEXT 1
		                LOOP
		            ENDIF
		        ENDIF
		    ENDSCAN
		
		    SELECT tax1099st
		    TABLEUPDATE(.T., .T.)
		
		    swclose('state1099tempR')
		    swclose('state1099tempW')
		
		    swselect('vendor')
		    SET ORDER TO cvendorid
		
		* Include vendor 1099s
		    swselect('tax1099')
		    SCAN FOR cidtype = 'V' AND cYear = lcYear
		        SCATTER MEMVAR
		
		        SELECT vendor
		        IF SEEK(m.cid)
		            m.c1099State = cbstate
		            IF EMPTY(m.c1099state)
		               LOOP
		            ENDIF 
		            m.cidtax1   = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            SET DELE OFF
		            SELE tax1099st1
		            SET ORDER TO cidtax1
		            DO WHILE INDEXSEEK(m.cidtax1)
		                m.cidtax1 = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.1099Key')
		            ENDDO
		            SET DELE ON
		
		            INSERT INTO tax1099st FROM MEMVAR
		        ENDIF
		    ENDSCAN
		
		    SELECT tax1099st
		    COUNT FOR NOT DELETED() AND cYear = lcYear TO lncount
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'Make_State_1099s', loError.LINENO, 'Create 1099 File', loError.ERRORNO, loError.MESSAGE, '', loError
		    IF VARTYPE(oProgress) = 'O'
		        oProgress.closeProgress()
		    ENDIF
		    MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		oProgress = .NULL.
		
		IF llReturn
		    RETURN lncount
		ELSE
		    RETURN llReturn
		ENDIF
	ENDPROC

	PROCEDURE oldsuspproc		&& Old removecuryearsuspense
	ENDPROC

	PROCEDURE plugcosts		&& Calculate and insert plugging fund charges
		LOCAL lcYear
		
		lcYear   = THISFORM.txtcYear.VALUE
		
		SELECT tax1099det
		SCAN FOR cyear = lcYear AND nPlugExp # 0
		   IF tax1099det.nexpense >=  nPlugExp
		      REPLACE nexpense WITH nexpense - nPlugExp
		   ENDIF
		ENDSCAN 
		
		TABLEUPDATE(.T.,.t.,'tax1099det')
	ENDPROC

	PROCEDURE plughdate		&& Plugs the correct hdate on released suspense
		LOCAL llReturn, loError
		
		llReturn = .T.
		
		TRY
		   swselect('sysctl')
		
		* Plug the correct hdate on released suspense
		   swselect('disbhist')
		   SCAN FOR NOT EMPTY(nrunno_in) AND NOT EMPTY(csusptype)
		      SELECT sysctl
		      LOCATE FOR nrunno = disbhist.nrunno AND crunyear = disbhist.crunyear AND cgroup = disbhist.cgroup AND sysctl.ctypeclose = 'R'
		      IF FOUND()
		         SELECT disbhist
		         REPLACE hdate WITH sysctl.dacctdate
		      ENDIF
		   ENDSCAN
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'PlugHDate', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn 
	ENDPROC

	PROCEDURE processoldsuspense		&& Processes the old susaudit suspense records that were converted.
	ENDPROC

	PROCEDURE qbvendor1099		&& Creates the vendor 1099s by calling QuickBooks to get the data.
		LOCAL lnAmount, llReturn
		LOCAL lcAccount, lclistid, lnX, loAcct, loAcctQuery, loAcctResp, loCredit, loDetail, loEntry
		LOCAL loError, loccquery, locharge, locharges, locheck, locheckquery, lochecks, locreditquery
		LOCAL locredits, lojournal, lojournalquery, lopmt, lopmtlist, lopmtquery
		
		llReturn = .T.
		
		IF NOT m.goApp.lQBVersion
		   RETURN .T.
		ENDIF
		
		LOCAL loCredit AS "qbfc12.ijournalcreditline"
		
		TRY
		   CREATE CURSOR wrk1099v ;
		      (cid       C(10), ;
		        cname     C(40), ;
		        cName2    C(40),  ;
		        cidtype   C(1), ;
		        cType     C(1), ;
		        caddr1    C(40), ;
		        caddr2    C(40), ;
		        ccity     C(25), ;
		        cstate    C(2), ;
		        czip      C(10), ;
		        ctaxid    C(15), ;
		        cprogcode C(10), ;
		        nStateTax1 N(12, 2), ;
		        nStateTax2 N(12, 2), ;
		        cTaxState1 C(2), ;
		        cTaxState2 C(2), ;
		        cStatePayerNo1 C(15), ;
		        cStatePayerNo2 C(15), ;
		        nroyalty  N(12, 2), ;
		        nrents    N(12, 2), ;
		        nNonEmp   N(12, 2))
		
		   IF m.goApp.oQB.QBFCVersion < ' 5.0'
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   IF NOT m.goApp.oQB.SDKVersion > ' 2.0'
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   #DEFINE    qbfileopensingleuser    0
		   #DEFINE    qbfileopenmultiuser        1
		   #DEFINE    qbfileopendonotcare     2
		   #DEFINE    qbstoponerror            0
		   #DEFINE    qbcontinueonerror        1
		
		   LOCAL lorequest, locustquery, loempquery, lovendquery
		   LOCAL loresponse, lccompanyfile, loempresp, lovendresp
		   LOCAL locustresp, locust, lni, lcfullname, lnsublevel, lccusttype
		   LOCAL lcacctno, lcphone, lcfirstname, lclastname, lchireddate, lcname
		   LOCAL ldDate1, ldDate2, lcYear
		
		   lcYear = THISFORM.txtcyear.VALUE
		
		   ldDate1 = CTOD('01/01/' + lcYear)
		   ldDate2 = CTOD('12/31/' + lcYear)
		
		   STORE 0 TO m.nroyalty, m.nrents
		
		   TRY
		* Clear any prior error info
		      m.goApp.oQB.oqbsm.ClearErrorRecovery()
		
		* Turn off QB Error Recovery
		      m.goApp.oQB.oqbsm.EnableErrorRecovery = .F.
		   CATCH
		   ENDTRY
		
		* set the on error attribute for the request
		   m.goApp.oQB.oQBRequest.ATTRIBUTES.onerror = 1
		
		* Clear any previous requests
		   m.goApp.oQB.oQBRequest.ClearRequests()
		
		* create output cursors
		   CREATE CURSOR Accounts (cAcctDesc C(60), clistid C(36))
		
		* add a customer query request to request message set
		   loAcctQuery = m.goApp.oQB.oQBRequest.AppendAccountQueryRq()
		
		* add a filter to the customer request to only pick up active customers
		   loAcctQuery.ORAccountListQuery.AccountListFilter.ActiveStatus.SetAsString('ActiveOnly')
		   loAcctQuery.ORAccountListQuery.AccountListFilter.AccountTypeList.ADD(2)   && Only bank accounts
		
		* process the request object RETURNing a response message object
		   loresponse = m.goApp.oQB.oqbsm.DoRequests(m.goApp.oQB.oQBRequest)
		
		* get reference to all responses in response message object,
		* these will each be collections of customer/employee/vendor ret objects
		   loAcctResp = loresponse.ResponseList.GetAt(0)
		
		* loop through the collection of account ret objects
		   IF loAcctResp.StatusCode = 0
		      FOR lni = 0 TO loAcctResp.DETAIL.COUNT - 1
		
		* get reference to single Acctomer
		         loAcct = loAcctResp.DETAIL.GetAt(lni)
		
		         m.clistid  = loAcct.ListID.GetValue()
		
		* get the value of the fullname tag
		         lcfullname = loAcct.FULLNAME.GetValue()
		
		         m.cAcctDesc = lcfullname
		
		         INSERT INTO Accounts FROM MEMVAR
		      ENDFOR
		   ENDIF
		
		   m.goApp.oQB.oQBRequest.ClearRequests()
		
		   SELE vendor
		   SCAN FOR lsend1099 = .T.
		      SCATTER MEMVAR
		
		* Make sure it doesn't show the vendor name twice on the 1099
		
		      IF ALLTRIM(LOWER(m.cvendname)) = ALLTRIM(LOWER(m.cbaddr1))
		         m.cbaddr1 = m.cbaddr2
		         m.cbaddr2 = ''
		      ENDIF
		
		      m.cid		= m.cvendorid
		      m.cname	= m.cvendname
		      m.cName2	= ''
		      m.caddr1	= m.cbaddr1
		      m.caddr2	= m.cbaddr2
		      m.ccity	= m.cbcity
		      m.cstate	= m.cbstate
		      m.czip	= m.cbzip
		      m.ctaxid	= m.ctaxid
		      m.cidtype	= 'V'
		      m.cType	= 'G'
		
		      STORE 0  TO m.nStateTax1, m.nStateTax2
		      STORE '' TO m.cTaxState1, m.cTaxState2, m.cStatePayerNo1, m.cStatePayerNo2
		
		      lnAmount = 0
		*  Setup the check query request
		      locheckquery = m.goApp.oQB.oQBRequest.appendcheckqueryrq()
		      locheckquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.FromTxnDate.SetValue(ldDate1)
		      locheckquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.ToTxnDate.SetValue(ldDate2)
		      locheckquery.ORTxnQuery.TxnFilter.EntityFilter.OREntityFilter.FullNameList.ADD(ALLT(m.cvendname))
		
		* Add Get the response from the check query
		      loresponse = m.goApp.oQB.oqbsm.DoRequests(m.goApp.oQB.oQBRequest)
		      lochecks	 = loresponse.ResponseList.GetAt(0)
		
		      IF lochecks.StatusCode = 0
		         FOR lni = 0 TO lochecks.DETAIL.COUNT - 1
		
		* get reference to single check
		            locheck = lochecks.DETAIL.GetAt(lni)
		            IF NOT ISNULL(locheck.Amount)
		               m.namount = locheck.Amount.GetValue()
		            ELSE
		               m.namount = 0
		            ENDIF
		            lnAmount = lnAmount + m.namount
		         ENDFOR
		      ENDIF
		
		      m.goApp.oQB.oQBRequest.ClearRequests()
		      m.goApp.oQB.oqbsm.ClearErrorRecovery()
		
		* Setup the journal query request
		      lojournalquery = m.goApp.oQB.oQBRequest.AppendJournalEntryQueryRq()
		      lojournalquery.ORTxnQuery.TxnFilter.EntityFilter.OREntityFilter.FullNameList.ADD(ALLTRIM(m.cvendname))
		      lojournalquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.FromTxnDate.SetValue(ldDate1)
		      lojournalquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.ToTxnDate.SetValue(ldDate2)
		      lojournalquery.includelineitems.SetValue(1)
		
		      SELECT Accounts
		      SCAN
		         lcAccount = cAcctDesc
		         lojournalquery.ORTxnQuery.TxnFilter.AccountFilter.ORAccountFilter.FullNameList.ADD(lcAccount)
		      ENDSCAN
		
		      loresponse = m.goApp.oQB.oqbsm.DoRequests(m.goApp.oQB.oQBRequest)
		      lojournal	 = loresponse.ResponseList.GetAt(0)
		
		      IF lojournal.StatusCode = 0
		         FOR lni = 0 TO lojournal.DETAIL.COUNT - 1
		
		* get reference to single entry
		            loEntry		= lojournal.DETAIL.GetAt(lni)
		            m.dTranDate	= loEntry.txndate.GetValue()
		
		            IF m.goApp.oQB.QBFCVersion > ' 4.0'
		               FOR lnX = 0 TO loEntry.ORJournalLineList.COUNT - 1
		                  loDetail = loEntry.ORJournalLineList.GetAt(lnX)
		                  loCredit = loDetail.JournalCreditLine
		                  IF NOT ISNULL(loCredit)
		                     IF NOT ISNULL(loCredit.EntityRef)
		                        IF loCredit.EntityRef.FULLNAME.GetValue() = ALLTRIM(m.cvendname)
		                           lclistid	= loCredit.AccountRef.ListID.GetValue()
		                           lnAmount	= lnAmount + loCredit.Amount.GetValue()
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDFOR
		            ELSE
		               FOR lnX = 0 TO loEntry.JournalCreditLineList.COUNT - 1
		                  loCredit  = loEntry.JournalCreditLineList.GetAt(lnX)
		                  IF NOT ISNULL(loCredit)
		                     IF NOT ISNULL(loCredit.EntityRef)
		                        IF loCredit.EntityRef.FULLNAME.GetValue() = ALLTRIM(m.cvendname)
		                           lclistid	= loCredit.AccountRef.ListID.GetValue()
		                           lnAmount	= lnAmount + loCredit.Amount.GetValue()
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDFOR
		            ENDIF
		         ENDFOR
		      ENDIF
		
		      m.goApp.oQB.oQBRequest.ClearRequests()
		      m.goApp.oQB.oqbsm.ClearErrorRecovery()
		
		********************
		*  Get Bill Payments
		********************
		*   LOCAL lopmtquery AS qbfc5Lib.IBillPaymentCheckQuery
		*   LOCAL lopmtlist  AS qbfc5Lib.IBillPaymentCheckRetList
		*   LOCAL lopmt      AS qbfc5Lib.IBillPaymentCheckRet
		
		      lopmtquery = m.goApp.oQB.oQBRequest.appendbillpaymentcheckqueryrq
		      lopmtquery.includelineitems.SetValue(.F.)
		      lopmtquery.ORTxnQuery.TxnFilter.EntityFilter.OREntityFilter.ListIDList.ADD(m.clistid)
		      lopmtquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.FromTxnDate.SetValue(ldDate1)
		      lopmtquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.ToTxnDate.SetValue(ldDate2)
		      loresponse = m.goApp.oQB.oqbsm.DoRequests(m.goApp.oQB.oQBRequest)
		      lopmtlist	 = loresponse.ResponseList.GetAt(0)
		
		      IF lopmtlist.StatusCode = 0
		         FOR lni = 0 TO lopmtlist.DETAIL.COUNT - 1
		            lopmt	 = lopmtlist.DETAIL.GetAt(lni)
		            lnAmount = lnAmount + lopmt.Amount.GetValue()
		         ENDFOR
		      ENDIF
		
		      m.goApp.oQB.oQBRequest.ClearRequests()
		      m.goApp.oQB.oqbsm.ClearErrorRecovery()
		
		*********************
		*  Get vendor credits
		*********************
		*   LOCAL lovendcrquery AS qbfc5Lib.IVendorCreditQuery
		*   LOCAL lovendorcredits AS qbfc5Lib.IVendorCreditRetList
		*   LOCAL lovendorcredit AS qbfc5Lib.IVendorCreditRet
		
		*!*	   lovendcrquery = m.goapp.oqb.oqbrequest.appendvendorcreditqueryrq
		*!*	   lovendcrquery.includelineitems.SetValue(.f.)
		*!*	   lovendcrquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.FromTxnDate.SetValue(lddate1)
		*!*	   lovendcrquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.ToTxnDate.SetValue(lddate2)
		*!*	   lovendcrquery.ORTxnQuery.TxnFilter.EntityFilter.OREntityFilter.ListIDList.Add(m.clistid)
		*!*	   loresponse = m.goApp.oQB.oQBSM.DoRequests(m.goApp.oQB.oQBRequest)
		*!*	   lovendorcredits = loresponse.ResponseList.GetAt(0)
		
		*!*	   IF lovendorcredits.StatusCode = 0
		*!*	      FOR lni = 0 TO lovendorcredits.detail.COUNT - 1
		
		*!*	         lovendorcredit = lovendorcredits.detail.GetAt(lni)
		*!*	         lnAmount = lnAmount - lovendorcredit.CreditAmount.GetValue()
		
		*!*	      ENDFOR
		*!*	   ENDIF
		
		*!*	   m.goApp.oQB.oQBRequest.ClearRequests()
		
		**************************
		*  Get credit card charges
		**************************
		*   LOCAL loccquery as QBFC5Lib.ICreditCardChargeQuery
		
		      loccquery = m.goApp.oQB.oQBRequest.appendcreditcardchargequeryrq
		      loccquery.ORTxnQuery.TxnFilter.EntityFilter.OREntityFilter.ListIDList.ADD(m.clistid)
		      loccquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.FromTxnDate.SetValue(ldDate1)
		      loccquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.ToTxnDate.SetValue(ldDate2)
		      loccquery.includelineitems.SetValue(.F.)
		      loresponse = m.goApp.oQB.oqbsm.DoRequests(m.goApp.oQB.oQBRequest)
		      locharges	 = loresponse.ResponseList.GetAt(0)
		
		      IF locharges.StatusCode = 0
		         FOR lnX = 0 TO locharges.DETAIL.COUNT - 1
		            locharge = locharges.DETAIL.GetAt(lnX)
		
		            lnAmount = lnAmount + locharge.Amount.GetValue()
		         ENDFOR
		      ENDIF
		      m.goApp.oQB.oQBRequest.ClearRequests()
		      m.goApp.oQB.oqbsm.ClearErrorRecovery()
		
		*************************
		*  Credit Card Credits
		*************************
		*   LOCAL locreditquery as QBFC5Lib.ICreditCardCreditQuery
		
		      locreditquery = m.goApp.oQB.oQBRequest.appendcreditcardcreditqueryrq
		      locreditquery.ORTxnQuery.TxnFilter.EntityFilter.OREntityFilter.ListIDList.ADD(m.clistid)
		      locreditquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.FromTxnDate.SetValue(ldDate1)
		      locreditquery.ORTxnQuery.TxnFilter.ORDateRangeFilter.TxnDateRangeFilter.ORTxnDateRangeFilter.TxnDateFilter.ToTxnDate.SetValue(ldDate2)
		
		      locreditquery.includelineitems.SetValue(.F.)
		      loresponse = m.goApp.oQB.oqbsm.DoRequests(m.goApp.oQB.oQBRequest)
		      locredits	 = loresponse.ResponseList.GetAt(0)
		
		      IF locredits.StatusCode = 0
		         FOR lni = 0 TO locredits.DETAIL.COUNT - 1
		            loCredit = locredits.DETAIL.GetAt(lni)
		            lnAmount = lnAmount - loCredit.Amount.GetValue()
		         ENDFOR
		      ENDIF
		      m.goApp.oQB.oQBRequest.ClearRequests()
		
		      m.nNonEmp	 = lnAmount
		      m.nroyalty = 0
		      m.nrents	 = 0
		      STORE 0 TO m.nStateIncome1, m.nStateTax1, m.nStateIncome2, m.nStateTax2, m.nFedTax
		      STORE ' ' TO m.cTaxState1, m.cStatePayerNo1, m.cTaxState2, m.cStatePayerNo2
		      IF m.nNonEmp # 0
		         INSERT INTO wrk1099v FROM MEMVAR
		      ENDIF
		
		* Turn on QB Error Recovery
		      m.goApp.oQB.oqbsm.EnableErrorRecovery = .T.
		      m.goApp.oQB.oqbsm.ClearErrorRecovery()
		   ENDSCAN
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'QBVendor1099', loError.LINENO, 'Create 1099s', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the 1099s at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
	ENDPROC

	PROCEDURE removecuryearsuspense		&& Removes suspense released in the 1099 year that came from the 1099 year since those amounts are already in disbhist.
	ENDPROC

	PROCEDURE Resize
		*
	ENDPROC

	PROCEDURE chkAdvanced.Click
		IF THIS.VALUE
		   THISFORM.chkExclTrans.VISIBLE   = .T.
		   THISFORM.chkExcludeSusp.VISIBLE = .T.
		   THISFORM.chklByWell.VISIBLE     = .T.
		   THISFORM.chkTaxID.VISIBLE       = .T.
		   thisform.chkgross.Visible       = .T.
		   thisform.Height = 392
		   thisform.cmdCreate.Top = 336
		   thisform.cmdExit.Top = 336
		   thisform.mwresize1.Top = thisform.Height-16
		   thisform.mwresize1.Left = thisform.Width-16
		ELSE
		   THISFORM.chkExclTrans.VISIBLE   = .F.
		   THISFORM.chkExcludeSusp.VISIBLE = .F.
		   THISFORM.chklByWell.VISIBLE     = .F.
		   THISFORM.chkTaxID.VISIBLE       = .F.
		   thisform.chkgross.Visible       = .F.
		   thisform.Height = 162
		   thisform.cmdCreate.Top = 96
		   thisform.cmdExit.Top = 96
		   thisform.mwresize1.Top = thisform.Height-16
		   thisform.mwresize1.Left = thisform.Width-16
		  
		ENDIF
	ENDPROC

	PROCEDURE chkExcludeSusp.Click
		IF this.Value
		   thisform.oMessage.display('Marking this option will create the 1099s based on money EARNED this year, regardless of whether it was actually paid out, or if it still remains in suspense.')
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE chkFlatRates.Click
		IF this.Value
		   MESSAGEBOX('Rental payments are subject to the non-employee compensation minimum amount. ' + ;
		              'If you want to create 1099s for rentals less than $' + TRANSFORM(thisform.txtMin1099.Value) + ;
		              ', change the non-employee compensation minimum to an amount that will allow' + ;
		              ' 1099s for rents to be created.',64,'REMINDER')
		ENDIF 
	ENDPROC

	PROCEDURE chkGross.Click
		IF this.Value
		   thisform.oMessage.display('Marking this option will create the 1099s based on GROSS revenue instead of NET.')
		   swselect('options')
		   REPLACE lgross1099 WITH .t.
		   TABLEUPDATE()
		ELSE
		   IF messagebox('Un-Marking this option will create the 1099s based on NET revenue instead of GROSS. ' + ;
		                 'Are you sure you want to create the 1099s based on NET revenue?',36,thisform.caption) = 6
		      swselect('options')
		      GO TOP 
		      REPLACE lgross1099 WITH .f.
		      TABLEUPDATE()
		   ELSE
		      this.Value = .t.     
		   ENDIF 
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE chklByWell.Click
		IF THIS.VALUE   
		   THISFORM.oMessage.Warning('This option should only be chosen if each well is considered a separate tax entity.  Owners will receive a 1099 from each well for which they earned money.')
		   thisform.chkTaxID.Value = .f.
		   thisform.chktaxID.Visible = .f.
		ELSE
		   thisform.chkTaxID.Value = .f.
		   thisform.chktaxID.Visible = .t.
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE chkTaxID.Click
		IF THIS.VALUE
		   THISFORM.oMessage.Warning('This option will group multiple owners with the same tax ID on them into a single 1099 record and 1099 Reconciliation Report. ')
		   IF thisform.chklByWell.Value
		      thisform.oMessage.Warning('The 1099 file cannot be created by both well and by tax ID, since it could cause owners to receive a 1099 from a well in which they have no interest.')
		      this.Value = .f.
		   ENDIF 
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cmdCreate.Click
		thisform.BuildData()
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE txtcYear.Valid
		IF NOT BETWEEN(VAL(this.value),1900,2099)
		   WAIT WIND 'Invalid year, please re-enter...'
		   RETURN 0
		ENDIF
	ENDPROC

	PROCEDURE txtMin1099.Valid
		swselect('options')
		REPLACE nmin1099non WITH this.Value
		TABLEUPDATE()
	ENDPROC

	PROCEDURE txtnMin1099Roy.Valid
		swselect('options')
		REPLACE nmin1099roy WITH this.Value
		TABLEUPDATE()
	ENDPROC

ENDDEFINE
