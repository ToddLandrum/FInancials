*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="dmclearsusp.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="1" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 727
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 520

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor10", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "disbhist", ;
		BufferModeOverride = 5, ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor12", ;
		Top = 380, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "ownpcts", ;
		BufferModeOverride = 5, ;
		CursorSource = "ownpcts", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor13", ;
		Top = 500, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "suspense", ;
		BufferModeOverride = 5, ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 21, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "suspense1", ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 152, ;
		Name = "Cursor5", ;
		Top = 135, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor9", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formdmclearsusp AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtcOwnName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLookOwner" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcOwnerID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcWellName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLookWell" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcWellID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblOwner" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblWell" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chklSingle" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chklCheck" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtdDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="SWGROUP1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: isonhold
		*m: process
	*</DefinedPropArrayMethod>

	Caption = "Clear Owner Suspense"
	DoCreate = .T.
	Height = 327
	HelpContextID = 136
	lcloseonescape = .T.
	Name = "formdmclearsusp"
	Width = 383
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'chklCheck' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Create a Check if Balance is Positive", ;
		Left = 98, ;
		Name = "chklCheck", ;
		TabIndex = 14, ;
		Top = 243, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chklSingle' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Clear Balance for a Single Well", ;
		Left = 90, ;
		Name = "chklSingle", ;
		TabIndex = 7, ;
		Top = 133, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 36, ;
		Left = 198, ;
		Name = "cmdCancel", ;
		TabIndex = 16, ;
		Top = 276, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLookOwner' AS cmdcommandbuttoncustom WITH ;
		Caption = "...", ;
		FontBold = .T., ;
		FontSize = 9, ;
		Height = 20, ;
		Left = 66, ;
		Name = "cmdLookOwner", ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 36, ;
		Width = 20, ;
		ZOrderSet = 47
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLookWell' AS cmdcommandbuttoncustom WITH ;
		Caption = "...", ;
		FontBold = .T., ;
		FontSize = 9, ;
		Height = 20, ;
		Left = 66, ;
		Name = "cmdLookWell", ;
		TabIndex = 9, ;
		TabStop = .F., ;
		Top = 160, ;
		Visible = .F., ;
		Width = 20, ;
		ZOrderSet = 47
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdProcess' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Process", ;
		Height = 36, ;
		Left = 110, ;
		Name = "cmdProcess", ;
		TabIndex = 15, ;
		Top = 276, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 24, ;
		Left = 12, ;
		Name = "Glmaint", ;
		Top = 269, ;
		Width = 24
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Date to Put on History Entries/Check:", ;
		Left = 59, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 12, ;
		Top = 204
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Group:", ;
		Left = 24, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 17, ;
		Top = 88
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblOwner' AS lbltextcustom WITH ;
		Caption = "Owner:", ;
		Left = 24, ;
		Name = "lblOwner", ;
		TabIndex = 6, ;
		Top = 38
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblWell' AS lbltextcustom WITH ;
		Caption = " Well:", ;
		Left = 24, ;
		Name = "lblWell", ;
		TabIndex = 8, ;
		Top = 160, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'SWGROUP1' AS swgroup WITH ;
		Left = 90, ;
		Name = "SWGROUP1", ;
		TabIndex = 5, ;
		Top = 86
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'txtcOwnerID' AS txtquickfill WITH ;
		clistexpression = investor.cownerid, ;
		clistworkarea = investor, ;
		Height = 20, ;
		Left = 90, ;
		MaxLength = 10, ;
		Name = "txtcOwnerID", ;
		TabIndex = 3, ;
		Top = 36, ;
		Width = 76
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcOwnName' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		Height = 20, ;
		Left = 174, ;
		Name = "txtcOwnName", ;
		TabIndex = 4, ;
		Top = 36, ;
		Width = 191
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcWellID' AS txtquickfill WITH ;
		clistexpression = wells.cwellid, ;
		clistworkarea = wells, ;
		Height = 20, ;
		Left = 90, ;
		MaxLength = 10, ;
		Name = "txtcWellID", ;
		TabIndex = 10, ;
		Top = 160, ;
		Visible = .F., ;
		Width = 76
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcWellName' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		Height = 20, ;
		Left = 174, ;
		Name = "txtcWellName", ;
		TabIndex = 11, ;
		Top = 160, ;
		Visible = .F., ;
		Width = 191
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtdDate' AS dpk WITH ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 241, ;
		Name = "txtdDate", ;
		TabIndex = 13, ;
		Top = 201, ;
		Visible = .T., ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />
	
	PROCEDURE isonhold
		LPARA tcOwnerid, tlIntHold, tcWellID, tcTypeInv
		LOCAL llReturn, loError
		*
		* Checks to see if an owner or interest on hold
		*
		llReturn = .F.
		
		TRY
		
		   IF NOT tlIntHold
		      swselect('investor')
		      SET ORDER TO cownerid
		      IF SEEK(tcOwnerid)
		         IF lhold
		            llReturn = .T.
		         ENDIF
		      ENDIF
		   ELSE
		      swselect('wellinv')
		      SET ORDER TO wellinvid
		      IF SEEK(tcWellID + tcOwnerid + tcTypeInv)
		         IF lonhold
		            llReturn = .T.
		         ENDIF
		      ELSE
		         llReturn = .F.
		      ENDIF
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'IsOnHold', loError.LINENO, 'Suspense', loError.ERRORNO, loError.MESSAGE, ' ', loError
		   MESSAGEBOX('Unable to process the suspense at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE process
		LOCAL lcidsusa, lcOwnerID, lcWellID, llSingle, llFound, llReturn, llCheck, llBalance, lcBatch
		LOCAL oSuspense AS 'suspense'
		LOCAL lcAcct, lcAcctDef, lcAcctMin, lcGroup, lcOwnName, lcRunYear, lcScan, ldDate, lnTotal, loError
		*:Global cBatch, cRunYear, ciddisb, hDate, nRunNo, oRegistry
		
		llReturn = .T.
		
		TRY
		   lcOwnerID = THISFORM.txtcOwnerID.VALUE
		   lcOwnName = THISFORM.txtcOwnName.VALUE
		   lcWellID	 = THISFORM.txtcWellID.VALUE
		   llSingle	 = THISFORM.chklSingle.VALUE
		   llFound	 = .F.
		   ldDate	 = THISFORM.txtdDate.VALUE
		   llCheck	 = THISFORM.chklCheck.VALUE
		   lcGroup	 = LEFT(THISFORM.swgROUP1.VALUE, 2)
		
		   oSuspense           = CREATEOBJECT('suspense')
		
		   lnTotal   = 0  &&  Running balance, to determine whether a check needs to be created for them
		
		   oRegistry = findglobalobject('cmRegistry')
		
		   STORE .T. TO llReturn, llBalance
		
		   IF llSingle  &&  Scan for a single well, so set the scan parameter appropriately
		      lcScan = 'cOwnerID == lcOwnerID and cWellID == lcWellID'
		   ELSE
		      IF lcGroup = '**'
		         lcScan = 'cOwnerID == lcOwnerID'
		      ELSE
		         lcScan = 'cOwnerID == lcOwnerID AND cGroup == lcGroup'
		      ENDIF
		   ENDIF
		
		*  Make sure the period or year isn't closed
		   IF NOT THISFORM.glmaint.CheckPeriod(ldDate)
		      THISFORM.omessage.warning('Unable to clear suspense. Either the fiscal year or period represented by this date has been closed.')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   lcRunYear = TRANSFORM(YEAR(ldDate))
		
		*  Common batch that will tie all balances released together, and tie them to the check register entry created, if that's being done
		   lcBatch = oRegistry.IncrementCounter('%Shared.Counters.Batch')
		
		   SELECT suspense
		   SCAN FOR &lcScan
		      SCATTER MEMVAR
		
		      IF NOT THISFORM.IsOnHold(m.cownerid, .T., m.cwellid, m.ctypeinv)
		         m.hDate = ldDate
		
		         m.cBatch = lcBatch
		
		         m.ciddisb = oRegistry.IncrementCounter('%Shared.Counters.Owner History')  &&  Make sure new primary key in disbhist is unique
		
		         SWSELECT('disbhist', .T.)
		         SET ORDER TO ciddisb
		         SET DELE OFF
		         DO WHILE SEEK(m.ciddisb)
		            m.ciddisb = oRegistry.IncrementCounter('%Shared.Counters.Owner History')
		         ENDDO
		
		         SWSELECT('ownpcts', .T.)  &&  Check ownpcts, too, since we're updating that, too
		         SET ORDER TO ciddisb
		         DO WHILE SEEK(m.ciddisb)
		            m.ciddisb = oRegistry.IncrementCounter('%Shared.Counters.Owner History')
		         ENDDO
		         SET DELE ON
		
		         m.nRunNo	= 9999
		         m.cRunYear	= lcRunYear
		
		         INSERT INTO disbhist FROM MEMVAR
		         INSERT INTO ownpcts FROM MEMVAR
		
		         lnTotal = lnTotal + m.nNetCheck  &&  Running total for the entries being transferred
		      ENDIF
		   ENDSCAN
		
		   IF lnTotal = 0
		      MESSAGEBOX('There was nothing to release for this owner.', 64, 'Clear Owner Suspense')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   SWSELECT('sysctl')
		   LOCATE FOR nRunNo = 9999 AND cRunYear = lcRunYear
		   IF NOT FOUND()
		      m.cidsysctl  = oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		      m.cRunYear   = lcRunYear
		      m.nRunNo	   = 9999
		      m.ddateclose = ldDate
		      m.cTimeClose = TIME()
		      m.dacctdate  = ldDate
		      m.dpostdate  = ldDate
		      m.drevdate   = ldDate
		      m.dexpdate   = ldDate
		      m.cTypeClose = 'R'
		      m.cGroup	   = '00'
		      m.cyear	   = lcRunYear
		      m.cperiod	   = '12'
		      m.lDisbman   = .T.
		      m.cversion   = STRTRAN(m.goapp.cFileVersion, '.', '')
		      INSERT INTO sysctl FROM MEMVAR
		      TABLEUPDATE(.T., .T., 'Sysctl')
		   ENDIF
		
		   IF lnTotal > 0  &&  Positive, so create a check, if needed
		      IF llCheck  &&  Create a check
		         THISFORM.omessage.DISPLAY('This will create a check for $' + ALLTRIM(STR(lnTotal, 10, 2)) + ' for owner ' + ALLT(lcOwnerID) + ' - ' + ALLT(lcOwnName) + '.')
		         SWSELECT('options')
		         lcAcct = options.cDisbAcct
		         IF EMPTY(lcAcct)
		            lcAcct = '999999'
		         ENDIF
		
		         SWSELECT('investor')  &&  Fill in check memo.  If marked to use 2nd address, or to send check to 2nd address, use 2nd address memo, otherwise, use main check memo
		         SET ORDER TO cownerid
		         IF SEEK(lcOwnerID)
		            IF investor.lChkToSec = .T. OR investor.lCheckOnly = .T.
		               THISFORM.glmaint.cMemo = investor.cChkMemo2
		            ELSE
		               THISFORM.glmaint.cMemo = investor.cChkMemo1
		            ENDIF
		         ELSE
		            THISFORM.glmaint.cMemo = ''
		         ENDIF
		
		*  Cash entry
		         THISFORM.glmaint.cSource	 = 'DM'
		         THISFORM.glmaint.dGLDate	 = ldDate
		         THISFORM.glmaint.cReference = 'Suspense Cleared'
		         THISFORM.glmaint.cDesc		 = lcOwnName
		         THISFORM.glmaint.cAcctNo	 = IIF(m.goapp.lAMVersion, lcAcct, '')
		         THISFORM.glmaint.cId		 = lcOwnerID
		         THISFORM.glmaint.cBatch	 = lcBatch
		         THISFORM.glmaint.nAmount	 = lnTotal
		         THISFORM.glmaint.dCheckDate = ldDate
		         THISFORM.glmaint.dpostdate	 = ldDate
		         THISFORM.glmaint.cpayee	 = lcOwnName
		         THISFORM.glmaint.cidchec	 = ''
		         THISFORM.glmaint.centrytype = 'C'
		         THISFORM.glmaint.cidtype	 = 'I'
		         THISFORM.glmaint.cyear		 = ' '
		         THISFORM.glmaint.cperiod	 = ' '
		         THISFORM.glmaint.ccheckno	 = ''
		         THISFORM.glmaint.cUnitNo	 = ''
		         THISFORM.glmaint.cDeptNo	 = ''
		         THISFORM.glmaint.lPrinted	 = .F.
		
		         THISFORM.glmaint.addcheck()  &&  Create check register entry
		
		         IF m.goapp.lAMVersion
		            THISFORM.glmaint.nAmount    = lnTotal * -1  &&  Make the amount negative for a credit
		            THISFORM.glmaint.updatebatch()  &&  Cash GL entry
		            THISFORM.glmaint.cidchec = ''
		         ENDIF
		
		         SWSELECT('options')
		         lcAcctMin = options.cMinAcct
		         lcAcctDef = options.cDefAcct
		         IF EMPTY(lcAcctMin)  &&  Check to see if minimum account is empty and if it is, fill it in
		            lcAcctMin = '999999'
		         ENDIF
		         IF EMPTY(lcAcctDef)
		            lcAcctDef = '999999'
		         ENDIF
		
		         THISFORM.glmaint.cAcctNo    = IIF(m.goapp.lAMVersion, lcAcct, '')  &&  Reset acct to suspense account
		
		**  If this is the AM, check the last suspense type for each well, and post it to legal suspense or deficit, depending on the type returned
		* Create suspense object
		
		         oSuspense.cBegOwner = lcOwnerID  &&  Set owner parameters, so it doesn't create it for all owners if you're just running the report for a smaller subset
		         oSuspense.cEndOwner = lcOwnerID
		         oSuspense.cRunYear	 = '2999'
		         oSuspense.nRunNo	 = 1
		
		         oSuspense.getlasttype(.F., .T., .F., .F., .T.)
		
		         SELECT suspense
		         SCAN FOR &lcScan
		            SCATTER MEMVAR
		            IF NOT THISFORM.IsOnHold(m.cownerid, .T., m.cwellid, m.ctypeinv)
		
		               THISFORM.glmaint.nAmount    = suspense.nNetCheck
		               SELECT curLastSusptype
		               LOCATE FOR cownerid == suspense.cownerid AND cwellid == suspense.cwellid
		               IF FOUND()
		                  IF cSuspType = 'D'
		                     THISFORM.glmaint.cAcctNo = lcAcctDef
		                  ELSE
		                     THISFORM.glmaint.cAcctNo = lcAcctMin
		                  ENDIF
		               ELSE
		                  THISFORM.glmaint.cAcctNo = lcAcctMin
		               ENDIF
		               THISFORM.glmaint.cUnitNo = suspense.cwellid
		               IF m.goapp.lAMVersion
		                  THISFORM.glmaint.updatebatch()  &&  Suspense GL entry
		               ENDIF
		               SELECT suspense
		               DELETE NEXT 1
		            ENDIF
		         ENDSCAN
		         IF m.goapp.lAMVersion
		            llBalance = THISFORM.glmaint.chkbalance()
		         ENDIF
		      ELSE
		
		* Delete the suspense entries since they weren't deleted above.
		         SELECT suspense
		         DELETE FOR &lcScan
		         lBalance = .T.
		         IF m.goapp.lAMVersion
		            MESSAGEBOX('No journal entry was created during the clearing process.' + ;
		                 ' A manual journal entry will need to be made to reflect this clearing.', 16, 'Clear Owner Suspense')
		         ENDIF 
		      ENDIF
		   ELSE
		      IF llCheck  &&  If the option to create a check was chosen, it can't be done, since the balance is negative
		         IF m.goapp.lAMVersion
		            MESSAGEBOX('No journal entry or check was created during the clearing process since the amount was negative.' + ;
		                 ' A manual journal entry will need to be made to reflect this clearing.', 16, 'Clear Owner Suspense')
		         ELSE
		            MESSAGEBOX('No check was created during the clearing process since the amount cleared was negative.', 48, 'Clear Owner Suspense')
		         ENDIF
		
		* Delete the suspense entries since they weren't deleted above.
		         SELECT suspense
		         DELETE FOR &lcScan
		
		      ELSE
		         IF m.goapp.lAMVersion
		            MESSAGEBOX('No journal entry or check was created during the clearing process since the amount was negative.' + ;
		                 ' A manual journal entry will need to be made to reflect this clearing.', 16, 'Clear Owner Suspense')
		         ENDIF
		
		* Delete the suspense entries since they weren't deleted above.
		         SELECT suspense
		         DELETE FOR &lcScan
		
		      ENDIF
		      llBalance = .T.
		   ENDIF
		
		   IF llBalance
		* Begin trying to commit the changes
		      BEGIN TRANSACTION
		      SELECT glmaster
		      llReturn = TABLEUPDATE(.T., .F., 'glmaster')
		      IF llReturn
		         SELECT checks
		         llReturn = TABLEUPDATE(.T., .F., 'checks')
		         IF llReturn
		            SELECT suspense
		            llReturn = TABLEUPDATE(.T., .F., 'suspense')
		            IF llReturn
		               SELECT disbhist
		               llReturn = TABLEUPDATE(.T., .F., 'disbhist')
		               IF llReturn
		                  SELECT ownpcts
		                  llReturn = TABLEUPDATE(.T., .F., 'ownpcts')
		                  IF llReturn
		                     SELECT coabal
		                     llReturn = TABLEUPDATE(.T., .F., 'coabal')
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		      IF llReturn
		         END TRANSACTION
		      ELSE
		         ROLLBACK
		      ENDIF
		   ENDIF
		* If the commit was successful, finish it, otherwise roll everything back.
		
		   THISFORM.txtcOwnerID.SET('value', '')
		   THISFORM.txtcOwnName.SET('value', '')
		   THISFORM.txtcWellID.SET('value', '')
		   THISFORM.txtcwellname.SET('value', '')
		
		   IF llReturn
		      IF llCheck  &&  If we're creating a check, they already know the amount being cleared
		         THISFORM.omessage.DISPLAY('Suspense balance was cleared successfully.')
		      ELSE
		         THISFORM.omessage.DISPLAY('Suspense balance of ' + IIF(lnTotal < 0, '-', '') + '$' + ALLTRIM(STR(ABS(lnTotal), 10, 2)) + ' cleared successfully.')
		      ENDIF
		   ELSE
		      IF NOT llBalance
		         THISFORM.omessage.severe('The suspense clearing caused an out of balance batch. The suspense was not cleared.')
		      ELSE
		         THISFORM.omessage.severe('There was a problem trying to clear this suspense. Please try again later.')
		      ENDIF
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Process', loError.LINENO, 'Clear Suspense', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to clear the suspense at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE chklCheck.Click
		DODEFAULT()
		
		IF THIS.VALUE = .T. and m.goApp.lAMVersion
		   THISFORM.oMessage.DISPLAY('This will cause a journal entry to be created which will debit ' + ;
		                             'your Legal Suspense Account (or Deficit Account for negative wells) and credit the Checking Account specified in the Rev Dist/JIB Posting portion of the Edit >> Preferences screen.')
		ENDIF
		
	ENDPROC

	PROCEDURE chklSingle.Click
		IF THIS.VALUE
		   THISFORM.lblWell.VISIBLE = .T.
		   THISFORM.cmdLookWell.VISIBLE = .T.
		   THISFORM.txtcWellID.VISIBLE = .T.
		   THISFORM.txtcWellName.VISIBLE = .T.
		ELSE
		   THISFORM.lblWell.VISIBLE = .F.
		   THISFORM.cmdLookWell.VISIBLE = .F.
		   THISFORM.txtcWellID.VISIBLE = .F.
		   THISFORM.txtcWellName.VISIBLE = .F.
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdLookOwner.Click
		LPARAMETERS cworkarea
		LOCAL lcList, lnRecNo
		PRIV llOK
		
		llOK = .F.
		lcList = 'cownerid,csortfield'
		
		DO FORM ..\CUSTOM\picklist WITH 'Investor', lcList, THISFORM.txtcOwnerID.VALUE, 2
		
		IF llOK
		   THISFORM.txtcOwnerID.SET('value',investor.cOwnerID)
		   THISFORM.txtcOwnName.SET('value',investor.cOwnName)
		   THISFORM.REFRESH()
		ENDIF
		
	ENDPROC

	PROCEDURE cmdLookOwner.When
		RETURN MDOWN()
	ENDPROC

	PROCEDURE cmdLookWell.Click
		LPARAMETERS cworkarea
		LOCAL lcList, lnRecNo
		PRIV llOK
		
		llOK = .F.
		lcList = 'cwellid,cwellname'
		
		DO FORM ..\CUSTOM\picklist WITH 'wells', lcList, THISFORM.txtcWellID.VALUE, 2
		
		IF llOK
		   THISFORM.txtcWellID.SET('value',wells.cWellID)
		   THISFORM.txtcWellName.SET('value',wells.cWellName)
		   thisform.setnextcontrol(thisform.txtcwellID)
		   THISFORM.REFRESH()   
		ENDIF
		
	ENDPROC

	PROCEDURE cmdLookWell.When
		RETURN MDOWN()
	ENDPROC

	PROCEDURE cmdProcess.Click
		IF THISFORM.chklSingle.VALUE  &&  If clearing for a specific well
		   IF THISFORM.oMessage.CONFIRM('Do you want to clear any suspense balance for owner ' +  ;
		         ALLTRIM(THISFORM.txtcOwnerID.VALUE) + ' - ' + ALLTRIM(THISFORM.txtcOwnName.VALUE)  ;
		         + ' for the ' + ALLTRIM(THISFORM.txtcWellName.VALUE) + ' well?')
		      thisform.Process()
		   ENDIF
		ELSE
		   IF THISFORM.oMessage.CONFIRM('Do you want to clear all suspense balances for owner ' +  ;
		         ALLTRIM(THISFORM.txtcOwnerID.VALUE) + ' - ' + ALLTRIM(THISFORM.txtcOwnName.VALUE) + '?')
		      thisform.Process()
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE txtcOwnerID.GotFocus
		ON KEY LABEL F2 _SCREEN.ACTIVEFORM.cmdLookOwner.CLICK()
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcOwnerID.InteractiveChange
		IF DODEFAULT()
		   SELECT investor
		   LOCATE FOR cownerid == this.Value
		   IF FOUND()
		      thisform.txtcownname.set('value',investor.cownname)
		   ELSE
		      thisform.txtcownname.set('value','')
		   ENDIF 
		ENDIF    
	ENDPROC

	PROCEDURE txtcOwnerID.LostFocus
		ON KEY LABEL F2 *
		DODEFAULT()
	ENDPROC

	PROCEDURE txtcOwnerID.Valid
		IF EMPTY(THIS.VALUE)
		   THISFORM.txtcOwnName.SET('value','')
		ELSE
		   IF NOT THISFORM.chklSingle.VALUE  &&  If not calculating for a specific well, check to see if there are any recs in suspense
		      SELECT suspense
		      LOCATE FOR cOwnerID = THIS.VALUE
		      IF NOT FOUND()
		         THISFORM.oMessage.Warning('There are no suspense history entries for this owner.')
		         this.set('value','')
		         thisform.txtcOwnName.set('value','')
		         RETURN 0
		      ENDIF
		   ENDIF
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcOwnName.When
		RETURN .F.
		
	ENDPROC

	PROCEDURE txtcWellID.GotFocus
		ON KEY LABEL F2 _SCREEN.ACTIVEFORM.cmdLookWell.CLICK()
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcWellID.InteractiveChange
		IF DODEFAULT()
		   SELECT wells
		   LOCATE FOR cwellid == this.Value
		   IF FOUND()
		      thisform.txtcwellname.set('value',wells.cwellname)
		   ELSE
		      thisform.txtcwellname.set('value','')
		   ENDIF 
		ENDIF    
	ENDPROC

	PROCEDURE txtcWellID.LostFocus
		ON KEY LABEL F2 *
		DODEFAULT()
	ENDPROC

	PROCEDURE txtcWellID.Valid
		IF EMPTY(THIS.VALUE)
		   THISFORM.txtcWellName.SET('value','')
		ELSE
		   SELECT suspense  &&  Check to see if there is any suspense for this owner and this well.
		   LOCATE FOR cwellid = THIS.VALUE AND cownerid = THISFORM.txtcOwnerID.VALUE
		   IF NOT FOUND()
		      THISFORM.oMessage.warning('There are no suspense history entries for this owner for this well.  Verify that this owner has interests in this well in the division of interests.')
		      this.set('value','')
		      thisform.txtcWellName.set('value','')
		      RETURN 0
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE txtcWellName.When
		RETURN .F.
		
	ENDPROC

	PROCEDURE txtdDate.Init
		IF DODEFAULT()
		   IF NOT m.goApp.lAMVersion
		      this.lcheckdate = .t.
		   ELSE
		      this.lcheckdate = .f.
		   ENDIF 
		ENDIF    
	ENDPROC

	PROCEDURE txtdDate.Refresh
		this.cvaluesource = 'this.value'
		
		DODEFAULT()
	ENDPROC

ENDDEFINE
