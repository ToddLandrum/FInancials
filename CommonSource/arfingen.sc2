*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="arfingen.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="1" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 475
	Left = 26
	Name = "Dataenvironment"
	Top = 78
	Width = 590

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "aropt", ;
		CursorSource = "aropt", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "custown", ;
		CursorSource = "custown", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor10", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "finchgs", ;
		CursorSource = "finchgs", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor11", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "terms", ;
		CursorSource = "terms", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor12", ;
		Order = "cidterm", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Order = "acctno", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 291, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Order = "glbatch", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "invhdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "invhdr", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Order = "cbatch", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "invdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "invdet", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 13, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Order = "cownerid", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "custs", ;
		CursorSource = "custs", ;
		Database = ..\datafiles\financechargedata\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor9", ;
		Order = "ccustid", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formarfingen AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Lbltextcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmdProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="CmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboApplyTo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtdGenDate" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: genfinchg		&& Generates the finance charges for customer/owners
		*m: glentries		&& Creates the G/L entries for each finance charge.
		*p: ofinsel		&& Object reference to customer/owner selection form.
	*</DefinedPropArrayMethod>

	Caption = "Generate Finance Charges"
	DoCreate = .T.
	Height = 189
	HelpContextID = 341
	Name = "Formarfingen"
	Width = 288
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cboApplyTo' AS cbocomboboxcustom WITH ;
		ColumnCount = 1, ;
		DisplayCount = 2, ;
		DisplayValue = , ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 70, ;
		Margin = 2, ;
		Name = "cboApplyTo", ;
		RowSourceType = 0, ;
		TabIndex = 2, ;
		Top = 79, ;
		Value = , ;
		Width = 202
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'CmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Exit", ;
		FontBold = .T., ;
		FontSize = 8, ;
		FontUnderline = .F., ;
		Height = 34, ;
		Left = 149, ;
		Name = "CmdExit", ;
		TabIndex = 4, ;
		Top = 132, ;
		Width = 74
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'CmdProcess' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Process", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Height = 34, ;
		Left = 65, ;
		Name = "CmdProcess", ;
		TabIndex = 3, ;
		Top = 132, ;
		Width = 74
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 24, ;
		Left = 12, ;
		Name = "Glmaint", ;
		Top = 132, ;
		Width = 24
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbltextcustom1' AS lbltextcustom WITH ;
		Caption = "Generation Date:", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 16, ;
		Name = "Lbltextcustom1", ;
		TabIndex = 6, ;
		Top = 38, ;
		Width = 83
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom2' AS lbltextcustom WITH ;
		Caption = "Apply To:", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 16, ;
		Name = "Lbltextcustom2", ;
		TabIndex = 7, ;
		Top = 81, ;
		Width = 48
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'txtdGenDate' AS dpk WITH ;
		ControlSource = "", ;
		Height = 20, ;
		lcheckdate = .T., ;
		Left = 108, ;
		Name = "txtdGenDate", ;
		TabIndex = 1, ;
		Top = 36, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />
	
	PROCEDURE genfinchg		&& Generates the finance charges for customer/owners
		LPARA laSelected
		*  Generates finance charges for the given customer/owners
		
		LOCAL m.cIntAcct, m.cARAcct, m.nDiscIn, m.nDiscPct, m.nNetDueIn, m.cTermDesc
		LOCAL lnCount, lnMax, lnProgress, lOwner
		
		*  Get the number of selected customers/owners
		*  If the count is zero, bail out
		lnCharges     = ALEN(laSelected,1)
		IF lnCharges = 0
		    RETURN
		ENDIF
		
		m.lOwner = .F.
		
		*  Get the date to use as the generation date
		ldDate      = THISFORM.txtdGenDate.VALUE
		
		*  Initialize some variables
		m.cTermDesc = ' '
		STORE 0 TO m.nDiscIn, m.nDiscPct, m.nNetDueIn
		
		SELECT aropt
		m.cIntAcct = cIntAcct
		m.cARAcct = cARAcct
		
		DO case
		   CASE EMPTY(m.cIntAcct) AND EMPTY(m.cARAcct)  &&  Warn if both accounts are blank
		      thisform.oMessage.Warning('Neither the Accounts Receivable nor the Int Income accounts are specified in the Accounts Receivable section of the Edit >> Preferences screen.  Please correct before proceeeding.')
		      RETURN .f.
		   CASE EMPTY(m.cIntAcct)  &&  No interest income account
		      thisform.oMessage.Warning('The Int Income account is not specified in the Accounts Receivable section of the Edit >> Preferences screen.  Please correct before proceeeding.')
		      RETURN .f.
		   CASE EMPTY(m.cARAcct)   &&  No accounts receivable account specified
		      thisform.oMessage.Warning('The Accounts Receivable account is not specified in the Accounts Receivable section of the Edit >> Preferences screen.  Please correct before proceeeding.')
		      RETURN .f.
		ENDCASE
		
		
		SELECT finchgs
		SET ORDER TO cFinCode
		
		CREATE CURSOR custbal ;
		    (cCustid     C(10), ;
		    cCustname   C(40), ;
		    lOwner      L, ;
		    cInvNum     C(10), ;
		    cFinCode    C(1), ;
		    dInvDate    D, ;
		    dDueDate    D, ;
		    cidTerm     C(8), ;
		    lChgInt     l, ;
		    nInvBal     N(12,2), ;
		    nInvAge     N(4,0),  ;
		    nPctInt     N(7,4), ;
		    nFinChg     N(12,2))
		INDEX ON cCustid TAG cCustid
		INDEX ON cCustid+cInvNum TAG custinv
		jtemp = laSelected[1]
		IF TYPE('jtemp') <> 'C'
		    RETURN
		ENDIF
		
		*  Scan through the selected array and process each customer/owner in it
		FOR lnX = 1 TO lnCharges
		    m.cCustid = LEFT(laSelected[lnX],10)
		    SELECT custs
		    SET ORDER TO cCustid
		    IF SEEK (m.cCustid)
		        m.cCustname = cCustname
		        m.cFinCode  = cFinCode
		        m.cidTerm   = cidTerm
		    ELSE
		        SELECT investor
		        SET ORDER TO cOwnerID
		        IF SEEK(m.cCustid)
		            m.cCustname = cOwnName
		            m.cFinCode = cFinCode
		            m.cidTerm  = cidTerm
		            m.lOwner = .T.
		        ENDIF
		    ENDIF
		    *  Retrieve Finance Charge Info
		    SELECT finchgs
		    IF SEEK (m.cFinCode)
		        m.nFinInt  = nFinInt
		        m.nFinDays = nFinDays
		        m.nMinFin  = nMinFin
		        m.lChgInt  = lChgInt
		        *  Look for outstanding invoices that are due before date given
		        SELECT invhdr
		        SCAN FOR cCustid = m.cCustid ;
		                AND dDueDate <= ldDate  ;
		                AND nInvBal > 0
		            SCATTER MEMVAR
		            m.nInvAge  = ldDate - dDueDate
		            lnMonthInt = (m.nFinInt/365)/100
		            m.nPctInt  = lnMonthInt
		            *  If invoice is past due by at least # of days finance
		            *  charge code specifies, calculate the finance charge
		            IF m.nInvAge >= m.nFinDays
		                m.nFinChg  = ROUND(m.nInvBal * (m.nInvAge * lnMonthInt),2)
		                * If finance charge is less than minimum, charge the minimum.
		                IF m.nFinChg < m.nMinFin
		                    m.nFinChg = m.nMinFin
		                ENDIF
		                INSERT INTO custbal FROM MEMVAR
		            ENDIF
		        ENDSCAN  && invhdr
		    ENDIF
		ENDFOR
		
		SELECT custbal
		IF RECC() = 0
		    THISFORM.oMessage.DISPLAY('%msgNoFinChgGen','Finance Charges')
		    RETURN
		ENDIF
		
		SELECT custbal
		lnMax = RECC()
		lnProgress = 1
		oProgress = THISFORM.oMessage.ProgressBar('Generating Finance Charges....')
		oProgress.SetProgressRange(0,lnMax)
		
		SELECT custbal
		SCAN
		    SCATTER MEMVAR
		    *
		    * Remove "FC" from front of Finance Charge invoices so we can tack
		    * "FC" for the new finance charge invoice
		    *
		    IF LEFT(m.cInvNum,2) = 'FC'
		        *  Don't charge finance charges on finance charges if code doesn't
		        *  allow it.
		        IF NOT m.lChgInt
		            LOOP
		        ENDIF
		        m.cInvNum = SUBSTR(m.cInvNum,3)
		    ENDIF
		    oProgress.UpdateProgress(lnProgress)
		    lnProgress = lnProgress + 1
		    SELECT terms
		    SET ORDER TO cidTerm
		    IF SEEK(m.cidTerm)
		        m.cTermDesc = cTermDesc
		        m.nDiscIn   = nDiscIn
		        m.nDiscPct  = nDiscPct
		        m.nNetDueIn = nNetDueIn
		    ELSE
		        m.cTermDesc = '        '
		        m.nDiscIn   = 0
		        m.nDiscPct  = 0
		        m.nNetDueIn = 0
		    ENDIF
		    m.dDueDate = ldDate + m.nNetDueIn
		    SELECT invhdr
		
		    m.cBatch  = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		    m.cInvNum = 'FC' + TRANSFORM(THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Invoice Number'))
		    m.cCustid    = m.cCustid
		    m.dInvDate   = ldDate
		    m.nSalesTax  = 0
		    m.nSubTotal  = m.nFinChg
		    m.nPayments  = 0
		    m.nDiscTot   = 0
		    m.nInvTot    = m.nFinChg
		    m.cidTerm    = m.cidTerm
		    m.cTaxCode   = ' '
		    IF NOT m.lowner
		       m.cinvtype   = 'I'
		    ELSE
		       m.cinvtype   = 'J'
		    ENDIF       
		    m.mNotes     = 'Finance Charge'
		    m.dDueDate   = m.dDueDate
		    m.dDiscDate  = m.dDueDate
		    m.nInvBal    = m.nFinChg
		    m.dPostDate  = ldDate
		    m.cReference = 'FC' + ALLTRIM(cInvNum)
		    INSERT INTO invhdr FROM MEMVAR
		
		    SELECT invdet
		    m.cidinvd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Invoice Detail')
		    m.cItemId    = 'FC '
		    m.cItemDesc  = 'Finance Charge - ' + DTOC(ldDate)
		    m.nPrice     = m.nFinChg
		    m.cPriceCode = '1'
		    m.nQuantity  = 1
		    m.cMeasure   = ' '
		    m.nExtension = m.nFinChg
		    m.nItemTax   = 0
		    m.cAcctNo    = m.cIntAcct
		    m.cTaxable   = 'E'
		    INSERT INTO invdet FROM MEMVAR
		
		    *  Generage the G/L entries for this invoice
		    THISFORM.glentries()
		ENDSCAN
		
		SELE invhdr
		TABLEUPDATE(.T.)
		SELE invdet
		TABLEUPDATE(.T.)
		SELECT glmaster
		TABLEUPDATE(.t.)
		
		IF TYPE('oProgress') = 'O'
		    oProgress.CLOSE()
		ENDIF
		
		THISFORM.oMessage.DISPLAY('Finance charges have been generated and posted.')
		
		SELECT custbal
		WAIT CLEAR
		
		IF USED('custwrk')
		    USE IN custwrk
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE glentries		&& Creates the G/L entries for each finance charge.
		LOCAL lcBatch
		
		lcSelect = SELECT()
		
		lcBatch = invhdr.cBatch
		
		*
		*  Delete the G/L journal entries for this invoice
		*
		thisform.glmaint.delbatch(lcBatch)
		
		*
		*  Set the source for this entry
		*
		thisform.glmaint.cSource = 'AR'
		
		*
		* Get the default A/R account
		*
		SELECT aropt
		GO TOP
		lcARAcct   = cARAcct
		lcTaxAcct  = cTaxAcct
		lcCOGSAcct = cCOGSAcct
		
		*
		*  Create the G/L journal entries for this invoice
		*
		
		*  A/R entry
		thisform.glmaint.cBatch     = lcBatch
		thisform.glmaint.dGLDate    = invhdr.dPostDate
		thisform.glmaint.cReference = 'Inv: ' + ALLTRIM(invhdr.cinvnum)
		thisform.glmaint.cDesc      = 'Finance Charge'
		thisform.glmaint.cAcctNo    = lcARAcct
		thisform.glmaint.cId        = invhdr.cCustId
		thisform.glmaint.nAmount    = invhdr.nInvTot
		
		thisform.glmaint.updatebatch()
		
		*  Detail Lines
		SELECT invdet
		lnRecNo = RECNO()
		SCAN FOR cBatch == lcBatch
		   thisform.glmaint.cBatch     = lcBatch
		   thisform.glmaint.dGLDate    = invhdr.dPostDate
		   thisform.glmaint.cReference = 'Inv: ' + ALLTRIM(invhdr.cinvnum)
		   thisform.glmaint.cDesc      = 'Finance Charge'
		   thisform.glmaint.cAcctNo    = invdet.cAcctNo
		   thisform.glmaint.cId        = invhdr.cCustId
		   thisform.glmaint.nAmount    = invdet.nExtension * -1     && Assume to be credit
		   thisform.glmaint.updatebatch()
		   
		ENDSCAN   
		GOTO lnRecNo
		
		*
		*  Check to make sure the batch balances
		*
		llReturn = thisform.glmaint.chkBalance()
		
		IF not llReturn
		   WAIT WIND 'The Batch Was Not In Balance...Unable to save invoice.'   
		ENDIF   
		
		SELECT (lcSelect)
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   this.oregistry = findglobalobject('cmregistry')
		ENDIF 
	ENDPROC

	PROCEDURE cboApplyTo.Init
		THIS.ADDLISTITEM('All Customers/Owners',1)
		THIS.ADDLISTITEM('Selected Customers/Owners',2)
		THIS.LISTITEMID = 1
		DODEFAULT()
		
	ENDPROC

	PROCEDURE CmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE CmdProcess.Click
		
		*  Check to see which item was selected
		DO CASE
		   CASE ALLTRIM(thisform.cboApplyTo.ListItem(thisform.cboApplyTo.ListItemID)) = 'All Customers/Owners'
		      SELECT cCustid+'-'+cCustName FROM custown INTO ARRAY laSelected ORDER BY cCustID
		      
		      thisform.GenFinChg(@laSelected)
		   CASE ALLTRIM(thisform.cboApplyTo.ListItem(thisform.cboApplyTo.ListItemID)) = 'Selected Customers/Owners'   
		      DO FORM arfinsel NAME thisform.oFinSel
		      lnCount = ALEN(thisform.oFinSel.aSelected)
		      DIMENSION laSelected[lnCount]
		      FOR lnX = 1 TO lnCount
		         laSelected[lnX] = thisform.oFinSel.aSelected[lnX]
		      ENDFOR
		      thisform.GenFinChg(@laSelected)
		ENDCASE
		
		IF TYPE('thisform.oFinSel') = 'O'
		   thisform.oFinSel.Release()
		ENDIF
		   
		   
		   
	ENDPROC

	PROCEDURE Glmaint.delbatch
		LPARAMETERS tcbatch
		
		IF TYPE('tcBatch') <> 'C'
		   WAIT WIND NOWAIT 'The batch number passed to delete batch was invalid...'
		   RETURN
		ENDIF
		
		DODEFAULT(tcBatch)   
	ENDPROC

ENDDEFINE
