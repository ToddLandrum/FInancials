*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="dmfixrelpct.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 448
	Left = 83
	Name = "Dataenvironment"
	Top = 58
	Width = 729

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "apopt", ;
		CursorSource = "apopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "groups", ;
		CursorSource = "groups", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 538, ;
		Name = "Cursor10", ;
		Top = 21, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 416, ;
		Name = "Cursor11", ;
		Top = 152, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "expense1", ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor13", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 21, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "expense", ;
		BufferModeOverride = 5, ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Order = "yrprdgrp", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "expcat", ;
		CursorSource = "expcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 415, ;
		Name = "Cursor9", ;
		Top = 21, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formdmfixrelpct AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Lbltextcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swgroup" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swyear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swperiod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDate1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: getwellrevenue		&& Creates a cursor of well revenue by well for this run so that any expenses being released that are based on a pct of revenue can be calculated.
		*m: process		&& Releases the fixed expenses
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Release Recurring Well Expenses"
	DataSession = 2
	DoCreate = .T.
	Height = 401
	HelpContextID = 102
	Name = "formdmfixrelpct"
	Visible = .T.
	Width = 556
	_memberdata = <VFPData>
		<memberdata name="getwellrevenue" display="GetWellRevenue"/>
		</VFPData>		&& XML Metadata for customizable properties
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Left = 329
	Mwresize1.Name = "Mwresize1"
	Mwresize1.Top = 136

	ADD OBJECT 'cboProcess' AS cbocomboboxcustom WITH ;
		Height = 20, ;
		Left = 219, ;
		Name = "cboProcess", ;
		TabIndex = 9, ;
		Top = 244, ;
		Width = 144
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Default = .F., ;
		Height = 36, ;
		Left = 288, ;
		Name = "cmdExit", ;
		TabIndex = 12, ;
		Top = 348, ;
		Width = 59
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdProcess' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Process", ;
		Height = 36, ;
		Left = 210, ;
		Name = "cmdProcess", ;
		TabIndex = 11, ;
		Top = 348, ;
		Width = 59
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 19, ;
		Left = 318, ;
		Name = "Glmaint", ;
		Top = 133, ;
		Width = 21
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = " Well Group:", ;
		Left = 146, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 2, ;
		Top = 57
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Process:", ;
		Left = 146, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 10, ;
		Top = 246
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom2' AS lbltextcustom WITH ;
		Caption = "Period/Year:", ;
		Left = 146, ;
		Name = "Lbltextcustom2", ;
		TabIndex = 6, ;
		Top = 118
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom3' AS lbltextcustom WITH ;
		Caption = "Acct. Date:", ;
		Left = 146, ;
		Name = "Lbltextcustom3", ;
		TabIndex = 8, ;
		Top = 179
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom5' AS lbltextcustom WITH ;
		Caption = "/", ;
		FontBold = .T., ;
		FontSize = 10, ;
		Height = 18, ;
		Left = 244, ;
		Name = "Lbltextcustom5", ;
		TabIndex = 5, ;
		Top = 117, ;
		Width = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Swgroup' AS swgroup WITH ;
		Left = 219, ;
		lexcludeall = .F., ;
		Name = "Swgroup", ;
		TabIndex = 1, ;
		Top = 55
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'Swperiod' AS swperiod WITH ;
		Left = 219, ;
		Name = "Swperiod", ;
		TabIndex = 3, ;
		Top = 116
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'Swyear' AS swyear WITH ;
		Left = 253, ;
		Name = "Swyear", ;
		TabIndex = 4, ;
		Top = 116
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtDate1' AS dpk WITH ;
		ControlSource = "", ;
		Height = 20, ;
		lcheckdate = .T., ;
		Left = 219, ;
		lmorethan90 = .T., ;
		Name = "txtDate1", ;
		TabIndex = 8, ;
		Top = 177, ;
		Visible = .T., ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />
	
	PROCEDURE getwellrevenue		&& Creates a cursor of well revenue by well for this run so that any expenses being released that are based on a pct of revenue can be calculated.
		
		* Get the current revenue per well so that expenses based on pct of revenue can be calculated.
		
		
		* Waiting to see if the calculations should be on Gross or Net revenue
		
		
		 SELECT  income.cwellid,  ;  && Income
		            income.drevdate AS ddate,  ;
		            income.cyear,  ;
		            income.cperiod,  ;
		            income.crefid,  ;
		            income.crevkey, ;
		            income.csource AS cdescrip,  ;
		            income.csource,  ;
		            income.nunits,  ;
		            income.cownerid, ;
		            income.nrunno,  ;
		            income.nprice AS nprice,  ;
		            income.ntotalinc AS ntotal ;
		            FROM income, wells  ;
		            WHERE income.cwellid IN (SELECT cid FROM SELECTED) ;
		            AND NOT 'TAX' $ csource ;
		            AND income.cwellid = wells.cwellid  ;
		            AND IIF(tcgroup <> '**', wells.cGroup = tcgroup, .T.)  ;
		            AND &lcincselect ;
		            &groupinclude  ;
		            INTO CURSOR welltmp  ;
		            ORDER BY ipagebreak, wells.cwellid, income.cyear, income.cperiod
		
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   * Recall Fixed expenses if they've somehow gotten deleted
		   IF m.goapp.RecallFixedExpenses()
		      MESSAGEBOX('A problem was found with your Fixed Expenses. We have recovered this problem for you. Please check your fixed expense listing ' + ;
		                 'by going to Reports, Well Reports, Fixed Expense Listing to verify your fixed expenses before releasing them.',48,'Fixed Expenses')
		   ENDIF               
		ENDIF 
		
	ENDPROC

	PROCEDURE process		&& Releases the fixed expenses
		LOCAL lcGroup, llAllWells, lcYear, lcPeriod, ldExpDate, llSepClose
		LOCAL lnFixed, lnTotal, lcExpClear, lcAPAcct, oProgress, llNoPost
		LOCAL lAPTran, lFixed, lcDMExp, lcDeptNo, lcWellID1, lcWellID2, llOK, llPostDm, llReturn, lnAmount
		LOCAL lnAmtRel, lnCount, lnMax, loError
		LOCAL cBatch, cCatCode, cRunYearJIB, cRunYearRev, cWellID, cYear, cexpclass, cidexpe, cidexph
		LOCAL cperiod, dAcctDate, dExpdate, nRunNoJIB, nRunnoRev
		
		llReturn = .T.
		
		TRY
		   SET DELETED ON
		
		   * Get the setting for JV Posting
		   IF m.goapp.lPartnershipMod
		      swselect('progopt')
		      GO TOP
		      llJVPosting = lJVPosting
		   ELSE
		      llJVPosting = .F.
		   ENDIF
		
		   *  Get the registry object
		   THISFORM.oRegistry = FindGlobalObject('cmRegistry')
		
		   *  Get the separate closing for JIB setting
		   SELECT options
		   llSepClose = lSepClose
		   lcDeptNo   = cDeptNo
		   lcDMExp    = cFixedAcct
		
		   IF TYPE('m.goApp') = 'O'
		      llPostDm = m.goapp.lAMVersion
		   ENDIF
		
		   *  Get the expense clearing account
		   SELECT glopt
		   lcExpClear = cExpClear
		
		   IF EMPTY(lcExpClear)
		      lcExpClear = cSuspense
		   ENDIF
		
		   *  Get the A/P account
		   SELECT apopt
		   lcAPAcct = cAPAcct
		
		   IF EMPTY(lcDMExp)
		      lcDMExp = lcAPAcct
		   ENDIF
		
		   llAllWells = .F.
		
		   lcGroup   = LEFT(THISFORM.swGroup.VALUE, 2)
		   lcYear    = THISFORM.swYear.VALUE
		   lcPeriod  = THISFORM.swPeriod.VALUE
		   ldExpDate = THISFORM.txtDate1.VALUE
		
		   * See if the date is within a close fiscal period
		   IF NOT THISFORM.glmaint.checkperiod(ldExpDate, .T.)
		      THISFORM.omessage.warning('Unable to release fixed expenses. Either the fiscal year or period represented by this date has been closed.')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   IF LEFT(THISFORM.cboProcess.VALUE, 1) = 'A'
		      llAllWells = .T.
		   ELSE
		      llAllWells = .F.
		   ENDIF
		
		   *  If all wells are to be processed, select them into wellsel
		   *  Exclude Inactive, Sold, and Plugged wells, since they won't be processed by the closing anyway
		   IF llAllWells
		      SELECT  cWellID, ' ' AS temp ;
		         FROM wells  ;
		         WHERE IIF(lcGroup <> '**', cGroup = lcGroup, .T.) ;
		         AND NOT INLIST(cwellstat, 'I', 'S', 'P') ;
		         INTO CURSOR wellsel ;
		         ORDER BY cWellID
		   ELSE
		      DO FORM dmselwells WITH lcGroup
		   ENDIF
		
		   *
		   *  There were no wells selected
		   *
		   SELECT wellsel
		   IF RECC() = 0
		      MESSAGEBOX('You must choose at least one well to have fixed expenses release.', 16, 'Unable to Release Fixed Expenses')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   *
		   *  Check for fixed expenses that have already been released.
		   *
		   lnFixed = 0
		
		   SELECT wellsel
		   SCAN
		      m.cWellID = cWellID
		      SELECT expense
		      SCAN FOR cWellID = m.cWellID ;
		            AND nRunnoRev = 0 AND cYear <> 'FIXD' ;
		            AND lFixed = .T. AND NOT DELETED()
		         lnFixed = lnFixed + 1
		      ENDSCAN
		   ENDSCAN
		
		   IF lnFixed > 0
		      IF NOT THISFORM.omessage.CONFIRM('Fixed expenses have already been released for the new run for some or all of the wells. ' + ;
		            ' Do you want to continue?')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   SELECT wellsel
		   GO TOP
		   lcWellID1 = cWellID
		   GO BOTT
		   lcWellID2 = cWellID
		
		   * Only get the flat amount expenses here
		   SELECT  * ;
		      FROM expense ;
		      WHERE cYear = 'FIXD' ;
		      AND cWellID IN (SELECT  cWellID ;
		      FROM wellsel) ;
		      AND iType # 2 ;
		      INTO CURSOR exptemp ;
		      ORDER BY cWellID
		
		   lnMax = _TALLY
		
		   * Get the pct amount expenses here
		   SELECT  * ;
		      FROM expense ;
		      WHERE cYear = 'FIXD' ;
		      AND cWellID IN (SELECT  cWellID ;
		      FROM wellsel) ;
		      AND iType = 2 ;
		      INTO CURSOR exppct ;
		      ORDER BY cWellID
		
		   lnMax = lnMax + _TALLY
		   IF lnMax = 0
		      THISFORM.omessage.DISPLAY('There were no fixed expenses found for the wells chosen...')
		      llReturn = .F.
		      EXIT
		   ENDIF
		  
		   *  Build the properties for the journal entries
		   THISFORM.glmaint.dgldate    = ldExpDate
		   THISFORM.glmaint.cReference = 'Fixed Exp Prd:' + lcYear + lcPeriod + lcGroup
		   THISFORM.glmaint.cSource    = 'DM'
		   THISFORM.glmaint.cDeptNo    = lcDeptNo
		   THISFORM.glmaint.cidchec    = ''
		   THISFORM.glmaint.mNotes     = ''
		
		   oProgress = THISFORM.omessage.ProgressBarEX('Releasing Fixed Expenses to Period: ' + lcYear + '/' + lcPeriod, '')
		   oProgress.SetProgressRange(0, lnMax)
		   lnCount = 0
		
		   lnAmtRel = 0
		
		   ** Make sure the wellinv table is open
		   ** so we can check any one man items
		   ** below to make sure the owner still
		   ** has an interest in the well.
		   swselect('wellinv')
		
		   SELECT wellsel
		   SCAN
		      SCATTER MEMVAR
		      SELECT exptemp
		      SCAN FOR cWellID = m.cWellID
		         SCATTER MEMVAR
		
		         IF m.namount = 0
		            LOOP
		         ENDIF
		
		         SELE vendor
		         LOCATE FOR cVendorID == m.cVendorID
		         IF NOT FOUND()
		            llNoPost = .T.
		         ELSE
		            llNoPost = .F.
		         ENDIF
		         oProgress.SetProgressMessage(' Well: ' + m.cWellID)
		         oProgress.UpdateProgress(lnCount)
		         lnCount = lnCount + 1
		
		         IF NOT EMPTY(m.cownerid)
		            ** Check to make sure the owner has an interest in the well
		            SELECT wellinv
		            LOCATE FOR cownerid == m.cownerid AND cWellID == m.cWellID
		            IF NOT FOUND()
		               LOOP
		            ENDIF
		         ENDIF
		
		         IF EMPTY(m.cCatCode)
		            SELECT expcat
		            SET ORDER TO ccateg
		            IF SEEK(m.ccateg)
		               m.cCatCode  = cCatCode
		               m.cexpclass = cexpclass
		            ELSE
		               LOOP
		            ENDIF
		         ELSE
		            IF llJVPosting
		               SELECT expcat
		               SET ORDER TO cCatCode
		               IF SEEK(m.cCatCode)
		                  m.cCatCode  = cCatCode
		                  m.cexpclass = cexpclass
		                  IF m.goapp.lQBVersion
		                     lcExpClear = cownacctlistid
		                  ELSE
		                     lcExpClear = cdraccto
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		         *      m.cBatch = thisform.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		         m.cYear       = lcYear
		         m.cRunYearRev = lcYear
		         m.cRunYearJIB = lcYear
		         m.nRunnoRev   = 0
		         m.nRunNoJIB   = 0
		         m.cperiod     = lcPeriod
		         m.dExpdate    = ldExpDate
		         m.dAcctDate   = ldExpDate
		         m.lFixed      = .T.
		         m.lAPTran     = .F.
		         m.cidexph     =  ''
		         m.cBatch      = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		         m.cidexpe     = GetNextPK('Expense')
		         m.cYear   = lcYear
		         m.cperiod = lcPeriod
		         lnAmtRel  = lnAmtRel + m.namount
		         m.cpaidbyck = ''
		         INSERT INTO expense FROM MEMVAR
		
		         *  Build the journal entries
		         IF llPostDm AND NOT llNoPost
		            THISFORM.glmaint.cBatch   = m.cBatch
		            * Net out "Dummy" owner's share
		            IF EMPTY(m.cownerid)  &&  Don't net out dummy share if it's a one-man item - BH 8/25/04
		               lnAmount = swNetExp(m.namount, m.cWellID, .T., m.cexpclass, 'B')
		            ELSE
		               * Check to see if this is a dummy owner
		               * If it is don't post to the G/L
		               swselect('investor')
		               SET ORDER TO cownerid
		               IF SEEK(m.cownerid) AND lDummy
		                  LOOP
		               ENDIF
		               lnAmount = m.namount
		            ENDIF
		            THISFORM.glmaint.namount  = lnAmount * -1
		            THISFORM.glmaint.cAcctno  = lcDMExp
		            THISFORM.glmaint.cUnitNo  = m.cWellID
		            THISFORM.glmaint.cCatCode = m.cCatCode
		            THISFORM.glmaint.cID      = m.cVendorID
		            THISFORM.glmaint.cDesc    = m.ccateg
		            THISFORM.glmaint.updatebatch()
		
		            THISFORM.glmaint.cAcctno = lcExpClear
		            THISFORM.glmaint.namount = lnAmount
		            THISFORM.glmaint.cUnitNo = m.cWellID
		            THISFORM.glmaint.updatebatch()
		         ENDIF
		
		      ENDSCAN
		
		      SELECT exppct
		      SCAN FOR cWellID = m.cWellID
		         SCATTER MEMVAR
		         
		          * Get the net revenue for the pct wells
		      SELECT cWellID, SUM(nTotalInc) AS nNetTotal ;
		         FROM income WHERE cWellID = m.cwellid ;
		         AND nRunNo = 0 ;
		         AND dRevDate <= ldExpDate ;
		         INTO CURSOR temp READWRITE ;
		         ORDER BY cWellID GROUP BY cWellID
		
		      SELECT cWellID, SUM(namount)*-1 AS nNetTotal ;
		         FROM expense WITH (BUFFERING = .T.) ;
		         WHERE cWellID = m.cWellID ;
		         AND nRunnoRev = 0 ;
		         AND cYear # 'FIXD' ;
		         AND dExpdate <= ldExpDate ;
		         INTO CURSOR tmpexp ;
		         ORDER BY cWellID GROUP BY cWellID
		
		      SELECT temp
		      APPEND FROM DBF('tmpexp')
		      swclose('tmpexp')
		
		      SELECT cWellID, SUM(nNetTotal) AS nNetTotal ;
		         FROM temp ;
		         INTO CURSOR netrevenue ;
		         ORDER BY cWellID GROUP BY cWellID
		
		         SELECT netrevenue
		         SCAN FOR cWellID = m.cWellID
		            m.nNetTotal = nNetTotal
		
		            m.namount = ROUND(m.nNetTotal * (m.namount/100),2)
		
		            IF m.namount > m.nMaxAmount AND m.nMaxAmount # 0
		               m.namount = m.nMaxAmount
		            ENDIF
		         ENDSCAN   && netrevenue
		
		         IF NOT EMPTY(m.cownerid)
		            ** Check to make sure the owner has an interest in the well
		            SELECT wellinv
		            LOCATE FOR cownerid == m.cownerid AND cWellID == m.cWellID
		            IF NOT FOUND()
		               LOOP
		            ENDIF
		         ENDIF
		
		         IF EMPTY(m.cCatCode)
		            SELECT expcat
		            SET ORDER TO ccateg
		            IF SEEK(m.ccateg)
		               m.cCatCode  = cCatCode
		               m.cexpclass = cexpclass
		            ELSE
		               LOOP
		            ENDIF
		         ELSE
		            IF llJVPosting
		               SELECT expcat
		               SET ORDER TO cCatCode
		               IF SEEK(m.cCatCode)
		                  m.cCatCode  = cCatCode
		                  m.cexpclass = cexpclass
		                  IF m.goapp.lQBVersion
		                     lcExpClear = cownacctlistid
		                  ELSE
		                     lcExpClear = cdraccto
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		         *      m.cBatch = thisform.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		         m.cYear       = lcYear
		         m.cRunYearRev = lcYear
		         m.cRunYearJIB = lcYear
		         m.nRunnoRev   = 0
		         m.nRunNoJIB   = 0
		         m.cperiod     = lcPeriod
		         m.dExpdate    = ldExpDate
		         m.dAcctDate   = ldExpDate
		         m.lFixed      = .T.
		         m.lAPTran     = .F.
		         m.cidexph     =  ''
		         m.cBatch      = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		         m.cidexpe     = GetNextPK('Expense')
		         m.cYear   = lcYear
		         m.cperiod = lcPeriod
		         lnAmtRel  = lnAmtRel + m.namount
		         m.cpaidbyck = ''
		         INSERT INTO expense FROM MEMVAR
		
		         *  Build the journal entries
		         IF llPostDm AND NOT llNoPost
		            THISFORM.glmaint.cBatch   = m.cBatch
		            * Net out "Dummy" owner's share
		            IF EMPTY(m.cownerid)  &&  Don't net out dummy share if it's a one-man item - BH 8/25/04
		               lnAmount = swNetExp(m.namount, m.cWellID, .T., m.cexpclass, 'B')
		            ELSE
		               * Check to see if this is a dummy owner
		               * If it is don't post to the G/L
		               swselect('investor')
		               SET ORDER TO cownerid
		               IF SEEK(m.cownerid) AND lDummy
		                  LOOP
		               ENDIF
		               lnAmount = m.namount
		            ENDIF
		            THISFORM.glmaint.namount  = lnAmount * -1
		            THISFORM.glmaint.cAcctno  = lcDMExp
		            THISFORM.glmaint.cUnitNo  = m.cWellID
		            THISFORM.glmaint.cCatCode = m.cCatCode
		            THISFORM.glmaint.cID      = m.cVendorID
		            THISFORM.glmaint.cDesc    = m.ccateg
		            THISFORM.glmaint.updatebatch()
		
		            THISFORM.glmaint.cAcctno = lcExpClear
		            THISFORM.glmaint.namount = lnAmount
		            THISFORM.glmaint.cUnitNo = m.cWellID
		            THISFORM.glmaint.updatebatch()
		         ENDIF
		
		      ENDSCAN  && exppct
		   ENDSCAN   && wellsel
		
		   llOK = .F.
		   BEGIN TRANSACTION
		   SELE glmaster
		   llOK = TABLEUPDATE(.T., .T.)
		   IF llOK
		      SELE expense
		      llOK = TABLEUPDATE(.T., .T.)
		   ELSE
		      DO errorlog WITH 'Process', 1, 'DMFixRel', 999, 'Unable to commit changes to GLMaster table', ' '
		   ENDIF
		   IF llOK
		      SELE coabal
		      llOK = TABLEUPDATE(.T., .T.)
		      IF NOT llOK
		         DO errorlog WITH 'Process', 1, 'DMFixRel', 999, 'Unable to commit changes to COABal table', ' '
		      ENDIF
		   ELSE
		      DO errorlog WITH 'Process', 1, 'DMFixRel', 999, 'Unable to commit changes to Expense table', ' '
		   ENDIF
		   IF llOK
		      END TRANSACTION
		   ELSE
		      MESSAGEBOX('There was a problem releasing the fixed expenses.  All files were reset.' + ;
		         'Check the system log found under the Other Report menu for more information.', 16, 'Problem Found')
		      ROLLBACK
		   ENDIF
		   oProgress.CloseProgress()
		
		   IF llOK
		      MESSAGEBOX('Release of Fixed Expenses for Period ' + lcYear + '/' + lcPeriod + ' Completed.' + CHR(13) + ;
		         'Released:  $' + ALLT(STR(lnAmtRel, 12, 2)) + ' total.', 0, 'Release Fixed Expenses')
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Process', loError.LINENO, 'DMFixRel', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the fixed expenses at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
	ENDPROC

	PROCEDURE cboProcess.Init
		this.addlistitem('All Wells',1)
		this.addlistitem('Selected Wells',2)
		this.listitemid = 1
		
		DODEFAULT()
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdProcess.Click
		thisform.process()
	ENDPROC

	PROCEDURE Swgroup.Init
		DODEFAULT()
		
		this.listitemid = 1
	ENDPROC

	PROCEDURE txtDate1.Refresh
		this.cvaluesource = 'this.value'
		DODEFAULT()
	ENDPROC

ENDDEFINE
