*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="importexp_map.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
#INCLUDE "..\source\appdefs.h"

DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 200
	Left = 42
	Name = "Dataenvironment"
	Top = 483
	Width = 520

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "importmap", ;
		BufferModeOverride = 5, ;
		CursorSource = "importmap", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Filter = "cType='E'", ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "importdefs", ;
		BufferModeOverride = 5, ;
		CursorSource = "importdefs", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formexpimport_map AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Sfmoverlist1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtImportName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmdcommandbuttoncustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdTemplate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkReset" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addrequired
		*m: buildtemplate
		*m: disableavailable
		*m: loadavailable		&& Loads the list of available fields to choose from for imports.
		*m: lookupoper
		*m: refreshform
		*m: resetdefs
		*m: setstate		&& Method to set the form as edited so the save button enables.
		*p: importname
		*p: importtype
	*</DefinedPropArrayMethod>

	Caption = "Expense Import Mapping"
	clistexpression = importmap.cimportname
	cworkarea = importmap
	DoCreate = .T.
	Height = 600
	importname = 
	importtype = .F.
	lnonewask = .T.
	lremembersize = .F.
	Name = "FormExpImport_map"
	Visible = .T.
	Width = 515
	WindowState = 0
	_memberdata = <VFPData>
		<memberdata name="loadavailable" display="LoadAvailable"/>
		<memberdata name="refreshform" display="RefreshForm"/>
		<memberdata name="lookupoper" display="LookupOper"/>
		<memberdata name="setstate" display="SetState"/>
		<memberdata name="disableavailable" display="DisableAvailable"/>
		<memberdata name="buildtemplate" display="BuildTemplate"/>
		<memberdata name="resetdefs" display="ResetDefs"/>
		<memberdata name="importname" display="ImportName"/>
		<memberdata name="addrequired" display="AddRequired"/>
		</VFPData>
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 7
	cmlookupmanager.Name = "cmlookupmanager"
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Left = 468
	Mwresize1.Name = "Mwresize1"
	Mwresize1.TabIndex = 6
	Mwresize1.Top = 576

	ADD OBJECT 'chkReset' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Reset Import Defininitions", ;
		Left = 189, ;
		Name = "chkReset", ;
		Top = 571, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Cmdcommandbuttoncustom1' AS cmdcommandbuttoncustom WITH ;
		Caption = "View Field Explanations", ;
		Height = 35, ;
		Left = 84, ;
		Name = "Cmdcommandbuttoncustom1", ;
		Top = 528, ;
		Width = 144
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdTemplate' AS cmdcommandbuttoncustom WITH ;
		Caption = "Create Template", ;
		Height = 36, ;
		Left = 273, ;
		Name = "cmdTemplate", ;
		Top = 530, ;
		Width = 144
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Available Fields", ;
		FontSize = 10, ;
		Left = 75, ;
		Name = "Lbllabelcustom1", ;
		Top = 62
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Import Name:", ;
		Left = 55, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 8, ;
		Top = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		Caption = "Select which fields are included in the import and the order they exist in the import file.", ;
		ForeColor = 255,0,0, ;
		Left = 53, ;
		Name = "Lbllabelcustom3", ;
		TabIndex = 4, ;
		Top = 38
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom4' AS lbllabelcustom WITH ;
		Caption = "Mapped Fields", ;
		FontSize = 10, ;
		Left = 327, ;
		Name = "Lbllabelcustom4", ;
		Top = 62
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Sfmoverlist1' AS sfmoverlist WITH ;
		Height = 456, ;
		Left = 36, ;
		Name = "Sfmoverlist1", ;
		TabIndex = 5, ;
		Top = 85, ;
		Width = 440, ;
		cmdAdd.Name = "cmdAdd", ;
		cmdAddAll.Name = "cmdAddAll", ;
		cmdRemove.Name = "cmdRemove", ;
		cmdRemoveAll.Name = "cmdRemoveAll", ;
		lstAvailable.Height = 432, ;
		lstAvailable.Left = 0, ;
		lstAvailable.Name = "lstAvailable", ;
		lstAvailable.Top = 0, ;
		lstAvailable.Width = 186, ;
		lstSelected.Height = 432, ;
		lstSelected.Left = 254, ;
		lstSelected.Name = "lstSelected", ;
		lstSelected.Top = 0, ;
		lstSelected.Width = 186
		*< END OBJECT: ClassLib="..\..\3rdparty\stonefield9\sfcommon\sfmover.vcx" BaseClass="container" />

	ADD OBJECT 'txtImportName' AS txttextboxcustom WITH ;
		ControlSource = "importmap.cimportname", ;
		Height = 20, ;
		Left = 120, ;
		Name = "txtImportName", ;
		TabIndex = 3, ;
		Top = 9, ;
		Width = 324
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE addrequired
		LOCAL llReturn, lnI, loAvailable, loError, loSelected
		
		llReturn = .T.
		
		TRY
		
		    loAvailable = THISFORM.sfmoverlist1.lstavailable
		    loSelected  = THISFORM.sfmoverlist1.lstSelected
		
		    swselect('importdefs')
		    SCAN FOR cType = THISFORM.ImportType AND 'REQUIRED' $ UPPER(colddesc)
		        SCATTER MEMVAR
		* Disable the items added.
		        FOR lnI = 1 TO loAvailable.LISTCOUNT
		            IF loAvailable.LIST[lnI] = ALLTRIM(importdefs.cdescript)
		                loSelected.ADDITEM(importdefs.cdescript)
		                THISFORM.sfmoverlist1.AfterAddItem(lnI, loSelected.NEWINDEX)
		                loSelected.SELECTED[loSelected.NewIndex] = .T.
		                loAvailable.LIST[lnI]                    = '\' + loAvailable.LIST[lnI]
		                loAvailable.SELECTED[lnI]                = .F.
		                * Put this here because this method gets called before aItems is setup
		                TRY 
		                   loAvailable.aItems[lnI]                  = .T.
		                CATCH
		                ENDTRY 
		            ENDIF
		        ENDFOR
		    ENDSCAN
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'AddRequired', loError.LINENO, 'ImportExp_map', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the map at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE buildtemplate
		LOCAL lcCaptions, lcTable, llReturn, lnLen, lnReturn, loError
		*:Global tcType, x
		llReturn = .T.
		
		TRY
		    STORE '' TO lcCaptions, lcName, lcTable
		
		    IF m.goApp.lCloudServer
		       lcFilename = 'S:\Template_Bills.csv'
		    ELSE 
		       lcFilename = 'datafiles\Template_' + 'Bills.csv'
		    ENDIF    
		    swselect('importmap')
		    LOCATE FOR cType = 'EXP' AND cImportName = ALLTRIM(THISFORM.ImportName)
		    IF FOUND()
		        IF MESSAGEBOX('Do you want a template based on your import map? Otherwise a template will be created for all fields available to import for this file.', 36, 'Template Type') = 6
		            lnDefMax = ALINES(laFields, mfields)
		            FOR lnx = 1 TO lnDefMax
		                lcCaptions = lcCaptions + laFields[lnx] + ','
		            ENDFOR
		        ELSE
		           lcCaptions = 'Invoice Number, Invoice Date, Due Date, Well ID, Well Name, Exp Code, Exp Description, Exp Amount, Prod Year, Prod Period, Dept, Alloc All To, Account'
		        ENDIF
		     ELSE
		        lcCaptions = 'Invoice Number, Invoice Date, Due Date, Well ID, Well Name, Exp Code, Exp Description, Exp Amount, Prod Year, Prod Period, Dept, Alloc All To, Account'
		     ENDIF 
		    
		    IF RIGHT(ALLTRIM(lcCaptions), 1) = ','
		        lnLen      = LEN(ALLTRIM(lcCaptions))
		        lcCaptions = SUBSTR(lcCaptions, 1, lnLen - 1)
		    ENDIF
		           
		    SET SAFETY OFF 
		    lnReturn = STRTOFILE(lcCaptions, lcFilename, 0)
		    SET SAFETY ON 
		    MESSAGEBOX('A template named: ' + lcFilename + ' was created for you. It will now be opened. Click OK to continue.', 64, 'Template Created')
		
		    ViewDocument(lcFilename)
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'Template', loError.LINENO, 'ImportExp_Map', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the template at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE disableavailable
		LOCAL loAvailable, loSelected
		
		loAvailable = THISFORM.sfmoverlist1.lstAvailable
		loSelected  = THISFORM.sfmoverlist1.lstSelected
		
		FOR lnx = 1 TO loSelected.LISTCOUNT
		    lcItem = loSelected.LIST[lnx]
		    IF 'UNUSED' $ UPPER(lcItem)
		       LOOP
		    ENDIF 
		    FOR lny = 1 TO loAvailable.LISTCOUNT
		        IF loAvailable.LIST[lny] = lcItem
		            loAvailable.LIST[lny] = '\' + lcItem
		            EXIT
		        ENDIF
		    ENDFOR
		ENDFOR
	ENDPROC

	PROCEDURE Init
		LPARAMETERS tcName
		LOCAL llReturn, lnCount
		
		IF DODEFAULT()
		
		    thisform.ImportName = tcName
		    thisform.ImportType = 'EXP'
		    thisform.ResetDefs(.f.)
		
		ENDIF
	ENDPROC

	PROCEDURE list
		LPARAMETERS cworkarea
		
		LOCAL lcList
		PRIV llOK
		
		TRY
		    llOK = .T.
		
		* Make sure the files are still open
		    swselect('importmap')
		
		    lcList = 'cimportname'
		
		    DO FORM picklist WITH 'importmap', lcList, 'iimportmap', 1
		
		    IF llOK
		 
		        THISFORM.txtimportName.VALUE = importmap.cimportname
		        THISFORM.cmdatamanager.afternav('Importmap')
		        THISFORM.REFRESH()
		    ENDIF
		CATCH TO loError
		    llOK = .F.
		    DO errorlog WITH 'List', loError.LINENO, 'ImportMap', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import mapping at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llOK
	ENDPROC

	PROCEDURE loadavailable		&& Loads the list of available fields to choose from for imports.
		LOCAL loAvailable, lnCount
		
		loAvailable = THISFORM.sfmoverlist1.lstAvailable
		loavailable.clear()
		IF loAvailable.LISTCOUNT = 0
		    loAvailable.ADDLISTITEM('----------',1)
		    lnCount = 2
		    swselect('importdefs')
		    SET ORDER to cdesc
		    SCAN FOR cType = 'EXP'
		        loAvailable.ADDLISTITEM(importdefs.cDescript, lnCount)
		        lnCount = lnCount + 1
		    ENDSCAN
		    loAvailable.AddListItem('Unused',lnCount)
		ENDIF
	ENDPROC

	PROCEDURE lookupoper
	ENDPROC

	PROCEDURE refreshform
		with This
			.LockScreen = .T.
			.Refresh()
			.LockScreen = .F.
		endwith
	ENDPROC

	PROCEDURE resetdefs
		LPARAMETERS tlFullReset
		
		swselect('importdefs')
		COUNT FOR NOT DELETED() TO lnRecs
		IF tlFullReset OR lnRecs = 0
		    WAIT WINDOW NOWAIT 'Reseting Import Definitions..Getting the Latest...Please Wait...'
		    SELECT importdefs
		    DELETE ALL
		    DO CASE
		        CASE m.goApp.lAMVersion
		            llReturn = get_importdefs('AM')
		        CASE m.goApp.lQBVersion
		            llReturn = get_importdefs('DMIE')
		        OTHERWISE
		            llReturn = get_importdefs('DM')
		    ENDCASE
		    TABLEUPDATE(.t.,.t.,'Importdefs')
		    thisform.chkReset.Value = .f.
		    WAIT WINDOW NOWAIT 'Import Definition Reset Complete'
		    WAIT clear 
		ENDIF
		
		
		SELECT importmap
		SET FILTER TO cType = ALLTRIM('EXP')
		COUNT FOR cType = ALLTRIM('EXP') TO lnCount
		IF lnCount = 0
		    THISFORM.new()
		ELSE
		    LOCATE FOR cimportname = ALLT(THISFORM.ImportName)
		    IF NOT FOUND()
		        GO BOTT
		        GO TOP
		    ENDIF
		* Call afternav so that it can use the parameter.
		* Afternav is called originally before the init fires
		* which is before we've seen what parameters was passed.
		    THISFORM.cmDataManager.AfterNav('Importmap')
		ENDIF
	ENDPROC

	PROCEDURE setstate		&& Method to set the form as edited so the save button enables.
		this.lChanged = .T.
		m.goStateManager.RefreshAll('Form Edit')
	ENDPROC

	PROCEDURE chkReset.Click
		IF this.Value
		   thisform.ResetDefs(.t.)
		ENDIF 
	ENDPROC

	PROCEDURE cmdatamanager.afternav
		LPARAMETERS cWorkarea
		LOCAL loSelected, loAvailable
		LOCAL laFields[1], lcItem, lioperator, lnLines, lnx, lny
		
		loAvailable = THISFORM.sfmoverlist1.lstAVAILABLE
		loSelected  = THISFORM.sfmoverlist1.lsTSELECTED
		
		IF cWorkarea = 'Importmap'
		    loSelected.clear()
		    SELECT importmap
		    lnLines = ALINES(laFields, mfields)
		    FOR lnx = 1 TO lnLines
		        loSelected.ADDLISTITEM(laFields[lnx], lnx)
		    ENDFOR
		    movercols(loSelected)
		* Disable selected items from the available list
		    thisform.LoadAvailable()
		    thisform.DisableAvailable()
		ENDIF
	ENDPROC

	PROCEDURE cmdatamanager.afternew
		LPARAMETERS cWorkarea
		
		thisform.sfmoverlist1.lstAVAILABLE.Clear()
		thisform.sfmoverlist1.lstSELECTED.Clear()
		thisform.txtImportName.Value = ''
		thisform.LoadAvailable()
		thisform.AddRequired()
		
		SELECT (cworkarea)
		REPLACE ctype WITH 'EXP'
		
		thisform.Refresh()
		
	ENDPROC

	PROCEDURE cmdatamanager.afterupdate
		LPARAMETERS cWorkareaList, lCurrentRecordOnly
		
		swselect('importmap')
		IF this.isnew('Importmap')
		   REPLACE cAddedBy WITH m.goApp.cuser, ;
		           dAdded   WITH DATETIME()
		ELSE
		   REPLACE cChangedBy WITH m.goApp.cUser, ;
		           dChanged   WITH DATETIME()
		ENDIF            
		        
		TABLEUPDATE()
		
	ENDPROC

	PROCEDURE Cmdcommandbuttoncustom1.Click
		m.gostatemanager.openform('importexplain.scx','EXP')
	ENDPROC

	PROCEDURE cmdTemplate.Click
		IF MESSAGEBOX('Do you want to save changes before building the template?',36,'Build Template') = 6
		   thisform.save()
		ENDIF 
		thisform.BuildTemplate()
	ENDPROC

	PROCEDURE Sfmoverlist1.addavailablefromselected
		lparameters tnSelectedItem
		
		IF DODEFAULT(tnSelectedItem)
		   thisform.SetState()
		ENDIF 
	ENDPROC

	PROCEDURE Sfmoverlist1.addselected
		* Add all selected items in the available list to the selected list.
		
		local loAvailable, ;
			loSelected, ;
			llFirst, ;
			lnIndex, ;
			lnI, ;
			lnJ
		Thisform.LockScreen = .T.
		with This
			loAvailable = .lstAvailable
			loSelected  = .lstSelected
			llFirst     = .T.
			lnIndex     = 0
			.lAnyAvailable = .F.
		
		* Loop throught the selected items in the available list (DO WHILE is used
		* instead of FOR because items may be removed from the available list as we
		* go). Add the selected items to the selected list.
		
			lnI = 1
			do while lnI <= loAvailable.ListCount
				if loAvailable.Selected[lnI]
		
		* If this was the first selected one, deselect all the items in the selected
		* list.
		
					if llFirst
						for lnJ = 1 to loSelected.ListCount
							loSelected.Selected[lnJ] = .F.
						next lnJ
						llFirst = .F.
					endif llFirst
		
		* Add the item to the selected list and select it.
		
					loSelected.AddItem(loAvailable.List[lnI])
					.AfterAddItem(lnI, loSelected.NewIndex)
					loSelected.Selected[loSelected.NewIndex] = .T.
		
		* If items are to be removed from the available list, do so. Otherwise, disable
		* the items.
		
					if .lRemoveFromAvailable
						lnIndex = loAvailable.ListIndex
						loAvailable.RemoveItem(lnI)
						lnIndex = min(lnIndex, loAvailable.ListCount)
					ELSE
					    IF NOT 'UNUSED' $ UPPER(loAvailable.List[lnI])
		   				   loAvailable.List[lnI] = '\' + loAvailable.List[lnI]
						   loAvailable.Selected[lnI] = .F.
						   loAvailable.aItems[lnI]   = .T.
						ENDIF    
		 		        lnI = lnI + 1				
					endif .lRemoveFromAvailable
				else
					if not .lRemoveFromAvailable and not loAvailable.aItems[lnI]
						.lAnyAvailable = .T.
					endif not .lRemoveFromAvailable ...
					lnI = lnI + 1
				endif loAvailable.Selected[lnI]
			enddo while lnI <= loAvailable.ListCount
		
		* Set the list index of the selected list to the last one added and refresh
		* the controls.
		
			loSelected.ListIndex = loSelected.NewIndex
			if lnIndex <> 0
				loAvailable.ListIndex = lnIndex
			endif lnIndex <> 0
			.HandleChange(.T.)
			.Refresh()
		endwith
		Thisform.LockScreen = .F.
		
	ENDPROC

	PROCEDURE Sfmoverlist1.handlechange
		LPARAMETERS tlAdd,  tlAll
		LOCAL lcFields
		
		IF DODEFAULT(tlAdd, tlAll)
		    lcFields = ''
		    
		    MOVERCOLS(thisform.sfmoverlist1.lstselected)
		    
		    FOR lnx = 1 TO THISFORM.sfmoverlist1.lstsELECTED.LISTCOUNT
		        lcFields = lcFields + SUBSTR(thisform.sfMoverlist1.lstselected.List[lnx], ;
		                                     AT('- ',thisform.sfMoverlist1.lstselected.List[lnx])+2) + ;
		                 CHR(10)
		    ENDFOR
		
		    IF THISFORM.sfmoverlist1.lstsELECTED.LISTCOUNT > 0
		        SELECT importmap
		        thisform.cmdatamanager.replace('Importmap','Ctype','EXP')
		        thisform.cmdatamanager.replace('Importmap','mFields',lcFields)
		    ENDIF
		    THISFORM.SetState()
		ENDIF
	ENDPROC

	PROCEDURE Sfmoverlist1.lstSelected.DragDrop
		lparameters toSource,  tnXCoord,  tnYCoord
		
		DODEFAULT(toSource,  tnXCoord,  tnYCoord)
		
		movercols(this)
		
		thisform.SetState()
		
	ENDPROC

	PROCEDURE Sfmoverlist1.lstSelected.InteractiveChange
		IF DODEFAULT()
		   lcFields = ''
		
		    MOVERCOLS(thisform.sfmoverlist1.lstselected)
		    
		    FOR lnx = 1 TO THISFORM.sfmoverlist1.lstsELECTED.LISTCOUNT
		        lcFields = lcFields + SUBSTR(THISFORM.sfmoverlist1.lstsELECTED.LIST[lnx],;
		                                     AT('- ',THISFORM.sfmoverlist1.lstsELECTED.LIST[lnx])+2) + CHR(10)
		    ENDFOR
		
		    IF THISFORM.sfmoverlist1.lstsELECTED.LISTCOUNT > 0
		        SELECT importmap
		        thisform.cmdatamanager.replace('Importmap','Ctype','EXP')
		        thisform.cmdatamanager.replace('Importmap','mFields',lcFields)
		    ENDIF
		    THISFORM.SetState()
		ENDIF     
	ENDPROC

ENDDEFINE
