*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="fileconvert.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 526
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 579

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "suspense", ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 425, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formfileconvert AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shpshapecustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shpshapecustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shpshapecustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cntgetfile2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdConvert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboComps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cntgetfile1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDMQBLocate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblAMLocate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDMLocate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chklChecks" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: convert		&& Converts the given data files
		*m: convertsuspense
		*m: countrecs		&& Counts the records to be converted.
		*m: oldcomp		&& Opens old company master file
	*</DefinedPropArrayMethod>

	Caption = "Convert Previous Version Data Files"
	DataSession = 2
	DoCreate = .T.
	Height = 496
	HelpContextID = 309
	Name = "FormFileconvert"
	Width = 543
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cboComps' AS cbocomboboxcustom WITH ;
		Enabled = .F., ;
		Height = 20, ;
		Left = 70, ;
		Name = "cboComps", ;
		TabIndex = 6, ;
		Top = 209, ;
		Width = 372, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chklChecks' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Copy Check Formats from Previous Version (Recommended)", ;
		Left = 116, ;
		Name = "chklChecks", ;
		TabIndex = 10, ;
		Top = 423, ;
		Value = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Cancel", ;
		Height = 36, ;
		Left = 294, ;
		Name = "cmdCancel", ;
		TabIndex = 12, ;
		Top = 452, ;
		Width = 75, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdConvert' AS cmdcommandbuttoncustom WITH ;
		Caption = "Con\<vert", ;
		Height = 36, ;
		Left = 174, ;
		Name = "cmdConvert", ;
		TabIndex = 11, ;
		Top = 452, ;
		Width = 75, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cntgetfile1' AS cntgetfile WITH ;
		Height = 22, ;
		Left = 70, ;
		lfullpath = .T., ;
		lmustexist = .T., ;
		lpathonly = .T., ;
		Name = "Cntgetfile1", ;
		TabIndex = 3, ;
		Top = 91, ;
		Width = 403, ;
		ZOrderSet = 7, ;
		CMDPATH.FontBold = .T., ;
		CMDPATH.Height = 20, ;
		CMDPATH.Left = 381, ;
		CMDPATH.Name = "CMDPATH", ;
		CMDPATH.Top = 0, ;
		edtPath.Height = 21, ;
		edtPath.Left = 0, ;
		edtPath.Margin = 1, ;
		edtPath.Name = "edtPath", ;
		edtPath.SelectOnEntry = .T., ;
		edtPath.Top = 0, ;
		edtPath.Width = 372
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="container" />

	ADD OBJECT 'Cntgetfile2' AS cntgetfile WITH ;
		Height = 22, ;
		Left = 70, ;
		lfullpath = .T., ;
		lmustexist = .F., ;
		lpathonly = .T., ;
		Name = "Cntgetfile2", ;
		TabIndex = 9, ;
		Top = 365, ;
		Width = 405, ;
		ZOrderSet = 3, ;
		CMDPATH.FontBold = .T., ;
		CMDPATH.Height = 20, ;
		CMDPATH.Left = 381, ;
		CMDPATH.Name = "CMDPATH", ;
		CMDPATH.Top = 0, ;
		edtPath.Height = 21, ;
		edtPath.Margin = 1, ;
		edtPath.Name = "edtPath", ;
		edtPath.SelectOnEntry = .T., ;
		edtPath.Width = 372
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="container" />

	ADD OBJECT 'lblAMLocate' AS lbllabelcustom WITH ;
		AutoSize = .F., ;
		Caption = "This will most commonly be an \Accounting Manager Pro or \AMPro folder.  If installed on a network, this folder may be on a server.  The chosen folder MUST contain a COMPMAST.DBF file.", ;
		Height = 30, ;
		Left = 24, ;
		Name = "lblAMLocate", ;
		TabIndex = 2, ;
		Top = 24, ;
		Width = 482, ;
		WordWrap = .T., ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDMLocate' AS lbllabelcustom WITH ;
		AutoSize = .F., ;
		Caption = "This will most commonly be a \Disbursement Manager Pro or \DMPro folder.  If installed on a network, this folder may be on a server.  The chosen folder MUST contain a COMPMAST.DBF file.", ;
		Height = 30, ;
		Left = 24, ;
		Name = "lblDMLocate", ;
		TabIndex = 2, ;
		Top = 24, ;
		Width = 482, ;
		WordWrap = .T., ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDMQBLocate' AS lbllabelcustom WITH ;
		AutoSize = .F., ;
		Caption = "This will most commonly be a \DMPro2002 or \DMPro2004 folder.  If installed on a network, this folder may be on a server.  The chosen folder MUST contain a COMPMAST.DBF file.", ;
		Height = 30, ;
		Left = 24, ;
		Name = "lblDMQBLocate", ;
		TabIndex = 2, ;
		Top = 24, ;
		Width = 486, ;
		WordWrap = .T., ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Step 3:  Select the location for the new files", ;
		FontBold = .T., ;
		FontSize = 9, ;
		Left = 19, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 7, ;
		Top = 259, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "It is recommended to use the default path generated by the software.  If installing on a network, be sure the path for the new data is accessible to all workstations that will be accessing the software.", ;
		Height = 30, ;
		Left = 24, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 8, ;
		Top = 325, ;
		Width = 484, ;
		WordWrap = .T., ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Step 2:  Select the company to be converted", ;
		FontBold = .T., ;
		FontSize = 9, ;
		Left = 19, ;
		Name = "Lbllabelcustom3", ;
		TabIndex = 4, ;
		Top = 141, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom4' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Step 1:  Locate where the old version is installed", ;
		FontBold = .T., ;
		FontSize = 9, ;
		Left = 19, ;
		Name = "Lbllabelcustom4", ;
		TabIndex = 1, ;
		Top = 5, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom6' AS lbllabelcustom WITH ;
		Caption = "The list of available companies shown below is based on the companies that are defined in the folder selected in Step 1.  Make sure no other users are in the old software when trying to convert.", ;
		Height = 44, ;
		Left = 24, ;
		Name = "Lbllabelcustom6", ;
		TabIndex = 5, ;
		Top = 160, ;
		Width = 459, ;
		WordWrap = .T., ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom7' AS lbllabelcustom WITH ;
		Caption = "The old data will be copied to this new folder, before being updated to the current version of the software.  The old data will remain unchanged.  If there are files already in the new location, they will be replaced.", ;
		Height = 44, ;
		Left = 24, ;
		Name = "Lbllabelcustom7", ;
		TabIndex = 8, ;
		Top = 278, ;
		Width = 464, ;
		WordWrap = .T., ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom8' AS lbllabelcustom WITH ;
		Caption = "To speed up conversions of larger data, choose to Reindex and Pack the files in the old software first.  This can be done under the Utilites Menu, with the options for All Tables and Pack marked.", ;
		Height = 30, ;
		Left = 24, ;
		Name = "Lbllabelcustom8", ;
		TabIndex = 2, ;
		Top = 56, ;
		Width = 470, ;
		WordWrap = .T., ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Shpshapecustom1' AS shpshapecustom WITH ;
		BackStyle = 0, ;
		Height = 116, ;
		Left = 13, ;
		Name = "Shpshapecustom1", ;
		Top = 12, ;
		Width = 516, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'Shpshapecustom2' AS shpshapecustom WITH ;
		BackStyle = 0, ;
		Height = 102, ;
		Left = 13, ;
		Name = "Shpshapecustom2", ;
		Top = 148, ;
		Width = 516, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'Shpshapecustom3' AS shpshapecustom WITH ;
		BackStyle = 0, ;
		Height = 136, ;
		Left = 13, ;
		Name = "Shpshapecustom3", ;
		Top = 266, ;
		Width = 516, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />
	
	PROCEDURE convert		&& Converts the given data files
		LOCAL lcOldPath, lcNewPath, lcOldCidComp, lcIDComp, lnCount, lcDataPath, oRegistry, oMessage, llTwoLines
		LOCAL oProgress, oProgress1
		
		DO CLOSECOMP WITH .T.
		m.goapp.closealldata()
		
		oRegistry = findglobalobject('cmRegistry')
		oMessage  = findglobalobject('cmMessage')
		
		SET DELETED ON
		SET SAFETY OFF
		
		lcOldPath         = ALLTRIM(THISFORM.cntgetfile1.edtPath.VALUE)
		lcNewPath         = ALLTRIM(THISFORM.cntgetfile2.edtPath.VALUE)
		lcOldCidComp      = THIS.cboComps.LISTITEM(THIS.cboComps.LISTITEMID,3)
		llCopyChecks      = THISFORM.chklChecks.VALUE
		
		STORE .F. TO llTwoLines  &&  Setting for the enhanced check stub.  Since the field name changes between the old/new versions, we have to store the value separately.
		
		IF EMPTY(lcOldPath)
		   THISFORM.oMessage.Warning('Please select a folder where the old version of the software is installed.')
		   THISFORM.setnextcontrol(THISFORM.cntgetfile1.edtPath)
		   RETURN .F.
		ENDIF
		
		IF EMPTY(lcOldCidComp)
		   THISFORM.oMessage.Warning('Please select a company to be converted.')
		   THISFORM.setnextcontrol(THISFORM.cboComps)
		   RETURN .F.
		ENDIF
		
		IF EMPTY(lcNewPath)
		   THISFORM.oMessage.Warning('Please select a folder where the converted files will be stored.')
		   THISFORM.setnextcontrol(THISFORM.cntgetfile2.edtPath)
		   RETURN .F.
		ENDIF
		
		IF FILE(ALLTRIM(lcNewPath)+'ampro.exe')  &&  Don't let them convert into the install directory
		   THISFORM.oMessage.Warning('The folder you have chosen to convert into appears to be the software installation directory.  Please choose a valid folder to convert into.')
		   THISFORM.setnextcontrol(THISFORM.cntgetfile2.edtPath)
		   RETURN .F.
		ENDIF
		
		lcOldDataFilePath = ALLTRIM(THIS.cboComps.LISTITEM(THIS.cboComps.LISTITEMID,2))
		IF NOT ':' $ lcOldDataFilePath  &&  Fill in full path, if folder only
		   IF NOT LEFT(lcOldDataFilePath,2) = '\\'
		      IF RIGHT(ALLTRIM(lcOldDataFilePath),1) = '\'
		         lnlen = LEN(ALLTRIM(lcOldDataFilePath))
		         lcOldDataFilePath = SUBSTR(lcOldDataFilePath,1,lnlen-1)
		      ENDIF
		      lcOldDataFilePath = ADDBS(ADDBS(lcOldPath) + JUSTSTEM(lcOldDataFilePath))
		   ENDIF
		ENDIF
		
		IF NOT USED('OldComp')
		   USE (lcOldPath+'compmast.dbf') IN 0 ALIAS oldcomp
		ENDIF
		IF NOT USED('compmast')
		   USE datafiles\compmast IN 0
		ENDIF
		
		IF THISFORM.oMessage.CONFIRM('Are you sure you want to convert the files for company: ' + ALLTRIM(THISFORM.cboComps.VALUE)+ '?  Make sure all users are out of the old software.')
		   SELECT oldcomp
		   LOCATE FOR cIDComp == lcOldCidComp
		   IF NOT FOUND()  &&  It better...
		      RETURN
		   ELSE
		      DO CASE
		         CASE m.goapp.lQBVersion
		            IF cVersion < '297'  &&  Version when the ntaxpct stuff was added - the minimum level to convert from - BH 12/19/2006
		               THISFORM.oMessage.Warning('The old company is not at a new enough version to be upgraded.  The minimum version to upgrade is version 2.9.7.')
		               RETURN
		            ENDIF
		         CASE m.goapp.lAMVersion
		            IF cVersion < '546'  &&  Version when the ntaxpct stuff was added - the minimum level to convert from - BH 12/19/2006
		               THISFORM.oMessage.Warning('The old company is not at a new enough version to be upgraded.  The minimum version to upgrade is version 5.4.6.')
		               RETURN
		            ENDIF
		         OTHERWISE
		            IF cVersion < '735'  &&  Version when the ntaxpct stuff was added - the minimum level to convert from - BH 12/19/2006
		               THISFORM.oMessage.Warning('The old company is not at a new enough version to be upgraded.  The minimum version to upgrade is version 7.3.5.')
		               RETURN
		            ENDIF
		      ENDCASE
		   ENDIF
		
		
		   SCATTER MEMVAR
		   m.cDataPath = ALLTRIM(lcNewPath)
		   lcDataPath  = m.cDataPath  &&  Store it as a non-memory variable, so it can be more easily used for macrosubstitution
		
		   STORE '' TO m.XFlag, m.cVersion
		   STORE .T. TO LUPDATE
		
		   SELECT compmast
		   SET DELETED OFF
		   SET ORDER TO cIDComp
		   lcIDComp = oRegistry.IncrementCounter('%Local.Counters.Company Master')
		   DO WHILE SEEK(lcIDComp)
		      lcIDComp = oRegistry.IncrementCounter('%Local.Counters.Company Master')
		   ENDDO
		   SET DELETED ON
		
		   m.cIDComp = lcIDComp
		   m.goapp.cIDComp = lcIDComp
		   m.cVersion = STRTRAN(TRANSFORM(m.goapp.cfileversion),'.','')
		   lcVersion = m.cVersion
		   INSERT INTO compmast FROM MEMVAR
		   SELECT compmast
		   LOCATE FOR cIDComp = m.cIDComp
		
		   IF NOT DIRECTORY("&lcDataPath")
		      MKDIR "&lcDataPath"
		   ENDIF
		
		   IF FILE(lcDataPath+'version.dbf')
		      USE (lcDataPath+'version') IN 0
		      SELECT VERSION
		      GO TOP
		      REPLACE cVersion WITH m.cVersion
		   ELSE
		      SELECT compmast
		      SCATTER MEMVAR
		      lnx=AFIELDS(latemp)
		      lcTable = lcDataPath+'version'
		      CREATE TABLE (lcTable) FREE FROM ARRAY latemp
		      m.cVersion = lcVersion
		      INSERT INTO VERSION FROM MEMVAR
		      USE IN VERSION
		   ENDIF
		
		   m.goapp.ccompanyname = m.cproducer
		
		   IF FILE(m.cDataPath+'afedet.dbf') AND NOT THISFORM.oMessage.CONFIRM('The folder being converted into already contains data files.  They will be replaced by this conversion.  Are you sure you want to continue?')
		      RETURN
		   ENDIF
		
		   * Try to delete the existing files in the new folder
		   TRY
		      ERASE (lcNewPath+'*.*')
		   CATCH
		   ENDTRY
		
		   * Check to see if the old company is in use
		   fh = FOPEN(lcOldDataFilePath+'appdata.dbc')
		   IF fh < 0  &&  Error
		      MESSAGEBOX('There was a sharing violation when trying to copy the old data.  Could not open ' + ;
		         'the main database. Make sure it is not in use, and try converting again.',16,'Error Converting Files')
		      FCLOSE(fh)
		      ERASE (m.goApp.cLocalAppData+'*.loc')
		      IF NOT USED('compmast')
		         USE ('datafiles\compmast') IN 0
		      ENDIF
		      SELECT compmast
		      DELETE FOR cIDComp = lcIDComp
		      FCLOSE(fh)
		      RETURN .F.
		   ENDIF
		   FCLOSE(fh)
		
		   * Update the files to the current version
		   m.goapp.cdatafilepath = lcNewPath
		   m.goapp.updfiles(lcIDComp,.T.)
		
		   lnCount = ADIR(aFiles,lcOldDataFilePath+'*.dbf')  &&  DBF Files first
		
		   IF lnCount > 0
		      oProgress = oMessage.Progressbarex('Converting Files for ' + ALLTRIM(m.cproducer) + '...Please Wait')
		      oProgress.SetProgressRange(0,lnCount)
		
		      FOR lnx = 1 TO ALEN(aFiles,1)
		
		         lcFile     = ALLTRIM(aFiles[lnX,1])
		
		         IF INLIST(lcFile,'SDTMETA','SDTUSER','DBCXREG','COREMETA','COMPMAST','APPREG')
		            LOOP
		         ENDIF
		
		         lcCopyFile = lcOldDataFilePath + lcFile
		         lcNewFile  = lcNewPath + lcFile
		         
		         *  Skip copies, temp files, and suspense backups
		         IF 'COPY OF' $ lcFile OR 'SUSP2' $ lcFile OR 'TEMP' $ lcFile
		            LOOP
		         ENDIF 
		
		         oProgress.UpdateProgress(lnx)
		         oProgress.SetProgressMessage('Copying File: ' + lcFile)
		
		         fh = FOPEN(lcCopyFile)  &&  Attempt to open the file
		         IF fh < 0  &&  Error
		            MESSAGEBOX ('There was a sharing violation when trying to copy the old data.  Could not open file: ' + ;
		               ALLTRIM(lcCopyFile) + ' Make sure it is not in use, and try converting again.',16,'Error Converting Files')
		
		            FCLOSE(fh)
		            ERASE (m.goApp.cLocalAppData+'*.loc')
		            IF NOT USED('compmast')
		               USE ('datafiles\compmast') IN 0
		            ENDIF
		            SELECT compmast
		            DELETE FOR cIDComp = lcIDComp
		            oProgress.CloseProgress()
		            IF VARTYPE(oProgress1) = 'O'
		               oProgress1.CloseProgress()
		            ENDIF
		            RETURN .F.
		         ENDIF
		         llResult = FCLOSE(fh)
		
		         IF 'DISBHIST' $ lcFile
		            oProgress1 = oMessage.Progressbar('Converting owner history file...')
		            lnHistCount = 0
		            llReturn = .F.
		            TRY
		               USE (lcCopyFile) IN 0 SHARED
		            CATCH TO loError
		               IF loError.ERRORNO = 3
		                  MESSAGEBOX('Unable to open the old owner history file. It is currently in use by someone else. Conversion cannot continue.',16,'Conversion Problem')
		               ELSE
		                  MESSAGEBOX('Unable to open the old owner history file. Error #' + loError.ERRORNO,16,'Conversion Problem')
		               ENDIF
		               IF VARTYPE(oProgress) = 'O'
		                  oProgress.CloseProgress()
		               ENDIF
		               IF VARTYPE(oProgress1) = 'O'
		                  oProgress1.CloseProgress()
		               ENDIF
		               llReturn = .T.
		            ENDTRY
		            IF llReturn
		               RETURN .F.
		            ENDIF
		            SELECT disbhist
		            COUNT FOR NOT DELETED() TO lnHistRecs
		            oProgress1.SetProgressRange(0,lnHistRecs)
		            USE (lcNewPath+'ownpcts') IN 0
		            SELECT disbhist
		            SCAN
		               SCATTER MEMVAR
		               oProgress1.UpdateProgress(lnHistCount)
		               lnHistCount = lnHistCount + 1
		               INSERT INTO ownpcts FROM MEMVAR
		            ENDSCAN
		            USE IN disbhist
		            USE IN ownpcts
		            CLOSE DATABASES
		            oProgress1.CloseProgress()
		         ENDIF
		
		         IF 'OPTIONS' $ lcFile
		            TRY
		               USE (lcOldDataFilePath+'OPTIONS') IN 0
		               SELECT options
		               llTwoLines = lAdjMin  &&  Setting for printing enhanced check stub
		               USE IN options
		               CLOSE DATABASES all
		            CATCH
		               llTwoLines = .F.
		               CLOSE DATABASES ALL 
		            ENDTRY
		         ENDIF
		
		         IF FILE(lcCopyFile)
		            COPY FILE (lcCopyFile) TO (lcNewFile)
		         ENDIF
		
		         *  Blank the QB file name in the old version after copying, so even if they open it up, it won't connect
		         IF m.goapp.lQBVersion AND 'GLOPT' $ lcFile
		            TRY
		               USE (lcOldDataFilePath+'GLOPT') IN 0
		               SELECT glopt
		               GO TOP
		               REPLACE cqbfilename WITH ''
		               USE IN glopt
		            CATCH
		               *  If we can't, we can't
		               IF USED('glopt')
		                  USE IN glopt
		               ENDIF 
		            ENDTRY
		         ENDIF
		
		      ENDFOR
		
		      lnCount = ADIR(aFiles,lcOldDataFilePath+'*.FPT')  && FPT Files
		
		      FOR lnx = 1 TO ALEN(aFiles,1)
		
		         lcFile = ALLTRIM(aFiles[lnX,1])
		
		         IF INLIST(lcFile,'SDTMETA','SDTUSER','DBCXREG','COREMETA','COMPMAST','APPREG','COPY OF')
		            LOOP
		         ENDIF
		
		         lcCopyFile = lcOldDataFilePath + lcFile
		         lcNewFile  = lcNewPath + lcFile
		
		         WAIT WINDOW NOWAIT 'Copying File:  ' + lcFile
		
		         fh = FOPEN(lcCopyFile)  &&  Attempt to open the file
		         IF fh < 0  &&  Error
		            MESSAGEBOX ('There was a sharing violation when trying to copy the old data.  Could not open file: ' + ;
		               ALLTRIM(lcCopyFile) + ' Make sure it is not in use, and try converting again.',16,'Error Converting Files')
		
		            FCLOSE(fh)
		            ERASE (m.goApp.cLocalAppData+'*.loc')
		            IF NOT USED('compmast')
		               USE ('datafiles\compmast') IN 0
		            ENDIF
		            SELECT compmast
		            DELETE FOR cIDComp = lcIDComp
		            oProgress.CloseProgress()
		            IF VARTYPE(oProgress1) = 'O'
		               oProgress1.CloseProgress()
		            ENDIF
		            FCLOSE(fh)
		            RETURN .F.
		         ENDIF
		         FCLOSE(fh)
		
		         IF FILE(lcCopyFile)
		            COPY FILE (lcCopyFile) TO (lcNewFile)
		         ENDIF
		
		      ENDFOR
		
		      lnCount = ADIR(aFiles,lcOldDataFilePath+'appreg*.*')  &&  Appreg files
		
		      FOR lnx = 1 TO ALEN(aFiles,1)
		
		         lcFile = ALLTRIM(aFiles[lnX,1])
		         lcCopyFile = lcOldDataFilePath + lcFile
		         lcNewFile  = lcNewPath + lcFile
		
		         WAIT WINDOW NOWAIT 'Copying File:  ' + lcFile
		
		         fh = FOPEN(lcCopyFile)  &&  Attempt to open the file
		         IF fh < 0  &&  Error
		            THISFORM.oMessage.Warning('There was a sharing violation when trying to copy the old data.  Could not open file: ' + ALLTRIM(lcCopyFile) + ' Make sure it is not in use, and try converting again.')
		            FCLOSE(fh)
		            ERASE (m.goApp.cLocalAppData+'*.loc')
		            IF NOT USED('compmast')
		               USE ('datafiles\compmast') IN 0
		            ENDIF
		            SELECT compmast
		            DELETE FOR cIDComp = lcIDComp
		            oProgress.CloseProgress()
		            IF VARTYPE(oProgress1) = 'O'
		               oProgress1.CloseProgress()
		            ENDIF
		            FCLOSE(fh)
		
		            RETURN .F.
		         ENDIF
		         FCLOSE(fh)
		
		         IF FILE(lcCopyFile)
		            COPY FILE (lcCopyFile) TO (lcNewFile)
		         ENDIF
		
		      ENDFOR
		
		      llCheckCopyError = .F.
		
		      IF llCopyChecks  &&  If copying check formats
		         TRY
		            lcChecksFolder = lcOldPath + 'checks'
		            IF DIRECTORY(lcChecksFolder)
		
		               IF DIRECTORY(m.goapp.cChecksFolder)
		                  * Make sure there's a checks folder in the current folder before copying
		                  ERASE m.goapp.cChecksFolder+'*.*'
		
		                  * Copy all the files from the old checks folder to the new checks folder
		                  COPY FILE (lcChecksFolder+'\*.*') TO (m.goapp.cChecksFolder+'*.*')
		
		                  TRY
		                     * Copy in the friendly names
		                     USE chkcopy IN 0
		
		                     lnfiles = ADIR(laChecks,m.goapp.cChecksFolder+'*.frx')
		                     FOR lnx = 1 TO lnfiles
		                        WAIT WINDOW NOWAIT 'Processing check: ' + laChecks[lnx,1]
		                        USE (m.goapp.cChecksFolder+laChecks[lnx,1]) IN 0 ALIAS chk
		
		                        SELECT chkcopy
		                        SCAN FOR NOT EMPTY(EXPR)
		                           m.name = NAME
		                           m.expr = LOWER(EXPR)
		                           SELECT chk
		                           SCAN FOR ALLTRIM(LOWER(m.expr)) $ LOWER(EXPR)
		                              REPLACE NAME WITH m.name
		                           ENDSCAN
		                           * Change the void graphic to protected
		                           * So it doesn't show when the check is modified
		                           SELECT chk
		                           LOCATE FOR objtype = 17
		                           IF FOUND()
		                              REPLACE ORDER WITH ''
		                           ENDIF
		                        ENDSCAN
		                        USE IN chk
		                     ENDFOR
		                     USE IN chkcopy
		                  CATCH TO loError
		                  ENDTRY                  
		               ELSE
		                  THISFORM.oMessage.Warning('The check formats were selected to be copied, but the checks folder to copy into could not be located.  Check formats will need to be manually copied from the old version.')
		               ENDIF
		            ELSE
		               THISFORM.oMessage.Warning('The check formats were selected to be copied, but the checks folder to copy from could not be located.  Check formats will need to be manually copied from the old version.')
		            ENDIF
		         CATCH TO loError
		            llCheckCopyError = .T.
		         FINALLY
		         ENDTRY
		      ENDIF
		
		
		      IF llCheckCopyError
		         MESSAGEBOX('The conversion was unable to copy the check formats from the old location. They will have to be manually copied from ' + ALLTRIM(lcOldPath)+'checks',48,'Check Format Copy Error')
		      ENDIF
		
		      oProgress.CloseProgress()
		
		      WAIT CLEAR
		
		      * Update the files to the current version
		      m.goapp.cdatafilepath = lcNewPath
		      m.goapp.closealldata()
		      OPEN DATABASE (lcNewPath+'appdata.dbc')
		      oMeta.SetDatabase(DBC())
		      m.goapp.updfiles(lcIDComp,.T.)
		      m.goapp.opensdt()
		      OPEN DATABASE (lcNewPath+'appdata.dbc')
		      oMeta.SetDatabase(DBC())
		      oMeta.oSDTMgr.REINDEX('ALL')
		
		      * Convert the susaudit table to tne new suspense table format
		      THISFORM.convertsuspense(lcNewPath)
		
		      THISFORM.oMessage.DISPLAY('The files have been successfully converted.  Please log in to the newly created company.')
		
		      THIS.VISIBLE = .F.
		
		      IF FILE(lcOldPath + 'edit.com') AND NOT FILE('edit.com')
		         lnx = FCREATE(m.goapp.cCommonFolder+'edit.com')
		         FCLOSE(lnx)
		      ENDIF
		
		      * Erase the last open company file
		      ERASE (m.goApp.cLocalAppData+'*.loc')
		      * Create the last open company file
		      IF NOT FILE(m.goapp.cLocalAppData+lcIDComp+'.loc')
		         fh = FCREATE(m.goapp.cLocalAppData+lcIDComp+'.loc')
		         FCLOSE(fh)
		      ENDIF
		
		      * Convert the sevtax records to use whole pcts
		      IF NOT USED('sevtax')
		         USE sevtax IN 0
		      ENDIF
		      SELECT sevtax
		      SCAN
		         IF cmethodbbl1 = 'P'
		            REPLACE nTaxBBL1 WITH nTaxBBL1 * 100
		         ENDIF
		         IF cmethodbbl2 = 'P'
		            REPLACE nTaxBBL2 WITH nTaxBBL2 * 100
		         ENDIF
		         IF cmethodbbl3 = 'P'
		            REPLACE nTaxBBL3 WITH nTaxBBL3 * 100
		         ENDIF
		         IF cmethodbbl4 = 'P'
		            REPLACE nTaxBBL4 WITH nTaxBBL4 * 100
		         ENDIF
		         IF cmethodmcf1 = 'P'
		            REPLACE nTaxMCF1 WITH nTaxMCF1 * 100
		         ENDIF
		         IF cmethodmcf2 = 'P'
		            REPLACE nTaxMCF2 WITH nTaxMCF2 * 100
		         ENDIF
		         IF cmethodmcf3 = 'P'
		            REPLACE nTaxMCF3 WITH nTaxMCF3 * 100
		         ENDIF
		         IF cmethodmcf4 = 'P'
		            REPLACE nTaxMCF4 WITH nTaxMCF4 * 100
		         ENDIF
		         IF cmethodoth1 = 'P'
		            REPLACE ntaxOTH1 WITH ntaxOTH1 * 100
		         ENDIF
		         IF cmethodoth2 = 'P'
		            REPLACE ntaxOTH2 WITH ntaxOTH2 * 100
		         ENDIF
		         IF cmethodoth3 = 'P'
		            REPLACE ntaxOTH3 WITH ntaxOTH3 * 100
		         ENDIF
		         IF cmethodoth4 = 'P'
		            REPLACE ntaxOTH4 WITH ntaxOTH4 * 100
		         ENDIF
		      ENDSCAN
		
		      IF NOT USED('compmast')
		         USE datafiles\compmast IN 0
		      ENDIF
		
		      m.goapp.cIDComp = lcIDComp
		      m.goapp.cdatafilepath = TRIM(compmast.cDataPath)
		      m.goapp.setsearchpath()
		      THIS.RELEASE()
		      m.goapp.opencompany1(.F.)
		      m.goapp.opencompany2()
		
		      IF llTwoLines = .T.  &&  Update the enhanced check stub setting
		         IF NOT USED('options')
		            USE options IN 0
		         ENDIF
		         SELECT options
		         REPLACE lTwoLines WITH .T.
		      ENDIF
		
		      * Mark dummy owners
		      swSELECT('investor')
		      LOCATE FOR ldummy = .T.
		      IF NOT FOUND()
		         WAIT WINDOW NOWAIT 'Performing "Dummy" owner check...'
		         SCAN FOR 'DUMMY' $ UPPER(cownname)
		            REPLACE ldummy WITH .T.
		         ENDSCAN
		         WAIT CLEAR
		      ENDIF
		
		      *  If using the old option for specifying special check file names, we have to copy them to the data folder, rename them as the appropriate LE file name
		      *  and then set their options to use the MICR format.  DM and DMIE only.
		      IF NOT m.goapp.lAMVersion
		         swSELECT('options')
		         GO TOP
		         IF lSpecialChk  &&  They are specifying format names
		            lcOldFormat = options.cdisbchkfmt
		            *  It has a relative path, so it needs to pad it out, so it can be found for copying
		            IF NOT '\\' $ lcOldFormat AND NOT ':' $ lcOldFormat
		               lcOldFormat = ALLTRIM(lcOldPath) + lcOldFormat
		            ENDIF
		            IF NOT EMPTY(lcOldFormat) AND FILE(lcOldFormat)
		               COPY FILE ALLTRIM(SUBSTR(lcOldFormat,1,AT('.',lcOldFormat)-1))+'.*' TO m.goapp.cdatafilepath + 'dmchekle.*'
		               SELECT options
		               REPLACE cchecktype WITH 'LE'
		            ENDIF
		            lcOldAPFormat = options.cvendchkfmt
		            *  It has a relative path, so it needs to pad it out, so it can be found for copying
		            IF NOT '\\' $ lcOldAPFormat AND NOT ':' $ lcOldAPFormat
		               lcOldAPFormat = ALLTRIM(lcOldPath) + lcOldAPFormat
		            ENDIF
		            IF NOT EMPTY(lcOldAPFormat) AND FILE(lcOldAPFormat)
		               COPY FILE ALLTRIM(SUBSTR(lcOldAPFormat,1,AT('.',lcOldAPFormat)-1))+'.*' TO m.goapp.cdatafilepath + 'apchekle.*'
		               swSELECT('apopt')
		               GO TOP
		               REPLACE cchecktype WITH 'LE'
		            ENDIF
		         ENDIF
		      ENDIF
		   ELSE
		      MESSAGEBOX('Unable to find the files to convert in the folder: ' + lcOldDataFilePath + ' Can not continue conversion.',16,'Conversion Problem')
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE convertsuspense
		LPARAMETERS tcNewPath
		LOCAL oProgress, oMessage, lnKey
		**  Scans and sums the current suspense balances for owners, and creates a beginning  **
		**  balance entry for them in the new suspense table                                  **
		
		oMessage = findglobalobject('cmMessage')
		
		SET DELETED ON
		
		IF NOT USED('investor')
		   USE (tcNewPath+'investor') IN 0
		ENDIF
		IF NOT USED('susaudit')
		   USE (tcNewPath+'susaudit') IN 0
		ENDIF
		IF NOT USED('suspense')
		   USE (tcNewPath+'suspense') IN 0
		ENDIF
		IF NOT USED('disbhist')
		   USE (tcNewPath+'disbhist') IN 0
		ENDIF
		IF NOT USED('wellinv')
		   USE (tcNewPath+'wellinv') IN 0
		ENDIF
		IF USED('temp')
		   USE IN temp
		ENDIF
		
		oRegistry = findglobalobject('cmRegistry')
		
		SWSELECT('suspense')
		COUNT FOR NOT DELETED() TO lnSuspCount
		IF lnSuspCount > 0
		   MESSAGEBOX('There are already suspense entries in the new suspense table. No old suspense will be converted.',64,'Suspense Conversion')
		   RETURN
		ENDIF
		
		
		oProgress = oMessage.ProgressBar('Performing First-Time Suspense Balance Calculations...')
		
		* Max progcode, so if they have a mixture of entries that have a progcode and some that are blank, it will always fill in with a code
		SELECT MAX(cYear) AS cYear, 'I' AS cAction, SUM(IIF(cAction='I',nAmount,nAmount*-1)) AS nNetCheck,  ;
		   SUM(IIF(cAction='I',nincome,nincome*-1)) AS nincome,  ;
		   MAX(cRunYear+PADL(TRANSFORM(nRunno),3,'0')) AS cYearRun,  ;
		   MAX(cYear+cPeriod) AS cYearPrd,  ;
		   SUM(IIF(cAction='I',nExpenses,nExpenses*-1)) AS nExpense,  ;
		   SUM(IIF(cAction='I',nTaxwith,nTaxWith*-1)) AS nTaxWith,  ;
		   SUM(IIF(cAction='I',nBackWith,nBackWith*-1)) AS nBackWith,  ;
		   SUM(IIF(cAction='I',nTaxes,nTaxes*-1)) AS nSevTaxes,cSuspType,MAX(cProgCode) AS cProgCode, ;
		   susaudit.cownerid AS cownerid, susaudit.cwellid AS cwellid, ;
		   cGroup, MAX(dSuspDate) AS hDate, ;
		   investor.cownname AS cownname, cTypeInv ;
		   FROM susaudit, investor ;
		   WHERE susaudit.cownerid == investor.cownerid ;
		   ORDER BY susaudit.cownerid, susaudit.cwellid ;
		   GROUP BY susaudit.cownerid, susaudit.cwellid ;
		   INTO CURSOR temp
		
		* Total balance for the owner - don't convert if the total is zero - BH 07/17/2008
		SELECT susaudit.cownerid AS cownerid, SUM(IIF(cAction='I',nAmount,nAmount*-1)) AS nNetCheck,  ;
		   .F. AS junk  ;
		   FROM susaudit  ;
		   ORDER BY susaudit.cownerid  ;
		   GROUP BY susaudit.cownerid  ;
		   INTO CURSOR temp1
		
		*  Make sure there are no screwy interest memvars still floating around that get assigned
		*  to the converted records.
		STORE 0 TO m.nRevOil, m.nRevGas, m.nRevOth, m.nRevTrp, m.nRevMisc1, m.nRevMisc2,  ;
		   m.nWorkInt, m.nIntClass1, m.nIntClass2, m.nIntClass3, m.nIntClass4, m.nIntClass5,  ;
		   m.nACPInt, m.nBCPInt, m.nAPOInt, m.nRevTax1, m.nRevTax2, m.nRevTax3, m.nRevTax4,  ;
		   m.nRevTax5, m.nRevTax6, m.nRevTax7, m.nRevTax8, m.nRevTax9, m.nRevTax10,  ;
		   m.nRevTax11, m.nRevTax12
		
		lnKey = 1
		SELECT temp
		COUNT FOR nNetCheck <> 0 TO lnCount
		oProgress.SetProgressRange(0,lnCount)
		lnTotRecs = 0
		SELECT temp
		SCAN FOR nNetCheck <> 0
		   SCATTER MEMVAR
		   
		   *  Don't care about blank well ID amounts.  Weren't getting processed in the old version, so don't care about them in the new.
		   IF EMPTY(m.cWellID)
		      LOOP
		   ENDIF 
		
		   * Look for a grand total of zero in suspense, and don't convert it.
		   * Balances are often cancelled by another well, and this avoids
		   * converting a positive balance offset by a negative balance in a
		   * different well
		   SELECT temp1
		   LOCATE FOR cownerid == m.cownerid
		   IF nNetCheck = 0  &&  No suspense total
		      LOOP
		   ENDIF
		
		   lnTotRecs = lnTotRecs + 1
		
		   * Variable to tell whether we found an existing suspense balance
		   * to add ALL records to
		   llFound = .F.
		
		   oProgress.updateprogress(lnTotRecs)
		   m.lBegBal = .T.  &&  Beginning balance flag
		
		   * Negative minimum, so make it a deficit
		   IF m.nNetCheck < 0 AND cSuspType = 'M'
		      m.cSuspType = 'D'
		   ENDIF
		
		   * Positive deficit, so make it a minimum
		   IF m.nNetCheck > 0 AND cSuspType = 'D'
		      m.cSuspType = 'M'
		   ENDIF
		   m.cRunYear     = LEFT(m.cYearRun,4)
		   m.nRunno       = VAL(SUBSTR(m.cYearRun,5))
		   m.cRunYear_in  = m.cRunYear
		   m.nRunno_in    = m.nRunno
		   m.cRecType     = 'R'
		   m.lManual      = .T.
		   m.hYear        = LEFT(m.cYearPrd,4)
		   m.hPeriod      = RIGHT(ALLTRIM(m.cYearPrd),2)
		   m.cTypeInt     = 'B'
		   m.cDirect      = 'N'  &&  Initial value to use, before trying to match it up better below
		   
		   * Set the interest on hold flag if the interest is on hold
		   IF m.cSuspType = 'I'
		      m.lOnHold = .T.
		   ELSE
		      m.lOnHold = .F.
		   ENDIF 
		   
		   * Set the owner on hold flag if the interest is on hold
		   IF m.cSuspType = 'H'
		      m.lHold = .T.
		   ELSE
		      m.lHold = .F.
		   ENDIF 
		
		   * Change all empty groups to use group '00'
		   IF EMPTY(m.cGroup)
		      m.cGroup = '00'
		   ENDIF
		   
		   *  Find a wellinv record to determine the DP setting for this owner/well/interest type.  
		   swselect('wellinv')
		   LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeinv = m.cTypeInv
		   IF FOUND()
		      m.cDirect = wellinv.cDirect
		      *  Assign the lJIB memvar, but make sure that no royalty owners can be marked as .t.
		      m.lJIB = wellinv.lJIB  
		      IF m.cTypeInv <> 'W'
		         m.lJIB = .f.
		      ENDIF 
		   ELSE  &&  Rats - no match, so we'll try and find something in disbhist for this owner/well/interest type.
		      swselect('disbhist')
		      LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeinv = m.cTypeInv
		      IF FOUND()
		         m.cDirect = disbhist.cDirect
		      ENDIF
		   ENDIF 
		
		   * Plug in a valid owner type for suspense records that don't have one
		   IF NOT INLIST(m.cTypeInv,'L','O','W')
		      SWSELECT('wellinv')
		      LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid
		      IF FOUND()
		         m.cTypeInv = cTypeInv
		      ELSE
		         * Just assign it something valid
		         m.cTypeInv = 'W'
		      ENDIF
		   ENDIF
		
		   * Plug in a valid well id for suspense records that have a well id of 'ALL'
		   IF m.cwellid = 'ALL '
		      SELECT cwellid FROM wellinv WHERE cOwnerID == m.cOwnerID  ;
		         AND cwellid IN(SELECT cwellid FROM wells WHERE cGroup = m.cGroup)  ;
		         INTO CURSOR tempall  ;
		         GROUP BY wellinv.cwellid
		      IF _TALLY > 0
		         SELECT tempall
		         GO TOP
		         m.cwellid = tempall.cwellid
		      ELSE
		         SWSELECT('wellinv')
		         LOCATE FOR cownerid == m.cownerid AND cTypeInv == m.cTypeInv
		         IF FOUND()
		            m.cwellid = cwellid
		         ELSE
		            * If no current interests, find some well to assign to it, to avoid leaving the ALL well ID on it
		            SWSELECT('susaudit')
		            LOCATE FOR cownerid == m.cownerid AND cTypeInv == m.cTypeInv AND cwellid <> 'ALL '
		            IF FOUND()
		               m.cwellid = cwellid
		            ELSE
		               * If we can't find a matching owner type for this owner, find ANY suspense record, and use that well ID.
		               * Pretty desperate by this point.
		               LOCATE FOR cownerid == m.cownerid AND cwellid <> 'ALL '
		               IF FOUND()
		                  m.cwellid = cwellid
		               ELSE
		                  SELECT disbhist  &&  One last-ditch attempt
		                  LOCATE FOR cownerid == m.cownerid
		                  IF FOUND()
		                     m.cwellid = cwellid
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		
		      * Add to an existing record for this owner and well, if there is one
		      SELECT suspense
		      LOCATE FOR cwellid == m.cwellid AND cownerid == m.cownerid AND cTypeInv == m.cTypeInv
		      IF FOUND()
		         REPLACE nNetCheck WITH nNetCheck + m.nNetCheck, nincome WITH nincome + m.nincome,  ;
		            nExpense WITH nExpense + m.nExpense, nGasRev WITH nGasRev + m.nGasRev, nSevTaxes WITH nSevTaxes + m.nSevTaxes
		         llFound = .T.
		      ENDIF
		   ENDIF
		
		   m.nGasRev = m.nincome
		   STORE 0 TO m.nOilRev, m.ncompress, m.ngather, m.nOilTax1, m.nOilTax2, m.nOilTax3, m.nOilTax4, m.nGasTax1, m.nGasTax2,  ;
		      m.nGasTax3, m.nGasTax4, m.nOthTax1, m.nOthTax2, m.nOthTax3, m.nOthTax4
		
		
		   m.ciddisb = '@' + PADL(TRANSFORM(lnKey),7,'0')
		   lnKey = lnKey + 1
		
		   IF NOT llFound
		      INSERT INTO suspense FROM MEMVAR
		   ENDIF
		ENDSCAN
		
		SELECT suspense
		SCAN FOR lManual AND cRecType <> 'P'
		   WAIT WINDOW NOWAIT 'Adjusting owner: ' + suspense.cownerid + ' suspense income and expense totals...'
		   IF nGasRev - nExpense - nSevTaxes <> nNetCheck
		      IF nExpense < 0
		         m.nExpense = ABS(nNetCheck + nSevTaxes - nGasRev)
		         REPLACE nExpense WITH m.nExpense
		      ELSE
		         m.nGasRev = nNetCheck + nSevTaxes + nExpense
		         REPLACE nGasRev WITH m.nGasRev, ;
		            nincome WITH m.nGasRev
		      ENDIF
		   ENDIF
		ENDSCAN
		
		oProgress.CloseProgress()
		WAIT CLEAR
		
		
		
	ENDPROC

	PROCEDURE countrecs		&& Counts the records to be converted.
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		
		IF nerror = 1707
		   llOK = .F.
		ENDIF
		
		DODEFAULT(nerror,cmethod,nline)   
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		
		DO CASE
		   CASE m.goapp.lQBVersion  &&  DMIE
		      THISFORM.lblAMLocate.VISIBLE = .F.
		      THISFORM.lblDMQBLocate.VISIBLE = .T.
		      THISFORM.lblDMLocate.VISIBLE = .F.
		   CASE m.goapp.lAMVersion  &&  AMPRO
		      THISFORM.lblAMLocate.VISIBLE = .T.
		      THISFORM.lblDMLocate.VISIBLE = .F.
		      THISFORM.lblDMQBLocate.VISIBLE = .F.
		   OTHERWISE  &&  DMPRO
		      THISFORM.lblAMLocate.VISIBLE = .F.
		      THISFORM.lblDMLocate.VISIBLE = .T.
		      THISFORM.lblDMQBLocate.VISIBLE = .F.
		ENDCASE
		
	ENDPROC

	PROCEDURE oldcomp		&& Opens old company master file
	ENDPROC

	PROCEDURE cboComps.Valid
		LOCAL lcFile, lcValue
		
		DODEFAULT()
		
		lcValue = ALLTRIM(this.ListItem(this.ListItemId,2))
		
		IF AT('\',lcValue,2) = 0  &&  Just a folder for the data file path
		   lcFile = LOWER(ALLTRIM(CURDIR()) + 'DataFiles\'+lcValue)
		ELSE  &&  Not just a folder name, so count back to the 2nd slash from the right to get the folder name
		   lcFile = LOWER(ALLTRIM(CURDIR()) + 'DataFiles\'+SUBSTR(lcValue,RAT('\',lcValue,2)+1))
		ENDIF
		
		THISFORM.cntgetfile2.edtpath.VALUE = lcFile
		THISFORM.cntgetfile2.edtpath.REFRESH()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdConvert.Click
		thisform.convert()
	ENDPROC

	PROCEDURE Cntgetfile1.CMDPATH.Click
		LOCAL lcDir
		
		lcDir = CURDIR()
		
		CD \
		
		DODEFAULT()
		
		CD "&lcDir"
		
		thisform.cboComps.set('enabled',.t.)
		this.Parent.edtPath.SetFocus()
	ENDPROC

	PROCEDURE Cntgetfile1.CMDPATH.When
		RETURN MDOWN()  
	ENDPROC

	PROCEDURE Cntgetfile1.edtPath.GotFocus
		ON KEY label F2 _screen.ActiveForm.cntGetFile1.cmdPath.click()
		
		DODEFAULT()
	ENDPROC

	PROCEDURE Cntgetfile1.edtPath.LostFocus
		LOCAL lcPath
		
		ON KEY label F2
		
		lcPath = THIS.VALUE
		
		IF EMPTY(lcPath)
		   thisform.cboComps.set('value','')
		   thisform.cboComps.set('Enabled',.f.)
		   RETURN
		ENDIF
		
		IF USED('oldcomp')
		   USE IN oldcomp
		ENDIF
		
		FOR lnX = 1 TO thisform.cboComps.ListCount
		   thisform.cbocomps.RemoveListItem(lnX)
		ENDFOR
		
		IF FILE(lcPath+'compmast.dbf')
		   thisform.cboComps.set('Enabled',.t.)
		   USE (lcPath+'compmast.dbf') IN 0 ALIAS oldcomp
		   SELECT cProducer, cDataPath, cidcomp FROM oldcomp WHERE NOT EMPTY(cProducer) INTO ARRAY laComps ORDER BY cProducer
		   IF _TALLY > 0
		      FOR lnX = 1 TO _TALLY
		         THISFORM.cboComps.ADDLISTITEM(laComps[lnX,1],lnX,1)
		         THISFORM.cboComps.ADDLISTITEM(laComps[lnX,2],lnX,2)
		         THISFORM.cboComps.ADDLISTITEM(laComps[lnX,3],lnX,3)
		         
		         IF (LEFT(laComps[lnX,2],1) = '\' AND LEFT(thisform.cboComps.ListItem(lnX,2),1) <> '\') OR (LEFT(laComps[lnX,2],2) = '\\' AND LEFT(thisform.cboComps.ListItem(lnX,2),2) <> '\\')
		            thisform.cboComps.ListItem(lnX,2) = '\\' + thisform.cboComps.ListItem(lnX,2)            
		         endif
		      ENDFOR
		   ELSE
		      THISFORM.cboComps.ADDLISTITEM('No Companies Found',1,1)
		      THISFORM.cboComps.ADDLISTITEM('',1,2)
		      THISFORM.cboComps.ADDLISTITEM('',1,3)
		   ENDIF
		ELSE
		   thisform.oMessage.Warning('The selected folder does not appear to be a valid installation directory.  Please choose a folder containing COMPMAST.DBF.')
		   thisform.cboComps.set('Enabled',.f.)
		   this.set('value','')
		   thisform.setnextcontrol(this)
		ENDIF
		
		* THISFORM.cboComps.LISTITEMID = 1
		THISFORM.cboComps.REFRESH()
		
	ENDPROC

	PROCEDURE Cntgetfile1.edtPath.Valid
		IF ALLTRIM(this.Value) = CURDIR()  &&  Don't let them pick the current directory as the folder to convert from
		   thisform.oMessage.Warning('You have chosen the folder for this installation of the software.  You must select a folder where the old version of the software is installed.')
		   RETURN 0
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE Cntgetfile2.CMDPATH.When
		RETURN MDOWN()  
	ENDPROC

	PROCEDURE Cntgetfile2.edtPath.GotFocus
		ON KEY label F2 _screen.ActiveForm.cntGetFile2.cmdPath.click()
		
		DODEFAULT()
	ENDPROC

	PROCEDURE Cntgetfile2.edtPath.LostFocus
		ON KEY LABEL F2
		
		DODEFAULT()
	ENDPROC

ENDDEFINE
