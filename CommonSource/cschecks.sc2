*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cschecks.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor20" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor21" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor23" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor24" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor28" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor30" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor31" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor32" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor33" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor34" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor38" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor27" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor39" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor40" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 1054
	Left = 42
	Name = "Dataenvironment"
	Top = 57
	Width = 1124

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "apopt", ;
		CursorSource = "apopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 123, ;
		Left = 9, ;
		Name = "Cursor1", ;
		Top = 15, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "expense", ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 840, ;
		Name = "Cursor11", ;
		Top = 380, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "disbhist", ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor12", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "income", ;
		CursorSource = "income", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 710, ;
		Name = "Cursor13", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 850, ;
		Name = "Cursor14", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 302, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor20' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 710, ;
		Name = "Cursor20", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor21' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 850, ;
		Name = "Cursor21", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor23' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor23", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor24' AS cursor WITH ;
		Alias = "wellhist", ;
		CursorSource = "wellhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor24", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor27' AS cursor WITH ;
		Alias = "expcat", ;
		CursorSource = "expcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 433, ;
		Name = "Cursor27", ;
		Top = 631, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor28' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 100, ;
		Left = 431, ;
		Name = "Cursor28", ;
		Top = 8, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor30' AS cursor WITH ;
		Alias = "landopt", ;
		CursorSource = "landopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor30", ;
		Top = 500, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor31' AS cursor WITH ;
		Alias = "landhist", ;
		CursorSource = "landhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 433, ;
		Name = "Cursor31", ;
		Top = 514, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor32' AS cursor WITH ;
		Alias = "land", ;
		CursorSource = "land", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 411, ;
		Name = "Cursor32", ;
		Top = 168, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor33' AS cursor WITH ;
		Alias = "landowner", ;
		CursorSource = "landowner", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 574, ;
		Name = "Cursor33", ;
		Top = 515, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor34' AS cursor WITH ;
		Alias = "programs", ;
		CursorSource = "programs", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 710, ;
		Name = "Cursor34", ;
		Top = 500, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor38' AS cursor WITH ;
		Alias = "revsrc", ;
		CursorSource = "revsrc", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 293, ;
		Name = "Cursor38", ;
		Top = 636, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor39' AS cursor WITH ;
		Alias = "groups", ;
		CursorSource = "groups", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 574, ;
		Name = "Cursor39", ;
		Top = 640, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Filter = "NOT DELETED()", ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor40' AS cursor WITH ;
		Alias = "wellinv", ;
		CursorSource = "wellinv", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 706, ;
		Name = "Cursor40", ;
		Top = 636, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "appurchh", ;
		CursorSource = "appurchh", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 710, ;
		Name = "Cursor6", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "appurchd", ;
		CursorSource = "appurchd", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 850, ;
		Name = "Cursor7", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formcschecks AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblCheckCount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtAcctDesc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboSelect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkPreview" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAlign" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgCheckType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCheckType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCashAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkZipCode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcbegcheckno" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Qbaccount1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: countchecks		&& Returns a count of the checks to be printed.
		*m: loadcursor		&& Loads the selected checks into the pickchk cursor.
		*m: oldstubdm
		*m: printchecks		&& Prints the selected checks
		*m: printregister		&& Prints the check register
		*m: printwhenfix
		*m: selectallchecks		&& Selects All Check To Print
		*m: send_to_printer
		*m: stubap		&& A/P Check Stub Processing
		*m: stubapcf		&& A/P Custom Stub Processing
		*m: stubdm		&& Disb Mgr Stub Processing
		*m: stubdmcf		&& Disb Mgr Custom Stub Processing
		*m: stublm		&& Land Manager Check Stub
		*m: stubpr		&& Payroll Stub Processing
		*m: stubprog		&& Stub for program distributions
		*m: updatereg		&& Updates the check register with check numbers printed.
		*p: corder		&& Order the checks should be printed in
		*p: creportname
		*p: laskok
		*p: ncheckcount		&& The count of checks to print of the currently selected type in the currently selected account.
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Print Checks"
	corder = CIDCHEC		&& Order the checks should be printed in
	creportname = .F.
	DataSession = 2
	DoCreate = .T.
	Height = 287
	HelpContextID = 118
	laskok = .F.
	Name = "formcschecks"
	Width = 489
	_memberdata = <VFPData>
		<memberdata name="corder" display="cOrder"/>
		</VFPData>		&& XML Metadata for customizable properties
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cboAcct' AS cbocomboboxcustom WITH ;
		BoundColumn = 1, ;
		ColumnCount = 2, ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 116, ;
		Name = "cboAcct", ;
		TabIndex = 3, ;
		Top = 129, ;
		Width = 71, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboSelect' AS cbocomboboxcustom WITH ;
		Height = 20, ;
		Left = 116, ;
		Name = "cboSelect", ;
		RowSource = "All Checks,Selected Checks", ;
		RowSourceType = 1, ;
		TabIndex = 5, ;
		Top = 163, ;
		Width = 133, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkPreview' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Preview", ;
		Left = 144, ;
		Name = "chkPreview", ;
		TabIndex = 8, ;
		Top = 206, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkZipCode' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Print by Zip Code", ;
		Left = 264, ;
		Name = "chkZipCode", ;
		TabIndex = 9, ;
		Top = 206, ;
		Value = .F., ;
		Visible = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdAlign' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Alignment", ;
		Height = 36, ;
		Left = 202, ;
		Name = "cmdAlign", ;
		TabIndex = 11, ;
		Top = 241, ;
		Width = 84, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdCancel' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Cancel", ;
		Height = 36, ;
		Left = 298, ;
		Name = "cmdCancel", ;
		TabIndex = 12, ;
		Top = 240, ;
		Width = 84, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Print", ;
		Height = 36, ;
		Left = 106, ;
		Name = "cmdPrint", ;
		TabIndex = 10, ;
		Top = 241, ;
		Width = 84, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblCashAcct' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Checking Account:", ;
		Height = 16, ;
		Left = 14, ;
		Name = "lblCashAcct", ;
		TabIndex = 15, ;
		Top = 132, ;
		Width = 93, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCheckCount' AS lbllabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "XXX Checks To Print", ;
		FontBold = .T., ;
		Height = 16, ;
		Left = 279, ;
		Name = "lblCheckCount", ;
		TabIndex = 2, ;
		Top = 47, ;
		Width = 114, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCheckType' AS lbllabelcustom WITH ;
		Caption = "Check Type:", ;
		Height = 16, ;
		Left = 48, ;
		Name = "lblCheckType", ;
		TabIndex = 13, ;
		Top = 10, ;
		Width = 62, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Print:", ;
		Left = 81, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 14, ;
		Top = 165, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Beg Check No:", ;
		Height = 16, ;
		Left = 285, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 7, ;
		Top = 165, ;
		Width = 73, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'opgCheckType' AS opgoptiongroupcustom WITH ;
		AutoSize = .T., ;
		BorderStyle = 0, ;
		ButtonCount = 5, ;
		Height = 110, ;
		Left = 116, ;
		Name = "opgCheckType", ;
		TabIndex = 1, ;
		Top = 2, ;
		Width = 107, ;
		ZOrderSet = 10, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Owner Checks", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Owner", ;
		Option1.Top = 5, ;
		Option1.Width = 91, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Payroll Checks", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 5, ;
		Option2.Name = "Payroll", ;
		Option2.TabIndex = 4, ;
		Option2.Top = 68, ;
		Option2.Width = 89, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "Vendor Checks", ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 5, ;
		Option3.Name = "Vendor", ;
		Option3.TabIndex = 2, ;
		Option3.Top = 26, ;
		Option3.Width = 93, ;
		Option4.AutoSize = .T., ;
		Option4.Caption = "Land Checks", ;
		Option4.FontSize = 8, ;
		Option4.Height = 16, ;
		Option4.Left = 5, ;
		Option4.Name = "Land", ;
		Option4.TabIndex = 3, ;
		Option4.Top = 47, ;
		Option4.Width = 81, ;
		Option5.AutoSize = .T., ;
		Option5.Caption = "Program Checks", ;
		Option5.FontSize = 8, ;
		Option5.Height = 16, ;
		Option5.Left = 5, ;
		Option5.Name = "Program", ;
		Option5.Top = 89, ;
		Option5.Width = 97
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'Qbaccount1' AS qbaccount WITH ;
		lbankonly = .T., ;
		Left = 116, ;
		Name = "Qbaccount1", ;
		TabIndex = 4, ;
		Top = 129, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'txtAcctDesc' AS txttextboxcustom WITH ;
		ControlSource = " ", ;
		Height = 20, ;
		Left = 198, ;
		lreadonly = .T., ;
		Name = "txtAcctDesc", ;
		TabIndex = 4, ;
		Top = 129, ;
		Width = 276, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcbegcheckno' AS txttextboxcustom WITH ;
		Height = 20, ;
		Left = 360, ;
		MaxLength = 10, ;
		Name = "txtcbegcheckno", ;
		TabIndex = 6, ;
		Top = 163, ;
		Width = 107
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE countchecks		&& Returns a count of the checks to be printed.
		LPARA tcChkType, tcAcctNo
		LOCAL lnChecks
		LOCAL llReturn, loError
		
		llReturn = .T.
		
		TRY
		   SET DELETED ON
		
		   lnChecks = 0
		
		   SWSELECT('checks', .T.)
		   SET FILTER TO
		
		   IF m.goApp.lAMVersion OR m.goApp.lQBVersion
		      DO CASE
		         CASE tcChkType = 'DM'
					SELECT  * ;
						FROM checks ;
						WHERE EMPTY(cCheckno) ;
							AND NOT lPrinted  ;
							AND cIdType <> 'D' ;
							AND cIdType <> 'V' ;
							AND cSource = 'DM' ;
							AND lVoid = .F.  ;
							AND lHist = .F. ;
							AND cAcctNo = tcAcctNo ;
						INTO CURSOR temp
		            lnChecks = _TALLY
		         CASE tcChkType = 'PR'
		            COUNT ALL ;
		               FOR (EMPTY(cCheckno)) ;
		               AND NOT lPrinted  ;
		               AND cIdType <> 'D' ;
		               AND cSource = 'PR' ;
		               AND lVoid = .F.  ;
		               AND lHist = .F. ;
		               AND cAcctNo = tcAcctNo TO lnChecks
		         CASE tcChkType = 'AP'
		            COUNT ALL ;
		               FOR (EMPTY(cCheckno)) ;
		               AND NOT lPrinted  ;
		               AND cIdType <> 'D' ;
		               AND (INLIST(cSource, 'AP', 'CS', 'CD') OR (cSource = 'DM' AND cIdType = 'V')) ;
		               AND lVoid = .F.  ;
		               AND lHist = .F. ;
		               AND cAcctNo = tcAcctNo TO lnChecks
		         CASE tcChkType = 'LM'
		            COUNT ALL ;
		               FOR (EMPTY(cCheckno)) ;
		               AND NOT lPrinted  ;
		               AND cIdType <> 'D' ;
		               AND cSource = 'LM' ;
		               AND lVoid = .F.  ;
		               AND lHist = .F. ;
		               AND cAcctNo = tcAcctNo TO lnChecks
		
		         CASE tcChkType = 'PD'
		            COUNT ALL ;
		               FOR (EMPTY(cCheckno)) ;
		               AND NOT lPrinted  ;
		               AND cIdType <> 'D' ;
		               AND cSource = 'PD' ;
		               AND lVoid = .F.  ;
		               AND lHist = .F. ;
		               AND cAcctNo = tcAcctNo TO lnChecks
		      ENDCASE
		   ELSE
		      DO CASE
		         CASE tcChkType = 'DM'
		            COUNT ALL ;
		               FOR EMPTY(cCheckno) ;
		               AND NOT lPrinted  ;
		               AND cIdType <> 'D' ;
		               AND cIdType <> 'V'  ;
		               AND cSource = 'DM' ;
		               AND lVoid = .F.  ;
		               AND lHist <> .T. TO lnChecks
		         CASE tcChkType = 'AP'
		            COUNT ALL ;
		               FOR EMPTY(cCheckno) ;
		               AND NOT lPrinted  ;
		               AND cIdType = 'V' ;
		               AND lVoid = .F.  ;
		               AND lHist <> .T. TO lnChecks
		         CASE tcChkType = 'LM'
		            COUNT ALL ;
		               FOR (EMPTY(cCheckno)) ;
		               AND NOT lPrinted  ;
		               AND cIdType <> 'D' ;
		               AND cSource = 'LM' ;
		               AND lVoid = .F.  ;
		               AND lHist <> .T. TO lnChecks
		         CASE tcChkType = 'PD'
		            COUNT ALL ;
		               FOR (EMPTY(cCheckno)) ;
		               AND NOT lPrinted  ;
		               AND cIdType <> 'D' ;
		               AND cSource = 'PD' ;
		               AND lVoid = .F.  ;
		               AND lHist = .F. TO lnChecks
		      ENDCASE
		   ENDIF
		
		   THISFORM.nCheckCount           = lnChecks
		   THISFORM.lblCheckCount.CAPTION = ALLTRIM(STR(lnChecks)) + ' Checks To Print'
		   THISFORM.lblCheckCount.REFRESH()
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'CountChecks', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the checks at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		 
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   ON KEY LABEL ctrl+a
		   ON KEY LABEL ctrl+p
		   ON KEY LABEL F10
		   ON KEY LABEL F2
		   THIS.oRegistry = FindGlobalObject('cmRegistry')
		   lcAcctNo = THISFORM.cboAcct.VALUE
		
		   * Set up what is displayed depending on which application is running
		   * and get the next
		   IF m.goApp.lAMVersion
		      SWSELECT('coa',.t.)
		      SET ORDER TO acctno
		      IF SEEK(lcAcctNo)
		         IF NOT EMPTY(coa.ccheckno)
		            THISFORM.txtcBegCheckNo.VALUE = coa.ccheckno
		            THISFORM.txtcBegCheckNo.REFRESH()
		         ENDIF
		         IF SEEK(THISFORM.cboAcct.VALUE)
		            THISFORM.txtAcctDesc.VALUE = cAcctDesc
		         ENDIF
		      ENDIF
		
		      THIS.opgCheckType.Payroll.VISIBLE = .T.
		      THIS.opgCheckType.Program.VISIBLE = .T.
		      THIS.opgCheckType.Land.VISIBLE = .T.
		      
		      THIS.lblCashAcct.VISIBLE = .T.
		      THIS.cboAcct.VISIBLE     = .T.
		      THIS.txtAcctDesc.VISIBLE = .T.
		      this.qbaccount1.Visible  = .F.
		      SWSELECT('propt')
		   ELSE
		      THIS.opgCheckType.Payroll.VISIBLE = .F.
		      THIS.opgCheckType.Program.VISIBLE = .F.
		      THIS.opgCheckType.Land.VISIBLE = .T.
		      
		      THIS.lblCashAcct.VISIBLE = .F.
		      THIS.cboAcct.VISIBLE     = .F.
		      THIS.txtAcctDesc.VISIBLE = .F.
		
		      SWSELECT('options')
		      GO TOP
		      IF NOT EMPTY(options.ccheckno)
		         THISFORM.txtcBegCheckNo.VALUE = options.ccheckno
		         THISFORM.txtcBegCheckNo.REFRESH()
		      ENDIF
		
		      IF m.goApp.lQBVersion
		         this.qbaccount1.Visible = .T.
		         this.opgCheckType.land.Visible = .f.
		         lcDisbAcct = cDisbAcct
		         THISFORM.qbaccount1.VALUE = lcDisbAcct
		         THISFORM.countchecks('DM',lcDisbAcct)
		         IF NOT m.goApp.oQB.lqbactive
		            THISFORM.qbaccount1.VISIBLE = .F.
		            THISFORM.lblCashAcct.CAPTION = 'QuickBooks Link Not Active'
		            thisform.lblcashAcct.FontBold = .t.
		            thisform.lblcashAcct.ForeColor = RGB(255,0,0)
		            THISFORM.lblCashAcct.LEFT = 116
		         ELSE
		            THISFORM.qbaccount1.VISIBLE = .T.
		            THISFORM.lblCashAcct.CAPTION = 'Bank Account'
		            THISFORM.lblCashAcct.LEFT = 28
		            thisform.lblcashAcct.FontBold = .t.
		            thisform.lblcashAcct.ForeColor = RGB(0,0,0)
		         ENDIF
		      ENDIF
		   ENDIF
		
		   IF EMPTY(THISFORM.txtcBegCheckNo.VALUE)
		      THISFORM.txtcBegCheckNo.SET('value','100000')
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Load
		IF DODEFAULT()
		   *  Get the cursor of QuickBooks Accounts
		   IF m.goapp.lqbversion
		      IF m.goapp.oQB.lqbactive  &&  Only do if a connection to QB is active
		         m.goapp.oQB.QBAccounts('',.F.,.T.,THISFORM.DATASESSIONID)
		      ENDIF
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE loadcursor		&& Loads the selected checks into the pickchk cursor.
		*
		*  Loads the pickchks cursor with the selected checks
		*
		
		llReturn = .T.
		
		TRY 
		CREATE CURSOR pickchks ;
		  (cid        C(10), ;
		   cidtype    C(1), ;
		   cpayee     C(60), ;
		   cpayee2    C(60), ;
		   cyear      C(4), ;
		   dCheckDate D, ;
		   cperiod    C(2), ;
		   namount    N(12,2), ;
		   chosen     C(1), ;
		   ccheckno   C(10), ;
		   cmemo      C(60), ;
		   lprinted   L, ;
		   cidchec    C(8), ;
		   csource    C(2), ;
		   cgroup     C(2), ;
		   cbatch     C(8), ;
		   lNoStub    L, ;
		   czipcode   c(10), ;
		   cvoid      C(1))
		
		SELECT picktmp
		lcOrder = ORDER('picktmp')
		SET ORDER TO 0
		SCAN FOR chosen = 'Y'
		   SCATTER MEMVAR
		   INSERT INTO pickchks FROM MEMVAR
		ENDSCAN
		
		SELECT pickchks   
		INDEX on cidchec TAG cidchec
		INDEX ON cid +DTOS(dcheckdate) TAG cid   
		INDEX on cpayee+DTOS(dcheckdate) TAG cpayee
		INDEX on DTOS(dcheckdate) TAG dcheckdate
		INDEX on cyear+cperiod+DTOS(dcheckdate) TAG cyearprd
		INDEX on namount TAG namount
		INDEX on cgroup+DTOS(dcheckdate)+cid TAG cgroup
		INDEX on czipcode + cID TAG zipcode
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'LoadCursor', loError.LineNo, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10)+CHR(10) + ;
		              'Contact SherWare Support for help at support@sherware.com',16,'Problem Encountered')
		ENDTRY 
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE oldstubdm
	ENDPROC

	PROCEDURE printchecks		&& Prints the selected checks
		LPARA tcChkType
		
		LOCAL  mword, mword2, lnFirstChk, m.checkno, lcChkType, lcChkForm, lcAcctNo
		LOCAL  lcCheckNo, lnLastChk, llEsc, m.routeno, m.transitno, m.onus, llCheckNames
		LOCAL  lcAPCheckName, lcDMCheckName, lcPRCheckName, lcLMCheckName, llNoFirstName
		LOCAL  llVoidNext, lcResult
		LOCAL lNoStub, lcAPName, lcCheckName, lcDMName, lcFirstChk, lcLMName, lcLastChk, lcMsg, lcOrder
		LOCAL lcPDCheckName, lcPRName, lcTitle, llPreview, llReturn, loError
		*:Global cMEMO, cProducer, caddr1, caddr2, caddr3, ccheckno, count, cpayee, cpayee2, cwordnum
		*:Global czipcode, gcPath, onus, paddr1, paddr2, paddr3, pcontact, pphone, ptax, routno, transitno
		
		llReturn = .T.
		
		TRY
		
		    llPreview  = THISFORM.chkPreview.VALUE
		
		    lcFirstChk = THISFORM.txtcBegCheckNo.VALUE
		    lcCheckNo  = lcFirstChk
		
		    llCommonMICR = FILE(m.goapp.cCommonFolder+'commonmicr.txt')
		
		    IF EMPTY(lcFirstChk)
		        THISFORM.omessage.warning('Please specify a beginning check number.')
		        llReturn = .F.
		        EXIT
		    ENDIF
		
		    STORE .F. TO llEsc, llNoFirstName, llVoidNext
		    STORE ' ' TO m.routno, m.transitno, m.onus
		    STORE '' TO lcAPName, lcDMName, lcPRName, lcLMName, lcResult
		
		*  Check to see if the check names were specified
		    SWSELECT('glopt')
		    GO TOP
		    llCheckNames = lCheckNames
		
		*  Get the cash account
		    lcAcctNo = THISFORM.cboAcct.VALUE
		
		*  Get the check names
		    IF llCheckNames
		        IF m.goapp.lAMVersion
		            SWSELECT('coa', .T.)
		            SET ORDER TO acctno
		            IF SEEK(lcAcctNo)
		                lcAPCheckName = cAPCheckName
		                lcDMCheckName = cDMCheckName
		                lcPRCheckName = cPRCheckName
		                lcLMCheckName = cLMCheckName
		            ENDIF
		        ELSE
		            STORE ' ' TO lcAPCheckName, lcDMCheckName, lcPRCheckName, lcLMCheckName, lcPDCheckName
		        ENDIF
		    ENDIF
		
		*  Get the type of check
		    DO CASE
		        CASE tcChkType = 'AP'
		            SWSELECT('apopt')
		            IF EMPTY(cCheckType)  &&  No check format selected, so warn them
		                THISFORM.omessage.warning('No check format selected.  Please select the A/P Check Format on the Check Printing section of the Edit >> Preferences screen before printing this type of check.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		            DO buildcheckv WITH .T., 'AP'  &&  Add void graphic to formats
		            SELECT apopt
		            lcChkForm   = 'A' + cCheckType
		            lcCheckName = lcAPCheckName
		            llVoidNext  = lVoidNext
		        CASE tcChkType = 'DM'
		            SWSELECT('options')
		            IF EMPTY(cCheckType)  &&  No check format selected, so warn them
		                THISFORM.omessage.warning('No check format selected.  Please select the Rev Dist Check Format on the Check Printing section of the Edit >> Preferences screen before printing this type of check.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		            DO buildcheckv WITH .T., 'DM'  &&  Add void graphic to formats
		            SELECT options
		            IF options.lTwoLines
		                lcChkForm = 'DLVE'
		            ELSE
		                lcChkForm = 'D' + cCheckType
		            ENDIF
		            llNoFirstName = lNoFirstName
		            llVoidNext    = lVoidNext
		            lcCheckName   = lcDMCheckName
		        CASE tcChkType = 'PR'
		            SWSELECT('propt')
		            IF EMPTY(cCheckType)  &&  No check format selected, so warn them
		                THISFORM.omessage.warning('No check format selected.  Please select the Payroll Check Format on the Check Printing section of the Edit >> Preferences screen before printing this type of check.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		            lcChkForm   = 'PR' + cCheckType
		            lcCheckName = lcPRCheckName
		        CASE tcChkType = 'LM'
		            SWSELECT('landopt')
		            IF EMPTY(cCheckType)  &&  No check format selected, so warn them
		                THISFORM.omessage.warning('No check format selected.  Please select the Delay Rental Check Format on the Check Printing section of the Edit >> Preferences screen before printing this type of check.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		            lcChkForm   = 'L' + cCheckType
		            lcCheckName = lcLMCheckName
		        CASE tcChkType = 'PD'
		            SWSELECT('progopt')
		            IF EMPTY(cCheckType)  &&  No check format selected, so warn them
		                THISFORM.omessage.warning('No check format selected.  Please select the Program Check Format on the Check Printing section of the Edit >> Preferences screen before printing this type of check.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		            lcChkForm   = 'PD' + cCheckType
		            lcCheckName = m.goapp.cChecksFolder + 'pdcheklv.frx'
		    ENDCASE
		
		*
		*  Get the company's address for printing MICR checks
		*
		    IF TYPE('m.goApp') = 'O'
		        m.cProducer = m.goapp.ccompanyname
		        m.paddr1    = m.goapp.cAddress1
		        m.paddr2    = m.goapp.cAddress2
		        m.paddr3    = m.goapp.cAddress3
		        m.ptax      = m.goapp.cTaxid
		        m.pcontact  = m.goapp.cContact
		        m.pphone    = m.goapp.cPhoneNo
		    ELSE
		        m.cProducer = 'SherWare, Inc.'
		        m.paddr1    = 'PO Box 209'
		        m.paddr2    = 'Apple Creek, OH 44606'
		        m.paddr3    = ''
		        m.ptax      = '12-34567'
		        m.pcontact  = 'Phil'
		        m.pphone    = '(330) 682-5882'
		    ENDIF
		
		    IF NOT m.goapp.lAMVersion AND tcChkType = 'AP'
		        SWSELECT('options')
		        lcChkForm = 'A' + cCheckType
		    ENDIF
		
		    CREATE CURSOR checktmp ;
		        (cID         C(10),    ;
		        cidtype     C(1),     ;
		        ccheckno    C(10),    ;
		        cyear       C(4),     ;
		        cperiod     C(2),     ;
		        dcheckdate  d,        ;
		        cpayee      C(60),    ;
		        cpayee2     C(60),    ;
		        namount     N(12, 2),  ;
		        cwordnum    C(100),   ;
		        caddr1      C(40),    ;
		        caddr2      C(40),    ;
		        caddr3      C(40),    ;
		        czipcode    C(10),    ;
		        cMEMO       C(60),    ;
		        cSource     C(2),     ;
		        cidchec     C(8),     ;
		        lNoStub     L,        ;
		        nCount      N(3, 0),   ;
		        cGROUP      C(2), ;
		        cbankname   C(60), ;
		        onus        C(15), ;
		        transitno   C(15), ;
		        csigfile    V(254))
		
		    m.count  = 0
		
		* Override the order if the zipcode checkbox is enabled
		    IF THISFORM.chkzipCode.VALUE = .T.
		        THISFORM.cOrder = 'zipcode'
		    ENDIF
		
		    WAIT WIND NOWAIT 'Building stub work files....'
		    SELECT pickchks
		    SET ORDER TO THISFORM.cOrder
		    SCAN
		        SCATTER MEMVAR
		        STORE ' ' TO m.caddr1, m.caddr2, m.caddr3
		        DO CASE
		            CASE tcChkType = 'AP'  && Vendor checks or checks that were cash disbursements
		                SWSELECT('apopt')
		                lcChkForm = 'A' + cCheckType
		                IF NOT EMPTY(m.cID)
		                    SWSELECT('vendor')
		                    SET ORDER TO cvendorid
		                    IF SEEK(m.cID)
		                        IF EMPTY(cbaddr1) AND EMPTY(cbaddr2) AND EMPTY(cbcity) AND EMPTY(cbzip) AND EMPTY(cbstate) &&  If billing address is blank, use the mailing address
		                            m.caddr1 = cAddress1
		                            IF EMPTY(cAddress2)
		                                m.caddr2 = ALLTRIM(ccity) + '  ' + ALLTRIM(cstate) + ;
		                                    '  ' + ALLTRIM(czip)
		                                m.caddr3 = ' '
		                            ELSE
		                                m.caddr2 = cAddress2
		                                m.caddr3  = ALLTRIM(ccity) + '  ' + ALLTRIM(cstate) + ;
		                                    '  ' + ALLTRIM(czip)
		                            ENDIF
		                        ELSE  &&  If billing address is filled in
		                            m.caddr1  = cbaddr1
		                            IF EMPTY(cbaddr2)
		                                m.caddr2 = ALLTRIM(cbcity) + '  ' + ALLTRIM(cbstate) + ;
		                                    '  ' + ALLTRIM(cbzip)
		                                m.caddr3 = ' '
		                            ELSE
		                                m.caddr2 = cbaddr2
		                                m.caddr3  = ALLTRIM(cbcity) + '  ' + ALLTRIM(cbstate) + ;
		                                    '  ' + ALLTRIM(cbzip)
		                            ENDIF
		                        ENDIF
		                        IF NOT EMPTY(vendor.cchkmemo)
		                            m.cMEMO = vendor.cchkmemo
		                        ENDIF
		                    ELSE  &&  Look through owner file for a match
		                        SWSELECT('investor')
		                        SET ORDER TO cOwnerID
		                        llNoFirstName = .T.
		                        IF SEEK(m.cID)
		                            IF investor.lChkToSec OR investor.lCheckOnly
		                                IF llNoFirstName
		                                    m.cpayee  = cownname2
		                                    m.cpayee2 = ''
		                                ELSE
		                                    m.cpayee  = cownname
		                                    m.cpayee2 = cownname2
		                                ENDIF
		                                m.caddr1 = caddress2a
		                                IF EMPTY(caddress2b)
		                                    m.caddr2 = ALLTRIM(ccity2) + '  ' + cstate2 + ' ' + czip2
		                                    m.caddr3 = ' '
		                                ELSE
		                                    m.caddr2 = caddress2b
		                                    m.caddr3 = ALLTRIM(ccity2) + '  ' + cstate2 + ' ' + czip2
		                                ENDIF
		                                IF EMPTY(m.cMEMO)
		                                    m.cMEMO = investor.cchkmemo2
		                                ENDIF
		                            ELSE
		                                m.cpayee  = cownname
		                                m.cpayee2 = cownname1
		                                m.caddr1  = caddress1a
		                                IF EMPTY(caddress1b)
		                                    m.caddr2 = ALLTRIM(ccity1) + '  ' + cstate1 + ' ' + czip1
		                                    m.caddr3 = ' '
		                                ELSE
		                                    m.caddr2 = caddress1b
		                                    m.caddr3 = ALLTRIM(ccity1) + '  ' + cstate1 + ' ' + czip1
		                                ENDIF
		                                IF EMPTY(m.cMEMO)
		                                    m.cMEMO = investor.cchkmemo1
		                                ENDIF
		                            ENDIF
		                        ELSE  &&  No owner or vendor matches, so try customers
		                            IF m.goapp.lAMVersion
		                                SWSELECT('custs')
		                                SET ORDER TO ccustid
		                                IF SEEK(m.cID)
		                                    m.cpayee  = cCustName
		                                    m.cpayee2 = ''
		                                    m.cMEMO   = ''
		                                    m.caddr1  = cbaddr1
		                                    IF EMPTY(cbaddr2)
		                                        m.caddr2 = ALLTRIM(cbcity) + '  ' + cbstate + ' ' + cbzip
		                                        m.caddr3 = ' '
		                                    ELSE
		                                        m.caddr2 = cbaddr2
		                                        m.caddr3 = ALLTRIM(cbcity) + '  ' + cbstate + ' ' + cbzip
		                                    ENDIF
		                                ELSE  &&  Not a vendor, owner, or customer, so try employees
		                                    SWSELECT('emps')
		                                    SET ORDER TO cempid
		                                    IF SEEK(m.cID)
		                                        m.cpayee  = ALLTRIM(cFirstName) + ' ' + ALLTRIM(cMidInit) + ' ' + cLastName
		                                        m.cpayee2 = ''
		                                        m.cMEMO   = ''
		                                        m.caddr1  = cAddress
		                                        m.caddr2  = ALLTRIM(ccity) + '  ' + cstate + ' ' + czipcode
		                                        m.caddr3  = ' '
		                                    ELSE  &&  Last chance - if not a vendor, owner, customer, or employee, try purchasers
		                                        SWSELECT('revsrc')
		                                        SET ORDER TO crevkey
		                                        IF SEEK(m.cID)
		                                            m.cpayee  = cRevName
		                                            m.cpayee2 = ''
		                                            m.cMEMO   = ''
		                                            m.caddr1  = cAddress1
		                                            m.caddr2  = cAddress2
		                                            m.caddr3  = cAddress3
		                                        ELSE  &&  No matches anywhere, so no address info
		                                            m.cpayee2 = ''
		                                            m.cMEMO   = ''
		                                            m.caddr1  = ''
		                                            m.caddr2  = ''
		                                            m.caddr3  = ''
		                                        ENDIF
		                                    ENDIF
		                                ENDIF
		                            ELSE
		                                m.cpayee2 = ''
		                                m.cMEMO   = ''
		                                m.caddr1  = ''
		                                m.caddr2  = ''
		                                m.caddr3  = ''
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ELSE
		                    SWSELECT('othnames')
		                    SET ORDER TO cname
		                    IF SEEK(TRIM(UPPER(m.cpayee)))
		                        SCATTER MEMVAR
		                    ENDIF
		                ENDIF
		            CASE tcChkType = 'DM' OR tcChkType = 'PD'
		* Don't try to print any checks other than owner checks
		                IF m.cidtype <> 'I'
		                    LOOP
		                ENDIF
		                SWSELECT('investor')
		                SET ORDER TO cOwnerID
		                IF SEEK(m.cID)
		                    m.lNoStub = lnostubdetail
		                    SELE pickchks
		                    REPL lNoStub WITH m.lNoStub
		                    SWSELECT('investor')
		                    IF investor.lChkToSec OR investor.lCheckOnly
		                        IF llNoFirstName
		                            m.cpayee  = cownname2
		                            m.cpayee2 = ''
		                        ELSE
		                            m.cpayee2 = cownname2
		                        ENDIF
		                        m.caddr1   = caddress2a
		                        m.czipcode = czip2
		                        IF EMPTY(caddress2b)
		                            m.caddr2 = ALLTRIM(ccity2) + '  ' + cstate2 + ' ' + czip2
		                            m.caddr3 = ' '
		                        ELSE
		                            m.caddr2 = caddress2b
		                            m.caddr3 = ALLTRIM(ccity2) + '  ' + cstate2 + ' ' + czip2
		                        ENDIF
		                        IF EMPTY(m.cMEMO)
		                            m.cMEMO = investor.cchkmemo2
		                        ENDIF
		                    ELSE
		                        m.cpayee2  = cownname1
		                        m.caddr1   = caddress1a
		                        m.czipcode = czip1
		                        IF EMPTY(caddress1b)
		                            m.caddr2 = ALLTRIM(ccity1) + '  ' + cstate1 + ' ' + czip1
		                            m.caddr3 = ' '
		                        ELSE
		                            m.caddr2 = caddress1b
		                            m.caddr3 = ALLTRIM(ccity1) + '  ' + cstate1 + ' ' + czip1
		                        ENDIF
		                        IF EMPTY(m.cMEMO)
		                            m.cMEMO = investor.cchkmemo1
		                        ENDIF
		                    ENDIF
		                ENDIF
		            CASE tcChkType = 'LM'
		* Don't try to print any checks other than owner checks
		                IF m.cidtype <> 'I'
		                    LOOP
		                ENDIF
		                SWSELECT('landopt')
		*         lcChkForm = 'L' + cCheckType
		                SWSELECT('investor')
		                SET ORDER TO cOwnerID
		                IF SEEK(m.cID)
		                    m.cpayee2 = cownname1
		                    m.caddr1  = caddress1a
		                    IF EMPTY(caddress1b)
		                        m.caddr2 = ALLTRIM(ccity1) + '  ' + cstate1 + ' ' + czip1
		                        m.caddr3 = ' '
		                    ELSE
		                        m.caddr2 = caddress1b
		                        m.caddr3 = ALLTRIM(ccity1) + '  ' + cstate1 + ' ' + czip1
		                    ENDIF
		                ENDIF
		            CASE tcChkType = 'PR'
		* Don't try to print any checks other than employee checks
		                IF m.cidtype <> 'E'
		                    LOOP
		                ENDIF
		                SWSELECT('emps')
		                SET ORDER TO cempid
		                IF SEEK(m.cID)
		                    m.caddr1 = cAddress
		                    m.caddr2 = TRIM(ccity) + ' ' + cstate + ' ' + czipcode
		                ELSE
		                    m.caddr1 = ' '
		                    m.caddr2 = ' '
		                ENDIF
		        ENDCASE
		        SELECT pickchks
		        REPLACE ccheckno WITH lcCheckNo, ;
		            lprinted WITH .T.
		        m.count = m.count + 1
		* Changed to test value before converting the amount to words.
		* If the amount is less than 1,000,000 use NumToWords
		* otherwise, use NumToStr - pws 8/26/13
		        IF m.namount > 999999.99
		            m.cwordnum = numtostr(m.namount)
		        ELSE
		            m.cwordnum = numtowords(m.namount)
		        ENDIF
		        m.cwordnum = ALLTRIM(m.cwordnum) + REPL(' *', 30)
		        m.ccheckno = lcCheckNo
		        IF m.goapp.ldemo  &&  If demo version, don't let them print proper checks
		            m.cpayee   = 'DEMO PAYEE * * * * * * * * * * * * * * * * '
		            m.caddr1   = 'VOID VOID VOID VOID VOID VOID'
		            m.caddr2   = 'VOID VOID VOID VOID VOID VOID'
		            m.cwordnum = 'DEMO VERSION   *VOID*   DEMO VERSION'
		            m.cMEMO    = '*VOID*   NON-NEGOTIABLE   *VOID*'
		        ENDIF
		        INSERT INTO checktmp FROM MEMVAR
		        lcCheckNo = PADL(ALLTRIM(STR(VAL(lcCheckNo) + 1, 10)), 10, ' ')
		    ENDSCAN
		
		    SELECT checktmp
		    INDEX ON czipcode + cID TAG zipcode
		    INDEX ON cidchec TAG cidchec
		    INDEX ON cpayee + DTOS(dcheckdate) TAG cpayee
		    INDEX ON DTOS(dcheckdate) TAG dcheckdate
		    INDEX ON cyear + cperiod + DTOS(dcheckdate) TAG cyearprd
		    INDEX ON namount TAG namount
		    INDEX ON cGROUP+DTOS(dcheckdate)+cID TAG cGROUP
		    INDEX ON cID + DTOS(dcheckdate) TAG cID
		
		    GO TOP
		    llEsc = .F.
		
		    IF TYPE('m.goApp') = 'O'
		        gcPath = ALLTRIM(m.goapp.cDataFilePath)
		        IF EMPTY(gcPath)
		            gcPath = 'data\'
		        ENDIF
		    ELSE
		        gcPath = m.goapp.cChecksFolder
		    ENDIF
		
		* Set the report behaviour to the old style to speed up check printing
		    SET REPORTBEHAVIOR 80
		
		    IF m.count > 0
		        lcOrder = THISFORM.cOrder
		        DO CASE
		            CASE lcChkForm = 'ADN'   && Dot-matrix (no voucher)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'apchekdn.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ADB'   && Dot-matrix (voucher below check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'apchekdb.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubap(lcChkForm)
		                SELECT stub
		                SET ORDER TO cID
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ADA'   && Dot-matrix (voucher above check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'apchekda.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubap(lcChkForm)
		                SELECT stub
		                SET ORDER TO cID
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ALN'   && Laser (no voucher)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'apchekln.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ALC'   && Laser (Check in middle)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'apcheklc.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubap(lcChkForm)
		                SELECT stub
		                SET ORDER TO cID
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ALV'   && Laser (voucher below)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'apcheklv.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubap(lcChkForm)
		                SELECT stub
		                SET ORDER TO cID
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ALA'   && Laser (voucher above)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'apchekla.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubap(lcChkForm)
		                SELECT stub
		                SET ORDER TO cID
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ALE'   && Laser (voucher and MICR encoded)
		                IF NOT llCheckNames
		                    IF llCommonMICR
		                        lcCheckName = ALLTRIM(m.goapp.cChecksFolder)+'apchekle.frx'
		                    ELSE
		                        lcCheckName = ALLTRIM(gcPath) + 'apchekle.frx'
		                    ENDIF
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubap(lcChkForm)
		                SELECT stub
		                SET ORDER TO cID
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ALM'   && Laser (no voucher and MICR encoded - 3 up)
		                IF NOT llCheckNames
		                    lcCheckName = ALLTRIM(gcPath) + 'apcheklm.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'ALI'   && Laser (voucher and MICR encoded - Stub Above)
		                IF NOT llCheckNames
		                    IF llCommonMICR
		                        lcCheckName = ALLTRIM(m.goapp.cChecksFolder)+'apchekli.frx'
		                    ELSE
		                        lcCheckName = ALLTRIM(gcPath) + 'apchekli.frx'
		                    ENDIF
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                PRIVATE m.onus, m.transitno
		
		                SWSELECT('micrdata')
		                GO TOP
		                m.onus = ALLTRIM(cmicracct)+'C'
		                m.transitno = 'A'+ALLTRIM(cmicrtransit)+'A'
		                m.cbankname = cbankname
		                SELECT checktmp
		                REPLACE onus WITH m.onus, transitno WITH m.transitno, cbankname WITH m.cbankname ALL
		
		                THISFORM.stubap()
		                SELECT stub
		                SET ORDER TO cID
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		
		            CASE lcChkForm = 'ACF'   && Custom Format
		                IF NOT llCheckNames
		                    lcCheckName = ALLTRIM(m.goapp.cDataFilePath) + 'apchekcf.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubap(lcChkForm)
		                SELECT stub
		                SET ORDER TO cID
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DDN'   && Dot-matrix (no voucher)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'dmchekdn.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DDB'   && Dot-matrix (voucher below check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'dmchekdb.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubdm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DDA'   && Dot-matrix (voucher above check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'dmchekda.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubdm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLN'   && Laser (no voucher)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'dmchekln.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLC'   && Laser (Check in middle)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'dmcheklc.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubdm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLVE'   && Laser (voucher below enhanced - 2 lines per well entry)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'dmcheklve.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubdm()
		                lcCheckName = THISFORM.printwhenfix(lcCheckName)
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLV'   && Laser (voucher below)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'dmcheklv.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubdm()
		                lcCheckName = THISFORM.printwhenfix(lcCheckName)
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLA'   && Laser (voucher above)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'dmchekla.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubdm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLE'   && Laser (voucher and MICR encoded)
		                IF NOT llCheckNames
		                    IF llCommonMICR
		                        lcCheckName = ALLTRIM(m.goapp.cChecksFolder)+'dmchekle.frx'
		                    ELSE
		                        lcCheckName = ALLTRIM(gcPath) + 'dmchekle.frx'
		                    ENDIF
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                PRIVATE m.onus, m.transitno
		
		                SWSELECT('micrdata')
		                GO TOP
		                m.onus = ALLTRIM(cmicracct)+'C'
		                m.transitno = 'A'+ALLTRIM(cmicrtransit)+'A'
		                m.cbankname = cbankname
		                SELECT checktmp
		                REPLACE onus WITH m.onus, transitno WITH m.transitno, cbankname WITH m.cbankname ALL
		
		                THISFORM.stubdm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLU'   && Laser (voucher and MICR encoded - Check in Middle)
		                IF NOT llCheckNames
		                    IF llCommonMICR
		                        lcCheckName = ALLTRIM(m.goapp.cChecksFolder)+'dmcheklu.frx'
		                    ELSE
		                        lcCheckName = ALLTRIM(gcPath) + 'dmcheklu.frx'
		                    ENDIF
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                PRIVATE m.onus, m.transitno
		
		                SWSELECT('micrdata')
		                GO TOP
		                m.onus = ALLTRIM(cmicracct)+'C'
		                m.transitno = 'A'+ALLTRIM(cmicrtransit)+'A'
		                m.cbankname = cbankname
		                SELECT checktmp
		                REPLACE onus WITH m.onus, transitno WITH m.transitno, cbankname WITH m.cbankname ALL
		
		                THISFORM.stubdm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLI'   && Laser (voucher and MICR encoded - Stub Above)
		                IF NOT llCheckNames
		                    IF llCommonMICR
		                        lcCheckName = ALLTRIM(m.goapp.cChecksFolder)+'dmchekli.frx'
		                    ELSE
		                        lcCheckName = ALLTRIM(gcPath) + 'dmchekli.frx'
		                    ENDIF
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                PRIVATE m.onus, m.transitno
		
		                SWSELECT('micrdata')
		                GO TOP
		                m.onus = ALLTRIM(cmicracct)+'C'
		                m.transitno = 'A'+ALLTRIM(cmicrtransit)+'A'
		                m.cbankname = cbankname
		                SELECT checktmp
		                REPLACE onus WITH m.onus, transitno WITH m.transitno, cbankname WITH m.cbankname ALL
		
		                THISFORM.stubdm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DLM'   && Laser (no voucher and MICR encoded - 3 up)
		                IF NOT llCheckNames
		                    lcCheckName = ALLTRIM(gcPath) + 'dmcheklm.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'DCF'   && Custom Format
		                IF NOT llCheckNames
		                    lcCheckName = ALLTRIM(m.goapp.cDataFilePath) + 'dmchekcf.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                IF FILE('dmchkstb.fxp')
		                    DO ('dmchkstb')
		                ELSE
		                    THISFORM.stubdm()
		                ENDIF
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LDN'   && Dot-matrix (no voucher)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'lmchekdn.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LDB'   && Dot-matrix (voucher below check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'lmchekdb.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stublm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LDA'   && Dot-matrix (voucher above check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'lmchekda.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stublm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LLN'   && Laser (no voucher)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'lmchekln.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LLV'   && Laser (voucher below)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'lmcheklv.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stublm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LLC'   && Laser (middle check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'lmcheklc.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stublm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LLA'   && Laser (voucher above)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'lmchekla.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stublm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LLE'   && Laser (voucher and MICR encoded)
		                IF NOT llCheckNames
		                    lcCheckName = ALLTRIM(gcPath) + 'lmchekle.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stublm()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'LLM'   && Laser (no voucher and MICR encoded - 3 up)
		                IF NOT llCheckNames
		                    lcCheckName = ALLTRIM(gcPath) + 'lmcheklm.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PDDN'   && Dot-matrix (no voucher)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'pdchekdn.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PDDB'   && Dot-matrix (voucher below check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'pdchekdb.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubprog()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PDDA'   && Dot-matrix (voucher above check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'pdchekda.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubprog()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PDLN'   && Laser (no voucher)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'pdchekln.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PDLV'   && Laser (voucher below)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'pdcheklv.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubprog()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PDLA'   && Laser (voucher above)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'pdchekla.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubprog()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PDLE'   && Laser (voucher and MICR encoded)
		                IF NOT llCheckNames
		                    lcCheckName = ALLTRIM(gcPath) + 'pdchekle.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubprog()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PDLM'   && Laser (no voucher and MICR encoded - 3 up)
		                IF NOT llCheckNames
		                    lcCheckName = ALLTRIM(gcPath) + 'pdcheklm.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PRDB'   && Dot-matrix (voucher below check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'prchekdb.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubpr()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PRDA'   && Dot-matrix (voucher above check)
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'prchekda.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubpr()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		
		            CASE lcChkForm = 'PRLV'   && Laser - Voucher below
		                IF NOT llCheckNames
		                    lcCheckName = m.goapp.cChecksFolder + 'prcheklv.frx'
		                ENDIF
		                IF NOT FILE(lcCheckName)
		                    lcCheckName = STRTRAN(lcCheckName, '\', '\\')
		                    IF llCheckNames
		                        THISFORM.omessage.DISPLAY('The file specified as the check format does not exist. Please ' + ;
		                            're-specify the format in the chart of accounts/options. Filename: ' + lcCheckName)
		                    ELSE
		                        THISFORM.omessage.DISPLAY('The standard check format file does not exist. Please ' + ;
		                            'contact SherWare Support to locate the check formats. Filename: ' + lcCheckName)
		                    ENDIF
		                    llReturn = .F.
		                    EXIT
		                ENDIF
		                THISFORM.stubpr()
		                SELECT stub
		                SET ORDER TO cidchec
		                SELECT checktmp
		                IF THISFORM.chkzipCode.VALUE = .T.
		                    SET ORDER TO zipcode
		                ELSE
		                    SET ORDER TO (lcOrder)
		                ENDIF
		                GO TOP
		                SET RELATION TO cidchec INTO stub
		                SET SKIP TO stub
		                THISFORM.creportname = lcCheckName
		                THISFORM.send_to_printer(llPreview)
		        ENDCASE
		    ENDIF
		
		    IF llEsc = .T.
		        WAIT WIND NOWAIT 'Check Printing Cancelled...' TIMEOUT 1
		    ENDIF
		
		* Make sure that each checktmp record doesn't have zero for ncount
		    SELECT checktmp
		    SCAN FOR nCount = 0
		        REPLACE nCount WITH 1
		    ENDSCAN
		
		    IF m.count > 0
		        SELE checktmp
		        IF THISFORM.chkzipCode.VALUE = .T.
		            SET ORDER TO zipcode
		        ELSE
		            SET ORDER TO (lcOrder)
		        ENDIF
		        GO BOTT
		        lcLastChk = ccheckno
		
		        IF llVoidNext &&  If voiding the next check, add the number of checks used to the last check, in case the last check printed used multiple pages
		            lcLastChk = PADL(ALLT(STR(VAL(ccheckno) + (nCount - 1))), 10, ' ')
		        ENDIF
		
		*   lcLastChk = PADL(ALLTRIM(STR(VAL(lcCheckNo)-1,10)),10,' ')
		        IF m.count = 1
		            lcMsg   = 'If check ' + ALLTRIM(lcFirstChk) + ' printed correctly, click on OK ' + ;
		                'to continue. Type the number of the first check which ' + ;
		                'printed incorrectly and then click OK or you can choose to reprint selected ' + ;
		                'checks by clicking the Selected Checks button.'
		            lcTitle = 'Did the check print OK?'
		        ELSE
		            lcMsg   = 'If checks ' + ALLTRIM(lcFirstChk) + ' through ' + ALLTRIM(lcLastChk) + ;
		                ' printed correctly, click on OK ' + ;
		                'to continue. Type the number of the first check which ' + ;
		                'printed incorrectly and then click OK or you can choose to reprint selected ' + ;
		                'checks by clicking the Selected Checks button.'
		            lcTitle = 'Did the checks print OK?'
		        ENDIF
		
		        IF THISFORM.laskok = .T.
		            IF NOT MESSAGEBOX('Did ALL the checks print correctly?',36,THISFORM.CAPTION) = 6
		                DO FORM cscheckok WITH lcMsg, lcTitle, lcFirstChk, lcLastChk TO lcResult
		*  Go update the check register with the check numbers
		*  of the checks that printed successfully.
		
		                IF ALLTRIM(lcResult) # '*****'
		                    SELECT cID, dcheckdate, namount, cidchec ;
		                        FROM checktmp ;
		                        INTO CURSOR SELECTED ;
		                        WHERE ccheckno >= lcResult
		                    lcNextChk = PADL(TRANSFORM(VAL(lcLastChk)+1),10,' ')
		                ELSE
		                    lcNextChk = PADL(TRANSFORM(VAL(lcLastChk)+1),10,' ')
		                ENDIF
		            ELSE
		                lcNextChk = PADL(TRANSFORM(VAL(lcLastChk)+1),10,' ')
		                IF NOT USED('selected')
		                    CREATE CURSOR SELECTED ;
		                        (cID   C(10), ;
		                        dcheckdate d, ;
		                        namount    N(12,2), ;
		                        cidchec    C(8))
		                    INDEX ON cID TAG cID
		                ENDIF
		
		            ENDIF
		
		            THISFORM.updatereg(lcNextChk, tcChkType, lcFirstChk, lcLastChk)
		        ENDIF
		        THISFORM.VISIBLE = .F.  &&  Force the screen to redraw to clear up problems with artifacts being left behind from the check format - BH 12/26/06
		        THISFORM.VISIBLE = .T.
		        THISFORM.REFRESH()
		    ELSE
		        WAIT WIND 'No Checks Printed' NOWAIT
		    ENDIF
		
		* Refresh the form with the new check number
		    IF m.goapp.lAMVersion
		        SWSELECT('coa', .T.)
		        SET ORDER TO acctno
		        IF SEEK(lcAcctNo)
		* Only fill in value if the next check # isn't blank, since we've already filled it in initially - BH 5-15-06
		            IF NOT EMPTY(coa.ccheckno)
		                THISFORM.txtcBegCheckNo.VALUE = coa.ccheckno
		                THISFORM.txtcBegCheckNo.REFRESH()
		            ENDIF
		        ENDIF
		    ELSE
		        SWSELECT('options')
		        GO TOP
		        THISFORM.txtcBegCheckNo.VALUE = options.ccheckno
		        THISFORM.txtcBegCheckNo.REFRESH()
		    ENDIF
		
		*  Refresh the form with the new check count.
		*  For some reason, just calling countchecks with the check type and account number doesn't work, but calling the
		*  click of the OPG that calls countchecks does work.  MOL
		*THISFORM.countchecks(tcChkType, lcAcctNo)
		    THISFORM.opgCheckType.CLICK()
		
		    IF USED('stub')
		        SELECT stub
		*   USE
		    ENDIF
		    IF USED('checktmp')
		        SELECT checktmp
		*   USE
		    ENDIF
		
		* Set the report behavior back to the new style
		    SET REPORTBEHAVIOR 90
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'PrintChecks', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		    MESSAGEBOX('Unable to process the checks at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		THISFORM.RELEASE()
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE printregister		&& Prints the check register
		LPARA tcFirstChk, tcLastChk
		LOCAL tcAcctNo, llError
		LOCAL lcSelect, lcSortOrder, lcTitle1, lcTitle2, llReturn, loError
		*:Global cacctdesc
		
		llReturn = .T.
		
		TRY
		   tcAcctNo = THISFORM.cboAcct.VALUE
		
		*  Create the report cursor
		   CREATE CURSOR tempchk ;
		      (cid        C(10), ;
		        cType      C(10), ;
		        cBal       C(1),  ;
		        cpayee     C(40), ;
		        dcheckdate D,     ;
		        cyear      C(4),  ;
		        cperiod    C(2),  ;
		        lCleared   L,     ;
		        cCheckno   C(10), ;
		        cacctdesc  C(30), ;
		        namount    N(12, 2))
		   INDEX ON cCheckno TAG checkno
		
		   lcTitle1 = 'By Check Range'
		
		   IF m.goapp.lAMVersion
		      SWSELECT('coa', .T.)
		      SET ORDER TO acctno
		      IF SEEK(tcAcctNo)
		         m.cacctdesc = cacctdesc
		      ELSE
		         m.cacctdesc = ' '
		      ENDIF
		   ELSE
		      m.cacctdesc = ''
		   ENDIF
		   lcTitle2    = cacctdesc
		   lcSelect    = 'Checks:  ' + tcFirstChk + ' - ' + tcLastChk
		   lcSortOrder = 'Check No'
		
		   SELECT  checks.*, 'Check' AS cType, 'A' AS cBal ;
			   FROM checks;
				   WITH (BUFFERING = .T.)  ;
			   WHERE IIF(m.goapp.lAMVersion, cAcctNo == tcAcctNo, .T.) ;
				   AND cIdType <> 'D' ;
				   AND BETWEEN(PADL(ALLTRIM(cCheckno), 10, '0'), PADL(ALLTRIM(tcFirstChk), 10, '0'), PADL(ALLTRIM(tcLastChk), 10, '0')) ;
				   AND cidchec IN (SELECT  cidchec ;
									   FROM pickchks) ;
				   AND lPrinted = .T. ;
			   INTO CURSOR temp ;
			   ORDER BY cCheckno
		
		   IF _TALLY > 0
		      llError = .F.
		      SELECT tempchk
		      APPEND FROM DBF('temp')
		      TRY
		         REPORT FORM cschkreg.frx TO PRINTER PROMPT NOCONSOLE NOEJECT
		      CATCH TO loError
		         llError = .T.
		      ENDTRY
		      IF llError
		         MESSAGEBOX('There was an error encountered sending the check register to the printer. Please check your printer setup and try again.', 48, 'Print Error')
		      ENDIF
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'PrintRegister', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
	ENDPROC

	PROCEDURE printwhenfix
		LPARA tcCheckName
		LOCAL lctempname, lcCheckName
		
		* RETURN tcCheckName
		
		TRY
		   lcTemp = ADDBS(SYS(2023))    && Get temp location
		   lctempname = SYS(3) + '.frx'
		   USE (tcCheckName) ALIAS checkfile IN 0
		   SELE checkfile
		   COPY TO (lcTemp+lctempname)
		   USE IN checkfile
		   USE (lcTemp+lctempname) ALIAS checkfile IN 0
		   SELE checkfile
		   SCAN FOR 'cwellname,1) <>' $ LOWER(supexpr)
		      REPL supexpr WITH "(left(stub.cwellname,1) <> '*' and stub.cprodprd <> '99/99') and not EMPTY(stub.cwellname)"
		   ENDSCAN
		
		   LOCATE FOR objtype=9 AND objcode=3 AND 'cidchec' $ EXPR
		   IF FOUND()
		      REPL EXPR WITH 'stub.cidchec+transform(stub.npageno)'
		   ENDIF
		   LOCATE FOR objtype=17 AND '_pageno' $ supexpr
		   IF FOUND()
		      REPL supexpr WITH 'stub.npageno > 1'
		   ENDIF
		   lcCheckName = lcTemp+lctempname
		   USE IN checkfile
		CATCH TO loError
		*   MESSAGEBOX('Error in PrintWhenFix: ' + loerror.message,0,'Error')
		   lcCheckName = tcCheckName
		ENDTRY
		
		RETURN (lcCheckName)
		
	ENDPROC

	PROCEDURE selectallchecks		&& Selects All Check To Print
		LPARA tcChkType, tcAcctNo
		
		LOCAL llReturn, loError
		llReturn = .T.
		
		TRY
		   DO CASE
		      CASE tcChkType = 'DM'
		         IF NOT m.goApp.lAMVersion
					SELECT  checks.cid        AS cid, ;
							checks.cidtype    AS cidtype, ;
							checks.dCheckDate AS dCheckDate, ;
							checks.cpayee     AS cpayee, ;
							SPACE(60)         AS cpayee2, ;
							checks.cYear      AS cYear, ;
							checks.cPeriod    AS cPeriod, ;
							checks.nAmount    AS nAmount, ;
							checks.cmemo      AS cmemo, ;
							checks.csource    AS csource, ;
							checks.cgroup     AS cgroup, ;
							'Y'               AS chosen, ;
							checks.cCheckno   AS cCheckno, ;
							.T.               AS lprinted, ;
							checks.cBatch     AS cBatch, ;
							checks.cidchec, ;
							IIF(investor.lchktosec, investor.czip2, investor.czip1) AS czipcode, ;
							checks.lVoid      AS lVoid ;
						FROM checks, investor ;
						WHERE EMPTY(checks.cCheckno) ;
							AND checks.csource = 'DM' ;
							AND checks.lHist = .F. ;
							AND checks.cidtype = 'I' ;
							AND checks.lVoid = .F. ;
							AND checks.lprinted = .F. ;
							AND checks.cid = investor.cownerid ;
							AND NOT DELETED() ;
						INTO CURSOR picktmp READWRITE  ;
						ORDER BY cCheckno, cYear, cPeriod, cid
		         ELSE
					SELECT  checks.cid        AS cid, ;
							checks.cidtype    AS cidtype, ;
							checks.dCheckDate AS dCheckDate, ;
							checks.cpayee     AS cpayee, ;
							SPACE(60)         AS cpayee2, ;
							checks.cYear      AS cYear, ;
							checks.cPeriod    AS cPeriod, ;
							checks.nAmount    AS nAmount, ;
							checks.cmemo      AS cmemo, ;
							checks.csource    AS csource, ;
							checks.cgroup     AS cgroup, ;
							'Y'               AS chosen, ;
							checks.cCheckno   AS cCheckno, ;
							.T.               AS lprinted, ;
							checks.cBatch     AS cBatch, ;
							checks.cidchec, ;
							IIF(investor.lchktosec, investor.czip2, investor.czip1) AS czipcode, ;
							checks.lVoid      AS lVoid ;
						FROM checks, investor ;
						WHERE EMPTY(checks.cCheckno) ;
							AND checks.lHist = .F. ;
							AND cAcctNo == tcAcctNo ;
							AND checks.csource = 'DM' ;
							AND checks.cidtype <> 'D' ;
							AND checks.cidtype <> 'V' ;
							AND checks.lVoid = .F. ;
							AND checks.lprinted = .F. ;
							AND checks.cid = investor.cownerid ;
							AND NOT DELETED() ;
						INTO CURSOR picktmp READWRITE  ;
						ORDER BY cCheckno, cYear, cPeriod, cid
		         ENDIF
		
		      CASE tcChkType = 'PD'
				 SELECT  checks.cid        AS cid, ;
						 checks.cidtype    AS cidtype, ;
						 checks.dCheckDate AS dCheckDate, ;
						 checks.cpayee     AS cpayee, ;
						 SPACE(60)         AS cpayee2, ;
						 SPACE(10)         AS czipcode, ;
						 checks.cYear      AS cYear, ;
						 checks.cPeriod    AS cPeriod, ;
						 checks.nAmount    AS nAmount, ;
						 checks.cmemo      AS cmemo, ;
						 checks.csource    AS csource, ;
						 'Y'               AS chosen, ;
						 checks.cCheckno   AS cCheckno, ;
						 .T.               AS lprinted, ;
						 checks.cidchec, ;
						 checks.lVoid      AS lVoid ;
					 FROM checks ;
					 WHERE (EMPTY(checks.cCheckno)) ;
						 AND checks.lHist = .F. ;
						 AND cAcctNo = tcAcctNo ;
						 AND checks.csource = 'PD' ;
						 AND checks.cidtype <> 'D' ;
						 AND checks.lVoid = .F. ;
						 AND checks.lprinted = .F. ;
						 AND NOT DELETED() ;
					 INTO CURSOR picktmp READWRITE  ;
					 ORDER BY cCheckno, cYear, cPeriod, cid
		
		      CASE tcChkType = 'PR'
				 SELECT  checks.cid        AS cid, ;
						 checks.cidtype    AS cidtype, ;
						 checks.dCheckDate AS dCheckDate, ;
						 checks.cpayee     AS cpayee, ;
						 SPACE(60)         AS cpayee2, ;
						 SPACE(10)         AS czipcode, ;
						 checks.cYear      AS cYear, ;
						 checks.cPeriod    AS cPeriod, ;
						 checks.nAmount    AS nAmount, ;
						 checks.cmemo      AS cmemo, ;
						 checks.csource    AS csource, ;
						 'Y'               AS chosen, ;
						 checks.cCheckno   AS cCheckno, ;
						 .T.               AS lprinted, ;
						 checks.cidchec, ;
						 checks.lVoid      AS lVoid ;
					 FROM checks ;
					 WHERE (EMPTY(checks.cCheckno)) ;
						 AND checks.lHist = .F. ;
						 AND cAcctNo = tcAcctNo ;
						 AND checks.csource = 'PR' ;
						 AND checks.cidtype <> 'D' ;
						 AND checks.lVoid = .F. ;
						 AND checks.lprinted = .F. ;
						 AND NOT DELETED() ;
					 INTO CURSOR picktmp READWRITE  ;
					 ORDER BY cCheckno, cYear, cPeriod, cid
		
		      CASE tcChkType = 'AP'
		         IF NOT m.goApp.lAMVersion
					SELECT  checks.cid        AS cid, ;
							checks.cidtype    AS cidtype, ;
							checks.dCheckDate AS dCheckDate, ;
							checks.cpayee     AS cpayee, ;
							SPACE(60)         AS cpayee2, ;
							SPACE(10)         AS czipcode, ;
							checks.cYear      AS cYear, ;
							checks.cPeriod    AS cPeriod, ;
							checks.nAmount    AS nAmount, ;
							checks.cmemo      AS cmemo, ;
							'Y'               AS chosen, ;
							checks.cCheckno   AS cCheckno, ;
							checks.csource    AS csource, ;
							.T.               AS lprinted, ;
							checks.cidchec, ;
							checks.lVoid      AS lVoid ;
						FROM checks ;
						WHERE (EMPTY(checks.cCheckno)) ;
							AND checks.lHist = .F. ;
							AND ((checks.csource = 'DM' ;
								AND checks.cidtype = 'V') ;
							  OR csource = 'AP') ;
							AND checks.lVoid = .F. ;
							AND checks.lprinted = .F. ;
							AND NOT DELETED() ;
						INTO CURSOR picktmp READWRITE  ;
						ORDER BY cid, cYear, cPeriod
		         ELSE
					SELECT  checks.cid        AS cid, ;
							checks.cidtype    AS cidtype, ;
							checks.dCheckDate AS dCheckDate, ;
							checks.cpayee     AS cpayee, ;
							SPACE(60)         AS cpayee2, ;
							SPACE(10)         AS czipcode, ;
							checks.cYear      AS cYear, ;
							checks.cPeriod    AS cPeriod, ;
							checks.nAmount    AS nAmount, ;
							checks.cmemo      AS cmemo, ;
							'Y'               AS chosen, ;
							checks.cCheckno   AS cCheckno, ;
							checks.csource    AS csource, ;
							.T.               AS lprinted, ;
							checks.cidchec, ;
							checks.lVoid      AS lVoid ;
						FROM checks ;
						WHERE (EMPTY(checks.cCheckno)) ;
							AND checks.lHist = .F. ;
							AND cAcctNo == tcAcctNo ;
							AND (INLIST(checks.csource, 'AP', 'CS', 'CD');
							  OR (checks.csource = 'DM' ;
								AND cidtype = 'V'))  ;
							AND checks.cidtype <> 'D' ;
							AND checks.lVoid = .F. ;
							AND checks.lprinted = .F. ;
							AND NOT DELETED() ;
						INTO CURSOR picktmp READWRITE  ;
						ORDER BY cid, cYear, cPeriod
		         ENDIF
		
		      CASE tcChkType = 'LM'
				 SELECT  checks.cid        AS cid, ;
						 checks.cidtype    AS cidtype, ;
						 checks.dCheckDate AS dCheckDate, ;
						 checks.cpayee     AS cpayee, ;
						 SPACE(60)         AS cpayee2, ;
						 SPACE(10)         AS czipcode, ;
						 checks.cYear      AS cYear, ;
						 checks.cPeriod    AS cPeriod, ;
						 checks.nAmount    AS nAmount, ;
						 checks.cmemo      AS cmemo, ;
						 'Y'               AS chosen, ;
						 checks.cCheckno   AS cCheckno, ;
						 checks.csource    AS csource, ;
						 .T.               AS lprinted, ;
						 checks.cidchec, ;
						 checks.lVoid      AS lVoid ;
					 FROM checks ;
					 WHERE (EMPTY(checks.cCheckno)) ;
						 AND checks.lHist = .F. ;
						 AND IIF(m.goApp.lAMVersion, cAcctNo == tcAcctNo, .T.) ;
						 AND checks.csource = 'LM' ;
						 AND checks.cidtype <> 'D' ;
						 AND checks.lVoid = .F. ;
						 AND checks.lprinted = .F. ;
						 AND NOT DELETED() ;
					 INTO CURSOR picktmp READWRITE  ;
					 ORDER BY cCheckno, cYear, cPeriod, cid
		   ENDCASE
		
		   SELECT picktmp
		   INDEX ON cpayee + DTOS(dCheckDate) TAG cpayee
		   INDEX ON DTOS(dCheckDate) TAG dCheckDate
		   INDEX ON cYear + cPeriod + DTOS(dCheckDate) TAG cyearprd
		   INDEX ON nAmount TAG nAmount
		   INDEX ON czipcode + cid TAG zipcode
		   INDEX ON cid + DTOS(dCheckDate) TAG cid
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'SelectAllChecks', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the checks at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE send_to_printer
		LPARAMETERS llPreview
		LOCAL lcPreviewWindowName, llError, lcCheckName
		
		IF llPreview
		    lcPrint = 'TO PRINTER PROMPT PREVIEW'
		ELSE
		    lcPrint = 'TO PRINTER PROMPT NOCONSOLE NOEJECT'
		ENDIF
		
		THISFORM.laskok = .F.
		
		llError = .F.
		
		lcCheckName = THIS.cReportName
		
		IF llPreview
		    SET REPORTBEHAVIOR 90
		    LOCAL loPreviewContainer, loReportListener
		    LOCAL loSession, lnRetval, loXFF, loPreview, loScripts
		    loSession = EVALUATE([xfrx("XFRX#LISTENER")])
		    loUpdate = CREATEOBJECT("updatelistener")
		    loUpdate.thermFormCaption = " Check Printing in Progress ..."
		    loSession.successor = loUpdate
		    lnRetval  = loSession.SetParams(, , , , , , "XFF") && no name = just in memory
		    loSession.SetOtherParams("PRINT_BOOKMARKS",.T.)
		    loSession.PRINTJOBNAME = 'Print Checks'
		    IF lnRetval = 0
		        TRY
		            REPORT FORM (lcCheckName) OBJECT loSession
		        CATCH TO loError
		            llError = .T.
		        ENDTRY
		
		        loXFF     = loSession.oxfDocument
		        loPreview = CREATEOBJECT("frmMPPreviewer")
		        loPreview.setExtensionHandler(CREATEOBJECT("CheckExtensionHandler"))
		        loPreview.iTool = 2
		        loPreview.ShowStatus = .F.
		        loPreview.oDisplayDefaults.ZoomFactor = -2
		        loPreview.PreviewXFF(loXFF)
		        loPreview.SHOW(1)
		    ENDIF
		
		    IF llError
		        IF loError.ERRORNO = 1958
		            MESSAGEBOX('There was an error loading the printer driver. Make sure you have a valid printer selected or setup as your default printer.', 16, 'Windows Printer Driver Error')
		        ELSE
		            MESSAGEBOX('Error sending the report to the printer.' + CHR(10) + ;
		                'Error: ' + loError.MESSAGE, 16, 'Report Print Problem')
		        ENDIF
		    ENDIF
		
		    IF THISFORM.omessage.CONFIRM('Should the checks be sent to the printer now?')
		        SELECT checktmp
		        REPORT FORM (lcCheckName) TO PRINTER PROMPT
		        THISFORM.laskok = .T.
		    ENDIF
		ELSE
		    TRY
		        REPORT FORM (lcCheckName) &lcPrint
		    CATCH
		        llError = .T.
		    ENDTRY
		    THISFORM.laskok = .T.
		ENDIF
		
		IF llError
		    MESSAGEBOX('There was an error encountered sending the check(s) to the printer. Please check your printer setup and try again.',48,'Print Checks Error')
		ENDIF
		
		
		
	ENDPROC

	PROCEDURE stubap		&& A/P Check Stub Processing
		LPARA tcChkForm
		LOCAL llStubDetail, gnstubline, llSkipPerf
		LOCAL llDupStub, llReturn, llVoidNext, lnBlankLines, lnCount, lnDetail, lnGroupLines, lnMaxPages
		LOCAL lnRecno, lnTotalLines, lnZ, lnx, loError, lskip
		*:Global cAcctDesc, cBatch, cCatCode, cCateg, cID, cInvNum, cNotes, cWellID, cacctno, ccheckno
		*:Global cdesc, cidchec, cpayee, creference, crptgroup, cwellname, dInvDate, iLines, ipage, jCount
		*:Global jMax, namount, namtpaid, ndisctot, ninvtot, tcFirst, tcLast, tcPeriod, tcYear
		
		llReturn = .T.
		
		TRY
		
		   llStubDetail = .F.
		
		   SELECT pickchks
		   SET ORDER TO cID
		   GO TOP
		   tcFirst = cID
		   GO BOTT
		   tcLast   = cID
		   tcYear   = cYear
		   tcPeriod = cPeriod
		
		   IF USED('tempexp1')
		      USE IN tempexp1
		   ENDIF
		
		   IF FILE('apstubdetail.cfg')  &&  Option for including the bill detail on the check stub
		      llStubDetail = .T.
		   ENDIF
		
		*  Set the line counter
		   jCount = 0
		
		*  Check to see if the next check should be voided
		*  if overflow occurs.  If so, set the max high.
		   SWSELECT('apopt')
		   llSkipPerf = lSkipPerf
		   llVoidNext = lVoidNext
		   llDupStub  = lDupStub
		
		   IF nstubline <> 0  &&  Get the maximum # of check stub lines
		      jMax       = nstubline
		      gnstubline = nstubline
		   ELSE
		      jMax       = 12
		      gnstubline = 12
		   ENDIF
		
		   IF llVoidNext  &&  If voiding next check, set max very high
		*jMax = 999999
		   ENDIF
		
		   CREATE CURSOR stub ;
		      (cID            C(10), ;
		        ipage          i, ;
		        crptgroup      C(1), ;
		        cInvNum        C(20), ;
		        dInvDate       D, ;
		        cWellID        C(10),  ;
		        cwellname      C(30), ;
		        cpayee         C(40), ;
		        cacctno        C(6),  ;
		        cAcctDesc      C(30),  ;
		        cdesc          C(30), ;
		        ninvtot        N(12, 2), ;
		        namtpaid       N(12, 2), ;
		        ndisctot       N(12, 2), ;
		        cCatCode       C(4),  ;
		        cCateg         C(25),  ;
		        creference     C(30), ;
		        namount        N(9, 2), ;
		        cidchec        C(8),  ;
		        cNotes         M, ;
		        ccheckno       C(10))
		   INDEX ON cidchec + PADL(TRANSFORM(ipage), 3, '0') + crptgroup + cInvNum TAG cID
		
		   m.ipage = 1
		
		*
		*  Find the detail information for this check.
		*
		   SWSELECT('vendor')
		   SET ORDER TO cvendorid
		
		   SELECT checktmp
		   SET ORDER TO THISFORM.cOrder
		   SCAN
		      jCount  = 1
		      m.ipage = 1
		      SCATTER MEMVAR
		      m.cwellname = ''
		      m.cdesc     = ''
		      SWSELECT('vendor')
		      IF SEEK(m.cID)
		         IF NOT m.goapp.lQBVersion
		            llStubDetail = lStubDetail
		         ELSE
		            llStubDetail = .F.
		         ENDIF
		      ELSE
		         llStubDetail = .F.  &&  Not a vendor, so there shouldn't be any option about printing stub detail
		      ENDIF
		     
		      DO CASE
		         CASE m.cSource = 'AP'
		            IF NOT llStubDetail  &&  Regular Stub, no detail
		               SWSELECT('appmtdet')
		               SET ORDER TO cInvNum
		               SCAN FOR cidchec = m.cidchec
		                  m.ndisctot   = ndisctot
		                  m.namtpaid   = namtpaid
		                  m.cInvNum    = cInvNum
		                  m.cBatch     = cBillToken
		                  m.ninvtot    = 0
		                  m.dInvDate   = {}
		                  m.creference = ' '
		                  m.cNotes     = ''
		                  SWSELECT('appurchh')
		                  SET ORDER TO cBatch
		                  IF SEEK(m.cBatch)
		                     m.ninvtot    = ninvtot
		                     m.dInvDate   = dInvDate
		                     m.creference = creference
		                     IF EMPTY(m.creference)  &&  If no ref for the bill header, check to see if there's just a single bill detail that we can use
		                        SWSELECT('appurchd')
		                        COUNT FOR cBatch = appurchh.cBatch TO lnDetail
		                        IF lnDetail = 1  &&  Just a single detail line, so use the description from it
		                           SWSELECT('appurchd')
		                           LOCATE FOR cBatch = appurchh.cBatch
		                           m.creference = appurchd.cItemDesc
		                        ENDIF
		                     ENDIF
		                  ENDIF
		                  m.cdesc   = 'Payment on Invoice: ' + cInvNum
		                  m.namount = namtpaid
		                  IF jCount >= jMax
		                     IF NOT llVoidNext
		                        m.cdesc     = '** Stub Overflow **'
		                        m.cwellname = '** Stub Overflow **'
		                        IF jCount = jMax
		                           INSERT INTO stub FROM MEMVAR
		                           m.ipage = m.ipage + 1
		                        ENDIF
		                     ELSE
		                        m.ipage = m.ipage + 1
		                        jCount  = 0
		                        INSERT INTO stub FROM MEMVAR
		                     ENDIF
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  jCount = jCount + 1
		               ENDSCAN
		            ELSE  &&  Build the stub from the bill detail lines
		               SWSELECT('appmtdet')
		               SET ORDER TO cInvNum
		               SCAN FOR cidchec = m.cidchec
		                  m.cBatch = cBillToken
		                  SWSELECT('appurchh')
		                  SET ORDER TO cBatch
		                  IF SEEK(m.cBatch)
		                     m.cInvNum  = appurchh.cInvNum
		                     m.dInvDate = appurchh.dInvDate
		                     SWSELECT('appurchd')  &&  Scan the detail lines for this batch
		                     SCAN FOR cBatch = m.cBatch
		                        m.cdesc      = cItemDesc
		                        m.namount    = nExtension
		                        m.cWellID    = cUnitNo
		                        m.ninvtot    = nExtension
		                        m.creference = m.cdesc
		                        SWSELECT('wells')  &&  Get well name from wells file
		                        SET ORDER TO cWellID
		                        IF SEEK(m.cWellID)
		                           m.cwellname = cwellname
		                        ELSE
		                           m.cwellname = ''
		                        ENDIF
		                        SWSELECT('appurchd')
		                        m.cCatCode = cCatCode
		                        SWSELECT('expcat')  &&  Get expense category name from expcat
		                        SET ORDER TO cCatCode
		                        IF SEEK(m.cCatCode)
		                           m.cCateg = cCateg
		                        ELSE
		                           m.cCateg = ''
		                        ENDIF
		                        SWSELECT('appurchd')
		                        m.cacctno = cacctno
		                        IF m.goapp.lAMVersion
		                           SWSELECT('coa', .T.)  &&  Get account description from coa
		                           SET ORDER TO acctno
		                           IF SEEK(m.cacctno)
		                              m.cAcctDesc = cAcctDesc
		                           ELSE
		                              m.cAcctDesc = ''
		                           ENDIF
		                        ELSE
		                           m.cAcctDesc = ''
		                        ENDIF
		                        IF jCount > jMax -2
		                           IF NOT llVoidNext
		                              m.cdesc     = '** Stub Overflow **'
		                              m.cwellname = '** Stub Overflow **'
		                           ELSE
		                              m.cwellname = ''
		                           ENDIF
		                           IF jCount = jMax -2
		                              INSERT INTO stub FROM MEMVAR
		                           ENDIF    
		                        ELSE
		                           INSERT INTO stub FROM MEMVAR
		                        ENDIF
		                        jCount = jCount + 1
		                     ENDSCAN
		                  ENDIF
		               ENDSCAN
		
		            ENDIF
		         CASE m.cSource = 'CD' OR m.cSource = 'CS'
		            IF NOT llStubDetail  &&  Not printing CD detail on the check stub
		               SWSELECT('csdishdr')
		               SET ORDER TO cInvNum
		               SCAN FOR cidchec = m.cidchec
		                  m.ninvtot    = nCashAmt
		                  m.namtpaid   = nCashAmt
		                  m.dInvDate   = dDate
		                  m.creference = ' '
		                  SWSELECT('csdisdet')
		                  COUNT FOR cBatch = csdishdr.cBatch TO lnDetail  &&  If only a single detail line for this CD, use the description as the reference here
		                  IF lnDetail = 1
		                     SWSELECT('csdisdet')
		                     LOCATE FOR cBatch = csdishdr.cBatch
		                     m.creference = cdesc
		                  ENDIF
		                  SWSELECT('csdishdr')
		                  m.cInvNum = cInvNum
		                  m.cdesc   = 'Payment on Invoice: ' + cInvNum
		                  m.namount = nCashAmt
		                  m.cacctno = cCashAcct
		                  IF csdishdr.lChkMemo
		                     m.cNotes = csdishdr.mDisbMemo
		                  ELSE
		                     m.cNotes = ' '
		                  ENDIF
		                  IF jCount >= jMax
		                     m.cdesc     = '** See Statement For Further Detail **'
		                     m.cwellname = '** Stub Overflow **'
		                     IF jCount = jMax
		                        INSERT INTO stub FROM MEMVAR
		                     ENDIF
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  jCount = jCount + 1
		               ENDSCAN
		            ELSE  &&  Build the stub from the cash disbursement detail lines
		               SWSELECT('csdishdr')
		               SCAN FOR cidchec = m.cidchec
		                  m.cBatch  = cBatch
		                  m.cInvNum = cInvNum
		                  SWSELECT('csdisdet')
		                  SCAN FOR cBatch = m.cBatch
		                     m.cdesc   = cdesc
		                     m.namount = namount
		                     m.cWellID = cUnitNo
		                     SWSELECT('wells')  &&  Get well name from wells file
		                     SET ORDER TO cWellID
		                     IF SEEK(m.cWellID)
		                        m.cwellname = cwellname
		                     ELSE
		                        m.cwellname = ''
		                     ENDIF
		                     SWSELECT('csdisdet')
		                     m.cCatCode = cCatCode
		                     SWSELECT('expcat')  &&  Get expense category name from expcat
		                     SET ORDER TO cCatCode
		                     IF SEEK(m.cCatCode)
		                        m.cCateg = cCateg
		                     ELSE
		                        m.cCateg = ''
		                     ENDIF
		                     SWSELECT('csdisdet')
		                     m.cacctno = cacctno
		                     IF m.goapp.lAMVersion
		                        SWSELECT('coa', .T.)  &&  Get account description from coa
		                        SET ORDER TO acctno
		                        IF SEEK(m.cacctno)
		                           m.cAcctDesc = cAcctDesc
		                        ELSE
		                           m.cAcctDesc = ''
		                        ENDIF
		                     ELSE
		                        m.cAcctDesc = ''
		                     ENDIF
		                     IF jCount >= jMax
		                        m.cdesc     = '** Stub Overflow **'
		                        m.cwellname = '** Stub Overflow **'
		                        IF jCount = jMax
		                           INSERT INTO stub FROM MEMVAR
		                        ENDIF
		                     ELSE
		                        INSERT INTO stub FROM MEMVAR
		                     ENDIF
		                     jCount = jCount + 1
		                  ENDSCAN
		               ENDSCAN
		
		            ENDIF
		
		         CASE m.cSource = 'DM'
		            IF USED('tempexp1')
		               USE IN tempexp1
		            ENDIF
					SELECT  cWellID, cExpClass, cownerid, crefid, dExpDate, SUM(namount) AS namount ;
						FROM expense ;
						WHERE cpaidbyck = m.cidchec  ;
						INTO CURSOR temp ;
						ORDER BY cWellID, cExpClass, crefid ;
						GROUP BY cWellID, cExpClass, crefid
		
		            USE DBF('temp') AGAIN IN 0 ALIAS tempexp1  &&  Net down the amount being paid to eliminate Dummy Owners
		            SELECT tempexp1
		            SCAN
		               IF EMPTY(cownerid)  &&  Don't net down one-man items
		                  m.namount = swNetExp(tempexp1.namount, tempexp1.cWellID, .T., tempexp1.cExpClass, 'B')
		               ENDIF
		               REPLACE tempexp1.namount WITH m.namount
		            ENDSCAN
		
					SELECT  crefid, dExpDate, SUM(namount) AS namount ;
						FROM tempexp1  ;
						INTO CURSOR tempexp ;
						ORDER BY crefid ;
						GROUP BY crefid
		
		            SELECT tempexp
		            SCAN
		               m.ndisctot   = 0
		               m.namtpaid   = namount
		               m.cInvNum    = crefid
		               m.cBatch     = ''
		               m.ninvtot    = namount
		               m.dInvDate   = dExpDate
		               m.creference = cMemo
		               m.cdesc      = 'Payment on Invoice: ' + cInvNum
		               m.namount    = namount
		               m.cNotes     = ''
		               IF jCount >= jMax
		                  IF NOT llVoidNext
		                     m.cdesc     = '** Stub Overflow **'
		                     m.cwellname = '** Stub Overflow **'
		                     IF jCount = jMax
		                        INSERT INTO stub FROM MEMVAR
		                        m.ipage = m.ipage + 1
		                     ENDIF
		                  ELSE
		                     m.ipage = m.ipage + 1
		                     jCount  = 0
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		               ELSE
		                  INSERT INTO stub FROM MEMVAR
		               ENDIF
		               jCount = jCount + 1
		            ENDSCAN
		      ENDCASE
		   ENDSCAN
		
		   IF llDupStub
		      SELE cidchec, cID, ipage, cInvNum, COUNT(cidchec) AS ncount FROM stub INTO CURSOR stubcnt ORDER BY cidchec, ipage GROUP BY cidchec, ipage
		      SELE stub
		
		      SCATTER MEMVAR BLANK
		      SELE stubcnt
		      SCAN
		         SCATTER MEMVAR
		         IF NOT llVoidNext  &&  Don't add additional lines if voiding next check - will really screw things up - BH 04/27/2004
		            FOR lnx = 1 TO (jMax - m.ncount)
		               m.lskip = .T.
		               INSERT INTO stub FROM MEMVAR
		            ENDFOR
		         ENDIF
		      ENDSCAN
		
		      SELE * FROM stub INTO CURSOR temp
		      SELE temp
		      SCAN
		         SCATTER MEMVAR
		         m.crptgroup = 'A'
		         INSERT INTO stub FROM MEMVAR
		      ENDSCAN
		
		      SELE stub
		      SET ORDER TO 0
		      SCAN
		         IF crptgroup <> 'A'
		            REPL crptgroup WITH 'B'
		         ENDIF
		      ENDSCAN
		      SET ORDER TO cID
		   ENDIF
		
		
		   IF llVoidNext  &&  If voiding next check for overflow, pad the stub to the max lines setting before advancing to the next check
		
		      WAIT WIND NOWAIT 'Processing Voided Checks...'
		
		      CREATE CURSOR stub1 ;  &&  New dummy stub file to dump the data, plus appropriately spaced blank lines into
		         (cID            C(10), ;
		           ipage          i, ;
		           crptgroup      C(1), ;
		           cInvNum        C(20), ;
		           dInvDate       D, ;
		           cWellID        C(10),  ;
		           cwellname      C(30), ;
		           cpayee         C(40), ;
		           cacctno        C(6),  ;
		           cAcctDesc      C(30),  ;
		           cdesc          C(30), ;
		           ninvtot        N(12, 2), ;
		           namtpaid       N(12, 2), ;
		           ndisctot       N(12, 2), ;
		           cCatCode       C(4),  ;
		           cCateg         C(25),  ;
		           creference     C(30), ;
		           namount        N(9, 2), ;
		           cidchec        C(8),  ;
		           cNotes         M, ;
		           ccheckno       C(10))
		      INDEX ON cidchec + PADL(TRANSFORM(ipage), 3, '0') TAG cID
		
		      SELECT checktmp
		      SCAN
		         SELECT * FROM stub INTO CURSOR tmpa READWRITE WHERE cidchec = checktmp.cidchec AND (crptgroup = 'A' OR EMPTY(crptgroup))  &&  Pull all A records first, or empty ones if we're not doing duplicate stubs
		         lnGroupLines = _TALLY
		
		         IF llDupStub  &&  Only get the B recs if doing a duplicate stub, since there won't be any otherwise
		            SELECT * FROM stub INTO CURSOR tmpb READWRITE WHERE cidchec = checktmp.cidchec AND crptgroup = 'B'  &&  Pull all B records next
		         ENDIF
		
		         lnMaxPages          = CEILING(_TALLY / (gnstubline - 2))       &&  Figure out how many pages will be needed
		         lnGroupLines        = MOD(_TALLY, gnstubline)
		         lnBlankLines        = gnstubline - lnGroupLines - 2
		         lnTotalLines        = gnstubline - (MOD(_TALLY, (gnstubline - 2)))  &&  Figure out the max number of blank lines that will need to be added
		         IF (gnstubline - 2) = _TALLY  &&  The lines to print match the stublines - 2, so manually set it; otherwise, it doesn't work, and you end up with a bunch of extra lines - BH 12/06/06
		            lnTotalLines     = 2
		         ENDIF
		
		         SELECT checktmp
		         REPLACE ncount WITH lnMaxPages  &&  Plug in the number of extra checks, so we know how many to void later
		         m.ipage  = 1
		         m.iLines = 0
		         FOR lnx = 1 TO lnMaxPages
		
		            SELECT tmpa
		            REPLACE ipage WITH lnx FOR BETWEEN(RECNO(), ((lnx - 1) * (gnstubline - 2)) + 1, (gnstubline - 2) * lnx)  &&  Add the A records back into the stub1 cursor
		            SELECT stub1
		            APPEND FROM DBF('tmpa') FOR BETWEEN(RECNO(), ((lnx-1)*(gnstubline-2)) + 1, (gnstubline-2)*lnx)  &&  Add the A records back into the stub1 cursor
		            SCATTER MEMVAR BLANK
		            m.ipage     = lnx
		            m.cidchec   = checktmp.cidchec
		            m.cID       = checktmp.cID
		            m.crptgroup = IIF(llDupStub, 'A', '')
		
		            IF llDupStub  &&  Only append from the tmpb cursor if we're doing duplicate stubs, otherwise, it won't be created
		               IF lnx <> lnMaxPages  &&  Insert two blank lines if we're not on the last page, otherwise, fill the stub with blanks
		                  INSERT INTO stub1 FROM MEMVAR
		                  INSERT INTO stub1 FROM MEMVAR
		                  m.iLines = m.iLines + 2
		               ELSE
		                  FOR lnZ = 1 TO lnBlankLines
		                     INSERT INTO stub1 FROM MEMVAR
		                  ENDFOR
		               ENDIF
		
		               SELECT tmpb
		               REPLACE ipage WITH lnx FOR BETWEEN(RECNO(), ((lnx - 1) * (gnstubline - 2)) + 1, (gnstubline - 2) * lnx)
		               SELECT stub1
		               APPEND FROM DBF('tmpb') FOR BETWEEN(RECNO(), ((lnx-1)*(gnstubline-2)) + 1, (gnstubline-2)*lnx)
		               SCATTER MEMVAR BLANK
		               m.ipage     = lnx
		               m.cidchec   = checktmp.cidchec
		               m.cID       = checktmp.cID
		               m.crptgroup = 'B'
		
		               IF lnx <> lnMaxPages
		                  INSERT INTO stub1 FROM MEMVAR
		                  INSERT INTO stub1 FROM MEMVAR
		               ELSE
		                  FOR lnZ = 1 TO (lnTotalLines)
		                     INSERT INTO stub1 FROM MEMVAR
		                  ENDFOR
		               ENDIF
		
		            ENDIF
		         ENDFOR
		
		      ENDSCAN
		
		      SELECT checktmp  &&  Increment check numbers if any checks have gone to multiple pages - figure out a better way of doing this some time...
		      LOCATE FOR ncount > 1  &&  See if there's any multiple page checks, so we know whether to create the chkvoid cursor
		      IF FOUND()
		         CREATE CURSOR chkvoid  ;
		            (cEntryType C(1),   ;
		              cID        C(10),  ;
		              cpayee     C(60),  ;
		              cSource    C(2),   ;
		              cGROUP     C(2),   ;
		              dcheckdate D,      ;
		              cdesc      C(10),  ;
		              ccheckno   C(10))
		         SELECT checktmp
		         GO TOP
		         SCAN FOR ncount > 1
		            FOR lnx = 1 TO (ncount - 1)
		               SCATTER MEMVAR
		               m.cdesc    = 'VOID'
		               m.cpayee   = ALLT(m.cpayee) + ' - Check Overflow'
		               m.ccheckno = PADL(ALLT(STR(VAL(ccheckno) + lnx)), 10, ' ')
		               INSERT INTO chkvoid FROM MEMVAR
		            ENDFOR
		            SELECT checktmp
		            lnRecno = RECNO()
		            lnCount = ncount - 1
		            SKIP 1  &&  Go to the next record and begin updating check numbers
		            REPLACE ccheckno WITH PADL(ALLT(STR(VAL(ccheckno) + (lnCount))), 10, ' ') REST
		            GOTO lnRecno
		         ENDSCAN
		      ENDIF
		
		      SELECT stub
		      USE
		      USE DBF('stub1') AGAIN IN 0 ALIAS stub
		   ELSE
		      SELECT checktmp
		      SCAN
		         REPLACE ncount WITH 1
		      ENDSCAN
		   ENDIF
		
		   WAIT CLEAR
		
		   SELECT pickchks
		   SET FILTER TO
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'StubAP', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the checks at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE stubapcf		&& A/P Custom Stub Processing
	ENDPROC

	PROCEDURE stubdm		&& Disb Mgr Stub Processing
		LOCAL lnCount, lnMaxLines, lcidChec, lnMax, lnProcess, llDistProc, tcFirst, tcLast
		LOCAL ldAcctDate, m.cIntType, tcYear, tcPeriod, tcGroup, oOwner
		
		SELE cID AS cOwnerID FROM pickchks INTO CURSOR tempchks ORDER BY cID
		sele tempchks
		go top
		tcowner1 = cid
		go bott
		tcowner2 = cid
		
		SELECT pickchks
		SET ORDER TO cID
		
		*
		*  Call distproc to create the (invtmp) and (wellwork) cursors
		*
		oOwner = CREATEOBJECT('swowner')
		oOwner.OwnerStub()
		
		RELEASE oOwner
		
		Return
		
		
	ENDPROC

	PROCEDURE stubdmcf		&& Disb Mgr Custom Stub Processing
	ENDPROC

	PROCEDURE stublm		&& Land Manager Check Stub
		LOCAL lnCount, lnMaxLines, lcidChec, lnMax, lnProcess, llDistProc, tcFirst, tcLast
		LOCAL ldAcctDate, m.cIntType, tcYear, tcPeriod, tcGroup
		LOCAL llReturn, lnLine, loError
		*:Global cIntType, ccounty, cleasename, cpmtFreq, ctownship, nAmount, npmtfreq, nyearpmt, oProgress
		
		llReturn = .T.
		
		TRY
		   STORE ' ' TO tcFirst, tcLast, m.cIntType
		   STORE {}  TO ldAcctDate
		
		   CREATE CURSOR stub ;
		      (cid             C(10), ;
		        cidtype         C(1), ;
		        cpayee          C(40), ;
		        cleaseid        C(10), ;
		        ccheckno        C(10), ;
		        cidchec         C(8), ;
		        cleasename      C(60), ;
		        dpmtdate        D, ;
		        cpmtfreq        C(15), ;
		        npmtacre        N(12, 2), ;
		        nYearpmt        N(12, 2), ;
		        nacres          N(9, 2), ;
		        nAmount         N(12, 2), ;
		        ctownship       C(20), ;
		        ccounty         C(20))
		   INDEX ON cid + cleaseid TAG cid
		   INDEX ON cidchec TAG cidchec
		
		*
		*  Setup Global Options
		*
		   SWSELECT('landopt')
		   GO TOP
		   SCATTER MEMVAR
		
		   SELECT pickchks
		   lnMax     = RECC()
		   lnProcess = 1
		   SET ORDER TO cid
		
		*
		*  Set up the progress bar
		*
		   oProgress = THISFORM.oMessage.ProgressBar('Building check stubs for the selected owners...')
		   oProgress.SetProgressRange(0, lnMax)
		   oProgress.UpdateProgress(lnProcess)
		
		   lnMaxLines = 12
		
		   SELECT pickchks
		   SCAN
		      SCATTER MEMVAR
		      lnLine     = 0
		      SWSELECT('landhist')
		      SCAN FOR cidchec = m.cidchec
		         SCATTER MEMVAR
		         m.nAmount = nPmtAmount
		         SWSELECT('land')
		         SET ORDER TO cleaseid
		         IF SEEK(m.cleaseid)
		            m.cleasename = cleasename
		            m.ctownship  = ctownship
		            m.ccounty    = ccounty
		         ELSE
		            m.cleasename = 'Unknown'
		            m.ctownship  = 'Unknown'
		            m.ccounty    = 'Unknown'
		         ENDIF
		         lnProcess = lnProcess + 1
		         oProgress.UpdateProgress(lnProcess)
		         SWSELECT('landowner')
		         SET ORDER TO leaseowner
		         IF SEEK(m.cleaseid + m.cownerid)
		            m.npmtfreq   = npmtfreq
		            m.nYearpmt   = nYearpmt
		            m.cleasename = ALLT(m.cleasename) + ' - ' + ALLT(landowner.cpmtdesc)
		         ELSE
		            m.npmtfreq = 1
		            m.nYearpmt = m.nacres * m.npmtacre
		         ENDIF
		         DO CASE
		            CASE m.npmtfreq = 1
		               m.cpmtfreq = 'Monthly'
		            CASE m.npmtfreq = 3
		               m.cpmtfreq = 'Quarterly'
		            CASE m.npmtfreq = 6
		               m.cpmtfreq = 'Semi-Annual'
		            CASE m.npmtfreq = 12
		               m.cpmtfreq = 'Yearly'
		            OTHERWISE
		               m.cpmtfreq = 'Unknown'
		         ENDCASE
		         lnLine = lnLine + 1
		         IF lnLine <= lnMaxLines
		            INSERT INTO stub FROM MEMVAR
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		   oProgress.CloseProgress()
		   SELECT pickchks
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'StubLM', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the checks at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE stubpr		&& Payroll Stub Processing
		LOCAL llReturn, loError
		
		llReturn = .T.
		
		TRY
		
		   CREATE CURSOR stub ;
		      (cid             C(10), ;
		        dPrdEnd        D, ;
		        dPayDate       D, ;
		        payee          C(40), ;
		        npaytype       N(1),  ;
		        nRegRate       N(12, 3), ;
		        nRegHours      N(7, 2), ;
		        nRegAmt        N(12, 2), ;
		        nOv1Hours      N(7, 2), ;
		        nOv1Amt        N(12, 2), ;
		        nOv2Hours      N(7, 2), ;
		        nOv2Amt        N(12, 2), ;
		        nOtherInc      N(12, 2), ;
		        nTotInc        N(12, 2), ;
		        nTotWageC      N(12, 2), ;
		        nTotWageQ      N(12, 2), ;
		        nTotWageY      N(12, 2), ;
		        nFedWHC        N(9, 2), ;
		        nFedWHQ        N(9, 2), ;
		        nFedWHY        N(9, 2), ;
		        nFicaWHC       N(9, 2), ;
		        nFicaWHQ       N(9, 2), ;
		        nFicaWHY       N(9, 2), ;
		        nMedWHC        N(9, 2), ;
		        nMedWHQ        N(9, 2), ;
		        nMedWHY        N(9, 2), ;
		        nStateWHC      N(9, 2), ;
		        nStateWHQ      N(9, 2), ;
		        nStateWHY      N(9, 2), ;
		        nLocalWHC      N(9, 2), ;
		        nLocalWHQ      N(9, 2), ;
		        nLocalWHY      N(9, 2), ;
		        nMiscWHC       N(9, 2), ;
		        nMiscWHQ       N(9, 2), ;
		        nMiscWHY       N(9, 2), ;
		        nNetPayC       N(12, 2), ;
		        nNetPayQ       N(12, 2), ;
		        nNetPayY       N(12, 2), ;
		        cDeduct1       C(20), ;
		        cDeduct2       C(20), ;
		        cDeduct3       C(20), ;
		        cDeduct4       C(20), ;
		        cDeduct5       C(20), ;
		        cDeduct6       C(20), ;
		        nDeduct1       N(9, 2), ;
		        nDeduct2       N(9, 2), ;
		        nDeduct3       N(9, 2), ;
		        nDeduct4       N(9, 2), ;
		        nDeduct5       N(9, 2), ;
		        nDeduct6       N(9, 2), ;
		        cIncome1       C(20), ;
		        nIncome1       N(9, 2), ;
		        cIncome2       C(20), ;
		        nIncome2       N(9, 2), ;
		        cIncome3       C(20), ;
		        nIncome3       N(9, 2), ;
		        cIncome4       C(20), ;
		        nIncome4       N(9, 2), ;
		        cIncome5       C(20), ;
		        nIncome5       N(9, 2), ;
		        cidchec        C(8),  ;
		        checkno        C(10))
		   INDEX ON cidchec TAG cidchec
		
		*
		*  Build the deduction code table
		*
		   SELECT  prcodes.cempid, prcodef.cdesc, prcodef.cidprcodef, prcodef.cAcctNo ;
			   FROM prcodes, prcodef ;
			   WHERE prcodes.cidprcodef = prcodef.cidprcodef ;
				   AND prcodes.cType = 'D' ;
			   INTO CURSOR tempded ;
			   ORDER BY prcodes.cempid, prcodes.cidprcode
		
		*
		*  Build the income code table
		*
		   SELECT  prcodes.cempid, prcodef.cdesc, prcodef.cidprcodef, prcodef.cAcctNo ;
			   FROM prcodes, prcodef ;
			   WHERE prcodes.cidprcodef = prcodef.cidprcodef ;
				   AND prcodes.cType = 'I' ;
			   INTO CURSOR tempinc ;
			   ORDER BY prcodes.cempid, prcodes.cidprcode
		
		*
		*  Find the detail information for this check.
		*
		   SELECT checktmp
		   SCAN
		      SCATTER MEMVAR
		      SWSELECT('prdata')
		      SCAN FOR cidchec = m.cidchec
		         SCATTER MEMVAR
		         STORE ' ' TO m.cDeduct1, m.cDeduct2, m.cDeduct3, m.cDeduct4, ;
		            m.cDeduct5, m.cDeduct6, m.cIncome1, m.cIncome2, m.cIncome3, m.cIncome4, m.cIncome5
		         m.nIncome1  = m.nRate1
		         m.nIncome2  = m.nRate2
		         m.nIncome3  = m.nRate3
		         m.nIncome4  = m.nRate4
		         m.nIncome5  = m.nRate5
		         m.nOtherInc = m.nRate1 + m.nRate2 + m.nRate3 + m.nRate4 + m.nRate5
		         m.nFedWHC   = m.nFedWH + m.nFedWHExt
		         m.nFicaWHC  = m.nFica
		         m.nMedWHC   = m.nMedicare
		         m.nStateWHC = m.nStateWH + m.nStWHExt
		         m.nLocalWHC = m.nLocal1 + m.nLocal2
		         m.nTotWageC = m.nTotInc
		         m.nMiscWHC  = m.nDeduct1 + m.nDeduct2 + m.nDeduct3 + ;
		            m.nDeduct4 + m.nDeduct5 + m.nDeduct6
		         m.nNetPayC  = m.nNetPay
		         SELECT tempded
		         SCAN FOR cempid = m.cempid
		            DO CASE
		               CASE m.cDedCode1 = cidprcodef
		                  m.cDeduct1  = cdesc
		               CASE m.cDedCode2 = cidprcodef
		                  m.cDeduct2 = cdesc
		               CASE m.cDedCode3 = cidprcodef
		                  m.cDeduct3 = cdesc
		               CASE m.cDedCode4 = cidprcodef
		                  m.cDeduct4 = cdesc
		               CASE m.cDedCode5 = cidprcodef
		                  m.cDeduct5 = cdesc
		               CASE m.cDedCode6 = cidprcodef
		                  m.cDeduct6 = cdesc
		            ENDCASE
		         ENDSCAN
		         SELECT tempinc
		         SCAN FOR cempid = m.cempid
		            DO CASE
		               CASE m.cInc1Code = cidprcodef
		                  m.cIncome1  = cdesc
		               CASE m.cInc2Code = cidprcodef
		                  m.cIncome2 = cdesc
		               CASE m.cInc3Code = cidprcodef
		                  m.cIncome3 = cdesc
		               CASE m.cInc4Code = cidprcodef
		                  m.cIncome4 = cdesc
		               CASE m.cInc5Code = cidprcodef
		                  m.cIncome5 = cdesc
		            ENDCASE
		         ENDSCAN
		
		**************************************
		*  Do the calculations for YTD and QTD
		**************************************
		         tcPRYear  = YEAR(checktmp.dcheckdate)
		         tcPRMonth = MONTH(checktmp.dcheckdate)
		
		         DO CASE
		            CASE BETWEEN(tcPRMonth, 1, 3)
		               tcBegMonth = 1
		               tcEndMonth = 3
		            CASE BETWEEN(tcPRMonth, 4, 6)
		               tcBegMonth = 4
		               tcEndMonth = 6
		            CASE BETWEEN(tcPRMonth, 7, 9)
		               tcBegMonth = 7
		               tcEndMonth = 9
		            OTHERWISE
		               tcBegMonth = 10
		               tcEndMonth = 12
		         ENDCASE
		
		         SWSELECT('prdata')  &&  Build the QTD cursor
				 SELECT  cempid,  ;
						 SUM(nTotInc) AS nTotWageQ,  ;
						 SUM(nFedWH + nFedWHExt) AS nFedWHQ,  ;
						 SUM(nFica) AS nFicaWHQ,  ;
						 SUM(nMedicare) AS nMedWHQ,  ;
						 SUM(nStateWH + nStWHExt) AS nStateWHQ,  ;
						 SUM(nLocal1 + nLocal2) AS nLocalWHQ,  ;
						 SUM(nDeduct1 + nDeduct2 + nDeduct3 + nDeduct4 + nDeduct5 + nDeduct6) AS nMiscWHQ,  ;
						 SUM(nNetPay) AS nNetPayQ  ;
					 FROM prdata  ;
					 INTO CURSOR PRTmpQ  ;
					 WHERE YEAR(dPayDate) = tcPRYear  ;
						 AND BETWEEN(MONTH(dPayDate), tcBegMonth, tcEndMonth)  ;
						 AND dPayDate <= checktmp.dcheckdate  ;
						 AND cempid = checktmp.cid  ;
					 GROUP BY cempid
		
		         SWSELECT('prdata')  &&  Build the YTD cursor
				 SELECT  cempid,  ;
						 SUM(nTotInc) AS nTotWageY,  ;
						 SUM(nFedWH + nFedWHExt) AS nFedWHY,  ;
						 SUM(nFica) AS nFicaWHY,  ;
						 SUM(nMedicare) AS nMedWHY,  ;
						 SUM(nStateWH + nStWHExt) AS nStateWHY,  ;
						 SUM(nLocal1 + nLocal2) AS nLocalWHY,  ;
						 SUM(nDeduct1 + nDeduct2 + nDeduct3 + nDeduct4 + nDeduct5 + nDeduct6) AS nMiscWHY,  ;
						 SUM(nNetPay) AS nNetPayY  ;
					 FROM prdata  ;
					 INTO CURSOR PRTmpY  ;
					 WHERE YEAR(dPayDate) = tcPRYear  ;
						 AND dPayDate <= checktmp.dcheckdate  ;
						 AND cempid = checktmp.cid  ;
					 GROUP BY cempid
		
		         SELECT PRTmpQ
		         SCATTER MEMVAR
		         SELECT PRTmpY
		         SCATTER MEMVAR
		
		      ENDSCAN
		      INSERT INTO stub FROM MEMVAR
		   ENDSCAN
		
		   SELECT pickchks
		   SET FILTER TO
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'StubPR', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the Checks at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE stubprog		&& Stub for program distributions
		LOCAL llReturn, loError
		*:Global cProgName, cprogcode, dPostDate, nTotalDist, tcBegMonth, tcEndMonth, tcPRMonth, tcPRYear
		llReturn = .T.
		
		TRY
		*
		*  Stub program for program distributions
		*
		   CREATE CURSOR stub ;
		      (cid            C(10), ;
		        cprogname      C(10), ;
		        creference     C(30), ;
		        dPostDate      D, ;
		        cpayee         C(40), ;
		        npercentage    N(11, 7),  ;
		        nAmount        N(12, 2), ;
		        nTotalDist     N(12, 2), ;
		        nYearDist      N(12, 2), ;
		        nQtrDist       N(12, 2), ;
		        nYearShare     N(12, 2), ;
		        nQtrShare      N(12, 2), ;
		        cidchec        C(8),  ;
		        ccheckno       C(10))
		   INDEX ON cidchec TAG cidchec
		
		   SELECT checktmp
		   SCAN
		      SCATTER MEMVAR
		      SWSELECT('proghstd')
		      SCAN FOR cidchec = m.cidchec
		         SCATTER MEMVAR
		
		         SWSELECT('proghsth')
		         LOCATE FOR cBatch = m.cBatch
		         IF FOUND()
		            m.nTotalDist = nDistAmt
		            m.dPostDate  = dPostDate
		            m.cprogcode  = cprogcode
		         ELSE
		            m.nTotalDist = 0
		            m.dPostDate  = {}
		            m.cprogcode  = ''
		         ENDIF
		
		         SWSELECT('programs')
		         LOCATE FOR cprogcode = m.cprogcode
		         IF FOUND()
		            m.cprogname = cprogname
		         ELSE
		            m.cprogname = ''
		         ENDIF
		
		**************************************
		*  Do the calculations for YTD and QTD
		**************************************
		         tcPRYear  = YEAR(checktmp.dcheckdate)
		         tcPRMonth = MONTH(checktmp.dcheckdate)
		
		         DO CASE
		            CASE BETWEEN(tcPRMonth, 1, 3)
		               tcBegMonth = 1
		               tcEndMonth = 3
		            CASE BETWEEN(tcPRMonth, 4, 6)
		               tcBegMonth = 4
		               tcEndMonth = 6
		            CASE BETWEEN(tcPRMonth, 7, 9)
		               tcBegMonth = 7
		               tcEndMonth = 9
		            OTHERWISE
		               tcBegMonth = 10
		               tcEndMonth = 12
		         ENDCASE
		
		*  Build the QTD cursor
				 SELECT  proghstd.cownerid,  ;
						 SUM(proghsth.nDistAmt) AS nQtrDist,  ;
						 SUM(proghstd.nAmount)  AS nQtrShare  ;
					 FROM proghstd, proghsth  ;
					 INTO CURSOR PRTmpQ  ;
					 WHERE proghstd.cBatch = proghsth.cBatch ;
						 AND YEAR(proghsth.dPostDate) = tcPRYear  ;
						 AND BETWEEN(MONTH(proghsth.dPostDate), tcBegMonth, tcEndMonth)  ;
						 AND proghsth.dPostDate <= checktmp.dcheckdate  ;
						 AND proghstd.cownerid = checktmp.cid  ;
					 GROUP BY cownerid
		
		*  Build the YTD cursor
				 SELECT  proghstd.cownerid,  ;
						 SUM(proghsth.nDistAmt) AS nYearDist,  ;
						 SUM(proghstd.nAmount) AS nYearShare  ;
					 FROM proghstd, proghsth  ;
					 INTO CURSOR PRTmpY  ;
					 WHERE proghstd.cBatch = proghsth.cBatch ;
						 AND YEAR(proghsth.dPostDate) = tcPRYear  ;
						 AND proghsth.dPostDate <= checktmp.dcheckdate  ;
						 AND proghstd.cownerid = checktmp.cid  ;
					 GROUP BY cownerid
		
		
		         SELECT PRTmpQ
		         SCATTER MEMVAR
		         SELECT PRTmpY
		         SCATTER MEMVAR
		
		      ENDSCAN
		      INSERT INTO stub FROM MEMVAR
		   ENDSCAN
		
		   SELECT pickchks
		   SET FILTER TO
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'StubProg', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the checks at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE updatereg		&& Updates the check register with check numbers printed.
		LPARA tcCheckNo, tcChkType, tcFirstChk, tcLastChk
		LOCAL lcidchec, lcNextChk, lcAcctNo, llVoidNext, llAlpha
		LOCAL lCleared, lPrinted, lVoid, lcBatch, lcDigit, llReturn, lnDigit, lnLen, lnx, loError
		*:Global cEntryType, cacctno, ccheckno, cidChec, dRecDate, nAmount
		
		llReturn = .T.
		
		TRY
		   *
		   *  Don't do any updating if none of the checks printed ok.
		   *
		   IF tcCheckNo = tcFirstChk
		      llReturn = .T.
		      EXIT
		   ENDIF
		
		   STORE .F. TO llVoidNext
		
		   WAIT WIND NOWAIT 'Updating Check Register With Check Numbers, Please Wait...'
		
		   *  Get the cash account
		   lcAcctNo = THISFORM.cboAcct.VALUE
		
		   IF tcChkType = 'DM'
		      SWSELECT('options')
		      llVoidNext = lVoidNext
		   ENDIF
		   IF tcChkType = 'AP'
		      SWSELECT('apopt')
		      llVoidNext = lVoidNext
		   ENDIF
		
		   *
		   *  Calculate the next check number to use when printing checks
		   *  the next time
		   *
		   llAlpha = .F.
		
		   *!*	   FOR lnx = 1 TO LEN(ALLTRIM(tcLastChk))
		   *!*	      IF NOT ISDIGIT(SUBSTR(ALLTRIM(tcLastChk), lnx, 1))
		   *!*	         llAlpha = .T.
		   *!*	      ENDIF
		   *!*	   ENDFOR
		
		   IF EMPTY(tcCheckNo)
		      IF llAlpha
		         lcNextChk = ALLTRIM(tcLastChk)
		         lnLen     = LEN(lcNextChk)
		         lnDigit   = SUBSTR(lcNextChk, lnLen, 1)
		         IF ISDIGIT(lnDigit)
		            lcDigit   = TRANSFORM(VAL(lnDigit) + 1)
		            lcNextChk = SUBSTR(lcNextChk, 1, lnLen - 1) + lcDigit
		         ELSE
		            lcNextChk = lcNextChk + '1'
		         ENDIF
		      ELSE
		         lcNextChk = PADL(TRANSFORM(VAL(tcLastChk) + 1), 10, ' ')
		      ENDIF
		   ELSE
		      lcNextChk = tcCheckNo
		   ENDIF
		
		   SELECT checktmp
		   SCAN
		      lcidchec   = cidChec
		      m.ccheckno = ccheckno
		
		      SELECT SELECTED
		      LOCATE FOR cidChec = lcidchec
		      IF FOUND()
		         LOOP
		      ENDIF
		
		      SWSELECT('checks', .T.)
		      SET ORDER TO cidChec
		      *
		      *  Look for the check in the check register. Plug in
		      *  the check number that the check was printed on.
		      *
		      IF SEEK (lcidchec)
		         REPLACE ccheckno WITH m.ccheckno, ;
		            lPrinted WITH .T.
		         m.cidChec = cidChec
		         IF tcChkType = 'AP'
		            *
		            *  Place the check number in the cash and payment journals
		            *
		            IF NOT m.goapp.lQBVersion
		               SWSELECT('csdishdr')
		               SCAN FOR cidChec = m.cidChec
		                  lcBatch = cBatch
		                  REPLACE ccheckno WITH m.ccheckno
		               ENDSCAN
		
		               SWSELECT('appmtdet')
		               SCAN FOR cidChec = m.cidChec
		                  REPLACE ccheckno WITH m.ccheckno
		               ENDSCAN
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   SWSELECT('checks', .T.)
		   SET ORDER TO cidChec
		
		   *  Get the cash account
		   lcAcctNo = THISFORM.cboAcct.VALUE
		
		
		   IF llVoidNext  &&  Add any voided checks to the register
		      IF USED('chkvoid')
		         SELE chkvoid
		         SCAN FOR cDesc = 'VOID' AND ccheckno < lcNextChk
		            SCATTER MEMVAR
		            m.lCleared   = .T.
		            m.dRecDate   = m.dcheckdate
		            m.nAmount    = 0
		            m.lPrinted   = .T.
		            m.lVoid      = .T.
		            m.cEntryType = 'C'
		            m.cidChec    = THIS.oregistry.incrementcounter('%Shared.Counters.Checks')
		            DO WHILE INDEXSEEK(m.cidChec, .F., 'Checks')
		               m.cidChec = THIS.oregistry.incrementcounter('%Shared.Counters.Checks')
		            ENDDO
		            m.cacctno = lcAcctNo
		            INSERT INTO checks FROM MEMVAR
		         ENDSCAN
		      ENDIF
		   ENDIF
		
		   *
		   *  Save the next available check number in the
		   *  appropriate option file.
		   *
		   IF m.goapp.lAMVersion
		      SWSELECT('coa', .T.)
		      SET ORDER TO acctno
		      IF SEEK(lcAcctNo)
		         REPL ccheckno WITH lcNextChk
		      ENDIF
		      = TABLEUPDATE(.T.)
		      SWSELECT('csdishdr', .T.)
		      = TABLEUPDATE(.T.)
		      SWSELECT('appmtdet', .T.)
		      = TABLEUPDATE(.T.)
		   ELSE
		      SWSELECT('options', .T.)
		      GO TOP
		      REPLACE ccheckno WITH lcNextChk
		      = TABLEUPDATE(.T.)
		   ENDIF
		
		   SWSELECT('checks', .T.)
		   = TABLEUPDATE(.T.)
		
		   THISFORM.txtcbegcheckno.REFRESH()
		
		   *
		   *  Ask if a check register should be printed for the checks
		   *  that were printed.
		   *
		   IF THISFORM.laskok = .T.
		      IF ALLTRIM(tcCheckNo) <> ALLTRIM(tcFirstChk)
		         IF THISFORM.oMessage.CONFIRM('Do you want to print a check register? ' + ;
		               '(Make sure you remove the check stock from the printer!)')
		            THISFORM.printregister(tcFirstChk, tcLastChk)
		         ENDIF
		      ENDIF
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'UpdateReg', loError.LINENO, 'Print Checks', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the checks at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		WAIT CLEAR
		
	ENDPROC

	PROCEDURE cboAcct.afterchange
		IF m.goapp.lAMVersion
		   SWSELECT('coa',.t.)
		   IF SEEK(THISFORM.cboAcct.VALUE)
		      THISFORM.txtAcctDesc.VALUE = cAcctDesc
		      THISFORM.txtAcctDesc.REFRESH()
		      THISFORM.opgCheckType.CLICK()
		   ENDIF
		ENDIF
		DODEFAULT()
		
		
	ENDPROC

	PROCEDURE cboAcct.Init
		LOCAL lnCount
		*
		*  Builds the data displayed in the combo list box
		*
		SWSELECT('glopt')
		lcUnDepFund = cUnDepFund
		
		SELECT  cAcctNo, cAcctDesc FROM coa INTO ARRAY laAcct WHERE lBankacct = .T. AND cAcctNo <> lcUnDepFund AND NOT DELETED() ORDER BY cAcctNo
		lnCount = _TALLY
		
		IF lnCount > 0
		   FOR lnX = 1 TO ALEN(laAcct,1)
		      IF laAcct[lnX,1] = lcUnDepFund
		         LOOP
		      ENDIF   
		      THIS.ADDLISTITEM(laAcct[lnX,1],lnX,1)
		      THIS.ADDLISTITEM(laAcct[lnX,2],lnX,2)
		   ENDFOR
		   THIS.LISTITEMID = 1
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cboSelect.Init
		this.listitemid = 2
		DODEFAULT()
	ENDPROC

	PROCEDURE cboSelect.Valid
		IF this.value = 'Selected Checks'
		   if thisform.chkpreview.value = .t.
		      thisform.cmdPrint.Caption = '\<Select/Preview'
		   else
		      thisform.cmdPrint.Caption = '\<Select Checks'
		   endif   
		ELSE
		   if thisform.chkpreview.value = .t.
		      thisform.cmdPrint.Caption = '\<Preview'
		   else
		      thisform.cmdPrint.Caption = '\<Print'
		   endif   
		ENDIF   
		      
	ENDPROC

	PROCEDURE chkPreview.Valid
		IF this.value 
		   IF thisform.cboselect.value = 'Selected Checks'
		      thisform.cmdPrint.caption = 'Select/\<Preview'
		   else
		      thisform.cmdPrint.caption = '\<Preview'
		   endif   
		ELSE   
		   IF thisform.cboselect.value = 'Selected Checks'
		      thisform.cmdPrint.caption = '\<Select Checks'
		   else
		      thisform.cmdPrint.caption = '\<Print'
		   endif   
		ENDIF   
	ENDPROC

	PROCEDURE cmdAlign.Click
		LOCAL tcModule
		LOCAL lcChkType, lcChkForm, lcAPName, lcPRName, lcDMName, lcLMName, llDupAP, llDupDM, lnAPLines, lnDMLines
		LOCAL lcAPCheckName, lcDMCheckName, lcPRCheckName, lcLMCheckName, llPreview, llAddDupes, llTwoLines
		
		llPreview = THISFORM.chkPreview.VALUE
		
		IF llPreview
		   lcPrint = 'PREVIEW'
		ELSE
		   lcPrint = 'TO PRINTER PROMPT NOCONSOLE NOEJECT'
		ENDIF
		
		DO CASE
		   CASE THISFORM.opgCheckType.VALUE = 1  &&  Owner Check
		      lcChkType = 'DM'
		   CASE THISFORM.opgCheckType.VALUE = 2  &&  Payroll check
		      lcChkType = 'PR'
		   CASE THISFORM.opgCheckType.VALUE = 3  &&  A/P Check
		      lcChkType = 'AP'
		   CASE THISFORM.opgCheckType.VALUE = 4  &&  Land check
		      lcChkType = 'LM'
		   CASE THISFORM.opgCheckType.VALUE = 5  &&  Program check
		      lcChkType = 'PD'
		ENDCASE
		
		llCommonMICR = FILE(m.goApp.cCommonFolder+'commonmicr.txt')
		
		tcModule = lcChkType
		
		 IF TYPE('m.goApp') = 'O'
		      m.cProducer = m.goApp.ccompanyname
		      m.paddr1    = m.goApp.cAddress1
		      m.paddr2    = m.goApp.cAddress2
		      m.paddr3    = m.goApp.cAddress3
		      m.ptax      = m.goApp.cTaxid
		      m.pcontact  = m.goApp.cContact
		      m.pphone    = m.goApp.cPhoneNo
		   ELSE
		      m.cProducer = 'SherWare, Inc.'
		      m.paddr1    = 'PO Box 209'
		      m.paddr2    = 'Apple Creek, OH 44606'
		      m.paddr3    = ''
		      m.ptax      = '12-34567'
		      m.pcontact  = 'Phil'
		      m.pphone    = '(330) 682-5882'
		   ENDIF
		   
		*  If printing vendor or owner checks, store the duplicate stub setting, and the # of lines
		SWSELECT('options')
		llTwoLines = lTwoLines
		
		IF LEFT(lcChkType,1) = 'D' OR LEFT(lcChkType,1) = 'A'  &&  Duplicate stub option marked, so warn them that the alignment won't print it
		   llDupDM = lDupStub
		   lnDMLines = nStubLine
		   swselect('apopt')
		   llDupAP = lDupStub
		   lnAPLines = nStubLine
		   llAddDupes = llDupDM OR llDupAP
		   
		   IF lnDMLines = 0
		      lnDMLines = 12
		   ENDIF
		   IF lnAPLines = 0
		      lnAPLines = 12
		   ENDIF 
		ENDIF
		
		IF TYPE('m.goApp') = 'O'
		   gcPath = ALLTRIM(m.goApp.cDataFilePath)
		ELSE
		   gcPath = m.goApp.cChecksFolder+''
		ENDIF
		
		*  Check to see if the check names were specified
		SWSELECT('glopt')
		GO TOP
		llCheckNames = lCheckNames
		
		*  Get the cash account
		lcAcctNo = THISFORM.cboAcct.VALUE
		
		*  Get the check names
		IF llCheckNames
		   IF m.goApp.lAMVersion
		      SWSELECT('coa',.T.)
		      SET ORDER TO acctno
		      IF SEEK(lcAcctNo)
		         lcAPCheckName = cAPCheckName
		         lcDMCheckName = cDMCheckName
		         lcPRCheckName = cPRCheckName
		         lcLMCheckName = cLMCheckName
		         lcPDCheckName = ''
		      ENDIF
		   ELSE
		      STORE ' ' TO lcAPCheckName, lcDMCheckName, lcPRCheckName, lcLMCheckName, lcPDCheckName
		   ENDIF
		ENDIF
		
		*  Get the type of check
		DO CASE
		   CASE lcChkType = 'AP'
		      SWSELECT('apopt',.T.)
		      GO TOP
		      IF NOT EMPTY(cCheckType)
		         lcChkForm = 'A' + cCheckType
		      ELSE
		         *  Replace a blank check type with Laser - Stub Below.
		         REPLACE cCheckType WITH 'LV'
		         lcChkForm = 'ALV'
		         =TABLEUPDATE(.T.)
		      ENDIF
		   CASE lcChkType = 'DM'
		      SWSELECT('options',.T.)
		      IF NOT EMPTY(cCheckType)
		         lcChkForm = 'D' + cCheckType
		         *  Store option for enhanced stub
		         llTwoLines = lTwoLines
		      ELSE
		         *  Replace a blank check type with Laser - Stub Below.
		         REPLACE cCheckType WITH 'LV'
		         lcChkForm = 'DLV'
		         =TABLEUPDATE(.T.)
		      ENDIF
		   CASE lcChkType = 'PR'
		      SWSELECT('propt',.T.)
		      IF NOT EMPTY(cCheckType)
		         lcChkForm = 'PR' + cCheckType
		      ELSE
		         *  Replace a blank check type with Laser - Stub Below.
		         REPLACE cCheckType WITH 'LV'
		         lcChkForm = 'PRLV'
		         =TABLEUPDATE(.T.)
		      ENDIF
		   CASE lcChkType = 'PD'
		      SWSELECT('progopt',.T.)
		      IF NOT EMPTY(cCheckType)
		         lcChkForm = 'PD' + cCheckType
		      ELSE
		         *  Replace a blank check type with Laser - Stub Below.
		         REPLACE cCheckType WITH 'LV'
		         lcChkForm = 'PDLV'
		         =TABLEUPDATE(.T.)
		      ENDIF
		   CASE lcChkType = 'LM'
		      SWSELECT('landopt',.T.)
		      IF NOT EMPTY(cCheckType)
		         lcChkForm = 'L' + cCheckType
		      ELSE
		         *  Replace a blank check type with Laser - Stub Below.
		         REPLACE cCheckType WITH 'LV'
		         lcChkForm = 'LLV'
		         =TABLEUPDATE(.T.)
		      ENDIF
		ENDCASE
		
		CREATE CURSOR checktmp ;
		   (cID        C(10),    ;
		   cidtype    C(1),     ;
		   ncount     I, ;
		   cidchec    C(8),     ;
		   ccheckno   C(10),     ;
		   dcheckdate D,        ;
		   cpayee     C(60),    ;
		   cpayee2    C(60),    ;
		   cNAME      C(60),    ;
		   namount    N(12,2),  ;
		   cwordnum   C(100),   ;
		   caddr1     C(40),    ;
		   caddr2     C(40),    ;
		   caddr3     C(40),    ;
		   cmemo      C(60), ;
		   cbankname  c(40), ;
		   onus       C(15), ;
		   transitno  C(15), ;
		   csigfile   V(254))
		
		IF tcModule <> 'PR'
		   CREATE CURSOR stub ;
		      (cID            C(10), ;
		      ipage          I, ;
		      cidtype        C(1), ;
		      npageno        I, ;
		      cpayee         C(60), ;
		      cpayee2        C(60),    ;
		      cprogcode      C(10), ;
		      ccheckno       C(10), ;
		      cidchec        C(8), ;
		      cwellid        C(10), ;
		      cwellname      C(30), ;
		      nincome        N(9,2), ;
		      nbbl           N(12,2), ;
		      cIncType       C(1), ;
		      nmcf           N(12,2), ;
		      nbblprice      N(12,6), ;
		      nmcfprice      N(12,6), ;
		      noilrev        N(12,2), ;
		      ngasrev        N(12,2), ;
		      cIntType       C(1), ;
		      cDesc          C(60), ;
		      cinvnum        C(15), ;
		      dinvdate       D, ;
		      dcheckdate     D, ;
		      dpmtdate       D,  ;
		      nacres         N(12,2),  ;
		      npmtacre       N(12,2), ;
		      nrental        N(12,2),  ;
		      ninvtot        N(12,2), ;
		      namtpaid       N(12,2), ;
		      ndisctot       N(12,2), ;
		      namount        N(12,2), ;
		      npercentage    N(11,7), ;
		      dproddate      D, ;
		      nexpense       N(9,2), ;
		      ntaxes         N(9,2), ;
		      nnetcheck      N(9,2), ;
		      creference     C(20), ;
		      nOTHER         N(9,2), ;
		      cprodprd       C(5), ;
		      nunits         N(6,2), ;
		      nprice         N(12,2), ;
		      ntotalinc      N(12,2), ;
		      ntax           N(12,2), ;
		      ntax1          N(12,2), ;
		      ntax2          N(12,2),  ;
		      ntax3          N(12,2),  ;
		      ntax4          N(12,2),  ;
		      nnetval        N(12,2), ;
		      ninterest      N(11,7), ;
		      nOwnTax        N(11,7),  ;
		      nowngross      N(12,2), ;
		      cRptGroup      C(1),     ;
		      cleasename     C(40),  ;
		      cLeaseID       C(10),  ;
		      cnotes         C(40),  ;
		      ccounty        c(40),  ;
		      cstate         c(2),  ;
		      dPostDate      D,  ;
		      cProgName      C(30),  ;
		      nTotalDist     N(12,2),  ;
		      nQtrDist       N(12,2),  ;
		      nQtrShare      N(12,2),  ;
		      nYearDist      N(12,2),  ;
		      nYearShare     N(12,2),  ;
		      lSkip          L, ;
		      cGROUP         C(2), ;
		      nbackwith      N(12, 2), ;
		      ntaxwith       N(12, 2))
		   INDEX ON cID+cGROUP+cprogcode+cRptGroup TAG cID
		   INDEX ON cidchec TAG cidchec
		
		ELSE
		   CREATE CURSOR stub ;
		      (cID           C(10), ;
		      ipage          I, ;
		      dPrdEnd        D, ;
		      dPayDate       D, ;
		      cpayee         C(60), ;
		      cpayee2        C(60),    ;
		      nRegRate       N(8,3), ;
		      nRegHours      N(5,2), ;
		      nRegAmt        N(12,2), ;
		      nOv1Hours      N(5,2), ;
		      nOv1Amt        N(12,2), ;
		      nOv2Hours      N(5,2), ;
		      nOv2Amt        N(12,2), ;
		      nOtherInc      N(12,2), ;
		      nTotInc        N(12,2), ;
		      nTotWageC      N(12,2), ;
		      nTotWageQ      N(12,2), ;
		      nTotWageY      N(12,2), ;
		      nFedWHC        N(9,2), ;
		      nFedWHQ        N(9,2), ;
		      nFedWHY        N(9,2), ;
		      nMedWHC        N(9,2), ;
		      nMedWHQ        N(9,2), ;
		      nMedWHY        N(9,2), ;
		      nFicaWHC       N(9,2), ;
		      nFicaWHQ       N(9,2), ;
		      nFicaWHY       N(9,2), ;
		      nStateWHC      N(9,2), ;
		      nStateWHQ      N(9,2), ;
		      nStateWHY      N(9,2), ;
		      nLocalWHC      N(9,2), ;
		      nLocalWHQ      N(9,2), ;
		      nLocalWHY      N(9,2), ;
		      nMiscWHC       N(9,2), ;
		      nMiscWHQ       N(9,2), ;
		      nMiscWHY       N(9,2), ;
		      nNetPayC       N(12,2), ;
		      nNetPayQ       N(12,2), ;
		      nNetPayY       N(12,2), ;
		      cincome1       C(20),  ;
		      cincome2       C(20),  ;
		      cincome3       C(20),  ;
		      cincome4       C(20),  ;
		      cincome5       C(20),  ;
		      nincome1       N(9,2),  ;
		      nincome2       N(9,2),  ;
		      nincome3       N(9,2),  ;
		      nincome4       N(9,2),  ;
		      nincome5       N(9,2),  ;
		      cDeduct1       C(20), ;
		      cDeduct2       C(20), ;
		      cDeduct3       C(20), ;
		      cDeduct4       C(20), ;
		      cDeduct5       C(20), ;
		      cDeduct6       C(20), ;
		      nDeduct1       N(9,2), ;
		      nDeduct2       N(9,2), ;
		      nDeduct3       N(9,2), ;
		      nDeduct4       N(9,2), ;
		      nDeduct5       N(9,2), ;
		      nDeduct6       N(9,2), ;
		      cidchec        C(8),  ;
		      cnotes         C(40),  ;
		      ccheckno       C(10))
		   INDEX ON cID+cidchec TAG cID
		
		ENDIF
		
		SELECT stub
		SCATTER MEMVAR BLANK
		
		m.ipage    = 1
		m.ncount   = 1
		m.cprodprd = '99/99'
		m.cID      = 'PAYEE ID'
		m.cidtype  = 'I'
		m.ccheckno = '9999999999'
		m.dcheckdate    = {^1980-01-01}
		m.namount  = 999999.99
		m.cNAME    = 'VOID'
		m.cpayee   = 'VOID PAYEE NAME VOID PAYEE NAME'
		m.cpayee2 = 'VOID PAYEE NAME2 VOID PAYEE NAME2'
		m.cidchec = 'ABCDEFGH'
		m.cwordnum = 'WRITTEN AMOUNT VOID WRITTEN AMOUNT VOID WRITTEN AMOUNT VOID'
		m.caddr1   = 'ADDRESS1 ADDRESS1 ADDRESS1 ADDRESS1'
		m.caddr2   = 'ADDRESS2 ADDRESS2 ADDRESS2 ADDRESS2'
		m.caddr3   = 'ADDRESS3 ADDRESS3 ADDRESS3 ADDRESS3'
		m.cmemo    = 'MEMO MEMO MEMO MEMO MEMO MEMO MEMO MEMO'
		m.prodadd1   = REPL('X',40)
		m.prodadd2   = REPL('X',40)
		m.prodadd3   = REPL('X',40)
		m.bankname   = 'Bank Name'
		m.bankadd1   = 'Bank Address 1'
		m.bankadd2   = 'Bank Address 2'
		m.crouteno    = 'Route No'
		m.ctransitno  = '{999999999{'
		m.conus       = '999999999999>'
		m.cincome1 = 'Income1'
		m.cincome2 = 'Income2'
		m.cincome3 = 'Income3'
		m.cincome4 = 'Income4'
		m.cincome5 = 'Income5'
		m.nincome1 = 99999.99
		m.nincome2 = 99999.99
		m.nincome3 = 99999.99
		m.nincome4 = 99999.99
		m.nincome5 = 99999.99
		m.lSkip = .F.
		m.cBankName = 'SHERWARE BANK'
		INSERT INTO checktmp FROM MEMVAR
		
		m.cwellname = 'Test Print'
		m.cwellid   = 'TESTWELL'
		m.progcode = 'XXXX'
		m.cleasename = 'TEST LEASE'
		m.cLeaseID = 'LEASE ID'
		m.income   = 999999.99
		m.nexpense  = 999999.99
		m.ntaxes    = 9999.99
		m.nOTHER    = 999999.99
		m.nnetcheck = 999999.99
		m.cDesc    = 'TestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTestTest'
		m.namount   = 99999.99
		m.dPrdEnd  = DATE()
		m.dPayDate = DATE()
		m.dpmtdate = DATE()
		m.cIncType = 'G'
		m.nunits = 99.99
		m.cprodprd = '01/99'
		m.nprice = 99.99
		m.ntotalinc = 999.99
		m.ntaxes = 99.99
		m.ntax1 = 99.99
		m.ntax2 = 99.99
		m.ntax3 = 99.99
		m.ntax4 = 99.99
		m.nnetval = 99.99
		m.ninterest = 99.9999
		m.nexpense = 99.99
		m.nnetcheck = 99.99
		m.nacres = 9999.99
		m.nrental = 9999.99
		m.ninvtot = 99.99
		m.nOwnTax = 99.99
		m.cDeduct1 = 'Deduct1'
		m.cDeduct2 = 'Deduct2'
		m.cDeduct3 = 'Deduct3'
		m.cDeduct4 = 'Deduct4'
		m.cDeduct5 = 'Deduct5'
		m.cDeduct6 = 'Deduct6'
		m.cinvnum = 'Invoice No'
		m.dinvdate = DATE()
		m.creference = 'Reference'
		m.dPostDate = DATE()
		m.cProgName = 'Program Name'
		m.cRptGroup = 'A'
		m.cCounty = 'COUNTY'
		m.cState = 'TX'
		
		m.cnotes = 'TEST NOTE TEST NOTE TEST NOTE TEST NOTE TEST NOTE'
		STORE 99.99 TO m.nRegHours, m.nRegRate, m.nRegAmt, m.nOv1Hours, m.nOv2Hours, ;
		   m.nOv1Amt, m.nOv2Amt, m.nOtherInc, m.nTotInc, m.nTotWageC, ;
		   m.nTotWageQ, m.nTotWageY, m.nFedWHC, m.nFedWHQ, m.nFedWHY, ;
		   m.nFicaWHC, m.nFicaWHQ, m.nFicaWHY, m.nStateWHC, m.nStateWHQ,npercentage
		STORE 999.99 TO m.nStateWHY, m.nLocalWHC, m.nLocalWHQ, m.nLocalWHY, ;
		   m.nMiscWHC, m.nMiscWHQ, m.nMiscWHY, m.nNetPayC, m.nNetPayQ, ;
		   m.nNetPayY, m.nDeduct1, m.nDeduct2, m.nDeduct3, m.nDeduct4, ;
		   m.nDeduct5, m.nDeduct6, nTotalDist,nQtrDist,nQtrShare,nYearDist,nYearShare
		
		INSERT INTO stub FROM MEMVAR
		
		
		*  Either the AP or Owner check is set to print duplicates, so check the settings and add as many lines as needed
		IF llAddDupes
		   IF llDupAP AND LEFT(lcChkType,1) = 'A'
		      FOR lnX = 2 TO lnAPLines
		         INSERT INTO stub FROM memvar
		      ENDFOR
		      m.cRptGroup = 'B'
		      FOR lnX = 1 TO lnAPLines
		         INSERT INTO stub FROM memvar
		      ENDFOR
		   ENDIF
		   
		   IF llDupDM AND LEFT(lcChkType,1) = 'D'
		      FOR lnX = 2 TO lnDMLines
		         INSERT INTO stub FROM memvar
		      ENDFOR
		      m.cRptGroup = 'B'
		      FOR lnX = 1 TO lnDMLines
		         INSERT INTO stub FROM memvar
		      ENDFOR
		   ENDIF   
		   
		   SELECT checktmp
		   SET RELATION TO cidchec INTO stub
		   SET SKIP TO stub
		ENDIF 
		
		
		SELECT checktmp
		
		DO CASE
		   CASE lcChkForm = 'ADN'   && Dot-matrix (no voucher)
		      IF NOT llCheckNames
		         lcAPCheckName = m.goApp.cChecksFolder+'apchekdn.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With No Stub: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ADB'   && Dot-matrix (voucher below check)
		      IF NOT llCheckNames
		         lcAPCheckName = m.goApp.cChecksFolder+'apchekdb.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Below: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ADA'   && Dot-matrix (voucher above check)
		      IF NOT llCheckNames
		         lcAPCheckName = m.goApp.cChecksFolder+'apchekda.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Above: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ALN'   && Laser (no voucher)
		      IF NOT llCheckNames
		         lcAPCheckName = m.goApp.cChecksFolder+'apchekln.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With No Stub: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ALC'   && Laser (Check in middle)
		      IF NOT llCheckNames
		         lcAPCheckName = m.goApp.cChecksFolder+'apcheklc.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub In The Middle: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ALV'   && Laser (voucher below)
		      IF NOT llCheckNames
		         lcAPCheckName = m.goApp.cChecksFolder+'apcheklv.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Below: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ALA'   && Laser (voucher above)
		      IF NOT llCheckNames
		         lcAPCheckName = m.goApp.cChecksFolder+'apchekla.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Above: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ALE'   && Laser (voucher below and MICR encoded)
		      IF NOT llCheckNames
		         IF llCommonMICR
		            lcAPCheckName = ALLTRIM(m.goapp.cChecksFolder+'apchekle.frx')
		         ELSE 
		            lcAPCheckName = ALLTRIM(gcPath)+'apchekle.frx'
		         ENDIF    
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser MICR Checks With A Stub Below: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		      
		   CASE lcChkForm = 'ALI'   && Laser (voucher above and MICR encoded)
		      IF NOT llCheckNames
		         IF llCommonMICR
		            lcAPCheckName = ALLTRIM(m.goapp.cChecksFolder+'apchekli.frx')
		         ELSE 
		            lcAPCheckName = ALLTRIM(gcPath)+'apchekli.frx'
		         ENDIF    
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser MICR Checks With A Stub Above: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ALM'   && Laser (no voucher and MICR encoded - 3 up)
		      IF NOT llCheckNames
		         lcAPCheckName = ALLTRIM(gcPath)+'apcheklm.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser MICR Checks With No Stub: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'ACF'   && Custom Format
		      IF NOT llCheckNames
		         lcAPCheckName = ALLTRIM(m.goApp.cDataFilePath)+'apchekcf.frx'
		      ENDIF
		      IF NOT FILE(lcAPCheckName)
		         lcAPCheckName = STRTRAN(lcAPCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Custom Format Checks: ' + lcAPCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcAPCheckName) &lcPrint
		
		   CASE lcChkForm = 'DDN'   && Dot-matrix (no voucher)
		      IF NOT llCheckNames
		         lcDMCheckName = m.goApp.cChecksFolder+'dmchekdn.frx'
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With No Stub: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcDMCheckName) &lcPrint
		
		   CASE lcChkForm = 'DDB'   && Dot-matrix (voucher below check)
		      IF NOT llCheckNames
		         lcDMCheckName = m.goApp.cChecksFolder+'dmchekdb.frx'
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Below: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcDMCheckName) &lcPrint
		
		   CASE lcChkForm = 'DDA'   && Dot-matrix (voucher above check)
		      IF NOT llCheckNames
		         lcDMCheckName = m.goApp.cChecksFolder+'dmchekda.frx'
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Above: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcDMCheckName) &lcPrint
		
		   CASE lcChkForm = 'DLN'   && Laser (no voucher)
		      IF NOT llCheckNames
		         lcDMCheckName = m.goApp.cChecksFolder+'dmchekln.frx'
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With No Stub: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcDMCheckName) &lcPrint
		
		   CASE lcChkForm = 'DLC'   && Laser (Check in middle)
		      IF NOT llCheckNames
		         lcDMCheckName = m.goApp.cChecksFolder+'dmcheklc.frx'
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Check In The Middle: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcDMCheckName) &lcPrint
		
		   CASE lcChkForm = 'DLV'   && Laser (voucher below)
		      IF NOT llCheckNames
		         IF llTwoLines
		            *  Enhanced stub
		            lcDMCheckName = m.goApp.cChecksFolder+'dmcheklve.frx'
		         ELSE
		            lcDMCheckName = m.goApp.cChecksFolder+'dmcheklv.frx'
		         ENDIF 
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Below: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcDMCheckName) &lcPrint
		
		   CASE lcChkForm = 'DLA'   && Laser (voucher above)
		      IF NOT llCheckNames
		         lcDMCheckName = m.goApp.cChecksFolder+'dmchekla.frx'
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Above: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcDMCheckName) &lcPrint
		
		   CASE lcChkForm = 'DLE'   && Laser (voucher below and MICR encoded)
		      IF NOT llCheckNames
		         IF llCommonMICR
		            lcDMCheckName = ALLTRIM(m.goapp.cChecksFolder+'dmchekle.frx')
		         ELSE 
		            lcDMCheckName = ALLTRIM(gcPath)+'dmchekle.frx'
		         ENDIF    
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser MICR Checks With A Stub Below: ' + lcDMCheckName + CHR(10)+CHR(10) + ;
		            'The MICR characters are an optional module that must have been purchased in order to use this format.' + ;
		            ' Contact SherWare support for the MICR format you need or change the default check format in check printing preferences.',64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      m.transitno = 'A123456789A'
		      m.onus      = 'C1122334455C'
		      m.csigfile  = ''
		      m.cBankname = 'PNC BANK'
		      
		      SELECT checktmp
		      REPLACE onus WITH m.onus, transitno WITH m.transitno, csigfile WITH m.csigfile, cbankname WITH m.cbankname all
		      REPORT FORM (lcDMCheckName) &lcPrint
		      
		   CASE lcChkForm = 'DLI'   && Laser (voucher above and MICR encoded)
		      IF NOT llCheckNames
		         IF llCommonMICR
		            lcDMCheckName = ALLTRIM(m.goapp.cChecksFolder+'dmchekli.frx')
		         ELSE 
		            lcDMCheckName = ALLTRIM(gcPath)+'dmchekli.frx'
		         ENDIF    
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser MICR Checks With A Stub Above: ' + lcDMCheckName + CHR(10)+CHR(10) + ;
		            'The MICR characters are an optional module that must have been purchased in order to use this format.' + ;
		            ' Contact SherWare support for the MICR format you need or change the default check format in check printing preferences.',64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      m.transitno = 'A123456789A'
		      m.onus      = 'C1122334455C'
		      m.csigfile  = ''
		      m.cBankname = 'PNC BANK'
		      
		      SELECT checktmp
		      REPLACE onus WITH m.onus, transitno WITH m.transitno, csigfile WITH m.csigfile, cbankname WITH m.cbankname all
		      REPORT FORM (lcDMCheckName) &lcPrint      
		      
		   CASE lcChkForm = 'DLU'   && Laser (voucher and MICR encoded Check in Middle)
		      IF NOT llCheckNames
		         IF llCommonMICR
		            lcDMCheckName = ALLTRIM(m.goapp.cChecksFolder+'dmcheklu.frx')
		         ELSE 
		            lcDMCheckName = ALLTRIM(gcPath)+'dmcheklu.frx'
		         ENDIF    
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser MICR Checks With A Check in Middle: ' + lcDMCheckName + CHR(10)+CHR(10) + ;
		            'The MICR characters are an optional module that must have been purchased in order to use this format.' + ;
		            ' Contact SherWare support for the MICR format you need or change the default check format in check printing preferences.',64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      m.transitno = 'A123456789A'
		      m.onus      = 'C1122334455C'
		      m.csigfile  = ''
		      m.cBankname = 'PNC BANK'
		      
		      SELECT checktmp
		      REPLACE onus WITH m.onus, transitno WITH m.transitno, csigfile WITH m.csigfile, cbankname WITH m.cbankname all
		      REPORT FORM (lcDMCheckName) &lcPrint   
		
		   CASE lcChkForm = 'DLM'   && Laser (no voucher and MICR encoded - 3 up)
		      IF NOT llCheckNames
		         lcDMCheckName = ALLTRIM(gcPath)+'dmcheklm.frx'
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser MICR Checks With No Stub: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (gcPath+'dmcheklm.frx') &lcPrint
		
		   CASE lcChkForm = 'DCF'   && Custom Format
		      IF NOT llCheckNames
		         lcDMCheckName = ALLTRIM(m.goApp.cDataFilePath)+'dmchekcf.frx'
		      ENDIF
		      IF NOT FILE(lcDMCheckName)
		         lcDMCheckName = STRTRAN(lcDMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Below: ' + lcDMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcDMCheckName) &lcPrint
		
		   CASE lcChkForm = 'PRDB'   && Dot-matrix (voucher below check)
		      IF NOT llCheckNames
		         lcPRCheckName = m.goApp.cChecksFolder+'prchekdb.frx'
		      ENDIF
		      IF NOT FILE(lcPRCheckName)
		         lcPRCheckName = STRTRAN(lcPRCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Below: ' + lcPRCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPRCheckName) &lcPrint
		
		   CASE lcChkForm = 'PRDA'   && Dot-matrix (voucher above check)
		      IF NOT llCheckNames
		         lcPRCheckName = m.goApp.cChecksFolder+'prchekda.frx'
		      ENDIF
		      IF NOT FILE(lcPRCheckName)
		         lcPRCheckName = STRTRAN(lcPRCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Above: ' + lcPRCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPRCheckName) &lcPrint
		
		   CASE lcChkForm = 'PRLV'   && Laser - Voucher below
		      IF NOT llCheckNames
		         lcPRCheckName = m.goApp.cChecksFolder+'prcheklv.frx'
		      ENDIF
		      IF NOT FILE(lcPRCheckName)
		         lcPRCheckName = STRTRAN(lcPRCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Below: ' + lcPRCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPRCheckName) &lcPrint
		
		   CASE lcChkForm = 'LDN'   && Dot-matrix (no voucher)
		      IF NOT llCheckNames
		         lcLMCheckName = m.goApp.cChecksFolder+'Lmchekdn.frx'
		      ENDIF
		      IF NOT FILE(lcLMCheckName)
		         lcLMCheckName = STRTRAN(lcLMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With No Stub: ' + lcLMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcLMCheckName) &lcPrint
		
		   CASE lcChkForm = 'LDB'   && Dot-matrix (voucher below check)
		      IF NOT llCheckNames
		         lcLMCheckName = m.goApp.cChecksFolder+'Lmchekdb.frx'
		      ENDIF
		      IF NOT FILE(lcLMCheckName)
		         lcLMCheckName = STRTRAN(lcLMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Below: ' + lcLMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcLMCheckName) &lcPrint
		
		   CASE lcChkForm = 'LDA'   && Dot-matrix (voucher above check)
		      IF NOT llCheckNames
		         lcLMCheckName = m.goApp.cChecksFolder+'Lmchekda.frx'
		      ENDIF
		      IF NOT FILE(lcLMCheckName)
		         lcLMCheckName = STRTRAN(lcLMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Above: ' + lcLMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcLMCheckName) &lcPrint
		
		   CASE lcChkForm = 'LLN'   && Laser (no voucher)
		      IF NOT llCheckNames
		         lcLMCheckName = m.goApp.cChecksFolder+'Lmchekln.frx'
		      ENDIF
		      IF NOT FILE(lcLMCheckName)
		         lcLMCheckName = STRTRAN(lcLMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With No Stub: ' + lcLMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcLMCheckName) &lcPrint
		
		   CASE lcChkForm = 'LLV'   && Laser (voucher below)
		      IF NOT llCheckNames
		         lcLMCheckName = m.goApp.cChecksFolder+'Lmcheklv.frx'
		      ENDIF
		      IF NOT FILE(lcLMCheckName)
		         lcLMCheckName = STRTRAN(lcLMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Below: ' + lcLMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcLMCheckName) &lcPrint
		
		   CASE lcChkForm = 'LLA'   && Laser (voucher above)
		      IF NOT llCheckNames
		         lcLMCheckName = m.goApp.cChecksFolder+'Lmchekla.frx'
		      ENDIF
		      IF NOT FILE(lcLMCheckName)
		         lcLMCheckName = STRTRAN(lcLMCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Above: ' + lcLMCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcLMCheckName) &lcPrint
		
		   CASE lcChkForm = 'PDDN'   && Dot-matrix (no voucher)
		      IF NOT llCheckNames
		         lcLMCheckName = m.goApp.cChecksFolder+'pdchekdn.frx'
		      ENDIF
		      IF NOT FILE(lcPDCheckName)
		         lcPDCheckName = STRTRAN(lcPDCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With No Stub: ' + lcPDCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPDCheckName) &lcPrint
		
		   CASE lcChkForm = 'PDDB'   && Dot-matrix (voucher below check)
		      IF NOT llCheckNames
		         lcPDCheckName = m.goApp.cChecksFolder+'pdchekdb.frx'
		      ENDIF
		      IF NOT FILE(lcPDCheckName)
		         lcPDCheckName = STRTRAN(lcPDCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Below: ' + lcPDCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPDCheckName) &lcPrint
		
		   CASE lcChkForm = 'PDDA'   && Dot-matrix (voucher above check)
		      IF NOT llCheckNames
		         lcPDCheckName = m.goApp.cChecksFolder+'pdchekda.frx'
		      ENDIF
		      IF NOT FILE(lcPDCheckName)
		         lcPDCheckName = STRTRAN(lcPDCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Dot-Matrix Checks With A Stub Above: ' + lcPDCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPDCheckName) &lcPrint
		
		   CASE lcChkForm = 'PDLN'   && Laser (no voucher)
		      IF NOT llCheckNames
		         lcPDCheckName = m.goApp.cChecksFolder+'pdchekln.frx'
		      ENDIF
		      IF NOT FILE(lcPDCheckName)
		         lcPDCheckName = STRTRAN(lcPDCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With No Stub: ' + lcPDCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPDCheckName) &lcPrint
		
		   CASE lcChkForm = 'PDLV'   && Laser (voucher below)
		      IF NOT llCheckNames
		         lcPDCheckName = m.goApp.cChecksFolder+'pdcheklv.frx'
		      ENDIF
		      IF NOT FILE(lcPDCheckName)
		         lcPDCheckName = STRTRAN(lcPDCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Below: ' + lcPDCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPDCheckName) &lcPrint
		
		   CASE lcChkForm = 'PDLA'   && Laser (voucher above)
		      IF NOT llCheckNames
		         lcPDCheckName = m.goApp.cChecksFolder+'pdchekla.frx'
		      ENDIF
		      IF NOT FILE(lcPDCheckName)
		         lcPDCheckName = STRTRAN(lcPDCheckName,'\','\\')
		         MESSAGEBOX('Cannot Find Check Report File For Laser Checks With A Stub Above: ' + lcPDCheckName,64,'Check Format Not Found' )
		         RETURN
		      ENDIF
		      REPORT FORM (lcPDCheckName) &lcPrint
		
		ENDCASE
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdPrint.Click
		LOCAL lcChkType, lcAcctNo
		
		*
		*  Look at the nCheckCount property to see if there's 
		*  any checks to print of this type in this account.
		*  This property is set by the countchecks method.
		IF thisform.nCheckCount = 0
		   thisform.oMessage.Display('There are not any checks to print of this type in this account...')
		   RETURN
		ENDIF
		
		lcFirstChk = THISFORM.txtcBegCheckNo.VALUE
		lcCheckNo  = lcFirstChk
		
		IF EMPTY(lcFirstChk)
		   THISFORM.omessage.warning('Please specify a beginning check number.')
		   THISFORM.SETNEXTcontrol(THISFORM.txtcBegCheckNo)
		   RETURN
		ENDIF
		  
		*
		*  Determine the type of check to print
		*
		DO CASE
		   CASE thisform.opgCheckType.value = 1
		      lcChkType = 'DM'
		   CASE thisform.opgCheckType.value = 2
		      lcChkType = 'PR'   
		   CASE thisform.opgCheckType.value = 3
		      lcChkType = 'AP'   
		   CASE thisform.opgCheckType.value = 4
		      lcChkType = 'LM'      
		   CASE thisform.opgCheckType.value = 5
		      lcChkType = 'PD'         
		ENDCASE
		
		*
		*  Get the cash acct number
		*
		lcAcctNo = thisform.cboAcct.value
		      
		*
		*  Either Send All the available checks of the type chosen to print
		*  or send the user to a check selection form.
		*
		DO CASE
		   CASE thisform.cboSelect.value = 'All Checks'
		      thisform.selectallchecks(lcChkType, lcAcctNo)
		      thisform.cOrder = ORDER('picktmp')
		      thisform.loadcursor()
		      thisform.printchecks(lcChkType)
		   
		   CASE thisform.cboSelect.value = 'Selected Checks'   
		      llReturn = .F.
		      DO FORM cspickchk WITH lcChkType, lcAcctNo, thisform.chkzipCode.value TO llReturn
		      IF llReturn
		         thisform.cOrder = ORDER('picktmp')
		         thisform.loadcursor()
		         thisform.printchecks(lcChkType)
		      ENDIF   
		ENDCASE
		
		
		      
		      
		      
	ENDPROC

	PROCEDURE opgCheckType.Click
		LOCAL lcAcctNo
		
		IF m.goApp.lAMVersion
		   lcAcctNo = THISFORM.cboAcct.VALUE
		   SWSELECT('coa',.T.)
		   SET ORDER TO acctno
		   IF SEEK(lcAcctNo)
		      IF NOT EMPTY(coa.cCheckNo)  &&   Only fill in value if the next check # isn't blank, since we've already filled it in initially - BH 5-15-06
		         THISFORM.txtcBegCheckNo.VALUE = coa.cCheckNo
		         THISFORM.txtcBegCheckNo.REFRESH()
		      ENDIF
		   ENDIF
		ELSE
		   SWSELECT('options')
		   GO TOP
		   IF NOT EMPTY(options.cCheckNo)  &&   Only fill in value if the next check # isn't blank, since we've already filled it in initially - BH 5-15-06
		      THISFORM.txtcBegCheckNo.VALUE = options.cCheckNo
		      THISFORM.txtcBegCheckNo.REFRESH()
		   ENDIF
		   IF m.goapp.lQBVersion
		      lcAcctNo = THISFORM.qbaccount1.VALUE
		   ELSE
		      lcAcctNo = THISFORM.cboAcct.VALUE   
		   ENDIF    
		ENDIF
		
		*
		*  Get the count of checks and the first check number
		*  for the check type chosen
		*
		DO CASE
		   CASE THIS.VALUE = 1
		      THISFORM.countchecks('DM', lcAcctNo)
		      thisform.chkZipCode.Visible = .t. 
		      
		   CASE THIS.VALUE = 2
		      THISFORM.countchecks('PR', lcAcctNo)
		      thisform.chkZipCode.Visible = .f. 
		      thisform.chkZipCode.Value   = .F.
		
		   CASE THIS.VALUE = 3
		      THISFORM.countchecks('AP', lcAcctNo)
		      thisform.chkZipCode.Visible = .f.
		      thisform.chkZipCode.Value   = .F. 
		      SWSELECT('apopt')
		      GO TOP
		      IF NOT m.goApp.lAMVersion
		         SWSELECT('options')
		         GO TOP
		         THISFORM.txtcBegCheckNo.VALUE = options.cCheckNo
		         THISFORM.txtcBegCheckNo.REFRESH()
		      ENDIF
		
		   CASE THIS.VALUE = 4
		      THISFORM.countchecks('LM', lcAcctNo)
		      thisform.chkZipCode.Visible = .f.
		      thisform.chkZipCode.Value   = .F. 
		
		   CASE THIS.VALUE = 5
		      THISFORM.countchecks('PD', lcAcctNo)
		      thisform.chkZipCode.Visible = .f.
		      thisform.chkZipCode.Value   = .F. 
		
		ENDCASE
		
		
	ENDPROC

	PROCEDURE opgCheckType.Init
		thisform.opgCheckType.value = 1
		thisform.opgCheckType.Click()
		
		RETURN(DODEFAULT())
	ENDPROC

	PROCEDURE opgCheckType.Land.GotFocus
		thisform.opgCheckType.value = 4
		thisform.opgCheckType.click
	ENDPROC

	PROCEDURE opgCheckType.Owner.GotFocus
		thisform.opgCheckType.value = 1
		thisform.opgCheckType.click
	ENDPROC

	PROCEDURE opgCheckType.Payroll.GotFocus
		thisform.opgCheckType.value = 2
		thisform.opgCheckType.click
	ENDPROC

	PROCEDURE opgCheckType.Program.GotFocus
		thisform.opgCheckType.value = 5
		thisform.opgCheckType.click
	ENDPROC

	PROCEDURE opgCheckType.Vendor.GotFocus
		thisform.opgCheckType.value = 3
		thisform.opgCheckType.click
	ENDPROC

	PROCEDURE Qbaccount1.Init
		IF m.goapp.lQBVersion
		   IF m.goapp.lqbactive  &&  Only build lookup if an active QB connection exists
		      DODEFAULT()
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Qbaccount1.InteractiveChange
		LOCAL lcAcctNo, lcType
		lcAcctNo = THIS.VALUE
		
		DO CASE 
		   CASE thisform.opgCheckType.Value = 1
		      lcType = 'DM'
		   CASE thisform.opgcheckType.Value = 3
		      lcType = 'AP'
		   CASE thisform.opgCheckType.Value = 4
		      lcType = 'LM'
		   OTHERWISE
		      lcType = 'DM'
		ENDCASE 
		
		thisform.countchecks(lcType, lcAcctNo)
		
	ENDPROC

	PROCEDURE txtAcctDesc.When
		RETURN .F.    
	ENDPROC

	PROCEDURE txtcbegcheckno.LostFocus
		LOCAL lnx, llAlpha
		
		llAlpha = .f.
		
		FOR lnx = 1 TO LEN(ALLTRIM(this.Value))
		    IF NOT ISDIGIT(SUBSTR(ALLTRIM(this.Value),lnx,1))
		       llAlpha = .t.
		    ENDIF
		ENDFOR
		
		IF NOT llAlpha
		   this.value = PADL(TRANSFORM(INT(val(this.value))),10,' ')
		   this.refresh()
		ENDIF
		
		DODEFAULT()
	ENDPROC

ENDDEFINE
