*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="lmselchecks.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 563
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 829

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "landowner1", ;
		CursorSource = "landowner", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor10", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "landhist", ;
		BufferModeOverride = 5, ;
		CursorSource = "landhist", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor11", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "landhist1", ;
		CursorSource = "landhist", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 291, ;
		Name = "Cursor12", ;
		Top = 387, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "expsusp", ;
		BufferModeOverride = 5, ;
		CursorSource = "expsusp", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 450, ;
		Name = "Cursor13", ;
		Top = 142, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 579, ;
		Name = "Cursor14", ;
		Top = 19, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "expcat", ;
		CursorSource = "expcat", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 441, ;
		Name = "Cursor15", ;
		Top = 20, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "expense", ;
		BufferModeOverride = 5, ;
		CursorSource = "expense", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 430, ;
		Name = "Cursor16", ;
		Top = 260, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "leasewell", ;
		CursorSource = "leasewell", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor17", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "land", ;
		CursorSource = "land", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "landopt", ;
		CursorSource = "landopt", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "landowner", ;
		BufferModeOverride = 5, ;
		CursorSource = "landowner", ;
		Database = ..\..\dmie_rv\qbdata\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor9", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formlmselchecks AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cntmoverlistpair" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom6" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: createchks		&& Prints the selected invoices
		*m: updowner		&& Updates the owner file with the last payment info.
		*p: cheldowner
		*p: dcheckdate
		*a: aselected[1,0]
	*</DefinedPropArrayMethod>

	Caption = "Select Delay Rental Payments"
	cheldowner = 
	DataSession = 2
	DoCreate = .T.
	Height = 414
	HelpContextID = 110
	Name = "FormLmselchecks"
	Width = 659
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cmdCancel' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Cancel", ;
		FontBold = .T., ;
		Height = 36, ;
		Left = 334, ;
		Name = "cmdCancel", ;
		Top = 372, ;
		Width = 95
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS cmdcommandbuttoncustom WITH ;
		Caption = "C\<reate Checks", ;
		FontBold = .T., ;
		Height = 36, ;
		Left = 230, ;
		Name = "cmdOK", ;
		Top = 372, ;
		Width = 95
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cntmoverlistpair' AS cntmoverlistpair WITH ;
		Height = 349, ;
		Left = 0, ;
		Name = "Cntmoverlistpair", ;
		Top = 24, ;
		Width = 648, ;
		cmdDeselect.Caption = "De-Select", ;
		cmdDeselect.FontBold = .F., ;
		cmdDeselect.Height = 23, ;
		cmdDeselect.Left = 340, ;
		cmdDeselect.Name = "cmdDeselect", ;
		cmdDeselect.Top = 156, ;
		cmdDeselect.Width = 84, ;
		cmdDeselectAll.Caption = "De-Select All", ;
		cmdDeselectAll.FontBold = .F., ;
		cmdDeselectAll.Height = 23, ;
		cmdDeselectAll.Left = 424, ;
		cmdDeselectAll.Name = "cmdDeselectAll", ;
		cmdDeselectAll.Top = 156, ;
		cmdDeselectAll.Width = 84, ;
		cmdSelect.Caption = "Select", ;
		cmdSelect.FontBold = .F., ;
		cmdSelect.Height = 23, ;
		cmdSelect.Left = 172, ;
		cmdSelect.Name = "cmdSelect", ;
		cmdSelect.Top = 156, ;
		cmdSelect.Width = 84, ;
		cmdSelectAll.Caption = "Select All", ;
		cmdSelectAll.FontBold = .F., ;
		cmdSelectAll.Height = 23, ;
		cmdSelectAll.Left = 256, ;
		cmdSelectAll.Name = "cmdSelectAll", ;
		cmdSelectAll.Top = 156, ;
		cmdSelectAll.Width = 84, ;
		lstSelected.FontName = "Courier New", ;
		lstSelected.FontSize = 8, ;
		lstSelected.Height = 132, ;
		lstSelected.Left = 12, ;
		lstSelected.Name = "lstSelected", ;
		lstSelected.Top = 209, ;
		lstSelected.Width = 636, ;
		lstSource.FontName = "Courier New", ;
		lstSource.FontSize = 8, ;
		lstSource.Height = 138, ;
		lstSource.Left = 12, ;
		lstSource.Name = "lstSource", ;
		lstSource.Top = 12, ;
		lstSource.Width = 636
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="container" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Rentals That Are Due", ;
		FontBold = .T., ;
		Left = 12, ;
		Name = "Lbllabelcustom1", ;
		Top = -1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Rentals To Pay", ;
		FontBold = .T., ;
		Left = 12, ;
		Name = "Lbllabelcustom2", ;
		Top = 214
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		Caption = "Pmt Due", ;
		Left = 482, ;
		Name = "Lbllabelcustom3", ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom4' AS lbllabelcustom WITH ;
		Caption = "Amount", ;
		Left = 588, ;
		Name = "Lbllabelcustom4", ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom5' AS lbllabelcustom WITH ;
		Caption = "Lease Name", ;
		Left = 24, ;
		Name = "Lbllabelcustom5", ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom6' AS lbllabelcustom WITH ;
		Caption = "Owner Name", ;
		Left = 280, ;
		Name = "Lbllabelcustom6", ;
		Top = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />
	
	PROCEDURE createchks		&& Prints the selected invoices
		LOCAL m.caddr1, m.caddr2, m.caddr3, m.ccustname, m.shipln1, m.shipln2
		LOCAL m.shipln3, m.shipln4, m.paddr1, m.paddr2, m.paddr3, m.message
		LOCAL lnCount, lnX, lnChecks, oRegistry, oGLMaint
		LOCAL lReturn, laptran, lcBatch, lcCatCode, lcExpClear, llReturn, llValidExpense, lnAmount, lnDiff
		LOCAL lnTotalAmt, lnWells, loError
		LOCAL cCatCode, cLeaseID, cLeaseName, cOwnerID, cPaidByCk, cPayee, cProducer, ccateg, cexpclass
		LOCAL cidchec, cidexps, cidland, cunitno, cvendorid, cwellid, dexpdate, dpmtdate, nAcres, nAmount
		LOCAL nPmtAcre, nPmtAmount, paddr1, paddr2, paddr3
		
		llReturn = .T.
		
		TRY
		* Check on the existence of the application object
		* if it doesn't exist, we're running in development
		* mode and need to initialize the company address info.
		    IF TYPE('m.goApp') = 'O'
		        m.cProducer = m.goApp.cCompanyName
		        m.paddr1    = m.goApp.cAddress1
		        m.paddr2    = m.goApp.cAddress2
		        m.paddr3    = m.goApp.cAddress3
		    ELSE
		        m.cProducer = 'SherWare, Inc.'
		        m.paddr1    = 'PO Box 223'
		        m.paddr2    = 'Wooster, OH  44691'
		        m.paddr3    = ''
		    ENDIF
		
		    SELECT landopt
		    SCATTER MEMVAR
		    lcCatCode = m.cCatCode
		
		    SELE glopt
		    lcExpClear = cExpClear
		
		    IF m.goApp.lAMVersion
		        IF EMPTY(m.cCashAcct)
		            THISFORM.oMessage.Warning('The cash account for delay rental checks was not specified in the Preferences for Land Management. Checks cannot be created.')
		            llReturn = .F.
		            EXIT
		        ENDIF
		        IF EMPTY(m.cRentAcct)
		            THISFORM.oMessage.Warning('The rental account for delay rental checks was not specified in the Preferences for Land Management. Checks cannot be created.')
		            llReturn = .F.
		            EXIT
		        ENDIF
		    ENDIF
		
		    oGLMaint  = CREATEOBJECT('glmaint')
		    oRegistry = FindGlobalObject('cmRegistry')
		
		    lReturn = oRegistry.GetKeyValue('%Shared.Counters.Land History', 10)
		    IF ISNULL(lReturn)  &&  Key doesn't exist, so create it to avoid errors later
		        oRegistry.SetKeyValueEx('%Shared.Counters.Land History', 0, 'Land History', 10, '00001000', 'Land History Key', 0)
		        IF NOT USED('appreg01')
		            USE appreg01 IN 0
		        ENDIF
		        SELECT appreg01
		        LOCATE FOR keyname = 'Counters.Land History.'
		        IF FOUND()
		            IF EMPTY(properties)  &&  No properties, so insert the code to change the length to be 8
		                REPLACE properties WITH '%Length= 8'
		            ELSE
		                IF NOT 'LENGTH' $ UPPER(cProperties)  &&  The length property is not set, so add it to the beginning
		                    REPLACE properties WITH '%Length= 8' + CHR(13) + properties
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		
		    lnCount  = ALEN(THISFORM.aSelected, 1)
		    lnChecks = 0
		
		    FOR lnX = 1 TO lnCount
		        SELECT landpmts
		        LOCATE FOR cLeaseID + '-' + LEFT(cLeaseName, 25) + '  ' + cOwnerID + '-' + LEFT(cOwnName, 15) + '  ' + DTOC(dpmtdate) + '  ' + STR(nPmtAmount, 9, 2) = THISFORM.aSelected[lnX]
		        IF FOUND()
		            REPL lSelected WITH .T.
		        ENDIF
		    ENDFOR
		
		    SELECT cOwnerID, cOwnName, SUM(nPmtAmount) AS nPayment FROM landpmts WHERE lSelected INTO CURSOR temppmt ORDER BY cOwnerID GROUP BY cOwnerID
		
		
		    SELECT temppmt
		    SCAN
		        SCATTER MEMVAR
		        lcBatch = oRegistry.IncrementCounter('%Shared.Counters.Batch')
		
		* If the owner record is held, ask if a delay rental check should be created.
		        IF THIS.cheldowner = m.cOwnerID
		            IF NOT THISFORM.oMessage.CONFIRM('Owner: ' + ALLTRIM(THISFORM.cheldowner) + ' is on hold. Do you want to create a check for this owner?')
		                LOOP
		            ENDIF
		        ENDIF
		        oGLMaint.cBatch     = lcBatch
		        oGLMaint.dGLDate    = THISFORM.dCheckDate
		        oGLMaint.cyear      = ' '
		        oGLMaint.cperiod    = ' '
		        oGLMaint.cReference = 'Delay Rental'
		        oGLMaint.cDesc      = m.cOwnName
		        oGLMaint.cAcctNo    = m.cCashAcct
		        oGLMaint.cId        = m.cOwnerID
		        oGLMaint.nAmount    = m.nPayment * -1
		        oGLMaint.cbunch     = ''
		        oGLMaint.cPayee     = m.cOwnName
		        oGLMaint.cId        = m.cOwnerID
		        oGLMaint.cEntryType = 'C'
		        oGLMaint.dPostDate  = THISFORM.dCheckDate
		        oGLMaint.dCheckDate = THISFORM.dCheckDate
		        oGLMaint.cIDType    = 'I'
		        oGLMaint.cSource    = 'LM'
		        oGLMaint.lCleared   = .F.
		        oGLMaint.lPrinted   = .F.
		
		* Create the register entry
		        oGLMaint.nAmount = m.nPayment
		        oGLMaint.cAcctNo = m.cCashAcct
		        lnChecks         = lnChecks + 1
		
		        SELECT investor  &&  Get check memo to print on check - BH 11/2/07
		        LOCATE FOR cOwnerID = m.cOwnerID
		        IF FOUND()
		            oGLMaint.cMemo = investor.cchkMemo1
		            IF investor.lChktoSec OR investor.lCheckOnly  &&  Use second address memo, if necessary
		                oGLMaint.cMemo = investor.cchkMemo2
		            ENDIF
		        ENDIF
		
		        oGLMaint.AddCheck()
		        m.cidchec = oGLMaint.GETKEY()
		
		*  Create Cash entry
		        IF m.goApp.lAMVersion
		            oGLMaint.nAmount    = m.nPayment * -1
		            oGLMaint.UpdateBatch()
		        ENDIF
		
		        swselect('land')
		        SET ORDER TO cLeaseID
		
		*Create Rental Entry
		        SELECT landpmts
		        SCAN FOR lSelected AND cOwnerID = m.cOwnerID
		            m.cunitno        = cLeaseID
		            m.nPmtAmount     = nPmtAmount
		            m.cLeaseName     = cLeaseName
		            m.nPmtAcre       = nPmtAcre
		            m.nAcres         = nAcres
		            m.cLeaseID       = cLeaseID
		            m.dpmtdate       = THISFORM.dCheckDate
		            oGLMaint.cDesc   = cLeaseName
		            oGLMaint.cunitno = cLeaseID
		            oGLMaint.cDeptNo = cDeptNo
		
		* Check for expensing to a valid well.
		            llValidExpense = .F.
		            lnWells        = 0
		            IF NOT m.goApp.lEnhancedLand
		                swselect('wells')
		                LOCATE FOR cLeaseID == m.cLeaseID
		* Only expense to wells that are Active, Shut-In or Permitted
		                IF FOUND() AND landopt.lExpense AND NOT INLIST(wells.cwellstat, 'I', 'S', 'P') 
		                    llValidExpense   = .T.
		                    oGLMaint.cAcctNo = lcExpClear
		                ELSE
		                    llValidExpense = .F.
		                    SELECT land
		                    IF SEEK(landpmts.cLeaseID)
		                        IF NOT EMPTY(cAcctNo)
		                            oGLMaint.cAcctNo = land.cAcctNo
		                        ELSE
		                            oGLMaint.cAcctNo = m.cRentAcct
		                        ENDIF
		                    ELSE
		                        LOOP
		                    ENDIF
		                ENDIF
		            ELSE
		                oGLMaint.cAcctNo = landopt.cRentAcct
		                llWellLease      = .F.
		                swselect('leasewell')
		                SCAN FOR cLeaseID == m.cLeaseID
		                    swselect('wells')
		                    LOCATE FOR cwellid == leasewell.cwellid
		                    IF FOUND()
		                        IF landopt.lExpense AND NOT INLIST(wells.cwellstat, 'I', 'S', 'P') 
		                            llValidExpense   = .T.
		                            oGLMaint.cAcctNo = lcExpClear
		                        ELSE
		                            llValidExpense = .F.
		                            swselect('land')
		                            IF SEEK(landpmts.cLeaseID)
		                                IF NOT EMPTY(cAcctNo)
		                                    oGLMaint.cAcctNo = land.cAcctNo
		                                ELSE
		                                    oGLMaint.cAcctNo = landopt.cRentAcct
		                                ENDIF
		                            ELSE
		                                LOOP
		                            ENDIF
		                        ENDIF
		                    ELSE
		                        oGLMaint.cAcctNo = landopt.cRentAcct
		                    ENDIF
		                    llWellLease = .T.
		                ENDSCAN
		                IF NOT llWellLease
		                    swselect('land')
		                    IF SEEK(landpmts.cLeaseID)
		                        IF NOT EMPTY(cAcctNo)
		                            oGLMaint.cAcctNo = land.cAcctNo
		                        ELSE
		                            oGLMaint.cAcctNo = landopt.cRentAcct
		                        ENDIF
		                    ELSE
		                        LOOP
		                    ENDIF
		                ENDIF
		            ENDIF
		
		            oGLMaint.nAmount = m.nPmtAmount
		            IF m.goApp.lAMVersion
		                oGLMaint.UpdateBatch()
		            ENDIF
		
		            m.cidland = oRegistry.IncrementCounter('%Shared.Counters.Land History')
		
		            SELECT landhist1
		            SET DELE OFF
		            SET ORDER TO cidland
		            DO WHILE SEEK(m.cidland)
		                m.cidland = oRegistry.IncrementCounter('%Shared.Counters.Land History')
		            ENDDO
		            SET DELE ON
		
		            SELECT landhist
		            INSERT INTO landhist FROM MEMVAR
		
		            IF landopt.lExpense  &&  Charging the delay rental payments to the wells as expenses
		                SCATTER MEMVAR
		                IF llValidExpense
		                    IF NOT EMPTY(lcCatCode)
		                        m.cCatCode = lcCatCode
		                        SELECT expcat
		                        SET ORDER TO cCatCode
		                        IF SEEK(m.cCatCode)
		                            m.ccateg    = ccateg
		                            m.cexpclass = cexpclass
		                        ENDIF
		                    ELSE
		                        SELE expcat
		                        LOCATE FOR 'DELAY RENTAL' $ UPPER(ccateg)
		                        IF FOUND()
		                            m.cCatCode  = expcat.cCatCode
		                            m.ccateg    = ccateg
		                            m.cexpclass = cexpclass
		                        ENDIF
		                    ENDIF
		
		                    IF m.goApp.lEnhancedLand
		                        swselect('leasewell')
								SELECT  cwellid ;
									FROM wells ;
									WHERE NOT INLIST(wells.cwellstat, 'I', 'S', 'P') ;
										AND cwellid IN (SELECT  cwellid ;
															FROM leasewell ;
															WHERE cLeaseID == m.cLeaseID) ;
									INTO CURSOR temp
		                        lnWells    = _TALLY
		                        lnAmount   = swround(m.nPmtAmount / lnWells, 2)
		                        lnTotalAmt = swround(lnAmount * lnWells, 2)
		                        lnDiff     = m.nPmtAmount - lnTotalAmt
		                        SCAN
		                            m.cwellid   = temp.cwellid
		                            m.dexpdate  = THISFORM.dCheckDate
		                            m.nAmount   = lnAmount + lnDiff
		                            m.nAmount   = swNetExp(m.nAmount, m.cwellid, .F., m.cexpclass, 'B')
		                            lnDiff      = 0
		                            m.cPayee    = m.cOwnName
		                            m.cvendorid = m.cOwnerID
		                            m.cOwnerID  = ''
		                            m.laptran   = .T.
		                            m.cPaidByCk = m.cidchec  &&  Store the check key used to pay this expense
		                            m.cidexps   = oRegistry.IncrementCounter('%Shared.Counters.Expense')
		                            SET DELETED OFF
		                            SELECT expsusp
		                            SET ORDER TO cidexps
		                            DO WHILE SEEK(m.cidexps)
		                                m.cidexps = oRegistry.IncrementCounter('%Shared.Counters.Expense')
		                            ENDDO
		                            SET DELETED ON
		                            INSERT INTO expsusp FROM MEMVAR
		                            m.cOwnerID = temppmt.cOwnerID
		                        ENDSCAN
		                    ELSE
		                        SELECT wells
		                        COUNT FOR cLeaseID = m.cLeaseID AND NOT INLIST(wells.cwellstat, 'I', 'S', 'P') TO lnWells
		                        lnAmount   = swround(m.nPmtAmount / lnWells, 2)
		                        lnTotalAmt = swround(lnAmount * lnWells, 2)
		                        lnDiff     = m.nPmtAmount - lnTotalAmt
		
		                        SELECT wells
		                        SCAN FOR cLeaseID = m.cLeaseID AND NOT INLIST(wells.cwellstat, 'I', 'S', 'P') 
		                            IF NOT EMPTY(m.cCatCode)
		                                m.cwellid   = wells.cwellid
		                                m.dexpdate  = THISFORM.dCheckDate
		                                m.nAmount   = lnAmount + lnDiff
		                                m.nAmount   = swNetExp(m.nAmount, m.cwellid, .F., m.cexpclass, 'B')
		                                lnDiff      = 0
		                                m.cPayee    = m.cOwnName
		                                m.cvendorid = m.cOwnerID
		                                m.cOwnerID  = ''
		                                m.laptran   = .T.
		                                m.cPaidByCk = m.cidchec  &&  Store the check key used to pay this expense
		                                m.cidexps   = oRegistry.IncrementCounter('%Shared.Counters.Expense')
		                                SET DELETED OFF
		                                SELECT expsusp
		                                SET ORDER TO cidexps
		                                DO WHILE SEEK(m.cidexps)
		                                    m.cidexps = oRegistry.IncrementCounter('%Shared.Counters.Expense')
		                                ENDDO
		                                SET DELETED ON
		                                INSERT INTO expsusp FROM MEMVAR
		                                m.cOwnerID = temppmt.cOwnerID
		                            ENDIF
		                        ENDSCAN
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDSCAN  &&  Landpmts
		    ENDSCAN
		
		    IF lnChecks > 0
		        THISFORM.updowner()
		        THISFORM.oMessage.DISPLAY('Created ' + ALLTRIM(STR(lnChecks)) + ' Delay Rental Checks')
		    ELSE
		        THISFORM.oMessage.DISPLAY('No Checks Were Created')
		    ENDIF
		
		    SELECT land
		    = TABLEUPDATE(.T.)
		    SELECT landowner
		    = TABLEUPDATE(.T.)
		    SELECT expense
		    = TABLEUPDATE(.T.)
		    SELECT checks
		    = TABLEUPDATE(.T.)
		    SELECT landhist
		    = TABLEUPDATE(.T.)
		    SELECT glmaster
		    = TABLEUPDATE(.T.)
		    SELECT expsusp
		    = TABLEUPDATE(.T.)
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'CreateChks', loError.LINENO, 'Delay Pmts', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the payments at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE Init
		LPARA tdDate, tdCheckDate
		LOCAL oLand
		
		thisform.dCheckDate = tdCheckDate
		
		DODEFAULT()
		SET DELETED ON
		
		THISFORM.CAPTION = 'Delay Rental Payments Due As Of ' + DTOC(tdDate)
		
		*
		*  Initialize the arrays
		*
		LOCAL laSelected[1]
		
		
		oLand = CREATEOBJECT('Land')
		oLand.buildpmts(1,tdDate,tdDate)
		
		SELECT landpmts
		lnCount = RECC()
		IF lnCount > 0
		   DIME laAvailable[lnCount]
		   lnX = 1
		   SCAN
		      SCATTER MEMVAR
		      SELECT investor
		      SET ORDER to cownerid
		      IF SEEK(m.cownerid) 
		         IF investor.lhold
		            thisform.cHeldOwner = m.cownerid 
		         ELSE
		            SELECT landowner
		            LOCATE FOR cownerid = m.cownerid AND cleaseid = m.cleaseid
		            IF FOUND() AND cstatus <> 'A'
		               thisform.cHeldOwner = m.cownerid 
		            ENDIF    
		         ENDIF       
		         laAvailable[lnX] = m.cleaseID + '-'+LEFT(m.cLeaseName,25) + '  ' + m.cOwnerID+'-'+LEFT(m.cOwnName,15) + '  ' + DTOC(m.dpmtdate) + '  ' + STR(m.nPmtAmount,9,2)
		      ENDIF 
		      
		      lnX = lnX + 1
		   ENDSCAN
		
		   *  Initialize the aSelected array property
		   THISFORM.aSelected = ""
		
		   *  Call the setvalue method to initialze the listboxes
		   THISFORM.cntMoverListPair.SetValue(@laAvailable,@laSelected)
		ELSE
		   thisform.oMessage.Display('There are no delay rental payments due as of the date given...')
		   RETURN .F.
		ENDIF
		
		
	ENDPROC

	PROCEDURE updowner		&& Updates the owner file with the last payment info.
		lnCount = ALEN(THISFORM.aSelected,1)
		lnChecks = 0
		
		FOR lnX = 1 TO lnCount
		   SELECT landpmts
		   LOCATE FOR cLeaseID + '-'+LEFT(cLeaseName,25) + '  ' + cOwnerID + '-'+LEFT(cOwnName,15) + '  ' + DTOC(dpmtdate) + '  ' + STR(nPmtAmount,9,2) = THISFORM.aSelected[lnX]
		   IF FOUND()
		      SCATTER MEMVAR
		      SELECT landowner
		      LOCATE FOR cidlando = landpmts.cidlando
		      IF FOUND()
		         REPL npmttodate WITH npmttodate + m.nPmtAmount
		         IF NOT EMPTY(landowner.dnextpmt)
		            REPLACE dNextPmt WITH GOMONTH(landowner.dNextPmt,landowner.nPmtFreq)
		         ELSE
		            IF NOT EMPTY(landowner.dstartdate)
		               REPLACE dNextPmt WITH GOMONTH(landowner.dstartdate,landowner.nPmtFreq)   
		            ELSE
		               REPLACE dNextPmt WITH GOMONTH(this.dcheckdate,landowner.nPmtFreq)   
		            ENDIF    
		         ENDIF    
		      ENDIF
		   ENDIF
		ENDFOR
		
		
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		*
		*  Empty the selected array so that nothing is selected
		*
		thisform.aSelected = ""
		thisform.release()
	ENDPROC

	PROCEDURE cmdOK.Click
		LOCAL lnX, lnCount, laSelected[100]
		
		*  Get the selected array
		lnCount = THISFORM.cntMoverListPair.GetValue(@laSelected)
		
		IF lnCount > 0
		   *  Set the aSelected property to the selected array
		   DIME THISFORM.aSelected[lnCount]
		   FOR lnX = 1 TO lnCount
		      THISFORM.aSelected[lnX] = laSelected[lnX]
		   ENDFOR
		ELSE
		   THISFORM.aSelected = ""
		ENDIF
		
		IF lnCount <> 0
		   *  Create the checks
		   THISFORM.createchks()
		   THISFORM.RELEASE()
		ELSE
		   THISFORM.oMessage.DISPLAY('No rentals were selected to be paid.  Please click on the appropriate rentals, and then click the Select button to choose them for payment.')
		ENDIF
		
	ENDPROC

ENDDEFINE
