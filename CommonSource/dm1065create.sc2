*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="dm1065create.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 581
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 761

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "checks", ;
		CursorSource = "checks", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "form1065", ;
		BufferModeOverride = 5, ;
		CursorSource = "form1065", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor10", ;
		Top = 260, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "k1file", ;
		BufferModeOverride = 5, ;
		CursorSource = "k1file", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 451, ;
		Name = "Cursor11", ;
		Top = 303, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "deplset", ;
		CursorSource = "deplset", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 628, ;
		Name = "Cursor12", ;
		Top = 185, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "deplfile", ;
		CursorSource = "deplfile", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 600, ;
		Name = "Cursor13", ;
		Top = 57, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "suspense", ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 601, ;
		Name = "Cursor14", ;
		Top = 409, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "k1deducts", ;
		CursorSource = "k1deducts", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 196, ;
		Name = "Cursor15", ;
		Top = 413, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "disbhist", ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "glmaster", ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "programs", ;
		CursorSource = "programs", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 278, ;
		Name = "Cursor6", ;
		Top = 156, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 430, ;
		Name = "Cursor8", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\monbeldata\appdata.dbc, ;
		Height = 90, ;
		Left = 279, ;
		Name = "Cursor9", ;
		Top = 280, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS form1065create AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCreate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swrptlook1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkProcessed" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDisbursed" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkExclude" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: makedeductfile		&& Creates the deduction file for statement1 of the 1065. (Line20)
		*m: makefile		&& Create the 1099 file
		*m: makeowndeducts		&& Creates a file that contains the partner's share of each deduction.
	*</DefinedPropArrayMethod>

	Caption = "Create 1065 & K1 Files"
	DataSession = 2
	DoCreate = .T.
	Height = 394
	HelpContextID = 631
	lcloseonescape = .T.
	Name = "Form1065Create"
	Width = 405
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'chkDisbursed' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Build based on what was actually disbursed", ;
		Left = 107, ;
		Name = "chkDisbursed", ;
		TabIndex = 6, ;
		Top = 216, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkExclude' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Exclude Royalty Owners", ;
		Left = 108, ;
		Name = "chkExclude", ;
		TabIndex = 7, ;
		Top = 276, ;
		Value = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkProcessed' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Build based on what was actually processed", ;
		Left = 107, ;
		Name = "chkProcessed", ;
		TabIndex = 7, ;
		Top = 246, ;
		Value = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdCreate' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Create", ;
		Height = 36, ;
		Left = 120, ;
		Name = "cmdCreate", ;
		TabIndex = 8, ;
		Top = 348, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 36, ;
		Left = 204, ;
		Name = "cmdExit", ;
		TabIndex = 9, ;
		Top = 348, ;
		Width = 72
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Create 1065 file for year:", ;
		FontBold = .T., ;
		Height = 16, ;
		Left = 72, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 1, ;
		Top = 29, ;
		Width = 135
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Beginning Program", ;
		Left = 24, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 4, ;
		Top = 91
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		Caption = "Ending Program", ;
		Left = 24, ;
		Name = "Lbllabelcustom3", ;
		TabIndex = 5, ;
		Top = 144
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Swrptlook1' AS swrptlook WITH ;
		Left = 125, ;
		Name = "Swrptlook1", ;
		TabIndex = 3, ;
		Top = 88, ;
		Swlookupbutton1.Name = "Swlookupbutton1", ;
		Swlookupbutton2.Name = "Swlookupbutton2", ;
		txtBegID.clistexpression = programs.cprogcode, ;
		txtBegID.clistworkarea = programs, ;
		txtBegID.Name = "txtBegID", ;
		TxtBegName.Name = "TxtBegName", ;
		txtEndID.clistexpression = programs.cprogcode, ;
		txtEndID.clistworkarea = programs, ;
		txtEndID.Name = "txtEndID", ;
		TxtEndName.Name = "TxtEndName"
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="container" />

	ADD OBJECT 'txtcYear' AS swyear WITH ;
		Left = 222, ;
		Name = "txtcYear", ;
		TabIndex = 2, ;
		Top = 27
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		IF DODEFAULT()
		   * If we're in demo mode, tell the user that this is an optional module
		   IF m.goapp.ldemo
		      thisform.omessage.warning('The 1065/K1 module is an optional module that can be purchased separately.' + ;
		                                ' It is included in the demo for evaluation purposes.')
		   ENDIF
		
		   *
		   *  Initialize the Year textbox
		   *
		   set dele on
		   THISFORM.txtcYear.VALUE = STR(YEAR(DATE())-1,4)
		
		   SELECT programs
		   SET ORDER TO cProgcode
		   GO TOP
		   THISFORM.swrptlook1.txtbegid.VALUE = cProgcode
		   THISFORM.swrptlook1.txtbegname.VALUE = cprogname
		   GO BOTT
		   THISFORM.swrptlook1.txtendid.VALUE = cProgcode
		   THISFORM.swrptlook1.txtendname.VALUE = cprogname
		
		   IF FILE('datafiles\1065roy.txt')
		      thisform.chkExclude.Value = .f.
		      thisform.chkexclude.Enabled = .f.
		   ENDIF 
		
		   *
		   *  Find the Registry object
		   *
		   THIS.oRegistry = FindGlobalObject('cmRegistry')
		
		ENDIF
		
	ENDPROC

	PROCEDURE makedeductfile		&& Creates the deduction file for statement1 of the 1065. (Line20)
		LOCAL lcYear, lcProg1, lcProg2, llProcessed, llDisbursed
		
		llReturn = .T.
		
		TRY
		   lcYear      = THISFORM.txtcyear.VALUE
		   lcProg1     = THISFORM.swrptlook1.txtbegid.VALUE
		   lcProg2     = THISFORM.swrptlook1.txtendid.VALUE
		   llProcessed = THISFORM.chkProcessed.VALUE
		   llDisbursed = THISFORM.chkdisbursed.VALUE
		
		
		   WAIT WINDOW NOWAIT 'Creating Statement 1 File....'
		   swselect('sysctl')
		   swselect('expense')
		   swselect('wellinv')
		   swselect('expcat')
		   swselect('taxcodes')
		   swselect('disbhist')
		   swselect('ownpcts')
		
		   SELECT ownpcts
		   SET ORDER TO ciddisb
		
		   CREATE CURSOR tempexpense ;
		      (cwellid     c(10), ;
		      cprogcode   c(10), ;
		      cprogname   c(40), ;
		      ctaxid      c(15), ;
		      nrunno      i, ;
		      crunyear    c(4), ;
		      ctaxcode    c(2), ;
		      cdesc       c(30), ;
		      ccatcode    c(4), ;
		      ccateg      c(30), ;
		      cownerid    c(10), ;
		      ninterest   N(11, 7), ;
		      ngrossamt   N(12, 2), ;
		      nprogamt    N(12, 2))
		
		   * Replace missing taxcodes
		   SELECT expcat
		   REPLACE ctaxcode WITH 'OE' FOR EMPTY(ctaxcode)
		
		
		   * Create a cursor of all expenses for the given year and programs for revenue runs
		   SELECT  'R' AS cType, expense.nrunnorev AS nrunno, expense.crunyearrev AS crunyear, expense.cwellid, ;
		      expense.cexpclass, expense.ccatcode, expcat.ctaxcode, expcat.ccateg, taxcodes.cdesc, SUM(namount) AS namount ;
		      FROM expense, expcat, taxcodes, programs ;
		      WHERE TRANSFORM(YEAR(expense.dacctdate)) = lcYear ;
		      AND expense.crunyearrev <> '1900' ;
		      AND expense.cwellid IN (SELECT  cwellid FROM wellinv ;
		                                 WHERE BETWEEN(cprogcode, lcProg1, lcProg2)) ;
		      AND expense.ccatcode = expcat.ccatcode ;
		      AND expcat.ctaxcode  = taxcodes.ctaxcode ;
		      INTO CURSOR exp1065 READWRITE  ;
		      ORDER BY expense.nrunnorev, expense.crunyearrev, expense.cwellid, expense.cexpclass, expcat.ctaxcode, expcat.ccateg ;
		      GROUP BY expense.nrunnorev, expense.crunyearrev, expense.cwellid, expense.cexpclass, expcat.ctaxcode, expcat.ccateg
		
		   * Create a cursor of all expenses for the given year and programs for revenue runs
		   SELECT  'J' AS cType, expense.nrunnojib AS nrunno, expense.crunyearjib AS crunyear, expense.cwellid, ;
		      expense.cexpclass, expcat.ctaxcode, expense.ccatcode, expcat.ccateg, taxcodes.cdesc, SUM(namount) AS namount ;
		      FROM expense, expcat, taxcodes ;
		      WHERE TRANSFORM(YEAR(expense.dacctdate)) = lcYear ;
		      AND expense.crunyearjib <> '1900' ;
		      AND expense.cwellid IN (SELECT  cwellid ;
		      FROM wellinv ;
		      WHERE BETWEEN(cprogcode, lcProg1, lcProg2)) ;
		      AND expense.ccatcode = expcat.ccatcode ;
		      AND expcat.ctaxcode  = taxcodes.ctaxcode ;
		      INTO CURSOR exp1065j  ;
		      ORDER BY expense.nrunnorev, expense.crunyearrev, expense.cwellid, expense.cexpclass, expcat.ctaxcode, expcat.ccateg ;
		      GROUP BY expense.nrunnorev, expense.crunyearrev, expense.cwellid, expense.cexpclass, expcat.ctaxcode, expcat.ccateg
		
		   SELECT exp1065
		   APPEND FROM DBF('exp1065j')
		
		   * Now that we have all the expenses grouped by taxcode
		   * we can calculate the program's share of the expense
		   * by scanning through wellinv to get the partner's
		   * percentages
		
		   SELECT cType, nrunno, crunyear FROM exp1065 INTO CURSOR tempruns ORDER BY cType, crunyear, nrunno GROUP BY cType, crunyear, nrunno
		
		   SELECT  crectype, crunyear, nrunno, cwellid, cprogcode, cownerid, ciddisb, crunyear_in, nrunno_in, ljib ;
		      FROM disbhist ;
		      WHERE BETWEEN(cprogcode, lcProg1, lcProg2) ;
		      AND cprogcode IN (SELECT  cprogcode ;
		      FROM programs ;
		      WHERE lprog1099 = .F.) ;
		      AND EMPTY(csusptype) ;
		      AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		      (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		      INTO CURSOR owntemp READWRITE ;
		      ORDER BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid ;
		      GROUP BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid
		
		   SELECT  crectype, crunyear, nrunno, cwellid, cprogcode, cownerid, ciddisb, crunyear_in, nrunno_in, ljib ;
		      FROM disbhist ;
		      WHERE BETWEEN(cprogcode, lcProg1, lcProg2) ;
		      AND cprogcode IN (SELECT  cprogcode ;
		      FROM programs ;
		      WHERE lprog1099 = .F.) ;
		      AND NOT EMPTY(csusptype) ;
		      AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		      (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		      AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') IN ;
		      (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		      INTO CURSOR owntempa ;
		      ORDER BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid ;
		      GROUP BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid
		
		   SELECT owntemp
		   APPEND FROM DBF('owntempa')
		
		   IF llDisbursed
		      SELECT  crectype, crunyear, nrunno, cwellid, cprogcode, cownerid, ciddisb, crunyear_in, nrunno_in, ljib ;
		         FROM disbhist ;
		         WHERE BETWEEN(cprogcode, lcProg1, lcProg2) ;
		         AND cprogcode IN (SELECT  cprogcode ;
		         FROM programs ;
		         WHERE lprog1099 = .F.) ;
		         AND NOT EMPTY(csusptype) ;
		         AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		         AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') NOT IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		         INTO CURSOR owntempb ;
		         ORDER BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid ;
		         GROUP BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid
		
		      SELECT owntemp
		      APPEND FROM DBF('owntempb')
		   ENDIF
		
		   swselect('programs')
		   SET ORDER TO cprogcode
		
		   SELECT tempruns
		   SCAN
		      SCATTER MEMVAR
		      SELECT owntemp
		      SCAN FOR IIF(nrunno_in = 0, nrunno = m.nrunno AND crunyear = m.crunyear, nrunno_in = m.nrunno AND crunyear_in = m.crunyear) ;
		            AND BETWEEN(cprogcode, lcProg1, lcProg2) AND crectype = m.cType
		         m.cwellid   = cwellid
		         m.cprogcode = cprogcode
		         m.ciddisb   = ciddisb
		         m.cownerid  = cownerid
		         m.ljib      = ljib
		
		         SELECT programs
		         IF SEEK(m.cprogcode) 
		            IF lprog1099
		               LOOP
		            ELSE
		               m.cprogname = cprogname
		               m.ctaxid    = cprogtaxid
		            ENDIF    
		         ENDIF
		
		         IF m.cType = 'J' AND NOT m.ljib
		            LOOP
		         ENDIF
		
		         SELECT ownpcts
		         IF SEEK(m.ciddisb)
		            SELECT exp1065
		            SCAN FOR cwellid == m.cwellid AND nrunno = m.nrunno AND crunyear = m.crunyear AND cType = m.cType
		               m.ctaxcode  = ctaxcode
		               m.cexpclass = cexpclass
		               m.ccateg    = ccateg
		               m.ngrossamt = namount
		               m.cdesc     = cdesc
		               m.ccatcode  = ccatcode
		
		               DO CASE
		                  CASE m.cexpclass = '0'
		                     m.ninterest = ownpcts.nworkint
		                  CASE m.cexpclass = '1'
		                     m.ninterest = ownpcts.nintclass1
		                  CASE m.cexpclass = '2'
		                     m.ninterest = ownpcts.nintclass2
		                  CASE m.cexpclass = '3'
		                     m.ninterest = ownpcts.nintclass3
		                  CASE m.cexpclass = '4'
		                     m.ninterest = ownpcts.nintclass4
		                  CASE m.cexpclass = '5'
		                     m.ninterest = ownpcts.nintclass5
		                  CASE m.cexpclass = 'A'
		                     m.ninterest = ownpcts.nintclassa
		                  CASE m.cexpclass = 'B'
		                     m.ninterest = ownpcts.nintclassb
		                  OTHERWISE
		                     m.ninterest = ownpcts.nworkint
		               ENDCASE
		
		               m.nprogamt = ROUND(m.ngrossamt * (m.ninterest / 100), 2)
		
		               INSERT INTO tempexpense FROM MEMVAR
		            ENDSCAN
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		
		   IF llProcessed
		      SELECT  * ;
		         FROM suspense ;
		         WHERE crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') ;
		         IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		         AND BETWEEN(cprogcode, lcProg1, lcProg2) ;
		         AND cprogcode IN (SELECT  cprogcode ;
		         FROM programs ;
		         WHERE lprog1099 = .F.) ;
		         INTO CURSOR sustemp ;
		         ORDER BY cprogcode, cwellid, crunyear_in, nrunno_in, cownerid ;
		         GROUP BY cprogcode, cwellid, crunyear_in, nrunno_in, cownerid
		
		      SELECT tempruns
		      SCAN
		         SCATTER MEMVAR
		         SELECT sustemp
		         SCAN FOR nrunno_in = m.nrunno AND crunyear_in = m.crunyear AND BETWEEN(cprogcode, lcProg1, lcProg2) AND crectype = m.cType
		            m.cwellid   = cwellid
		            m.cprogcode = cprogcode
		            m.ciddisb   = ciddisb
		            m.cownerid  = cownerid
		            m.ljib      = ljib
		
		            SELECT programs
		            IF SEEK(m.cprogcode) 
		               IF lprog1099
		                  LOOP
		               ELSE
		                  m.cprogname = cprogname
		                  m.ctaxid    = cprogtaxid
		               ENDIF   
		            ENDIF
		
		            IF m.cType = 'J' AND NOT m.ljib
		               LOOP
		            ENDIF
		
		            SELECT exp1065
		            SCAN FOR cwellid == m.cwellid AND nrunno = m.nrunno AND crunyear = m.crunyear AND cType = m.cType
		               m.ctaxcode  = ctaxcode
		               m.cexpclass = cexpclass
		               m.ccateg    = ccateg
		               m.ngrossamt = namount
		               m.cdesc     = cdesc
		               m.ccatcode  = ccatcode
		
		               DO CASE
		                  CASE m.cexpclass = '0'
		                     m.ninterest = sustemp.nworkint
		                  CASE m.cexpclass = '1'
		                     m.ninterest = sustemp.nintclass1
		                  CASE m.cexpclass = '2'
		                     m.ninterest = sustemp.nintclass2
		                  CASE m.cexpclass = '3'
		                     m.ninterest = sustemp.nintclass3
		                  CASE m.cexpclass = '4'
		                     m.ninterest = sustemp.nintclass4
		                  CASE m.cexpclass = '5'
		                     m.ninterest = sustemp.nintclass5
		                  CASE m.cexpclass = 'A'
		                     m.ninterest = sustemp.nintclassa
		                  CASE m.cexpclass = 'B'
		                     m.ninterest = sustemp.nintclassb
		                  OTHERWISE
		                     m.ninterest = sustemp.nworkint
		               ENDCASE
		
		               m.nprogamt = ROUND(m.ngrossamt * (m.ninterest / 100), 2)
		
		               INSERT INTO tempexpense FROM MEMVAR
		            ENDSCAN
		         ENDSCAN
		      ENDSCAN
		   ENDIF
		
		   SELECT  lcYear AS cyear, cprogcode, ctaxcode, cdesc, ccateg, SUM(nprogamt) AS namount ;
		      FROM tempexpense ;
		      INTO CURSOR tempstmt ;
		      ORDER BY cprogcode, ctaxcode, ccateg ;
		      GROUP BY cprogcode, ctaxcode, ccateg
		
		   swselect('stmtone1065')
		   APPEND FROM DBF('tempstmt')
		
		   SELECT  cprogcode, SUM(namount) AS namount ;
		      FROM stmtone1065 ;
		      INTO CURSOR tmp1065 ;
		      WHERE cyear = lcYear ;
		      ORDER BY cprogcode ;
		      GROUP BY cprogcode
		
		   SELECT tmp1065
		   SCAN
		      SCATTER MEMVAR
		
		      SELECT form1065
		      LOCATE FOR cprogcode = m.cprogcode AND cyear = lcYear
		      IF FOUND()
		         IF nRoyalties # 0
		            IF nRoyDeducts # m.namount
		               lnDiff = nRoyDeducts - m.namount
		               SELECT stmtone1065
		               LOCATE FOR cprogcode = m.cprogcode AND cyear = lcYear AND ctaxcode = 'OE'
		               IF FOUND()
		                  REPLACE namount WITH namount + lnDiff
		               ENDIF
		            ENDIF
		         ELSE
		            IF ndeduct # m.namount
		               lnDiff = ndeduct - m.namount
		               SELECT stmtone1065
		               LOCATE FOR cprogcode = m.cprogcode AND cyear = lcYear AND ctaxcode = 'OE'
		               IF FOUND()
		                  REPLACE namount WITH namount + lnDiff
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   * Split out the IDC
		   SELECT tempstmt
		   SCAN FOR ctaxcode = 'ID'
		      m.cprogcode = cprogcode
		      m.namount   = namount
		
		      SELECT form1065
		      LOCATE FOR cyear == lcYear AND cprogcode == m.cprogcode
		      IF FOUND()
		         REPLACE nIDC WITH m.namount, ;
		            ndeduct WITH ndeduct - m.namount
		      ENDIF
		   ENDSCAN
		
		   WAIT CLEAR
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'MakeDeductFile', loError.LINENO, 'Form 1065', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE makefile		&& Create the 1099 file
		LOCAL lGenPart, lLLCPart, lcProg1, lcProg2, lcYear, llDisbursed, llProcessed, lnCount, lnK1
		LOCAL lnTally1065, lnpct, lnDeplRecs, oProgress, m.cProgcode
		LOCAL cid1065, cidk1file, cownerid, cProgcode, cyear, nPct, nTaxes, nWorkInt, ncapbal, ndeduct
		LOCAL ndepletion, ngrossexp, ngrossinc, nordincome, npartdist, npartshare, npctcap, npctloss
		LOCAL npctprofit, lcExclude
		
		llReturn = .T.
		
		TRY
		   lcYear      = THISFORM.txtcyear.VALUE
		   lcProg1     = THISFORM.swrptlook1.txtbegid.VALUE
		   lcProg2     = THISFORM.swrptlook1.txtendid.VALUE
		   llProcessed = THISFORM.chkProcessed.VALUE
		   llDisbursed = THISFORM.chkdisbursed.VALUE
		   llExclude   = THISFORM.chkexclude.VALUE
		   lnDeplRecs  = 0
		
		   IF llExclude
		      lcExclude  = "ctypeinv = 'W'"
		   ELSE
		      lcExclude  = "INLIST(ctypeinv,'L','O','W')"
		   ENDIF
		
		*!*	   IF MESSAGEBOX("This module assumes that the partnership's total receipts for the year were less than $250,000 and the total assets were " + ;
		*!*	         "less than $1,000,000 and that the partnership is not required to file Schedule M-3. Is this OK?", 36, "Form 1065/K1 Limitations") = 7
		*!*	      THISFORM.omessage.warning('Form 1065/K1 filing aborted.')
		*!*	      llReturn = .F.
		*!*	      EXIT
		*!*	   ENDIF
		
		   oProgress = THISFORM.omessage.ProgressBarEx('Building Form 1065/K1 Data...')
		
		   swselect('programs')
		   SELECT cProgcode FROM programs WHERE BETWEEN(cProgcode, lcProg1, lcProg2) INTO CURSOR temp
		
		   lnMax = _TALLY * 2
		
		   oProgress.setprogressrange(0, 19)
		
		   ***
		   * Create the depletion file
		   ***
		   IF NOT FILE(ALLTRIM(m.goApp.cDataFilePath) + 'depltemp.dbf')
		      CREATE TABLE (ALLTRIM(m.goApp.cDataFilePath) + 'depltemp') FREE ;
		         (cleasename  C(30),   ;
		         cidlease    C(10),   ;
		         cownerid    C(10),   ;
		         cownname    C(40),   ;
		         cinvtaxid   C(15),   ;
		         cProgcode   C(10),   ;
		         cowntype    C(1),    ;
		         cyear       C(4),    ;
		         cMarginal   C(1),    ;
		         nMargPct    N(4, 2),  ;
		         nNonPct     N(4, 2),  ;
		         ninvamount  N(12, 2), ;
		         dinvdate    D,       ;
		         nintanpct   N(11, 7), ;
		         nintanamt   N(12, 2), ;
		         ntanpct     N(11, 7), ;
		         ntanamt     N(12, 2), ;
		         nTotMCF     N(12, 4), ;
		         nTotBBL     N(12, 4), ;
		         nBBLDay     N(12, 2), ;
		         ngrossinc   N(12, 2), ;
		         nIntDrill   N(12, 2), ;
		         nIndExp     N(12, 2), ;
		         nDirExp     N(12, 2), ;
		         nIDCExp     N(12, 2), ;
		         nDeprExp    N(12, 2), ;
		         nNetInc     N(12, 2), ;
		         nNetIncLim  N(12, 2), ;
		         nDeplpct    N(4, 2), ;
		         nDepl       N(12, 2), ;
		         nTentDepl   N(12, 2), ;
		         nTotDepl    N(12, 2), ;
		         nCostDepl   N(12, 2), ;
		         nPctOwned   N(11, 7), ;
		         nMCFShare   N(12, 2), ;
		         nMCFInt     N(11, 7), ;
		         nWorkInt     N(11, 7), ;
		         nMCFBBL     N(12, 2))
		      INDEX ON cownerid + cowntype + cleasename TAG cownerid
		      INDEX ON cowntype + cleasename TAG well
		      INDEX ON cownname + cowntype  TAG PROD
		      INDEX ON cownname + cowntype + cleasename TAG prodwell
		   ENDIF
		   swselect('depltemp')
		
		   IF NOT FILE(ALLTRIM(m.goApp.cDataFilePath) + 'stmtone1065.DBF')
		      CREATE TABLE (ALLTRIM(m.goApp.cDataFilePath) + 'stmtone1065') FREE ;
		         (cyear         C(4), ;
		         cProgcode     C(10), ;
		         ctaxcode      C(2), ;
		         cdesc         C(30), ;
		         namount       N(12, 2))
		   ENDIF
		   swselect('stmtone1065')
		   SELECT form1065
		   COUNT FOR cyear = lcYear TO lnCount
		   IF lnCount > 0
		      IF THISFORM.omessage.CONFIRM('Form 1065 data for year ' + lcYear + ' already exists. Do you want to overwrite it?')
		         DELETE FOR cyear = lcYear AND BETWEEN(cProgcode, lcProg1, lcProg2)
		         SELECT k1file
		         DELETE FOR cyear = lcYear AND BETWEEN(cProgcode, lcProg1, lcProg2)
		         SELECT stmtone1065
		         DELETE FOR cyear = lcYear AND BETWEEN(cProgcode, lcProg1, lcProg2)
		         SELECT k1deducts
		         DELETE FOR cyear = lcYear AND BETWEEN(cProgcode, lcProg1, lcProg2)
		         IF USED('depltemp')
		            SELECT depltemp
		            DELETE FOR cyear = lcYear AND BETWEEN(cProgcode, lcProg1, lcProg2)
		         ENDIF
		      ELSE
		         WAIT WIND NOWAIT 'Form 1065 file creation cancelled'
		         llReturn = .F.
		         EXIT
		      ENDIF
		      swselect('depltemp')
		      DELETE FOR cyear == lcYear
		   ENDIF
		   STORE 0 TO lnTally1065, lnK1
		
		   oProgress.SetProgressMessage('Building 1065 Records...')
		   oProgress.UpdateProgress(1)
		
		   IF llDisbursed
		      SELECT  disbhist.cProgcode, ;
		         SUM(nexpense + ngather + ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal, ;
		         programs.dprogstart as dbegindate ;
		         WHERE BETWEEN(disbhist.cProgcode, lcProg1, lcProg2) ;
		         AND EMPTY(csusptype) ;
		         AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'J','R'));
		         AND disbhist.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         FROM disbhist JOIN programs ON disbhist.cProgcode = programs.cProgcode ;
		         INTO CURSOR temp1065a READWRITE ;
		         GROUP BY disbhist.cProgcode ;
		         ORDER BY disbhist.cProgcode
		
		      lnTally1065 = _TALLY
		
		      oProgress.UpdateProgress(2)
		      SELECT  disbhist.cProgcode, ;
		         SUM(nexpense + ngather + ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal, ;
		         programs.dprogstart as dbegindate ;
		         WHERE BETWEEN(disbhist.cProgcode, lcProg1, lcProg2) ;
		         AND NOT EMPTY(csusptype) ;
		         AND disbhist.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'J','R'));
		         FROM disbhist JOIN programs ON disbhist.cProgcode = programs.cProgcode ;
		         INTO CURSOR temp1065b ;
		         GROUP BY disbhist.cProgcode ;
		         ORDER BY disbhist.cProgcode
		
		      SELECT temp1065a
		      APPEND FROM DBF('temp1065b')
		
		      oProgress.UpdateProgress(3)
		      SELECT  disbhist.cProgcode, ;
		         SUM(nexpense + ngather + ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),0000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal, ;
		         programs.dprogstart as dbegindate ;
		         WHERE BETWEEN(disbhist.cProgcode, lcProg1, lcProg2) ;
		         AND NOT EMPTY(csusptype) ;
		         AND disbhist.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') NOT IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'J','R'));
		         AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'J','R'));
		         FROM disbhist JOIN programs ON disbhist.cProgcode = programs.cProgcode ;
		         INTO CURSOR temp1065c ;
		         GROUP BY disbhist.cProgcode ;
		         ORDER BY disbhist.cProgcode
		
		      SELECT temp1065a
		      APPEND FROM DBF('temp1065c')
		   ELSE
		      * Only include what was processed whether in suspense or not
		      SELECT  disbhist.cProgcode, ;
		         SUM(nexpense + ngather + ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal, ;
		         programs.dprogstart as dbegindate ;
		         WHERE BETWEEN(disbhist.cProgcode, lcProg1, lcProg2) ;
		         AND EMPTY(csusptype) ;
		         AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'J','R'));
		         AND disbhist.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         FROM disbhist JOIN programs ON disbhist.cProgcode = programs.cProgcode ;
		         INTO CURSOR temp1065a READWRITE ;
		         GROUP BY disbhist.cProgcode ;
		         ORDER BY disbhist.cProgcode
		
		      lnTally1065 = _TALLY
		
		      oProgress.UpdateProgress(2)
		      SELECT  disbhist.cProgcode, ;
		         SUM(nexpense + ngather + ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal, ;
		         programs.dprogstart as dbegindate ;
		         WHERE BETWEEN(disbhist.cProgcode, lcProg1, lcProg2) ;
		         AND NOT EMPTY(csusptype) ;
		         AND disbhist.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0');
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'J','R')) ;
		         FROM disbhist JOIN programs ON disbhist.cProgcode = programs.cProgcode ;
		         INTO CURSOR temp1065b ;
		         GROUP BY disbhist.cProgcode ;
		         ORDER BY disbhist.cProgcode
		
		      SELECT temp1065a
		      APPEND FROM DBF('temp1065b')
		
		      oProgress.UpdateProgress(3)
		
		      oProgress.UpdateProgress(4)
		      * Get the totals still in suspense
		      SELECT  suspense.cProgcode, ;
		         SUM(nexpense + ngather + ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal, ;
		         programs.dprogstart as dbegindate ;
		         WHERE BETWEEN(suspense.cProgcode, lcProg1, lcProg2) ;
		         AND suspense.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'J','R'));
		         FROM suspense JOIN programs ON suspense.cProgcode = programs.cProgcode ;
		         INTO CURSOR temp1065d ;
		         GROUP BY suspense.cProgcode ;
		         ORDER BY suspense.cProgcode
		
		      lnTally1065 = lnTally1065 + _TALLY
		
		      SELECT temp1065a
		      APPEND FROM DBF('temp1065d')
		   ENDIF
		
		   oProgress.UpdateProgress(5)
		   * Get the combination of disbhist and suspense records for each program
		   SELECT  cProgcode, ;
		      SUM(nexptotal)   AS nexptotal, ;
		      SUM(noiltotal)   AS noiltotal, ;
		      SUM(ngastotal)   AS ngastotal, ;
		      SUM(ntrptotal)   AS ntrptotal, ;
		      SUM(nothtotal)   AS nothtotal, ;
		      SUM(noiltotalr)  AS noiltotalr, ;
		      SUM(ngastotalr)  AS ngastotalr, ;
		      SUM(ntrptotalr)  AS ntrptotalr, ;
		      SUM(nothtotalr)  AS nothtotalr, ;
		      SUM(nclasstotal) AS nclasstotal, ;
		      SUM(ntaxtotal)   AS ntaxtotal, ;
		      SUM(nnettotal)   AS nnettotal, ;
		      dbegindate ;
		      FROM temp1065a ;
		      INTO CURSOR temp1065 ;
		      ORDER BY cProgcode ;
		      GROUP BY cProgcode
		
		   lnTally1065 = _TALLY
		
		   IF lnTally1065 = 0
		      THISFORM.omessage.DISPLAY('There were no program history records found for the criteria given')
		      llReturn = .F.
		      EXIT
		   ENDIF
		   *
		   *  Figure out the pct ownership of each program
		   *
		   oProgress.UpdateProgress(6)
		
		   IF FILE('datafiles\1065Roy.txt')
		      SELE cProgcode, SUM(nrevgas) AS nPct FROM wellinv WHERE NOT EMPTY(cProgcode) ;
		         INTO CURSOR tempprog1 ;
		         ORDER BY cProgcode ;
		         GROUP BY cProgcode
		   ELSE
		      SELE cProgcode, SUM(nWorkInt) AS nPct FROM wellinv WHERE NOT EMPTY(cProgcode) ;
		         INTO CURSOR tempprog1 ;
		         ORDER BY cProgcode ;
		         GROUP BY cProgcode
		   ENDIF
		
		   IF _TALLY > 0
		
		      IF FILE('datafiles\1065Roy.txt')
		         SELE cownerid, cProgcode, SUM(nrevgas) AS nWorkInt FROM wellinv WHERE NOT EMPTY(cProgcode) ;
		            INTO CURSOR tempprog2 ;
		            ORDER BY cProgcode, cownerid ;
		            GROUP BY cProgcode, cownerid
		      ELSE
		         SELE cownerid, cProgcode, SUM(nWorkInt) AS nWorkInt FROM wellinv WHERE NOT EMPTY(cProgcode) ;
		            INTO CURSOR tempprog2 ;
		            ORDER BY cProgcode, cownerid ;
		            GROUP BY cProgcode, cownerid
		      ENDIF
		
		      CREATE CURSOR progrel ;
		         (cProgcode  C(10), ;
		         cownerid   C(10), ;
		         nPct       N(11, 7))
		      INDEX ON cProgcode + cownerid TAG progown
		      SELECT tempprog1
		      SCAN
		         SCATTER MEMVAR
		         lnpct = m.nPct
		         SELE tempprog2
		         SCAN FOR cProgcode = m.cProgcode
		            SCATTER MEMVAR
		            m.nPct = ROUND(m.nWorkInt / (lnpct / 100), 7)
		            INSERT INTO progrel FROM MEMVAR
		         ENDSCAN
		      ENDSCAN
		   ENDIF
		   ******************************************************************
		   *   Load the Form1065 table
		   ******************************************************************
		   oProgress.UpdateProgress(7)
		   SELECT temp1065
		   SCAN
		      SCATTER MEMVAR
		      STORE 0 TO m.nBegCash, m.nEndCash, m.nOtherDeducts, m.ndeduct, m.nRoyDeducts
		      m.cid1065    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		      m.cyear      = lcYear
		      m.nordincome = m.nnettotal
		      m.ngrossinc  = m.ngastotal + m.noiltotal + m.ntrptotal + m.nothtotal
		      m.nRoyalties = m.ngastotalr + m.noiltotalr + m.ntrptotalr + m.nothtotalr
		      m.nTaxes     = m.ntaxtotal
		      IF m.nRoyalties # 0
		         m.nRoyDeducts = m.nexptotal + m.nclasstotal
		      ELSE
		         m.ndeduct    = m.nexptotal + m.nclasstotal
		      ENDIF
		
		      INSERT INTO form1065 FROM MEMVAR
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 1')
		   oProgress.UpdateProgress(8)
		
		   ******************************************************************
		   *   Calculate the K1File table
		   ******************************************************************
		   
		   IF llDisbursed
		      SELECT  disbhist.cownerid, ;
		         investor.cownname AS invname, ;
		         disbhist.cWellID, ;
		         wells.cwellname, ;
		         disbhist.cProgcode, ;
		         programs.cprogname, ;
		         programs.nprogtype, ;
		         IIF(disbhist.ctypeinv = 'W',.F.,.T.) as lRoyalty, ;
		         'Individual'   AS centity, ;
		         SUM(nexpense + disbhist.ngather + disbhist.ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal ;
		         WHERE BETWEEN(disbhist.cProgcode, lcProg1, lcProg2) ;
		         AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'R','J')) ;
		         AND disbhist.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         FROM disbhist JOIN programs ON disbhist.cProgcode = programs.cProgcode ;
		         JOIN investor ON disbhist.cownerid  = investor.cownerid ;
		         JOIN wells    ON disbhist.cWellID   = wells.cWellID ;
		         INTO CURSOR tempK1a READWRITE ;
		         GROUP BY disbhist.cProgcode, disbhist.cownerid ;
		         ORDER BY disbhist.cProgcode, disbhist.cownerid
		
		      oProgress.SetProgressMessage('Building K1 Records...Step 2')
		      oProgress.UpdateProgress(9)
		      oProgress.SetProgressMessage('Building K1 Records...Step 3')
		      oProgress.UpdateProgress(10)
		      oProgress.SetProgressMessage('Building K1 Records...Step 4')
		      oProgress.UpdateProgress(12)
		
		   ELSE
		      * Only include what was processed
		
		      SELECT  disbhist.cownerid, ;
		         investor.cownname AS invname, ;
		         disbhist.cWellID, ;
		         wells.cwellname, ;
		         disbhist.cProgcode, ;
		         programs.cprogname, ;
		         programs.nprogtype, ;
		         IIF(disbhist.ctypeinv = 'W',.F.,.T.) as lRoyalty, ;
		         'Individual'   AS centity, ;
		         SUM(nexpense + disbhist.ngather + disbhist.ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal ;
		         WHERE BETWEEN(disbhist.cProgcode, lcProg1, lcProg2) ;
		         AND EMPTY(csusptype) ;
		         AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'R','J')) ;
		         AND disbhist.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         FROM disbhist JOIN programs ON disbhist.cProgcode = programs.cProgcode ;
		         JOIN investor ON disbhist.cownerid  = investor.cownerid ;
		         JOIN wells    ON disbhist.cWellID   = wells.cWellID ;
		         INTO CURSOR tempK1a READWRITE ;
		         GROUP BY disbhist.cProgcode, disbhist.cownerid ;
		         ORDER BY disbhist.cProgcode, disbhist.cownerid
		
		      oProgress.SetProgressMessage('Building K1 Records...Step 2')
		      oProgress.UpdateProgress(9)
		
		      SELECT  disbhist.cownerid, ;
		         investor.cownname AS invname, ;
		         disbhist.cWellID, ;
		         wells.cwellname, ;
		         disbhist.cProgcode, ;
		         IIF(disbhist.ctypeinv = 'W',.F.,.T.) as lRoyalty, ;
		         programs.cprogname, ;
		         programs.nprogtype, ;
		         'Individual'   AS centity, ;
		         SUM(nexpense + disbhist.ngather + disbhist.ncompress)  AS nexptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(disbhist.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(disbhist.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal ;
		         WHERE BETWEEN(disbhist.cProgcode, lcProg1, lcProg2) ;
		         AND NOT EMPTY(csusptype) ;
		         AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'R','J')) ;
		         AND disbhist.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         FROM disbhist JOIN programs ON disbhist.cProgcode = programs.cProgcode ;
		         JOIN investor ON disbhist.cownerid  = investor.cownerid ;
		         JOIN wells    ON disbhist.cWellID   = wells.cWellID ;
		         INTO CURSOR tempK1b ;
		         GROUP BY disbhist.cProgcode, disbhist.cownerid ;
		         ORDER BY disbhist.cProgcode, disbhist.cownerid
		
		      oProgress.SetProgressMessage('Building K1 Records...Step 3')
		      oProgress.UpdateProgress(10)
		
		      SELECT  suspense.cownerid, ;
		         investor.cownname AS invname, ;
		         suspense.cWellID, ;
		         wells.cwellname, ;
		         suspense.cProgcode, ;
		         programs.cprogname, ;
		         programs.nprogtype, ;
		         IIF(suspense.ctypeinv = 'W',.F.,.T.) as lRoyalty, ;
		         'Individual'   AS centity, ;
		         SUM(nexpense + suspense.ngather + suspense.ncompress)  AS nexptotal, ;
		         IIF(suspense.ctypeinv = 'W',SUM(noilrev),000000000.00)   AS noiltotal, ;
		         IIF(suspense.ctypeinv = 'W',SUM(ngasrev),000000000.00)   AS ngastotal, ;
		         IIF(suspense.ctypeinv = 'W',SUM(ntrprev),000000000.00)   AS ntrptotal, ;
		         IIF(suspense.ctypeinv = 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotal, ;
		         IIF(suspense.ctypeinv # 'W',SUM(noilrev),000000000.00)   AS noiltotalr, ;
		         IIF(suspense.ctypeinv # 'W',SUM(ngasrev),000000000.00)   AS ngastotalr, ;
		         IIF(suspense.ctypeinv # 'W',SUM(ntrprev),000000000.00)   AS ntrptotalr, ;
		         IIF(suspense.ctypeinv # 'W',SUM(nothrev+nmiscrev1+nmiscrev2),000000000.00)   AS nothtotalr, ;
		         SUM(ntotale1 + ntotale2 + ntotale3 + ntotale4 + ntotale5)  AS nclasstotal, ;
		         SUM(nsevtaxes) AS ntaxtotal, ;
		         SUM(nnetcheck) AS nnettotal ;
		         WHERE BETWEEN(suspense.cProgcode, lcProg1, lcProg2) ;
		         AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear AND INLIST(ctypeclose,'R','J')) ;
		         AND suspense.lProgram = .F. ;
		         AND programs.lprog1099 = .F. ;
		         AND &lcExclude ;
		         FROM suspense JOIN programs ON suspense.cProgcode = programs.cProgcode ;
		         JOIN investor ON suspense.cownerid  = investor.cownerid ;
		         JOIN wells    ON suspense.cWellID   = wells.cWellID ;
		         INTO CURSOR tempK1c ;
		         GROUP BY suspense.cProgcode, suspense.cownerid ;
		         ORDER BY suspense.cProgcode, suspense.cownerid
		
		      oProgress.SetProgressMessage('Building K1 Records...Step 4')
		      oProgress.UpdateProgress(11)
		
		      SELECT tempK1a
		      APPEND FROM DBF('tempk1b')
		      APPEND FROM DBF('tempk1c')
		      lnK1 = RECCOUNT()
		
		   ENDIF
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 5')
		   oProgress.UpdateProgress(12)
		   SELECT  cownerid, invname, cWellID, cwellname, cProgcode, cprogname, nprogtype, ;
		      centity, ;
		      lRoyalty, ;
		      SUM(nexptotal)  AS nexptotal, ;
		      SUM(noiltotal)  AS noiltotal, ;
		      SUM(ngastotal)  AS ngastotal, ;
		      SUM(ntrptotal)  AS ntrptotal, ;
		      SUM(nothtotal)  AS nothtotal, ;
		      SUM(noiltotalr) AS noiltotalr, ;
		      SUM(ngastotalr) AS ngastotalr, ;
		      SUM(ntrptotalr) AS ntrptotalr, ;
		      SUM(nothtotalr) AS nothtotalr, ;
		      SUM(nclasstotal) AS nclasstotal, ;
		      SUM(ntaxtotal)  AS ntaxtotal, ;
		      SUM(nnettotal)  AS nnettotal ;
		      FROM tempK1a ;
		      INTO CURSOR tempk1 ;
		      ORDER BY cProgcode, cownerid ;
		      GROUP BY cProgcode, cownerid
		
		   lnK1 = _TALLY
		
		   SELECT cWellID, cProgcode FROM wellinv INTO CURSOR progwells ;
		      WHERE BETWEEN(cProgcode, lcProg1, lcProg2) ;
		      ORDER BY cProgcode, cWellID ;
		      GROUP BY cProgcode, cWellID
		   ******************************************************************
		   *   Load the K1File table
		   ******************************************************************
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 6')
		   oProgress.UpdateProgress(13)
		   SELECT tempk1
		   SCAN
		      SCATTER MEMVAR
		      m.cidk1file = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		      m.cyear     = lcYear
		
		      IF m.nprogtype = 2
		         m.lLLCPart = .T.
		         m.lGenPart = .F.
		      ELSE
		         m.lGenPart = .T.
		         m.lLLCPart = .F.
		      ENDIF
		
		      * Calculate the depletion
		      SELECT progwells
		      SCAN FOR cownerid == m.cownerid AND cProgcode == m.cProgcode
		         m.cWellID = cWellID
		         llReturn  = calcdepl(lcYear, m.cownerid, m.cownerid, .F., m.cWellID, m.cProgcode, llProcessed)
		         IF llReturn
		            SELECT depltemp
		            m.ndepletion = tempdepl.nTentDepl
		            APPEND FROM DBF('tempdepl')
		         ELSE
		            EXIT
		         ENDIF
		      ENDSCAN
		
		      IF NOT llReturn
		         EXIT
		      ENDIF
		
		      * Plug in the partership owner pcts
		      SELECT progrel
		      SET ORDER TO progown
		      IF SEEK(m.cProgcode + m.cownerid)
		         STORE nPct TO m.nPctProfitBeg, m.nPctLossBeg, m.nPctCapBeg, ;
		                       m.nPctProfitEnd, m.nPctLossEnd, m.nPctCapEnd
		      ELSE
		         SELECT disbhist
		         LOCATE FOR cownerid = m.cownerid AND cProgcode = m.cProgcode AND nrunno # 0 AND nincome # 0 AND crunyear = lcYear
		         IF FOUND()
		            swselect('ownpcts')
		            LOCATE FOR ciddisb == disbhist.ciddisb
		            IF FOUND()
		               IF disbhist.ctypeinv # 'W'
		                  m.nWorkInt = ownpcts.nrevgas
		                  llRoyalty  = .T.
		               ELSE    
		                  llRoyalty  = .F.   
		                  m.nWorkInt = nWorkInt
		               ENDIF 
		               IF USED('tempprog1')
		                  SELECT tempprog1
		                  LOCATE FOR cProgcode = m.cProgcode
		                  IF FOUND()
		                     m.nPct       = ROUND(m.nWorkInt / (nPct / 100), 7)
		                     STORE m.nPct TO m.nPctProfitBeg, m.nPctLossBeg, m.nPctCapBeg, ;
		                                     m.nPctProfitEnd, m.nPctLossEnd, m.nPctCapEnd
		                  ENDIF
		               ENDIF
		            ENDIF
		         ELSE
		            SELECT suspense
		            LOCATE FOR cownerid = m.cownerid AND cProgcode = m.cProgcode AND nrunno_in # 0 AND nincome # 0
		            IF FOUND()
		               IF suspense.ctypeinv # 'W'
		                  m.nWorkInt = suspense.nrevgas
		                  llRoyalty  = .T.
		               ELSE    
		                  llRoyalty  = .F.   
		                  m.nWorkInt = nWorkInt
		               ENDIF 
		               
		               IF USED('tempprog1')
		                  SELECT tempprog1
		                  LOCATE FOR cProgcode = m.cProgcode
		                  IF FOUND()
		                     m.nPct       = ROUND(m.nWorkInt / (nPct / 100), 7)
		                     STORE m.nPct TO m.nPctProfitBeg, m.nPctLossBeg, m.nPctCapBeg, ;
		                                     m.nPctProfitEnd, m.nPctLossEnd, m.nPctCapEnd
		                  ENDIF
		               ENDIF
		            ELSE
		              STORE 0 TO m.nPctProfitBeg, m.nPctLossBeg, m.nPctCapBeg, ;
		                         m.nPctProfitEnd, m.nPctLossEnd, m.nPctCapEnd
		            ENDIF
		         ENDIF
		      ENDIF
		
		      m.npartshare = m.nnettotal
		      m.npartdist  = m.nnettotal
		      m.ncapbal    = 0
		      m.nordincome = m.nnettotal
		
		      IF NOT m.lRoyalty
		         m.ngrossinc  = m.noiltotal + m.ngastotal + m.ntrptotal + m.nothtotal
		      ELSE
		         m.ngrossinc  = m.noiltotalr + m.ngastotalr + m.ntrptotalr + m.nothtotalr
		      ENDIF    
		      m.ngrossexp  = m.nexptotal + m.nclasstotal + m.ntaxtotal
		
		      INSERT INTO k1file FROM MEMVAR
		   ENDSCAN
		
		   IF NOT llReturn
		      EXIT
		   ENDIF
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 7')
		   oProgress.UpdateProgress(14)
		
		   * Check for missing owners
		   SELECT cownerid, cProgcode ;
		      FROM wellinv ;
		      WHERE NOT EMPTY(cProgcode) ;
		      AND BETWEEN(cProgcode,lcProg1,lcProg2) ;
		      AND &lcExclude ;
		      INTO CURSOR tempcode ;
		      ORDER BY cownerid, cProgcode ;
		      GROUP BY cownerid, cProgcode
		   SELECT cownerid, cProgcode, cWellID ;
		      FROM wellinv ;
		      WHERE NOT EMPTY(cProgcode) ;
		      AND BETWEEN(cProgcode,lcProg1,lcProg2) ;
		      AND &lcExclude ;
		      INTO CURSOR tempcode1 ;
		      ORDER BY cownerid, cProgcode, cWellID ;
		      GROUP BY cownerid, cProgcode, cWellID
		   *!*	SELECT cownerid, cprogcode FROM tempcode WHERE cownerid+cprogcode NOT IN (SELECT cownerid+cprogcode FROM k1file WITH (BUFFERING=.T.) WHERE cYear=lcYear) ;
		   *!*	   INTO CURSOR missingpart ORDER BY cownerid, cprogcode GROUP BY cownerid, cprogcode
		
		   CREATE CURSOR missingpart (cownerid C(10), cProgcode C(10))
		   CREATE CURSOR missingpart1 (cownerid C(10), cProgcode C(10), cWellID C(10))
		   SELECT tempcode
		   SCAN
		      SCATTER MEMVAR
		
		      SELECT k1file
		      SET ORDER TO YRPROGOWN   && CYEAR+CPROGCODE+COWNERID
		      IF NOT SEEK(lcYear+m.cProgcode+m.cownerid)
		         INSERT INTO missingpart FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELECT tempcode1
		   SCAN
		      SCATTER MEMVAR
		
		      SELECT k1file
		      SET ORDER TO YRPROGOWN   && CYEAR+CPROGCODE+COWNERID
		      IF NOT SEEK(lcYear+m.cProgcode+m.cownerid)
		         INSERT INTO missingpart1 FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELECT missingpart1
		   SCAN
		      SCATTER MEMVAR
		      llReturn = calcdepl(lcYear, m.cownerid, m.cownerid, .F., m.cWellID, m.cProgcode, llProcessed)
		      IF llReturn
		         SELECT depltemp
		         m.ndepletion = tempdepl.nTentDepl
		         APPEND FROM DBF('tempdepl')
		      ELSE
		         EXIT
		      ENDIF
		   ENDSCAN
		
		   IF NOT llReturn
		      EXIT
		   ENDIF
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 8')
		   oProgress.UpdateProgress(15)
		   SELECT  wellinv.cownerid, ;
		      investor.cownname AS invname, ;
		      wellinv.cWellID, ;
		      wells.cwellname, ;
		      wellinv.cProgcode, ;
		      programs.cprogname, ;
		      programs.nprogtype, ;
		      'Individual'   AS centity, ;
		      0  AS nexptotal, ;
		      0   AS noiltotal, ;
		      0   AS ngastotal, ;
		      0  AS ntrptotal, ;
		      0  AS nothtotal, ;
		      0  AS nclasstotal, ;
		      0 AS ntaxtotal, ;
		      0 AS nnettotal ;
		      WHERE BETWEEN(wellinv.cProgcode, lcProg1, lcProg2) ;
		      AND wellinv.cownerid + wellinv.cProgcode IN (SELECT  cownerid + cProgcode ;
		      FROM missingpart) ;
		      AND programs.lprog1099 = .F. ;
		      AND &lcExclude ;
		      FROM wellinv     JOIN programs ON wellinv.cProgcode = programs.cProgcode ;
		      JOIN investor ON wellinv.cownerid  = investor.cownerid ;
		      JOIN wells    ON wellinv.cWellID   = wells.cWellID ;
		      INTO CURSOR tempmissing ;
		      GROUP BY wellinv.cProgcode, wellinv.cownerid ;
		      ORDER BY wellinv.cProgcode, wellinv.cownerid
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 9')
		   oProgress.UpdateProgress(16)
		   * Add a zero K1 for partners who didn't receive anything during the year
		   SELECT tempmissing
		   SCAN
		      SCATTER MEMVAR
		      m.cidk1file = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		      m.cyear     = lcYear
		
		      IF m.nprogtype = 2
		         m.lLLCPart = .T.
		         m.lGenPart = .F.
		      ELSE
		         m.lGenPart = .T.
		         m.lLLCPart = .F.
		      ENDIF
		
		      m.ndepletion = 0
		      llRoyalty    = .F.
		      SELECT progrel
		      SET ORDER TO progown
		      IF SEEK(m.cProgcode + m.cownerid)
		         STORE nPct TO m.nPctProfitBeg, m.nPctLossBeg, m.nPctCapBeg, ;
		                                     m.nPctProfitEnd, m.nPctLossEnd, m.nPctCapEnd
		      ELSE
		         SELECT disbhist
		         LOCATE FOR cownerid = m.cownerid AND cProgcode = m.cProgcode AND nrunno # 0
		         IF FOUND()
		            swselect('ownpcts')
		            LOCATE FOR ciddisb == disbhist.ciddisb
		            IF FOUND()
		               IF disbhist.ctypeinv # 'W'
		                  m.nWorkInt = ownpcts.nrevgas
		                  llRoyalty  = .T.
		               ELSE    
		                  llRoyalty  = .F.   
		               ENDIF 
		               m.nWorkInt = nWorkInt
		               IF USED('tempprog1')
		                  SELECT tempprog1
		                  LOCATE FOR cProgcode = m.cProgcode
		                  IF FOUND()
		                     m.nPct       = ROUND(m.nWorkInt / (nPct / 100), 7)
		                     STORE m.nPct TO m.nPctProfitBeg, m.nPctLossBeg, m.nPctCapBeg, ;
		                                     m.nPctProfitEnd, m.nPctLossEnd, m.nPctCapEnd
		                  ENDIF
		               ENDIF
		            ENDIF
		         ELSE
		            SELECT suspense
		            LOCATE FOR cownerid = m.cownerid AND cProgcode = m.cProgcode AND nrunno_in # 0
		            IF FOUND()
		               IF suspense.ctypeinv # 'W'
		                  m.nWorkInt = suspense.nrevgas
		                  llRoyalty  = .T.
		               ELSE    
		                  llRoyalty  = .F.      
		               ENDIF 
		               m.nWorkInt = nWorkInt
		               IF USED('tempprog1')
		                  SELECT tempprog1
		                  LOCATE FOR cProgcode = m.cProgcode
		                  IF FOUND()
		                     m.nPct       = ROUND(m.nWorkInt / (nPct / 100), 7)
		                     STORE m.nPct TO m.nPctProfitBeg, m.nPctLossBeg, m.nPctCapBeg, ;
		                                     m.nPctProfitEnd, m.nPctLossEnd, m.nPctCapEnd
		                  ENDIF
		               ENDIF
		            ELSE
		               STORE 0 TO m.nPctProfitBeg, m.nPctLossBeg, m.nPctCapBeg, ;
		                          m.nPctProfitEnd, m.nPctLossEnd, m.nPctCapEnd
		            ENDIF
		         ENDIF
		      ENDIF
		
		      m.npartshare = 0
		      m.npartdist  = 0
		      m.ncapbal    = 0
		      m.nordincome = 0
		      m.ngrossinc  = 0
		      m.ngrossexp  = 0
		
		      INSERT INTO k1file FROM MEMVAR
		      lnK1 = lnK1 + 1
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 10')
		   oProgress.UpdateProgress(17)
		   * Zero out pcts if the owner doesn't have a pct in the program anymore
		   SELECT k1file
		   SCAN FOR cyear == lcYear
		      m.cownerid  = cownerid
		      m.cProgcode = cProgcode
		
		      SELECT wellinv
		      LOCATE FOR cownerid == m.cownerid AND cProgcode == m.cProgcode
		      IF NOT FOUND()
		         SELECT k1file
		         REPLACE npctprofitbeg WITH 0, ;
		            npctlossbeg   WITH 0, ;
		            npctcapbeg    WITH 0, ;
		            npctprofitend WITH 0, ;
		            npctlossend   WITH 0, ;
		            npccapend     WITH 0
		      ENDIF
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 11')
		   oProgress.UpdateProgress(18)
		   * Fill in the tax id to the depltemp file
		   swselect('investor')
		   SET ORDER TO cownerid
		   swselect('depltemp')
		   SCAN
		      m.cownerid = cownerid
		      SELECT investor
		      IF SEEK(m.cownerid)
		         m.cinvtaxid = ctaxid
		         SELECT depltemp
		         REPLACE cinvtaxid WITH cmencrypt(ALLTRIM(m.cinvtaxid),m.goApp.cEncryptionKey)
		      ENDIF
		   ENDSCAN
		
		   oProgress.SetProgressMessage('Building K1 Records...Step 12')
		   oProgress.UpdateProgress(19)
		   WAIT CLEAR
		   TABLEUPDATE(.T., .T., 'Form1065')
		   TABLEUPDATE(.T., .T., 'K1File')
		
		   oProgress.SetProgressMessage('Building 1065 Deduction Statements...')
		   oProgress.UpdateProgress(15)
		   * Create the statement1 file for line 20 of 1065
		   THISFORM.makedeductfile()
		   
		   * Create k1 deduct table
		   thisform.makeowndeducts() 
		
		   * Clean up depletion file
		   SELECT depltemp
		   DELETE FOR cyear = lcYear AND nNetInc = 0 AND ngrossinc = 0 AND nDirExp = 0
		
		   oProgress.CloseProgress()
		   RELEASE oProgress
		
		   THISFORM.omessage.DISPLAY('Created: ' + TRANSFORM(lnTally1065) + ' Form 1065 Records and ' + ;
		      TRANSFORM(lnK1) + ' Form K1 Records')
		
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'MakeFile', loError.LINENO, 'Form 1065', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		IF NOT llReturn
		   IF VARTYPE(oProgress) = 'O'
		      oProgress.CloseProgress()
		      RELEASE oProgress
		   ENDIF
		ENDIF
		
		RETURN llReturn
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE makeowndeducts		&& Creates a file that contains the partner's share of each deduction.
		LOCAL lcYear, lcProg1, lcProg2, llProcessed, llDisbursed
		
		llReturn = .T.
		
		TRY
		   lcYear      = THISFORM.txtcyear.VALUE
		   lcProg1     = THISFORM.swrptlook1.txtbegid.VALUE
		   lcProg2     = THISFORM.swrptlook1.txtendid.VALUE
		   llProcessed = THISFORM.chkProcessed.VALUE
		   llDisbursed = THISFORM.chkdisbursed.VALUE
		
		
		   WAIT WINDOW NOWAIT 'Creating Deducts File....'
		   swselect('sysctl')
		   swselect('expense')
		   swselect('wellinv')
		   swselect('expcat')
		   swselect('taxcodes')
		   swselect('disbhist')
		   swselect('ownpcts')
		
		   SELECT ownpcts
		   SET ORDER TO ciddisb
		
		   CREATE CURSOR tempexpense ;
		      (cwellid     c(10), ;
		      cprogcode   c(10), ;
		      cprogname   c(40), ;
		      ctaxid      c(15), ;
		      nrunno      i, ;
		      crunyear    c(4), ;
		      ctaxcode    c(2), ;
		      cdesc       c(30), ;
		      ccatcode    c(4), ;
		      ccateg      c(30), ;
		      cownerid    c(10), ;
		      ninterest   N(11, 7), ;
		      ngrossamt   N(12, 2), ;
		      nprogamt    N(12, 2))
		
		   * Replace missing taxcodes
		   SELECT expcat
		   REPLACE ctaxcode WITH 'OE' FOR EMPTY(ctaxcode)
		
		   * Create a cursor of all expenses for the given year and programs for revenue runs
		   SELECT  'R' AS cType, expense.nrunnorev AS nrunno, expense.crunyearrev AS crunyear, expense.cwellid, ;
		      expense.cexpclass, expense.ccatcode, expcat.ctaxcode, expcat.ccateg, taxcodes.cdesc, SUM(namount) AS namount ;
		      FROM expense, expcat, taxcodes, programs ;
		      WHERE TRANSFORM(YEAR(expense.dacctdate)) = lcYear ;
		      AND expense.crunyearrev <> '1900' ;
		      AND expense.cwellid IN (SELECT  cwellid FROM wellinv ;
		      WHERE BETWEEN(cprogcode, lcProg1, lcProg2)) ;
		      AND expense.ccatcode = expcat.ccatcode ;
		      AND expcat.ctaxcode  = taxcodes.ctaxcode ;
		      INTO CURSOR exp1065 READWRITE  ;
		      ORDER BY expense.nrunnorev, expense.crunyearrev, expense.cwellid, expense.cexpclass, expcat.ctaxcode, expcat.ccateg ;
		      GROUP BY expense.nrunnorev, expense.crunyearrev, expense.cwellid, expense.cexpclass, expcat.ctaxcode, expcat.ccateg
		
		   * Create a cursor of all expenses for the given year and programs for revenue runs
		   SELECT  'J' AS cType, expense.nrunnojib AS nrunno, expense.crunyearjib AS crunyear, expense.cwellid, ;
		      expense.cexpclass, expcat.ctaxcode, expense.ccatcode, expcat.ccateg, taxcodes.cdesc, SUM(namount) AS namount ;
		      FROM expense, expcat, taxcodes ;
		      WHERE TRANSFORM(YEAR(expense.dacctdate)) = lcYear ;
		      AND expense.crunyearjib <> '1900' ;
		      AND expense.cwellid IN (SELECT  cwellid ;
		      FROM wellinv ;
		      WHERE BETWEEN(cprogcode, lcProg1, lcProg2)) ;
		      AND expense.ccatcode = expcat.ccatcode ;
		      AND expcat.ctaxcode  = taxcodes.ctaxcode ;
		      INTO CURSOR exp1065j  ;
		      ORDER BY expense.nrunnorev, expense.crunyearrev, expense.cwellid, expense.cexpclass, expcat.ctaxcode, expcat.ccateg ;
		      GROUP BY expense.nrunnorev, expense.crunyearrev, expense.cwellid, expense.cexpclass, expcat.ctaxcode, expcat.ccateg
		
		   SELECT exp1065
		   APPEND FROM DBF('exp1065j')
		
		   * Now that we have all the expenses grouped by taxcode
		   * we can calculate the program's share of the expense
		   * by scanning through wellinv to get the partner's
		   * percentages
		
		   SELECT cType, nrunno, crunyear FROM exp1065 INTO CURSOR tempruns ORDER BY cType, crunyear, nrunno GROUP BY cType, crunyear, nrunno
		
		   SELECT  crectype, crunyear, nrunno, cwellid, cprogcode, cownerid, ciddisb, crunyear_in, nrunno_in, ljib ;
		      FROM disbhist ;
		      WHERE BETWEEN(cprogcode, lcProg1, lcProg2) ;
		      AND cprogcode IN (SELECT  cprogcode ;
		      FROM programs ;
		      WHERE lprog1099 = .F.) ;
		      AND EMPTY(csusptype) ;
		      AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		      (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		      INTO CURSOR owntemp READWRITE ;
		      ORDER BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid ;
		      GROUP BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid
		
		   SELECT  crectype, crunyear, nrunno, cwellid, cprogcode, cownerid, ciddisb, crunyear_in, nrunno_in, ljib ;
		      FROM disbhist ;
		      WHERE BETWEEN(cprogcode, lcProg1, lcProg2) ;
		      AND cprogcode IN (SELECT  cprogcode ;
		      FROM programs ;
		      WHERE lprog1099 = .F.) ;
		      AND NOT EMPTY(csusptype) ;
		      AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		      (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		      AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') IN ;
		      (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		      FROM sysctl ;
		      WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		      INTO CURSOR owntempa ;
		      ORDER BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid ;
		      GROUP BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid
		
		   SELECT owntemp
		   APPEND FROM DBF('owntempa')
		
		   IF llDisbursed
		      SELECT  crectype, crunyear, nrunno, cwellid, cprogcode, cownerid, ciddisb, crunyear_in, nrunno_in, ljib ;
		         FROM disbhist ;
		         WHERE BETWEEN(cprogcode, lcProg1, lcProg2) ;
		         AND cprogcode IN (SELECT  cprogcode ;
		         FROM programs ;
		         WHERE lprog1099 = .F.) ;
		         AND NOT EMPTY(csusptype) ;
		         AND crunyear + PADL(TRANSFORM(nrunno), 3, '0') IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		         AND crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') NOT IN ;
		         (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		         INTO CURSOR owntempb ;
		         ORDER BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid ;
		         GROUP BY cprogcode, cwellid, crunyear, nrunno, crunyear_in, nrunno_in, cownerid
		
		      SELECT owntemp
		      APPEND FROM DBF('owntempb')
		   ENDIF
		
		   swselect('programs')
		   SET ORDER TO cprogcode
		
		   SELECT tempruns
		   SCAN
		      SCATTER MEMVAR
		      SELECT owntemp
		      SCAN FOR IIF(nrunno_in = 0, nrunno = m.nrunno AND crunyear = m.crunyear, nrunno_in = m.nrunno AND crunyear_in = m.crunyear) ;
		            AND BETWEEN(cprogcode, lcProg1, lcProg2) AND crectype = m.cType
		         m.cwellid   = cwellid
		         m.cprogcode = cprogcode
		         m.ciddisb   = ciddisb
		         m.cownerid  = cownerid
		         m.ljib      = ljib
		
		         SELECT programs
		         IF SEEK(m.cprogcode)
		            IF lprog1099
		               LOOP
		            ELSE
		               m.cprogname = cprogname
		               m.ctaxid    = cprogtaxid
		            ENDIF
		         ENDIF
		
		         IF m.cType = 'J' AND NOT m.ljib
		            LOOP
		         ENDIF
		
		         SELECT ownpcts
		         IF SEEK(m.ciddisb)
		            SELECT exp1065
		            SCAN FOR cwellid == m.cwellid AND nrunno = m.nrunno AND crunyear = m.crunyear AND cType = m.cType
		               m.ctaxcode  = ctaxcode
		               m.cexpclass = cexpclass
		               m.ccateg    = ccateg
		               m.ngrossamt = namount
		               m.cdesc     = cdesc
		               m.ccatcode  = ccatcode
		
		               DO CASE
		                  CASE m.cexpclass = '0'
		                     m.ninterest = ownpcts.nworkint
		                  CASE m.cexpclass = '1'
		                     m.ninterest = ownpcts.nintclass1
		                  CASE m.cexpclass = '2'
		                     m.ninterest = ownpcts.nintclass2
		                  CASE m.cexpclass = '3'
		                     m.ninterest = ownpcts.nintclass3
		                  CASE m.cexpclass = '4'
		                     m.ninterest = ownpcts.nintclass4
		                  CASE m.cexpclass = '5'
		                     m.ninterest = ownpcts.nintclass5
		                  CASE m.cexpclass = 'A'
		                     m.ninterest = ownpcts.nintclassa
		                  CASE m.cexpclass = 'B'
		                     m.ninterest = ownpcts.nintclassb
		                  OTHERWISE
		                     m.ninterest = ownpcts.nworkint
		               ENDCASE
		
		               m.nprogamt = ROUND(m.ngrossamt * (m.ninterest / 100), 2)
		
		               INSERT INTO tempexpense FROM MEMVAR
		            ENDSCAN
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		
		   IF llProcessed
		      SELECT  * ;
		         FROM suspense ;
		         WHERE crunyear_in + PADL(TRANSFORM(nrunno_in), 3, '0') ;
		         IN (SELECT  crunyear + PADL(TRANSFORM(nrunno), 3, '0') ;
		         FROM sysctl ;
		         WHERE TRANSFORM(YEAR(dacctdate)) = lcYear) ;
		         AND BETWEEN(cprogcode, lcProg1, lcProg2) ;
		         AND cprogcode IN (SELECT  cprogcode ;
		         FROM programs ;
		         WHERE lprog1099 = .F.) ;
		         INTO CURSOR sustemp ;
		         ORDER BY cprogcode, cwellid, crunyear_in, nrunno_in, cownerid ;
		         GROUP BY cprogcode, cwellid, crunyear_in, nrunno_in, cownerid
		
		      SELECT tempruns
		      SCAN
		         SCATTER MEMVAR
		         SELECT sustemp
		         SCAN FOR nrunno_in = m.nrunno AND crunyear_in = m.crunyear AND BETWEEN(cprogcode, lcProg1, lcProg2) AND crectype = m.cType
		            m.cwellid   = cwellid
		            m.cprogcode = cprogcode
		            m.ciddisb   = ciddisb
		            m.cownerid  = cownerid
		            m.ljib      = ljib
		
		            SELECT programs
		            IF SEEK(m.cprogcode)
		               IF lprog1099
		                  LOOP
		               ELSE
		                  m.cprogname = cprogname
		                  m.ctaxid    = cprogtaxid
		               ENDIF
		            ENDIF
		
		            IF m.cType = 'J' AND NOT m.ljib
		               LOOP
		            ENDIF
		
		            SELECT exp1065
		            SCAN FOR cwellid == m.cwellid AND nrunno = m.nrunno AND crunyear = m.crunyear AND cType = m.cType
		               m.ctaxcode  = ctaxcode
		               m.cexpclass = cexpclass
		               m.ccateg    = ccateg
		               m.ngrossamt = namount
		               m.cdesc     = cdesc
		               m.ccatcode  = ccatcode
		
		               DO CASE
		                  CASE m.cexpclass = '0'
		                     m.ninterest = sustemp.nworkint
		                  CASE m.cexpclass = '1'
		                     m.ninterest = sustemp.nintclass1
		                  CASE m.cexpclass = '2'
		                     m.ninterest = sustemp.nintclass2
		                  CASE m.cexpclass = '3'
		                     m.ninterest = sustemp.nintclass3
		                  CASE m.cexpclass = '4'
		                     m.ninterest = sustemp.nintclass4
		                  CASE m.cexpclass = '5'
		                     m.ninterest = sustemp.nintclass5
		                  CASE m.cexpclass = 'A'
		                     m.ninterest = sustemp.nintclassa
		                  CASE m.cexpclass = 'B'
		                     m.ninterest = sustemp.nintclassb
		                  OTHERWISE
		                     m.ninterest = sustemp.nworkint
		               ENDCASE
		
		               m.nprogamt = ROUND(m.ngrossamt * (m.ninterest / 100), 2)
		
		               INSERT INTO tempexpense FROM MEMVAR
		            ENDSCAN
		         ENDSCAN
		      ENDSCAN
		   ENDIF
		
		   SELECT  lcYear AS cyear, cprogcode, cprogname, cownerid, ctaxcode, cdesc, ccateg, SUM(nprogamt) AS namount ;
		      FROM tempexpense ;
		      INTO CURSOR tempdeducts ;
		      ORDER BY cprogcode, cownerid, ctaxcode, ccateg ;
		      GROUP BY cprogcode, cownerid, ctaxcode, ccateg
		
		   swselect('k1deducts')
		   APPEND FROM DBF('tempdeducts')
		
		   SELECT  cprogcode, cownerid, SUM(namount) AS namount ;
		      FROM k1deducts ;
		      INTO CURSOR tmpk1deds ;
		      WHERE cyear = lcYear ;
		      AND ctaxcode # 'ID' ;
		      ORDER BY cprogcode, cownerid ;
		      GROUP BY cprogcode, cownerid
		
		   SELECT tmpk1deds
		   SCAN
		      SCATTER MEMVAR
		
		      SELECT k1file
		      LOCATE FOR cprogcode = m.cprogcode AND cyear = lcYear AND cownerid = m.cownerid
		      IF FOUND()
		         IF nGrossExp # m.namount
		            lnDiff = nGrossExp - m.namount
		            SELECT k1deducts
		            LOCATE FOR cprogcode = m.cprogcode AND cyear = lcYear AND ctaxcode = 'OD' AND cownerid = m.cownerid
		            IF FOUND()
		               REPLACE namount WITH namount + lnDiff
		            ELSE
		               LOCATE FOR cprogcode = m.cprogcode AND cyear = lcYear AND ctaxcode = 'OE' AND cownerid = m.cownerid
		               IF FOUND()
		                  REPLACE namount WITH namount + lnDiff
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF 
		   ENDSCAN
		
		      WAIT CLEAR
		   CATCH TO loError
		      llReturn = .F.
		      DO errorlog WITH 'MakeDeductFile', loError.LINENO, 'Form 1065', loError.ERRORNO, loError.MESSAGE, '', loError
		      MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		         'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		   ENDTRY
		
		   RETURN llReturn
		
		
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE chkDisbursed.Click
		IF this.Value
		   thisform.chkProcessed.Value = .f.
		ELSE
		   thisform.chkProcessed.Value = .t.   
		ENDIF 
	ENDPROC

	PROCEDURE chkExclude.When
		RETURN NOT FILE('datafiles\1065roy.txt')
	ENDPROC

	PROCEDURE chkProcessed.Click
		IF this.Value
		   thisform.chkDisbursed.Value = .f.
		ELSE
		   thisform.chkdisbursed.Value = .t.
		ENDIF 
	ENDPROC

	PROCEDURE cmdCreate.Click
		thisform.makefile()
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE Swrptlook1.Swlookupbutton1.Click
		PRIV llOK
		LOCAL lcList
		
		llOK = .F.
		
		lcList = 'cprogcode,cprogname'
		
		DO FORM ..\custom\picklist WITH 'Programs',lcList,programs.cprogcode, 2
		
		IF llOK
		   thisform.swrptlook1.txtbegid.value = programs.cprogcode
		   thisform.swrptlook1.txtbegid.refresh()
		   thisform.swrptlook1.txtbegname.value = programs.cprogname
		   thisform.swrptlook1.txtbegname.refresh()
		ENDIF   
	ENDPROC

	PROCEDURE Swrptlook1.Swlookupbutton2.Click
		PRIV llOK
		LOCAL lcList
		
		llOK = .F.
		
		lcList = 'cprogcode,cprogname'
		
		DO FORM ..\custom\picklist WITH 'Programs',lcList,programs.cprogcode, 2
		
		IF llOK
		   thisform.swrptlook1.txtendid.value = programs.cprogcode
		   thisform.swrptlook1.txtendid.refresh()
		   thisform.swrptlook1.txtendname.value = programs.cprogname
		   thisform.swrptlook1.txtendname.refresh()
		ENDIF   
	ENDPROC

	PROCEDURE txtcYear.Valid
		IF NOT BETWEEN(VAL(this.value),1900,2099)
		   WAIT WIND 'Invalid year, please re-enter...'
		   RETURN 0
		ENDIF
	ENDPROC

ENDDEFINE
