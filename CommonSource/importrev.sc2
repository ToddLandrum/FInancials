*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="importrev.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor18" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor19" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 688
	Left = 71
	Name = "Dataenvironment"
	Top = 100
	Width = 973

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "csrcthdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "csrcthdr", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 16, ;
		Name = "Cursor1", ;
		Top = 12, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "expcat", ;
		CursorSource = "expcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 338, ;
		Name = "Cursor10", ;
		Top = 294, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "importdefs", ;
		CursorSource = "importdefs", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 91, ;
		Left = 519, ;
		Name = "Cursor11", ;
		Top = 302, ;
		Width = 98
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 364, ;
		Name = "Cursor12", ;
		Top = 463, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "glmaster", ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 218, ;
		Name = "Cursor13", ;
		Top = 474, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "revsrc", ;
		CursorSource = "revsrc", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 545, ;
		Name = "Cursor14", ;
		Top = 472, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "expsusp", ;
		BufferModeOverride = 5, ;
		CursorSource = "expsusp", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 538, ;
		Name = "Cursor15", ;
		Top = 155, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 12, ;
		Name = "Cursor16", ;
		Top = 518, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "custvend", ;
		CursorSource = "custvend", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 680, ;
		Name = "Cursor17", ;
		Top = 177, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor18' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 702, ;
		Name = "Cursor18", ;
		Top = 338, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor19' AS cursor WITH ;
		Alias = "csrctdet1", ;
		CursorSource = "csrctdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 790, ;
		Name = "Cursor19", ;
		Top = 40, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "incsusp", ;
		BufferModeOverride = 5, ;
		CursorSource = "incsusp", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 266, ;
		Name = "Cursor2", ;
		Top = 0, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "revcat", ;
		CursorSource = "revcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 397, ;
		Name = "Cursor3", ;
		Top = 30, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor4", ;
		Top = 20, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 213, ;
		Name = "Cursor5", ;
		Top = 294, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "csrctdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "csrctdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 125, ;
		Name = "Cursor6", ;
		Top = 16, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "income", ;
		BufferModeOverride = 5, ;
		CursorSource = "income", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 266, ;
		Name = "Cursor7", ;
		Top = 170, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "expense", ;
		BufferModeOverride = 5, ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 404, ;
		Name = "Cursor8", ;
		Top = 169, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "importmap", ;
		CursorSource = "importmap", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 158, ;
		Left = 69, ;
		Name = "Cursor9", ;
		Top = 288, ;
		Width = 102
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Relation1' AS relation WITH ;
		ChildAlias = "incsusp", ;
		ChildOrder = "cwellid", ;
		Name = "Relation1", ;
		ParentAlias = "wells", ;
		RelationalExpr = "cwellid"
		*< END OBJECT: BaseClass="relation" />

	ADD OBJECT 'Relation2' AS relation WITH ;
		ChildAlias = "income", ;
		ChildOrder = "cwellid", ;
		Name = "Relation2", ;
		ParentAlias = "wells", ;
		RelationalExpr = "cwellid"
		*< END OBJECT: BaseClass="relation" />

	ADD OBJECT 'Relation3' AS relation WITH ;
		ChildAlias = "expense", ;
		ChildOrder = "cwellid", ;
		Name = "Relation3", ;
		ParentAlias = "wells", ;
		RelationalExpr = "cwellid"
		*< END OBJECT: BaseClass="relation" />

	ADD OBJECT 'Relation4' AS relation WITH ;
		ChildAlias = "expsusp", ;
		ChildOrder = "cwellid", ;
		Name = "Relation4", ;
		ParentAlias = "wells", ;
		RelationalExpr = "cwellid"
		*< END OBJECT: BaseClass="relation" />

ENDDEFINE

DEFINE CLASS formimport AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shpshapecustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdImport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="dCheckDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCvendorid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcPurchName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblImport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboImportMap" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdMapping" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboCashAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgDeposits" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtPurchaser" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="QBAccountLab" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="QBACCOUNT1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkPostQB" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkMapped" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkEnergyLink" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCDEX" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdVendor" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCDEXRpt" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: allocevenly		&& Allocate the MCF total evenly among the wells tied to this master meter
		*m: buildcodes
		*m: buildmeter		&& Builds list of wells and data already imported into meterdata.
		*m: calcallocation		&& Does the allocation
		*m: chkforsubmeter		&& Checks to see if the wells have any totals
		*m: dmincome		&& Post receipt to well income table.
		*m: excelexit
		*m: findcode		&& Looks up the passed code to find what it is mapped to.
		*m: gasreceipts		&& Builds Cash Receipts from Imported Gas Data
		*m: getacctlistid
		*m: import		&& Imports the given format
		*m: importexcel		&& Import Excel Data
		*m: lookupoper
		*m: meter_report		&& Prints report of allocations done.
		*m: oilreceipts		&& Builds cash receipt from imported oil data
		*m: postbill
		*m: postrcptam
		*m: postrcptdm
		*m: postrcptqb
		*m: processcdex		&& Processes the importfile created by the import of a CDEX DAT file.
		*m: processcsv		&& Processes the importfile cursor created by importing an owner relations connect csv file.
		*m: processdeducts
		*m: qbpostbill
		*m: qbpostrec		&& Post receipt to QuickBooks
		*m: wellincome
		*p: ioperatorkpk
		*p: ioperatorpk
		*p: lqbnopost
		*p: lsendtoallocate
		*p: ntotalcheck
		*p: ntotalimport
		*p: odist
		*p: oexcel
		*p: ofile		&& SWFile object
	*</DefinedPropArrayMethod>

	Caption = "Import Receipts"
	DoCreate = .T.
	Height = 328
	ioperatorkpk = 0
	ioperatorpk = 0
	lnonewask = .T.
	lsendtoallocate = .F.
	Name = "FormImport"
	ntotalcheck = 0
	ntotalimport = 0
	ofile = .NULL.		&& SWFile object
	Width = 617
	_memberdata = <VFPData>
		<memberdata name="import" display="Import"/>
		<memberdata name="ofile" display="oFile"/>
		<memberdata name="processcsv" display="ProcessCSV"/>
		<memberdata name="processcdex" display="ProcessCDEX"/>
		<memberdata name="ioperatorpk" display="iOperatorPK"/>
		<memberdata name="ntotalimport" display="nTotalImport"/>
		<memberdata name="buildcodes" display="BuildCodes"/>
		<memberdata name="getacctlistid" display="GetAcctListID"/>
		<memberdata name="wellincome" display="WellIncome"/>
		<memberdata name="lsendtoallocate" display="lSendToAllocate"/>
		<memberdata name="postrcptqb" display="PostRcptQB"/>
		<memberdata name="postrcptam" display="PostRcptAM"/>
		<memberdata name="postrcptdm" display="PostRcptDM"/>
		<memberdata name="findcode" display="FindCode"/>
		<memberdata name="processdeducts" display="ProcessDeducts"/>
		</VFPData>
	cmdatamanager.Left = 4
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 16
	cmdatamanager.Top = 1
	cmlookupmanager.Left = 17
	cmlookupmanager.Name = "cmlookupmanager"
	cmlookupmanager.Top = 3
	MWRESIZE1.lblHighLight.Name = "lblHighLight"
	MWRESIZE1.lblShading.Name = "lblShading"
	MWRESIZE1.Left = 600
	MWRESIZE1.Name = "MWRESIZE1"
	MWRESIZE1.TabIndex = 17
	MWRESIZE1.Top = 312

	ADD OBJECT 'cboCashAcct' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		ColumnCount = 2, ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 252, ;
		Name = "cboCashAcct", ;
		TabIndex = 2, ;
		Top = 35, ;
		Visible = .F., ;
		Width = 348
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboImportMap' AS cbocomboboxcustom WITH ;
		Height = 22, ;
		Left = 211, ;
		Name = "cboImportMap", ;
		TabIndex = 12, ;
		Top = 228, ;
		Visible = .T., ;
		Width = 276
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkCDEX' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "CDEX Import", ;
		Left = 425, ;
		Name = "chkCDEX", ;
		TabIndex = 11, ;
		Top = 176, ;
		Value = .F., ;
		ZOrderSet = 24
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkEnergyLink' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "EnergyLink SherWare Voucher", ;
		Left = 221, ;
		Name = "chkEnergyLink", ;
		TabIndex = 10, ;
		Top = 176, ;
		Value = .F., ;
		ZOrderSet = 23
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkMapped' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Mapped Import", ;
		Left = 101, ;
		Name = "chkMapped", ;
		TabIndex = 9, ;
		Top = 176, ;
		Value = .T., ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkPostQB' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Don't Post To QuickBooks", ;
		Left = 240, ;
		Name = "chkPostQB", ;
		TabIndex = 22, ;
		Top = 10, ;
		Value = .F., ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkUseDate' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Use This Date Instead of Date in Import", ;
		Left = 273, ;
		Name = "chkUseDate", ;
		TabIndex = 8, ;
		Top = 110, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 36, ;
		Left = 372, ;
		Name = "cmdExit", ;
		TabIndex = 15, ;
		Top = 276, ;
		Width = 84
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdImport' AS cmdcommandbuttoncustom WITH ;
		Caption = "Choose Data", ;
		Height = 36, ;
		Left = 189, ;
		Name = "cmdImport", ;
		TabIndex = 13, ;
		Top = 276, ;
		Width = 84
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdMapping' AS cmdcommandbuttoncustom WITH ;
		Caption = "Mapping", ;
		Height = 36, ;
		Left = 288, ;
		Name = "cmdMapping", ;
		TabIndex = 14, ;
		Top = 276, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdVendor' AS swlookupbutton WITH ;
		Left = 203, ;
		Name = "cmdVendor", ;
		TabIndex = 5, ;
		Top = 72, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'dCheckDate' AS dpk WITH ;
		Left = 165, ;
		Name = "dCheckDate", ;
		TabIndex = 7, ;
		Top = 107
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 48, ;
		Name = "Glmaint", ;
		Top = 264
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCDEXRpt' AS lbllabelcustom WITH ;
		Caption = "", ;
		ForeColor = 255,0,0, ;
		Left = 441, ;
		Name = "lblCDEXRpt", ;
		TabIndex = 24, ;
		Top = 193, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCvendorid' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Received From:", ;
		Height = 16, ;
		Left = 30, ;
		Name = "lblCvendorid", ;
		TabIndex = 18, ;
		Top = 74, ;
		Width = 77, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblImport' AS lbllabelcustom WITH ;
		Caption = "Import Map", ;
		Left = 129, ;
		Name = "lblImport", ;
		TabIndex = 20, ;
		Top = 231, ;
		Visible = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Check Date", ;
		Left = 100, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 19, ;
		Top = 111
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Import Type", ;
		Left = 47, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 23, ;
		Top = 146, ;
		ZOrderSet = 25
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'opgDeposits' AS opgoptiongroupcustom WITH ;
		ButtonCount = 2, ;
		Height = 24, ;
		Left = 61, ;
		Name = "opgDeposits", ;
		TabIndex = 1, ;
		Top = 33, ;
		Value = 2, ;
		Visible = .F., ;
		Width = 204, ;
		Option1.Caption = "Group Deposits", ;
		Option1.FontSize = 8, ;
		Option1.Height = 17, ;
		Option1.Left = 7, ;
		Option1.Name = "optGroup", ;
		Option1.Top = 5, ;
		Option1.Width = 107, ;
		Option2.Caption = "Deposit To", ;
		Option2.FontSize = 8, ;
		Option2.Height = 19, ;
		Option2.Left = 118, ;
		Option2.Name = "optDepositTo", ;
		Option2.Top = 3, ;
		Option2.Value = 1, ;
		Option2.Width = 83
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'QBACCOUNT1' AS qbaccount WITH ;
		Height = 20, ;
		Left = 196, ;
		Name = "QBACCOUNT1", ;
		TabIndex = 3, ;
		Top = 35, ;
		Visible = .F., ;
		Width = 404
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'QBAccountLab' AS lbllabelcustom WITH ;
		Caption = "QB Checking Account:", ;
		Left = 69, ;
		Name = "QBAccountLab", ;
		TabIndex = 21, ;
		Top = 37, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Shpshapecustom1' AS shpshapecustom WITH ;
		Height = 60, ;
		Left = 37, ;
		Name = "Shpshapecustom1", ;
		Top = 153, ;
		Width = 540, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'txtcPurchName' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 248, ;
		Margin = 1, ;
		MaxLength = 40, ;
		Name = "txtcPurchName", ;
		ReadOnly = .F., ;
		TabIndex = 6, ;
		Top = 72, ;
		Width = 352, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtPurchaser' AS txtquickfill WITH ;
		clistexpression = , ;
		clistworkarea = , ;
		ControlSource = "", ;
		Format = "K!", ;
		Height = 20, ;
		InputMask = "XXXXXXXXXX", ;
		Left = 118, ;
		Name = "txtPurchaser", ;
		TabIndex = 4, ;
		Top = 72, ;
		Width = 79, ;
		ZOrderSet = 30
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		IF DODEFAULT()
		   thisform.cboImportMap.Requery()
		ENDIF 
	ENDPROC

	PROCEDURE allocevenly		&& Allocate the MCF total evenly among the wells tied to this master meter
	ENDPROC

	PROCEDURE buildcodes
		LOCAL llReturn, lnCount, loError
		LOCAL ccode, x
		
		llReturn = .T.
		
		TRY
		* Build revenue import codes
		    CREATE CURSOR oiltypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'OIL' OR cType = 'BBL'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO oiltypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		    CREATE CURSOR gastypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'GAS' OR cType = 'MCF'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO gastypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		    CREATE CURSOR othtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'OTH' OR cType = 'NGL'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO othtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the adjustment codes
		    CREATE CURSOR adjtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'ADJ'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO adjtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the royalty codes
		    CREATE CURSOR roytypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'ROY'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO roytypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the workint int codes
		    CREATE CURSOR wrktypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'WRK'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO wrktypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the override int codes
		    CREATE CURSOR ovrtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'OVR'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO ovrtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the STAX codes
		    CREATE CURSOR staxtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'STAX'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO staxtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the PTAX codes
		    CREATE CURSOR ptaxtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'PTAX'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO ptaxtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		    
		    * Build the GTAX codes
		    CREATE CURSOR gtaxtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'GTAX'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO gtaxtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		    
		* Build the OTAX codes
		    CREATE CURSOR otaxtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'OTAX'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO otaxtypes FROM MEMVAR
		        ENDFOR
		    ENDIF    
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'BuildCodes', loError.LINENO, 'Import Revenue', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE buildmeter		&& Builds list of wells and data already imported into meterdata.
	ENDPROC

	PROCEDURE calcallocation		&& Does the allocation
	ENDPROC

	PROCEDURE chkforsubmeter		&& Checks to see if the wells have any totals
	ENDPROC

	PROCEDURE dmincome		&& Post receipt to well income table.
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		
		if nerror = 1737
		   dodefault(nerror,cmethod,nline)
		   return
		endif
		   
		dodefault(nerror,cmethod,nline)
		
	ENDPROC

	PROCEDURE excelexit
		thisform.oExcel.QUIT()
		
		thisform.oExcel = .Null.
	ENDPROC

	PROCEDURE findcode		&& Looks up the passed code to find what it is mapped to.
		LPARAMETERS tcCode
		
		swselect('importtypes')
		
		LOCATE FOR tcCode $ mTypes
		IF FOUND()
		   lcCode = cType
		ELSE
		   lcCode = tcCode
		ENDIF 
		
		RETURN lcCode 
	ENDPROC

	PROCEDURE gasreceipts		&& Builds Cash Receipts from Imported Gas Data
	ENDPROC

	PROCEDURE getacctlistid
		LPARAMETERS tcType, tcOwnerType
		LOCAL m.cacctno
		
		IF VARTYPE(tcType) # 'C'
		    MESSAGEBOX('Invalid type passed to GetAcctListID', 16, 'Bad Revenue Type')
		    RETURN ''
		ENDIF
		
		m.cacctno = ''
		
		swselect('revcat')
		LOCATE FOR crevtype = ALLTRIM(tcType)
		IF FOUND()
		    DO CASE
		        CASE tcOwnerType = 'W'
		            m.cacctno = ccracctnow
		        CASE tcOwnerType = 'O'
		            m.cacctno = ccracctnoo
		        OTHERWISE
		            m.cacctno = ccracctnol
		    ENDCASE
		ELSE
		    swselect('expcat')
		    LOCATE FOR ccatcode = ALLTRIM(m.ctype)
		    IF FOUND()
		       m.cacctno = ccraccto
		    ELSE
		        m.cacctno = ''
		    ENDIF
		ENDIF 
		
		RETURN m.cacctno 
	ENDPROC

	PROCEDURE import		&& Imports the given format
		LOCAL lcFile, loError, llReturn, llCDEXReport
		
		THISFORM.nTotalImport = 0
		
		llReturn     = .T.
		llCDEXReport = .F.
		
		TRY
		   DO CASE
		      CASE THISFORM.chkenergyLink.VALUE
		
		         lcFile = GETFILE('CSV,XLSX,XLS,XLSM', 'Choose Owner Relations File To Import:', 'Choose', 0, 'Where is the import file?')
		
		         IF EMPTY(lcFile)
		            llReturn = .F.
		            EXIT
		         ENDIF
		
		         llReturn = m.goApp.oImport.ImportOildex(lcFile, 'R', THISFORM.DATASESSIONID)
		         IF NOT llReturn
		            EXIT
		         ENDIF
		
		         llReturn = THISFORM.ProcessCSV()
		         IF NOT llReturn
		            EXIT
		         ENDIF
		
		         IF llReturn
		            DO CASE
		               CASE m.goApp.lAMVersion
		                  llReturn = THISFORM.PostRcptAM()
		               CASE m.goApp.lQBVersion
		                  llReturn = THISFORM.PostRcptQB()
		               OTHERWISE
		                  llReturn = THISFORM.PostRcptDM()
		            ENDCASE
		         ENDIF
		
		      CASE THISFORM.chkCDEX.VALUE
		
		         lcFile = GETFILE('DAT,TXT', 'Choose CDEX File To Import:', 'Choose', 0, 'Where is CDEX file?')
		
		         IF EMPTY(lcFile)
		            llReturn = .F.
		            EXIT
		         ENDIF
		
		         IF THISFORM.lblCDEXRpt.CAPTION = 'Report Only'
		            llReturn = parsecdex(lcFile, .F., THISFORM.DATASESSIONID, .T.)
		            llCDEXReport = .T.
		         ELSE
		            IF llReturn
		               llCDEXReport = .F.
		               llReturn = m.goApp.oImport.ImportCDEX(lcFile, 'R', THISFORM.DATASESSIONID)
		               IF NOT llReturn
		                  EXIT
		               ENDIF
		
		               llReturn = THISFORM.ProcessCDEX()
		               IF NOT llReturn
		                  EXIT
		               ENDIF
		
		               IF llReturn
		                  DO CASE
		                     CASE m.goApp.lAMVersion
		                        llReturn = THISFORM.PostRcptAM()
		                     CASE m.goApp.lQBVersion
		                        llReturn = THISFORM.PostRcptQB()
		                     OTHERWISE
		                        llReturn = THISFORM.PostRcptDM()
		                  ENDCASE
		               ENDIF
		            ENDIF
		         ENDIF
		
		      OTHERWISE   && Mapped Import
		
		         lcMapName = THISFORM.cboImportMap.VALUE
		
		         lcFile = GETFILE('CSV,XLS,XLSX,XLSM', 'Choose Revenue File To Import:', 'Choose', 0, 'Where is the import file?')
		
		         IF EMPTY(lcFile)
		            llReturn = .F.
		            EXIT
		         ENDIF
		
		         lcOperator = THISFORM.txtcPurchName.VALUE
		
		         llReturn = m.goApp.oImport.ImportMap(lcFile, lcMapName, 'REV', THISFORM.DATASESSIONID)
		         IF NOT llReturn
		            EXIT
		         ENDIF
		
		         llReturn = THISFORM.ProcessCSV()
		         IF NOT llReturn
		            EXIT
		         ENDIF
		
		         IF llReturn
		            DO CASE
		               CASE m.goApp.lAMVersion
		                  llReturn = THISFORM.PostRcptAM()
		               CASE m.goApp.lQBVersion
		                  llReturn = THISFORM.PostRcptQB()
		               OTHERWISE
		                  llReturn = THISFORM.PostRcptDM()
		            ENDCASE
		         ENDIF
		         IF NOT llReturn
		            EXIT
		         ENDIF
		
		   ENDCASE
		
		   IF NOT llCDEXReport
		      lnTotalcks = RECCOUNT('curNewChecks')
		      SELECT SUM(nCashAmt) AS nTotal FROM curNewChecks INTO CURSOR temp
		      lnTotal = thisform.ntotalcheck
		      IF llReturn
		         MESSAGEBOX('Imported: ' + TRANSFORM(lnTotalcks) + IIF(lnTotalcks > 1, ' Checks ', ' Check ') + ;
		            ' Totaling: ' + TRANSFORM(lnTotal, '999,999,999.99'), 64, 'Import Successful')
		      ELSE
		         MESSAGEBOX('Imported: ' + TRANSFORM(lnTotalcks) + IIF(lnTotalcks > 1, ' Checks ', ' Check ') + ;
		            ' Totaling: ' + TRANSFORM(lnTotal, '999,999,999.99'), 64, 'Import Partially Successful')
		      ENDIF
		
		      IF llReturn
		         TABLEUPDATE(.T., .T., 'Csrcthdr')
		         TABLEUPDATE(.T., .T., 'Csrctdet')
		         TABLEUPDATE(.T., .T., 'Checks')
		         TABLEUPDATE(.T., .T., 'Income')
		         TABLEUPDATE(.T., .T., 'Incsusp')
		         TABLEUPDATE(.T., .T., 'Expense')
		         TABLEUPDATE(.T., .T., 'Expsusp')
		         IF m.goApp.lAMVersion
		            TABLEUPDATE(.T., .T., 'Glmaster')
		         ENDIF
		      ENDIF
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Import', loError.LINENO, 'Import Revenue', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE importexcel		&& Import Excel Data
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		    DO CASE
		        CASE  m.goApp.lAMVersion
		            THISFORM.cboCashAcct.LISTITEMID = 1
		            THISFORM.QBAccount1.VISIBLE     = .F.
		            THISFORM.QBAccountLab.VISIBLE   = .F.
		            THISFORM.cboCashAcct.VISIBLE    = .T.
		            THISFORM.opgDeposits.VISIBLE    = .T.
		            thisform.chkpostQB.Visible      = .F.
		            swselect('custvend')
		            REQUERY('custvend')
		            thisform.txtpurchaser.clistexpression = 'custvend.cid'
		            thisform.txtpurchaser.clistworkarea   = 'custvend'
		        CASE m.goApp.lQBVersion
		            THISFORM.cboCashAcct.VISIBLE  = .F.
		            THISFORM.opgDeposits.VISIBLE  = .F.
		            THISFORM.QBAccount1.VISIBLE   = .T.
		            THISFORM.QBAccountLab.VISIBLE = .T.
		            IF m.goapp.oqb.lqbactive = .t.
		               thisform.chkpostQB.Visible    = .T.
		            ELSE
		               thisform.chkPostQB.Visible    = .t.
		               thisform.chkPostQB.Value      = .t.   
		            ENDIF    
		            swselect('custvend')
		            REQUERY('custvend')
		            thisform.txtpurchaser.clistexpression = 'custvend.cid'
		            thisform.txtpurchaser.clistworkarea   = 'custvend'
		        OTHERWISE
		            THISFORM.cboCashAcct.VISIBLE  = .F.
		            THISFORM.opgDeposits.VISIBLE  = .F.
		            THISFORM.QBAccount1.VISIBLE   = .F.
		            THISFORM.QBAccountLab.VISIBLE = .F.
		            thisform.chkpostQB.Visible    = .F.
		            swselect('custvend')
		            REQUERY('custvend')
		            thisform.txtpurchaser.clistexpression = 'custvend.cid'
		            thisform.txtpurchaser.clistworkarea   = 'custvend'
		    ENDCASE
		ENDIF
	ENDPROC

	PROCEDURE list
		LPARAMETERS cWorkarea
		*
	ENDPROC

	PROCEDURE Load
		IF DODEFAULT()
		   IF m.goApp.lQBVersion
		      *  Get the cursor of QuickBooks Accounts
		      m.goApp.oQB.QBAccounts('',.F.,.T.,THISFORM.DATASESSIONID)
		   ENDIF    
		ENDIF
		
	ENDPROC

	PROCEDURE lookupoper
	ENDPROC

	PROCEDURE meter_report		&& Prints report of allocations done.
	ENDPROC

	PROCEDURE oilreceipts		&& Builds cash receipt from imported oil data
	ENDPROC

	PROCEDURE postbill
	ENDPROC

	PROCEDURE postrcptam
		LOCAL lcBatch, lcAPAcct,  llReturn, lcSelect, lnRecNo, lcFilter, lcidchec
		LOCAL lcYear, lcRun, llDiffAmount, llCleared, llDiffAccount
		LOCAL lcRevClear, lcWellName, loError
		LOCAL cGroup, cWellStat, cperiod, cyear
		
		llReturn = .T.
		
		TRY
		    SELECT curNewChecks
		    SCAN
		        m.cBatch = cBatch
		
		        SELECT csrcthdr
		        LOCATE FOR cBatch == m.cBatch
		        IF FOUND()
		* Check for required fields
		            IF EMPTY(csrcthdr.cCashAcct)
		                THISFORM.oMessage.Warning('A cash account must be specified.  Please choose the cash account.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		
		            IF EMPTY(csrcthdr.ddate)
		                THISFORM.oMessage.Warning('Please enter a receipt date for this receipt.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		
		            IF NOT llReturn
		                EXIT
		            ENDIF
		
		            IF EMPTY(csrcthdr.dpostdate)
		                REPLACE csrcthdr.dpostdate WITH csrcthdr.ddate
		            ENDIF
		
		            lcBatch = csrcthdr.cBatch
		
		*  Check to see if the fiscal period is closed
		            IF NOT THISFORM.glmaint.checkperiod(csrcthdr.dpostdate)
		                llReturn = .F.
		                EXIT
		            ENDIF
		
		            lcidchec = csrcthdr.cidchec
		
		*
		* If the total has changed and it's not a new receipt,
		* don't allow the receipt to be changed if it has been
		* deposited or cleared
		*
		            llDiffAmount = .F.
		            llDeposited  = .F.
		            llCleared    = .F.
		
		*  Look to see if this receipt has been deposited
		            swselect('depositd')
		            LOCATE FOR cidchec = lcidchec
		            IF FOUND()
		                llDeposited = .T.
		            ENDIF
		
		*  Look to see if the check register entry has been cleared.
		            swselect('checks')
		            SET ORDER TO cidchec
		            IF SEEK(lcidchec)
		                llCleared = checks.lcleared
		            ENDIF
		
		
		            lcSelect = SELECT()
		            lcBatch  = csrcthdr.cBatch
		            lcidchec = csrcthdr.cidchec
		
		            lcBatch = csrcthdr.cBatch
		
		*  Delete the G/L journal entries for this invoice
		            THISFORM.glmaint.delbatch(lcBatch, 'CS')
		
		*  Delete any checks created by this a detail line in this receipt
		            THISFORM.glmaint.delcheck(lcBatch, .T.)
		
		*  Create the G/L journal entries for this invoice
		*  Cash entry
		            THISFORM.glmaint.cSource    = 'CS'
		            THISFORM.glmaint.cBatch     = lcBatch
		            THISFORM.glmaint.dGLDate    = csrcthdr.dpostdate
		            THISFORM.glmaint.cReference = 'Cash: ' + ALLTRIM(csrcthdr.cinvnum)
		            THISFORM.glmaint.cDesc      = THISFORM.txtcPurchName.VALUE
		            THISFORM.glmaint.cacctno    = csrcthdr.cCashAcct
		            THISFORM.glmaint.cId        = csrcthdr.cId
		            THISFORM.glmaint.namount    = csrcthdr.nCashAmt
		            THISFORM.glmaint.cBunch     = THISFORM.cBunch
		            THISFORM.glmaint.dCheckDate = csrcthdr.dpostdate
		            THISFORM.glmaint.dpostdate  = csrcthdr.dpostdate
		            THISFORM.glmaint.cpayee     = csrcthdr.cname
		            THISFORM.glmaint.cidchec    = ''
		            THISFORM.glmaint.centrytype = 'D'
		            THISFORM.glmaint.cidtype    = 'D'
		            THISFORM.glmaint.cyear      = ' '
		            THISFORM.glmaint.cperiod    = ' '
		            THISFORM.glmaint.lcleared   = .F.
		            THISFORM.glmaint.ccheckno   = csrcthdr.ccheckno
		            THISFORM.glmaint.cUnitNo    = ''
		            THISFORM.glmaint.lPrinted   = .T.
		
		* Only add a register entry if the receipt is positive
		            IF csrcthdr.nCashAmt > 0
		                IF NOT llCleared AND NOT llDeposited
		                    THISFORM.glmaint.addcheck()
		                    lcidchec = THISFORM.glmaint.GETKEY()
		                    swselect('csrcthdr')
		                    REPL cidchec WITH lcidchec
		                    THISFORM.glmaint.cidchec    = lcidchec
		                ENDIF
		            ENDIF
		
		*  Detail Lines
		            swselect('csrctdet')
		            lnRecNo  = RECNO()
		            lcFilter = FILTER()
		            SET FILTER TO
		            SCAN FOR cBatch == lcBatch
		                lcRevClear = csrctdet.cacctno
		                IF NOT EMPTY(csrctdet.cidchec)
		                    THISFORM.glmaint.delcheck(csrctdet.cidchec)
		                ENDIF
		                swselect('coa')
		                SET ORDER TO acctno
		                IF SEEK(lcRevClear) AND lbankacct
		                    THISFORM.glmaint.centrytype = 'C'
		                    THISFORM.glmaint.cidtype    = 'P'
		
		                    THISFORM.glmaint.cBatch     = lcBatch
		                    THISFORM.glmaint.dGLDate    = csrcthdr.dpostdate
		                    THISFORM.glmaint.cReference = 'Cash: ' + ALLTRIM(csrcthdr.cinvnum)
		                    THISFORM.glmaint.cDesc      = csrctdet.cDesc
		                    THISFORM.glmaint.cacctno    = csrctdet.cacctno
		                    THISFORM.glmaint.cId        = csrcthdr.cId
		                    THISFORM.glmaint.cDeptNo    = csrctdet.cDeptNo
		                    THISFORM.glmaint.namount    = csrctdet.namount
		                    THISFORM.glmaint.addcheck()
		                ELSE
		                    THISFORM.glmaint.cBatch     = lcBatch
		                    THISFORM.glmaint.dGLDate    = csrcthdr.dpostdate
		                    THISFORM.glmaint.cReference = 'Cash: ' + ALLTRIM(csrcthdr.cinvnum)
		                    IF csrctdet.lWellRcpt
		                        swselect('wells')
		                        SET ORDER TO cwellid
		                        IF SEEK(csrctdet.cwellid)
		                            lcWellName               = wells.cWellName
		                            THISFORM.glmaint.cDesc   = lcWellName
		                            THISFORM.glmaint.cacctno = lcRevClear
		                        ELSE
		                            lcWellName = 'Unknown'
		                        ENDIF
		                    ELSE
		                        THISFORM.glmaint.cDesc   = csrctdet.cDesc
		                        THISFORM.glmaint.cacctno = csrctdet.cacctno
		                    ENDIF
		                ENDIF
		
		                THISFORM.glmaint.cId     = csrcthdr.cId
		                THISFORM.glmaint.namount = csrctdet.namount * -1
		                THISFORM.glmaint.cUnitNo = csrctdet.cwellid
		                THISFORM.glmaint.cDeptNo = csrctdet.cDeptNo
		                THISFORM.glmaint.updatebatch()
		            ENDSCAN
		
		            CREATE CURSOR tempdept ;
		                (cDeptNo  C(8), ;
		                  namount  N(12, 2))
		
		            swselect('csrctdet')
		            SCAN FOR cBatch = lcBatch
		                SCATTER MEMVAR
		                INSERT INTO tempdept FROM MEMVAR
		            ENDSCAN
		
					SELECT  cDeptNo, SUM(namount) AS namount ;
					   FROM tempdept ;
					   INTO CURSOR temp ;
					   ORDER BY cDeptNo ;
					   GROUP BY cDeptNo
		
		*  Cash entry
		            THISFORM.glmaint.cSource    = 'CS'
		            THISFORM.glmaint.cBatch     = lcBatch
		            THISFORM.glmaint.dGLDate    = csrcthdr.dpostdate
		            THISFORM.glmaint.cReference = 'Cash: ' + ALLTRIM(csrcthdr.cinvnum)
		            THISFORM.glmaint.cDesc      = THISFORM.txtcPurchName.VALUE
		            THISFORM.glmaint.cacctno    = csrcthdr.cCashAcct
		            THISFORM.glmaint.cId        = csrcthdr.cId
		            THISFORM.glmaint.cBunch     = THISFORM.cBunch
		            THISFORM.glmaint.dCheckDate = csrcthdr.dpostdate
		            THISFORM.glmaint.dpostdate  = csrcthdr.dpostdate
		            THISFORM.glmaint.cpayee     = csrcthdr.cname
		            THISFORM.glmaint.cidchec    = ''
		            THISFORM.glmaint.centrytype = 'D'
		            THISFORM.glmaint.cidtype    = 'D'
		            THISFORM.glmaint.cyear      = ' '
		            THISFORM.glmaint.cperiod    = ' '
		            THISFORM.glmaint.lcleared   = llCleared
		            THISFORM.glmaint.ccheckno   = csrcthdr.ccheckno
		            THISFORM.glmaint.cUnitNo    = ''
		            THISFORM.glmaint.lPrinted   = .T.
		
		            SELECT temp
		            SCAN
		                SCATTER MEMVAR
		                THISFORM.glmaint.cDeptNo = m.cDeptNo
		                THISFORM.glmaint.namount = m.namount
		                THISFORM.glmaint.updatebatch()
		            ENDSCAN
		
		            SELECT csrctdet
		            SET FILTER TO &lcFilter
		
		*
		*  Check to make sure the batch balances
		*
		            llReturn = THISFORM.glmaint.chkBalance()
		
		            IF llReturn
		
		               llReturn = THISFORM.WellIncome(m.cBatch)
		               IF NOT llReturn
		                  EXIT
		               ENDIF 
		
		                THISFORM.setchanged(.F.)
		
		                WAIT WINDOW NOWAIT 'Receipt was posted to the G/L....' TIMEOUT 2
		            ELSE
		                WAIT WIND 'The Batch Was Not In Balance...Unable to save receipt.'
		            ENDIF
		        ENDIF
		    ENDSCAN
		
		    SELECT (lcSelect)
		
		    THISFORM.lChanged = .F.
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'postrcpt', loError.LINENO, 'Importrev', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
	ENDPROC

	PROCEDURE postrcptdm
		LOCAL lcBatch, lcAPAcct,  llReturn, lcSelect, lnRecNo, lcFilter, lcidchec
		LOCAL lcYear, lcRun, llDiffAmount, llCleared, llDiffAccount
		LOCAL lcRevClear, lcWellName, loError
		LOCAL cGroup, cWellStat, cperiod, cyear
		
		llReturn = .T.
		llDeposited  = .F.
		
		TRY
		    SELECT curNewChecks
		    SCAN
		        m.cBatch = cBatch
		
		        llReturn = THISFORM.WellIncome(m.cBatch)
		        IF NOT llReturn
		            EXIT
		        ENDIF
		        *  Create the G/L journal entries for this invoice
		        *  Cash entry
		        swselect('csrcthdr', .T.)
		        SET ORDER TO cBatch
		        IF SEEK(m.cBatch)
		            THISFORM.glmaint.cSource    = 'CS'
		            THISFORM.glmaint.cBatch     = m.cBatch
		            THISFORM.glmaint.dGLDate    = csrcthdr.dpostdate
		            THISFORM.glmaint.cReference = 'Cash: ' + ALLTRIM(csrcthdr.cinvnum)
		            THISFORM.glmaint.cDesc      = THISFORM.txtcPurchName.VALUE
		            THISFORM.glmaint.cacctno    = csrcthdr.cCashAcct
		            THISFORM.glmaint.cId        = csrcthdr.cId
		            THISFORM.glmaint.namount    = csrcthdr.nCashAmt
		            THISFORM.glmaint.cBunch     = THISFORM.cBunch
		            THISFORM.glmaint.dCheckDate = csrcthdr.dpostdate
		            THISFORM.glmaint.dpostdate  = csrcthdr.dpostdate
		            THISFORM.glmaint.cpayee     = csrcthdr.cname
		            THISFORM.glmaint.cidchec    = ''
		            THISFORM.glmaint.centrytype = 'D'
		            THISFORM.glmaint.cidtype    = 'D'
		            THISFORM.glmaint.cyear      = ' '
		            THISFORM.glmaint.cperiod    = ' '
		            THISFORM.glmaint.lcleared   = .F.
		            THISFORM.glmaint.ccheckno   = csrcthdr.ccheckno
		            THISFORM.glmaint.cUnitNo    = ''
		            THISFORM.glmaint.lPrinted   = .T.
		
		            * Only add a register entry if the receipt is positive
		            IF csrcthdr.nCashAmt > 0
		                IF NOT llCleared AND NOT llDeposited
		                    THISFORM.glmaint.addcheck()
		                    lcidchec = THISFORM.glmaint.GETKEY()
		                    swselect('csrcthdr')
		                    REPL cidchec WITH lcidchec
		                    THISFORM.glmaint.cidchec    = lcidchec
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDSCAN
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'PostRcptDM', loError.LINENO, 'Importrev', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE postrcptqb
		LOCAL lcBatch, lcAPAcct,  llReturn, lcSelect, lnRecNo, lcFilter, lcidchec, llInvestment
		
		llReturn     = .T.
		llInvestment = .F.
		
		TRY
		
		    SELECT curNewChecks
		    SCAN
		        m.cbatch = cbatch
		
		        SELECT csrcthdr
		        LOCATE FOR cbatch == m.cbatch
		        IF FOUND()
		
		            IF csrcthdr.nCashAmt <= 0
		                THISFORM.oMessage.Warning('A negative or zero balance receipt cannot be saved.  Please correct.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		
		            IF m.goapp.oqb.lqbactive = .t.
		            IF EMPTY(csrcthdr.cCashAcct)
		                THISFORM.oMessage.Warning('A cash account must be specified.  Please choose the cash account.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		            ENDIF 
		
		            IF EMPTY(csrcthdr.dPostDate)
		                THISFORM.oMessage.Warning('A posting date must be specified.  Please enter a posting date.')
		                llReturn = .F.
		                EXIT
		            ENDIF
		
		            IF EMPTY(csrcthdr.dDate)
		                THISFORM.oMessage.Warning('A accounting date must be specified.  Please enter an accounting date.')
		                llReturn = .F.
		            ENDIF
		
		            * If the ref file exists, plug 'DM' into the reference for journal entries
		            IF FILE('dmref.cfg')
		                lcref = 'DM'
		            ELSE
		                lcref = ''
		            ENDIF
		            
		            *  Add the entries to the INCSUSP or INCOME tables
		            llReturn = THISFORM.WellIncome(m.cbatch)
		            IF NOT llReturn
		               EXIT
		            ENDIF
		
		            *  Look to see if this receipt has been deposited
		            lcidchec = csrcthdr.cidchec
		
		            lcSelect = SELECT()
		            lcBatch  = csrcthdr.cbatch
		            lcidchec = csrcthdr.cidchec
		
		            WAIT WINDOW NOWAIT 'Saving Changes, Please Wait.....'
		
		            *  Create the G/L journal entries for this receipt
		            THISFORM.glmaint.cSource    = 'CS'
		            THISFORM.glmaint.cbatch     = lcBatch
		            THISFORM.glmaint.dGLDate    = csrcthdr.dPostDate
		            THISFORM.glmaint.cReference = 'Cash: ' + ALLTRIM(csrcthdr.cinvnum)
		            THISFORM.glmaint.cDesc      = THISFORM.txtcPurchName.VALUE
		            THISFORM.glmaint.cacctno    = csrcthdr.cCashAcct
		            THISFORM.glmaint.cId        = csrcthdr.cId
		            THISFORM.glmaint.namount    = csrcthdr.nCashAmt
		            THISFORM.glmaint.cBunch     = ''
		            THISFORM.glmaint.dCheckDate = csrcthdr.dPostDate
		            THISFORM.glmaint.dPostDate  = csrcthdr.dPostDate
		            THISFORM.glmaint.cpayee     = csrcthdr.cname
		            THISFORM.glmaint.cidchec    = ''
		            THISFORM.glmaint.centrytype = 'D'
		            THISFORM.glmaint.cidtype    = 'D'
		            THISFORM.glmaint.cyear      = ' '
		            THISFORM.glmaint.cperiod    = ' '
		            THISFORM.glmaint.lcleared   = .F.
		            THISFORM.glmaint.ccheckno   = csrcthdr.ccheckno
		            THISFORM.glmaint.cUnitNo    = ''
		            THISFORM.glmaint.lPrinted   = .T.
		
		            * Only add a register entry if the receipt is positive
		            IF csrcthdr.nCashAmt > 0
		                THISFORM.glmaint.addcheck()
		                lcidchec = THISFORM.glmaint.GETKEY()
		                swselect('csrcthdr')
		                REPL cidchec WITH lcidchec
		                THISFORM.glmaint.cidchec    = lcidchec
		            ENDIF
		
		            IF THISFORM.chkpostQB.VALUE = .T.
		                llReturn = .T.
		                EXIT 
		            ENDIF
		
		            * Get revenue clearing account
		            swselect('glopt')
		            GO TOP
		            lcClearAcct = cRevClear
		            lcExpClear  = cExpClear
		
		            IF EMPTY(lcClearAcct)
		                lcAcct = 'Uncategorized Expenses'
		                SELECT accounts
		                LOCATE FOR lcAcct $ cAcctDesc
		                IF FOUND()
		                    lcAcctListID = cListID
		                ELSE
		                    * IF the account is invalid, post to last account
		                    GO BOTT
		                    lcAcctListID = cListID
		                ENDIF
		            ELSE
		                lcAcctListID = lcClearAcct
		            ENDIF
		
		            *  Create the G/L journal entries for this invoice
		            IF m.goapp.oQB.lqbactive AND NOT thisform.chkpostQB.Value 
		
		                IF m.goapp.oQB.oqbsm.IsErrorRecoveryInfo()
		                    loresp     = m.goapp.oQB.oqbsm.geterrorrecoverystatus()
		                    lcxml      = loresp.toxmlstring()
		                    loresponse = loresp.responselist.getat(0)
		                    IF loresponse.statuscode = 0
		                        lcreq  = m.goapp.oQB.oqbsm.getsavedmsgsetrequest()
		                        m.goapp.oQB.oqbsm.ClearErrorRecovery()
		                    ELSE
		                        MESSAGEBOX(lcxml, 48, 'Error Recovery Info')
		                    ENDIF
		                ENDIF
		
		                * get a message set request object (version 1.1 xml)
		                loRequest = m.goapp.oQB.oQBRequest
		
		                * set the on error attribute for the request
		                loRequest.ATTRIBUTES.OnError = 1
		                loRequest.clearrequests()
		
		
		                IF csrcthdr.lnoqbpost = .F.
		                    loRequest.clearrequests()
		
		                    *  Setup the receipt add request
		                    loRcptAdd = loRequest.AppendJournalEntryAddRq()
		
		                    loRcptAdd.RefNumber.SetValue(csrcthdr.ccheckno)
		                    loRcptAdd.TxnDate.SetValue(csrcthdr.dPostDate)
		                    *      loRcptAdd.MEMO.SetValue('** DO NOT CHANGE OR DELETE THIS ENTRY IN QUICKBOOKS **')
		
		
		                    *  Add the deposit to the check register
		                    IF m.goapp.oQB.qbfcversion > ' 4.0'
		                        loDebit = loRcptAdd.orjournallinelist.APPEND.JournalDebitLine
		                    ELSE
		                        loDebit = loRcptAdd.JournalDebitLineList.APPEND
		                    ENDIF
		
		                    SELECT revsrc
		                    SET ORDER TO cRevKey
		                    IF SEEK(csrcthdr.cId)
		                        IF EMPTY(revsrc.cListID)
		                            THISFORM.oMessage.Warning('The receipt cannot be saved.  The purchaser file needs to be synchronized with QuickBooks.')
		                            loRequest.clearrequests()
		                            llReturn = .F.
		                            EXIT
		                        ENDIF
		                        loDebit.EntityRef.ListID.SetValue(revsrc.cListID)
		                    ELSE
		                        SELECT vendor
		                        SET ORDER TO cvendorid
		                        IF SEEK(csrcthdr.cId)
		                            loDebit.EntityRef.ListID.SetValue(vendor.cListID)
		                        ELSE
		                            WAIT WIND 'Purchaser/Vendor: ' + csrcthdr.cId + ' not found.'
		                            llReturn = .F.
		                            EXIT
		                        ENDIF
		                    ENDIF
		
		                    loDebit.AccountRef.ListID.SetValue(csrcthdr.cCashAcct)
		                    loDebit.Amount.SetValue(ROUND(csrcthdr.nCashAmt, 2))
		
		                    *  Add detail lines to check
		                    SELECT csrctdet
		                    SCAN FOR cbatch == lcBatch
		                        SCATTER MEMVAR
		
		                        IF m.namount > 0
		                            IF m.goapp.oQB.qbfcversion > ' 4.0'
		                                loEntry = loRcptAdd.orjournallinelist.APPEND.JournalCreditLine
		                            ELSE
		                                loEntry = loRcptAdd.JournalCreditLineList.APPEND
		                            ENDIF
		                        ELSE
		                            IF m.goapp.oQB.qbfcversion > ' 4.0'
		                                loEntry = loRcptAdd.orjournallinelist.APPEND.JournalDebitLine
		                            ELSE
		                                loEntry = loRcptAdd.JournalDebitLineList.APPEND
		                            ENDIF
		                            m.namount = ABS(m.namount)
		                        ENDIF
		
		                        IF NOT EMPTY(csrctdet.cwellid)
		                            SELE wells
		                            LOCATE FOR cwellid = csrctdet.cwellid
		                            IF FOUND()
		                                IF EMPTY(ALLT(wells.cListID))
		                                    THISFORM.oMessage.Warning('The receipt cannot be saved.  The wells file needs to be synchronized with QuickBooks.')
		                                    loRequest.clearrequests()
		                                    llReturn = .F.
		                                    EXIT
		                                ENDIF
		                                loEntry.ClassRef.ListID.SetValue(wells.cListID)
		                                IF wells.cWellStat = "V"
		                                    llInvestment = .T.
		                                ELSE
		                                    llInvestment = .F.
		                                ENDIF
		                            ENDIF
		                        ENDIF
		
		                        IF llInvestment
		                            SELE revcat
		                            LOCATE FOR cRevType == m.cType
		                            IF FOUND()
		                                IF EMPTY(ALLT(ccracctnow))
		                                    THISFORM.oMessage.Warning('The receipt cannot be saved.  The Revenue Category needs to have a valid QuickBooks account specified.')
		                                    loRequest.clearrequests()
		                                    llReturn = .F.
		                                    EXIT
		                                ENDIF
		                                m.cAcctListID = ccracctnow
		                            ELSE
		                                SELE expcat
		                                LOCATE FOR cCatCode == m.cType
		                                IF FOUND()
		                                    m.cAcctListID = cownacctlistid
		                                ELSE
		                                    m.cAcctListID = ''
		                                ENDIF
		                            ENDIF
		                        ELSE
		                            SELE revcat
		                            SET ORDER TO cRevType
		                            IF SEEK(m.cType)
		                                m.cAcctListID = lcClearAcct
		                            ELSE
		                                m.cAcctListID = lcExpClear
		                            ENDIF
		                        ENDIF
		
		                        loEntry.AccountRef.ListID.SetValue(m.cAcctListID)
		                        loEntry.Amount.SetValue(ROUND(m.namount, 2))
		
		                        IF NOT EMPTY(csrctdet.cprodperiod)
		                            lcMemoExtra =  "' Period: '+ csrctdet.cprodperiod+'/'+csrctdet.cprodyear"
		                            DO CASE
		                                CASE INLIST(m.cType, 'BBL', 'MCF', 'OTH')
		                                    loEntry.MEMO.SetValue(ALLT(STR(csrctdet.nunits, 5, 2)) + ' ' + csrctdet.cType + ;
		                                          ' @ ' + ALLT(STR(csrctdet.nprice, 5, 2)) + &lcMemoExtra)
		                                CASE m.cType = 'GTAX1'
		                                    loEntry.MEMO.SetValue('Gas Tax 1' + &lcMemoExtra)
		                                CASE m.cType = 'GTAX2'
		                                    loEntry.MEMO.SetValue('Gas Tax 2' + &lcMemoExtra)
		                                CASE m.cType = 'GTAX3'
		                                    loEntry.MEMO.SetValue('Gas Tax 3' + &lcMemoExtra)
		                                CASE m.cType = 'GTAX4'
		                                    loEntry.MEMO.SetValue('Gas Tax 4' + &lcMemoExtra)
		                                CASE m.cType = 'OTAX1'
		                                    loEntry.MEMO.SetValue('Oil Tax 1' + &lcMemoExtra)
		                                CASE m.cType = 'OTAX2'
		                                    loEntry.MEMO.SetValue('Oil Tax 2' + &lcMemoExtra)
		                                CASE m.cType = 'OTAX3'
		                                    loEntry.MEMO.SetValue('Oil Tax 3' + &lcMemoExtra)
		                                CASE m.cType = 'OTAX4'
		                                    loEntry.MEMO.SetValue('Oil Tax 4' + &lcMemoExtra)
		                                CASE m.cType = 'PTAX1'
		                                    loEntry.MEMO.SetValue('OTH Tax 1' + &lcMemoExtra)
		                                CASE m.cType = 'PTAX2'
		                                    loEntry.MEMO.SetValue('OTH Tax 2' + &lcMemoExtra)
		                                CASE m.cType = 'PTAX3'
		                                    loEntry.MEMO.SetValue('OTH Tax 3' + &lcMemoExtra)
		                                CASE m.cType = 'PTAX4'
		                                    loEntry.MEMO.SetValue('OTH Tax 4' + &lcMemoExtra)
		                                CASE m.cType = 'TRANS'
		                                    loEntry.MEMO.SetValue('Transportation' + &lcMemoExtra)
		                                CASE m.cType = 'MISC1'
		                                    loEntry.MEMO.SetValue('Miscellaneous Revenue 1' + &lcMemoExtra)
		                                CASE m.cType = 'MISC2'
		                                    loEntry.MEMO.SetValue('Miscellaneous Revenue 2' + &lcMemoExtra)
		                                OTHERWISE  &&  Expenses - all other types should be covered above
		                                    SELECT expcat
		                                    LOCATE FOR ALLTRIM(cCatCode) = ALLTRIM(csrctdet.cType)
		                                    IF FOUND()
		                                        loEntry.MEMO.SetValue(ALLT(expcat.cCateg) + &lcMemoExtra)
		                                    ELSE
		                                        loEntry.MEMO.SetValue('')
		                                    ENDIF
		                            ENDCASE
		                        ENDIF
		                    ENDSCAN
		
		                    loresponse = m.goapp.oQB.oqbsm.DoRequests(loRequest)
		                    loAddResp  = loresponse.responselist.getat(0)
		
		                    IF loAddResp.statuscode = 0
		                        WAIT WIND NOWAIT 'Receipt successfully added in QuickBooks'
		
		                        loNewCheck = loAddResp.DETAIL
		                        m.ctxnid   = loNewCheck.TxnID.getvalue()
		                        m.goapp.oQB.oqbsm.ClearErrorRecovery()
		
		                        SELE csrcthdr
		                        REPL ctxnid WITH m.ctxnid
		
		                        *  Add the entries to the INCSUSP or INCOME tables
		                    ELSE
		                        SELE csrcthdr
		                        REPL ctxnid WITH ''
		
		                        IF 'object' $ LOWER(loAddResp.StatusMessage)
		                            lcListID = SUBSTR(loAddResp.StatusMessage, AT('"', loAddResp.StatusMessage) + 1, AT('"', loAddResp.StatusMessage, 2) - (AT('"', loAddResp.StatusMessage) + 1))
		                            llResult = m.goapp.oQB.QBListID(lcListID, THISFORM.DATASESSIONID)
		                            IF llResult
		                                SELECT QBListID
		                                IF QBListID.cType = 'Account'
		                                    lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' specified in the ' + ;
		                                        'QB Posting Preferences was not found in QuickBooks. Please select a new account ' + ;
		                                        'and try to save the receipt again.'
		                                ELSE
		                                    lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' was not found in QuickBooks. ' + ;
		                                        'Please synchronize the ' + ALLTRIM(QBListID.cType) + ' file and try to save the receipt again.'
		                                ENDIF
		                            ELSE
		                                lcMessage = loAddResp.StatusMessage
		                            ENDIF
		                            THISFORM.oMessage.severe(lcMessage)
		                        ELSE
		                            THISFORM.oMessage.severe(loAddResp.StatusMessage)
		                        ENDIF
		                        m.goapp.oQB.oqbsm.ClearErrorRecovery()
		                        llReturn = .F.
		                        EXIT
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDSCAN
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'PostRcptQB', loError.LINENO, 'ImportRev', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE processcdex		&& Processes the importfile created by the import of a CDEX DAT file.
		LOCAL loError, llReturn, lnBadRecs, lcMessage, lcMessage2
		
		lnBadRecs = 0
		llReturn  = .T.
		STORE '' TO lcMessage, lcMessage2
		
		TRY
		
		   IF NOT USED('importfile')
		      MESSAGEBOX('The import did not complete successfully. Missing the temporary import file to process.', 16, 'Missing Import File')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   IF USED('newwells')
		      IF RECCOUNT() > 0
		* There are new wells to process, so add them
		      ENDIF
		   ENDIF
		
		   m.cUser = m.goapp.cUser
		   m.dlastmodified = DATETIME()
		
		   CREATE CURSOR baddetail ;
		      (cwellid    c(14), ;
		      cpropname  c(40), ;
		      cprodcode  c(7), ;
		      ccheckno   c(14))
		
		*    make_copy('csrcthdr', 'temphdr')
		*    make_copy('csrctdet', 'tempdet')
		
		
		* Get the total of each check
		   SELECT  ccompcode, ccheckno, SPACE(8) AS cbatch, SUM(nownnet+nownnet2) AS ncashamt ;
		      FROM importfile ;
		      INTO CURSOR curNewChecks READWRITE ;
		      ORDER BY ccompcode, ccheckno ;
		      GROUP BY ccompcode, ccheckno
		
		   SELECT curNewChecks
		   SCAN
		      SCATTER MEMVAR
		* Build the header record for the receipt
		      m.cid       = THISFORM.txtpurchaser.VALUE
		      m.cname     = THISFORM.txtcpurchname.VALUE
		      m.ddate     = THISFORM.dcheckdate.VALUE
		      m.dPostDate = m.dDate
		      m.ccashacct = THISFORM.cboCashAcct.VALUE
		      m.cbatch    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		
		      SELECT curNewChecks
		      REPLACE cbatch WITH m.cbatch
		
		      IF VARTYPE(m.ddate) # 'D'
		         MESSAGEBOX('An invalid date was found in the import. Using todays date instead. Correct in Production Receipts after this import.',16,'Bad Date')
		         m.ddate = DATE()
		      ENDIF
		      IF NOT BETWEEN(m.ddate,{01/01/1980},{12/31/2050})
		         MESSAGEBOX('An invalid date was found in the import. Using todays date instead. Correct in Production Receipts after this import.',16,'Bad Date')
		         m.ddate = DATE()
		      ENDIF
		
		      m.lUploaded   = .T.
		      
		      m.dAdded   = DATETIME()
		      m.cAddedBy = m.goapp.cuser
		
		      INSERT INTO csrcthdr FROM MEMVAR
		
		
		* Build the detail records for the receipt
		      SELECT importfile
		      SCAN FOR ccompcode == m.ccompcode AND ccheckno == m.ccheckno
		         SCATTER MEMVAR
		         lcprop = m.cwellid
		         swselect('wells')
		         LOCATE FOR cpropno = lcprop
		         IF FOUND()
		            m.cwellid      = wells.cwellid
		            m.cdesc        = wells.cwellname
		            m.cprodperiod  = LEFT(m.cProdDate1, 2)
		            m.cprodyear    = '20' + RIGHT(m.cproddate1,2)
		            m.ctype        = m.cprodcode
		            m.cOwnType     = m.cTypeInv
		            m.cwellname    = wells.cwellname
		            DO CASE
		            CASE m.cOwnType = 'W'
		               m.nUnits  = ROUND(m.nLeaseGrossVol * (m.nInterest/100), 2)
		               m.nAmount = m.nownnet + m.nownnet2
		            CASE m.cOwnType = 'O' OR m.cOwnType = 'R'
		               m.nUnits  = ROUND(m.nLeaseGrossVol * (m.nInterest/100), 2)
		               m.nAmount = m.nownnet + m.nownnet2
		            OTHERWISE
		               m.nUnits  = 0
		               m.nAmount = m.nownnet + m.nownnet2
		            ENDCASE
		            
		            IF m.nLeaseGrossVol # 0
		               m.nprice = (m.nLeaseGrossTax + m.nLeaseNet)/m.nLeaseGrossVol
		            ELSE
		               m.nprice = 0
		            ENDIF 
		
		            SELECT csrctdet
		            SET FILTER TO
		            lcidrctd = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		            SET DELETED OFF
		            SELECT csrctdet1
		            SET ORDER TO cidpurd
		            DO WHILE SEEK(lcidrctd)
		               lcidrctd = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		            ENDDO
		            SET DELETED ON
		            m.cidrctd = lcidrctd
		
		            INSERT INTO csrctdet FROM MEMVAR
		         ELSE
		            INSERT INTO baddetail FROM MEMVAR
		            lnBadRecs = lnBadRecs + 1
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		
		* Inform about any recs that couldn't be imported
		* Inform about any recs that couldn't be imported
		   IF lnBadRecs > 0
		      lcMessage = "There were " + TRANSFORM(lnBadRecs) + " detail lines that could not be imported." + CHR(10) + ;
		         "The property numbers that couldn't be found in the well records are: " + CHR(10)
		
		      SELECT ccheckno, cwellid FROM baddetail INTO CURSOR temp ORDER BY cwellid, ccheckno GROUP BY cwellid, ccheckno
		      SELECT temp
		      SCAN
		         SCATTER MEMVAR
		         lcMessage2 = lcMessage2 + 'Property: ' + m.cwellid + ' Check No: ' + m.ccheckno + CHR(10)
		      ENDSCAN
		      MESSAGEBOX(lcMessage + lcMessage2, 48, 'Missing Properties')
		      IF MESSAGEBOX('Do you want to print this list of invalid properties?', 36, 'Missing Properties') = 6
		         SELECT ccheckno, cpropname, cprodcode, cwellid FROM baddetail INTO CURSOR temp ORDER BY cwellid, ccheckno GROUP BY cwellid, ccheckno
		         REPORT FORM baddetail TO PRINTER PROMPT PREVIEW
		      ENDIF
		      IF MESSAGEBOX('Do you want to continue the import?', 36, 'Continue Import') = 7
		         llReturn = .F.
		      ENDIF
		   ELSE
		*!*	* Inform about the import's success
		*!*	      lnTotalcks = RECCOUNT('curNewChecks')
		*!*	      SELECT SUM(ncashamt) AS nTotal FROM curNewChecks INTO CURSOR temp
		*!*	      lnTotal = nTotal
		*!*	      MESSAGEBOX('Imported: ' + TRANSFORM(lnTotalcks) + IIF(lnTotalcks > 1,' Checks',' Check') + ' Totaling: ' + TRANSFORM(lnTotal,'999,999,999.99'),64,'Import Successful')
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'ProcessCDEX', loError.LINENO, 'Import', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE processcsv		&& Processes the importfile cursor created by importing an owner relations connect csv file.
		LOCAL llReturn, loError
		LOCAL lPostToQB, lcMessage, lcMessage2, lnTotal, lnTotalcks, lnDeducts
		LOCAL cBatch, cOwnType, cType, ccashacct, cleasename, cname, copername
		LOCAL ddate, dentdate, ileasespk, ioperatorpk, nNetUnits, nPrice
		LOCAL lcRevClear, lcExpClear
		
		lnBadRecs = 0
		llReturn  = .T.
		STORE '' TO m.cprodperiod, m.cProdYear
		
		TRY
		
		   swselect('glopt')
		   GO TOP
		   lcRevClear = cRevClear
		   lcExpClear = cExpClear
		   STORE '' TO lcMessage2, m.ccashacct, m.cType
		   lcMapName = THISFORM.cboimportMap.VALUE
		
		   * Check to see if the operator assumes that deducts are negative
		   * If the operator does assume we need to multiply by -1 otherwise
		   * just by 1.
		   swselect('ImportMap')
		   LOCATE FOR cType = 'REV' AND cImportName = ALLTRIM(lcMapName)
		   IF FOUND()
		      IF ImportMap.ldeducts
		         lnDeducts = 1
		      ELSE
		         lnDeducts = -1
		      ENDIF
		   ELSE
		      lnDeducts = -1
		   ENDIF
		
		   * Create cursor for bad detail lines
		   CREATE CURSOR baddetail ;
		      (cwellid    c(20), ;
		      cwellname  c(40), ;
		      cprodcode  c(7), ;
		      ccheckno   c(14), ;
		      cdesc      c(40))
		
		   * Create cursors for all the revenue and adjustment codes
		   llReturn = THISFORM.BuildCodes()
		
		   m.cUser		   = m.goapp.cUser
		   m.dlastmodified = DATETIME()
		
		   * Fill in check date if missing
		   IF THISFORM.chkUseDate.VALUE = .T.
		      SELECT importfile
		      REPLACE dcheckdate WITH THISFORM.dcheckdate.VALUE, ;
		         dpostdate  WITH THISFORM.dcheckdate.VALUE  ALL
		   ELSE
		      SELECT importfile
		      LOCATE FOR NOT EMPTY(dcheckdate)
		      IF NOT FOUND()
		         MESSAGEBOX('There was not a check date column in the import and the option to use the ' + ;
		            'shown date instead of the check date was not chosen. Please correct.', 64, 'Missing Checkdate')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   SELECT importfile
		   REPLACE dpostdate WITH dcheckdate FOR EMPTY(dpostdate)
		   REPLACE ccheckno WITH DTOC(dcheckdate) FOR EMPTY(ccheckno)
		
		   * Get a total for each check in the import
		   SELECT  ccheckno,;
		      dcheckdate,;
		      dpostdate,;
		      SPACE(8) AS cBatch,;
		      SUM(nTotalInc - ntax - ndeducts - nDeducts2 - nDeducts3 - nDeducts4 - nDeducts5) AS nCashAmt ;
		      FROM importfile ;
		      WHERE NOT EMPTY(dcheckdate) ;
		      AND NOT EMPTY(cwellid) ;
		      INTO CURSOR curNewChecks READWRITE ;
		      ORDER BY ccheckno, dcheckdate, dpostdate ;
		      GROUP BY ccheckno, dcheckdate, dpostdate
		
		   IF _TALLY = 0
		      llReturn = .F.
		      MESSAGEBOX('No valid records found in the import.', 16, 'No Records')
		      EXIT
		   ENDIF
		
		   SELECT curNewChecks
		   SCAN
		      SCATTER MEMVAR
		
		      DO CASE
		         CASE m.goapp.lAMVersion
		            m.ccashacct = THISFORM.cboCashAcct.VALUE
		         CASE m.goapp.lQBVersion
		            m.ccashacct = THISFORM.qbACCOUNT1.VALUE
		         OTHERWISE
		            m.ccashacct = ''
		      ENDCASE
		
		      m.cBatch    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		      lcBatch     = m.cBatch
		
		      SELECT curNewChecks
		      REPLACE cBatch WITH lcBatch
		
		      IF m.goapp.lQBVersion
		         m.lNoQBPost = THISFORM.chkpostQB.VALUE = .T.
		      ELSE
		         m.lNoQBPost = .F.
		      ENDIF
		
		      m.cname    = THISFORM.txtcPurchName.VALUE
		
		      IF THISFORM.chkUseDate.VALUE
		         m.ddate    = THISFORM.dcheckdate.VALUE
		      ELSE
		         m.ddate    = m.dcheckdate
		      ENDIF
		
		      IF EMPTY(m.dpostdate)
		         m.dpostdate = m.ddate
		      ENDIF
		
		      m.dentdate = DATE()
		
		      IF VARTYPE(m.ddate) # 'D'
		         MESSAGEBOX('An invalid date was found in the import. Using todays date instead. Correct in Production Receipts after this import.', 16, 'Bad Date')
		         m.ddate = DATE()
		      ENDIF
		      IF NOT BETWEEN(m.ddate, {01/01/1980}, {12/31/2050})
		         MESSAGEBOX('An invalid date was found in the import. Using todays date instead. Correct in Production Receipts after this import.', 16, 'Bad Date')
		         m.ddate = DATE()
		      ENDIF
		
		      m.cid = THISFORM.txtPurchaser.VALUE
		      m.cBatch = lcBatch
		      
		      m.dAdded   = DATETIME()
		      m.cAddedBy = m.goapp.cuser
		      
		      INSERT INTO csrcthdr FROM MEMVAR
		
		      lcLastProdType = ''
		      m.lWellRcpt	 = .F.
		      lnRow = 1
		      lnBadTotal     = 0
		  
		      llHeader = .F.
		  
		      SELECT importfile
		      SCAN FOR ccheckno = m.ccheckno AND dpostdate = m.dpostdate
		         SCATTER MEMVAR
		         IF llHeader AND lnRow = 1
		            lnRow = lnRow + 1 
		            LOOP
		         ENDIF 
		         m.cProdtype   = UPPER(ALLTRIM(m.cProdtype))
		         m.cwellid	   = PADR(ALLTRIM(UPPER(m.cwellid)), 20, ' ')
		         IF NOT EMPTY(m.cprodperiod)
		            m.cprodperiod = PADL(ALLTRIM(m.cprodperiod), 2, '0')
		         ENDIF
		         m.nAmount	   = m.nTotalInc
		
		         IF NOT EMPTY(m.cwellid)
		            swselect('wells')
		            LOCATE FOR (cPropNo == m.cwellid) OR ;
		               (coilpurchno == m.cwellid) OR ;
		               (cgaspurchno == m.cwellid) OR ;
		               (cothpurchno == m.cwellid) OR ;
		               (cwellid == LEFT(m.cwellid, 10))
		            IF FOUND()
		               m.cwellname = cwellname
		               m.cdesc	   = m.cwellname
		               m.cAcctNo   = lcRevClear
		               m.cwellid   = cwellid
		               m.lWellRcpt = .T.
		               IF wells.cwellid # ALLTRIM(m.cwellid)
		                  m.cwellid = wells.cwellid
		               ENDIF
		
		               swselect('revcat')
		               LOCATE FOR crevtype = PADR(ALLTRIM(m.cProdtype), 5, ' ')
		               IF NOT FOUND()
		                  swselect('expcat')
		                  LOCATE FOR UPPER(cCatCode) = PADR(ALLTRIM(m.cProdtype), 4, ' ')
		                  IF FOUND()
		                     m.cType   = cCatCode
		                     m.cAcctNo = lcExpClear
		                  ELSE
		                     lcCode = THISFORM.FindCode(m.cProdtype)
		                     IF INLIST(lcCode,'BBL','MCF','OTH','MISC1','MISC2','TRP')
		                        m.cType = lcCode
		                        m.cAcctNo = lcRevClear
		                     ELSE
		                        SELECT gastypes
		                        LOCATE FOR UPPER(ccode) = m.cProdtype
		                        IF FOUND()
		                           m.cType		= 'MCF'
		                           m.cProdtype	= m.cType
		                           m.cAcctNo	= lcRevClear
		                        ELSE
		                           SELECT oiltypes
		                           LOCATE FOR UPPER(ccode) = m.cProdtype
		                           IF FOUND()
		                              m.cType	   = 'BBL'
		                              m.cProdtype = m.cType
		                              m.cAcctNo   = lcRevClear
		                           ELSE
		                              SELECT othtypes
		                              LOCATE FOR UPPER(ccode) = m.cProdtype
		                              IF FOUND()
		                                 m.cType	  = 'OTH'
		                                 m.cProdtype = m.cType
		                                 m.cAcctNo	  = lcRevClear
		                              ELSE
		                                 SELECT gtaxtypes
		                                 LOCATE FOR UPPER(ccode) = m.cProdtype
		                                 IF FOUND()
		                                    m.cType	 = 'GTAX1'
		                                    m.cProdtype = m.cType
		                                    m.cAcctNo	 = lcRevClear
		                                 ELSE
		                                    SELECT otaxtypes
		                                    LOCATE FOR UPPER(ccode) = m.cProdtype
		                                    IF FOUND()
		                                       m.cType		= 'OTAX1'
		                                       m.cProdtype	= m.cType
		                                       m.cAcctNo	= lcRevClear
		                                    ELSE
		                                       SELECT ptaxtypes
		                                       LOCATE FOR UPPER(ccode) = m.cProdtype
		                                       IF FOUND()
		                                          m.cType	   = 'PTAX1'
		                                          m.cProdtype = m.cType
		                                          m.cAcctNo   = lcRevClear
		                                       ELSE
		                                          IF m.nTotalInc # 0
		                                             MESSAGEBOX('An invalid revenue code was found in the import. The code found is: ' + CHR(10) + CHR(10) + ;
		                                                m.cProdtype + CHR(10) + CHR(10) + ;
		                                                'Please add this code to the appropriate revenue type in the import ' + ;
		                                                'code mapping and then try the import again.', 16, 'Invalid Revenue Code')
		                                             llReturn = .F.
		                                             EXIT
		                                          ENDIF
		                                       ENDIF
		                                    ENDIF
		                                 ENDIF
		                              ENDIF
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ELSE
		                  m.cAcctNo	  = lcRevClear
		                  m.cType	  = ALLTRIM(m.cProdtype)
		                  m.lWellRcpt = .F.
		               ENDIF
		            ELSE
		               m.cprodcode = m.cType
		               m.cdesc	   = 'Property No: ' + ALLTRIM(m.cwellid) + ' was not found.'
		               INSERT INTO baddetail FROM MEMVAR
		               lnBadRecs = lnBadRecs + 1
		               lnBadTotal = lnBadTotal + (importfile.nTotalInc - importfile.ntax - importfile.ndeducts - ;
		                                          importfile.nDeducts2 - importfile.nDeducts3 - importfile.nDeducts4 - ;
		                                          importfile.nDeducts5)
		               LOOP 
		            ENDIF
		
		            IF NOT llReturn
		               EXIT
		            ENDIF
		
		            IF EMPTY(m.cProdYear) AND NOT EMPTY(m.dProdDate)
		               m.cProdYear	 = TRANSFORM(YEAR(m.dProdDate))
		               m.cprodperiod = PADL(TRANSFORM(MONTH(m.dProdDate)), 2, '0')
		            ENDIF
		
		            IF 'TAX' $ m.cType
		               m.nPrice	= 0
		               m.nUnits	= 0
		            ELSE
		               IF m.nPrice = 0
		                  IF m.nUnits <> 0
		                     m.nPrice    = m.nTotalInc / m.nUnits
		                  ELSE
		                     m.nPrice = 0
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF NOT EMPTY(m.cdesc) AND m.nAmount # 0
		               m.cidRctD   = GetNextPK('CSRCTDET')
		               m.lWellRcpt = .T.
		               m.cBatch = lcBatch
		               INSERT INTO csrctdet FROM MEMVAR
		            ENDIF
		
		            IF m.ntax # 0
		               m.nAmount = m.ntax * -1
		               m.cType	 = '**'
		               IF NOT EMPTY(m.cTaxType)
		                  SELECT otaxtypes
		                  LOCATE FOR UPPER(ccode) = m.cProdtype
		                  IF FOUND()
		                     m.cType   = 'OTAX1'
		                     m.cAcctNo = lcRevClear
		                  ELSE
		                     SELECT gtaxtypes
		                     LOCATE FOR UPPER(ccode) = m.cProdtype
		                     IF FOUND()
		                        m.cType	  = 'GTAX1'
		                        m.cAcctNo = lcRevClear
		                     ELSE
		                        SELECT ptaxtypes
		                        LOCATE FOR UPPER(ccode) = m.cProdtype
		                        IF FOUND()
		                           m.cType	 = 'PTAX1'
		                           m.cAcctNo = lcRevClear
		                        ELSE
		                           SELECT revcat
		                           LOCATE FOR UPPER(crevtype) = ALLTRIM(m.cTaxType)
		                           IF FOUND()
		                              m.cType	= crevtype
		                              m.cAcctNo	= lcRevClear
		                           ELSE
		                              m.cprodcode = m.cTaxType
		                              m.cdesc	  = 'Tax Type: ' + ALLTRIM(m.cTaxType) + ' not valid.'
		                              INSERT INTO baddetail FROM MEMVAR
		                              lnBadRecs = lnBadRecs + 1
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ELSE
		                  DO CASE
		                     CASE m.cProdtype = 'BBL'
		                        m.cType = 'OTAX1'
		                     CASE m.cProdtype = 'MCF'
		                        m.cType = 'GTAX1'
		                     CASE m.cProdtype = 'OTH'
		                        m.cType = 'PTAX1'
		                     OTHERWISE
		                        m.cType = 'GTAX4'
		                  ENDCASE
		               ENDIF
		               IF m.cType # '**'
		                  m.cidRctD	  = GetNextPK('CSRCTDET')
		                  m.lWellRcpt = .T.
		                  STORE 0 TO m.nPrice, m.nUnits
		                  m.cBatch = lcBatch
		                  INSERT INTO csrctdet FROM MEMVAR
		               ENDIF
		            ENDIF
		
		            IF m.ndeducts # 0
		               THISFORM.ProcessDeducts(m.cBatch, m.nDeducts, m.cDedCode)
		            ENDIF
		            IF m.ndeducts2 # 0
		               THISFORM.ProcessDeducts(m.cBatch, m.nDeducts2, m.cDedCode2)
		            ENDIF
		            IF m.ndeducts3 # 0
		               THISFORM.ProcessDeducts(m.cBatch, m.nDeducts3, m.cDedCode3)
		            ENDIF
		            IF m.ndeducts4 # 0
		               THISFORM.ProcessDeducts(m.cBatch, m.nDeducts4, m.cDedCode4)
		            ENDIF
		            IF m.ndeducts5 # 0
		               THISFORM.ProcessDeducts(m.cBatch, m.nDeducts5, m.cDedCode5)
		            ENDIF
		         ELSE
		            IF NOT EMPTY(m.cdesc) AND m.nAmount # 0
		               m.cidRctD   = GetNextPK('CSRCTDET')
		               m.lWellRcpt = .F.
		               m.cBatch = lcBatch
		               INSERT INTO csrctdet FROM MEMVAR
		            ENDIF
		         ENDIF
		      ENDSCAN && importfile
		   ENDSCAN &&cshdr
		
		   * Inform about any recs that couldn't be imported
		   IF lnBadRecs > 0
		      lcMessage = "There were " + TRANSFORM(lnBadRecs) + " detail lines that could not be imported." + CHR(10) + ;
		         "The wells that couldn't be imported: " + CHR(10)
		
		      SELECT ccheckno, cwellid FROM baddetail INTO CURSOR temp ORDER BY cwellid, ccheckno GROUP BY cwellid, ccheckno
		      SELECT temp
		      SCAN
		         SCATTER MEMVAR
		         lcMessage2 = lcMessage2 + 'Property: ' + m.cwellid + ' Check No: ' + m.ccheckno + CHR(10)
		      ENDSCAN
		      MESSAGEBOX(lcMessage + lcMessage2, 48, 'Import Problems')
		      IF MESSAGEBOX('Do you want to print this list of import problems?', 36, 'Import Problems') = 6
		         SELECT ccheckno, cwellname, cprodcode, cwellid, cdesc FROM baddetail INTO CURSOR temp ORDER BY cwellid, ccheckno GROUP BY cwellid, cprodcode, ccheckno, cdesc
		         REPORT FORM baddetail TO PRINTER PROMPT PREVIEW
		      ENDIF
		      IF MESSAGEBOX('Do you want to continue the import?', 36, 'Continue Import') = 7
		         llReturn = .F.
		      ELSE
		         SELECT csrcthdr
		         thisform.nTotalcheck = nCashAmt - lnBadTotal
		         REPLACE nCashAmt WITH nCashAmt - lnBadTotal
		      ENDIF
		   ELSE 
		      thisform.nTotalcheck = thisform.nTotalCheck + csrcthdr.nCashAmt
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'ProcessCSV', loError.LINENO, 'Import Revenue', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE processdeducts
		LPARAMETERS tcBatch, tnAmount, tcDedCode
		
		swselect('glopt')
		GO TOP
		lcRevClear = cRevClear
		lcExpClear = cExpClear
		STORE '' TO lcMessage2, m.ccashacct, m.cType
		
		m.nAmount   = tnAmount * -1
		m.cidRctD   = GetNextPK('CSRCTDET')
		m.lWellRcpt = .T.
		IF NOT EMPTY(tcDedCode)
		   swselect('expcat')
		   LOCATE FOR cCatCode = ALLTRIM(tcDedCode)
		   IF FOUND()
		      m.cAcctNo = lcExpClear
		      m.cType   = ALLTRIM(tcDedCode)
		      STORE 0 TO m.nPrice, m.nUnits
		      m.cBatch = tcBatch
		      INSERT INTO csrctdet FROM MEMVAR
		   ELSE
		      swselect('importtypes')
		      LOCATE FOR ALLTRIM(UPPER(tcDedCode)) $ mtypes
		      IF FOUND()
		         m.cType   = cType
		         m.cAcctNo = lcExpClear
		         STORE 0 TO m.nPrice, m.nUnits
		         swselect('expcat')
		         LOCATE FOR cCatCode = ALLTRIM(m.cType)
		         IF FOUND()
		            m.cAcctNo = lcExpClear
		            STORE 0 TO m.nPrice, m.nUnits
		            m.cBatch = tcBatch
		            INSERT INTO csrctdet FROM MEMVAR
		         ELSE
		            SELECT revcat
		            LOCATE FOR crevtype = ALLTRIM(m.cType)
		            IF FOUND()
		               m.cAcctNo = lcRevClear
		               STORE 0 TO m.nPrice, m.nUnits
		               m.cBatch = tcBatch
		               INSERT INTO csrctdet FROM MEMVAR
		            ELSE
		               m.cprodcode = m.cType
		               m.cdesc     = 'Deduction Code: ' + ALLTRIM(m.cType) + ' not valid.'
		               INSERT INTO baddetail FROM MEMVAR
		               lnBadRecs = lnBadRecs + 1
		            ENDIF
		         ENDIF
		      ELSE
		         m.cprodcode = tcDedCode
		         m.cdesc     = 'Deduction Code: ' + ALLTRIM(tcDedCode) + ' not valid.'
		         INSERT INTO baddetail FROM MEMVAR
		         lnBadRecs = lnBadRecs + 1
		      ENDIF
		   ENDIF
		ELSE
		   swselect('importtypes')
		   LOCATE FOR 'OD' $ mtypes
		   IF FOUND()
		      m.cType   = cType
		      m.cAcctNo = lcExpClear
		      STORE 0 TO m.nPrice, m.nUnits
		      swselect('expcat')
		      LOCATE FOR cCatCode = ALLTRIM(m.cType)
		      IF FOUND()
		         m.cAcctNo = lcExpClear
		         STORE 0 TO m.nPrice, m.nUnits
		         m.cBatch = tcBatch
		         INSERT INTO csrctdet FROM MEMVAR
		      ELSE
		         m.cprodcode = m.cType
		         m.cdesc     = 'Deduction Code: ' + ALLTRIM(m.cType) + ' not valid.'
		         INSERT INTO baddetail FROM MEMVAR
		         lnBadRecs = lnBadRecs + 1
		      ENDIF
		   ELSE
		      m.cprodcode = tcDedCode
		      m.cdesc     = 'Deduction Code: ' + ALLTRIM(tcDedCode) + ' not valid.'
		      INSERT INTO baddetail FROM MEMVAR
		      lnBadRecs = lnBadRecs + 1
		   ENDIF
		ENDIF
	ENDPROC

	PROCEDURE qbpostbill
	ENDPROC

	PROCEDURE qbpostrec		&& Post receipt to QuickBooks
	ENDPROC

	PROCEDURE wellincome
		LPARAMETERS tcBatch
		LOCAL lcbatch, m.cownerid, llcloserun, llSendToAllocation, oWellInv
		*******************************************************************
		*  Adds the income entries to the disbursement manager INCSUSP or
		*  INCOME tables depending on whether the production year and
		*  period are specified.
		*******************************************************************
		
		llReturn = .T.
		* Set the default for property lSendToAllocate
		THISFORM.lSendToAllocate = m.goApp.lSendToAllocate
		llSendToAllocation = thisform.lSendToAllocate
		
		TRY
		   * Create the oWellInv object so we can lookup the DOI Deck if needed
		   oWellInv = CREATEOBJECT('swbizobj_wellinv')
		   
		*
		*  Call distproc to create the (invtmp) and (wellwork) cursors
		*
		    swselect('wells')
		    SET ORDER TO cwellid
		    GO TOP
		    lcwellid1 = cwellid
		    GO BOTT
		    lcwellid2 = cwellid
		
		    lcbatch    = tcBatch
		    swselect('csrcthdr', .T.)
		    SET ORDER TO cbatch
		    IF SEEK(lcbatch)
		        m.ccheckno = csrcthdr.ccheckno
		
		        swselect('income')
		        = AFIELDS(lafields)
		        CREATE CURSOR tempinc FROM ARRAY lafields
		
		        swselect('incsusp')
		        SCAN FOR cbatch = lcbatch
		            DELETE NEXT 1
		        ENDSCAN
		        swselect('expsusp')
		        SCAN FOR cbatch = lcbatch
		            DELETE NEXT 1
		        ENDSCAN
		
		* Remove Income entries
		        swselect('income')
		        SCAN FOR cbatch == lcbatch
		            DELE NEXT 1
		        ENDSCAN
		
		* Remove Expense entries
		        swselect('expense')
		        SCAN FOR cbatch == lcbatch
		            DELE NEXT 1
		        ENDSCAN
		
		        swselect('csrctdet')
		        lcfilter = FILTER()
		        SET FILTER TO
		        SCAN FOR cbatch == lcbatch AND lwellrcpt = .T.
		
		            m.lnetrev  = .T.  &&  Variable for whether this item should be grossed thru NetRev up or not.  Should be reset for each line - BH 08/02/2007
		
		            SCATTER MEMVAR
		            
		            IF EMPTY(m.cprodyear) or EMPTY(m.cprodperiod) OR THISFORM.lSendToAllocate 
		               llSendToAllocation = .T.
		            ENDIF 
		            
		            * Only fill in blank decks when sending straight to the income and expense tables
		            IF EMPTY(m.cDeck) AND NOT llSendToAllocation
		               m.cDeck = oWellInv.DOIDeckNameLookup(m.cProdyear, m.cProdperiod, m.cWellID)
		            ENDIF
		            
		            llgrossunits = m.lgrossunits
		
		* Changed 12/18/08 by pws from using postdate to using receipt date
		            m.drevdate       = csrcthdr.ddate
		            IF EMPTY(m.cprodyear) OR EMPTY(m.cprodperiod)
		* Nothing
		            ELSE
		                m.cyear   = m.cprodyear
		                m.cperiod = m.cprodperiod
		            ENDIF
		            m.crevkey     = csrcthdr.cid
		
		*  If the well is not valid, don't try to create income records
		            swselect('wells')
		            SET ORDER TO cwellid
		            IF NOT SEEK(m.cwellid)
		                LOOP
		            ELSE
		                IF INLIST(cwellstat, 'I', 'S', 'P')
		                    llSendToAllocation = .T.
		                ENDIF
		            ENDIF
		
		            IF NOT EMPTY(m.cownerid)
		                m.lnetrev = .F.
		            ENDIF
		
		            DO CASE
		                CASE m.ctype = 'BBL'
		                    m.csource = 'BBL'
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, 'O', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'O', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                CASE m.ctype = 'MCF'
		                    m.csource = 'MCF'
		
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, 'G', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'G', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                CASE m.ctype = 'OTH'
		                    m.csource = 'OTH'
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, 'P', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'P', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		
		                CASE m.ctype = 'MISC1'
		                    m.csource = 'MISC1'
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, '1', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, '1', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		
		                CASE m.ctype = 'MISC2'
		                    m.csource = 'MISC2'
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, '2', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, '2', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		
		                CASE m.ctype = 'TRANS'
		                    m.csource = 'TRANS'
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, 'T', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'T', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                CASE m.ctype = 'OTAX1' OR m.ctype = 'OTAX2' OR m.ctype = 'OTAX3' OR m.ctype = 'OTAX4'
		                    m.csource = m.ctype
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, 'O' + RIGHT(ALLT(m.csource), 1), .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'O' + RIGHT(ALLT(m.csource), 1), .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                CASE m.ctype = 'GTAX1' OR m.ctype = 'GTAX2' OR m.ctype = 'GTAX3' OR m.ctype = 'GTAX4'
		                    m.csource = m.ctype
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, 'G' + RIGHT(ALLT(m.csource), 1), .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'G' + RIGHT(ALLT(m.csource), 1), .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                CASE m.ctype = 'PTAX1' OR m.ctype = 'PTAX2' OR m.ctype = 'PTAX3' OR m.ctype = 'PTAX4'
		                    m.csource = m.ctype
		                    IF m.lnetrev AND NOT llgrossunits
		                        m.nunits = swNetRevenue(m.cwellid, m.nunits, 'P', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ENDIF
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'P', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                CASE m.ctype = 'EXO'
		                    m.csource = 'EXO'
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'O', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                CASE m.ctype = 'EXG'
		                    m.csource = 'EXG'
		                    IF m.lnetrev
		                        m.ntotalinc = swNetRevenue(m.cwellid, m.namount, 'G', .T., .T.,.F.,.F.,.F.,.F.,.F.,m.cDeck)
		                    ELSE
		                        m.ntotalinc = m.namount
		                    ENDIF
		
		                OTHERWISE
		                    swselect('expcat')
		                    SET ORDER TO ccatcode
		                    IF SEEK(LEFT(m.ctype, 4))
		                        m.cexpclass = cexpclass
		                        m.ccateg    = ccateg
		                        m.ccatcode  = ccatcode
		                        m.crefid    = m.ccheckno
		                        IF m.ctype = 'MKTG'
		                            IF m.cexpclass = '0'
		                                m.namount = swNetRevenue(m.cwellid, m.namount, 'G', .T., .T., .F., m.cownerid, .F., .F., .F., m.cDeck)
		                            ELSE
		                                m.namount   = swNetExp(m.namount, m.cwellid, .F., expcat.cexpclass, 'B', .F., m.cownerid, m.cCatCode, m.cDeck)
		                            ENDIF
		                        ELSE
		                            m.namount   = swNetExp(m.namount, m.cwellid, .F., expcat.cexpclass, 'B', .F., m.cownerid, m.cCatCode, m.cDeck)
		                        ENDIF
		                        m.namount     = m.namount * -1
		                        m.cpayee      = csrcthdr.cname
		                        m.cvendorid   = csrcthdr.cid
		                        m.laptran     = .T.
		                        m.lfixed      = .F.
		                        m.cbatch      = lcbatch
		                        m.dpostdate   = m.drevdate
		                        m.dexpdate    = m.drevdate
		                        m.nSaltWater  = m.nSaltBBL
		                        m.cmemo       = ''
		                        m.nrunnorev   = 0
		                        m.nrunnojib   = 0
		                        m.crunyearrev = ''
		                        m.crunyearjib = ''
		                        m.cidexph     = ''
		                        IF NOT EMPTY(m.cprodyear) AND NOT EMPTY(m.cprodperiod) AND NOT THISFORM.lSendToAllocate AND NOT llSendToAllocation
		                            m.cidexpe = THISFORM.oregistry.incrementcounter('%Shared.Counters.Expense')
		                            SET DELETED OFF
		                            SELECT expense
		                            SET ORDER TO cidexpe
		                            DO WHILE SEEK(m.cidexpe)
		                                m.cidexpe = THISFORM.oregistry.incrementcounter('%Shared.Counters.Expense')
		                            ENDDO
		                            SET DELETED ON
		                            swselect('expense')
		                            m.cyear   = m.cprodyear
		                            m.cperiod = m.cprodperiod
		                            INSERT INTO expense FROM MEMVAR
		                        ELSE
		                            m.cidexps    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Expense')
		                            SET DELETED OFF
		                            swselect('expsusp')
		                            SET ORDER TO cidexps
		                            DO WHILE SEEK(m.cidexps)
		                                m.cidexps    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Expense')
		                            ENDDO
		                            SET DELETED ON
		                            m.cyear   = m.cprodyear
		                            m.cperiod = m.cprodperiod
		                            INSERT INTO expsusp FROM MEMVAR
		                        ENDIF
		                    ENDIF
		                    LOOP
		            ENDCASE
		
		            m.crefid    = m.ccheckno
		            m.lcstran   = .T.
		            m.cbatch    = lcbatch
		            m.dpostdate = m.drevdate
		            m.cmemo     = ''
		            m.cAcctNo   = ''
		
		            IF NOT EMPTY(m.cprodyear) AND NOT EMPTY(m.cprodperiod) AND NOT THISFORM.lSendToAllocate AND NOT llSendToAllocation
		                m.cidinch = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		                m.cidinco = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		                SELECT income
		                SET DELETED OFF
		                SET ORDER TO cidinco
		                DO WHILE SEEK(m.cidinco)
		                    m.cidinco = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		                ENDDO
		                SET DELE ON
		                m.nrunno  = 0
		                m.cyear   = m.cprodyear
		                m.cperiod = m.cprodperiod
		                INSERT INTO income FROM MEMVAR
		            ELSE
		                m.cidincs    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		                SELECT incsusp
		                SET DELE OFF
		                SET ORDER TO cidincs
		                DO WHILE SEEK(m.cidincs)
		                    m.cidincs    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		                ENDDO
		                SET DELE ON
		                m.lallocated = .F.
		                m.nrunno     = 0
		                m.cyear      = m.cprodyear
		                m.cperiod    = m.cprodperiod
		                INSERT INTO incsusp FROM MEMVAR
		            ENDIF
		        ENDSCAN
		    ENDIF
		
		    swselect('csrctdet')
		    SET FILTER TO &lcfilter
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'WellIncome', loError.LINENO, 'Import Revenue', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
	ENDPROC

	PROCEDURE cboCashAcct.Init
		*
		*  Builds the data displayed in the combo list box
		*
		
		SELECT  cAcctNo + '-'+ cacctdesc, cAcctNo ;
		   FROM coa INTO ARRAY laAcct ;
		   WHERE lBankacct = .T. ;
		      OR ((naccttype = 4 AND 'PAYABLE' $ UPPER(cacctdesc) ;
		      OR  (naccttype = 4 AND 'A/P' $ UPPER(cacctdesc))))  ;
		   ORDER BY cAcctNo
		
		IF _TALLY > 0
		   FOR lnX = 1 TO ALEN(laAcct,1)
		      THIS.ADDLISTITEM(laAcct[lnX,1],lnX,1)
		      THIS.ADDLISTITEM(laAcct[lnX,2],lnX,2)
		   ENDFOR
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE cboImportMap.Init
		IF DODEFAULT()
		   this.Requery()
		ENDIF 
	ENDPROC

	PROCEDURE cboImportMap.Requery
		IF DODEFAULT()
		   this.Clear()
		   lnx = 1
		   swselect('importmap')
		   SET ORDER to IMPORTNAME   && CIMPORTNAME
		   SET FILTER TO ctype = 'R'
		   SCAN
		      this.AddListItem(cimportname,lnx) 
		      lnx = lnx + 1
		   ENDSCAN 
		ENDIF    
	ENDPROC

	PROCEDURE chkCDEX.Click
		IF this.Value
		   thisform.lblimport.Visible = .f.
		   thisform.cboImportMap.Visible = .f.
		   thisform.cmdmapping.Visible = .f.
		   thisform.chkmapped.Value = .f.
		   thisform.chkenergyLink.Value = .f.
		   
		   IF MESSAGEBOX('Do you want a validation report instead of importing?',36,thisform.Caption) = 6
		      thisform.lblCDEXRpt.caption = 'Report Only'
		   ELSE
		      thisform.lblCDEXRpt.caption = ''
		   ENDIF 
		ENDIF 
		   
	ENDPROC

	PROCEDURE chkEnergyLink.Click
		IF this.Value
		   thisform.lblimport.Visible = .f.
		   thisform.cboImportMap.Visible = .f.
		   thisform.cmdmapping.Visible = .f.
		   thisform.chkmapped.Value = .f.
		   thisform.chkCDEX.value = .f.
		ENDIF 
		   
	ENDPROC

	PROCEDURE chkMapped.Click
		IF this.Value
		   thisform.lblimport.Visible = .t.
		   thisform.cboImportMap.Visible = .t.
		   thisform.cmdmapping.Visible = .t.
		   thisform.chkenergyLink.Value = .f.
		   thisform.chkcdEX.Value = .f.
		ENDIF 
		   
	ENDPROC

	PROCEDURE chkPostQB.When
		RETURN m.goapp.oqb.lqbactive 
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdImport.Click
		thisform.import()
		
		
	ENDPROC

	PROCEDURE cmdMapping.Click
		m.goStateManager.OpenForm('importrev_map.scx', thisform.cboImportMap.value)
	ENDPROC

	PROCEDURE cmdVendor.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		
		    lcList = 'cid\ID,cname\Name,ctype\Type'
		        SELECT custvend
		        SET SAFETY OFF
		        INDEX ON cid TAG cid
		        INDEX ON cname TAG cname
		        INDEX ON ctype TAG ctype
		        DO FORM ..\CUSTOM\picklist WITH 'custvend', lcList, THISFORM.txtPurchaser.VALUE, 3, .T., .T.
		
		        IF llOK
		            THISFORM.txtPurchaser.VALUE  = custvend.cid
		            THISFORM.txtcPurchName.VALUE = custvend.cname
		        ENDIF
		
		THISFORM.setnextcontrol(THISFORM.txtPurchaser)
		
		DODEFAULT()
		
		
		
		
	ENDPROC

	PROCEDURE opgDeposits.optDepositTo.Click
		THISFORM.cboCashAcct.SET('enabled',.T.)
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE opgDeposits.optGroup.Click
		
		lnSelect = SELECT()
		swselect('glopt')
		IF NOT EMPTY(glopt.cundepfund)
		   swselect('coa')
		   SET ORDER TO acctno
		   SEEK(glopt.cundepfund)
		   IF lbankacct
		      THISFORM.cboCashAcct.VALUE = glopt.cundepfund
		      THISFORM.cmdatamanager.REPLACE('csrcthdr','Ccashacct',glopt.cundepfund)
		      THISFORM.cboCashAcct.REFRESH()
		      THISFORM.cboCashAcct.afterchange()
		      thisform.cboCashAcct.set('enabled',.f.)
		   ELSE  &&  Not a bank account, so don't let them continue
		      THISFORM.oMessage.DISPLAY('Your undeposited funds account is not defined as a bank account.  This must be corrected before any deposits can be grouped.')
		      THIS.PARENT.VALUE = 2
		      THISFORM.cboCashAcct.LISTITEMID = 1
		      THISFORM.cboCashAcct.afterchange()
		      THISFORM.setnextcontrol(THISFORM.cboAcct)
		   ENDIF
		ELSE
		   THISFORM.omessage.warning('The undeposited funds account is not defined in the G/L options. Deposits cannot be grouped.')
		   THISFORM.opgDeposits.VALUE = 2
		ENDIF
		
		SELECT(lnselect)
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcPurchName.When
		DODEFAULT()
		RETURN .F.    
	ENDPROC

	PROCEDURE txtPurchaser.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdVendor.Click()
		DODEFAULT()
	ENDPROC

	PROCEDURE txtPurchaser.InteractiveChange
		IF DODEFAULT()
		        swselect('custvend')
		        LOCATE FOR cid == THIS.VALUE
		        IF FOUND()
		            THISFORM.txtcPurchName.SET('value', custvend.cname)
		        ELSE
		            THISFORM.txtcPurchName.SET('value', '')
		        ENDIF
		ENDIF
		
		
		
		
	ENDPROC

	PROCEDURE txtPurchaser.LostFocus
		ON KEY LABEL F2 *
		
		
	ENDPROC

	PROCEDURE txtPurchaser.Valid
		    swselect('custvend')
		    IF NOT EMPTY(THIS.VALUE)
		        LOCATE FOR cid == THIS.VALUE
		        IF NOT FOUND()
		            MESSAGEBOX('Invalid ID code entered. Please lookup the ID from the list.', 20, 'Bad Received From')
		            RETURN .F.
		        ENDIF
		    ENDIF
		
		DODEFAULT()
		
		
		
	ENDPROC

ENDDEFINE
