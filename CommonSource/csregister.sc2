*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="csregister.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor18" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor19" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor20" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor21" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor23" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor24" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor22" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor25" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor26" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor27" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor28" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor29" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor30" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor31" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor32" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor33" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor34" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor35" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 842
	Left = 125
	Name = "Dataenvironment"
	Top = 112
	Width = 849

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 3, ;
		CursorSource = "checks", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "othnames", ;
		CursorSource = "othnames", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 428, ;
		Name = "Cursor10", ;
		Top = 19, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "apopt", ;
		CursorSource = "apopt", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor11", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "glmaster1", ;
		CursorSource = "glmaster", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 710, ;
		Name = "Cursor12", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 292, ;
		Name = "Cursor13", ;
		Top = 265, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "suspense", ;
		CursorSource = "suspense", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 424, ;
		Name = "Cursor14", ;
		Top = 268, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "disbhist", ;
		BufferModeOverride = 5, ;
		CursorSource = "disbhist", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 429, ;
		Name = "Cursor15", ;
		Top = 543, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "invhdr", ;
		CursorSource = "invhdr", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 700, ;
		Name = "Cursor16", ;
		Top = 274, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "appurchh", ;
		CursorSource = "appurchh", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 574, ;
		Name = "Cursor17", ;
		Top = 13, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor18' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 702, ;
		Name = "Cursor18", ;
		Top = 12, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor19' AS cursor WITH ;
		Alias = "custs", ;
		CursorSource = "custs", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor19", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 3, ;
		CursorSource = "glmaster", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor20' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor20", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor21' AS cursor WITH ;
		Alias = "emps", ;
		CursorSource = "emps", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor21", ;
		Top = 380, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor22' AS cursor WITH ;
		Alias = "appmtdet", ;
		CursorSource = "appmtdet", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 705, ;
		Name = "Cursor22", ;
		Top = 395, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor23' AS cursor WITH ;
		Alias = "expense", ;
		CursorSource = "expense", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 68, ;
		Left = 571, ;
		Name = "Cursor23", ;
		Top = 380, ;
		Width = 94
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor24' AS cursor WITH ;
		Alias = "csdishdr", ;
		CursorSource = "csdishdr", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 420, ;
		Name = "Cursor24", ;
		Top = 391, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor25' AS cursor WITH ;
		Alias = "appmthdr", ;
		CursorSource = "appmthdr", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor25", ;
		Top = 500, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor26' AS cursor WITH ;
		Alias = "prdata", ;
		CursorSource = "prdata", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor26", ;
		Top = 500, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor27' AS cursor WITH ;
		Alias = "expsusp", ;
		CursorSource = "expsusp", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor27", ;
		Top = 500, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor28' AS cursor WITH ;
		Alias = "checks1", ;
		CursorSource = "checks", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 597, ;
		Name = "Cursor28", ;
		Top = 534, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor29' AS cursor WITH ;
		Alias = "ownpcts", ;
		CursorSource = "ownpcts", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 256, ;
		Name = "Cursor29", ;
		Top = 640, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor30' AS cursor WITH ;
		Alias = "susaudit", ;
		CursorSource = "susaudit", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 459, ;
		Name = "Cursor30", ;
		Top = 644, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor31' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor31", ;
		Top = 620, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor32' AS cursor WITH ;
		Alias = "wellinv", ;
		CursorSource = "wellinv", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor32", ;
		Top = 620, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor33' AS cursor WITH ;
		Alias = "deposits", ;
		CursorSource = "deposits", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 578, ;
		Name = "Cursor33", ;
		Top = 670, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor34' AS cursor WITH ;
		Alias = "depositd", ;
		CursorSource = "depositd", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 705, ;
		Name = "Cursor34", ;
		Top = 696, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor35' AS cursor WITH ;
		Alias = "landowner", ;
		CursorSource = "landowner", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor35", ;
		Top = 620, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "coabal", ;
		CursorSource = "coabal", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "revsrc", ;
		CursorSource = "revsrc", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "trangroup", ;
		CursorSource = "trangroup", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "custownvend", ;
		CursorSource = "custownvend", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 428, ;
		Name = "Cursor9", ;
		Top = 147, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Relation1' AS relation WITH ;
		ChildAlias = "depositd", ;
		ChildOrder = "cbatch", ;
		Name = "Relation1", ;
		ParentAlias = "deposits", ;
		RelationalExpr = "cbatch"
		*< END OBJECT: BaseClass="relation" />

ENDDEFINE

DEFINE CLASS formcsregister AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shpshapecustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtAcctDesc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCcheckno" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCcheckno" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDcheckdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkLcleared" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCpayee" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCpayee" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDrecdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDrecdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCidtype" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCidtype" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNamount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNamount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboEntryType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCashAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcWordNum" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkLprinted" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chklManual" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCmemo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCmemo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAddr1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAddr2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAddr3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblVoid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkLhist" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCsource" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCsource" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCyear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCyear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCperiod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCperiod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swgroup1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblcgroup" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtdCheckDate" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: f5		&& Toggles an entry in the undeposited funds account as deposited/undeposited.
		*m: reissue
		*m: void
		*p: caction
		*p: lpostdm
	*</DefinedPropArrayMethod>

	Caption = "Check Register"
	clistexpression = checkrec.cidchec
	ctoolbar = tbrCheck
	cworkarea = checks
	DoCreate = .T.
	Height = 315
	HelpContextID = 117
	lconfirmdelete = .F.
	lexpliciteditmode = .F.
	Name = "formcsregister"
	Visible = .T.
	Width = 577
	cmdatamanager.loverwrite = .F.
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 1
	cmdatamanager.ZOrderSet = 0
	cmlookupmanager.Name = "cmlookupmanager"
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cboAcct' AS cbocomboboxcustom WITH ;
		BoundColumn = 1, ;
		ColumnCount = 2, ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 167, ;
		lreadonly = .F., ;
		Name = "cboAcct", ;
		TabIndex = 2, ;
		Top = 9, ;
		Width = 96, ;
		ZOrderSet = 23
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboEntryType' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		ControlSource = "checks.centrytype", ;
		Height = 20, ;
		Left = 65, ;
		lreadonly = .F., ;
		Name = "cboEntryType", ;
		TabIndex = 6, ;
		Top = 53, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkLcleared' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Cleared", ;
		ControlSource = "checks.lcleared", ;
		Height = 16, ;
		Left = 474, ;
		Name = "chkLcleared", ;
		TabIndex = 40, ;
		Top = 260, ;
		Width = 55, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkLhist' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Historical Entry", ;
		ControlSource = "checks.lhist", ;
		Height = 16, ;
		Left = 474, ;
		Name = "chkLhist", ;
		TabIndex = 39, ;
		Top = 277, ;
		Width = 90, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chklManual' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Manual Entry", ;
		ControlSource = "checks.lmanual", ;
		ForeColor = 128,128,128, ;
		Height = 16, ;
		Left = 474, ;
		Name = "chklManual", ;
		TabIndex = 41, ;
		Top = 294, ;
		Width = 80, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkLprinted' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Printed", ;
		ControlSource = "checks.lprinted", ;
		Height = 16, ;
		Left = 474, ;
		Name = "chkLprinted", ;
		TabIndex = 38, ;
		Top = 243, ;
		Width = 51, ;
		ZOrderSet = 25
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdID' AS swlookupbutton WITH ;
		Left = 226, ;
		Name = "cmdID", ;
		TabIndex = 15, ;
		Top = 117
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		cperiod = '', ;
		cyear = '', ;
		Left = 516, ;
		Name = "Glmaint", ;
		ncredits = 0, ;
		ndebits = 0, ;
		Top = 12
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCashAcct' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Viewing Register For Account", ;
		Height = 16, ;
		Left = 12, ;
		Name = "lblCashAcct", ;
		TabIndex = 4, ;
		Top = 11, ;
		Width = 148, ;
		ZOrderSet = 22
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCcheckno' AS lblfieldlabelcustom WITH ;
		Caption = "Check No", ;
		Height = 16, ;
		Left = 167, ;
		Name = "lblCcheckno", ;
		TabIndex = 19, ;
		Top = 86, ;
		Width = 48, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblcgroup' AS lbllabelcustom WITH ;
		Caption = "Group", ;
		Left = 348, ;
		Name = "lblcgroup", ;
		TabIndex = 20, ;
		Top = 86, ;
		ZOrderSet = 43
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCid' AS lblfieldlabelcustom WITH ;
		Caption = "ID Code", ;
		Height = 16, ;
		Left = 93, ;
		Name = "lblCid", ;
		TabIndex = 23, ;
		Top = 119, ;
		Width = 39, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCidtype' AS lblfieldlabelcustom WITH ;
		Caption = "ID Type", ;
		Height = 16, ;
		Left = 22, ;
		Name = "lblCidtype", ;
		TabIndex = 25, ;
		Top = 119, ;
		Width = 38, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCmemo' AS lblfieldlabelcustom WITH ;
		Caption = "Memo", ;
		Height = 16, ;
		Left = 30, ;
		Name = "lblCmemo", ;
		TabIndex = 42, ;
		Top = 290, ;
		Width = 30, ;
		ZOrderSet = 28
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCpayee' AS lblfieldlabelcustom WITH ;
		Caption = "Payee", ;
		Height = 16, ;
		Left = 28, ;
		Name = "lblCpayee", ;
		TabIndex = 27, ;
		Top = 143, ;
		Width = 32, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCperiod' AS lblfieldlabelcustom WITH ;
		Caption = "Period", ;
		Height = 16, ;
		Left = 360, ;
		Name = "lblCperiod", ;
		TabIndex = 14, ;
		Top = 56, ;
		Visible = .F., ;
		Width = 32, ;
		ZOrderSet = 41
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCsource' AS lblfieldlabelcustom WITH ;
		Caption = "Source", ;
		Height = 16, ;
		Left = 196, ;
		Name = "lblCsource", ;
		TabIndex = 12, ;
		Top = 56, ;
		Width = 37, ;
		ZOrderSet = 37
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCyear' AS lblfieldlabelcustom WITH ;
		Caption = "Year", ;
		Height = 16, ;
		Left = 281, ;
		Name = "lblCyear", ;
		TabIndex = 13, ;
		Top = 56, ;
		Visible = .F., ;
		Width = 26, ;
		ZOrderSet = 39
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDcheckdate' AS lblfieldlabelcustom WITH ;
		Caption = "Date", ;
		Height = 16, ;
		Left = 36, ;
		Name = "lblDcheckdate", ;
		TabIndex = 18, ;
		Top = 86, ;
		Width = 24, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDrecdate' AS lblfieldlabelcustom WITH ;
		Caption = "Reconciliation Date", ;
		Height = 16, ;
		Left = 386, ;
		Name = "lblDrecdate", ;
		TabIndex = 33, ;
		Top = 204, ;
		Width = 93, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Entry Type", ;
		Left = 6, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 11, ;
		Top = 55, ;
		ZOrderSet = 21
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Address", ;
		Left = 16, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 31, ;
		Top = 204, ;
		ZOrderSet = 32
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Status Codes", ;
		Left = 465, ;
		Name = "Lbllabelcustom3", ;
		TabIndex = 35, ;
		Top = 227, ;
		ZOrderSet = 33
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNamount' AS lblfieldlabelcustom WITH ;
		Caption = "Amount", ;
		Height = 16, ;
		Left = 383, ;
		Name = "lblNamount", ;
		TabIndex = 28, ;
		Top = 143, ;
		Width = 39, ;
		ZOrderSet = 19
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblVoid' AS lbllabelcustom WITH ;
		Caption = "VOID", ;
		FontBold = .T., ;
		FontSize = 24, ;
		ForeColor = 255,0,0, ;
		Left = 468, ;
		Name = "lblVoid", ;
		TabIndex = 5, ;
		Top = 39, ;
		Visible = .F., ;
		ZOrderSet = 34
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'shape1' AS shpshapecustom WITH ;
		Height = 34, ;
		Left = 0, ;
		Name = "shape1", ;
		Top = 2, ;
		Width = 576, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'Shpshapecustom1' AS shpshapecustom WITH ;
		Height = 79, ;
		Left = 462, ;
		Name = "Shpshapecustom1", ;
		Top = 234, ;
		Width = 108, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'Swgroup1' AS swgroup WITH ;
		BoundColumn = 2, ;
		ControlSource = "checks.cgroup", ;
		Height = 20, ;
		Left = 396, ;
		lexcludeall = .T., ;
		Name = "Swgroup1", ;
		TabIndex = 17, ;
		Top = 84, ;
		Width = 156, ;
		ZOrderSet = 42
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'txtAcctDesc' AS txttextboxcustom WITH ;
		BackColor = 255,255,255, ;
		ControlSource = " ", ;
		Height = 20, ;
		Left = 274, ;
		lreadonly = .T., ;
		Name = "txtAcctDesc", ;
		TabIndex = 3, ;
		Top = 9, ;
		Width = 238, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcAddr1' AS txttextboxcustom WITH ;
		Height = 20, ;
		Left = 65, ;
		Name = "txtcAddr1", ;
		TabIndex = 30, ;
		Top = 200, ;
		Width = 288, ;
		ZOrderSet = 29
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcAddr2' AS txttextboxcustom WITH ;
		Height = 20, ;
		Left = 65, ;
		Name = "txtcAddr2", ;
		TabIndex = 34, ;
		Top = 225, ;
		Width = 288, ;
		ZOrderSet = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcAddr3' AS txttextboxcustom WITH ;
		Height = 20, ;
		Left = 65, ;
		Name = "txtcAddr3", ;
		TabIndex = 36, ;
		Top = 250, ;
		Width = 288, ;
		ZOrderSet = 31
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCcheckno' AS txttextboxcustom WITH ;
		Alignment = 1, ;
		ControlSource = "checks.ccheckno", ;
		Height = 20, ;
		Left = 223, ;
		MaxLength = 10, ;
		Name = "txtCcheckno", ;
		SelectOnEntry = .T., ;
		TabIndex = 16, ;
		Top = 84, ;
		Width = 89, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCid' AS txttextboxcustom WITH ;
		ControlSource = "checks.cid", ;
		Format = "!", ;
		Height = 20, ;
		Left = 139, ;
		MaxLength = 10, ;
		Name = "txtCid", ;
		SelectOnEntry = .T., ;
		TabIndex = 21, ;
		Top = 117, ;
		Width = 76, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCidtype' AS txttextboxcustom WITH ;
		ControlSource = "checks.cidtype", ;
		Format = "!", ;
		Height = 20, ;
		Left = 65, ;
		MaxLength = 1, ;
		Name = "txtCidtype", ;
		SelectOnEntry = .T., ;
		TabIndex = 22, ;
		Top = 117, ;
		Width = 16, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCmemo' AS txttextboxcustom WITH ;
		ControlSource = "checks.cmemo", ;
		Height = 20, ;
		Left = 65, ;
		MaxLength = 50, ;
		Name = "txtCmemo", ;
		TabIndex = 37, ;
		Top = 288, ;
		Width = 379, ;
		ZOrderSet = 27
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCpayee' AS txttextboxcustom WITH ;
		ControlSource = "checks.cpayee", ;
		Height = 20, ;
		Left = 65, ;
		MaxLength = 0, ;
		Name = "txtCpayee", ;
		SelectOnEntry = .T., ;
		TabIndex = 24, ;
		Top = 141, ;
		Width = 286, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCperiod' AS txttextboxcustom WITH ;
		ControlSource = "checks.cperiod", ;
		Height = 20, ;
		Left = 400, ;
		MaxLength = 2, ;
		Name = "txtCperiod", ;
		SelectOnEntry = .T., ;
		TabIndex = 10, ;
		Top = 54, ;
		Visible = .F., ;
		Width = 23, ;
		ZOrderSet = 40
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCsource' AS txttextboxcustom WITH ;
		ControlSource = "checks.csource", ;
		Format = "!", ;
		Height = 20, ;
		InputMask = "", ;
		Left = 241, ;
		MaxLength = 2, ;
		Name = "txtCsource", ;
		SelectOnEntry = .T., ;
		TabIndex = 7, ;
		Top = 54, ;
		Width = 23, ;
		ZOrderSet = 36
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcWordNum' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		Height = 20, ;
		Left = 65, ;
		Name = "txtcWordNum", ;
		TabIndex = 29, ;
		Top = 168, ;
		Width = 456, ;
		ZOrderSet = 24
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCyear' AS txttextboxcustom WITH ;
		ControlSource = "checks.cyear", ;
		Height = 20, ;
		Left = 315, ;
		MaxLength = 4, ;
		Name = "txtCyear", ;
		SelectOnEntry = .T., ;
		TabIndex = 8, ;
		Top = 54, ;
		Visible = .F., ;
		Width = 35, ;
		ZOrderSet = 38
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtdCheckDate' AS dpk WITH ;
		ControlSource = "checks.dcheckdate", ;
		Height = 20, ;
		Left = 65, ;
		Name = "txtdCheckDate", ;
		TabIndex = 9, ;
		Top = 84, ;
		Visible = .T., ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtDrecdate' AS txtdate WITH ;
		ControlSource = "checks.drecdate", ;
		Height = 20, ;
		InputMask = "99/99/9999", ;
		Left = 487, ;
		lenabled = .F., ;
		Name = "txtDrecdate", ;
		SelectOnEntry = .T., ;
		TabIndex = 32, ;
		Top = 200, ;
		Width = 76, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNamount' AS txttextboxcustom WITH ;
		ControlSource = "checks.namount", ;
		Height = 20, ;
		Left = 431, ;
		lreadonly = .F., ;
		Name = "txtNamount", ;
		SelectOnEntry = .T., ;
		TabIndex = 26, ;
		Top = 141, ;
		Width = 90, ;
		ZOrderSet = 18
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		IF DODEFAULT()
		   ON KEY LABEL ctrl+v _screen.activeform.void()
		   ON KEY LABEL ctrl+r _screen.activeform.reissue()
		   ON KEY LABEL F5     _screen.ActiveForm.F5()
		*   thisform.prior('Checks')
		*   thisform.next('Checks')
		ENDIF   
	ENDPROC

	PROCEDURE Deactivate
		IF DODEFAULT()
		   ON KEY LABEL ctrl+v 
		   ON KEY LABEL ctrl+r 
		   ON KEY LABEL F5
		ENDIF   
	ENDPROC

	PROCEDURE delete
		LPARAMETERS cworkarea
		LOCAL llPostDM, lcidchec
		LOCAL lcAPAcct, lcBatch, lcDMBatch, lcIDType, lcLeaseID, lcPeriod, lcRevClear, lcSuspAcct, lcType
		LOCAL lcUnDepFund, lcYear, ldNewDate, ldSuspDate, llFound, lnRecNo
		*:Global cBillToken, cRunYearJIB, cRunYearRev, cSuspType, cidchec, ciddisb, cidexpe, cpaidbyck
		*:Global crunyear, nAmount, nRunnoJIB, nRunnoRev, nrunno
		
		THISFORM.cAction = ''
		ldNewDate        = checks.dcheckdate
		
		IF checks.centrytype = 'C'
		   lcType = 'Check'
		ELSE
		   IF checks.lManual = .F. AND m.goapp.lAMVersion = .T.
		      THISFORM.omessage.Warning('Deposit entries must be deleted by deleting the original receipt.')
		      RETURN .F.
		   ENDIF
		ENDIF
		
		IF checks.lVoid
		   THISFORM.omessage.Warning('This check has been voided. It cannot be deleted.')
		   RETURN .F.
		ENDIF
		
		IF checks.csource = 'CS'
		   THISFORM.omessage.Warning('Cash Disbursement checks cannot be deleted here. Go to Tasks Cash Disbursements and delete the disbursement that created this check.')
		   RETURN
		ENDIF
		
		* Don't allow printed checks to be deleted. Void them instead.
		IF checks.lPrinted
		   THISFORM.void()
		   RETURN
		ENDIF
		
		swselect('checks')
		SCATTER MEMVAR
		lcBatch  = m.cBatch
		lnRecNo  = RECNO()
		lcidchec = m.cidchec
		
		swselect('glopt')
		lcRevClear = cRevClear
		
		llPostDM = THIS.lPostDM
		
		IF m.goapp.lAMVersion
		   llPostDM = .T.
		ENDIF
		
		IF m.csource = 'CS'  &&  If it came from a cash disbursement, make sure it deletes the expenses created by that CD.
		   swselect('expense')    &&  Make sure the expenses haven't been processed during a rev or JIB run before doing the void, though. - BH 5/2/06
		   LOCATE FOR cBatch == m.cBatch AND (nRunnoRev <> 0 OR nRunnoJIB <> 0)
		   IF FOUND()  &&  Already closed expenses, so they can't void this entry
		      THISFORM.omessage.Warning('There were expenses paid by this check, and those expenses have been processed during a revenue or JIB closing.  This check cannot be voided.')
		      RETURN
		   ENDIF
		   SCAN FOR cBatch == m.cBatch  &&  Once we're sure the expenses haven't been processed during a closing, delete them.
		      DELETE NEXT 1
		   ENDSCAN
		ENDIF
		
		lcBatch  = checks.cBatch
		lcIDType = checks.cidtype
		
		IF DODEFAULT('Checks')
		
		   IF llPostDM
		*   DO FORM csgetdate TO ldNewDate
		
		      DO CASE
		         CASE m.csource = 'AP'
		* Get the A/P Account Number
		            lcAPAcct = apopt.capacct
		
		*
		*  Create a journal entry to void the original check
		*
		            THISFORM.glmaint.cBatch     = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		            THISFORM.glmaint.dgldate    = ldNewDate
		            THISFORM.glmaint.csource    = 'AP'
		            THISFORM.glmaint.cReference = 'VOID: ' + m.cCheckno
		            THISFORM.glmaint.cid        = m.cid
		            THISFORM.glmaint.dcheckdate = ldNewDate
		            THISFORM.glmaint.dpostdate  = ldNewDate
		            THISFORM.glmaint.cdesc      = m.cPayee
		            THISFORM.glmaint.cPayee     = m.cPayee
		            THISFORM.glmaint.cunitno    = ''
		            THISFORM.glmaint.cdeptno    = ''
		
		*!*    * Create the deposit entry to add the amount back to the register
		*!*             THISFORM.glmaint.cEntryType = 'D'
		*!*             THISFORM.glmaint.cidtype    = m.cidtype
		*!*             THISFORM.glmaint.cacctno    = m.cacctno
		*!*             THISFORM.glmaint.nAmount    = m.nAmount
		*!*             THISFORM.glmaint.cMemo      = 'Void of Check ' + m.cCheckno
		*!*             THISFORM.glmaint.addcheck()
		*!*             THISFORM.glmaint.cidchec    = THISFORM.glmaint.getkey()
		
		*  Add the amount back to cash
		            THISFORM.glmaint.cacctno = m.cacctno
		            THISFORM.glmaint.nAmount = m.nAmount
		            IF NOT m.lManual AND m.goapp.lAMVersion
		               THISFORM.glmaint.updatebatch()
		            ENDIF
		
		*  Credit accounts payable
		            THISFORM.glmaint.cacctno = lcAPAcct
		            THISFORM.glmaint.nAmount = m.nAmount * -1
		            IF NOT m.lManual AND m.goapp.lAMVersion
		               THISFORM.glmaint.updatebatch()
		            ENDIF
		
		*
		*  Mark the invoices as not being paid by this check
		*
		
		            swselect('appmtdet')
		            SCAN FOR cidchec = lcidchec
		               SCATTER MEMVAR
		               m.cBillToken  = cBillToken
		               DELE NEXT 1
		               swselect('appurchh')
		               LOCATE FOR cBatch = m.cBillToken
		               IF FOUND()
		                  REPL nPayments WITH nPayments - m.nAmtPaid - m.nDiscTaken, ;
		                     nInvBal   WITH nInvBal   + m.nAmtPaid + m.nDiscTaken
		               ENDIF
		            ENDSCAN
		
		         CASE m.csource = 'CS'
		
		* Create the deposit or check entry to add the amount back to the register
		            THISFORM.glmaint.cBatch     = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		            THISFORM.glmaint.dgldate    = ldNewDate
		            THISFORM.glmaint.csource    = 'CS'
		            THISFORM.glmaint.cReference = 'VOID: ' + m.cCheckno
		            THISFORM.glmaint.cid        = m.cid
		            THISFORM.glmaint.dcheckdate = ldNewDate
		            THISFORM.glmaint.dpostdate  = ldNewDate
		            THISFORM.glmaint.cPayee     = m.cPayee
		            THISFORM.glmaint.cMemo      = 'Void of Check ' + m.cCheckno
		            IF m.centrytype = 'C'
		               THISFORM.glmaint.centrytype = 'D'
		               THISFORM.glmaint.cidtype    = 'D'
		            ELSE
		               THISFORM.glmaint.centrytype = 'C'
		               THISFORM.glmaint.cidtype    = m.cidtype
		*
		*  Return the receipts to undeposited funds
		*
		               swselect('glopt')
		               lcUnDepFund = cUnDepFund
		               swselect('deposits')
		               SET ORDER TO cBatch
		               IF SEEK(lcBatch)
		                  swselect('depositd')
		                  SCAN FOR cBatch = lcBatch
		                     m.cidchec = cidchec
		                     swselect('checks')
		                     LOCATE FOR cidchec = m.cidchec
		                     IF FOUND()
		                        REPLACE lDeposited WITH .F.
		                     ENDIF
		                     swselect('depositd')
		                     DELETE NEXT 1
		                  ENDSCAN
		                  swselect('deposits')
		                  DELETE NEXT 1
		               ENDIF
		               swselect('checks')
		               DELE FOR cacctno = lcUnDepFund AND centrytype = 'C' AND cBatch = lcBatch
		            ENDIF
		            THISFORM.glmaint.cacctno  = m.cacctno
		            THISFORM.glmaint.cCheckno = m.cCheckno
		            THISFORM.glmaint.nAmount  = m.nAmount
		*         THISFORM.glmaint.addcheck()
		            THISFORM.glmaint.cidchec    = THISFORM.glmaint.GETKEY()
		
		*
		*  Scan through Glmaster to get the journal entry for this entry
		*  so that the debits and credits can be reversed
		*
		            SELECT glmaster1
		            SCAN FOR cBatch = lcBatch
		*
		*  Create a journal entry to void the original check
		*
		               THISFORM.glmaint.cdesc   = glmaster1.cdesc
		               THISFORM.glmaint.cunitno = glmaster1.cunitno
		               THISFORM.glmaint.cdeptno = glmaster1.cdeptno
		               THISFORM.glmaint.cacctno = glmaster1.cacctno
		               IF glmaster1.nDebits > 0
		                  THISFORM.glmaint.nAmount = glmaster1.nDebits * -1
		               ELSE
		                  THISFORM.glmaint.nAmount = glmaster1.nCredits
		               ENDIF
		               IF NOT m.lManual
		                  THISFORM.glmaint.updatebatch()
		               ENDIF
		            ENDSCAN
		
		         CASE m.csource = 'DM'
		* Get the legal suspense account
		            lcSuspAcct = options.cMinAcct
		            IF EMPTY(lcSuspAcct)
		               swselect('glopt')
		               lcSuspAcct = cSuspense
		            ENDIF
		*
		*  Get the production period associated with this check
		*
		            swselect('sysctl')
		            LOCATE FOR cBatch = lcBatch
		            IF FOUND()
		               lcYear     = cYear
		               lcPeriod   = cPeriod
		               ldSuspDate = dAcctDate
		               lcDMBatch  = cDMBatch
		            ELSE
		* Should never get here
		               lcYear     = ''
		               lcPeriod   = ''
		               ldSuspDate = {}
		               lcDMBatch  = ''
		            ENDIF
		
		*
		*  Create a journal entry to void the original check
		*
		            THISFORM.glmaint.cBatch     = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		            THISFORM.glmaint.dgldate    = ldNewDate
		            THISFORM.glmaint.csource    = 'DM'
		            THISFORM.glmaint.cReference = 'VOID: ' + m.cCheckno
		            THISFORM.glmaint.cid        = m.cid
		            THISFORM.glmaint.dcheckdate = ldNewDate
		            THISFORM.glmaint.dpostdate  = ldNewDate
		            THISFORM.glmaint.cdesc      = m.cPayee
		            THISFORM.glmaint.cPayee     = m.cPayee
		            THISFORM.glmaint.cunitno    = ''
		            THISFORM.glmaint.cdeptno    = ''
		
		* Create the deposit entry to add the amount back to the register
		            THISFORM.glmaint.centrytype = 'D'
		            THISFORM.glmaint.cidtype    = 'D'
		            THISFORM.glmaint.cacctno    = m.cacctno
		            THISFORM.glmaint.cCheckno   = m.cCheckno
		            THISFORM.glmaint.nAmount    = m.nAmount
		            THISFORM.glmaint.cMemo      = 'Void of Check ' + m.cCheckno
		*         THISFORM.glmaint.addcheck()
		            THISFORM.glmaint.cidchec    = THISFORM.glmaint.GETKEY()
		
		*  Add the amount back to cash
		            THISFORM.glmaint.cacctno = m.cacctno
		            THISFORM.glmaint.nAmount = m.nAmount
		            THISFORM.glmaint.cMemo   = ''
		            IF NOT m.lManual
		               THISFORM.glmaint.updatebatch()
		            ENDIF
		
		            IF lcIDType = 'I'
		               IF THISFORM.omessage.CONFIRM('Should the check amount be credited to suspense? If you answer no the amount is credited to revenue clearing.')
		*  Credit the legal suspense account
		                  THISFORM.glmaint.cacctno = lcSuspAcct
		                  THISFORM.glmaint.nAmount = m.nAmount * -1
		                  IF NOT m.lManual
		                     THISFORM.glmaint.updatebatch()
		                  ENDIF
		*
		*  Add the amount to the suspense file
		*
		                  swselect('sysctl')
		                  LOCATE FOR cDMBatch == lcBatch
		                  IF FOUND()
		                     m.nrunno   = nrunno
		                     m.crunyear = crunyear
		                     swselect('disbhist')
		                     SCAN FOR nrunno == m.nrunno AND crunyear == m.crunyear AND cownerid = m.cid
		                        SCATTER MEMVAR
		                        m.cSuspType = 'M'
		                        m.ciddisb   = THISFORM.oregistry.incrementcounter('%Shared.Counters.Owner History')
		                        SET DELETED OFF
		                        swselect('suspense')
		                        SET ORDER TO ciddisb
		                        DO WHILE SEEK(m.ciddisb)
		                           m.ciddisb   = THISFORM.oregistry.incrementcounter('%Shared.Counters.Owner History')
		                        ENDDO
		                        SET DELETED ON
		                        INSERT INTO suspense FROM MEMVAR
		                        swselect('disbhist')
		                        DELETE NEXT 1
		                     ENDSCAN
		                  ENDIF
		               ELSE
		*  Credit the revenue clearing account
		                  THISFORM.glmaint.cacctno = lcRevClear
		                  THISFORM.glmaint.nAmount = m.nAmount * -1
		                  IF NOT m.lManual
		                     THISFORM.glmaint.updatebatch()
		                  ENDIF
		               ENDIF
		            ELSE
		*  Credit the A/P Account
		               lcAPAcct                 = apopt.capacct
		               THISFORM.glmaint.cacctno = lcAPAcct
		               THISFORM.glmaint.nAmount = m.nAmount * -1
		               IF NOT m.lManual
		                  THISFORM.glmaint.updatebatch()
		               ENDIF
		            ENDIF
		
		
		         CASE m.csource = 'PR'
		
		* Create the deposit entry to add the amount back to the register
		            THISFORM.glmaint.dgldate    = ldNewDate
		            THISFORM.glmaint.csource    = 'PR'
		            THISFORM.glmaint.cReference = 'VOID: ' + m.cCheckno
		            THISFORM.glmaint.cid        = m.cid
		            THISFORM.glmaint.dcheckdate = ldNewDate
		            THISFORM.glmaint.dpostdate  = ldNewDate
		            THISFORM.glmaint.centrytype = 'D'
		            THISFORM.glmaint.cidtype    = 'D'
		            THISFORM.glmaint.cacctno    = m.cacctno
		            THISFORM.glmaint.nAmount    = m.nAmount
		            THISFORM.glmaint.cMemo      = 'Void of Check ' + m.cCheckno
		*         THISFORM.glmaint.addcheck()
		            THISFORM.glmaint.cidchec    = THISFORM.glmaint.GETKEY()
		
		*
		*  Scan through Glmaster to get the journal entry for this entry
		*  so that the debits and credits can be reversed
		*
		            THISFORM.glmaint.cBatch = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		            SELECT glmaster1
		            SCAN FOR cBatch = lcBatch
		*
		*  Create a journal entry to void the original check
		*
		               THISFORM.glmaint.cdesc   = glmaster1.cdesc
		               THISFORM.glmaint.cunitno = glmaster1.cunitno
		               THISFORM.glmaint.cdeptno = glmaster1.cdeptno
		               THISFORM.glmaint.cacctno = glmaster1.cacctno
		               IF glmaster1.nDebits > 0
		                  THISFORM.glmaint.nAmount = glmaster1.nDebits * -1
		               ELSE
		                  THISFORM.glmaint.nAmount = glmaster1.nCredits
		               ENDIF
		               IF NOT m.lManual
		                  THISFORM.glmaint.updatebatch()
		               ENDIF
		            ENDSCAN
		
		         CASE m.csource = 'GJ'
		* Create the deposit or check entry to add the amount back to the register
		            THISFORM.glmaint.cBatch     = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		            THISFORM.glmaint.dgldate    = ldNewDate
		            THISFORM.glmaint.csource    = 'GJ'
		            THISFORM.glmaint.cReference = 'VOID: ' + m.cCheckno
		            THISFORM.glmaint.cid        = m.cid
		            THISFORM.glmaint.dcheckdate = ldNewDate
		            THISFORM.glmaint.dpostdate  = ldNewDate
		            THISFORM.glmaint.cPayee     = m.cPayee
		            IF m.centrytype = 'C'
		               THISFORM.glmaint.centrytype = 'D'
		               THISFORM.glmaint.cidtype    = 'D'
		            ELSE
		               THISFORM.glmaint.centrytype = 'C'
		               THISFORM.glmaint.cidtype    = m.cidtype
		*
		*  Return the receipts to undeposited funds if it came from there
		*
		               swselect('glopt')
		               lcUnDepFund = cUnDepFund
		               swselect('deposits')
		               SET ORDER TO cBatch
		               IF SEEK(lcBatch)
		                  swselect('depositd')
		                  SCAN FOR cBatch = lcBatch
		                     m.cidchec = cidchec
		                     swselect('checks')
		                     LOCATE FOR cidchec = m.cidchec
		                     IF FOUND()
		                        REPLACE lDeposited WITH .F.
		                     ENDIF
		                     swselect('depositd')
		                     DELETE NEXT 1
		                  ENDSCAN
		                  swselect('deposits')
		                  DELETE NEXT 1
		               ENDIF
		               swselect('checks')
		               DELE FOR cacctno = lcUnDepFund AND centrytype = 'C' AND cBatch = lcBatch
		            ENDIF
		            THISFORM.glmaint.cacctno  = m.cacctno
		            THISFORM.glmaint.cCheckno = m.cCheckno
		            THISFORM.glmaint.nAmount  = m.nAmount
		*         THISFORM.glmaint.addcheck()
		            THISFORM.glmaint.cidchec    = THISFORM.glmaint.GETKEY()
		
		*
		*  Scan through Glmaster to get the journal entry for this entry
		*  so that the debits and credits can be reversed
		*
		            SELECT glmaster1
		            SCAN FOR cBatch = lcBatch
		*
		*  Create a journal entry to void the original check
		*
		               THISFORM.glmaint.cdesc   = glmaster1.cdesc
		               THISFORM.glmaint.cunitno = glmaster1.cunitno
		               THISFORM.glmaint.cdeptno = glmaster1.cdeptno
		               THISFORM.glmaint.cacctno = glmaster1.cacctno
		               IF glmaster1.nDebits > 0
		                  THISFORM.glmaint.nAmount = glmaster1.nDebits * -1
		               ELSE
		                  THISFORM.glmaint.nAmount = glmaster1.nCredits
		               ENDIF
		               IF NOT m.lManual
		                  THISFORM.glmaint.updatebatch()
		               ENDIF
		            ENDSCAN
		
		         CASE m.csource = 'PD'
		* Create the deposit or check entry to add the amount back to the register
		            THISFORM.glmaint.cBatch     = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		            THISFORM.glmaint.dgldate    = ldNewDate
		            THISFORM.glmaint.csource    = 'PD'
		            THISFORM.glmaint.cReference = 'VOID: ' + m.cCheckno
		            THISFORM.glmaint.cid        = m.cid
		            THISFORM.glmaint.dcheckdate = ldNewDate
		            THISFORM.glmaint.dpostdate  = ldNewDate
		            THISFORM.glmaint.cPayee     = m.cPayee
		            THISFORM.glmaint.centrytype = 'D'
		            THISFORM.glmaint.cidtype    = 'D'
		            THISFORM.glmaint.cacctno    = m.cacctno
		            THISFORM.glmaint.cCheckno   = m.cCheckno
		            THISFORM.glmaint.nAmount    = m.nAmount
		*         THISFORM.glmaint.addcheck()
		            THISFORM.glmaint.cidchec    = THISFORM.glmaint.GETKEY()
		
		*
		*  Scan through Glmaster to get the journal entry for this entry
		*  so that the debits and credits can be reversed
		*
		            SELECT glmaster1
		            SCAN FOR cBatch = lcBatch
		*
		*  Create a journal entry to void the original check
		*
		               THISFORM.glmaint.cdesc   = glmaster1.cdesc
		               THISFORM.glmaint.cunitno = glmaster1.cunitno
		               THISFORM.glmaint.cdeptno = glmaster1.cdeptno
		               THISFORM.glmaint.cacctno = glmaster1.cacctno
		               IF glmaster1.nDebits > 0
		                  THISFORM.glmaint.nAmount = glmaster1.nDebits * -1
		               ELSE
		                  THISFORM.glmaint.nAmount = glmaster1.nCredits
		               ENDIF
		               IF NOT m.lManual
		                  THISFORM.glmaint.updatebatch()
		               ENDIF
		            ENDSCAN
		
		            swselect('proghstd')
		            DELETE FOR cBatch == checks.cBatch AND cownerid = m.cid
		* Remove any landhist records associated with this check
		
		         CASE m.csource = 'LM'
		            swSelect('landhist')
		            LOCATE FOR cidchec == lcidchec
		            IF FOUND()
		               lcLeaseID = cLeaseID
		               DELETE NEXT 1
		            ELSE
		               lcLeaseID = '**'
		            ENDIF
		
		            llFound = .F.
		
		            swSelect('expense')
		            SCAN FOR cpaidbyck = lcidchec  &&  See if the entries paid by this check have been processed
		               lnRecNo = RECNO()
		               IF nRunnoRev <> 0 OR nRunnoJIB <> 0  &&  It's been processed, so add it back to the new run as a credit
		                  llFound = .T.
		                  SCATTER MEMVAR
		                  m.nAmount = m.nAmount * -1  &&  Reverse the charge
		                  STORE 0 TO m.nRunnoRev, m.nRunnoJIB
		                  STORE '' TO m.cRunYearRev, m.cRunYearJIB, m.cpaidbyck
		
		                  m.cidexpe = THIS.oregistry.incrementcounter('%Shared.Counters.Expense')
		                  SET DELETED OFF
		                  swSelect('expense')
		                  SET ORDER TO cidexpe
		                  DO WHILE SEEK(m.cidexpe)
		                     m.cidexpe = THIS.oregistry.incrementcounter('%Shared.Counters.Expense')
		                  ENDDO
		                  SET DELETED ON
		                  INSERT INTO expense FROM MEMVAR
		
		                  GOTO lnRecNo
		               ELSE  &&  Not processed, so just delete it
		                  DELETE NEXT 1
		               ENDIF
		            ENDSCAN
		
		            swSelect('expsusp')
		            SCAN FOR cpaidbyck = lcidchec  &&  Always delete it from expsusp if it exists
		               DELETE NEXT 1
		            ENDSCAN
		
		            IF llFound  &&  One or more entries were found that have been processed in a closing, so tell them how it's getting handled
		               THIS.omessage.DISPLAY('One or more expense entries related to this payment were processed during a revenue or JIB run closing. ' + ;
		                    'Those expenses have been charged back to the well as a credit in the New Run.')
		            ENDIF
		
		            * Update the next payment date back to the previous payment date if we can
		            IF lcLeaseID # '**'
		               swSelect('landowner')
		               LOCATE FOR cownerid == m.cid AND cLeaseID == lcLeaseID
		               IF FOUND()
		                  REPLACE dNextPmt WITH GOMONTH(landowner.dNextPmt, landowner.nPmtFreq *- 1)
		               ELSE
		                  THIS.omessage.Warning('The next payment date on this lease obligation has not been changed. ' + ;
		                       'Any changes to the next payment date will have to be done manually.')
		
		               ENDIF
		            ENDIF
		      ENDCASE
		   ENDIF
		   swselect('checks')
		   THISFORM.SAVE()
		   THISFORM.prior()
		   THISFORM.NEXT()
		ENDIF
		
		
		 
	ENDPROC

	PROCEDURE Destroy
		IF DODEFAULT()
		   ON KEY LABEL ctrl+v 
		   ON KEY LABEL ctrl+r 
		ENDIF   
	ENDPROC

	PROCEDURE f5		&& Toggles an entry in the undeposited funds account as deposited/undeposited.
		LOCAL lcUndepFund
		
		swselect('glopt')
		lcUndepFund = glopt.cUndepFund
		
		IF NOT m.goapp.lQBVersion
		   IF checks.cacctno <> lcUndepFund
		      RETURN
		   ENDIF
		   
		   IF checks.lDeposited
		      IF thisform.oMessage.confirm('Are you sure you want to mark this entry as being undeposited?  Doing so will make it show up again on the Make Deposits screen.')
		         swselect('checks')
		         replace lDeposited WITH .f.
		         =TABLEUPDATE(.t.)
		      ENDIF
		   ELSE
		      IF thisform.oMessage.confirm('Are you sure you want to mark this entry as being deposited?  Doing so will remove it from the Make Deposits screen.')
		         swselect('checks')
		         replace lDeposited WITH .t.
		         =TABLEUPDATE(.t.)
		      ENDIF
		   ENDIF
		ENDIF 
	ENDPROC

	PROCEDURE Init
		
		swselect('checks')
		SET ORDER TO datechk
		
		IF TYPE('m.goApp') = 'O'
		   THIS.lPostDM = m.goApp.lAMVersion
		ENDIF
		
		IF NOT THIS.lPostDM
		   THIS.lblCashAcct.VISIBLE = .F.
		   THIS.cboAcct.VISIBLE = .F.
		   THIS.txtAcctDesc.VISIBLE = .F.
		   THIS.shape1.VISIBLE = .F.
		   THIS.txtcsource.VISIBLE = .F.
		   THIS.lblcsource.VISIBLE = .F.
		ELSE
		   THIS.lblcgroup.VISIBLE = .F.
		   THIS.swgroup1.VISIBLE = .F.
		ENDIF
		
		THISFORM.cAction = 'C'
		
		m.goStateManager.DefineAction('Void')
		m.goStateManager.DefineAction('Reissue')
		
		SELECT checks1
		COUNT FOR NOT DELETED() TO lnCount
		IF lnCount = 0
		   IF THISFORM.omessage.CONFIRM("This file is empty. Do you want to add a New record? From now on, you'll need to click the New button in the toolbar to add a new record")
		      THISFORM.new('checks')
		   ENDIF
		ELSE
		   * If we have a bad record pointer because we opened another
		   * company, put the pointer at the last record.
		   IF EOF('Checks')
		      THISFORM.prior('Checks')
		   ENDIF
		ENDIF
		DODEFAULT()
		m.goStateManager.RefreshAll('Void')
		m.goStateManager.RefreshAll('Reissue')
		
	ENDPROC

	PROCEDURE list
		LPARAMETERS cworkarea
		LOCAL lcList, lnRecNo
		PRIV llOK
		
		IF USED('lookuptmp')
		   USE IN lookuptmp
		ENDIF
		IF USED('lookuptmp1')
		   USE IN lookuptmp1
		ENDIF
		
		llOK = .T.
		lcList = 'ccheckno\Check No,dcheckdate\Date,cid\ID Code,cpayee\Payee,csource\Src,namount\Amount,cEntryType\Type'
		
		SELECT cidchec,ALLT(ccheckno) AS cCheckNo,dcheckdate,cid, LEFT(cpayee,30) as cpayee,csource,namount,cEntrytype,.F. AS junk FROM checks  ;
		   INTO CURSOR lookuptmp READWRITE where cAcctno = thisform.cboAcct.value
		   
		SELECT lookuptmp
		INDEX ON ccheckno TAG ccheckno
		INDEX on cid TAG cid 
		INDEX ON dCheckDate TAG dcheckdate
		index on cSource+cPayee tag cSource
		index on cEntryType+cPayee tag cEntryType
		INDEX ON cpayee+allt(str(year(dCheckDate)))+padl(allt(str(month(dCheckDate))),2,'0')+padl(allt(str(day(dCheckDate))),2,'0')+cCheckNo TAG cpayee
		INDEX ON namount TAG namount
		
		IF THIS.FlushControlBuffer() AND THIS.beforenav('Checks')
		   DO FORM ..\CUSTOM\picklist WITH 'lookuptmp', lcList, ALLT(checks.ccheckno), 7,.T.,.T.
		ENDIF
		
		IF llOK
		   swselect('checks')
		   LOCATE FOR cidchec = lookuptmp.cidchec
		   THISFORM.REFRESH()
		   THISFORM.cmdatamanager.afternav('Checks')
		ENDIF
		
	ENDPROC

	PROCEDURE new
		LPARAMETERS cworkarea
		
		IF TYPE('m.goapp') = 'O'
		   IF m.goApp.lAMVersion = .T.
		      thisform.oMessage.Warning('%msgRegWarning')
		   ENDIF
		ENDIF      
		
		DODEFAULT()
	ENDPROC

	PROCEDURE reissue
		LOCAL lcAcct, lcPayee, lcidchec
		
		ldNewDate = DATE()
		
		swselect('checks')
		lcidchec = checks.cidchec
		
		IF checks.csource = 'CS'
		   thisform.omessage.warning('Cash Disbursement checks cannot be reissued here. Go to Tasks, Cash Disbursements and change the disbursement that created this check.')
		   RETURN
		ENDIF
		
		IF thisform.glmaint.reissuecheck(lcidchec)
		   thisform.lblvoid.Visible = .t.
		   thisform.save()
		ELSE
		   RETURN .f.
		ENDIF
		
		
	ENDPROC

	PROCEDURE void
		LOCAL lcAcct, lcPayee, lcidchec, llFound
		
		* Save any changes to this record before beginning the void process
		THISFORM.SAVE()
		
		* Get the primary key of the current check to void
		swselect('checks')
		lcidchec = checks.cidchec
		
		* pws - 2011/05/18  Commented out. Cash disbursement checks should be able to be voided but not deleted.
		*!*	IF checks.csource = 'CS'
		*!*	   thisform.omessage.warning('Cash Disbursement checks cannot be voided here. Go to Tasks, Cash Disbursements and delete the disbursement that created this check.')
		*!*	   RETURN
		*!*	ENDIF
		
		* Call the void routine in glmaint to do the voiding
		IF thisform.glmaint.voidcheck(lcidchec)
		   * The void was successful
		   thisform.lblvoid.Visible = .t.
		   thisform.save()
		   THISFORM.REFRESH()
		   RETURN .t.
		ELSE
		   RETURN .f.
		ENDIF 
		
		
		
		
		
		
	ENDPROC

	PROCEDURE cboAcct.afterchange
		swselect('coa')
		LOCATE FOR THISFORM.cboAcct.VALUE == coa.cacctno
		IF FOUND()
			THISFORM.txtAcctDesc.VALUE = cAcctDesc
			swselect('checks')
			SET FILTER TO cAcctNo = coa.cAcctNo
			thisform.next()
		ENDIF
		DODEFAULT()
		
		
	ENDPROC

	PROCEDURE cboAcct.Init
		LOCAL lnItem
		
		lnItem = 1
		
		if m.goApp.lAMVersion
		*
		*  Builds the data displayed in the combo list box
		*
		SELECT  cAcctNo, cAcctDesc FROM coa INTO ARRAY laAcct WHERE lBankacct = .T. ORDER BY cAcctNo
		
		IF _TALLY > 0
		   FOR lnX = 1 TO ALEN(laAcct,1)
		      THIS.ADDLISTITEM(laAcct[lnX,1],lnX,1)
		      THIS.ADDLISTITEM(laAcct[lnX,2],lnX,2)
		      IF laAcct[lnX,1] = checks.cacctno
		         lnItem = lnX
		      ENDIF   
		   ENDFOR
		
		   this.listitemid = lnItem
		   
		   swselect('coa')
		   LOCATE FOR coa.cAcctNo == THISFORM.cboAcct.VALUE
		   IF FOUND()
		      THISFORM.txtAcctDesc.VALUE = cAcctDesc
		      swselect('checks')
		      SET FILTER TO cAcctNo = coa.cAcctNo
		   ENDIF
		ENDIF
		endif
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cboEntryType.GotFocus
		IF NOT checks.lVoid  &&  Don't let them change the entry type for voided entries - BH 8/22/06
		   DODEFAULT()
		ELSE
		   RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE cboEntryType.Init
		this.addlistitem('Check',1,1)
		this.addlistitem('C',1,2)
		this.addlistitem('Deposit',2,1)
		this.addlistitem('D',2,2)
		
		DODEFAULT()
	ENDPROC

	PROCEDURE cboEntryType.Valid
		IF this.value = 'D'
		   thisform.cmdatamanager.replace('checks','cidtype','D')
		   thisform.txtcidtype.refresh()
		ENDIF
		
		DODEFAULT()   
	ENDPROC

	PROCEDURE cboEntryType.When
		RETURN thisform.isnew('checks')
	ENDPROC

	PROCEDURE chkLcleared.Click
		IF THIS.VALUE  &&  If cleared, enable the recon date
		   THISFORM.txtdRecDate.set('lENABLED',.T.)
		ELSE
		   THISFORM.txtdRecDate.set('lENABLED',.F.)
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE chklManual.When
		RETURN .f.
	ENDPROC

	PROCEDURE cmdatamanager.afternav
		LPARAMETERS cworkarea
		LOCAL lcWords, lnLength
		
		IF m.cworkarea == 'Checks'
		
		   THISFORM.txtcWordNum.VALUE = NumToWords(Checks.nAmount) + '**********'
		   SELECT custownvend
		   LOCATE FOR cID = Checks.cID
		   IF FOUND()
		      THISFORM.txtcAddr1.VALUE = cAddr1
		      THISFORM.txtcAddr2.VALUE = cAddr2
		      THISFORM.txtcAddr3.VALUE = cAddr3
		   ELSE
		      SELECT othnames
		      LOCATE FOR TRIM(Checks.cPayee) $ cName
		      IF FOUND()
		         THISFORM.txtcAddr1.VALUE = cAddr1
		         THISFORM.txtcAddr2.VALUE = cAddr2
		         THISFORM.txtcAddr3.VALUE = cAddr3
		      ELSE
		         swselect('emps')
		         LOCATE FOR cempid = Checks.cID
		         IF FOUND()
		            THISFORM.txtcAddr1.VALUE = cAddress
		            THISFORM.txtcAddr2.VALUE = TRIM(cCity) + ' ' + cstate + ' ' + czipcode
		            THISFORM.txtcAddr3.VALUE = ''
		         ENDIF
		      ENDIF
		   ENDIF
		
		   swselect('coa')
		   LOCATE FOR coa.cacctno == THISFORM.cboAcct.VALUE
		   IF FOUND()
		      THISFORM.txtAcctDesc.VALUE = cAcctDesc
		   ENDIF
		
		   IF Checks.lVoid
		      THISFORM.lblVoid.VISIBLE = .T.
		   ELSE
		      THISFORM.lblVoid.VISIBLE = .F.
		   ENDIF
		
		   IF checks.lCleared
		      thisform.txtdrecdate.set('lenabled',.t.)
		   ELSE
		      thisform.txtdrecdate.set('lenabled',.f.)
		   ENDIF    
		ENDIF
		
	ENDPROC

	PROCEDURE cmdatamanager.afternew
		LPARAMETERS cworkarea
		LOCAL lcCheckKey, lcFilter
		
		lcFilter = FILTER()
		SET FILTER TO
		IF m.cWorkarea = 'Checks'
		   lcCheckKey = thisform.oregistry.incrementcounter('%Shared.Counters.Checks')
		   SET DELETED OFF
		   swselect('checks')
		   SET ORDER TO cidchec
		   DO WHILE INDEXSEEK(lcCheckKey)
		      lcCheckKey = thisform.oregistry.incrementcounter('%Shared.Counters.Checks')
		   ENDDO   
		   swselect('checks')
		   REPL cidchec WITH lcCheckKey, ;
		        cacctno    WITH thisform.cboacct.value, ;
		        centrytype WITH 'C', ;
		        lmanual    WITH .T., ;
		        lcleared   WITH .F., ;
		        lvoid      WITH .F., ;
		        cgroup     WITH '00', ;
		        cSource    with 'CS',  ;
		        cIDType    WITH 'M',  ;
		        cYear      with allt(str(year(date()))),  ;
		        cPeriod    with padl(allt(str(month(date()))),2,'0'),  ;
		        dcheckdate with date()
		   SET DELETED ON  
		   thisform.txtcAddr1.set('value','')
		   thisform.txtcAddr2.set('value','')         
		   thisform.txtcAddr3.set('value','')
		ENDIF   
		
		thisform.setnextcontrol(thisform.txtdcheckdate)
	ENDPROC

	PROCEDURE cmdatamanager.beforeupdate
		LPARAMETERS cworkarealist
		LOCAL ldNewDate, lcBatch, lnRecNo
		
		swselect('checks')
		SCATTER MEMVAR
		
		IF THISFORM.chklCleared.VALUE AND EMPTY(THISFORM.txtdRecDate.VALUE)
		   THISFORM.oMessage.Warning('You cannot save a cleared item without a reconciliation date.  Please correct and resave.')
		   thisform.setnextcontrol(THISFORM.txtdRecDate)
		   RETURN .F.
		ENDIF
		
		IF checks.centrytype = 'D'
		   IF checks.cidtype <> 'D'
		      this.replace('checks','cidtype','D')
		   ENDIF
		ENDIF      
		
		DO CASE
		   CASE THISFORM.cAction = 'R'
		      THISFORM.cAction = ''
		
		
		   CASE THISFORM.cAction = 'V'
		      THISFORM.cAction = ''
		
		ENDCASE
		
	ENDPROC

	PROCEDURE cmdID.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .F.
		
		IF checks.cidtype = 'E'
		   lcList = 'cempid\Employee ID,clastname\Last Name,cfirstname\First Name'
		   DO FORM ..\CUSTOM\picklist WITH 'Emps', lcList, THISFORM.txtcid.VALUE, 3,.F.,.T.
		
		   IF llOK
		      THISFORM.cmdatamanager.REPLACE('Checks','Cid',emps.cempid)
		      THISFORM.cmdatamanager.REPLACE('Checks','cidtype','E')
		      THISFORM.txtcid.VALID()
		   ENDIF
		ELSE
		
		   lcList = 'cid\ID,cname\Name,ctype\Type'
		   SET SAFETY OFF
		   SELECT custownvend
		   INDEX ON cid TAG cid
		   INDEX ON cname TAG cname
		   INDEX ON ctype TAG ctype
		   DO FORM ..\CUSTOM\picklist WITH 'Custownvend', lcList, THISFORM.txtcid.VALUE, 3,.F.,.T.
		
		   IF llOK
		      THISFORM.cmdatamanager.REPLACE('Checks','Cid',custownvend.cid)
		      DO CASE
		         CASE custownvend.ctype = 'Owner'
		            THISFORM.cmdatamanager.REPLACE('Checks','cidtype','I')
		         CASE custownvend.ctype = 'Vendor'
		            THISFORM.cmdatamanager.REPLACE('Checks','cidtype','V')
		         CASE custownvend.ctype = 'Customer'
		            THISFORM.cmdatamanager.REPLACE('Checks','cidtype','C')
		      ENDCASE
		      THISFORM.txtcidtype.REFRESH()
		      THISFORM.txtcid.VALID()
		   ENDIF
		
		ENDIF
		
		THISFORM.setnextcontrol(THISFORM.txtcid)
		
	ENDPROC

	PROCEDURE cmdID.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE Swgroup1.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtAcctDesc.When
		RETURN .F.    
	ENDPROC

	PROCEDURE txtcAddr1.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtcAddr2.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtcAddr3.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtCcheckno.Valid
		DODEFAULT()
		
		lcCheck = PADL(ALLTRIM(THIS.VALUE),10,' ')
		IF checks.ccheckno <> lcCheck AND ALLTRIM(checks.cCheckNo) <> ALLTRIM(lcCheck)
		   thisform.cmdatamanager.REPLACE('Checks','ccheckno',lcCheck)
		ENDIF    
		
		
	ENDPROC

	PROCEDURE txtCid.GotFocus
		on key label F2 _screen.activeform.cmdID.click()
		
		dodefault()
	ENDPROC

	PROCEDURE txtCid.LostFocus
		ON KEY LABEL F2 *
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtCid.Valid
		IF DODEFAULT()
		
		   DO CASE
		      CASE checks.cidtype = 'I'
		         swselect('investor')
		         SET ORDER TO cownerid
		         IF SEEK(checks.cid)
		            m.cPayee = cownname
		            IF lchktosec
		               m.caddr1 = caddress2a
		               IF EMPTY(caddress2b)
		                  m.caddr2 = TRIM(ccity2)+' '+cstate2+' '+czip2
		                  m.caddr3 = ' '
		               ELSE
		                  m.caddr2 = caddress2b
		                  m.caddr3 = TRIM(ccity2)+' '+cstate2+' '+czip2
		               ENDIF
		            ELSE
		               m.caddr1 = caddress1a
		               IF EMPTY(caddress1b)
		                  m.caddr2 = TRIM(ccity1)+' '+cstate1+' '+czip1
		                  m.caddr3 = ' '
		               ELSE
		                  m.caddr2 = caddress1b
		                  m.caddr3 = TRIM(ccity1)+' '+cstate1+' '+czip1
		               ENDIF
		            ENDIF
		         ELSE
		            m.cPayee = 'Unknown Owner'
		            m.caddr1 = ' '
		            m.caddr2 = ' '
		            m.caddr3 = ' '
		         ENDIF
		
		      CASE checks.cidtype = 'V'
		         swselect('vendor')
		         SET ORDER TO cvendorid
		         IF SEEK(checks.cid)
		            m.cPayee = cvendname
		            m.caddr1 = cbaddr1
		            IF EMPTY(cbaddr2)
		               m.caddr2 = TRIM(cbcity)+' '+cbstate+' '+cbzip
		               m.caddr3 = ' '
		            ELSE
		               m.caddr2 = cbaddr2
		               m.caddr3 = TRIM(cbcity)+' '+cbstate+' '+cbzip
		            ENDIF
		         ELSE
		            m.cPayee = 'Unknown Vendor'
		            m.caddr1 = ' '
		            m.caddr2 = ' '
		            m.caddr3 = ' '
		         ENDIF
		
		      CASE checks.cidtype = 'E'
		         swselect('emps')
		         SET ORDER TO cempid
		         IF SEEK(checks.cid)
		            m.cPayee = TRIM(cFirstName) + ' ' + TRIM(cMidInit) + ' ' + TRIM(cLastName)
		            m.caddr1 = caddress
		            m.caddr2 = ALLTRIM(ccity) + ', ' + cstate + ' ' + czipcode
		            m.caddr3 = ' '
		         ELSE
		            m.cPayee = 'Unknown Employee'
		            m.caddr1 = SPACE(40)
		            m.caddr2 = SPACE(40)
		            m.caddr3 = SPACE(40)
		         ENDIF
		
		      CASE checks.cidtype = 'D'
		         swselect('revsrc')
		         SET ORDER TO crevkey
		         IF SEEK(checks.cid)
		            m.cPayee  = crevname
		            m.caddr1 = ' '
		            m.caddr2 = ' '
		            m.caddr3 = ' '
		         ELSE
		            swselect('custs')
		            SET ORDER TO cCustId
		            IF SEEK(checks.cid)
		               m.cPayee  = cCustName
		               m.caddr1 = cbaddr1
		               IF EMPTY(cbaddr2)
		                  m.caddr2 = TRIM(cbcity)+' '+cbstate+' '+cbzip
		                  m.caddr3 = ' '
		               ELSE
		                  m.caddr2 = cbaddr2
		                  m.caddr3 = TRIM(cbcity)+' '+cbstate+' '+cbzip
		               ENDIF
		            ELSE
		               swselect('emps')
		               SET ORDER TO cempid
		               IF SEEK(checks.cid)
		                  m.cPayee = TRIM(cFirstName) + ' ' + TRIM(cMidInit) + ' ' + TRIM(cLastName)
		                  m.caddr1 = caddress
		                  m.caddr2 = ALLTRIM(ccity) + ', ' + cstate + ' ' + czipcode
		                  m.caddr3 = ' '
		               ELSE
		                  swselect('vendor')
		                  SET ORDER TO cvendorid
		                  IF SEEK(checks.cid)
		                     m.cPayee = cvendname
		                     m.caddr1 = cbaddr1
		                     IF EMPTY(cbaddr2)
		                        m.caddr2 = TRIM(cbcity)+' '+cbstate+' '+cbzip
		                        m.caddr3 = ' '
		                     ELSE
		                        m.caddr2 = cbaddr2
		                        m.caddr3 = TRIM(cbcity)+' '+cbstate+' '+cbzip
		                     ENDIF
		                  ELSE
		                     m.cPayee = 'Deposit'
		                     m.caddr1 = SPACE(40)
		                     m.caddr2 = SPACE(40)
		                     m.caddr3 = SPACE(40)
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      OTHERWISE
		         m.cPayee = 'Manual Entry'
		         STORE '' TO m.caddr1, m.caddr2, m.caddr3
		   ENDCASE
		
		   IF checks.cPayee <> m.cPayee
		      THISFORM.cmdatamanager.REPLACE('Checks','Cpayee',m.cPayee)
		   ENDIF
		   THISFORM.txtcaddr1.VALUE = m.caddr1
		   THISFORM.txtcaddr2.VALUE = m.caddr2
		   THISFORM.txtcaddr3.VALUE = m.caddr3
		
		   THISFORM.txtcaddr1.Refresh()
		   thisform.txtcaddr2.Refresh()
		   thisform.txtcaddr3.Refresh()
		   thisform.txtcpayee.Refresh()
		ENDIF
		
	ENDPROC

	PROCEDURE txtCid.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtCidtype.Valid
		IF checks.lManual  &&  If a manual check, make sure it gets a source on it
		   IF THIS.VALUE = 'I'  &&  Owner check
		      REPLACE checks.csource WITH 'DM'
		   ELSE  &&  Anything else
		      if m.goApp.lAMVersion  &&  If DM, replace the type with 'DM' no matter what
		         REPLACE checks.csource WITH 'AP'
		      else
		         replace checks.cSource with 'DM'
		      endif
		   ENDIF
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtCidtype.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtCpayee.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtCperiod.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtCsource.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtcWordNum.When
		RETURN .f.
	ENDPROC

	PROCEDURE txtCyear.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtdCheckDate.When
		RETURN checks.lManual
	ENDPROC

	PROCEDURE txtNamount.Valid
		DODEFAULT()
		thisform.txtcWordNum.value = NumToWords(Checks.nAmount) + '**********'
		thisform.txtcWordNum.Refresh()
	ENDPROC

	PROCEDURE txtNamount.When
		RETURN checks.lManual
	ENDPROC

ENDDEFINE
