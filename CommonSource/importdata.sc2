*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="importdata.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 688
	Left = 71
	Name = "Dataenvironment"
	Top = 100
	Width = 716

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "importdefs", ;
		BufferModeOverride = 5, ;
		CursorSource = "importdefs", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 91, ;
		Left = 183, ;
		Name = "Cursor11", ;
		Top = 176, ;
		Width = 98
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "revcat", ;
		CursorSource = "revcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 194, ;
		Name = "Cursor3", ;
		Top = 36, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 334, ;
		Name = "Cursor4", ;
		Top = 47, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "importmap", ;
		CursorSource = "importmap", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 158, ;
		Left = 30, ;
		Name = "Cursor9", ;
		Top = 44, ;
		Width = 102
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formimportdata AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdImport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblImport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboImportMap" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdMapping" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: allocevenly		&& Allocate the MCF total evenly among the wells tied to this master meter
		*m: backupdata
		*m: buildcodes
		*m: buildmeter		&& Builds list of wells and data already imported into meterdata.
		*m: calcallocation		&& Does the allocation
		*m: checkaccountlevels
		*m: chkforsubmeter		&& Checks to see if the wells have any totals
		*m: coaparentcheck
		*m: dmexpense
		*m: dmincome		&& Post receipt to well income table.
		*m: excelexit
		*m: fixsortfield
		*m: gasreceipts		&& Builds Cash Receipts from Imported Gas Data
		*m: genfilename
		*m: getacctlistid
		*m: handlecoa
		*m: handlecusts
		*m: handledoi
		*m: handleexpcodes
		*m: handlegl
		*m: handleland		&& Imports land records
		*m: handlemeters		&& Import Master Meters
		*m: handleobligations		&& Imports Lease Obligations
		*m: handleowners
		*m: handlepumpers
		*m: handlepurchasers
		*m: handlevends
		*m: handlewells
		*m: import		&& Imports the given format
		*m: importexcel		&& Import Excel Data
		*m: lookupoper
		*m: meter_report		&& Prints report of allocations done.
		*m: oilreceipts		&& Builds cash receipt from imported oil data
		*m: postbill
		*m: postgl
		*m: postrcpt
		*m: processcdex		&& Processes the importfile created by the import of a CDEX DAT file.
		*m: processmap		&& Processes the importfile cursor created by importing an owner relations connect csv file.
		*m: qbpostbill
		*m: qbpostrec		&& Post receipt to QuickBooks
		*m: recalcnri
		*m: reportprobs
		*m: wellincome
		*p: cerror
		*p: importtype
		*p: ioperatorkpk
		*p: ioperatorpk
		*p: lqbnopost
		*p: lsendtoallocate
		*p: ntotalimport
		*p: odist
		*p: oexcel
		*p: ofile		&& SWFile object
	*</DefinedPropArrayMethod>

	Caption = "Import Data"
	cerror = 
	DoCreate = .T.
	Height = 206
	importtype = *
	ioperatorkpk = 0
	ioperatorpk = 0
	lnonewask = .T.
	lsendtoallocate = .F.
	Name = "formimportdata"
	ntotalimport = 0
	ofile = .NULL.		&& SWFile object
	Width = 617
	_memberdata = <VFPData>
		<memberdata name="import" display="Import"/>
		<memberdata name="ofile" display="oFile"/>
		<memberdata name="processcdex" display="ProcessCDEX"/>
		<memberdata name="ioperatorpk" display="iOperatorPK"/>
		<memberdata name="ntotalimport" display="nTotalImport"/>
		<memberdata name="buildcodes" display="BuildCodes"/>
		<memberdata name="getacctlistid" display="GetAcctListID"/>
		<memberdata name="wellincome" display="WellIncome"/>
		<memberdata name="lsendtoallocate" display="lSendToAllocate"/>
		<memberdata name="importtype" display="ImportType"/>
		<memberdata name="processmap" display="ProcessMap"/>
		<memberdata name="handlewells" display="HandleWells"/>
		<memberdata name="handleowners" display="HandleOwners"/>
		<memberdata name="handlecusts" display="HandleCusts"/>
		<memberdata name="handlevends" display="HandleVends"/>
		<memberdata name="handlecoa" display="HandleCOA"/>
		<memberdata name="handledoi" display="HandleDOI"/>
		<memberdata name="handlegl" display="HandleGL"/>
		<memberdata name="genfilename" display="GenFileName"/>
		<memberdata name="backupdata" display="BackupData"/>
		<memberdata name="fixsortfield" display="FixSortField"/>
		<memberdata name="handlepurchasers" display="HandlePurchasers"/>
		<memberdata name="handleexpcodes" display="HandleExpCodes"/>
		<memberdata name="reportprobs" display="ReportProbs"/>
		<memberdata name="dmexpense" display="DMExpense"/>
		<memberdata name="postgl" display="PostGL"/>
		<memberdata name="recalcnri" display="RecalcNRI"/>
		<memberdata name="checkaccountlevels" display="CheckAccountLevels"/>
		<memberdata name="handleland" display="HandleLand"/>
		<memberdata name="handleobligations" display="HandleObligations"/>
		<memberdata name="handlemeters" display="HandleMeters"/>
		<memberdata name="handlepumpers" display="HandlePumpers"/>
		</VFPData>
	cmdatamanager.Left = 4
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 7
	cmdatamanager.Top = 1
	cmlookupmanager.Left = 17
	cmlookupmanager.Name = "cmlookupmanager"
	cmlookupmanager.Top = 3
	MWRESIZE1.lblHighLight.Name = "lblHighLight"
	MWRESIZE1.lblShading.Name = "lblShading"
	MWRESIZE1.Left = 600
	MWRESIZE1.Name = "MWRESIZE1"
	MWRESIZE1.TabIndex = 5
	MWRESIZE1.Top = 312

	ADD OBJECT 'cboImportMap' AS cbocomboboxcustom WITH ;
		Height = 22, ;
		Left = 156, ;
		Name = "cboImportMap", ;
		TabIndex = 1, ;
		Top = 48, ;
		Visible = .T., ;
		Width = 384
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 48, ;
		Left = 360, ;
		Name = "cmdExit", ;
		TabIndex = 4, ;
		Top = 132, ;
		Width = 84
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdImport' AS cmdcommandbuttoncustom WITH ;
		Caption = "Choose Data", ;
		Height = 48, ;
		Left = 166, ;
		Name = "cmdImport", ;
		TabIndex = 2, ;
		Top = 132, ;
		Width = 86
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdMapping' AS cmdcommandbuttoncustom WITH ;
		Caption = "Mapping", ;
		Height = 48, ;
		Left = 265, ;
		Name = "cmdMapping", ;
		TabIndex = 3, ;
		Top = 132, ;
		Width = 82
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 24, ;
		Name = "Glmaint", ;
		Top = 84
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'lblImport' AS lbllabelcustom WITH ;
		Caption = "Import Map", ;
		Left = 83, ;
		Name = "lblImport", ;
		TabIndex = 6, ;
		Top = 51, ;
		Visible = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />
	
	PROCEDURE Activate
		IF DODEFAULT()
		   thisform.cboImportMap.Requery()
		ENDIF 
	ENDPROC

	PROCEDURE allocevenly		&& Allocate the MCF total evenly among the wells tied to this master meter
	ENDPROC

	PROCEDURE backupdata
		
		* Skip out if we're testing
		IF FILE('debug.dat')
		   RETURN
		ENDIF 
		
		IF MESSAGEBOX('Do you want to create a backup of your current data before the import?' + CHR(10) + CHR(10) + ;
		              'THIS IS RECOMMENDED UNLESS YOU HAVE A CURRENT BACKUP ALREADY!',36,'Backup Data') = 7
		   RETURN
		ENDIF 
		
		lcDataPath = ALLT(m.goApp.cDataFilePath)
		IF NOT ':' $ lcDataPath AND NOT '\\' $ lcDataPath AND LEFT(lcDataPath, 1) <> '\'
		    lcSavePath = ALLT(CURDIR())
		    lcDataPath = SYS(5) + CURDIR() + lcDataPath
		ELSE
		    IF LEFT(lcDataPath, 1) = '\' AND NOT '\\' $ lcDataPath
		        lcDataPath = SYS(5) + lcDataPath
		    ENDIF
		ENDIF
		lcFolderName = lcDataPath
		lcDataPath   = '"' + lcDataPath + '*.*' + '"'
		
		IF NOT '\' $ lcDataPath
		    lcDataPath = 'Datafiles\data\*.*'
		ENDIF
		
		lcFileName = JUSTPATH(lcDataPath)
		
		lcDataPath = ALLTRIM(m.goApp.cDataFilePath)
		lcFolder   = specialfolders('CommonDocuments')
		lcFileName = THISFORM.GenFileName()
		
		lnError = swbackup('B', lcDataPath, lcFileName, lcFolder, .f., .f., .f., .f., .t.)
		
		
	ENDPROC

	PROCEDURE buildcodes
		LOCAL llReturn, lnCount, loError
		LOCAL ccode, x
		
		llReturn = .T.
		
		TRY
		* Build revenue import codes
		    CREATE CURSOR oiltypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'OIL'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO oiltypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		    CREATE CURSOR gastypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'GAS'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO gastypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		    CREATE CURSOR ngltypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'NGL'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO ngltypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the adjustment codes
		    CREATE CURSOR adjtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'ADJ'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO adjtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the royalty codes
		    CREATE CURSOR roytypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'ROY'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO roytypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the workint int codes
		    CREATE CURSOR wrktypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'WRK'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO wrktypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the override int codes
		    CREATE CURSOR ovrtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'OVR'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO ovrtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the STAX codes
		    CREATE CURSOR staxtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'STAX'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO staxtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		
		* Build the PTAX codes
		    CREATE CURSOR ptaxtypes (ccode c(10))
		    swselect('importtypes')
		    LOCATE FOR cType = 'PTAX'
		    IF FOUND()
		        SELECT importtypes
		        lnCount = GETWORDCOUNT(mtypes, ',')
		        FOR x = 1 TO lnCount
		            m.ccode = ALLTRIM(GETWORDNUM(ALLTRIM(mtypes), x, ','))
		            INSERT INTO ptaxtypes FROM MEMVAR
		        ENDFOR
		    ENDIF
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'BuildCodes', loError.LINENO, 'Import Revenue', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE buildmeter		&& Builds list of wells and data already imported into meterdata.
	ENDPROC

	PROCEDURE calcallocation		&& Does the allocation
	ENDPROC

	PROCEDURE checkaccountlevels
		LPARAMETERS tcacctno, tcParent
		** Checks to see what level this account is on, and refreshes the label accordingly  **
		
		LOCAL lcAcctNo, lcAcctNo2, lcAcctNo3, lcAcctNo4, llParent, llreturn, lnLevel, lnLevelBelow, lnRecNo2
		LOCAL lnRecNo3, lnRecNo4, loError
		
		TRY
		   lcAcctNo		= tcParent
		   lnLevel		= 1
		   lnLevelBelow	= 0
		   llreturn		= .T.
		
		   swselect('coa', .F., 'coa1')
		
		**  Do a preliminary check to make sure that the account is not going to be getting set as a sub account of itself, through a circular route
		**  There are two checks to be made:  first, look downstream, then look upstream for matching accounts.  It can't be done in a single step due to buffering issues.
		   llParent = .F.  &&  Flag for whether we find this account as a subaccount of itself
		   SELECT coa1
		   LOCATE FOR cacctno = tcParent  &&  Look through all subaccounts for this account - these would be level 2 accounts, at a minimum
		   IF FOUND()
		      lnRecNo2	= RECNO()
		      lcAcctNo2	= coa1.cacctno
		      IF coa1.cparent = tcacctno  &&  The next level down sets it as a parent account
		         llParent = .T.
		      ELSE
		         SCAN FOR cparent = lcAcctNo2 AND cacctno <> tcacctno  &&  Level 3 accounts, and the first ones that could possibly be set back to the original account
		            IF cacctno = tcacctno  &&  The account is set as a parent of itself, so bail out
		               llParent = .T.
		
		            ENDIF
		            lnRecNo3  = RECNO()
		            lcAcctNo3 = coa1.cacctno
		            SCAN FOR cparent = lcAcctNo3 AND cacctno <> tcacctno  &&  Level 4 accounts
		               IF cacctno = tcacctno  &&  The account is set as a parent of itself, so bail out
		                  llParent = .T.
		
		               ENDIF
		               lnRecNo4	 = RECNO()
		               lcAcctNo4 = coa1.cacctno
		               SCAN FOR cparent = lcAcctNo4 AND cacctno <> tcacctno  &&  Level 5 accounts, and the deepest we'll check.  Even if it winds up being more than 5 levels deep, the validation below will catch it.
		                  IF cacctno = tcacctno  &&  The account is set as a parent of itself, so bail out
		                     llParent = .T.
		
		                  ENDIF
		               ENDSCAN
		               GOTO lnRecNo4
		            ENDSCAN
		            GOTO lnRecNo3
		         ENDSCAN
		      ENDIF
		      GOTO lnRecNo2
		   ENDIF
		
		   IF llParent = .T.  &&  It turned out to be a parent of itself, so don't let them proceed
		      THISFORM.cError = 'The selected account cannot be chosen as a parent account, as doing so will make this account a parent of itself.'
		      llreturn		  = .F.
		      EXIT
		   ENDIF
		
		
		   IF NOT EMPTY(lcAcctNo)  &&  Is a subaccount, so automatically becomes a level 2, then checks further
		      SELECT coa1
		      SET ORDER TO acctno
		      IF SEEK(lcAcctNo)
		         lnLevel = 2
		         IF NOT EMPTY(coa1.cparent)  &&  Check to see if it's a level 3 account
		            lcAcctNo = coa1.cparent
		            SELECT coa1
		            IF SEEK(lcAcctNo)
		               lnLevel = 3  &&  Account exists, so it becomes a level 3
		               IF NOT EMPTY(coa1.cparent)  &&  Check to see if it's a level 4
		                  lcAcctNo = coa1.cparent
		                  SELECT coa1
		                  IF SEEK(lcAcctNo)
		                     lnLevel = 4  &&  Account exists, so it becomes a level 4
		                     IF NOT EMPTY(coa1.cparent)  &&  Check to see if it's a level 5
		                        lcAcctNo = coa1.cparent
		                        SELECT coa1
		                        IF SEEK(lcAcctNo)
		                           lnLevel = 5
		                           IF NOT EMPTY(coa1.cparent)  &&  Check to see if it's more than 5 levels deep, and don't let them set it up this way
		                              lnLevel = 6
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDIF
		
		   IF lnLevel <> 6  &&  If the account itself isn't above a level 5, check to see how many levels are below it, to make sure it isn't crossing the 5 level limit
		      SELECT coa1
		      LOCATE FOR cparent = tcacctno
		      IF FOUND()
		         lnLevelBelow = 1
		         lcAcctNo	  = coa1.cacctno
		         LOCATE FOR cparent = lcAcctNo
		         IF FOUND()
		            lnLevelBelow = 2
		            lcAcctNo	 = coa1.cacctno
		            LOCATE FOR cparent = lcAcctNo
		            IF FOUND()
		               lnLevelBelow	= 3
		               lcAcctNo		= coa1.cacctno
		               LOCATE FOR cparent = lcAcctNo
		               IF FOUND()
		                  lnLevelBelow = 4
		                  lcAcctNo	   = coa1.cacctno
		                  LOCATE FOR cparent = lcAcctNo
		                  IF FOUND()
		                     lnLevelBelow = 5
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		      IF lnLevel + lnLevelBelow > 5  &&  More than 5 levels deep, so don't let them do it
		         THISFORM.cError = 'The chosen account cannot be selected, since it will create a sublevel structure more than 5 levels deep.  Please choose a different account as the parent account.'
		         llreturn		 = .F.
		         EXIT
		      ENDIF
		   ELSE
		      THISFORM.cError = 'There are a maximum of 5 account levels.  Selecting this account as a subaccount would make it more than 5 levels deep from the parent account.'
		      llreturn		  = .F.
		      EXIT
		   ENDIF
		CATCH TO loError
		   llreturn = .F.
		ENDTRY
		
		RETURN llreturn
	ENDPROC

	PROCEDURE chkforsubmeter		&& Checks to see if the wells have any totals
	ENDPROC

	PROCEDURE coaparentcheck
	ENDPROC

	PROCEDURE dmexpense
		LOCAL lcBatch, lcYear, lcPeriod, llAllocExp
		*
		*  Adds the expense entries to the disbursement manager EXPSUSP
		*
		llReturn = .T.
		
		TRY
		    swselect('wells')
		    SET ORDER TO cWellID
		    GO TOP
		    lcWellID1 = cWellID
		    GO BOTT
		    lcWellID2 = cWellID
		
		*  Check to see if expenses entered for wells were allocated
		*  If so, and the period isn't closed, delete it.  Otherwise
		*  let the user know he can't delete this entry.
		    lcBatch = gljourn.cBatch
		
		    IF NOT checkexp(lcBatch)
		        llReturn = .F.
		        EXIT
		    ENDIF
		
		    swselect('afeopt')  &&  Whether to allocate AFE expenses or not
		    llAllocExp = lAllocExp
		
		    swselect('expsusp',.T.)
		    SCAN FOR cBatch == lcBatch
		        DELE NEXT 1
		    ENDSCAN
		
		* Remove Expense entries
		    swselect('expense',.t.)
		    SCAN FOR cBatch == lcBatch
		        DELE NEXT 1
		    ENDSCAN
		
		    m.cvendorid   = ''
		    m.dExpDate    = gljourn.dgldate
		    lcYear        = gljourn.cyear
		    lcPeriod      = gljourn.cperiod
		    m.crefid      = gljourn.cglref
		    m.lAPTran     = .T.
		    m.cBatch      = lcBatch
		    m.dPostDate   = gljourn.dgldate
		    m.cMemo       = ''
		    m.cPaidByCk   = ''
		    m.cPrdPaid    = ''
		    m.lFixed      = .F.
		    m.lClosed     = .F.
		    m.lAllocated  = .F.
		    m.nRunNoRev   = 0
		    m.nRunNoJIB   = 0
		    m.cRunYearRev = ''
		    m.cRunYearJIB = ''
		
		    swselect('gljndet')
		    SCAN FOR cBatch == lcBatch AND NOT EMPTY(cUnitNo) AND NOT EMPTY(cCatCode)
		        SCATTER MEMVAR
		        m.cPayee     = m.cdesc
		
		*  Don't process any non-well expenses
		        swselect('wells')
		        SET ORDER TO cWellID
		        IF NOT SEEK(m.cUnitNo)
		            LOOP
		        ENDIF
		
		*  Don't process any expenses that aren't tied
		*  to a valid expense category code
		        swselect('expcat')
		        SET ORDER TO cCatCode
		        IF NOT SEEK(m.cCatCode)
		            LOOP
		        ELSE
		            IF m.goapp.lAFEOpt AND lAFEType AND NOT llAllocExp  &&  Only loop if they've got the AFE mod and it's not set to allocate to AFE expenses
		                LOOP
		            ENDIF
		            m.cCateg    = cCateg
		            m.cExpClass = cExpClass
		        ENDIF
		
		        m.cMemo      = gljndet.cdesc
		        m.cYear      = ''
		        m.cPeriod    = ''
		        m.cWellID    = m.cUnitNo
		        m.nSaltWater = 0
		
		        IF m.nDebits > 0
		            m.nAmount = m.nDebits
		        ENDIF
		
		        IF m.nCredits > 0
		            m.nAmount = m.nCredits * -1
		        ENDIF
		
		* Adjust amount to account for dummy owners
		        m.nAmount = swNetExp(m.nAmount, m.cWellID, .F., m.cExpClass, 'B')
		
		        m.lOneMan = .F.
		        m.cidexps = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Expense')
		
		        swselect('expsusp')
		        SET DELE OFF
		        SET ORDER TO cidexps
		        DO WHILE SEEK(m.cidexps)
		            m.cidexps    = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Expense')
		        ENDDO
		        SET DELE ON
		
		        INSERT INTO expsusp FROM MEMVAR
		    ENDSCAN
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'DMExpense', loError.LINENO, 'Import GL', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE dmincome		&& Post receipt to well income table.
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		
		if nerror = 1737
		   dodefault(nerror,cmethod,nline)
		   return
		endif
		   
		dodefault(nerror,cmethod,nline)
		
	ENDPROC

	PROCEDURE excelexit
		thisform.oExcel.QUIT()
		
		thisform.oExcel = .Null.
	ENDPROC

	PROCEDURE fixsortfield
		LPARAMETERS tcType
		**  Scans through the owner file, replacing the sortfield with a reversed name, if necessary.      **
		**  It reverses by going back one space from the end, and using that as the cut-off point.         **
		**  It reverses special cases like Jr.'s by going back two spaces from the right before reversing. **
		
		LOCAL oProgress
		
		
		IF VARTYPE(tcType) # 'C'
		    tcType = 'OWNERS'
		ENDIF
		
		oProgress = THISFORM.omessage.progressbarex('Building the Sort Field (Reversing the Owner Name)')
		
		swselect('investor')
		COUNT FOR EMPTY(csortfield) TO lnMax
		SET ORDER TO 0
		
		tcType = UPPER(tcType)
		
		lnCount = 1
		oProgress.SetProgressRange(0, lnMax)
		IF tcType = 'OWNERS'
		    SELECT investor
		ELSE
		    SELECT vendor
		ENDIF
		SCAN FOR EMPTY(csortfield)
		    SCATTER MEMVAR
		    IF tcType = 'OWNERS'
		       oProgress.setprogressmessage(ALLTRIM(m.cownname))
		       m.cName = UPPER(ALLT(m.cownname))
		    ELSE
		       oProgress.setprogressmessage(ALLTRIM(m.cvendname))
		       m.cName = UPPER(ALLT(m.cvendname))
		    ENDIF       
		    oProgress.UpdateProgress(lnCount)
		    lnCount = lnCount + 1
		    
		    DO CASE
		
		&&  Things that would cause it to go back 2 spaces from the end before reversing
		        CASE RIGHT(m.cName, 3) = 'JR.' OR RIGHT(m.cName, 2) = 'JR' OR RIGHT(m.cName, 3) = 'III' OR RIGHT(m.cName, 6) = 'ESTATE' OR RIGHT(m.cName, 2) = 'IV' ;
		                OR RIGHT(m.cName, 2) = ' V' OR RIGHT(m.cName, 3) = 'L P' OR RIGHT(m.cName, 2) = 'SR' OR RIGHT(m.cName, 3) = 'SR.'  OR RIGHT(m.cName, 3) = ' II' ;
		                OR RIGHT(m.cName, 6) = 'AND/OR' OR RIGHT(m.cName, 1) = '&' OR RIGHT(m.cName, 5) = 'EXEC.' OR RIGHT(m.cName, 4) = ', MD' OR RIGHT (m.cName, 5) = ', MD.' ;
		                OR RIGHT(m.cName, 3) = ' MD' OR RIGHT(m.cName, 4) = ' MD.' OR RIGHT(m.cName, 4) = ' TUW' OR RIGHT(m.cName, 5) = ' TRST' OR RIGHT(m.cName, 4) = 'M.D.'
		            REPLACE csortfield WITH SUBSTR(ALLT(m.cownname), RAT(' ', ALLT(m.cownname), 2) + 1) + ', ' + SUBSTR(ALLT(m.cownname), 1, RAT(' ', ALLT(m.cownname), 2) - 1)
		
		&&  Things that would cause it NOT to be reversed   
		        CASE 'COMPANY' $ m.cName OR 'BANK' $ m.cName OR 'INC.' $ m.cName OR 'CO.' $ m.cName OR 'OPERATING' $ m.cName OR 'COMPANY' $ m.cName ;
		                OR 'PROPERTIES' $ m.cName OR 'LIVING' $ m.cName OR 'TRUST' $ m.cName OR 'LTD' $ m.cName OR ' LAND' $ m.cName OR 'PARTNER' $ m.cName ;
		                OR 'CORP.' $ m.cName OR 'CORPORATION' $ m.cName OR 'PETROLEUM' $ m.cName OR 'PROPERTY' $ m.cName OR 'LIMITED' $ m.cName OR 'PRODUCTION' $ m.cName ;
		                OR 'LLC' $ m.cName OR 'CORP' $ m.cName OR 'LLP' $ m.cName OR 'FOUNDATION' $ m.cName OR 'CONSERVATION' $ m.cName OR 'DEVELOPMENT' $ m.cName ;
		                OR 'ASSOCIATION' $ m.cName OR 'METHODIST' $ m.cName OR 'SCHOOL' $ m.cName OR RIGHT(m.cName, 4) = ' AND' OR RIGHT(m.cName, 1) = ')' ;
		                OR RIGHT(m.cName, 3) = 'INC' OR 'CONSOLIDATED' $ m.cName OR 'INVESTMENT' $ m.cName OR 'CONSULTANT' $ m.cName OR 'COLLECTION' $ m.cName ;
		                OR 'CREEK' $ m.cName OR 'GROUP' $ m.cName OR '#' $ m.cName OR 'MANUFACTURING' $ m.cName OR 'GAS ' $ m.cName OR 'RESOURCES' $ m.cName ;
		                OR 'SUMMIT' $ m.cName OR 'CHURCH' $ m.cName OR 'SERVICE' $ m.cName OR 'MINERALS' $ m.cName OR 'BAPTIST' $ m.cName OR 'STATE' $ m.cName ;
		                OR 'RENTAL' $ m.cName OR 'DRILLING' $ m.cName OR 'OWNER' $ m.cName OR 'REFINING' $ m.cName OR 'INTEREST' $ m.cName OR RIGHT(m.cName, 4) = ' TRT' ;
		                OR 'ROYALTIES' $ m.cName OR RIGHT(m.cName, 3) = ' CO' OR 'TENANT' $ m.cName OR 'ASSOCIATES' $ m.cName OR RIGHT(m.cName, 4) = ' TTE' ;
		                OR RIGHT(m.cName, 4) = ' DBA' OR RIGHT(m.cName, 6) = ' D/B/A' OR RIGHT(m.cName, 4) = ' TR.' OR 'ELECTRIC' $ m.cName OR RIGHT(m.cName, 3) = ' LP' ;
		                OR 'NATURAL' $ m.cName OR RIGHT(m.cName, 4) = ' EST' OR 'ENERGY' $ m.cName OR 'REVOC' $ m.cName OR 'EXPLORATION' $ m.cName OR RIGHT(m.cName, 5) = ' TTEE' ;
		                OR 'COMP.' $ m.cName OR ' OIL' $ m.cName OR 'TRST.' $ m.cName OR 'FIREPROOFING' $ m.cName OR 'LAKE ERIE' $ m.cName OR 'FARMS' $ m.cName ;
		                OR 'RANCH' $ m.cName OR 'COMMISSIONER' $ m.cName OR 'MOBILE HOMES' $ m.cName OR 'KILLBUCK' $ m.cName OR 'APARTMENT' $ m.cName OR 'WORKERS' $ m.cName ;
		                OR 'BRONCO' $ m.cName OR 'AGENT' $ m.cName OR 'HEIRS' $ m.cName OR 'CHARLESTON' $ m.cName OR RIGHT(m.cName, 6) = 'L.L.C.' OR 'AIRSTRIP' $ m.cName ;
		                OR ' TR ' $ m.cName OR ' REV ' $ m.cName OR 'TELEPHONE' $ m.cName OR 'DOZEN' $ m.cName OR 'COMMUNITY' $ m.cName OR 'SEP -' $ m.cName ;
		                OR 'DEPARTMENT' $ m.cName OR 'BOYS HOME' $ m.cName OR 'DEPOSIT' $ m.cName OR 'ENGINEER' $ m.cName OR '2001' $ m.cName OR '2002' $ m.cName ;
		                OR '2003' $ m.cName OR 'COLLEGE' $ m.cName OR 'PRESBYTERIAN' $ m.cName OR 'TOWN OF' $ m.cName OR 'INVEST' $ m.cName OR 'HOME FOR' $ m.cName ;
		                OR 'CONGREGATION' $ m.cName OR ' BANK ' $ m.cName OR RIGHT(m.cName, 5) = ' BANK' OR 'HOSPITAL' $ m.cName OR 'BIBLE ' $ m.cName OR RIGHT(m.cName, 5) = ' L.C.' ;
		                OR 'CEMETERY' $ m.cName OR 'LUTHERAN' $ m.cName OR 'LODGE' $ m.cName OR 'PAID' $ m.cName OR RIGHT(m.cName, 4) = 'L.P.' OR RIGHT(m.cName, 3) = ' TR' ;
		                OR 'SOCIETY' $ m.cName
		
		            IF csortfield <> cownname
		                REPLACE csortfield WITH cownname
		            ENDIF
		            LOOP
		
		        OTHERWISE  &&  Reverse as normal
		            REPL csortfield WITH SUBSTR(ALLT(m.cname), RAT(' ', ALLT(m.cname)) + 1) + ', ' + SUBSTR(ALLT(m.cname), 1, RAT(' ', ALLT(m.cname)) - 1)
		    ENDCASE
		ENDSCAN
		
		oProgress.CLOSE()
		oProgress = .NULL.
		
		WAIT CLEAR
	ENDPROC

	PROCEDURE gasreceipts		&& Builds Cash Receipts from Imported Gas Data
	ENDPROC

	PROCEDURE genfilename
		
		lcFileName = ALLT(STRTRAN(LOWER(m.goApp.ccompanyname), ' ', '')) + '_' + ALLT(STR(YEAR(DATE()))) + '_' + PADL(ALLT(STR(MONTH(DATE()))), 2, '0') + '_' + PADL(ALLT(STR(DAY(DATE()))), 2, '0')
		   lcFileName = STRTRAN(lcFileName, ',', '')
		   lcFileName = STRTRAN(lcFileName, '.', '')
		   lcFileName = STRTRAN(lcFileName, '-', '')
		   lcFileName = STRTRAN(lcFileName, '#', '')
		   lcFileName = STRTRAN(lcFileName, '&', '')
		   lcFileName = STRTRAN(lcFileName, '\', '')
		   lcFileName = STRTRAN(lcFileName, '/', '')
		   lcFileName = STRTRAN(lcFileName, '?', '')
		   lcFileName = STRTRAN(lcFileName, "'", '')
		   lcFileName = STRTRAN(lcFileName, ' ', '')
		   lcFileName = STRTRAN(lcFileName, '*', '')
		
		   lcFileName = ALLTRIM(lcFileName) + '_'+ STRTRAN(TIME(),':','_')
		
		   IF UPPER(RIGHT(ALLTRIM(lcFileName), 4)) <> '.ZIP'  &&  Only append the .ZIP if it doesn't already exist
		      lcFileName = lcFileName + '.zip'
		   ENDIF
		   
		   RETURN lcFileName
	ENDPROC

	PROCEDURE getacctlistid
	ENDPROC

	PROCEDURE handlecoa
		LOCAL llDuplicates, llReplace, loError, llReturn
		
		llReturn	 = .T.
		llDuplicates = .F.
		llReplace	 = .T.
		llContinue	 = .T.
		
		TRY
		   swselect('coa', .T.)
		   SET ORDER TO acctno
		   SET DELETED OFF
		   SELECT importfile
		   SCAN
		      m.cID1  = PADR(ALLTRIM(cacctno), 6, '0')
		      m.cID2  = ''
		      m.cName = ALLTRIM(cAcctDesc)
		      IF NOT THISFORM.CheckAccountLevels(importfile.cacctno, importfile.cParent)
		         m.coldid	= importfile.cacctno
		         m.coldname	= importfile.cAcctDesc
		         m.cdesc	= THISFORM.cerror
		         INSERT INTO badrecs FROM MEMVAR
		         llContinue = .F.
		      ENDIF
		      SELECT coa
		      LOCATE FOR cacctno = ALLTRIM(m.cID1)
		      IF FOUND()
		         IF DELETED()
		            RECALL
		            TABLEUPDATE(.T., .T., 'Coa')
		         ENDIF
		         m.coldid	  = cacctno
		         m.coldname	  = cAcctDesc
		         m.cdesc	  = 'Duplicate Account found.'
		         llDuplicates = .T.
		         INSERT INTO badrecs FROM MEMVAR
		      ENDIF
		
		* If an invalid account type is passed it defaults to "Other Expenses"        
		      SELECT importfile
		      IF NOT BETWEEN(nAcctType, 1, 16)
		         REPLACE nAcctType WITH 14
		      ENDIF
		
		   ENDSCAN
		   SET DELETED ON
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace = THISFORM.ReportProbs('Importing Accounts', llContinue, llDuplicates)
		   ENDIF
		   
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		
		
		   DO CASE
		      CASE NOT llContinue
		         llReturn = .F.
		
		      CASE NOT llDuplicates
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cacctno)
		            SCATTER MEMVAR MEMO
		            SELECT coa
		            SET ORDER TO acctno
		            IF NOT SEEK(m.cacctno)
		               INSERT INTO coa FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		      CASE llReplace
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cacctno)
		            SCATTER MEMVAR
		            SELECT coa
		            IF SEEK(m.cacctno)
		               IF NOT EMPTY(m.cAcctDesc)
		                  REPLACE cAcctDesc WITH m.cAcctDesc
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'caccttype'
		               IF FOUND()
		                  SELECT coa
		                  REPLACE nAcctType WITH m.nAcctType
		               ENDIF
		               IF NOT EMPTY(m.cParent)
		                  REPLACE cParent WITH m.cParent
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cbankacct'
		               IF FOUND()
		                  SELECT coa
		                  REPLACE lBankAcct  WITH m.lBankAcct
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cacctunit'
		               IF FOUND()
		                  SELECT coa
		                  REPLACE lAcctUnit WITH m.lAcctUnit
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'crent1099'
		               IF FOUND()
		                  SELECT coa
		                  REPLACE lRent1099 WITH m.lRent1099
		               ENDIF
		            ELSE
		               SELECT coa
		               SET ORDER TO acctno
		               IF NOT SEEK(m.cacctno)
		                  INSERT INTO coa FROM MEMVAR
		               ENDIF
		            ENDIF
		         ENDSCAN
		      OTHERWISE
		         llReturn = .F.
		   ENDCASE
		
		   TABLEUPDATE(.T., .T., 'Coa')
		
		   lnCount = RECCOUNT('importfile')
		
		   IF llReturn
		      MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' accounts.', 64, 'Import Accounts')
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'HandleCOA', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handlecusts
		LOCAL llDuplicates, llReplace, loError, llReturn
		LOCAL lcMessage, lnCount
		LOCAL cCustName, cOldCust, cOldName, ccustid
		
		llReturn	 = .T.
		llDuplicates = .F.
		llReplace	 = .T.
		llContinue	 = .T.
		
		TRY
		   swselect('custs', .T.)
		   SELECT custs
		   SET ORDER TO ccustid
		   SET DELETED OFF
		   SELECT importfile
		   SCAN
		      m.cID1	  = ccustid
		      m.cID2	  = ''
		      m.cName	  = cCustName
		      m.lContinue = .T.
		
		      SELECT custs
		      IF SEEK(m.cID1)
		         IF DELETED()
		            REPLACE ccustid WITH GetNextPK('BATCH')
		            LOOP
		         ENDIF
		         m.cOldID	  = ccustid
		         m.cOldName	  = cCustName
		         m.cDesc	  = 'Duplicate Customer found.'
		         llDuplicates = .T.
		         INSERT INTO badrecs FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   SET DELETED ON
		
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace = THISFORM.ReportProbs('Importing Customers', llContinue, llDuplicates)
		   ENDIF
		   
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		   
		
		   DO CASE
		      CASE NOT llContinue
		         llReturn = .F.
		
		      CASE NOT llDuplicates
		         SELECT importfile
		         SCAN FOR NOT EMPTY(ccustid)
		            SCATTER MEMVAR MEMO
		            m.mBillNote = m.mCustNote
		            m.cTaxid = cmEncrypt(ALLTRIM(importfile.ctaxid), m.goapp.cEncryptionKey)
		            SELECT custs
		            SET ORDER TO ccustid
		            IF NOT SEEK(m.ccustid)
		               INSERT INTO custs FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		      CASE llReplace
		         SELECT importfile
		         SCAN FOR NOT EMPTY(ccustid)
		            SCATTER MEMVAR
		            SET DELETED OFF
		            SELECT custs
		            IF SEEK(m.ccustid)
		               IF DELETED()
		                  RECALL
		               ENDIF
		               IF NOT EMPTY(m.cCustName)
		                  REPLACE cCustName WITH m.cCustName
		               ENDIF
		               IF NOT EMPTY(m.cAddress1)
		                  REPLACE cAddress1 WITH m.cAddress1
		               ENDIF
		               IF NOT EMPTY(m.cAddress2)
		                  REPLACE cAddress2 WITH m.cAddress2
		               ENDIF
		               IF NOT EMPTY(m.cCity)
		                  REPLACE cCity  WITH m.cCity
		               ENDIF
		               IF NOT EMPTY(m.cState)
		                  REPLACE cState WITH m.cState
		               ENDIF
		               IF NOT EMPTY(m.czip)
		                  REPLACE czip WITH m.czip
		               ENDIF
		               IF NOT EMPTY(m.cphone)
		                  REPLACE cphone WITH m.cphone
		               ENDIF
		               IF NOT EMPTY(m.cFaxPhone)
		                  REPLACE cFaxPhone WITH m.cFaxPhone
		               ENDIF
		               IF NOT EMPTY(m.ccontact)
		                  REPLACE ccontact WITH m.ccontact
		               ENDIF
		               IF NOT EMPTY(m.cbaddr1)
		                  REPLACE cbaddr1 WITH m.cbaddr1
		               ENDIF
		               IF NOT EMPTY(m.cbaddr2)
		                  REPLACE cbaddr2 WITH m.cbaddr2
		               ENDIF
		               IF NOT EMPTY(m.cbCity)
		                  REPLACE cbCity WITH m.cbCity
		               ENDIF
		               IF NOT EMPTY(m.cbState)
		                  REPLACE cbState WITH m.cbState
		               ENDIF
		               IF NOT EMPTY(m.cbZip)
		                  REPLACE cbZip WITH m.cbZip
		               ENDIF
		               IF NOT EMPTY(m.cbphone)
		                  REPLACE cbphone WITH m.cbphone
		               ENDIF
		               IF NOT EMPTY(m.cbfaxphone)
		                  REPLACE cbfaxphone WITH m.cbfaxphone
		               ENDIF
		               IF NOT EMPTY(m.cbcontact)
		                  REPLACE cbcontact WITH m.cbcontact
		               ENDIF
		               IF NOT EMPTY(m.cTaxID)
		                  replace ctaxid WITH cmEncrypt(ALLTRIM(importfile.ctaxid), m.goapp.cEncryptionKey)
		               ENDIF    
		
		               IF NOT EMPTY(m.mCustNote)
		                  REPLACE mCustNote WITH m.mCustNote + CHR(10) + mCustNote
		                  REPLACE mBillNote WITH m.mCustNote + CHR(10) + mBillNote
		               ENDIF
		               SET DELETED ON
		            ELSE
		               SELECT importfile
		               SCAN FOR NOT EMPTY(ccustid)
		                  SCATTER MEMVAR MEMO
		                  m.mBillNote = m.mCustNote
		                  SELECT custs
		                  SET ORDER TO ccustid
		                  IF NOT SEEK(m.ccustid)
		                     INSERT INTO custs FROM MEMVAR
		                  ENDIF
		               ENDSCAN
		            ENDIF
		         ENDSCAN
		      OTHERWISE
		         llReturn = .F.
		   ENDCASE
		
		   TABLEUPDATE(.T., .T., 'Custs')
		
		   lnCount = RECCOUNT('importfile')
		
		   IF llReturn
		      MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' customers.', 64, 'Import Vendor')
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'HandleCusts', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		   SET DELETED ON
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handledoi
		LOCAL llDuplicates, llReplace, loError, llReturn, oProgress
		
		llReturn	 = .T.
		llDuplicates = .F.
		llReplace	 = .T.
		llContinue	 = .T.
		oProgress    = .NULL.
		
		TRY
		   swselect('wellinv', .T.)
		   swselect('wells', .T.)
		   SET ORDER TO cwellid
		   swselect('investor', .T.)
		   SET ORDER TO cownerid
		
		   SELECT importfile
		   SCAN
		      m.cID1	  = PADR(ALLTRIM(cownerid), 10, ' ')
		      m.cID2	  = PADR(ALLTRIM(cwellid), 10, ' ')
		      m.cTypeInv  = ALLTRIM(cTypeInv)
		      m.cprogcode = PADR(ALLTRIM(cprogcode), 10, ' ')
		
		      IF m.cTypeInv = 'R'
		         m.cTypeInv = 'L'
		         REPLACE cTypeInv WITH m.cTypeInv
		      ENDIF
		      IF NOT INLIST(m.cTypeInv, 'L', 'O', 'W')
		         m.cDesc = 'Bad Interest Type'
		         llContinue  = .F.
		         m.lContinue = .F.
		         INSERT INTO badrecs FROM MEMVAR
		      ENDIF
		      SELECT wellinv
		      LOCATE FOR cownerid = m.cID1 AND ;
		         cwellid  = m.cID2 AND ;
		         cTypeInv = m.cTypeInv
		      IF FOUND()
		         m.cDesc	  = 'Interest already exists'
		         m.lContinue  = .T.
		         m.cname	  = ''
		         m.coldname	  = ''
		         m.coldid	  = m.cID1
		         llDuplicates = .T.
		         INSERT INTO badrecs FROM MEMVAR
		      ENDIF
		      SELECT wells
		      IF NOT SEEK(m.cID2)
		         m.cDesc = 'Well not found.'
		         STORE '' TO m.cname, m.coldname, m.coldid
		         m.lContinue = .F.
		         INSERT INTO badrecs FROM MEMVAR
		         llContinue = .F.
		      ENDIF
		      SELECT investor
		      IF NOT SEEK(m.cID1)
		         m.cDesc = 'Owner not found.'
		         STORE '' TO m.cname, m.coldname, m.coldid
		         m.lContinue = .F.
		         INSERT INTO badrecs FROM MEMVAR
		         llContinue = .F.
		      ENDIF
		      IF NOT EMPTY(m.cprogcode)
		         swselect('programs')
		         LOCATE FOR cprogcode = ALLTRIM(m.cprogcode)
		         IF NOT FOUND()
		            m.cDesc = 'Program: ' + ALLTRIM(m.cprogcode) + ' not found.'
		            STORE '' TO m.cname, m.coldname, m.coldid
		            m.lContinue = .F.
		            INSERT INTO badrecs FROM MEMVAR
		            llContinue = .F.
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace = THISFORM.ReportProbs('Importing DOI', llContinue, llDuplicates)
		   ENDIF
		   
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		   
		   IF NOT llContinue
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   SET DELETED OFF
		   SELECT wellinv
		   SET ORDER TO CIDWINV   && CIDWINV
		   GO BOTT
		   lnKey = VAL(RIGHT(CIDWINV, 6)) + 1
		   SET DELETED ON
		
		   IF MESSAGEBOX("Are the interests being imported coming in as decimal interests? " + ;
		                 "If so, they'll be multiplied by 100 to turn them into whole percentages.", 36, 'Decimal Interests?') = 6
		      llDecimal = .T.
		   ELSE
		      llDecimal = .F.
		   ENDIF
		
		   DO CASE
		      CASE NOT llContinue
		         llReturn = .F.
		
		      CASE NOT llDuplicates
		         SELECT importfile
		         lnMax	   = RECCOUNT()
		         lnCount   = 0
		         oProgress = m.goapp.omessage.progressbar('Importing DOI...')
		         oProgress.setProgressRange(0, lnMax)
		         SELECT importfile
		         SCAN
		            SCATTER MEMVAR
		            oProgress.UpdateProgress(lnCount)
		            lnCount = lnCount + 1
		            IF EMPTY(m.cdirect)
		               m.cdirect = 'N'
		            ENDIF
		            IF EMPTY(m.ctypeint)
		               m.ctypeint = 'B'
		            ENDIF
		            m.CIDWINV = GetNextPK('DOI')
		            IF llDecimal
		               m.nWorkInt	= m.nWorkInt * 100
		               m.nRevGas	= m.nRevGas * 100
		               m.nRevOil	= m.nRevOil * 100
		               m.nRevOth	= m.nRevOth * 100
		               m.nRevTrp	= m.nRevTrp * 100
		               m.nrevtax1	= m.nrevtax1 * 100
		               m.nRevTax2	= m.nRevTax2 * 100
		               m.nRevTax3	= m.nRevTax3 * 100
		               m.nrevtax4	= m.nrevtax4 * 100
		               m.nrevtax5	= m.nrevtax5 * 100
		               m.nrevtax6	= m.nrevtax6 * 100
		               m.nrevtax7	= m.nrevtax7 * 100
		               m.nrevtax8	= m.nrevtax8 * 100
		               m.nrevtax9	= m.nrevtax9 * 100
		               m.nrevtax10	= m.nrevtax10 * 100
		               m.nrevtax11	= m.nrevtax11 * 100
		               m.nrevtax12	= m.nrevtax12 * 100
		               m.nIntClass1	= m.nIntClass1 * 100
		               m.nIntClass2	= m.nIntClass2 * 100
		               m.nIntClass3	= m.nIntClass3 * 100
		               m.nIntClass4	= m.nIntClass4 * 100
		               m.nIntClass5	= m.nIntClass5 * 100
		               m.nbcpint	= m.nbcpint * 100
		               m.nacpint	= m.nacpint * 100
		               m.napoint	= m.napoint * 100
		               m.nrevmisc1	= m.nrevmisc1 * 100
		               m.nrevmisc2	= m.nrevmisc2 * 100
		               m.ntaxpct	= m.ntaxpct * 100
		            ENDIF
		            m.dadded   = DATETIME()
		            m.cAddedBy = m.goapp.cUser
		            INSERT INTO wellinv FROM MEMVAR
		         ENDSCAN
		         IF VARTYPE(oProgress) = 'O'
		            oProgress.closeprogress()
		         ENDIF    
		
		      CASE llReplace
		* Get mapped fields to replace
		         STORE .F. TO llTypeInt, llDirect, llProgCode, llJIB, ;
		            llOnHold, llRevOil, llRevGas, llRevOth, ;
		            llWorkInt, llOilTax, llGasTax, llOthTax, ;
		            llIntClass1, llIntClass2, llIntClass3, llIntClass4, ;
		            llIntClass5, llAcpInt, llBcpInt, llRevMisc1, llRevMisc2, ;
		            llTaxPct, llRevTrp, llAPOInt
		         SELECT mappedfields
		         LOCATE FOR cname = 'ctypeint'
		         IF FOUND()
		            llTypeInt = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cdirect'
		         IF FOUND()
		            llDirect = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cprogcode'
		         IF FOUND()
		            llProgCode = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cjib'
		         IF FOUND()
		            llJIB = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'conhold'
		         IF FOUND()
		            llOnHold = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevoil'
		         IF FOUND()
		            llRevOil = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevgas'
		         IF FOUND()
		            llRevGas = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevoth'
		         IF FOUND()
		            llRevOth = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevtrp'
		         IF FOUND()
		            llRevTrp = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cworkint'
		         IF FOUND()
		            llWorkInt = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevtax1'
		         IF FOUND()
		            llOilTax = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevtax2'
		         IF FOUND()
		            llGasTax = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevtax3'
		         IF FOUND()
		            llOthTax = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cintclass1'
		         IF FOUND()
		            llIntClass1 = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cintclass2'
		         IF FOUND()
		            llIntClass2 = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cintclass3'
		         IF FOUND()
		            llIntClass3 = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cintclass4'
		         IF FOUND()
		            llIntClass4 = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cintclass5'
		         IF FOUND()
		            llIntClass5 = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cbcpint'
		         IF FOUND()
		            llBcpInt = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'cacpint'
		         IF FOUND()
		            llAcpInt = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'capoint'
		         IF FOUND()
		            llApoInt = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevmisc1'
		         IF FOUND()
		            llRevMisc1 = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'crevmisc2'
		         IF FOUND()
		            llRevMisc2 = .T.
		         ENDIF
		         SELECT mappedfields
		         LOCATE FOR cname = 'ctaxpct'
		         IF FOUND()
		            llTaxPct = .T.
		         ENDIF
		         SELECT importfile
		         lnMax	   = RECCOUNT()
		         lnCount   = 0
		         oProgress = m.goapp.omessage.progressbar('Replacing DOI Records...')
		         oProgress.setProgressRange(0, lnMax)
		         SELECT importfile
		         SCAN
		            SCATTER MEMVAR
		            oProgress.UpdateProgress(lnCount)
		            lnCount	  = lnCount + 1
		            m.cwellid = LEFT(m.cwellid, 10)
		            IF EMPTY(m.cdirect)
		               m.cdirect = 'N'
		            ENDIF
		            IF EMPTY(m.ctypeint)
		               m.ctypeint = 'B'
		            ENDIF
		            IF llDecimal
		               m.nWorkInt	= m.nWorkInt * 100
		               m.nRevGas	= m.nRevGas * 100
		               m.nRevOil	= m.nRevOil * 100
		               m.nRevOth	= m.nRevOth * 100
		               m.nRevTrp	= m.nRevTrp * 100
		               m.nrevtax1	= m.nrevtax1 * 100
		               m.nRevTax2	= m.nRevTax2 * 100
		               m.nRevTax3	= m.nRevTax3 * 100
		               m.nrevtax4	= m.nrevtax4 * 100
		               m.nrevtax5	= m.nrevtax5 * 100
		               m.nrevtax6	= m.nrevtax6 * 100
		               m.nrevtax7	= m.nrevtax7 * 100
		               m.nrevtax8	= m.nrevtax8 * 100
		               m.nrevtax9	= m.nrevtax9 * 100
		               m.nrevtax10	= m.nrevtax10 * 100
		               m.nrevtax11	= m.nrevtax11 * 100
		               m.nrevtax12	= m.nrevtax12 * 100
		               m.nIntClass1	= m.nIntClass1 * 100
		               m.nIntClass2	= m.nIntClass2 * 100
		               m.nIntClass3	= m.nIntClass3 * 100
		               m.nIntClass4	= m.nIntClass4 * 100
		               m.nIntClass5	= m.nIntClass5 * 100
		               m.nbcpint	= m.nbcpint * 100
		               m.nacpint	= m.nacpint * 100
		               m.napoint	= m.napoint * 100
		               m.nrevmisc1	= m.nrevmisc1 * 100
		               m.nrevmisc2	= m.nrevmisc2 * 100
		               m.ntaxpct	= m.ntaxpct * 100
		            ENDIF
		            SELECT wellinv
		            LOCATE FOR cownerid = m.cownerid AND ;
		               cwellid  = m.cwellid AND ;
		               cTypeInv = m.cTypeInv
		            IF FOUND()
		               IF llTypeInt
		                  SELECT wellinv
		                  REPLACE ctypeint WITH m.ctypeint
		               ENDIF
		               IF llDirect
		                  SELECT wellinv
		                  REPLACE cdirect WITH m.cdirect
		               ENDIF
		               IF llProgCode
		                  SELECT wellinv
		                  REPLACE cprogcode WITH m.cprogcode
		               ENDIF
		               IF llJIB
		                  SELECT wellinv
		                  REPLACE ljib WITH m.ljib
		               ENDIF
		               IF llOnHold
		                  SELECT wellinv
		                  REPLACE lonhold WITH m.lonhold
		               ENDIF
		               IF llRevOil
		                  SELECT wellinv
		                  REPLACE nRevOil WITH m.nRevOil
		               ENDIF
		               IF llRevGas
		                  SELECT wellinv
		                  REPLACE nRevGas WITH m.nRevGas
		               ENDIF
		               IF llRevOth
		                  SELECT wellinv
		                  REPLACE nRevOth WITH m.nRevOth
		               ENDIF
		               IF llRevTrp
		                  SELECT wellinv
		                  REPLACE nRevTrp WITH m.nRevTrp
		               ENDIF
		               IF llWorkInt
		                  SELECT wellinv
		                  REPLACE nWorkInt WITH m.nWorkInt
		               ENDIF
		               IF llOilTax
		                  SELECT wellinv
		                  REPLACE nrevtax1 WITH m.nrevtax1, ;
		                     nrevtax4 WITH m.nrevtax1, ;
		                     nrevtax7 WITH m.nrevtax1, ;
		                     nrevtax10 WITH m.nrevtax1
		               ENDIF
		               IF llGasTax
		                  SELECT wellinv
		                  REPLACE nRevTax2 WITH m.nRevTax2, ;
		                     nrevtax5 WITH m.nRevTax2, ;
		                     nrevtax8 WITH m.nRevTax2, ;
		                     nrevtax11 WITH m.nRevTax2
		               ENDIF
		               IF llOthTax
		                  SELECT wellinv
		                  REPLACE nRevTax3 WITH m.nRevTax3, ;
		                     nrevtax6 WITH m.nRevTax3, ;
		                     nrevtax9 WITH m.nRevTax3, ;
		                     nrevtax12 WITH m.nRevTax3
		               ENDIF
		               IF llIntClass1
		                  SELECT wellinv
		                  REPLACE nIntClass1 WITH m.nIntClass1
		               ENDIF
		               IF llIntClass2
		                  SELECT wellinv
		                  REPLACE nIntClass2 WITH m.nIntClass2
		               ENDIF
		               IF llIntClass3
		                  SELECT wellinv
		                  REPLACE nIntClass3 WITH m.nIntClass3
		               ENDIF
		               IF llIntClass4
		                  SELECT wellinv
		                  REPLACE nIntClass4 WITH m.nIntClass4
		               ENDIF
		               IF llIntClass5
		                  SELECT wellinv
		                  REPLACE nIntClass5 WITH m.nIntClass5
		               ENDIF
		               IF llBcpInt
		                  SELECT wellinv
		                  REPLACE nbcpint WITH m.nbcpint
		               ENDIF
		               IF llAcpInt
		                  SELECT wellinv
		                  REPLACE nacpint WITH m.nacpint
		               ENDIF
		               IF llApoInt
		                  SELECT wellinv
		                  REPLACE napoint WITH m.napoint
		               ENDIF
		               IF llRevMisc1
		                  SELECT wellinv
		                  REPLACE  nrevmisc1 WITH m.nrevmisc1
		               ENDIF
		               IF llRevMisc2
		                  SELECT wellinv
		                  REPLACE nrevmisc2 WITH m.nrevmisc2
		               ENDIF
		               IF llTaxPct
		                  SELECT wellinv
		                  REPLACE  ntaxpct  WITH m.ntaxpct
		               ENDIF
		               SELECT wellinv
		               REPLACE  dchanged WITH DATETIME(), ;
		                  cChangedBy WITH m.goapp.cUser
		            ELSE
		               m.CIDWINV  = GetNextPK('DOI')
		               m.dadded	  = DATETIME()
		               m.cAddedBy = m.goapp.cUser
		               INSERT INTO wellinv FROM MEMVAR
		            ENDIF
		         ENDSCAN
		         IF VARTYPE(oProgress) = 'O'
		            oProgress.closeprogress()
		         ENDIF    
		      OTHERWISE
		         llReturn = .F.
		   ENDCASE
		
		   IF llReturn
		      IF MESSAGEBOX('Should the net revenue interests be recalculated for working interest owners?', 36, 'Recalc NRI?') = 6
		         TABLEUPDATE(.T., .T., 'Wellinv')
		         THISFORM.RecalcNRI()
		      ENDIF
		
		      TABLEUPDATE(.T., .T., 'Wellinv')
		
		      lnCount = RECCOUNT('importfile')
		
		      IF llReturn
		         MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' interests to DOI.', 64, 'Import DOI')
		      ENDIF
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'HandleDOI', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handleexpcodes
		LOCAL llDuplicates, llReplace, loError, llReturn
		
		llReturn     = .T.
		llDuplicates = .F.
		llReplace    = .T.
		llContinue   = .T.
		
		TRY
		    swselect('expcat',.t.)
		    SET ORDER TO ccatcode
		    SET DELETED OFF
		    SELECT importfile
		    SCAN
		        m.cID1      = ALLTRIM(ccatcode)
		        m.cID2      = ''
		        m.cName     = ALLTRIM(ccateg)
		
		        IF NOT INLIST(ALLTRIM(importfile.cexpclass), '0', '1', '2', '3', '4', '5', 'A', 'B')
		            REPLACE cexpclass WITH '0'
		        ENDIF
		        
		        IF NOT INLIST(importfile.ctaxcode,'OE','ID','IC','TC','TD','LC')
		           replace ctaxcode WITH 'OE'
		        ENDIF 
		        
		        IF EMPTY(importfile.ccateg)
		           m.cOldID     = ccatcode
		            m.cOldName   = ccateg
		            m.cDesc      = 'Blank expense code name found.'
		            llContinue   = .f. 
		            llDuplicates = .f.
		            INSERT INTO badrecs FROM MEMVAR
		            LOOP
		        ENDIF
		
		        SELECT expcat
		        LOCATE FOR ccatcode = ALLTRIM(m.cID1)
		        IF FOUND()
		            IF DELETED()
		                REPLACE ccatcode WITH GetNextPK('BATCH')
		                REPLACE cidexpc WITH GetNextPK('BATCH')
		                LOOP
		            ENDIF
		            m.cOldID     = ccatcode
		            m.cOldName   = ccateg
		            m.cDesc      = 'Duplicate Expense Code found.'
		            llDuplicates = .T.
		            m.lContinue  = .T.
		            INSERT INTO badrecs FROM MEMVAR
		            LOOP
		        ENDIF
		    ENDSCAN
		    SET DELETED ON
		
		    IF RECCOUNT('badrecs') > 0
		        llReplace = THISFORM.ReportProbs('Importing Expense Codes', llContinue, llDuplicates)
		    ENDIF
		    
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		    
		
		    DO CASE
		       CASE NOT llContinue
		          llReturn = .F.
		       
		        CASE NOT llDuplicates
		            SELECT importfile
		            SCAN FOR NOT EMPTY(ccatcode)
		                SCATTER MEMVAR
		                m.cidexpc = GetNextPK('EXPCAT')
		                INSERT INTO expcat FROM MEMVAR
		            ENDSCAN
		
		        CASE llReplace
		            SELECT importfile
		            SCAN
		                SCATTER MEMVAR
		
		                SELECT expcat
		                IF SEEK(m.ccatcode)
		                    IF NOT EMPTY(m.ccateg)
		                        REPLACE ccateg WITH m.ccateg
		                    ENDIF
		                    IF NOT EMPTY(m.cDescrip)
		                        REPLACE cDescrip WITH m.cDescrip
		                    ENDIF
		                    IF NOT EMPTY(m.cexpclass)
		                        REPLACE cexpclass WITH m.cexpclass
		                    ENDIF
		                    IF NOT EMPTY(m.ctaxcode)
		                        replace ctaxcode WITH m.ctaxcode
		                    ENDIF 
		                ELSE
		                    SELECT importfile
		                    SCAN FOR NOT EMPTY(ccatcode)
		                        SCATTER MEMVAR
		                        m.cidexpc = GetNextPK('EXPCAT')
		                        INSERT INTO expcat FROM MEMVAR
		                    ENDSCAN
		                ENDIF
		            ENDSCAN
		        OTHERWISE
		            llReturn = .F.
		    ENDCASE
		    
		    TABLEUPDATE(.t.,.t.,'Expcat')
		
		    lnCount = RECCOUNT('importfile')
		
		    IF llReturn
		        MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' expense codes.', 64, 'Import Expense Codes')
		    ENDIF
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'HandleExpCodes', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handlegl
		LOCAL llDuplicates, llReplace, loError, llReturn
		LOCAL lcMessage, lnCount
		LOCAL cID1, cID2, cOldName, cName
		LOCAL lContinue, lcBatch, lcNewbatch, lcExpClear
		LOCAL cBatch, cDesc, cEntTime, cGLType, cOldID, cPeriod, cYear, dEntDate, oglmaint
		
		llReturn     = .T.
		llDuplicates = .F.
		llReplace    = .T.
		llContinue   = .T.
		
		TRY
		   swselect('gljourn', .T.)
		   swselect('coabal', .T.)
		   swselect('expense', .T.)
		   swselect('expsusp', .T.)
		   swselect('checks', .T.)
		   swselect('gljndet', .T.)
		   swselect('gldept')
		   swselect('glmaster', .T.)
		   SET ORDER TO glbatch
		   swselect('afehdr')
		   swselect('coa')
		   SET ORDER TO acctno
		   swselect('wells')
		   SET ORDER TO cwellid
		
		   swselect('glopt')
		   GO TOP
		   lcExpClear = glopt.cExpClear
		
		   SELECT importfile
		   SCAN
		      SCATTER MEMVAR 
		      m.cID1      = cacctno
		      m.cID2      = ''
		      m.cName     = cDesc
		      m.lContinue = .T.
		      m.cUnitno   = cUnitno
		
		      SELECT coa
		      IF NOT SEEK(m.cID1)
		         m.cOldID   = ''
		         m.cOldName = ''
		         m.cDesc    = 'Account Not found.'
		         llContinue = .F.
		         m.lContinue = .f. 
		         INSERT INTO badrecs FROM MEMVAR
		      ENDIF
		      
		      IF NOT EMPTY(m.cdeptno)
		         SELECT gldept
		         LOCATE FOR cdeptno = m.cdeptno
		         IF NOT FOUND()
		            m.coldID = ''
		            m.cOldName = ''
		            m.cDesc = 'Dept: ' + ALLTRIM(m.cdeptno) + ' Not Found'
		            llContinue = .f.
		            m.lContinue = .f.
		            INSERT INTO badrecs FROM MEMVAR 
		         ENDIF 
		      ENDIF    
		
		      IF NOT EMPTY(m.cUnitno)
		         m.cUnitNo = UPPER(m.cUnitNo)
		         m.cWellID = PADR(LEFT(ALLTRIM(m.cUnitNo),10),10,' ')
		         SELECT wells
		         LOCATE FOR (UPPER(cPropNo) = m.cUnitNo) OR ;
		               (UPPER(coilpurchno) = m.cUnitNo) OR ;
		               (UPPER(cgaspurchno) = m.cUnitNo) OR ;
		               (UPPER(cothpurchno) = m.cUnitNo) OR ;
		               (cwellid == m.cWellID)
		         IF NOT FOUND()
		            m.cOldID   = ''
		            m.cOldName = ''
		            m.cDesc    = 'Well: ' + ALLTRIM(m.cUnitno) + ' Not Found'
		            llContinue = .F.
		            m.lContinue = .f.
		            INSERT INTO badrecs FROM MEMVAR
		         ELSE
		            m.cWellID = cWellID   
		            SELECT importfile
		            REPLACE cUnitNo WITH m.cwellid
		         ENDIF
		      ENDIF
		      
		      IF NOT EMPTY(m.cAFENo)
		         m.cAFENo = UPPER(m.cAFENo)
		         m.cAFEno = PADR(LEFT(ALLTRIM(m.cAFENo),10),10,' ')
		         SELECT afehdr
		         LOCATE FOR cafeno = m.cAFENO
		         IF NOT FOUND()
		            m.cOldID   = ''
		            m.cOldName = ''
		            m.cDesc    = 'AFE No: ' + ALLTRIM(m.cAFENo) + ' Not Found'
		            llContinue = .F.
		            m.lContinue = .f.
		            INSERT INTO badrecs FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace = THISFORM.ReportProbs('Importing Journal Entries', llContinue, llDuplicates)
		   ENDIF
		   
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		   
		
		   IF llContinue
		
		      SELECT  cBatch,;
		              MAX(dgldate) as dgldate,;
		              MAX(cref) AS cGLRef,;
		              SUM(ndebits) AS ntotaldr,;
		              SUM(ncredits) AS ntotalcr ;
		          FROM importfile ;
		          INTO CURSOR tempbatch ;
		          ORDER BY cBatch ;
		          GROUP BY cBatch
		
		      SELECT gljourn
		      SCATTER MEMVAR BLANK
		      
		      SELECT tempbatch
		      SCAN
		         SCATTER MEMVAR
		         lnTotalDr  = m.ntotaldr
		         lnTotalCR  = m.ntotalcr
		         lcBatch    = cBatch
		         lcNewbatch = GetNextPK("BATCH")
		
		         m.ntotaldr = lnTotalDr
		         m.ntotalcr = lnTotalCR
		         m.cBatch   = lcNewbatch
		         m.cGLType  = 'GJ'
		         m.dEntDate = DATE()
		         m.cEntTime = TIME()
		         m.dgldate  = tempbatch.dgldate
		         m.cYear    = THISFORM.glmaint.getperiod(m.dgldate, .T.)
		         m.cPeriod  = THISFORM.glmaint.getperiod(m.dgldate, .F.)
		         INSERT INTO gljourn FROM MEMVAR
		
		         SELECT importfile
		         SCAN FOR cBatch == lcBatch
		            SCATTER MEMVAR
		            m.cBatch  = lcNewbatch
		            m.cidgljo = GetNextPK('GLJNDET')
		            INSERT INTO gljndet FROM MEMVAR
		         ENDSCAN
		
		         llReturn = THISFORM.PostGL(lcNewbatch)
		
		      ENDSCAN
		
		      TABLEUPDATE(.T., .T., 'Gljourn')
		      TABLEUPDATE(.T., .T., 'Gljndet')
		
		      lnCount = RECCOUNT('importfile')
		
		      IF llReturn
		         MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' entries.', 64, 'Import Journal')
		      ENDIF
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'HandleGL', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		
		   SET DELETED ON
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handleland		&& Imports land records
		LOCAL llDuplicates, llReplace, loError, llReturn
		LOCAL lcMessage, lnCount, llContinue
		LOCAL cOldName, cOldWell, cWellName, cwellid
		LOCAL cID1, cID2, cName, cOldID, cAddedBy, dadded
		
		llReturn     = .T.
		llDuplicates = .F.
		llReplace    = .t.
		llContinue   = .T.
		
		TRY
		   swselect('land', .T.)
		   SET ORDER TO cleaseid
		
		   SELECT importfile
		   SCAN
		      SCATTER MEMVAR MEMO
		      m.cID1        = cleaseid
		      m.cID2        = ''
		      m.cName       = cleasename
		      m.cLeaseGroup = cLeaseGroup
		      m.cprospect   = cprospect
		
		      SET DELETED OFF
		      SELECT land
		      IF SEEK(m.cID1)
		         IF DELETED()
		            REPLACE cleaseid WITH GetNextPK('BATCH')
		         ELSE
		            m.cOldID     = cleaseid
		            m.cOldName   = cleasename
		            m.cDesc      = 'Duplicate lease found.'
		            llDuplicates = .T.
		            m.lContinue  = .T.
		            INSERT INTO badrecs FROM MEMVAR
		         ENDIF
		
		         IF NOT EMPTY(m.cLeaseGroup)
		            m.cLeaseGroup = ALLTRIM(m.cLeaseGroup)
		            IF LEN(m.cLeaseGroup) < 2
		               m.cLeaseGroup = PADL(m.cLeaseGroup, 2, '0')
		               SELECT importfile
		               REPLACE cGroup WITH m.cLeaseGroup
		            ENDIF
		
		            swselect('groups')
		            LOCATE FOR cGroup = ALLTRIM(m.cLeaseGroup)
		            IF NOT FOUND()
		               m.cDesc = 'Group: ' + ALLTRIM(m.cLeaseGroup) + ' not found.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               INSERT INTO badrecs FROM MEMVAR
		            ELSE
		               SELECT importfile
		               REPLACE cGroup WITH m.cLeaseGroup
		            ENDIF
		         ELSE
		            SELECT importfile
		            REPLACE cLeaseGroup WITH '00'
		         ENDIF
		      ELSE
		         IF NOT EMPTY(m.cLeaseGroup)
		            m.cLeaseGroup = ALLTRIM(m.cLeaseGroup)
		            IF LEN(m.cLeaseGroup) < 2
		               m.cLeaseGroup = PADL(m.cLeaseGroup, 2, '0')
		            ENDIF
		
		            swselect('groups')
		            LOCATE FOR cGroup == m.cLeaseGroup
		            IF NOT FOUND()
		               m.cDesc = 'Group: ' + ALLTRIM(m.cLeaseGroup) + ' not found.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               INSERT INTO badrecs FROM MEMVAR
		            ELSE
		               SELECT importfile
		               REPLACE cGroup WITH m.cLeaseGroup
		            ENDIF
		         ELSE
		            SELECT importfile
		            REPLACE cGroup WITH '00'
		         ENDIF
		      ENDIF
		      SET DELETED ON
		   ENDSCAN
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace    = THISFORM.ReportProbs('Importing Leases', llContinue, llDuplicates)
		   ENDIF
		   
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		   
		
		   DO CASE
		      CASE NOT llContinue
		         llReturn = .F.
		
		      CASE NOT llDuplicates
		         m.dadded   = DATETIME()
		         m.cAddedBy = m.goApp.cUser
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cleaseid)
		            SCATTER MEMVAR
		            IF EMPTY(m.cleasestatus)
		               m.cleasestatus = 'Active'
		            ENDIF
		            IF EMPTY(m.cLeaseGroup)
		               m.cLeaseGroup = '00'
		            ENDIF
		            SELECT land
		            SET ORDER TO cleaseid
		            IF NOT SEEK(m.cleaseid)
		               INSERT INTO land FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		      CASE llReplace
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cleaseid)
		            SCATTER MEMVAR memo 
		            SET DELETED OFF
		            SELECT land
		            IF SEEK(m.cleaseid)
		               IF DELETED()
		                  RECALL
		               ENDIF
		               TRY
		                  IF NOT EMPTY(m.cleasename)
		                     REPLACE cleasename WITH m.cleasename
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cCounty)
		                     REPLACE cCounty WITH m.cCounty
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cstate)
		                     REPLACE cstate  WITH m.cstate
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cLeaseGroup)
		                     REPLACE cLeaseGroup  WITH m.cLeaseGroup
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cleasestatus)
		                     REPLACE cleasestatus WITH m.cleasestatus
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.drecdate)
		                     REPLACE drecdate WITH m.drecdate
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cRecBook)
		                     REPLACE cRecBook WITH m.cRecBook
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.crecpage)
		                     REPLACE crecpage WITH m.crecpage
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cpaymentfreq)
		                     REPLACE cpaymentfreq WITH m.cpaymentfreq
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cinstrument)
		                     REPLACE cinstrument WITH m.cinstrument
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.ccomingle)
		                     REPLACE ccomingle WITH m.ccomingle
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.crrcleaseno)
		                     REPLACE crrcleaseno WITH m.crrcleaseno
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.crrcdistno)
		                     REPLACE crrcdistno WITH m.crrcdistno
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.ctownship)
		                     REPLACE ctownship WITH m.ctownship
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cagent)
		                     REPLACE cagent WITH m.cagent
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.dexpires)
		                     REPLACE dexpires WITH m.dexpires
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.dpmtstart)
		                     REPLACE dpmtstart WITH m.dpmtstart
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cpartner)
		                     REPLACE cpartner WITH m.cpartner
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.npartpct)
		                     REPLACE npartpct WITH m.npartpct
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cacquired)
		                     REPLACE cacquired WITH m.cacquired
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.dacquired)
		                     REPLACE dacquired WITH m.dacquired
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cdeptno)
		                     REPLACE cdeptno WITH m.cdeptno
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cacctno)
		                     REPLACE cacctno WITH m.cacctno
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.csurfowner)
		                     REPLACE csurfowner WITH m.csurfowner
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.coriglessor)
		                     REPLACE coriglessor WITH m.coriglessor
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cprimadd)
		                     REPLACE cprimadd WITH m.cprimadd
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cmailadd)
		                     REPLACE cmailadd WITH m.cmailadd
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mParcel)
		                     REPLACE mParcel WITH m.mParcel
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cLatitude)
		                     REPLACE cLatitude WITH m.cLatitude
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cLongitude)
		                     REPLACE cLongitude WITH m.cLongitude
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.cunique)
		                     REPLACE cunique WITH m.cunique
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mdescription)
		                     REPLACE mdescription WITH m.mdescription
		                  ENDIF
		               CATCH
		               ENDTRY
		                TRY
		                  IF NOT EMPTY(m.cconsoleref)
		                     REPLACE cconsoleref WITH m.cconsoleref
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.dconsoldate)
		                     REPLACE dconsoldate WITH m.dconsoldate
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mRenewal)
		                     REPLACE mRenewal WITH ALLTRIM(m.mRenewal) + CHR(13) + ALLTRIM(mRenewal), ;
		                        lRenewal WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mpoolnotes)
		                     REPLACE mpoolnotes WITH ALLTRIM(m.mpoolnotes) + CHR(10) + ALLTRIM(mpoolnotes), ;
		                        lpooling WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mdepthnotes)
		                     REPLACE mdepthnotes WITH ALLTRIM(m.mdepthnotes) + CHR(10) + ALLTRIM(mdepthnotes), ;
		                        ldepthrestrict WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mshutnotes)
		                     REPLACE mshutnotes WITH ALLTRIM(m.mshutnotes) + CHR(10) + ALLTRIM(mshutnotes), ;
		                        lshutin WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.morrinotes)
		                     REPLACE morrinotes WITH ALLTRIM(m.morrinotes) + CHR(10) + ALLTRIM(morrinotes), ;
		                        lorri WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mfreegas)
		                     REPLACE mfreegas WITH ALLTRIM(m.mfreegas) + CHR(10) + ALLTRIM(mfreegas), ;
		                        lfreegas WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mcontinuous)
		                     REPLACE mcontinuous WITH ALLTRIM(m.mcontinuous) + CHR(10) + ALLTRIM(mcontinuous), ;
		                        lcontinuous WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.munitization)
		                     REPLACE munitization WITH ALLTRIM(m.munitization) + CHR(10) + ALLTRIM(munitization), ;
		                        lunitization WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.mloapprove)
		                     REPLACE mloapprove WITH ALLTRIM(m.mloapprove) + CHR(10) + ALLTRIM(mloapprove), ;
		                        lloapprove WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               TRY
		                  IF NOT EMPTY(m.massignment)
		                     REPLACE massignment WITH ALLTRIM(m.massignment) + CHR(10) + ALLTRIM(massignment), ;
		                        lassignment WITH .T.
		                  ENDIF
		               CATCH
		               ENDTRY
		               SET DELETED ON
		            ELSE
		               m.dadded   = DATETIME()
		               m.cAddedBy = m.goApp.cUser
		               IF NOT EMPTY(m.cwellid)
		                  SELECT land
		                  SET ORDER TO cleaseid
		                  IF NOT SEEK(m.cleaseid)
		                     INSERT INTO land FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDSCAN
		      OTHERWISE
		         llReturn = .F.
		   ENDCASE
		
		   lnCount = RECCOUNT('importfile')
		
		   IF llReturn
		      TABLEUPDATE(.T., .T., 'land')
		      MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' leases.', 64, 'Import Leases')
		   ELSE
		      TABLEREVERT(.T., 'land')
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'HandleLand', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		   SET DELETED ON
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handlemeters		&& Import Master Meters
		LOCAL llDuplicates, llReplace, loError, llReturn
		
		llReturn     = .T.
		llDuplicates = .F.
		llReplace    = .T.
		llContinue   = .T.
		
		TRY
		    swselect('meters',.t.)
		    SET ORDER TO meterid
		    SET DELETED OFF
		    SELECT importfile
		    SCAN
		        m.cID1      = PADR(ALLTRIM(cmeterid),15,' ')
		        m.cID2      = ''
		        m.cName     = ALLTRIM(cmeterdesc)
		
		        IF EMPTY(importfile.cmeterdesc)
		           m.cOldID     = cmeterid
		            m.cOldName   = cmeterdesc
		            m.cDesc      = 'Blank meter description found.'
		            llContinue   = .f. 
		            llDuplicates = .f.
		            INSERT INTO badrecs FROM MEMVAR
		            LOOP
		        ENDIF
		
		        SELECT meters
		        LOCATE FOR cmeterid == m.cID1
		        IF FOUND()
		            IF DELETED()
		                REPLACE cmeterid WITH GetNextPK('BATCH')
		                LOOP
		            ENDIF
		            m.cOldID     = cmeterid
		            m.cOldName   = cmeterdesc
		            m.cDesc      = 'Duplicate Meter found.'
		            llDuplicates = .T.
		            m.lContinue  = .T.
		            INSERT INTO badrecs FROM MEMVAR
		            LOOP
		        ENDIF
		    ENDSCAN
		    SET DELETED ON
		
		    IF RECCOUNT('badrecs') > 0
		        llReplace = THISFORM.ReportProbs('Importing Master Meters Codes', llContinue, llDuplicates)
		    ENDIF
		    
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		
		    DO CASE
		       CASE NOT llContinue
		          llReturn = .F.
		       
		        CASE NOT llDuplicates
		            SELECT importfile
		            SCAN FOR NOT EMPTY(cmeterid)
		                SCATTER MEMVAR
		                INSERT INTO meters FROM MEMVAR
		            ENDSCAN
		
		        CASE llReplace
		            SELECT importfile
		            SCAN
		                SCATTER MEMVAR
		
		                SELECT meters
		                IF SEEK(m.cmeterid)
		                    IF NOT EMPTY(m.cmeterdesc)
		                       REPLACE cmeterdesc WITH m.cmeterdesc
		                    ENDIF
		                    IF NOT EMPTY(m.cmeterserialno)
		                       REPLACE cmeterserialno WITH m.cmeterserialno
		                    ENDIF
		                    IF NOT EMPTY(m.cmeterloc)
		                       REPLACE cmeterloc WITH m.cmeterloc
		                    ENDIF
		                    IF NOT EMPTY(m.cmetercity)
		                       REPLACE cmetercity WITH m.cmetercity
		                    ENDIF
		                    IF NOT EMPTY(m.cmeterstate)
		                       REPLACE cmeterstate WITH m.cmeterstate
		                    ENDIF
		                    IF NOT EMPTY(m.cmeterzip)
		                       REPLACE cmeterzip WITH m.cmeterzip
		                    ENDIF
		                ELSE
		                    SELECT importfile
		                    IF NOT EMPTY(cmeterid)
		                       SCATTER MEMVAR
		                       INSERT INTO meters FROM MEMVAR
		                    ENDIF 
		                ENDIF
		            ENDSCAN
		        OTHERWISE
		            llReturn = .F.
		    ENDCASE
		    
		    TABLEUPDATE(.t.,.t.,'meters')
		
		    lnCount = RECCOUNT('importfile')
		
		    IF llReturn
		        MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' Master Meters.', 64, 'Import Master Meters')
		    ENDIF
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'HandleMeters', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handleobligations		&& Imports Lease Obligations
	ENDPROC

	PROCEDURE handleowners
		LOCAL llDuplicates, llReplace, loError, llReturn
		LOCAL lcMessage, lnCount
		LOCAL cOldName, cOldOwner, cOwnName, cownerid
		
		llReturn	 = .T.
		llDuplicates = .F.
		llReplace	 = .T.
		llContinue	 = .T.
		
		TRY
		   swselect('investor', .T.)
		   SET ORDER TO cownerid
		   SET DELETED OFF
		   SELECT importfile
		   SCAN
		      m.cID1	  = cownerid
		      m.cID2	  = ''
		      m.cName	  = cOwnName
		      m.lContinue = .T.
		
		      SELECT investor
		      IF SEEK(m.cID1)
		         IF DELETED()
		            REPLACE cownerid WITH GetNextPK('BATCH')
		            LOOP
		         ENDIF
		         m.cOldID	  = cownerid
		         m.cOldName	  = cOwnName
		         m.cDesc	  = 'Duplicate Owner found.'
		         llDuplicates = .T.
		         m.lContinue  = .T.
		         INSERT INTO badrecs FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   SET DELETED ON
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace = THISFORM.ReportProbs('Importing Owners', llContinue, llDuplicates)
		   ENDIF
		   
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		
		   DO CASE
		      CASE NOT llContinue
		         llReturn = .F.
		
		      CASE NOT llDuplicates
		         m.dadded	= DATETIME()
		         m.cAddedBy	= m.goApp.cUser
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cownerid)
		            SCATTER MEMVAR
		            m.cTaxid = cmEncrypt(importfile.ctaxid, m.goapp.cEncryptionKey)
		            m.cBankAcct = cmEncrypt((importfile.cBankAcct), m.goapp.cEncryptionKey)
		            m.cBankTransit = cmEncrypt((importfile.cbanktransit), m.goapp.cEncryptionKey)
		            IF m.nDisbFreq = 0
		               m.nDisbFreq = 1
		            ENDIF
		            SELECT investor
		            SET ORDER TO cownerid
		            IF NOT SEEK(m.cownerid)
		               INSERT INTO investor FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		      CASE llReplace
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cownerid)
		            SCATTER MEMVAR
		            SELECT investor
		            IF SEEK(m.cownerid)
		               IF NOT EMPTY(m.cOwnName)
		                  REPLACE cOwnName WITH m.cOwnName
		               ENDIF
		               IF NOT EMPTY(m.caddress1a)
		                  REPLACE caddress1a WITH ALLTRIM(m.caddress1a)
		               ENDIF
		               IF NOT EMPTY(m.caddress1b)
		                  REPLACE caddress1b WITH ALLTRIM(m.caddress1b)
		               ENDIF
		               IF NOT EMPTY(m.caddress2a)
		                  REPLACE caddress2a WITH ALLTRIM(m.caddress2a)
		               ENDIF
		               IF NOT EMPTY(m.caddress2b)
		                  REPLACE caddress2b WITH ALLTRIM(m.caddress2b)
		               ENDIF
		               IF NOT EMPTY(m.cCity1)
		                  REPLACE cCity1 WITH ALLTRIM(m.cCity1)
		               ENDIF
		               IF NOT EMPTY(m.cCity2)
		                  REPLACE cCity2 WITH ALLTRIM(m.cCity2)
		               ENDIF
		               IF NOT EMPTY(m.cstate1)
		                  REPLACE cstate1 WITH ALLTRIM(m.cstate1)
		               ENDIF
		               IF NOT EMPTY(m.cstate2)
		                  REPLACE cstate2 WITH ALLTRIM(m.cstate2)
		               ENDIF
		               IF NOT EMPTY(m.cZip1)
		                  REPLACE cZip1 WITH ALLTRIM(m.cZip1)
		               ENDIF
		               IF NOT EMPTY(m.cZip2)
		                  REPLACE cZip2 WITH ALLTRIM(m.cZip2)
		               ENDIF
		               IF NOT EMPTY(m.cSortField)
		                  REPLACE cSortField WITH ALLTRIM(m.cSortField)
		               ENDIF
		               IF NOT EMPTY(m.cOwnname1)
		                  REPLACE cOwnname1 WITH m.cOwnname1
		               ENDIF
		               IF NOT EMPTY(m.cphoneh)
		                  REPLACE cphoneh WITH m.cphoneh
		               ENDIF
		               IF NOT EMPTY(m.cphonew)
		                  REPLACE cphonew WITH m.cphonew
		               ENDIF
		               IF NOT EMPTY(m.cphonecell)
		                  REPLACE cphonecell WITH m.cphonecell
		               ENDIF
		               IF NOT EMPTY(m.ctaxid)
		                  REPLACE ctaxid WITH cmEncrypt((importfile.ctaxid), m.goapp.cEncryptionKey)
		               ENDIF
		               IF NOT EMPTY(m.cemail)
		                  REPLACE cemail WITH m.cemail
		               ENDIF
		              
		               SELECT mappedfields
		               LOCATE FOR cName = 'cinvmin'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE nInvMin WITH m.nInvMin
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'ctaxidtype'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE itaxidtype WITH m.itaxidtype
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cdisbfreq'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE nDisbFreq WITH m.nDisbFreq
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cinv1099'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE linv1099 WITH m.linv1099
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'chold'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE lhold WITH m.lhold
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cprtdef'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE lprtdef WITH m.lprtdef
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cdummy'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE ldummy WITH m.ldummy
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cexempt'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE lexempt WITH m.lexempt
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'conlinerpts'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE lonlinerpts WITH m.lonlinerpts
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cdirectdep'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE ldirectdep WITH m.ldirectdep
		               ENDIF
		               IF NOT EMPTY(m.cbankname)
		                  REPLACE cbankname WITH m.cbankname
		               ENDIF
		               IF NOT EMPTY(m.cbankacct)
		                  REPLACE cbankacct WITH cmEncrypt((importfile.cbankacct), m.goapp.cEncryptionKey)
		               ENDIF
		               IF NOT EMPTY(m.cbanktransit)
		                  REPLACE cbanktransit WITH cmEncrypt((importfile.cbanktransit), m.goapp.cEncryptionKey)
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cbackpct'
		               IF FOUND()
		                  SELECT investor
		                  IF m.nbackpct # 0
		                     REPLACE nbackpct WITH m.nbackpct, ;
		                        lbackwith WITH .T.
		                  ELSE
		                     REPLACE nbackpct WITH m.nbackpct, ;
		                        lbackwith WITH .f.
		                  ENDIF       
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cwellpage'
		               IF FOUND()
		                  SELECT investor
		                  REPLACE lwellpage WITH m.lwellpage
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cnotes'
		               IF FOUND()
		                  SELECT investor
		                  IF NOT EMPTY(mNotes)
		                     REPLACE mNotes WITH ALLTRIM(m.mNotes) + CHR(10) + ALLTRIM(mNotes)
		                  ENDIF
		               ENDIF    
		               SELECT investor
		               REPLACE dChanged WITH DATE(), cChangedBy WITH m.goApp.cUser
		            ELSE
		               m.dadded	  = DATE()
		               m.cAddedBy = m.goApp.cUser
		               IF NOT EMPTY(m.cownerid)
		                  SELECT investor
		                  SET ORDER TO cownerid
		                  IF NOT SEEK(m.cownerid)
		                     INSERT INTO investor FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDSCAN
		      OTHERWISE
		         llReturn = .F.
		   ENDCASE
		
		   THISFORM.FixSortField('OWNERS')
		
		   TABLEUPDATE(.T., .T., 'Investor')
		
		   lnCount = RECCOUNT('importfile')
		
		   IF llReturn
		      MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' owners.', 64, 'Import Owners')
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'HandleOwners', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		
		   SET DELETED ON
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handlepumpers
		LOCAL llDuplicates, llReplace, loError, llReturn
		
		llReturn     = .T.
		llDuplicates = .F.
		llReplace    = .T.
		llContinue   = .T.
		
		TRY
		    swselect('pumpers',.t.)
		    SET ORDER TO cname
		    SET DELETED OFF
		    SELECT importfile
		    SCAN
		        m.cID1      = PADR(ALLTRIM(cidpumper),15,' ')
		        m.cID2      = ''
		        m.cPumperName     = ALLTRIM(cpumpername)
		
		        IF EMPTY(importfile.cpumpername)
		            m.cOldID     = cidpumper
		            m.cOldName   = cpumpername
		            m.cDesc      = 'Blank pumper name found.'
		            llContinue   = .f. 
		            llDuplicates = .f.
		            INSERT INTO badrecs FROM MEMVAR
		            LOOP
		        ENDIF
		
		        SELECT pumpers
		        LOCATE FOR cpumpername == m.cPumperName
		        IF FOUND()
		            m.cOldID     = cmeterid
		            m.cOldName   = cmeterdesc
		            m.cDesc      = 'Duplicate Pumper found.'
		            llDuplicates = .T.
		            m.lContinue  = .T.
		            INSERT INTO badrecs FROM MEMVAR
		            LOOP
		        ENDIF
		    ENDSCAN
		    SET DELETED ON
		
		    IF RECCOUNT('badrecs') > 0
		        llReplace = THISFORM.ReportProbs('Importing Pumpers', llContinue, llDuplicates)
		    ENDIF
		    
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		
		    DO CASE
		       CASE NOT llContinue
		          llReturn = .F.
		       
		        CASE NOT llDuplicates
		            SELECT importfile
		            SCAN FOR NOT EMPTY(cpumpername)
		                SCATTER MEMVAR
		                INSERT INTO pumpers FROM MEMVAR
		            ENDSCAN
		
		        CASE llReplace
		            SELECT importfile
		            SCAN FOR NOT EMPTY(cPumperName)
		                SCATTER MEMVAR
		
		                SELECT pumpers
		                IF SEEK(m.cpumpername)
		                    IF NOT EMPTY(m.caddress1)
		                       REPLACE caddress1 WITH m.caddress1
		                    ENDIF
		                    IF NOT EMPTY(m.ccity)
		                       REPLACE ccity WITH m.ccity
		                    ENDIF
		                    IF NOT EMPTY(m.cstate)
		                       REPLACE cstate WITH m.cstate
		                    ENDIF
		                    IF NOT EMPTY(m.czip)
		                       REPLACE czip WITH m.czip
		                    ENDIF
		                    IF NOT EMPTY(m.cemail)
		                       replace cemail WITH m.cemail
		                    ENDIF 
		                ELSE
		                    SELECT importfile
		                    SCATTER MEMVAR
		                    INSERT INTO pumpers FROM MEMVAR
		                ENDIF
		            ENDSCAN
		        OTHERWISE
		            llReturn = .F.
		    ENDCASE
		    
		    TABLEUPDATE(.t.,.t.,'pumpers')
		
		    lnCount = RECCOUNT('importfile')
		
		    IF llReturn
		        MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' Pumpers.', 64, 'Import Pumpers')
		    ENDIF
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'HandlePumpers', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handlepurchasers
		LOCAL llDuplicates, llReplace, loError, llReturn
		
		llReturn	 = .T.
		llDuplicates = .F.
		llReplace	 = .t.
		llContinue	 = .T.
		
		TRY
		   swselect('revsrc', .T.)
		   SET ORDER TO crevkey
		   SET DELETED OFF
		   SELECT importfile
		   SCAN
		      m.cid1	  = UPPER(ALLTRIM(crevkey))
		      m.cID2	  = ''
		      m.cname	  = ALLTRIM(crevname)
		      m.lContinue = .T.
		
		      SELECT revsrc
		      LOCATE FOR crevkey = ALLTRIM(m.cid1)
		      IF FOUND()
		         IF DELETED()
		            REPLACE crevkey WITH GetNextPK('BATCH')
		            LOOP
		         ENDIF
		         m.cOldID	  = crevkey
		         m.cOldName	  = crevname
		         m.cDesc	  = 'Duplicate Purchaser found.'
		         llDuplicates = .T.
		         m.lContinue  = .T.
		         INSERT INTO badrecs FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   SET DELETED ON
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace = THISFORM.ReportProbs('Importing Purchasers', llContinue, llDuplicates)
		   ENDIF
		   
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		
		   DO CASE
		      CASE NOT llContinue
		         llReturn = .F.
		
		      CASE NOT llDuplicates
		         SELECT importfile
		         SCAN FOR NOT EMPTY(crevkey)
		            SCATTER MEMVAR MEMO
		            SELECT revsrc
		            SET ORDER TO crevkey
		            IF NOT SEEK(m.crevkey)
		               INSERT INTO revsrc FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		      CASE llReplace
		         SELECT importfile
		         SCAN
		            SCATTER MEMVAR
		            SELECT revsrc
		            IF SEEK(m.crevkey)
		               IF NOT EMPTY(m.crevname)
		                  REPLACE crevname WITH m.crevname
		               ENDIF
		               IF NOT EMPTY(m.cAddress1)
		                  REPLACE cAddress1 WITH m.cAddress1
		               ENDIF
		               IF NOT EMPTY(m.cAddress2)
		                  REPLACE cAddress1 WITH m.cAddress2
		               ENDIF
		               IF NOT EMPTY(m.cAddress3)
		                  REPLACE cAddress1 WITH m.cAddress3
		               ENDIF
		               IF NOT EMPTY(m.cphone)
		                  REPLACE cphone WITH m.cphone
		               ENDIF
		               IF NOT EMPTY(m.cfaxphone)
		                  REPLACE cfaxphone WITH m.cfaxphone
		               ENDIF
		            ELSE
		               SELECT importfile
		               SCAN FOR NOT EMPTY(crevkey)
		                  SCATTER MEMVAR MEMO
		                  SELECT revsrc
		                  SET ORDER TO crevkey
		                  IF NOT SEEK(m.crevkey)
		                     INSERT INTO revsrc FROM MEMVAR
		                  ENDIF
		               ENDSCAN
		            ENDIF
		         ENDSCAN
		      OTHERWISE
		         llReturn = .F.
		   ENDCASE
		
		   TABLEUPDATE(.T., .T., 'Revsrc')
		
		   lnCount = RECCOUNT('importfile')
		
		   IF llReturn
		      MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' purchasers.', 64, 'Import Purchasers')
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'HandlePurchasers', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handlevends
		LOCAL llDuplicates, llReplace, loError, llReturn
		LOCAL lcMessage, lnCount
		LOCAL cOldName, cOldVend, cVendName, cVendorID
		
		llReturn	 = .T.
		llDuplicates = .F.
		llReplace	 = .T.
		llContinue	 = .T.
		
		TRY
		   swselect('vendor', .T.)
		   SELECT vendor
		   SET ORDER TO cVendorID
		   SET DELETED OFF
		
		   SELECT importfile
		   SCAN
		      m.cID1  = cVendorID
		      m.cID2  = ''
		      m.cName = cVendName
		      SELECT vendor
		      IF SEEK(m.cID1)
		         IF DELETED()
		            REPLACE cVendorID WITH GetNextPK('BATCH')
		            LOOP
		         ENDIF
		         m.cOldID	  = cVendorID
		         m.cOldName	  = cVendName
		         m.cDesc	  = 'Duplicate vendor found.'
		         llDuplicates = .T.
		         m.lContinue  = .T.
		         INSERT INTO badrecs FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   SET DELETED ON
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace = THISFORM.ReportProbs('Importing Vendors', llContinue, llDuplicates)
		   ENDIF
		
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		   
		
		   DO CASE
		      CASE NOT llContinue
		         llReturn = .F.
		
		      CASE NOT llDuplicates
		         m.dadded	= DATETIME()
		         m.cAddedBy	= m.goApp.cUser
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cVendorID)
		            SCATTER MEMVAR MEMO
		            m.ctaxid = cmEncrypt(alltrim(importfile.ctaxid), m.goapp.cEncryptionKey)
		            SELECT vendor
		            SET ORDER TO cVendorID
		            IF NOT SEEK(m.cVendorID)
		               INSERT INTO vendor FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		      CASE llReplace
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cVendorID)
		            SCATTER MEMVAR MEMO
		            SET DELETED OFF
		            SELECT vendor
		            IF SEEK(m.cVendorID)
		               IF DELETED()
		                  RECALL
		               ENDIF
		               IF NOT EMPTY(m.cVendName)
		                  REPLACE cVendName WITH m.cVendName
		               ENDIF
		               IF NOT EMPTY(m.cAddress1)
		                  REPLACE cAddress1 WITH m.cAddress1
		               ENDIF
		               IF NOT EMPTY(m.cAddress2)
		                  REPLACE cAddress2 WITH m.cAddress2
		               ENDIF
		               IF NOT EMPTY(m.cCity)
		                  REPLACE cCity  WITH m.cCity
		               ENDIF
		               IF NOT EMPTY(m.cState)
		                  REPLACE cState WITH m.cState
		               ENDIF
		               IF NOT EMPTY(m.czip)
		                  REPLACE czip WITH m.czip
		               ENDIF
		               IF NOT EMPTY(m.cphone)
		                  REPLACE cphone WITH m.cphone
		               ENDIF
		               IF NOT EMPTY(m.cFaxPhone)
		                  REPLACE cFaxPhone WITH m.cFaxPhone
		               ENDIF
		               IF NOT EMPTY(m.ccontact)
		                  REPLACE ccontact WITH m.ccontact
		               ENDIF
		               IF NOT EMPTY(m.cbaddr1)
		                  REPLACE cbaddr1 WITH m.cbaddr1
		               ENDIF
		               IF NOT EMPTY(m.cbaddr2)
		                  REPLACE cbaddr2 WITH m.cbaddr2
		               ENDIF
		               IF NOT EMPTY(m.cbCity)
		                  REPLACE cbCity WITH m.cbCity
		               ENDIF
		               IF NOT EMPTY(m.cbState)
		                  REPLACE cbState WITH m.cbState
		               ENDIF
		               IF NOT EMPTY(m.cbZip)
		                  REPLACE cbZip WITH m.cbZip
		               ENDIF
		               IF NOT EMPTY(m.cbphone)
		                  REPLACE cbphone WITH m.cbphone
		               ENDIF
		               IF NOT EMPTY(m.cbfaxphone)
		                  REPLACE cbfaxphone WITH m.cbfaxphone
		               ENDIF
		               IF NOT EMPTY(m.cbcontact)
		                  REPLACE cbcontact WITH m.cbcontact
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'csend1099'
		               IF FOUND()
		                  SELECT vendor
		                  REPLACE lSend1099 WITH m.lSend1099
		               ENDIF
		               IF NOT EMPTY(m.cTaxid)
		                  REPLACE cTaxid WITH cmEncrypt(alltrim(importfile.ctaxid), m.goapp.cEncryptionKey)
		               ENDIF
		               IF NOT EMPTY(m.cSortField)
		                  REPLACE cSortField WITH m.cSortField
		               ENDIF
		               IF NOT EMPTY(m.mvendnote)
		                  REPLACE mvendnote WITH m.mvendnote + CHR(10) + mvendnote
		               ENDIF
		               SET DELETED ON
		            ELSE
		               m.dadded	  = DATETIME()
		               m.cAddedBy = m.goApp.cUser
		               SELECT vendor
		               SET ORDER TO cVendorID
		               IF NOT SEEK(m.cVendorID)
		                  INSERT INTO vendor FROM MEMVAR
		               ENDIF
		            ENDIF
		         ENDSCAN
		      OTHERWISE
		         llReturn = .F.
		   ENDCASE
		
		   SELECT vendor
		   REPLACE cSortField WITH cVendName FOR EMPTY(cSortField)
		
		   THISFORM.FixSortField('VENDORS')
		
		   TABLEUPDATE(.T., .T., 'Vendor')
		
		   lnCount = RECCOUNT('importfile')
		
		   IF llReturn
		      MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' vendors.', 64, 'Import Vendor')
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Handlevends', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		
		   SET DELETED ON
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE handlewells
		LOCAL llDuplicates, llReplace, loError, llReturn
		LOCAL lcMessage, lnCount, llContinue
		LOCAL cOldName, cOldWell, cWellName, cwellid
		LOCAL cID1, cID2, cName, cOldID, cAddedBy, dadded
		
		llReturn	 = .T.
		llDuplicates = .F.
		llReplace	 = .T.
		llContinue	 = .T.
		
		TRY
		   swselect('wells', .T.)
		   SET ORDER TO cwellid
		
		   swselect('groups')
		
		   SELECT importfile
		   SCAN
		      m.cID1	  = cwellid
		      m.cID2	  = ''
		      m.cName	  = cWellName
		      m.cGroup	  = cGroup
		      m.cTable	  = cTable
		      m.cwellstat = cwellstat
		      m.cpumper   = cpumper
		      SET DELETED OFF
		      SELECT wells
		      IF SEEK(m.cID1)
		         IF DELETED()
		            REPLACE cwellid WITH GetNextPK('BATCH')
		         ELSE
		            m.cOldID	 = cwellid
		            m.cOldName	 = cWellName
		            m.cDesc		 = 'Duplicate well found.'
		            llDuplicates = .T.
		            m.lContinue  = .T.
		            INSERT INTO badrecs FROM MEMVAR
		         ENDIF
		         
		         IF NOT EMPTY(m.cpumper)
		            m.cPumper = ALLTRIM(m.cPumper)
		            swselect('pumpers')
		            LOCATE FOR UPPER(cPumperName) = UPPER(ALLTRIM(m.cPumper))
		            IF NOT FOUND()
		               m.cDesc = 'Pumper: ' + ALLTRIM(m.cPumper) + ' not found.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               m.lContinue = .f.
		               INSERT INTO badrecs FROM MEMVAR
		            ELSE
		               SELECT importfile
		               REPLACE cidpumper WITH pumpers.cidpumper
		            ENDIF
		         ENDIF
		
		         IF NOT EMPTY(m.cGroup)
		            m.cGroup = ALLTRIM(m.cGroup)
		            IF LEN(m.cGroup) < 2
		               m.cGroup = PADL(m.cGroup, 2, '0')
		               SELECT importfile
		               REPLACE cGroup WITH m.cGroup
		            ENDIF
		               
		            swselect('groups')
		            LOCATE FOR cGroup = ALLTRIM(m.cGroup)
		            IF NOT FOUND()
		               m.cDesc = 'Group: ' + ALLTRIM(m.cGroup) + ' not found.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               m.lContinue = .f.
		               INSERT INTO badrecs FROM MEMVAR
		            ELSE
		               SELECT importfile
		               REPLACE cGroup WITH m.cGroup
		            ENDIF
		         ELSE
		            SELECT importfile
		            REPLACE cGroup WITH '00'
		         ENDIF
		         IF NOT EMPTY(m.cTable)
		            swselect('sevtax')
		            LOCATE FOR cTable = ALLTRIM(m.cTable)
		            IF NOT FOUND()
		               m.cDesc = 'Tax Table: ' + ALLTRIM(m.cTable) + ' not found.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               m.lContinue = .f.
		               INSERT INTO badrecs FROM MEMVAR
		            ENDIF
		         ENDIF
		         IF NOT EMPTY(m.cwellstat)
		            IF NOT INLIST(m.cwellstat, 'A', 'I', 'T', 'P', 'S', 'D', 'V', 'N')
		               m.cDesc = 'Invalid Status: ' + ALLTRIM(m.cwellstat) + ' not valid.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               m.lContinue = .f.
		               INSERT INTO badrecs FROM MEMVAR
		            ENDIF
		         ENDIF
		      ELSE
		         IF NOT EMPTY(m.cpumper)
		            m.cPumper = ALLTRIM(m.cPumper)
		            swselect('pumpers')
		            LOCATE FOR UPPER(cPumperName) = UPPER(ALLTRIM(m.cPumper))
		            IF NOT FOUND()
		               m.cDesc = 'Pumper: ' + ALLTRIM(m.cPumper) + ' not found.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               m.lContinue = .f.
		               INSERT INTO badrecs FROM MEMVAR
		            ELSE
		               SELECT importfile
		               REPLACE cidpumper WITH pumpers.cidpumper
		            ENDIF
		         ENDIF
		
		         IF NOT EMPTY(m.cGroup)
		            m.cGroup = ALLTRIM(m.cGroup)
		            IF LEN(m.cGroup) < 2
		               m.cGroup = PADL(m.cGroup, 2, '0')
		            ENDIF
		
		            swselect('groups')
		            LOCATE FOR cGroup == m.cgroup
		            IF NOT FOUND()
		               m.cDesc = 'Group: ' + ALLTRIM(m.cGroup) + ' not found.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               m.lContinue = .f.
		               INSERT INTO badrecs FROM MEMVAR
		            ELSE
		               SELECT importfile
		               REPLACE cGroup WITH m.cGroup
		            ENDIF
		         ELSE
		            SELECT importfile
		            REPLACE cGroup WITH '00'
		         ENDIF
		         IF NOT EMPTY(m.cTable)
		            swselect('sevtax')
		            LOCATE FOR cTable = ALLTRIM(m.cTable)
		            IF NOT FOUND()
		               m.cDesc = 'Tax Table: ' + ALLTRIM(m.cTable) + ' not found.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               m.lContinue = .f.
		               INSERT INTO badrecs FROM MEMVAR
		            ENDIF
		         ENDIF
		         IF NOT EMPTY(m.cwellstat)
		            IF NOT INLIST(m.cwellstat, 'A', 'I', 'T', 'P', 'S', 'D', 'V', 'N')
		               m.cDesc = 'Invalid Status: ' + ALLTRIM(m.cwellstat) + ' not valid.'
		               STORE '' TO m.cOldID, m.cOldName
		               llContinue = .F.
		               m.lContinue = .f.
		               INSERT INTO badrecs FROM MEMVAR
		            ENDIF
		         ENDIF
		      ENDIF
		      SET DELETED ON
		   ENDSCAN
		
		   IF RECCOUNT('badrecs') > 0
		      llReplace    = THISFORM.ReportProbs('Importing Wells', llContinue, llDuplicates)
		   ENDIF
		   
		   IF llContinue AND NOT llReplace
		      IF MESSAGEBOX("Do you want to continue with the import?",36,thisform.Caption) = 7
		         llReturn = .F.
		         EXIT 
		      ENDIF 
		   ENDIF 
		
		   DO CASE
		      CASE NOT llContinue
		         llReturn = .F.
		
		      CASE NOT llDuplicates
		         m.dadded	= DATETIME()
		         m.cAddedBy	= m.goApp.cUser
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cwellid)
		            SCATTER MEMVAR
		            IF EMPTY(m.cwellstat)
		               m.cwellstat = 'A'
		            ENDIF
		            IF EMPTY(m.cGroup)
		               m.cGroup = '00'
		            ENDIF
		            SELECT wells
		            SET ORDER TO cwellid
		            IF NOT SEEK(m.cwellid)
		               INSERT INTO wells FROM MEMVAR
		            ENDIF
		         ENDSCAN
		
		      CASE llReplace
		         SELECT importfile
		         SCAN FOR NOT EMPTY(cwellid)
		            SCATTER MEMVAR
		            SET DELETED OFF
		            SELECT wells
		            IF SEEK(m.cwellid)
		               IF DELETED()
		                  RECALL
		               ENDIF
		               IF NOT EMPTY(m.cWellName)
		                  REPLACE cWellName WITH m.cWellName
		               ENDIF
		               IF NOT EMPTY(m.cCounty)
		                  REPLACE cCounty WITH m.cCounty
		               ENDIF
		               IF NOT EMPTY(m.cstate)
		                  REPLACE cstate  WITH m.cstate
		               ENDIF
		               IF NOT EMPTY(m.cGroup)
		                  REPLACE cGroup  WITH m.cGroup
		               ENDIF
		               IF NOT EMPTY(m.cwellstat)
		                  REPLACE cwellstat WITH m.cwellstat
		               ENDIF
		               IF NOT EMPTY(m.cPermit1)
		                  REPLACE cPermit1 WITH m.cPermit1
		               ENDIF
		               IF NOT EMPTY(m.cPermit2)
		                  REPLACE cPermit2 WITH m.cPermit2
		               ENDIF
		               IF NOT EMPTY(m.cPermit3)
		                  REPLACE cPermit3 WITH m.cPermit3
		               ENDIF
		               IF NOT EMPTY(m.cPermit4)
		                  REPLACE cPermit4 WITH m.cPermit4
		               ENDIF
		               IF NOT EMPTY(m.cPermit5)
		                  REPLACE cPermit5 WITH m.cPermit5
		               ENDIF
		               IF NOT EMPTY(m.cPermit6)
		                  REPLACE cPermit6 WITH m.cPermit6
		               ENDIF
		               IF NOT EMPTY(m.cMeterID)
		                  REPLACE cMeterID WITH m.cMeterID
		               ENDIF
		               IF NOT EMPTY(m.cMeterID2)
		                  REPLACE cMeterID2 WITH m.cMeterID2
		               ENDIF
		               IF NOT EMPTY(m.cMeterID3)
		                  REPLACE cMeterID3 WITH m.cMeterID3
		               ENDIF
		               IF NOT EMPTY(m.cMeterID4)
		                  REPLACE cMeterID4 WITH m.cMeterID4
		               ENDIF
		               IF NOT EMPTY(m.cMeterID5)
		                  REPLACE cMeterID5 WITH m.cMeterID5
		               ENDIF
		               IF NOT EMPTY(m.cMeterID6)
		                  REPLACE cMeterID6 WITH m.cMeterID6
		               ENDIF
		               IF NOT EMPTY(m.cUser1)
		                  REPLACE cUser1 WITH m.cUser1
		               ENDIF
		               IF NOT EMPTY(m.cUser2)
		                  REPLACE cUser2 WITH m.cUser2
		               ENDIF
		               IF NOT EMPTY(m.cUser3)
		                  REPLACE cUser3 WITH m.cUser3
		               ENDIF
		               IF NOT EMPTY(m.cUser4)
		                  REPLACE cUser4 WITH m.cUser4
		               ENDIF
		               IF NOT EMPTY(m.cUser5)
		                  REPLACE cUser5 WITH m.cUser5
		               ENDIF
		               IF NOT EMPTY(m.cUser6)
		                  REPLACE cUser6 WITH m.cUser6
		               ENDIF
		               IF NOT EMPTY(m.cSection)
		                  REPLACE cSection WITH m.cSection
		               ENDIF
		               IF NOT EMPTY(m.cRange)
		                  REPLACE cRange WITH m.cRange
		               ENDIF
		               IF NOT EMPTY(m.cTNR)
		                  REPLACE cTNR WITH m.cTNR
		               ENDIF
		               IF NOT EMPTY(m.cFormation)
		                  REPLACE cFormation WITH m.cFormation
		               ENDIF
		               IF NOT EMPTY(m.cidPumper)
		                  REPLACE cidPumper WITH m.cidPumper
		               ENDIF 
		               SELECT mappedfields
		               LOCATE FOR cName = 'cpurchased'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE dPurchased WITH m.dPurchased
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cpurchfrom'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cpurchfrom WITH m.cpurchfrom
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'csold'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE dSold WITH m.dSold
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cplugged'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE dPlugged WITH m.dPlugged
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cproddate'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE dProdDate WITH m.dProdDate
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'ccompdate'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE dCompDate WITH m.dCompDate
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cacres'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE nAcres WITH m.nAcres
		               ENDIF
		               SELECT wells 
		               IF NOT EMPTY(m.cParcel)
		                  REPLACE cParcel WITH m.cParcel
		               ENDIF
		               IF NOT EMPTY(m.cLatitude)
		                  REPLACE cLatitude WITH m.cLatitude
		               ENDIF
		               IF NOT EMPTY(m.cLongitude)
		                  REPLACE cLongitude WITH m.cLongitude
		               ENDIF
		               IF NOT EMPTY(m.cLot)
		                  REPLACE cLot WITH m.cLot
		               ENDIF
		               IF NOT EMPTY(m.cTable)
		                  REPLACE cTable WITH m.cTable
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cthird_prty'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lthird_prty WITH m.lthird_prty
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'coiltax1'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev1o WITH m.lSev1o
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cgastax1'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev1g WITH m.lSev1g
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cothtax1'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev1p WITH m.lSev1p
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'coiltax2'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev2o WITH m.lSev2o
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cgastax2'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev2g WITH m.lSev2g
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cothtax2'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev2p WITH m.lSev2p
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'coiltax3'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev3o WITH m.lSev3o
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cgastax3'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev3g WITH m.lSev3g
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cothtax3'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev3p WITH m.lSev3p
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'coiltax4'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev4o WITH m.lSev4o
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cgastax4'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev4g WITH m.lSev4g
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cothtax4'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lSev4p WITH m.lSev4p
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cnglpropane'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lNGLPropane WITH m.lNGLPropane
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cnglethane'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lNGLEthane WITH m.lNGLEthane
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cnglbutane'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lNGLButane WITH m.lNGLButane
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cnglisobutane'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lNGLISOButane WITH m.lNGLISOButane
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cnglpentane'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE lNGLPentane WITH m.lNGLPentane
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cwvdistrict'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cwvdistrict WITH m.cwvdistrict
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cnra1'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cnra1 WITH m.cnra1
		               ENDIF
		                SELECT mappedfields
		               LOCATE FOR cName = 'cnra2'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cnra2 WITH m.cnra2
		               ENDIF
		                SELECT mappedfields
		               LOCATE FOR cName = 'cnra3'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cnra3 WITH m.cnra3
		               ENDIF
		                SELECT mappedfields
		               LOCATE FOR cName = 'cnra4'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cnra4 WITH m.cnra4
		               ENDIF
		                SELECT mappedfields
		               LOCATE FOR cName = 'cnra5'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cnra5 WITH m.cnra5
		               ENDIF
		                SELECT mappedfields
		               LOCATE FOR cName = 'cnra6'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cnra6 WITH m.cnra6
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cpropno'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cpropno WITH m.cpropno
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'coilpurchno'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE coilpurchno WITH m.coilpurchno
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cgaspurchno'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cgaspurchno WITH m.cgaspurchno
		               ENDIF
		               SELECT mappedfields
		               LOCATE FOR cName = 'cothpurchno'
		               IF FOUND()
		                  SELECT wells
		                  REPLACE cothpurchno WITH m.cothpurchno
		               ENDIF
		               TRY
		                  IF NOT EMPTY(m.mwellnote)
		                     REPLACE mwellnote WITH ALLTRIM(m.mwellnote) + CHR(10) + ALLTRIM(mwellnote)
		                  ENDIF
		               CATCH
		               ENDTRY
		               SELECT wells
		               REPLACE dChanged WITH DATETIME(), cChangedBy WITH m.goApp.cUser
		               SET DELETED ON
		            ELSE
		               m.dadded	  = DATETIME()
		               m.cAddedBy = m.goApp.cUser
		               IF NOT EMPTY(m.cwellid)
		                  SELECT wells
		                  SET ORDER TO cwellid
		                  IF NOT SEEK(m.cwellid)
		                     INSERT INTO wells FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDSCAN
		      OTHERWISE
		         llReturn = .F.
		   ENDCASE
		
		   TABLEUPDATE(.T., .T., 'Wells')
		
		   lnCount = RECCOUNT('importfile')
		
		   IF llReturn
		      TABLEUPDATE(.T., .T., 'Wells')
		      MESSAGEBOX('Successfully imported ' + TRANSFORM(lnCount) + ' wells.', 64, 'Import Wells')
		   ELSE
		      TABLEREVERT(.T., 'Wells')
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'HandleWells', loError.LINENO, 'Import Data', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		   SET DELETED ON
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE import		&& Imports the given format
		LOCAL lcFile, loError, llReturn
		
		THISFORM.nTotalImport = 0
		
		llReturn     = .T.
		
		TRY
		
		    lcMapName = THISFORM.cboImportMap.VALUE
		
		    lcFile = GETFILE('CSV,XLS,XLSX', 'Choose the file to Import:', 'Choose', 0, 'Where is the import file?')
		
		    IF EMPTY(lcFile)
		        llReturn = .F.
		        EXIT
		    ENDIF
		
		    THISFORM.BackupData()
		
		    llReturn = m.goApp.oImport.ImportMap(lcFile, lcMapName, THISFORM.ImportType, THISFORM.DATASESSIONID)
		    IF NOT llReturn
		        EXIT
		    ENDIF
		
		    CREATE CURSOR badrecs ;
		        (cID1      C(10), ;
		          cID2      C(10), ;
		          cName     C(30), ;
		          cOldID    C(10), ;
		          cOldName  C(30), ;
		          cDesc     C(140), ;
		          lContinue L)
		    INDEX on lcontinue TAG continue 
		
		* Get the list of fields in the map so we know what fields to update if we're 
		* just replacing existing data
		     CREATE CURSOR mappedfields ;
		      (cFieldDesc   c(30), ;
		       cName        c(20))
		      
		     SWSELECT('ImportMap')
		        LOCATE FOR cType = THISFORM.ImportType AND cImportName = ALLTRIM(lcMapName)
		        IF NOT FOUND()
		            MESSAGEBOX('A valid mapping file must be selected before choosing a file to import.', 16, 'Missing Map File')
		            llReturn = .F.
		            EXIT
		        ENDIF
		        lnDefMax = ALINES(laFields, mfields)
		        FOR lnx = 1 TO lnDefMax
		            m.cFieldDesc = LOWER(laFields[lnx])
		            swselect('importdefs')
		            LOCATE FOR LOWER(cdescript) = ALLTRIM(LOWER(m.cFieldDesc))
		            IF FOUND()
		               m.cName = LOWER(cName)
		            ELSE
		               m.cName = 'unknown'
		            ENDIF 
		            INSERT INTO mappedfields FROM MEMVAR 
		        ENDFOR
		
		    DO CASE
		        CASE THISFORM.ImportType = 'WELL'
		            llReturn = THISFORM.HandleWells()
		
		        CASE THISFORM.ImportType = 'OWN'
		            llReturn = THISFORM.HandleOwners()
		
		        CASE THISFORM.ImportType = 'DOI'
		            llReturn = THISFORM.HandleDOI()
		
		        CASE THISFORM.ImportType = 'COA'
		            llReturn = THISFORM.HandleCOA()
		
		        CASE THISFORM.ImportType = 'CUST'
		            llReturn = THISFORM.HandleCusts()
		
		        CASE THISFORM.ImportType = 'VEND'
		            llReturn = THISFORM.HandleVends()
		
		        CASE THISFORM.ImportType = 'GL'
		            llReturn = THISFORM.HandleGL()
		
		        CASE THISFORM.ImportType = 'PURCH'
		            llReturn = THISFORM.HandlePurchasers()
		
		        CASE THISFORM.ImportType = 'ECAT'
		            llReturn = THISFORM.HandleExpCodes()
		        
		        CASE THISFORM.ImportType = 'LSE'
		            llReturn = THISFORM.HandleLand()  
		            
		        CASE THISFORM.ImportType = 'LO'
		            llReturn = THISFORM.HandleLandOwner()
		        
		        CASE THISFORM.ImportType = 'METER'
		            llReturn = THISFORM.HandleMeters()            
		
		        CASE THISFORM.ImportType = 'PUMP'
		            llReturn = THISFORM.HandlePumpers()            
		
		    ENDCASE
		
		    lnTotal = RECCOUNT('ImportFile')
		
		    IF llReturn
		*        MESSAGEBOX('Imported: ' + TRANSFORM(lnTotal) + IIF(lnTotal > 1, ' Records ', ' Record '), 64, 'Import Successful')
		    ELSE
		        MESSAGEBOX('The import did not complete successfully. Please check the problem report for ' + ;
		                   'more details. There was at least one error that kept the import from continuing.',48 , 'Import Failed')
		    ENDIF
		
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'Import', loError.LINENO, 'Import Revenue', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE importexcel		&& Import Excel Data
	ENDPROC

	PROCEDURE Init
		PARAMETERS tcType
		
		thisform.ImportType = tcType
		
		IF DODEFAULT()
		   
		   DO CASE 
		      CASE tcType = 'GL'
		         thisform.Caption = 'Import Journal Entries'
		      CASE tcType = 'COA'
		         thisform.Caption = 'Import Accounts to Chart of Accounts'
		      CASE tcType = 'CUST'
		         thisform.Caption = 'Import Customers'   
		      CASE tcType = 'VEND'
		         thisform.Caption = 'Import Vendors'
		      CASE tcType = 'OWN'
		         thisform.Caption = 'Import Owners'
		      CASE tcType = 'WELL'
		         thisform.Caption = 'Import Wells'
		      CASE tcType = 'DOI'
		         thisform.Caption = 'Import Division of Interests'
		      CASE tcType = 'PURCH'
		         thisform.Caption = 'Import Purchasers'
		      CASE tcType = 'ECAT'
		         thisform.Caption = 'Import Expense Codes'  
		      CASE tcType = 'LSE'
		         thisform.Caption = 'Import Leases'       
		      CASE tcType = 'LO'
		         thisform.Caption = 'Import Lease Obligations'            
		      CASE tcType = 'METER'
		         thisform.Caption = 'Import Master Meters'    
		      CASE tcType = 'PUMP'
		         thisform.Caption = 'Import Pumpers'           
		      OTHERWISE 
		         thisform.Caption = 'Import Wells'
		   ENDCASE                
		ENDIF 
	ENDPROC

	PROCEDURE list
		LPARAMETERS cWorkarea
		*
	ENDPROC

	PROCEDURE lookupoper
	ENDPROC

	PROCEDURE meter_report		&& Prints report of allocations done.
	ENDPROC

	PROCEDURE oilreceipts		&& Builds cash receipt from imported oil data
	ENDPROC

	PROCEDURE postbill
	ENDPROC

	PROCEDURE postgl
		LPARAMETERS tcBatch
		LOCAL lcBatch, lcSelect, llReturn, lnNotes
		LOCAL lcidchec, loError
		
		llReturn = .T.
		
		TRY
		
		    lcSelect = SELECT()
		
		    lcBatch = tcBatch
		
		* Open all tables needed    
		    swselect('checks',.T.)
		    swselect('gljndet',.T.)
		    swselect('coabal',.T.)
		    swselect('glmaster',.T.)
		    swselect('expense',.T.)
		    swselect('expsusp',.T.)
		
		    swselect('gljourn',.T.)
		    LOCATE FOR cbatch == lcBatch
		
		*  Create G/L Master entries for this journal entry
		    WITH THISFORM.glmaint
		        .cbatch     = lcBatch
		        .cReference = gljourn.cglref
		        .cSource    = 'GJ'
		        .dgldate    = gljourn.dgldate
		        .DMBatch    = ''
		        .cBunch     = THISFORM.cBunch
		        .mNotes     = 'gljourn.mnotes'
		        .cid        = ''
		        lnNotes     = 1
		        .cYear      = gljourn.cYear
		        .cPeriod    = gljourn.cPeriod
		
		        swselect('gljndet',.T.)
		        SCAN FOR cbatch == lcBatch
		            IF nDebits = 0 AND nCredits = 0
		                DELETE NEXT 1
		                LOOP
		            ENDIF
		            .cDesc    = gljndet.cDesc
		            .cAcctNo  = gljndet.cAcctNo
		            .cUnitNo  = gljndet.cUnitNo
		            .cDeptNo  = gljndet.cDeptNo
		            .cCatCode = gljndet.cCatCode
		            .cidchec  = ''
		
		* Check for bank accounts
		            swselect('coa')
		            SET ORDER TO acctno
		            IF SEEK(gljndet.cAcctNo)
		                IF lBankAcct
		                    IF gljndet.nDebits > 0
		                        lcidchec = gljndet.cidchec
		                        .delcheck(lcidchec)
		                        .cEntryType = 'D'
		                        .cIdType    = 'D'
		                        .nAmount    = gljndet.nDebits
		                        .dCheckDate = gljourn.dgldate
		                        .dPostDate  = gljourn.dgldate
		                        .cCheckNo   = 'GL' + lcBatch
		                        .cPayee     = .cDesc
		                        .lPrinted   = .T.
		                        .addcheck()
		                        lcidchec = .GETKEY()
		                        .cidchec = lcidchec
		                    ELSE
		                        lcidchec = gljndet.cidchec
		                        .delcheck(lcidchec)
		                        .cEntryType = 'C'
		                        .cIdType    = 'M'
		                        .nAmount    = gljndet.nCredits
		                        .dCheckDate = gljourn.dgldate
		                        .dPostDate  = gljourn.dgldate
		                        .cCheckNo   = 'GL' + lcBatch
		                        .cPayee     = .cDesc
		                        .lPrinted   = .T.
		                        .addcheck()
		                        lcidchec = .GETKEY()
		                        .cidchec = lcidchec
		                    ENDIF
		                ENDIF
		            ENDIF
		
		            swselect('gljndet',.T.)
		            REPLACE cidchec WITH .cidchec
		
		            IF gljndet.nDebits <> 0
		                .nAmount = gljndet.nDebits
		            ENDIF
		            IF gljndet.nCredits <> 0
		                .nAmount = gljndet.nCredits * -1
		            ENDIF
		
		            .updatebatch()
		
		        ENDSCAN
		
		        llReturn = .chkBalance()
		
		        IF NOT llReturn
		            THISFORM.oMessage.DISPLAY('%msgOutofBalance', 'G/L Master Out of Balance')
		        ELSE
		* Create the Disb Mgr expenses to allocate (if any)
		            llReturn = THISFORM.dmexpense()
		        ENDIF
		
		    ENDWITH
		
		    swselect('glmaster')
		    llReturn = TABLEUPDATE(.T., .T.)
		    swselect('expense')
		    llReturn = TABLEUPDATE(.T., .T.)
		    swselect('expsusp')
		    llReturn = TABLEUPDATE(.T., .T.)
		    swselect('checks')
		    llReturn = TABLEUPDATE(.T., .T.)
		    swselect('gljourn')
		    llReturn = TABLEUPDATE(.T., .T.)
		    swselect('gljndet')
		    llReturn = TABLEUPDATE(.T., .T.)
		    swselect('coabal')
		    llReturn = TABLEUPDATE(.T., .T.)
		
		    SELECT (lcSelect)
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'PostGL', loError.LINENO, 'Import Journal', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE postrcpt
	ENDPROC

	PROCEDURE processcdex		&& Processes the importfile created by the import of a CDEX DAT file.
	ENDPROC

	PROCEDURE processmap		&& Processes the importfile cursor created by importing an owner relations connect csv file.
		LOCAL llReturn, loError
		LOCAL lPostToQB, lcMessage, lcMessage2, lnBadRecs, lnTotal, lnTotalcks, lnDeducts
		LOCAL cBatch, cOwnType, cProdYear, cType, ccashacct, cdesc, cleasename, cname, copername
		LOCAL cprodperiod, ddate, dentdate, ileasespk, ioperatorpk, nNetUnits, nPrice
		
		lnBadRecs = 0
		llReturn  = .T.
		
		TRY
		
		    STORE '' TO lcMessage2, m.ccashacct, m.cType
		    lcMapName = THISFORM.cboimportMap.VALUE
		
		
		* Create cursor for bad detail lines
		    CREATE CURSOR baddetail ;
		        (cwellid    c(14), ;
		          cpropname  c(40), ;
		          cprodcode  c(7), ;
		          ccheckno   c(14))
		
		
		    m.cUser         = m.goapp.cUser
		    m.dlastmodified = DATETIME()
		
		
		    m.cBatch = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		
		    SELECT curNewChecks
		    SCAN
		        SCATTER MEMVAR
		
		        m.ccashacct = THISFORM.cboCashAcct.VALUE
		        m.cBatch    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		
		        m.cname    = THISFORM.txtcPurchName.VALUE
		
		        IF THISFORM.chkUseDate.VALUE
		            m.ddate    = THISFORM.dcheckdate.VALUE
		        ELSE
		            m.ddate    = m.dcheckdate
		        ENDIF
		        
		        m.dPostDate = m.dDate
		
		        m.dentdate = DATE()
		
		        IF VARTYPE(m.ddate) # 'D'
		            MESSAGEBOX('An invalid date was found in the import. Using todays date instead. Correct in Production Receipts after this import.', 16, 'Bad Date')
		            m.ddate = DATE()
		        ENDIF
		        IF NOT BETWEEN(m.ddate, {01/01/1980}, {12/31/2020})
		            MESSAGEBOX('An invalid date was found in the import. Using todays date instead. Correct in Production Receipts after this import.', 16, 'Bad Date')
		            m.ddate = DATE()
		        ENDIF
		
		        m.cid = THISFORM.txtPurchaser.VALUE
		
		        INSERT INTO csrcthdr FROM MEMVAR
		
		        lcLastProdType = ''
		        m.lWellRcpt    = .T.
		
		        SELECT importfile
		        SCAN FOR ccheckno = m.ccheckno AND csender = m.csender AND NOT 'PROPERTY' $ UPPER(cpropertyno) AND NOT 'TOTAL' $ UPPER(cpropertyno)
		            SCATTER MEMVAR
		
		            swselect('wells')
		            LOCATE FOR (cPropNo = ALLTRIM(m.cpropertyno)) OR ;
		                (coilpurchno = ALLTRIM(m.cpropertyno)) OR ;
		                (cgaspurchno = ALLTRIM(m.cpropertyno)) OR ;
		                (cothpurchno = ALLTRIM(m.cpropertyno))
		            IF FOUND()
		                m.cwellid   = cwellid
		                m.cwellname = cwellname
		                m.cdesc     = m.cwellname
		                lcTaxType   = ''
		
		                SELECT gastypes
		                LOCATE FOR ccode = m.cprodtype
		                IF FOUND()
		                    m.cType   = 'MCF'
		                    lcTaxType = 'GTAX'
		                ELSE
		                    SELECT ngltypes
		                    LOCATE FOR ccode = m.cprodtype
		                    IF FOUND()
		                        m.cType   = 'NGL'
		                        lcTaxType = 'NTAX'
		                    ELSE
		                        SELECT oiltypes
		                        LOCATE FOR ccode = m.cprodtype
		                        IF FOUND()
		                            m.cType   = 'BBL'
		                            lcTaxType = 'OTAX'
		                        ELSE
		                            IF m.nowngross # 0
		                                MESSAGEBOX('An invalid revenue code was found in the import. The code found is: ' + CHR(10) + CHR(10) + ;
		                                      m.cprodtype + CHR(10) + CHR(10) + ;
		                                      'Please add this code to the appropriate revenue type in the import ' + ;
		                                      'code mapping and then try the import again.', 16, 'Invalid Revenue Code')
		                                llReturn = .F.
		                                EXIT
		                            ENDIF
		                        ENDIF
		                    ENDIF
		                ENDIF
		
		                IF NOT EMPTY(m.cprodtype)
		                    lcLastProdType = m.cType
		                ENDIF
		
		                m.nUnits  = m.nownervol
		                m.nAmount = m.nowngross
		
		                IF m.nPrice = 0
		                    IF m.nownervol <> 0
		                        m.nPrice    = m.nowngross / m.nownervol
		                    ELSE
		                        m.nPrice = 0
		                    ENDIF
		                ENDIF
		
		                IF EMPTY(m.dproddate)
		                    m.dproddate = m.ddate
		                ENDIF
		                m.cprodperiod = PADL(TRANSFORM(MONTH(m.dproddate)), 2, '0')
		                m.cProdYear   = TRANSFORM(YEAR(m.dproddate))
		
		                SELECT ovrtypes
		                LOCATE FOR ccode = m.cIntType
		                IF FOUND()
		                    m.cOwnType = 'O'
		                ELSE
		                    SELECT roytypes
		                    LOCATE FOR ccode = m.cIntType
		                    IF FOUND()
		                        m.cOwnType = 'R'
		                    ELSE
		                        SELECT wrktypes
		                        LOCATE FOR ccode = m.cIntType
		                        IF FOUND()
		                            m.cOwnType = 'W'
		                        ELSE
		                            m.cOwnType = 'W'
		                        ENDIF
		                    ENDIF
		                ENDIF
		
		                IF NOT EMPTY(m.cprodtype) AND m.nAmount # 0
		                    m.cacctno = THISFORM.GetAcctListID(m.cType, m.cOwnType)
		                    lcidrctd  = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    SET DELETED OFF
		                    SELECT csrctdet
		                    SET ORDER TO cidpurd
		                    DO WHILE SEEK(lcidrctd)
		                        lcidrctd = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    ENDDO
		                    SET DELETED ON
		                    m.cidRctD = lcidrctd
		                    INSERT INTO csrctdet FROM MEMVAR
		                ENDIF
		
		                IF m.nownroychg # 0
		                    m.nPrice  = 0
		                    m.nUnits  = 0
		                    m.nAmount = m.nownroychg * lnDeducts
		                    lcidrctd  = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    SET DELETED OFF
		                    SELECT csrctdet
		                    SET ORDER TO cidpurd
		                    DO WHILE SEEK(lcidrctd)
		                        lcidrctd = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    ENDDO
		                    SET DELETED ON
		                    m.cidRctD = lcidrctd
		                    INSERT INTO csrctdet FROM MEMVAR
		                ENDIF
		
		                IF m.nowndeducts # 0 OR m.nGrossDeducts # 0
		                    m.nPrice  = 0
		                    m.nUnits  = 0
		                    m.nAmount = m.nowndeducts * lnDeducts
		
		                    IF NOT EMPTY(m.cAdjCode)
		                        swselect('expcat')
		                        LOCATE FOR ccatcode == PADR(m.cAdjCode, 4, ' ')
		                        IF NOT FOUND()
		                            SELECT ptaxtypes
		                            LOCATE FOR ccode = m.cAdjCode
		                            IF FOUND()
		                                DO CASE
		                                    CASE lcLastProdType = 'MCF'
		                                        m.cType = 'GTAX'
		                                    CASE lcLastProdType = 'BBL'
		                                        m.cType = 'OTAX'
		                                    CASE lcLastProdType = 'OTH'
		                                        m.cType = 'PTAX'
		                                    CASE lcLastProdType = 'NGL'
		                                        m.cType = 'NTAX'
		                                    OTHERWISE
		                                        m.cType = 'LO'
		                                ENDCASE
		                            ELSE
		                                SELECT adjtypes
		                                LOCATE FOR ccode = m.cAdjCode
		                                IF FOUND()
		                                    m.cType = 'OD'
		                                ELSE
		                                    SELECT staxtypes
		                                    LOCATE FOR ccode = m.cAdjCode
		                                    IF FOUND()
		                                        m.cType = 'STAX'
		                                    ELSE
		                                        m.cType = 'OD'
		                                    ENDIF
		                                ENDIF
		                            ENDIF
		                        ELSE
		                            m.cType = m.cAdjCode
		                        ENDIF
		                    ELSE
		                        m.cType = 'OD'
		                    ENDIF
		lcidrctd  = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    SET DELETED OFF
		                    SELECT csrctdet
		                    SET ORDER TO cidpurd
		                    DO WHILE SEEK(lcidrctd)
		                        lcidrctd = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    ENDDO
		                    SET DELETED ON
		                    m.cidRctD = lcidrctd
		                    INSERT INTO csrctdet FROM MEMVAR
		                ENDIF
		
		                IF m.nowntax # 0
		                    m.nPrice  = 0
		                    m.nUnits  = 0
		                    m.nAmount = m.nowntax * lnDeducts
		                    m.cType   = lcTaxType
		                    m.cacctno = THISFORM.GetAcctListID(m.cType, m.cOwnType)
		                    lcidrctd  = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    SET DELETED OFF
		                    SELECT csrctdet
		                    SET ORDER TO cidpurd
		                    DO WHILE SEEK(lcidrctd)
		                        lcidrctd = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    ENDDO
		                    SET DELETED ON
		                    m.cidRctD = lcidrctd
		                    INSERT INTO csrctdet FROM MEMVAR
		                ENDIF
		
		                IF m.nwithhold # 0
		                    m.nPrice = 0
		                    m.nUnits = 0
		                    IF m.ninterest = 0
		                        m.ninterest = 1
		                    ENDIF
		                    m.Amount  = m.nwithhold * lnDeducts
		                    m.cType   = 'STAX'
		                    m.cacctno = THISFORM.GetAcctListID(m.cType, m.cOwnType)
		                    lcidrctd  = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    SET DELETED OFF
		                    SELECT csrctdet
		                    SET ORDER TO cidpurd
		                    DO WHILE SEEK(lcidrctd)
		                        lcidrctd = THISFORM.oregistry.incrementcounter('%Shared.Counters.Cash Receipt Detail')
		                    ENDDO
		                    SET DELETED ON
		                    m.cidRctD = lcidrctd
		                    INSERT INTO csrctdet FROM MEMVAR
		                ENDIF
		            ELSE
		                m.cwellid   = m.cpropertyno
		                m.cprodcode = ALLTRIM(m.cprodtype)
		                INSERT INTO baddetail FROM MEMVAR
		                lnBadRecs = lnBadRecs + 1
		            ENDIF
		        ENDSCAN && importfile
		    ENDSCAN &&cshdr
		
		* Inform about any recs that couldn't be imported    
		    IF lnBadRecs > 0
		        lcMessage = "There were " + TRANSFORM(lnBadRecs) + " detail lines that could not be imported." + CHR(10) + ;
		            "The property numbers that couldn't be found in the well records are: " + CHR(10)
		
		        SELECT ccheckno, cwellid FROM baddetail INTO CURSOR temp ORDER BY cwellid, ccheckno GROUP BY cwellid, ccheckno
		        SELECT temp
		        SCAN
		            SCATTER MEMVAR
		            lcMessage2 = lcMessage2 + 'Property: ' + m.cwellid + ' Check No: ' + m.ccheckno + CHR(10)
		        ENDSCAN
		        MESSAGEBOX(lcMessage + lcMessage2, 48, 'Missing Properties')
		        IF MESSAGEBOX('Do you want to print this list of invalid properties?', 36, 'Missing Properties') = 6
		            SELECT ccheckno, cpropname, cprodcode, cwellid FROM baddetail INTO CURSOR temp ORDER BY cwellid, ccheckno GROUP BY cwellid, cprodcode, ccheckno
		            REPORT FORM baddetail TO PRINTER PROMPT PREVIEW
		        ENDIF
		        IF MESSAGEBOX('Do you want to continue the import?', 36, 'Continue Import') = 7
		            llReturn = .F.
		        ENDIF
		    ENDIF
		
		    llReturn = thisform.WellIncome()
		    
		    IF llReturn
		        TABLEUPDATE(.T., .T., 'Csrcthdr')
		        TABLEUPDATE(.T., .T., 'Csrctdet')
		        TABLEUPDATE(.T., .T., 'Income')
		        TABLEUPDATE(.T., .T., 'Incsusp')
		        TABLEUPDATE(.T., .T., 'Expense')
		        TABLEUPDATE(.T., .T., 'Expsusp')
		    ENDIF
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'ProcessCSV', loError.LINENO, 'Import Revenue', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE qbpostbill
	ENDPROC

	PROCEDURE qbpostrec		&& Post receipt to QuickBooks
	ENDPROC

	PROCEDURE recalcnri
		LOCAL lcKey, lnNumInv, lnGasRev, lnOilRev, lnGas, lnOil, lnOver, jnGasRev, jnOilRev, jnOthRev, lnOthRev, lnOther
		LOCAL llReturn, llTaxes, llWorkIntComplain, loError
		
		llReturn = .T.
		
		IF NOT USED('wells')
		   USE wells IN 0
		ENDIF
		
		IF NOT USED('wellinv')
		   USE wellinv IN 0
		ENDIF 
		TRY
		
		SELECT wells
		SCAN FOR NOT lRecalc 
		   m.cwellid = cwellid
		   
		    STORE 0 TO lnGasRev, lnGas, lnOilRev, lnOil, jnGasRev, jnOilRev, lnOther, lnOthRev, jnOthRev, lnNumInv, lnOver
		
		        llTaxes = .T.
		*
		*  Not explicitly specifying gas and oil income interests, so calculate
		*
		    WAIT WIND NOWAIT 'Recalculating Revenue Interests...'
		    SELECT  cWellID, cownerid, nworkint, ctypeinv, cTypeInt, ;
		            000.00000000 AS noinc, 000.00000000 AS nginc, ;
		            lflat, nflatrate, cDirect, lprogram, cprogcode, cidwinv, ;
		            nrevgas, nrevoil, lJIB, lOnHold ;
		       FROM wellinv ;
		       INTO CURSOR doiwrk ;
		       WHERE cWellID = m.cwellid ;
		           AND nworkint >= 0  ;
		       ORDER BY ctypeinv, cprogcode, cownerid
		
		    lnNumInv = _TALLY
		
		* Get the total of royalty percentages for oil and gas
		    SELECT  SUM(nrevgas) AS nGasPct, SUM(nrevoil) AS nOilPct, SUM(nrevoth) AS nOthPct ;
		       FROM wellinv ;
		       INTO CURSOR revwrk ;
		       WHERE cWellID = m.cwellid ;
		           AND (wellinv.lflat = .F. ;
		             OR nflatrate = 0) ;
		           AND INLIST(ctypeinv, 'L', 'O')
		
		    SELECT revwrk
		    lnGasRev = nGasPct
		    lnOilRev = nOilPct
		    lnOthRev = nOthPct
		    jnGasRev = nGasPct
		    jnOilRev = nOilPct
		    jnOthRev = nOthPct
		
		    SELECT wellinv
		    SET ORDER TO cidinvwell
		
		    llWorkIntComplain = .F.
		
		* Initialize lcKey in case they don't have any working interest owners entered yet.
		    lcKey = '********'
		
		    SELECT doiwrk
		    SCAN FOR NOT lprogram
		        SCATTER MEMVAR
		        IF m.ctypeinv = 'W'
		            IF INLIST(m.cTypeInt, 'B', 'G')
		                lnGas = ROUND(m.nworkint * (100 - lnGasRev) / 100, 7)
		            ELSE
		                lnGas = 0
		            ENDIF
		            IF INLIST(m.cTypeInt, 'B', 'O')
		                lnOil = ROUND(m.nworkint * (100 - lnOilRev) / 100, 7)
		            ELSE
		                lnOil = 0
		            ENDIF
		            IF m.cTypeInt = 'B'
		                lnOther = ROUND(m.nworkint * (100 - lnOthRev) / 100, 7)
		            ELSE
		                lnOther = 0
		            ENDIF
		            jnGasRev = jnGasRev + lnGas
		            jnOilRev = jnOilRev + lnOil
		            jnOthRev = jnOthRev + lnOther
		            lcKey    = m.cidwinv + m.cownerid + m.cWellID
		            SELECT wellinv
		            IF SEEK (lcKey)
		                REPLACE nworkint WITH m.nworkint
		                IF nrevgas <> lnGas
		                    REPLACE nrevgas WITH lnGas
		                    IF llTaxes
		                        REPL nRevTax2  WITH lnGas, ;
		                            nRevTax5  WITH lnGas, ;
		                            nRevTax8  WITH lnGas, ;
		                            nRevTax11 WITH lnGas
		                    ENDIF
		                ENDIF
		                IF nrevoil <> lnOil
		                    REPLACE nrevoil WITH lnOil
		                    IF llTaxes
		                        REPL nRevTax1  WITH lnOil, ;
		                            nRevTax4  WITH lnOil, ;
		                            nRevTax7  WITH lnOil, ;
		                            nRevTax10 WITH lnOil
		                    ENDIF
		                ENDIF
		                IF nrevoth <> lnOther
		                    REPLACE nrevoth WITH lnOther
		                    IF llTaxes
		                        REPL nRevTax3  WITH lnOther, ;
		                            nRevTax6  WITH lnOther, ;
		                            nRevTax9  WITH lnOther, ;
		                            nRevTax12 WITH lnOther
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDSCAN
		*
		*  If the gas revenue percentages total over 100%, subtract the
		*  overage from the last owner in the well.
		*
		    IF jnGasRev > 100
		        lnOver = jnGasRev - 100.0000000
		        lnGas  = lnGas - lnOver
		        SELECT wellinv
		        IF SEEK(lcKey)
		            IF nrevgas <> lnGas
		                REPLACE nrevgas WITH lnGas
		                IF llTaxes
		                    REPL nRevTax2  WITH lnGas, ;
		                        nRevTax5  WITH lnGas, ;
		                        nRevTax8  WITH lnGas, ;
		                        nRevTax11 WITH lnGas
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		*
		*  If the gas revenue percentages are under 100%, add the
		*  amount to the last owner in the well.  This is only if
		*  the amount the total is under 100% is less than 1%.
		*
		    IF jnGasRev < 100 AND jnGasRev > 99
		        lnOver = 100 - jnGasRev
		        lnGas  = lnGas + lnOver
		        SELECT wellinv
		        IF SEEK(lcKey)
		            IF nrevgas <> lnGas
		                REPLACE nrevgas WITH lnGas
		                IF llTaxes
		                    REPL nRevTax2  WITH lnGas, ;
		                        nRevTax5  WITH lnGas, ;
		                        nRevTax8  WITH lnGas, ;
		                        nRevTax11 WITH lnGas
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		*
		*  If the oil revenue percentages total over 100%, subtract the
		*  overage from the last owner in the well.
		*
		    IF jnOilRev > 100
		        lnOver = jnOilRev - 100.0000000
		        lnOil  = lnOil - lnOver
		        SELECT wellinv
		        IF SEEK (lcKey)
		            IF nrevoil <> lnOil
		                REPLACE nrevoil WITH lnOil
		                IF llTaxes
		                    REPL nRevTax1  WITH lnOil, ;
		                        nRevTax4  WITH lnOil, ;
		                        nRevTax7  WITH lnOil, ;
		                        nRevTax10 WITH lnOil
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		*
		*  If the gas revenue percentages are under 100%, add the
		*  amount to the last owner in the well.  This is only if
		*  the amount the total is under 100% is less than 1%.
		*
		    IF jnOilRev < 100 AND jnOilRev > 99
		        lnOver = 100 - jnOilRev
		        lnOil  = lnOil + lnOver
		        SELECT wellinv
		        IF SEEK (lcKey)
		            IF nrevoil <> lnOil
		                REPLACE nrevoil WITH lnOil
		                IF llTaxes
		                    REPL nRevTax1  WITH lnOil, ;
		                        nRevTax4  WITH lnOil, ;
		                        nRevTax7  WITH lnOil, ;
		                        nRevTax10 WITH lnOil
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		
		*
		*  If the other revenue percentages total over 100%, subtract the
		*  overage from the last owner in the well.
		*
		    IF jnOthRev > 100
		        lnOver  = jnOthRev - 100.0000000
		        lnOther = lnOther - lnOver
		        SELECT wellinv
		        IF SEEK (lcKey)
		            IF nrevoth <> lnOther
		                REPLACE nrevoth WITH lnOther
		                IF llTaxes
		                    REPL nRevTax3  WITH lnOther, ;
		                        nRevTax6  WITH lnOther, ;
		                        nRevTax9  WITH lnOther, ;
		                        nRevTax12 WITH lnOther
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		*
		*  If the other revenue percentages are under 100%, add the
		*  amount to the last owner in the well.  This is only if
		*  the amount the total is under 100% is less than 1%.
		*
		    IF jnOthRev < 100 AND jnOthRev > 99
		        lnOver  = 100 - jnOthRev
		        lnOther = lnOther + lnOver
		        SELECT wellinv
		        IF SEEK (lcKey)
		            IF nrevoth <> lnOther
		                REPLACE nrevoth WITH lnOther
		                IF llTaxes
		                    REPL nRevTax3  WITH lnOther, ;
		                        nRevTax6  WITH lnOther, ;
		                        nRevTax9  WITH lnOther, ;
		                        nRevTax12 WITH lnOther
		                ENDIF
		            ENDIF
		        ENDIF
		    ENDIF
		
		*  Update landowner and override pcts in the well record
		    SELECT wells
		    IF nOilInt <> lnOilRev
		        REPL nOilInt WITH lnOilRev
		    ENDIF
		    IF nGasInt <> lnGasRev
		        REPL nGasInt WITH lnGasRev
		    ENDIF
		    ENDSCAN 
		
		
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'Recalcrev', loError.LINENO, 'DOI-D', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the DOI at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE reportprobs
		LPARAMETERS tcTitle, tlContinue, tlDuplicates
		
		PRIV lcProducer, lcTitle
		LOCAL llReplace, llDuplicates, lnCount
		
		STORE .F. TO llReplace, llDuplicates
		
		IF MESSAGEBOX('There were problems found during the import.' + CHR(10) + CHR(10) + 'Do you want a report of the import problems?', 36, 'Import Problems') = 6
		    SELECT badrecs
		    lcProducer = ALLTRIM(m.goapp.cCompanyName)
		    lcTitle    = tcTitle
		    REPORT FORM badimprecs TO PRINTER PROMPT PREVIEW NOCONSOLE
		ENDIF
		
		SELECT badrecs
		COUNT FOR NOT lContinue TO lnCount
		llDuplicates = lnCount = 0
		
		IF tlContinue
		    IF tlDuplicates 
		        IF MESSAGEBOX('Do you want to replace the current records with imported data?', 36, 'Duplicates Found') = 6
		            llReplace = .T.
		        ELSE
		            llReplace = .F.
		        ENDIF
		    ENDIF
		ELSE
		    llReplace = .F.
		ENDIF
		
		RETURN llReplace
	ENDPROC

	PROCEDURE wellincome
		LOCAL lcbatch, m.cownerid, llcloserun, llSendToAllocation
		*******************************************************************
		*  Adds the income entries to the disbursement manager INCSUSP or
		*  INCOME tables depending on whether the production year and
		*  period are specified.
		*******************************************************************
		
		llReturn = .T.
		
		TRY
		*
		*  Call distproc to create the (invtmp) and (wellwork) cursors
		*
		    swselect('wells')
		    SET ORDER TO cwellid
		    GO TOP
		    lcwellid1 = cwellid
		    GO BOTT
		    lcwellid2 = cwellid
		
		    THISFORM.odist = CREATEOBJECT('distproc', lcwellid1, lcwellid2, ;
		          '01', '1980', '00', 'W', DATE(), .F., 0)
		
		    lcbatch    = csrcthdr.cbatch
		    m.ccheckno = csrcthdr.ccheckno
		
		* Set the default for property lSendToAllocate
		    THISFORM.lSendToAllocate = m.goApp.lSendToAllocate
		
		    swselect('income')
		    = AFIELDS(lafields)
		    CREATE CURSOR tempinc FROM ARRAY lafields
		
		    swselect('incsusp')
		    SCAN FOR cbatch = lcbatch
		        DELETE NEXT 1
		    ENDSCAN
		    swselect('expsusp')
		    SCAN FOR cbatch = lcbatch
		        DELETE NEXT 1
		    ENDSCAN
		
		* Remove Income entries
		    swselect('income')
		    SCAN FOR cbatch == lcbatch
		        DELE NEXT 1
		    ENDSCAN
		
		* Remove Expense entries
		    swselect('expense')
		    SCAN FOR cbatch == lcbatch
		        DELE NEXT 1
		    ENDSCAN
		
		    swselect('csrctdet')
		    lcfilter = FILTER()
		    SET FILTER TO
		    SCAN FOR cbatch == lcbatch AND lwellrcpt = .T.
		
		        m.lnetrev  = .T.  &&  Variable for whether this item should be grossed thru NetRev up or not.  Should be reset for each line - BH 08/02/2007
		
		        SCATTER MEMVAR
		        llgrossunits = m.lgrossunits
		
		* Changed 12/18/08 by pws from using postdate to using receipt date
		        m.drevdate       = csrcthdr.ddate
		        IF EMPTY(m.cprodyear) OR EMPTY(m.cprodperiod)
		* Nothing
		        ELSE
		            m.cyear   = m.cprodyear
		            m.cperiod = m.cprodperiod
		        ENDIF
		        m.crevkey     = csrcthdr.cid
		
		        llSendToAllocation = .F.
		
		*  If the well is not valid, don't try to create income records
		        swselect('wells')
		        SET ORDER TO cwellid
		        IF NOT SEEK(m.cwellid)
		            LOOP
		        ELSE
		            IF INLIST(cwellstat, 'I', 'S', 'P')
		                llSendToAllocation = .T.
		            ENDIF
		        ENDIF
		
		        IF NOT EMPTY(m.cownerid)
		            m.lnetrev = .F.
		        ENDIF
		
		        DO CASE
		            CASE m.ctype = 'BBL'
		                m.csource = 'BBL'
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, 'O', .T., .T.)
		                ENDIF
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'O', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		            CASE m.ctype = 'MCF'
		                m.csource = 'MCF'
		
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, 'G', .T., .T.)
		                ENDIF
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'G', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		            CASE m.ctype = 'OTH'
		                m.csource = 'OTH'
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, 'P', .T., .T.)
		                ENDIF
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'P', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		
		            CASE m.ctype = 'MISC1'
		                m.csource = 'MISC1'
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, '1', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, '1', .T., .T.)
		                ENDIF
		
		            CASE m.ctype = 'MISC2'
		                m.csource = 'MISC2'
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, '2', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, '2', .T., .T.)
		                ENDIF
		
		            CASE m.ctype = 'TRANS'
		                m.csource = 'TRANS'
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, 'T', .T., .T.)
		                ENDIF
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'T', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		            CASE m.ctype = 'OTAX1' OR m.ctype = 'OTAX2' OR m.ctype = 'OTAX3' OR m.ctype = 'OTAX4'
		                m.csource = m.ctype
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, 'O' + RIGHT(ALLT(m.csource), 1), .T., .T.)
		                ENDIF
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'O' + RIGHT(ALLT(m.csource), 1), .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		            CASE m.ctype = 'GTAX1' OR m.ctype = 'GTAX2' OR m.ctype = 'GTAX3' OR m.ctype = 'GTAX4'
		                m.csource = m.ctype
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, 'G' + RIGHT(ALLT(m.csource), 1), .T., .T.)
		                ENDIF
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'G' + RIGHT(ALLT(m.csource), 1), .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		            CASE m.ctype = 'PTAX1' OR m.ctype = 'PTAX2' OR m.ctype = 'PTAX3' OR m.ctype = 'PTAX4'
		                m.csource = m.ctype
		                IF m.lnetrev AND NOT llgrossunits
		                    m.nunits = THISFORM.odist.netrev(m.cwellid, m.nunits, 'P', .T., .T.)
		                ENDIF
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'P', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		            CASE m.ctype = 'EXO'
		                m.csource = 'EXO'
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'O', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		            CASE m.ctype = 'EXG'
		                m.csource = 'EXG'
		                IF m.lnetrev
		                    m.ntotalinc = THISFORM.odist.netrev(m.cwellid, m.namount, 'G', .T., .T.)
		                ELSE
		                    m.ntotalinc = m.namount
		                ENDIF
		
		            OTHERWISE
		                swselect('expcat')
		                SET ORDER TO ccatcode
		                IF SEEK(LEFT(m.ctype, 4))
		                    m.cexpclass = cexpclass
		                    m.ccateg    = ccateg
		                    m.ccatcode  = ccatcode
		                    m.crefid    = m.ccheckno
		                    IF m.ctype = 'MKTG'
		                        IF m.cexpclass = '0'
		                            m.namount = THISFORM.odist.netrev(m.cwellid, m.namount, 'G', .T., .T., .F., m.cownerid)
		                        ELSE
		                            m.namount   = swNetExp(m.namount, m.cwellid, .F., expcat.cexpclass, 'B', .F., m.cownerid)
		                        ENDIF
		                    ELSE
		                        m.namount   = swNetExp(m.namount, m.cwellid, .F., expcat.cexpclass, 'B', .F., m.cownerid)
		                    ENDIF
		                    m.namount     = m.namount * -1
		                    m.cpayee      = csrcthdr.cname
		                    m.cvendorid   = csrcthdr.cid
		                    m.laptran     = .T.
		                    m.lfixed      = .F.
		                    m.cbatch      = lcbatch
		                    m.dpostdate   = m.drevdate
		                    m.dexpdate    = m.drevdate
		                    m.nSaltWater  = m.nSaltBBL
		                    m.cmemo       = ''
		                    m.nrunnorev   = 0
		                    m.nrunnojib   = 0
		                    m.crunyearrev = ''
		                    m.crunyearjib = ''
		                    m.cidexph     = ''
		                    IF NOT EMPTY(m.cprodyear) AND NOT EMPTY(m.cprodperiod) AND NOT THISFORM.lSendToAllocate AND NOT llSendToAllocation
		                        m.cidexpe = THISFORM.oregistry.incrementcounter('%Shared.Counters.Expense')
		                        SET DELETED OFF
		                        SELECT expense
		                        SET ORDER TO cidexpe
		                        DO WHILE SEEK(m.cidexpe)
		                            m.cidexpe = THISFORM.oregistry.incrementcounter('%Shared.Counters.Expense')
		                        ENDDO
		                        SET DELETED ON
		                        swselect('expense')
		                        m.cyear   = m.cprodyear
		                        m.cperiod = m.cprodperiod
		                        INSERT INTO expense FROM MEMVAR
		                    ELSE
		                        m.cidexps    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Expense')
		                        SET DELETED OFF
		                        swselect('expsusp')
		                        SET ORDER TO cidexps
		                        DO WHILE SEEK(m.cidexps)
		                            m.cidexps    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Expense')
		                        ENDDO
		                        SET DELETED ON
		                        m.cyear   = m.cprodyear
		                        m.cperiod = m.cprodperiod
		                        INSERT INTO expsusp FROM MEMVAR
		                    ENDIF
		                ENDIF
		                LOOP
		        ENDCASE
		
		        m.crefid    = m.ccheckno
		        m.lcstran   = .T.
		        m.cbatch    = lcbatch
		        m.dpostdate = m.drevdate
		        m.cmemo     = ''
		        m.cAcctNo   = ''
		
		        IF NOT EMPTY(m.cprodyear) AND NOT EMPTY(m.cprodperiod) AND NOT THISFORM.lSendToAllocate AND NOT llSendToAllocation
		            m.cidinch = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		            m.cidinco = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		            SELECT income
		            SET DELETED OFF
		            SET ORDER TO cidinco
		            DO WHILE SEEK(m.cidinco)
		                m.cidinco = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		            ENDDO
		            SET DELE ON
		            m.nrunno  = 0
		            m.cyear   = m.cprodyear
		            m.cperiod = m.cprodperiod
		            INSERT INTO income FROM MEMVAR
		        ELSE
		            m.cidincs    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		            SELECT incsusp1
		            SET DELE OFF
		            SET ORDER TO cidincs
		            DO WHILE SEEK(m.cidincs)
		                m.cidincs    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		            ENDDO
		            SET DELE ON
		            m.lallocated = .F.
		            m.nrunno     = 0
		            m.cyear      = m.cprodyear
		            m.cperiod    = m.cprodperiod
		            INSERT INTO incsusp FROM MEMVAR
		        ENDIF
		    ENDSCAN
		
		    swselect('csrctdet')
		    SET FILTER TO &lcfilter
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'WellIncome', loError.LINENO, 'Import Revenue', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE cboImportMap.Init
		IF DODEFAULT()
		   this.Requery()
		ENDIF 
	ENDPROC

	PROCEDURE cboImportMap.Requery
		IF DODEFAULT()
		   this.Clear()
		   lnx = 1
		   swselect('importmap')
		   SELECT cimportname FROM importmap WHERE ctype = thisform.ImportType INTO CURSOR temp ORDER BY cimportname
		   SCAN
		      this.AddListItem(cimportname,lnx) 
		      lnx = lnx + 1
		   ENDSCAN 
		ENDIF    
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdImport.Click
		thisform.import()
		
		
	ENDPROC

	PROCEDURE cmdMapping.Click
		m.goStateManager.OpenForm('import_map.scx',thisform.ImportType, thisform.cboImportMap.value)
	ENDPROC

ENDDEFINE
