*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="pluggingback.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 487
	Left = 40
	Name = "Dataenvironment"
	Top = 235
	Width = 737

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "apopt", ;
		CursorSource = "apopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 21, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 291, ;
		Name = "Cursor3", ;
		Top = 19, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "expense", ;
		BufferModeOverride = 5, ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Order = "glbatch", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Order = "yrprdgrp", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "expcat", ;
		CursorSource = "expcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor9", ;
		Top = 300, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formpluggingback AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="SWGROUP1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: process		&& Releases the fixed expenses
		*m: processqb
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Back Out Plugging Charges"
	DataSession = 2
	DoCreate = .T.
	Height = 345
	HelpContextID = 134
	Name = "FormPluggingBack"
	Visible = .T.
	Width = 494
	_memberdata = <VFPData>
		<memberdata name="processqb" display="ProcessQB"/>
		</VFPData>		&& XML Metadata for customizable properties
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cboProcess' AS cbocomboboxcustom WITH ;
		Height = 24, ;
		Left = 132, ;
		Name = "cboProcess", ;
		TabIndex = 3, ;
		Top = 155, ;
		Width = 228
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 48, ;
		Left = 240, ;
		Name = "cmdExit", ;
		TabIndex = 6, ;
		Top = 276, ;
		Width = 85
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdProcess' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Process", ;
		Default = .T., ;
		Height = 48, ;
		Left = 133, ;
		Name = "cmdProcess", ;
		TabIndex = 5, ;
		Top = 276, ;
		Width = 88
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 303, ;
		Name = "Glmaint", ;
		Top = 183
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Group", ;
		Left = 85, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 1, ;
		Top = 85
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Process", ;
		Left = 85, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 4, ;
		Top = 157
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'SWGROUP1' AS swgroup WITH ;
		BoundColumn = 2, ;
		Height = 20, ;
		Left = 132, ;
		Name = "SWGROUP1", ;
		TabIndex = 2, ;
		Top = 83, ;
		Width = 299
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />
	
	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		
		LOCAL lnTxnLevel  
		
		=aerror(gaerrors)
		lnTxnLevel = txnlevel()
		
		IF lnTxnLevel > 0
		   ROLLBACK
		ENDIF
		
		DODEFAULT(nerror,cmethod,nline)
		* thisform.oMessage.Severe('An error occurred while backing out fixed expenses')
		
		* thisform.release()
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   IF m.goApp.lAMVersion
		      IF NOT USED('glbatches')
		         USE (ALLTRIM(m.goApp.cDataFilePath)+'glbatches') IN 0
		         SELECT glbatches
		         =CURSORSETPROP("Buffering",5)
		      ENDIF 
		   ENDIF 
		ENDIF 
	ENDPROC

	PROCEDURE process		&& Releases the fixed expenses
		LOCAL lcGroup, llAllWells, lcYear, lnRunNo, llSepClose
		LOCAL lnFixed, lnTotal, lcExpClear, lcAPAcct, oProgress
		
		SET DELETED ON
		
		lcGroup = THISFORM.swgroup1.VALUE
		
		IF m.goapp.lAMVersion  &&  Since glbatches isn't in the database for DM or DMIE.
		   swselect('glbatches')
		ENDIF 
		
		*  Get the registry object
		THISFORM.oRegistry = FindGlobalObject('cmRegistry')
		
		*  Get the separate closing for JIB setting
		SELECT options
		llSepClose = lSepClose
		
		*  Get the expense clearing account
		SELECT glopt
		llSepAccts = lSepAccounts
		IF llSepAccts
		   lcExpClear = cExpClear
		ELSE
		   lcExpClear = cRevClear
		ENDIF
		
		*  Get the A/P account
		SELECT apopt
		lcAPAcct = cAPAcct
		
		llAllWells = .F.
		
		lnRunNo = 0
		
		IF THISFORM.cboProcess.VALUE = 'All Wells'
		   llAllWells = .T.
		ELSE
		   llAllWells = .F.
		ENDIF
		
		*  If all wells are to be processed, select them into wellsel
		IF llAllWells
		   IF lcGroup = '**'
		      SELECT cWellID, ' ' AS temp FROM wells  ;
		         INTO CURSOR wellsel ;
		         ORDER BY cWellID
		   ELSE
		      SELECT cWellID, ' ' AS temp FROM wells  ;
		         WHERE cGroup = lcGroup ;
		         INTO CURSOR wellsel ;
		         ORDER BY cWellID
		   ENDIF
		ELSE
		   DO FORM dmselwells WITH lcGroup
		ENDIF
		
		*
		*  There were no wells selected
		*
		SELECT wellsel
		IF RECC() = 0
		   THISFORM.omessage.DISPLAY('There were no wells chosen to remove plugging charges.')
		   RETURN
		ENDIF
		
		lnWells = 0
		
		ldDate = DATE()
		SELECT wellsel
		SCAN
		   m.cWellID = cWellID
		   SELECT expense
		   LOCATE FOR cWellID = m.cWellID ;
		      AND nRunNoJIB = 0 ;
		      AND nRunNoRev = 0 ;
		      AND lFixed = .T. ;
		      AND cCatCode = 'PLUG' 
		   IF FOUND()
		      lnWells = lnWells + 1
		      ldDate = expense.dexpdate
		   ENDIF
		   IF lnWells # 0
		      EXIT
		   ENDIF
		ENDSCAN
		
		IF lnWells = 0
		   THISFORM.omessage.Warning('There are no plugging charges found for the selected wells.')
		   RETURN
		ENDIF
		
		*  Make sure the period or year isn't closed
		IF NOT THISFORM.glmaint.CheckPeriod(ldDate)
		   THISFORM.omessage.Warning('Unable to remove plugging charges. Either the fiscal year or period represented by this date has been closed.')
		   RETURN .F.
		ENDIF
		
		oProgress = THISFORM.omessage.ProgressBarEx('Removing plugging charges','Test')
		
		SELECT wellsel
		lnMax = RECC()
		lnCount = 1
		oProgress.SetProgressRange(0,lnMax)
		SCAN
		   SCATTER MEMVAR
		   oProgress.SetProgressMessage(' Well: ' + m.cWellID)
		   oProgress.UpdateProgress(lnCount)
		   lnCount = lnCount + 1
		   SELECT expense
		   SCAN FOR cWellID = m.cWellID ;
		         AND nRunNoRev = 0 ;
		         AND nRunNoJIB = 0 ;
		         AND lFixed = .T. ;
		         AND cCatCode = 'PLUG' 
		      m.cBatch = cBatch
		      DELETE NEXT 1
		      *  Remove the journal entries
		      THISFORM.glmaint.delbatch(m.cBatch,'DM')
		   ENDSCAN
		ENDSCAN
		
		oProgress.CloseProgress()
		
		BEGIN TRANSACTION
		SELECT expense
		llok =TABLEUPDATE(.T.)
		IF m.goapp.lAMVersion
		   IF llok
		      SELECT glmaster
		      llok=TABLEUPDATE(.T.)
		   ENDIF
		   IF llok
		      SELECT coabal
		      llok=TABLEUPDATE(.T.)
		   ENDIF
		   IF llok
		      SELECT glbatches
		      llok=TABLEUPDATE(.T.)
		   ENDIF
		ENDIF
		IF llok
		   END TRANSACTION
		   THISFORM.omessage.DISPLAY('Plugging charges Removed...')
		ELSE
		   ROLLBACK
		   THISFORM.omessage.severe('Unable to commit removal of plugging charges. Plugging charges were NOT removed.')
		ENDIF
		
		
	ENDPROC

	PROCEDURE processqb
		LOCAL lcGroup, llAllWells, lcYear, lnRunNo, llSepClose, lnFixedExp
		LOCAL lnFixed, lnTotal, lcExpClear, lcAPAcct, oProgress
		
		SET DELETED ON
		
		* Set the parameter to pass to dmselwell to tell it
		* that we want a list of wells that have plugging expenses
		STORE 2 TO lnFixedExp
		
		*  Get the registry object
		THISFORM.oRegistry = FindGlobalObject('cmRegistry')
		
		*  Get the A/P account
		SWSELECT('apopt')
		lcAPAcct = cAPAcct
		
		*  Get the separate closing for JIB setting
		SWSELECT('options')
		llSepClose = .t.
		lcDMExp    = cFixedAcct
		
		IF EMPTY(lcDMExp)
		    lcDMExp = lcAPAcct
		ENDIF
		
		*  Get the expense clearing account
		SWSELECT('glopt')
		llSepAccts = lSepAccounts
		IF llSepAccts
		    lcExpClear = cExpClear
		ELSE
		    lcExpClear = cRevClear
		ENDIF
		
		IF m.goApp.oQB.lQBActive
		    m.goApp.oQB.oQBSM.ClearErrorRecovery()
		* get a message set request object (version 1.1 xml)
		    loRequest = m.goApp.oQB.oQBRequest
		* set the on error attribute for the request
		    loRequest.ATTRIBUTES.OnError = 1
		    loRequest.ClearRequests()
		ELSE
		    THISFORM.oMessage.Warning('You must be connected to QuickBooks before any plugging expenses can be removed.')
		    RETURN
		ENDIF
		
		llAllWells = .F.
		
		tcGroup = THISFORM.swGroup1.VALUE
		
		IF THISFORM.cboProcess.VALUE = 'All Wells'
		    llAllWells = .T.
		ELSE
		    llAllWells = .F.
		ENDIF
		
		*  If all wells are to be processed, select them into wellsel
		IF llAllWells
		   SELECT  cWellID, ' ' AS temp ;
		      FROM wells  ;
		      WHERE cwellid in (SELECT cwellid FROM plugwell) ;
		      INTO CURSOR wellsel ;
		      ORDER BY cWellID
		ELSE
		    DO FORM ..\commonsource\dmselwells WITH tcGroup, lnFixedExp
		ENDIF
		
		*
		*  There were no wells selected
		*
		SELECT wellsel
		IF RECC() = 0
		    THISFORM.oMessage.Warning('There are no plugging expenses found for the selected wells.')
		    RETURN
		ENDIF
		
		lnFixed  = 0
		llClosed = .F.
		
		SELECT wellsel
		SCAN
		    m.cWellID = cWellID
		    SELECT expense
		    SCAN FOR cWellID = m.cWellID ;
		            AND nrunnorev = 0 ;
		            AND nrunnojib = 0 ;
		            AND cexpclass = 'P'
		        lnFixed = lnFixed + 1
		    ENDSCAN
		ENDSCAN
		
		IF lnFixed = 0
		    THISFORM.oMessage.Warning('There are no plugging expenses found for the selected wells.')
		    RETURN
		ENDIF
		
		oProgress = THISFORM.oMessage.ProgressBarEx('Backing Out Plugging Expenses...', '')
		
		SELECT wellsel
		lnMax   = RECC()
		lnCount = 1
		oProgress.SetProgressRange(0, lnMax)
		
		SELE wellsel  &&  Scan selected wells to remove their expenses
		SCAN
		    SCATTER MEMVAR
		    oProgress.SetProgressMessage(' Well: ' + m.cWellID)
		    oProgress.UpdateProgress(lnCount)
		    lnCount = lnCount + 1
		    SELECT expense
		    SCAN FOR cWellID = m.cWellID ;
		            AND nrunnorev = 0 ;
		            AND nrunnojib = 0 ;
		            AND cExpClass = 'P'
		        m.cBatch  = cBatch
		        m.cidexpe = cidexpe
		        DELETE NEXT 1
		*
		*  Remove the QuickBooks journal entries
		*
		        IF m.goApp.oQB.lQBActive
		* Clear error recovery
		            m.goApp.oQB.oQBSM.ClearErrorRecovery()
		
		            m.goApp.oQB.oQBSM.EnableErrorRecovery = .F.
		
		* set the on error attribute for the request
		            m.goApp.oQB.oQBRequest.ATTRIBUTES.OnError = 1
		            loRequest.ClearRequests()
		            swselect('qbpost')
		            LOCATE FOR cidsysctl = m.cBatch
		            IF FOUND()
		                m.nType  = nType
		                lcTxnIDs = mtxnids
		                lnCount  = ALINES(laTxnid, lcTxnIDs)
		                IF lnCount > 0
		                    FOR lnX = 1 TO lnCount
		                        lcTxnID      = PADR(ALLT(laTxnid[lnX]), 36, ' ')
		                        loJournalDel = m.goApp.oQB.oQBRequest.AppendTxnDelRq()
		                        loJournalDel.TxnDelType.SetValue(m.nType)
		                        loJournalDel.TxnID.SetValue(lcTxnID)
		
		                        loResponse = m.goApp.oQB.oQBSM.DoRequests(loRequest)
		                        loDelResp  = loResponse.responselist.getat(0)
		                        loRequest.ClearRequests()
		                    ENDFOR
		                ENDIF
		            ENDIF
		            loRequest.ClearRequests()
		* add a request to delete the receipt
		            loExpDel = loRequest.AppendTxnDelRq()
		            IF m.goApp.oQB.QBFCVersion > ' 4.0'
		                loExpDel.TxnDelType.SetValue(15)
		            ELSE
		                loExpDel.TxnDelType.SetValue(14)
		            ENDIF
		            SWSELECT('exptxnid')
		            LOCATE FOR cidexpe = m.cidexpe
		            IF FOUND()
		                loExpDel.TxnID.SetValue(exptxnid.ctxnid)
		                loResponse = m.goApp.oQB.oQBSM.DoRequests(loRequest)
		                loDelResp  = loResponse.responselist.getat(0)
		                m.goApp.oQB.oQBSM.ClearErrorRecovery()
		            ENDIF
		            loRequest.ClearRequests()
		        ENDIF
		    ENDSCAN
		ENDSCAN
		
		oProgress.CloseProgress()
		
		BEGIN TRANSACTION
		SELECT expense
		llok =TABLEUPDATE(.T.)
		
		IF llok
		   END TRANSACTION
		   THISFORM.omessage.DISPLAY('Plugging charges Removed...')
		ELSE
		   ROLLBACK
		   THISFORM.omessage.severe('Unable to commit removal of plugging charges. Plugging charges were NOT removed.')
		ENDIF
		
		
	ENDPROC

	PROCEDURE cboProcess.Init
		this.addlistitem('All Wells',1)
		this.addlistitem('Selected Wells',2)
		this.listitemid = 1
		
		DODEFAULT()
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdProcess.Click
		IF m.goapp.lQBVersion
		   thisform.processqb()
		ELSE    
		   thisform.process()
		ENDIF    
	ENDPROC

	PROCEDURE SWGROUP1.Init
		dodefault()
		
		this.listitemid = 1
	ENDPROC

ENDDEFINE
