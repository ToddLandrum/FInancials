*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="dmreopenj.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 587
	Left = -2
	Name = "Dataenvironment"
	Top = 233
	Width = 1016

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 9, ;
		Name = "Cursor10", ;
		Top = 404, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "invhdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "invhdr", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 152, ;
		Name = "Cursor11", ;
		Top = 397, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "invdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "invdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 292, ;
		Name = "Cursor12", ;
		Top = 405, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "arpmtdet", ;
		CursorSource = "arpmtdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 6, ;
		Name = "Cursor13", ;
		Top = 154, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "disbhist", ;
		BufferModeOverride = 5, ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "expense", ;
		BufferModeOverride = 5, ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "prepayd", ;
		BufferModeOverride = 5, ;
		CursorSource = "prepayd", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 199, ;
		Left = 430, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "groups", ;
		CursorSource = "groups", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "sysctl", ;
		BufferModeOverride = 5, ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Top = 277, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "wellhist", ;
		BufferModeOverride = 5, ;
		CursorSource = "wellhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor9", ;
		Top = 272, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formdmreopenj AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdReopen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Runcombo1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="GLMaint" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: reopen		&& Re-Opens the closed revenue period.
	*</DefinedPropArrayMethod>

	Caption = "Open a Closed JIB Run"
	DataSession = 2
	DoCreate = .T.
	Height = 244
	HelpContextID = 132
	Name = "FormDmreopenj"
	Visible = .T.
	Width = 448
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cmdClose' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Cancel", ;
		Height = 36, ;
		Left = 223, ;
		Name = "cmdClose", ;
		TabIndex = 4, ;
		Top = 187, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdReopen' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Re-Open", ;
		Height = 36, ;
		Left = 133, ;
		Name = "cmdReopen", ;
		TabIndex = 3, ;
		Top = 187, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'GLMaint' AS glmaint WITH ;
		Height = 26, ;
		Left = 284, ;
		Name = "GLMaint", ;
		Top = 94, ;
		Width = 40
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Run No", ;
		Left = 29, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 2, ;
		Top = 84
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Runcombo1' AS runcombo WITH ;
		ColumnWidths = "230,0,0", ;
		cshowwhat = J, ;
		Height = 20, ;
		Left = 77, ;
		lshownew = .F., ;
		Name = "Runcombo1", ;
		TabIndex = 1, ;
		Top = 82, ;
		Width = 335
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />
	
	PROCEDURE Activate
		thisform.runcombo1.init()
		DODEFAULT()
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		LOCAL lnLevel
		
		=aerror(gaerror)
		
		lnLevel = TXNLEVEL()
		
		IF lnLevel > 0
		   FOR lnX = 1 TO lnLevel
		     ROLLBACK
		   ENDFOR
		ENDIF
		
		DODEFAULT()     
	ENDPROC

	PROCEDURE Init
		
		SET DELETED ON
		
		*
		*  See if there are any closed jib periods
		*
		SELECT sysctl
		LOCATE FOR cTypeClose = 'J'
		
		IF NOT Found()
		   thisform.oMessage.Display('There are no closed JIB periods to open.')
		   RETURN .F.
		ENDIF   
		
		thisform.runcombo1.listitemid = 1 
		DODEFAULT()       
	ENDPROC

	PROCEDURE reopen		&& Re-Opens the closed revenue period.
		LOCAL lcsyskey, lcDMBatch, lcYear, lcPeriod, lcGroup, lcIDChec, oGL
		LOCAL lcBatch, lcMessage, lnRunNo
		*:Global cbatch, cidsysctl, dpostdate
		
		lcYear    = THISFORM.runcombo1.LISTITEM[thisform.runcombo1.listitemid, 2]
		lnRunNo   = INT(VAL(THISFORM.runcombo1.LISTITEM[thisform.runcombo1.listitemid, 3]))
		lcDMBatch = THISFORM.runcombo1.LISTITEM[thisform.runcombo1.listitemid, 5]
		
		
		SWSELECT('sysctl', .T.)
		LOCATE FOR cyear = lcYear AND lDisbMan AND cTypeClose = 'J' AND nRunNo = lnRunNo
		IF FOUND()
		    IF EMPTY(cVersion)   &&  Don't let them re-open a run closed at a previous version - BH 11/29/06
		        THISFORM.oMessage.Warning('You cannot re-open this run, because it was closed with a previous version of the software.')
		        RETURN
		    ENDIF
		
		    m.cidsysctl = cidsysctl
		    m.dpostdate = dpostdate
		    IF NOT THISFORM.glmaint.checkperiod(m.dpostdate, .T.)
		        THISFORM.oMessage.severe('This JIB run cannot be reopened. The fiscal year/period this JIB was posted has been closed.')
		        RETURN
		    ENDIF
		ELSE
		    THISFORM.oMessage.Warning('Could not find the system control record for this closed run.')
		    RETURN
		ENDIF
		
		*
		* Check for payments that have been applied to JIB's from this run
		* Don't allow the run to be reopened if there are payments
		*
		SWSELECT('invhdr')
		SCAN FOR cDMBatch == lcDMBatch
		    lcBatch = cbatch
		    SELECT arpmtdet
		    LOCATE FOR cinvtoken == lcBatch AND namtapp <> 0
		    IF FOUND()
		        lcMessage = 'You cannot re-open this run, because there are payments' + CHR(10) + ;
		            'that have been received for JIB invoices created in this run.' + CHR(10) + CHR(10) + ;
		            'Delete the payments first and then try to open the run again.' + CHR(10) + CHR(10) + ;
		            'Payments Found: ' + CHR(10) + CHR(10) + ;
		            PADR('Owner ID  ', 15, ' ') + ' Date        ' + '        Amount' + CHR(10)
		        m.cbatch = cbatch
		        SCAN FOR cinvtoken == lcBatch AND namtapp <> 0
		            SWSELECT('arpmthdr')
		            SET ORDER TO cbatch
		            IF SEEK(m.cbatch)
		                lcMessage = lcMessage + invhdr.ccustid + SPACE(5) + DTOC(arpmthdr.drecdate) + SPACE(5) + TRANSFORM(arpmthdr.npmtamt, '$$$,$$$,$$$.99') + CHR(10)
		            ENDIF
		        ENDSCAN
		        MESSAGEBOX(lcMessage, 16, 'Unable To Reopen Run')
		        RETURN 0
		    ENDIF
		ENDSCAN
		
		IF m.goapp.lAMVersion
		*  Make sure the period or year isn't closed
		    IF NOT THISFORM.glmaint.checkperiod(m.dpostdate)
		        THISFORM.oMessage.Warning('Unable to reopen this JIB run. Either the fiscal year or period represented by this date has been closed.')
		        RETURN .F.
		    ENDIF
		ENDIF
		
		
		* Check to make sure it's ok to reopen this JIB run
		IF MESSAGEBOX('Confirm that JIB run: ' + lcYear + '/' + TRANSFORM(lnRunNo) + ' should be opened?', 36, 'Open a JIB Run') = 7
		    RETURN
		ENDIF
		
		* Turn FoxAudit auditing off for the reopen
		   IF TYPE('oFoxAudit_APPDATA') = 'O'
		      oFoxAudit_APPDATA.lLogUpdates = .F.
		   ENDIF
		
		
		SWSELECT('checks')
		COUNT FOR lPrinted AND cbatch == lcDMBatch TO lnPrtCount
		IF lnPrtCount > 0
		    IF MESSAGEBOX('There are checks from this run that have already been printed! ' + CHR(10) + CHR(10) + ;
		              'NOTE: ' + CHR(10) + ;
		              'If the checks from the run closing have been mailed out, DO NOT open this run!' + CHR(10) + CHR(10) + ;
		              'If any time has lapsed since they were mailed out there is a very good chance that the check amounts will NOT match the original '  + ;
		              'checks created when the run is closed again.' + CHR(10) + CHR(10) + ;
		              'Do you want to void them and continue?', 20, 'Confirmation Required') = 7
		        THIS.oprogress.CloseProgress()
		        lnReturn = 0
		        EXIT
		    ELSE
		        THIS.oprogress.SetProgressMessage('Voiding checks from the check register...')
		        llVoidCheck = .T.
		        SWSELECT('checks', .T.)
		        SCAN FOR cbatch = lcDMBatch
		            lcIDChec = cidchec
		            IF cidtype = 'V'
		                SWSELECT('expense', .T.)
		                REPL cpaidbyck WITH '', cprdpaid WITH '', lclosed WITH .F. FOR cpaidbyck = lcIDChec
		            ENDIF
		            SWSELECT('checks', .T.)
		            IF lPrinted
		                REPL nvoidamt WITH namount, ;
		                    namount  WITH 0, ;
		                    lVoid    WITH .T.,  ;
		                    lCleared WITH .T.  &&  Mark as cleared, so they don't show on the recon screen - BH 02/15/2008
		            ELSE
		                DELETE NEXT 1
		            ENDIF
		        ENDSCAN
		    ENDIF
		ELSE
		    SWSELECT('checks', .T.)
		    SCAN FOR cbatch = lcDMBatch
		        lcIDChec = cidchec
		        IF cidtype = 'V'
		            SWSELECT('expense', .T.)
		            REPL cpaidbyck WITH '', cprdpaid WITH '', lclosed WITH .F. FOR cpaidbyck = lcIDChec
		        ENDIF
		        SWSELECT('checks', .T.)
		        DELETE NEXT 1
		    ENDSCAN
		ENDIF
		*
		*  Remove records from the well history table
		*
		WAIT WIND NOWAIT 'Removing well history records...'
		SWSELECT('wellhist', .T.)
		DELETE FOR nRunNo = lnRunNo AND cRunYear = lcYear AND cRecType = 'J'
		
		*
		*  Remove records from the owner history table
		*
		WAIT WIND NOWAIT 'Removing owner history records...'
		SWSELECT('disbhist', .T.)
		DELETE FOR nRunNo = lnRunNo AND cRunYear = lcYear AND cRecType = 'J'
		
		*
		*  Remove journal entries from the glmaster table
		*
		IF m.goapp.lAMVersion
		    WAIT WIND NOWAIT 'Removing journal entries....'
		    SWSELECT('glbatches', .T.)
		    SELECT cbatch FROM glmaster WHERE cDMBatch = lcDMBatch INTO CURSOR tempbatch ORDER BY cbatch GROUP BY cbatch
		    SELECT tempbatch
		    SCAN
		        m.cbatch = cbatch
		        SELECT glbatches
		        DELETE FOR cbatch == m.cbatch
		    ENDSCAN
		
		    SWSELECT('glmaster', .T.)
		    DELE FOR cDMBatch == lcDMBatch
		ENDIF
		*
		*  Remove invoices from the invhdr and invdet files
		*
		WAIT WIND NOWAIT 'Removing joint interest billing statements....'
		SWSELECT('invhdr', .T.)
		DELETE FOR cDMBatch = lcDMBatch
		
		SWSELECT('plugwellbal', .T.)
		DELETE FROM plugwellbal WHERE cDMBatch == lcDMBatch
		
		*
		*  Reset the flag in the expense table
		*
		WAIT WIND NOWAIT 'Resetting closed flag in the well expense records...'
		SWSELECT('expense', .T.)
		SCAN FOR nRunNoJIB = lnRunNo AND cRunYearJIB = lcYear
		    REPL lclosed     WITH .F., ;
		        nRunNoJIB   WITH 0, ;
		        cRunYearJIB WITH '', ;
		        cprdpaid WITH ''
		    IF crunyearrev = '1901'
		        REPL nrunnorev   WITH 0, ;
		            crunyearrev WITH ''
		    ENDIF
		
		    IF expense.laptran = .F.
		        SWSELECT('checks')
		        LOCATE FOR cidchec = expense.cpaidbyck AND cbatch = lcDMBatch
		        IF FOUND()
		            SWSELECT('expense')
		            REPLACE cpaidbyck WITH ''
		        ENDIF
		    ENDIF
		ENDSCAN
		
		*
		*  Remove the closed record from the sysctl table
		*
		SWSELECT('sysctl', .T.)
		DELETE FOR nRunNo = lnRunNo AND cyear = lcYear AND lDisbMan AND cTypeClose = 'J'
		
		
		*  Remove any pre-pay records from prepayd that were created during the closing
		SWSELECT('prepayd', .T.)
		SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear AND cRecType = 'U'
		    DELETE NEXT 1
		ENDSCAN
		
		
		BEGIN TRANSACTION
		IF m.goapp.lAMVersion
		    SELE glmaster
		    = TABLEUPDATE(.T.)
		    SELE glbatches
		    = TABLEUPDATE(.T.)
		ENDIF
		SELE expense
		= TABLEUPDATE(.T.)
		SELE invhdr
		= TABLEUPDATE(.T.)
		SELE wellhist
		= TABLEUPDATE(.T.)
		SELE sysctl
		= TABLEUPDATE(.T.)
		SELE disbhist
		= TABLEUPDATE(.T.)
		SELE wellhist
		= TABLEUPDATE(.T.)
		SELECT prepayd
		= TABLEUPDATE(.T.)
		SELECT plugwellbal
		= TABLEUPDATE(.T.)
		SELECT checks
		TABLEUPDATE(.t.)
		END TRANSACTION
		
		THISFORM.oMessage.DISPLAY('JIB run: ' + lcYear + '/' + ALLT(STR(lnRunNo)) + ' is now open.')
		
		* Turn FoxAudit auditing on after the reopen
		   IF TYPE('oFoxAudit_APPDATA') = 'O'
		      oFoxAudit_APPDATA.lLogUpdates = m.goapp.lAuditTrail
		   ENDIF
		
		THISFORM.RELEASE()
		
		
	ENDPROC

	PROCEDURE cmdClose.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdReopen.Click
		thisform.reopen()
	ENDPROC

ENDDEFINE
