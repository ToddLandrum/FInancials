*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="importexp.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 688
	Left = 71
	Name = "Dataenvironment"
	Top = 100
	Width = 716

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "csrcthdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "csrcthdr", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "expcat", ;
		CursorSource = "expcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 293, ;
		Name = "Cursor10", ;
		Top = 282, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "importtypes", ;
		CursorSource = "importtypes", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor11", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "expense", ;
		BufferModeOverride = 5, ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 448, ;
		Name = "Cursor12", ;
		Top = 350, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "expsusp", ;
		BufferModeOverride = 5, ;
		CursorSource = "expsusp", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 301, ;
		Name = "Cursor13", ;
		Top = 441, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "apopt", ;
		CursorSource = "apopt", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 154, ;
		Name = "Cursor14", ;
		Top = 389, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\newdbc\appdata.dbc, ;
		Height = 90, ;
		Left = 32, ;
		Name = "Cursor17", ;
		Top = 477, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 449, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 570, ;
		Name = "Cursor4", ;
		Top = 20, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 437, ;
		Name = "Cursor5", ;
		Top = 167, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "csrctdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "csrctdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 125, ;
		Name = "Cursor6", ;
		Top = 20, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "appurchd", ;
		BufferModeOverride = 5, ;
		CursorSource = "appurchd", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 132, ;
		Name = "Cursor7", ;
		Top = 190, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "appurchh", ;
		BufferModeOverride = 5, ;
		CursorSource = "appurchh", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor8", ;
		Top = 140, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 555, ;
		Name = "Cursor9", ;
		Top = 289, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formexpimport AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdImport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="dCheckDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCvendorid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCvendname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblImport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboImportMap" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdMap" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkOneInvoice" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdVendor" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcVendorID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkPostQB" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkImportPmts" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboCashAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCashAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkVendorid" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: allocevenly		&& Allocate the MCF total evenly among the wells tied to this master meter
		*m: buildmeter		&& Builds list of wells and data already imported into meterdata.
		*m: calcallocation		&& Does the allocation
		*m: chkforsubmeter		&& Checks to see if the wells have any totals
		*m: createpayments		&& Creates the payment records and posting for the payments
		*m: dmexpense
		*m: dmincome		&& Post receipt to well income table.
		*m: excelexit
		*m: gasreceipts		&& Builds Cash Receipts from Imported Gas Data
		*m: getdetailkey		&& Gets the next primary key for appurchd
		*m: import		&& Imports the given format
		*m: importexcel		&& Import Excel Data
		*m: lookupoper
		*m: meter_report		&& Prints report of allocations done.
		*m: oglmaint_access
		*m: oilreceipts		&& Builds cash receipt from imported oil data
		*m: postbillam
		*m: postbilldm
		*m: postbillqb
		*m: postpayments
		*m: postrcpt
		*m: processcdex		&& Processes the importfile created by the import of a CDEX DAT file.
		*m: processcsv		&& Processes the importfile cursor created by importing an owner relations connect csv file.
		*m: qbpostbill
		*m: qbpostrec		&& Post receipt to QuickBooks
		*m: validateterms
		*p: ioperatorkpk
		*p: ioperatorpk
		*p: lqbnopost
		*p: ntotalimport
		*p: odist
		*p: oexcel
		*p: ofile		&& SWFile object
		*p: oglmaint
	*</DefinedPropArrayMethod>

	Caption = "Import Bills"
	DoCreate = .T.
	Height = 363
	ioperatorkpk = 0
	ioperatorpk = 0
	lconfirmsave = .F.
	lnonewask = .T.
	Name = "FormExpImport"
	ntotalimport = 0
	ofile = .NULL.		&& SWFile object
	oglmaint = .NULL.
	Width = 617
	_memberdata = <VFPData>
		<memberdata name="import" display="Import"/>
		<memberdata name="ofile" display="oFile"/>
		<memberdata name="processcsv" display="ProcessCSV"/>
		<memberdata name="processcdex" display="ProcessCDEX"/>
		<memberdata name="ioperatorpk" display="iOperatorPK"/>
		<memberdata name="ntotalimport" display="nTotalImport"/>
		<memberdata name="getdetailkey" display="GetDetailKey"/>
		<memberdata name="postbillqb" display="PostBillQB"/>
		<memberdata name="dmexpense" display="DMExpense"/>
		<memberdata name="postbilldm" display="PostBillDM"/>
		<memberdata name="postbillam" display="PostBillAM"/>
		<memberdata name="createpayments" display="CreatePayments"/>
		<memberdata name="postpayments" display="PostPayments"/>
		<memberdata name="oglmaint" display="oGLMaint"/>
		<memberdata name="oglmaint_access" display="oGLMaint_Access"/>
		<memberdata name="validateterms" display="ValidateTerms"/>
		</VFPData>
	cmdatamanager.Left = 4
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 13
	cmdatamanager.Top = 1
	cmlookupmanager.Left = 17
	cmlookupmanager.Name = "cmlookupmanager"
	cmlookupmanager.Top = 3
	MWRESIZE1.lblHighLight.Name = "lblHighLight"
	MWRESIZE1.lblShading.Name = "lblShading"
	MWRESIZE1.Left = 588
	MWRESIZE1.Name = "MWRESIZE1"
	MWRESIZE1.TabIndex = 14
	MWRESIZE1.Top = 348

	ADD OBJECT 'cboCashAcct' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		ControlSource = "", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 193, ;
		Margin = 2, ;
		Name = "cboCashAcct", ;
		TabIndex = 8, ;
		Top = 194, ;
		Visible = .F., ;
		Width = 353
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboImportMap' AS cbocomboboxcustom WITH ;
		Height = 22, ;
		Left = 192, ;
		Name = "cboImportMap", ;
		TabIndex = 9, ;
		Top = 234, ;
		Visible = .T., ;
		Width = 353
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkImportPmts' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Import Payments", ;
		Left = 266, ;
		Name = "chkImportPmts", ;
		TabIndex = 7, ;
		Top = 159, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkOneInvoice' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Create One Invoice for the Import", ;
		Left = 265, ;
		Name = "chkOneInvoice", ;
		TabIndex = 5, ;
		Top = 132, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkPostQB' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Don't Post To QuickBooks", ;
		Left = 367, ;
		Name = "chkPostQB", ;
		TabIndex = 19, ;
		Top = 11, ;
		Value = .F., ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkUseDate' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Use This Date Instead of Date in Import", ;
		Left = 265, ;
		Name = "chkUseDate", ;
		TabIndex = 4, ;
		Top = 104, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkVendorid' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Vendor ID is Being Imported In File", ;
		Left = 132, ;
		Name = "chkVendorid", ;
		Top = 12, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Height = 36, ;
		Left = 375, ;
		Name = "cmdExit", ;
		TabIndex = 12, ;
		Top = 312, ;
		Width = 84
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdImport' AS cmdcommandbuttoncustom WITH ;
		Caption = "Choose Data", ;
		Height = 36, ;
		Left = 168, ;
		Name = "cmdImport", ;
		TabIndex = 10, ;
		Top = 312, ;
		Width = 84
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdMap' AS cmdcommandbuttoncustom WITH ;
		Caption = "Mapping", ;
		Height = 36, ;
		Left = 276, ;
		Name = "cmdMap", ;
		TabIndex = 11, ;
		Top = 312, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdVendor' AS swlookupbutton WITH ;
		Left = 203, ;
		Name = "cmdVendor", ;
		TabIndex = 2, ;
		Top = 42, ;
		ZOrderSet = 26
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'dCheckDate' AS dpk WITH ;
		Left = 157, ;
		Name = "dCheckDate", ;
		TabIndex = 3, ;
		Top = 101
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 73, ;
		Name = "Glmaint", ;
		Top = 298
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCashAcct' AS lbllabelcustom WITH ;
		Caption = "Cash Acct", ;
		FontSize = 8, ;
		Left = 128, ;
		Name = "lblCashAcct", ;
		TabIndex = 6, ;
		Top = 196, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblCvendorid' AS lblfieldlabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Vendor", ;
		Height = 16, ;
		Left = 71, ;
		Name = "lblCvendorid", ;
		TabIndex = 17, ;
		Top = 44, ;
		Width = 38, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblImport' AS lbllabelcustom WITH ;
		Caption = "Import Map", ;
		Left = 127, ;
		Name = "lblImport", ;
		TabIndex = 18, ;
		Top = 237, ;
		Visible = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Bill Date", ;
		Left = 92, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 16, ;
		Top = 105
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'txtCvendname' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 248, ;
		Margin = 1, ;
		MaxLength = 40, ;
		Name = "txtCvendname", ;
		ReadOnly = .F., ;
		TabIndex = 15, ;
		Top = 42, ;
		Width = 352, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcVendorID' AS txtquickfill WITH ;
		clistexpression = vendor.cvendorid, ;
		clistworkarea = vendor, ;
		ControlSource = "", ;
		Format = "K!", ;
		Height = 20, ;
		InputMask = "XXXXXXXXXX", ;
		Left = 118, ;
		Name = "txtcVendorID", ;
		TabIndex = 1, ;
		Top = 42, ;
		Width = 79, ;
		ZOrderSet = 30
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		IF DODEFAULT()
		   thisform.cboImportMap.Requery()
		ENDIF 
	ENDPROC

	PROCEDURE allocevenly		&& Allocate the MCF total evenly among the wells tied to this master meter
	ENDPROC

	PROCEDURE buildmeter		&& Builds list of wells and data already imported into meterdata.
	ENDPROC

	PROCEDURE calcallocation		&& Does the allocation
	ENDPROC

	PROCEDURE chkforsubmeter		&& Checks to see if the wells have any totals
	ENDPROC

	PROCEDURE createpayments		&& Creates the payment records and posting for the payments
		LOCAL llReturn, loError, m.cacctno
		LOCAL cBatch, cCheckNo, cInvNum, cVendorID, cidappmd, cvendname, dBillDate, dPmtDate, nTotDisc
		LOCAL nTotDue, nTotPaid
		
		*
		* Build a list of payments from the import and create the payment records and posting for them
		*
		
		llReturn = .T.
		WAIT WINDOW NOWAIT 'Importing bill payments...'
		
		TRY
		   swselect('appmthdr',.T.)
		   swselect('appmtdet',.T.)
		
		   m.cacctno = THISFORM.cboCashAcct.VALUE
		   llVendor  = THISFORM.chkvendorid.VALUE
		
		
		   * Cursor of payments
		   SELECT SUM(nPayAmount) AS nPayAmount, cInvNum, dpaydate, cCheckNo, cVendorID ;
		      FROM importfile WHERE NOT EMPTY(cCheckNo) ;
		      INTO CURSOR temp1 ;
		      ORDER BY dpaydate, cVendorID, cInvNum, cCheckNo ;
		      GROUP BY dpaydate, cVendorID, cInvNum, cCheckNo
		
		   SELECT SUM(nPayAmount) AS nPayAmount, cInvNum, dpaydate, cCheckNo, cVendorID ;
		      FROM importfile WHERE NOT EMPTY(cCheckNo) ;
		      INTO CURSOR checkpmts ;
		      ORDER BY dpaydate, cVendorID, cCheckNo ;
		      GROUP BY dpaydate, cVendorID, cCheckNo
		
		   SELECT dpaydate, SPACE(8) AS cBatch, SUM(nPayAmount) AS nTotPaid ;
		      FROM temp1 ;
		      INTO CURSOR billpmts READWRITE ;
		      ORDER BY dpaydate ;
		      GROUP BY dpaydate
		
		   SELECT billpmts
		   SCAN
		      SCATTER MEMVAR
		
		      m.cBatch = getnextpk('BATCH')
		      REPLACE cBatch WITH m.cBatch
		
		      STORE m.dpaydate TO m.dBillDate, m.dPmtDate
		
		      m.nTotDue  = m.nTotPaid
		      m.nTotDisc = 0
		      m.ndisctot  = 0
		      m.ndisctaken = 0
		      m.ddiscdate = {}
		      m.lNewPmt  = .T.
		      m.cidchec  = ''
		
		      INSERT INTO appmthdr FROM MEMVAR
		
		      SELECT temp1
		      SCAN FOR dpaydate = m.dpaydate
		         SCATTER MEMVAR
		
		         IF NOT llVendor
		            m.cVendorID = THISFORM.txtcVendorID.VALUE
		         ENDIF
		
		         swselect('vendor')
		         SET ORDER TO cVendorID
		         IF SEEK(m.cVendorID)
		            m.cvendname = cvendname
		         ELSE
		            m.cvendname = 'Unknown'
		         ENDIF
		
		         m.cInvNum  = ALLTRIM(m.cInvNum)
		         m.namtpaid = m.nPayAmount
		         SELECT appmtdet
		         SET ORDER TO cidarpmd
		         SET DELETED OFF
		         m.cidappmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AP Payment Detail')
		         DO WHILE SEEK(m.cidappmd)
		            m.cidappmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AP Payment Detail')
		         ENDDO
		         SET DELETED ON
		         SELECT appurchh
		         LOCATE FOR cVendorID = m.cVendorID AND cInvNum = m.cInvNum
		         IF FOUND()
		            REPLACE npayments WITH m.nPayAmount, ;
		               ninvbal   WITH ninvtot - m.nPayAmount
		            m.cbilltoken = cBatch
		         ELSE
		            m.cbilltoken = ''
		            LOOP
		         ENDIF
		         
		         m.ccheckno = PADL(ALLTRIM(m.ccheckno),10,' ')
		
		         THISFORM.glmaint.cId        = m.cVendorID
		         THISFORM.glmaint.cidType    = 'V'
		         THISFORM.glmaint.dCheckDate = appmthdr.dPmtDate
		         THISFORM.glmaint.dPostDate  = appmthdr.dPmtDate
		         THISFORM.glmaint.cSource    = 'AP'
		         THISFORM.glmaint.cPayee     = m.cvendname
		         THISFORM.glmaint.nAmount    = m.namtpaid
		         THISFORM.glmaint.cEntryType = 'C'
		         THISFORM.glmaint.lPrinted   = .T.
		         THISFORM.glmaint.cacctno    = appmthdr.cacctno
		         THISFORM.glmaint.cBatch     = m.cBatch
		         THISFORM.glmaint.ccheckno   = m.ccheckno
		
		         *  Add the entry to the checks table
		         THISFORM.glmaint.addcheck()
		
		         *  Get the key of the check just created
		         *  and put it in the payment detail rec.
		         m.cidchec               = THISFORM.glmaint.GETKEY()
		         
		         INSERT INTO appmtdet FROM MEMVAR
		      ENDSCAN
		   ENDSCAN
		CATCH TO loError
		   MESSAGEBOX('Error: ' + loError.MESSAGE + CHR(13) + 'Line No: ' + TRANSFORM(loError.LINENO),16,'CreatePayments')
		   llReturn = .F.
		ENDTRY
		WAIT CLEAR
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE dmexpense
		LPARAMETERS tcBatch
		LOCAL lcBatch, lcYear, lcPeriod, m.cOwnerID, lcWellStat
		LOCAL lAPTran, lAllocated, lClosed, lFixed, lOneMan, lcWellID1, lcWellID2, llAllocExp, llFound
		LOCAL llReturn, loError, oWellInv
		*:Global cBatch, cCateg, cExpClass, cMemo, cPaidByCk, cPayee, cPeriod, cPrdPaid, cRunYearJIB
		*:Global cRunYearRev, cWellID, cYear, cidexpe, cidexph, cidexps, crefid, cvendorid, dExpDate
		*:Global dPostDate, nAmount, nRunNoJIB, nRunNoRev, nSaltWater
		
		*********************************************************************
		*  Adds the expense entries to the disbursement manager EXPSUSP or
		*  EXPENSE tables depending on whether the production year and
		*  period are specified.
		*********************************************************************
		llSendToAllocation = m.goApp.lSendToAllocate
		
		TRY
		   swselect('afeopt')
		   GO TOP
		   llAllocExp = lAllocExp
		   oWellInv = CREATEOBJECT('swbizobj_wellinv')
		
		   *  Check to see if expenses entered for wells were allocated
		   *  If so, and the period isn't closed, delete it.  Otherwise
		   *  let the user know he can't delete this entry.
		   lcBatch = tcBatch
		   swselect('appurchh')
		   SET ORDER TO cbatch
		   SEEK(lcBatch)
		
		   *  Call distproc to create the (invtmp) and (wellwork) cursors
		   swselect('wells')
		   SET ORDER TO cWellID
		   GO TOP
		   lcWellID1 = cWellID
		   GO BOTT
		   lcWellID2 = cWellID
		
		   THISFORM.oDist = CREATEOBJECT('distproc', lcWellID1, lcWellID2, ;
		      '01', '1980', '00', 'W', DATE(), .T., 0)
		
		   m.cvendorid   = appurchh.cvendorid
		
		   swselect('vendor')
		   SET ORDER TO cvendorid
		   IF SEEK(m.cvendorid)
		      lcPayee = cvendname
		   ELSE
		      lcPayee = 'Unknown'
		   ENDIF
		   m.dExpDate    = appurchh.dinvdate
		   lcYear        = TRANSFORM(YEAR(m.dExpDate))
		   lcPeriod      = PADL(ALLTRIM(TRANSFORM(MONTH(m.dExpDate))), 2, '0')
		   m.crefid      = appurchh.cinvnum
		   m.cPayee      = lcPayee
		   m.lAPTran     = .T.
		   m.cbatch      = lcBatch
		   m.dPostDate   = appurchh.dPostDate
		   m.cMemo       = ''
		   m.cPaidByCk   = ''
		   m.cPrdPaid    = ''
		   m.lFixed      = .F.
		   m.lClosed     = .F.
		   m.lAllocated  = .F.
		   m.nRunNoRev   = 0
		   m.nRunNoJIB   = 0
		   m.cRunYearRev = ''
		   m.cRunYearJIB = ''
		
		   swselect('appurchd')
		   SCAN FOR cbatch == lcBatch AND NOT lItemDetail AND NOT EMPTY(cUnitNo) AND NOT EMPTY(cCatCode)
		      SCATTER MEMVAR
		
		      IF EMPTY(m.cprodyear) or EMPTY(m.cprodperiod) OR llSendToAllocation 
		         llSendToAllocation = .T.
		      ENDIF 
		            
		      * Only fill in blank decks when sending straight to the income and expense tables
		      IF EMPTY(m.cDeck) AND NOT llSendToAllocation
		         m.cDeck = oWellInv.DOIDeckNameLookup(m.cProdyear, m.cProdperiod, m.cWellID)
		      ENDIF
		
		      *
		      *  Don't process any non-well expenses
		      *
		      swselect('wells')
		      SET ORDER TO cWellID
		      IF NOT SEEK(m.cUnitNo)
		         LOOP
		      ELSE
		         lcWellStat = wells.cWellStat  &&  Store current well status, so we know whether to send it to the allocation file or not
		      ENDIF
		
		      *
		      *  Don't process any expenses that aren't tied
		      *  to a valid expense category or AFE category code
		      *
		      swselect('expcat')
		      SET ORDER TO cCatCode
		      IF NOT SEEK(m.cCatCode)
		         LOOP
		      ELSE
		         IF (lAFEType AND NOT llAllocExp) AND m.goapp.lafeopt
		            LOOP
		         ENDIF
		         m.cCateg = cCateg
		
		         IF EMPTY(m.cExpClass)  &&  If they somehow get a blank expense class, use the current setting - BH 10/11/05
		            m.cExpClass = cExpClass
		         ENDIF
		      ENDIF
		
		      m.cWellID    = m.cUnitNo
		      m.nSaltWater = m.nSaltBBL
		      m.cMemo      = m.citemdesc
		
		      IF EMPTY(m.cOwnerID)
		         m.nAmount = swNetExp(m.nExtension, m.cWellID, .F., m.cExpClass, 'B', .F., m.cOwnerID, m.cCatCode, m.cDeck)
		      ELSE
		         m.nAmount = m.nExtension
		      ENDIF
		
		      IF EMPTY(m.cProdyear) OR EMPTY(m.cProdperiod)
		         m.cYear   = lcYear
		         m.cPeriod = lcPeriod
		      ELSE
		         m.cYear   = m.cProdyear
		         m.cPeriod = m.cProdperiod
		      ENDIF
		
		      IF NOT EMPTY(m.cOwnerID)
		         m.cExpClass = '0' && Force one-man items to class 0
		         m.lOneMan = .T.
		      ELSE
		         m.lOneMan = .F.
		      ENDIF
		
		      IF NOT EMPTY(m.cProdyear) AND NOT EMPTY(m.cProdperiod) AND NOT m.goapp.lSendToAllocate AND INLIST(lcWellStat, 'A', 'V')
		         m.cidexpe = GetNextPK('EXPENSE')
		         m.cYear   = m.cProdyear
		         m.cPeriod = m.cProdperiod
		         INSERT INTO expense FROM MEMVAR
		      ELSE
		         m.cidexps = GetNextPK('EXPENSE')
		         m.cYear   = m.cProdyear
		         m.cPeriod = m.cProdperiod
		         INSERT INTO expsusp FROM MEMVAR
		      ENDIF
		   ENDSCAN
		   llReturn = .T.
		CATCH TO loError
		   DO errorlog WITH 'DMExpense', loError.LINENO, 'Enter Bills', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to import the bill at this time. Check the System Log found under Help for more information.', 16, 'Problem Encountered')
		   llReturn = .F.
		ENDTRY
		
		RETURN llReturn
		
	ENDPROC

	PROCEDURE dmincome		&& Post receipt to well income table.
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		
		if nerror = 1737
		   dodefault(nerror,cmethod,nline)
		   return
		endif
		   
		dodefault(nerror,cmethod,nline)
		
	ENDPROC

	PROCEDURE excelexit
		thisform.oExcel.QUIT()
		
		thisform.oExcel = .Null.
	ENDPROC

	PROCEDURE gasreceipts		&& Builds Cash Receipts from Imported Gas Data
	ENDPROC

	PROCEDURE getdetailkey		&& Gets the next primary key for appurchd
	ENDPROC

	PROCEDURE import		&& Imports the given format
		LOCAL lcFile, loError, llReturn
		
		THISFORM.nTotalImport = 0
		
		llReturn     = .T.
		
		
		TRY
			lcMapName = THISFORM.cboImportMap.VALUE
		
			lcFile = GETFILE('CSV,XLS,XLSX', 'Choose the File To Import:', 'Choose', 0, 'Where is import file?')
		
			IF EMPTY(lcFile)
				llReturn = .F.
				EXIT
			ENDIF
		
			lcOperator = THISFORM.txtcVendName.VALUE
		
			llReturn = m.goApp.oImport.ImportMap(lcFile, lcMapName, 'EXP', THISFORM.DATASESSIONID)
			IF NOT llReturn
				EXIT
			ENDIF
		
			llReturn = THISFORM.ProcessCSV()
			IF NOT llReturn
				EXIT
			ENDIF
			
			IF NOT m.goApp.lQBVersion
			   swselect('appmthdr',.T.)
			   swselect('appmtdet',.T.)
			ENDIF 
			IF m.goApp.lAMVersion
			   swselect('glmaster',.T.)
			ENDIF 
		
			DO CASE
				CASE m.goApp.lAMVersion
					llReturn = THISFORM.PostBillAM()
					IF llReturn AND thisform.chkImportPmts.value
		       		   llReturn = thisform.CreatePayments()
		       		   IF llReturn
		          		  llReturn = thisform.PostPayments()
		          	   ENDIF
		          	ENDIF
				CASE m.goApp.lQBVersion
					IF NOT THISFORM.chkpostqb.VALUE
						llReturn = THISFORM.PostBillQB()
						IF llReturn
							llReturn = THISFORM.PostBillDM()
						ENDIF
					ELSE
						llReturn = THISFORM.PostBillDM()
					ENDIF
				OTHERWISE
					llReturn = THISFORM.PostBillDM()
			ENDCASE
		
			IF llReturn
		
				lnTotalBills = RECCOUNT('curNewBills')
				IF thisform.chkImportPmts.Value 
		    	   lnTotalPmts	 = RECCOUNT('checkpmts')
				   SELECT SUM(nPayAmount) as nPmts FROM checkpmts INTO CURSOR temppmts
		   		   lnPmtTotal = nPmts
		   		ELSE
		   		   lnPmtTotal = 0
		   		   lnTotalPmts = 0
		   		ENDIF    
		   		
				SELECT SUM(nInvTot) AS nTotal FROM curNewBills INTO CURSOR temp
				lnTotal = nTotal
				IF llReturn
				    IF m.goapp.lAmVersion
		       		   MESSAGEBOX('Imported: ' + TRANSFORM(lnTotalBills) + IIF(lnTotalBills > 1, ' Bills ', ' Bill ') + ;
						    ' Totaling: ' + ALLTRIM(TRANSFORM(lnTotal, '999,999,999.99')) + ' and ' + TRANSFORM(lnTotalPmts) + ' Payments totaling: ' + ;
						    ALLTRIM(TRANSFORM(lnPmtTotal, '999,999,999.99')), 64, 'Import Successful')
					ELSE
					   MESSAGEBOX('Imported: ' + TRANSFORM(lnTotalBills) + IIF(lnTotalBills > 1, ' Bills ', ' Bill ') + ;
						    ' Totaling: ' + ALLTRIM(TRANSFORM(lnTotal, '999,999,999.99')), 64, 'Import Successful')
					ENDIF 	    
				ELSE
					MESSAGEBOX('Imported: ' + TRANSFORM(lnTotalBills) + IIF(lnTotalBills > 1, ' Bills ', ' Bill ') + ;
						    ' Totaling: ' + ALLTRIM(TRANSFORM(lnTotal, '999,999,999.99')), 64, 'Import Partially Successful')
				ENDIF
			ENDIF
		
			IF llReturn
				TABLEUPDATE(.T., .T., 'appurchh')
				TABLEUPDATE(.T., .T., 'appurchd')
				TABLEUPDATE(.T., .T., 'expense')
				TABLEUPDATE(.T., .T., 'expsusp')
				IF NOT m.goapp.lQBVersion
				   TABLEUPDATE(.T., .T., 'appmthdr')
				   TABLEUPDATE(.T., .T., 'appmtdet')
				ENDIF    
				TABLEUPDATE(.T., .T., 'checks')
				IF m.goapp.lAMVersion
				   TABLEUPDATE(.T., .T., 'glmaster')
				ENDIF 
			ELSE
				TABLEREVERT(.T., 'appurchh')
				TABLEREVERT(.T., 'appurchd')
				TABLEUPDATE(.T., .T., 'expense')
				TABLEUPDATE(.T., .T., 'expsusp')
				IF NOT m.goapp.lQBVersion
				   TABLEREVERT(.T., 'appmthdr')
				   TABLEREVERT(.T., 'appmtdet')
				ENDIF    
				TABLEREVERT(.T., 'checks')
				IF m.goapp.lAMVersion
		  		   TABLEREVERT(.T., 'glmaster')
		  		ENDIF 
			ENDIF
		
		CATCH TO loError
			llReturn = .F.
			DO errorlog WITH 'Import', loError.LINENO, 'Import Expenses', loError.ERRORNO, loError.MESSAGE, '', loError
			MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
				    'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE importexcel		&& Import Excel Data
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   IF m.goapp.lQBVersion AND m.goapp.oqb.lqbactive = .t.
		      thisform.chkpostQB.Visible = .t.
		   ELSE
		      thisform.chkpostQB.Visible = .f.
		      thisform.chkPostQB.Value      = .t.   
		   ENDIF
		   IF NOT m.goApp.lAMVersion
		      thisform.chkImportPmts.Visible = .f.
		      thisform.chkvendorid.Visible = .f.
		   ENDIF 
		ENDIF 
	ENDPROC

	PROCEDURE Load
		IF DODEFAULT()
		   IF m.goapp.lQBVersion
		*  Get the cursor of QuickBooks Accounts
		      m.goapp.oQB.QBAccounts('',.F.,.T.,THISFORM.DATASESSIONID)
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE lookupoper
		LPARAMETERS toControl
		
		PRIVATE llok
		
		llok = .f.
		
		lcList = 'copername'
		
		swselect('operator')
		SET ORDER to copername
		
		
		DO FORM picklist WITH 'operator', lcList, toControl.value, 1
		
		IF llOK
		   toControl.value = operator.copername
		   thisform.ioperatorpk = operator.ioperatorpk
		ENDIF 
	ENDPROC

	PROCEDURE meter_report		&& Prints report of allocations done.
	ENDPROC

	PROCEDURE oglmaint_access
		
		IF VARTYPE(this.oGLMaint) # 'O'
		   this.oGLMaint = CREATEOBJECT('glmaint')
		ENDIF 
		
		return This.oGLMaint
		
	ENDPROC

	PROCEDURE oilreceipts		&& Builds cash receipt from imported oil data
	ENDPROC

	PROCEDURE postbillam
		LOCAL lcBatch, lcAPAcct, lcTaxAcct, llReturn, lcSelect, lnRecNo, lcFilter
		LOCAL lctype, lcyear, lcrun, m.cBatch
		LOCAL ldPostDate, llRetVal, lnBalance, loError
		*:Global cdeptno, nAmount
		
		llReturn = .T.
		WAIT WINDOW NOWAIT 'Importing bills...'
		TRY
		
		   SELECT curNewBills
		   SCAN
		      m.cBatch = cBatch
		
		      SELECT appurchh
		      SCAN FOR cBatch == m.cBatch
		
		         lcBatch = appurchh.cBatch
		
		         IF EMPTY(appurchh.cVendorID)
		            * THISFORM.oMessage.warning('You must specify a vendor before saving a bill.')
		            llReturn = .F.
		            EXIT
		         ENDIF
		
		         IF appurchh.nInvTot = 0
		            swselect('appurchd')
		            LOCATE FOR cBatch == lcBatch AND nextension # 0
		            IF NOT FOUND()
		               WAIT WIND NOWAIT 'You cannot save a zero amount invoice....'
		               llReturn = .F.
		               EXIT
		            ENDIF
		         ENDIF
		
		         swselect('vendor')
		         LOCATE FOR cVendorID == appurchh.cVendorID
		         IF FOUND()
		            IF vendor.lIntegGL
		               IF NOT THISFORM.oMessage.CONFIRM('This vendor is marked to post to the G/L. If this bill is saved ' + ;
		                       'it will have to be paid through Pay Bills instead of being automatically ' + ;
		                       'posted as revenue for this vendor. Do you want to continue?')
		                  llReturn = .F.
		                  EXIT
		               ENDIF
		            ENDIF
		         ENDIF
		
		         lcSelect = SELECT()
		
		
		         swselect('apopt')
		         swselect('appurchh')
		         REPLACE appurchh.dpostdate WITH appurchh.dinvdate
		
		*  Make sure the period or year isn't closed
		         IF NOT THISFORM.glmaint.CheckPeriod(appurchh.dpostdate)
		            THISFORM.oMessage.warning('This post date is invalid. Either the fiscal year or period represented by this date has been closed.')
		            llReturn = .F.
		            EXIT
		         ENDIF
		
		         IF llReturn
		
		            lnBalance = appurchh.nInvTot - appurchh.nPayments
		
		*  Delete the G/L journal entries for this invoice
		            THISFORM.glmaint.delbatch(lcBatch, 'AP')
		
		* Get the default A/P account
		            swselect('apopt')
		            GO TOP
		            lcAPAcct     = cAPAcct
		
		*  Create the G/L journal entries for this invoice
		*  A/P entry
		            THISFORM.glmaint.cSource = 'AP'
		            THISFORM.glmaint.cBatch  = lcBatch
		
		* Check the option to use the invoice date as post date
		            ldPostDate    = appurchh.dinvdate
		
		            THISFORM.glmaint.dGLDate = ldPostDate
		
		            THISFORM.glmaint.cReference = ALLTRIM(appurchh.cinvnum) + ': ' + appurchh.cReference
		            THISFORM.glmaint.cBunch     = THISFORM.cBunch
		
		*  Detail Lines
		            swselect('appurchd')
		            lcFilter = FILTER()
		            SET FILTER TO
		            lnRecNo = RECNO()
		            SCAN FOR cBatch == lcBatch
		               THISFORM.glmaint.cBatch     = lcBatch
		               THISFORM.glmaint.dGLDate    = ldPostDate
		               THISFORM.glmaint.cReference = 'Pur: ' + ALLTRIM(appurchh.cinvnum)
		               THISFORM.glmaint.cDesc      = appurchd.citemdesc
		               THISFORM.glmaint.cAcctNo    = appurchd.cAcctNo
		               THISFORM.glmaint.cId        = appurchh.cVendorID
		               THISFORM.glmaint.cUnitNo    = appurchd.cUnitNo
		               THISFORM.glmaint.cCatCode   = appurchd.cCatCode
		               THISFORM.glmaint.nAmount    = appurchd.nextension
		               THISFORM.glmaint.cdeptno    = appurchd.cdeptno
		               THISFORM.glmaint.updatebatch()
		            ENDSCAN
		
		            CREATE CURSOR tempdept ;
		               (cdeptno  C(8), ;
		                 nAmount  N(12, 2))
		
		            swselect('appurchd')
		            SCAN FOR cBatch == lcBatch
		               m.cdeptno = cdeptno
		               m.nAmount = nextension
		               INSERT INTO tempdept FROM MEMVAR
		            ENDSCAN
		            GO TOP
		
					SELECT  cdeptno,;
							SUM(nAmount) AS nAmount ;
						FROM tempdept ;
						INTO CURSOR temp ;
						ORDER BY cdeptno ;
						GROUP BY cdeptno
		
		*  A/P entry
		            THISFORM.glmaint.cSource    = 'AP'
		            THISFORM.glmaint.cBatch     = lcBatch
		            THISFORM.glmaint.dGLDate    = ldPostDate
		            THISFORM.glmaint.cReference = ALLTRIM(appurchh.cinvnum) + ': ' + appurchh.cReference
		            THISFORM.glmaint.cDesc      = THISFORM.txtcVendName.VALUE
		            THISFORM.glmaint.cAcctNo    = lcAPAcct
		            THISFORM.glmaint.cId        = appurchh.cVendorID
		            THISFORM.glmaint.mNotes     = 'appurchh.mnotes'
		            THISFORM.glmaint.cUnitNo    = ''
		            THISFORM.glmaint.cCatCode   = ''  &&  Blank out the cat code for the AP entry - BH 10/22/2008
		
		
		            SELECT temp
		            SCAN
		               SCATTER MEMVAR
		               THISFORM.glmaint.cdeptno = m.cdeptno
		               THISFORM.glmaint.nAmount = m.nAmount * -1
		               THISFORM.glmaint.updatebatch()
		            ENDSCAN
		
		*
		*  Check to make sure the batch balances
		*
		            llReturn = THISFORM.glmaint.chkBalance()
		
		            IF !llReturn
		               MESSAGEBOX('The G/L batch for this bill was not in balance. Unable to save the bill at this time.', 16, 'Problem Saving')
		            ENDIF
		         ENDIF
		      ENDSCAN
		      
		      lcBatch  = m.cBatch
		      llReturn = THISFORM.DMExpense(m.cBatch)
		
		   ENDSCAN
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'PostBillAM', loError.LINENO, 'ImportExp', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to import the bill at this time. Check the System Log found under Help for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		WAIT clear
		RETURN (llReturn)
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE postbilldm
		
		
		SELECT curNewBills
		SCAN
		    lcBatch  = cBatch
		    llReturn = THISFORM.DMExpense(lcBatch)
		ENDSCAN
		
		IF llReturn
		    TABLEUPDATE(.T., .F., 'Appurchh')
		    TABLEUPDATE(.T., .F., 'Appurchd')
		    TABLEUPDATE(.T., .F., 'Expense')
		    TABLEUPDATE(.T., .F., 'Expsusp')
		ELSE
		    TABLEREVERT(.T., 'Appurchh')
		    TABLEREVERT(.T., 'Appurchd')
		    TABLEREVERT(.T., 'Expense')
		    TABLEREVERT(.T., 'Expsusp')
		ENDIF
	ENDPROC

	PROCEDURE postbillqb
		LOCAL lcbatch, lcapacct, lctaxacct, llreturn, lcselect, lnrecno, lcfilter
		LOCAL loqbsm, llDelete
		LOCAL lobilladd AS 'qbfc5.ibilladd'
		LOCAL lcAPListID, lcCatchAll, lcListID, lcMessage, lcidterm, lcreq, lcrunno, lctype, lcxml, lcyear
		LOCAL llResult, loError, loaddresp, lobilldel, lobillline, lobilllist, locreditline, locreditlist
		LOCAL lodelresp, lonewbill, lonewcredit, lorequest, loresp, loresponse, lovendorcreditadd, llDebug
		*:Global ctxnid
		
		IF thisform.chkpostQB.Value = .t.
		   RETURN .T.
		ENDIF 
		
		IF m.goapp.oqb.lqbactive = .f.
		   MESSAGEBOX('QuickBooks is not connected to SherWare. The import cannot complete unless QuickBooks ' + ;
		              'is connected or the option to not post to QuickBooks is chosen.',16,'QuickBooks Not Connected')
		   RETURN .f.
		ENDIF 
		           
		llreturn = .T.
		swselect('apopt')
		lcAPListID = capacct
		WAIT WINDOW NOWAIT 'Importing bills...'
		*  Get the catch-all account
		swselect('glopt')
		lcCatchAll = cSuspense
		TRY
		    SELECT curNewBills
		    SCAN
		        m.cBatch = cBatch
		
		        SELECT appurchh
		        SCAN FOR cBatch == m.cBatch
		
		
		            lcbatch    = appurchh.cBatch
		
		            IF EMPTY(lcAPListID)
		                THISFORM.oMessage.severe('Please choose a valid A/P account under A/P Preferences. Then import again.')
		                llreturn = .F.
		                EXIT
		            ENDIF
		
		            lcselect   = SELECT()
		
		            IF appurchh.ninvtot = 0
		                swselect('appurchd')
		                LOCATE FOR cBatch == lcbatch AND nextension <> 0
		                IF NOT FOUND()
		                    WAIT WIND NOWAIT 'You cannot save a zero amount invoice....'
		                    llreturn = .F.
		                    EXIT
		                ENDIF
		            ENDIF
		
		            WAIT WINDOW NOWAIT 'Saving Changes, Please Wait.....'
		
		** Do we have an active connection to QuicBooks?
		            IF m.goapp.oQB.lqbactive
		
		                IF m.goapp.oQB.oqbsm.IsErrorRecoveryInfo()
		                    loresp     = m.goapp.oQB.oqbsm.geterrorrecoverystatus()
		                    lcxml      = loresp.toxmlstring()
		                    loresponse = loresp.responselist.getat(0)
		                    IF loresponse.statuscode = 0
		                        lcreq  = m.goapp.oQB.oqbsm.getsavedmsgsetrequest()
		                        m.goapp.oQB.oqbsm.ClearErrorRecovery()
		                    ELSE
		                        MESSAGEBOX(lcxml, 48, 'Error Recovery Info')
		                    ENDIF
		                ENDIF
		
		* get a message set request object (version 1.1 xml)
		                lorequest = m.goapp.oQB.oQBRequest
		
		* set the on error attribute for the request
		                lorequest.ATTRIBUTES.onerror = 1
		                lorequest.clearrequests()
		
		
		                IF NOT appurchh.lNoQBPost
		
		                    lorequest.clearrequests()
		
		                    IF appurchh.ninvtot > 0
		*  Setup the bill add request
		                        lobilladd = lorequest.appendbilladdrq()
		
		*  Get the vendor listid
		                        swselect('vendor')
		                        LOCATE FOR cvendorid = appurchh.cvendorid
		                        IF NOT FOUND()
		                            WAIT WIND 'Vendor: ' + appurchh.cvendorid + ' not found in vendor file.'
		                            lorequest.clearrequests()
		                            llreturn = .F.
		                            EXIT
		                        ENDIF
		
		                        lobilladd.vendorref.listid.setvalue(vendor.clistid)
		
		                        IF EMPTY(appurchh.dinvdate)
		                           SELECT appurchh
		                           REPLACE dinvdate WITH DATE()
		                        ENDIF 
		                        lobilladd.txndate.setvalue(appurchh.dinvdate)
		                        
		                        IF EMPTY(appurchh.dduedate)
		                           SELECT appurchh
		                           REPLACE dduedate WITH DATE()
		                        ENDIF 
		                        lobilladd.duedate.setvalue(appurchh.dduedate)
		                        lobilladd.refnumber.setvalue(appurchh.cinvnum)
		                        lobilladd.MEMO.setvalue(appurchh.creference)
		
		* Set the default A/P Account
		                        IF NOT EMPTY(lcAPListID)
		                            lobilladd.APAccountRef.listid.setvalue(lcAPListID)
		                        ENDIF
		
		* Get terms
		                        lcidterm = appurchh.cidterm
		                        swselect('terms')
		                        LOCATE FOR ALLTRIM(clistid) == ALLTRIM(lcidterm)
		                        IF FOUND()
		                            lcidterm = terms.clistid
		                            lobilladd.termsref.listid.setvalue(lcidterm)
		                        ENDIF
		
		                        lobilllist = lobilladd.expenselineaddlist
		*    loBillLine = loBillList.APPEND
		
		*  Add detail lines to bill
		                        swselect('appurchd')
		                        SCAN FOR cBatch == lcbatch
		                            SCATTER MEMVAR
		                            lobillline = lobilllist.APPEND
		                            IF NOT EMPTY(appurchd.cacctlistid)
		                                lobillline.accountref.listid.setvalue(appurchd.cacctlistid)
		                            ELSE
		                                lobillline.accountref.listid.setvalue(lcCatchAll)
		                            ENDIF
		                            lobillline.amount.setvalue(appurchd.nextension)
		
		                            IF NOT EMPTY(appurchd.cunitno)
		                                SELE wells
		                                LOCATE FOR cwellid = appurchd.cunitno
		                                IF FOUND()
		                                    lobillline.classref.listid.setvalue(wells.clistid)
		                                ENDIF
		                            ENDIF
		
		                            IF NOT EMPTY(appurchd.ccatcode)
		                                SELE expcat
		                                LOCATE FOR ccatcode = appurchd.ccatcode
		                                IF FOUND()
		                                    lobillline.MEMO.setvalue(ALLT(expcat.ccateg) + ' ' + appurchd.cprodyear + '/' + appurchd.cprodperiod)
		                                ENDIF
		                            ENDIF
		                        ENDSCAN
		
		                        lcxml      = lorequest.toxmlstring()
		                        loresponse = m.goapp.oQB.oqbsm.dorequests(lorequest)
		                        loaddresp  = loresponse.responselist.getat(0)
		                        IF loaddresp.statuscode = 0
		                            WAIT WIND NOWAIT 'Bill successfully added in QuickBooks'
		
		                            lonewbill = loaddresp.DETAIL
		                            m.ctxnid  = lonewbill.txnid.getvalue()
		                            m.goapp.oQB.oqbsm.ClearErrorRecovery()
		                            SELE appurchh
		                            REPL ctxnid WITH m.ctxnid
		                            = TABLEUPDATE(.T.)
		                        ELSE
		                            IF 'object' $ LOWER(loaddresp.StatusMessage)
		                                lcListID = SUBSTR(loaddresp.StatusMessage, AT('"', loaddresp.StatusMessage) + 1, AT('"', loaddresp.StatusMessage, 2) - (AT('"', loaddresp.StatusMessage) + 1))
		                                llResult = m.goapp.oQB.QBListID(lcListID, THISFORM.DATASESSIONID)
		                                IF llResult
		                                    SELECT QBListID
		                                    IF QBListID.ctype = 'Account'
		                                        lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' specified in the ' + ;
		                                            'QB Posting Preferences was not found in QuickBooks. Please select a new account ' + ;
		                                            'and try to save the bill again.'
		                                    ELSE
		                                        lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' was not found in QuickBooks. ' + ;
		                                            'Please synchronize the ' + ALLTRIM(QBListID.ctype) + ' file and try to save the bill again.'
		                                    ENDIF
		                                    THISFORM.oMessage.severe(lcMessage)
		                                ELSE
		                                    MESSAGEBOX(loaddresp.StatusMessage, 48, 'Unable to Save Bill')
		                                ENDIF
		                            ELSE
		                                MESSAGEBOX(loaddresp.StatusMessage, 48, 'Unable to Save Bill')
		                            ENDIF
		                            m.goapp.oQB.oqbsm.ClearErrorRecovery()
		                            llreturn = .F.
		                            EXIT
		                        ENDIF
		                    ELSE
		*  Setup the credit add request
		                        lovendorcreditadd = lorequest.appendvendorcreditaddrq()
		
		*  Get the vendor listid
		                        swselect('vendor')
		                        LOCATE FOR cvendorid = appurchh.cvendorid
		                        IF FOUND()
		                            lovendorcreditadd.vendorref.listid.setvalue(vendor.clistid)
		                        ELSE
		                            WAIT WIND 'Vendor: ' + appurchh.cvendorid + ' not found in vendor file.'
		                            llreturn = .F.
		                            EXIT
		                        ENDIF
		
		                        lovendorcreditadd.txndate.setvalue(appurchh.dinvdate)
		                        lovendorcreditadd.refnumber.setvalue(appurchh.cinvnum)
		                        lovendorcreditadd.MEMO.setvalue(appurchh.creference)
		                        locreditlist = lovendorcreditadd.expenselineaddlist
		
		*  Add detail lines to bill
		                        swselect('appurchd')
		                        SCAN FOR cBatch == lcbatch
		                            SCATTER MEMVAR
		                            locreditline = locreditlist.APPEND
		                            IF NOT EMPTY(appurchd.cacctlistid)
		                                locreditline.accountref.listid.setvalue(appurchd.cacctlistid)
		                            ELSE
		                                locreditline.accountref.listid.setvalue(lcCatchAll)
		                            ENDIF
		                            locreditline.amount.setvalue(appurchd.nextension * -1)
		
		                            IF NOT EMPTY(appurchd.cunitno)
		                                SELE wells
		                                LOCATE FOR cwellid = appurchd.cunitno
		                                IF FOUND()
		                                    locreditline.classref.listid.setvalue(wells.clistid)
		                                ENDIF
		                            ENDIF
		
		                            IF NOT EMPTY(appurchd.ccatcode)
		                                SELE expcat
		                                LOCATE FOR ccatcode = appurchd.ccatcode
		                                IF FOUND()
		                                    locreditline.MEMO.setvalue(ALLT(expcat.ccateg) + ' ' + appurchd.cprodyear + '/' + appurchd.cprodperiod)
		                                ENDIF
		                            ENDIF
		                        ENDSCAN
		
		                        loresponse = m.goapp.oQB.oqbsm.dorequests(lorequest)
		                        loaddresp  = loresponse.responselist.getat(0)
		
		                        IF loaddresp.statuscode = 0
		                            WAIT WIND NOWAIT 'Vendor Credit successfully added in QuickBooks'
		
		                            lonewcredit = loaddresp.DETAIL
		                            m.ctxnid    = lonewcredit.txnid.getvalue()
		                            m.goapp.oQB.oqbsm.ClearErrorRecovery()
		                            SELE appurchh
		                            REPL ctxnid WITH m.ctxnid
		                            = TABLEUPDATE(.T.)
		                        ELSE
		                            IF 'object' $ LOWER(loaddresp.StatusMessage)
		                                lcListID = SUBSTR(loaddresp.StatusMessage, AT('"', loaddresp.StatusMessage) + 1, AT('"', loaddresp.StatusMessage, 2) - (AT('"', loaddresp.StatusMessage) + 1))
		                                llResult = m.goapp.oQB.QBListID(lcListID, THISFORM.DATASESSIONID)
		                                IF llResult
		                                    SELECT QBListID
		                                    IF QBListID.ctype = 'Account'
		                                        lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' specified in the ' + ;
		                                            'QB Posting Preferences was not found in QuickBooks. Please select a new account ' + ;
		                                            'and try to save the credit again.'
		                                    ELSE
		                                        lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' was not found in QuickBooks. ' + ;
		                                            'Please synchronize the ' + ALLTRIM(QBListID.ctype) + ' file and try to save the credit again.'
		                                    ENDIF
		                                    THISFORM.oMessage.severe(lcMessage)
		                                ELSE
		                                    THISFORM.oMessage.severe('The files need to be synchronized with QuickBooks.  Could not save this credit.')
		                                ENDIF
		                            ELSE
		                                MESSAGEBOX(loaddresp.StatusMessage, 48, 'Unable to Save Credit')
		                            ENDIF
		                            m.goapp.oQB.oqbsm.ClearErrorRecovery()
		                            llreturn = .F.
		                            EXIT
		                        ENDIF
		                    ENDIF
		                ENDIF
		
		            ELSE
		                IF NOT appurchh.lNoQBPost
		                    THISFORM.oMessage.severe('There is no active connection to QuickBooks.  The imported bill(s) cannot be posted to QuickBooks.')
		                    llreturn = .F.
		                ELSE
		                    IF llreturn
		                        
		                    ENDIF
		                ENDIF
		            ENDIF
		        ENDSCAN && Appurchh
		    ENDSCAN && curNewBills
		    
		    IF llReturn
		       TABLEUPDATE(.t.,.f.,'Appurchh')
		       TABLEUPDATE(.t.,.f.,'Appurchd')
		       TABLEUPDATE(.t.,.f.,'Glmaster')
		       TABLEUPDATE(.t.,.f.,'Expense')
		       TABLEUPDATE(.t.,.f.,'Expsusp')
		    ELSE
		       TABLEREVERT(.t.,'Appurchh')
		       TABLEREVERT(.t.,'Appurchd')
		       TABLEREVERT(.t.,'Glmaster')
		       TABLEREVERT(.t.,'Expense')
		       TABLEREVERT(.t.,'Expsusp')
		    ENDIF 
		CATCH TO loError
		    DO errorlog WITH 'PostBillQB', loError.LINENO, 'ImportExp', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to import the bill at this time. Check the System Log found under Help for more information.', 16, 'Problem Encountered')
		    llreturn = .F.
		ENDTRY
		WAIT CLEAR 
		RETURN llreturn
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE postpayments
		LOCAL llReturn, m.cacctno, m.cbatch
		LOCAL lcCheckKey, lnChkCount, loError
		
		
		llReturn = .T.
		WAIT WINDOW NOWAIT 'Posting bill payments...'
		
		TRY
			m.cacctno = THISFORM.cboCashAcct.VALUE
		
			swselect('appmthdr',.T.)
			swselect('appmtdet',.T.)
		
			swselect('apopt')
			GO TOP
			lcAPAcct	  = capacct
			lnChkCount = 0
		
			SELECT billpmts  && dPayDate
			SCAN
				m.cbatch = cbatch
		
				SELECT appmthdr
				LOCATE FOR cbatch = m.cbatch
				IF FOUND()
					m.dpmtdate = dpmtdate
				ELSE
					m.dpmtdate = DATE()
				ENDIF
		
				SELECT appmtdet
				SCAN FOR cbatch = m.cbatch
					SCATTER MEMVAR
		
					*  Create the G/L journal entries for this payment
		
					swselect('vendor')
					LOCATE FOR cvendorid = m.cvendorid
					IF FOUND()
						m.cvendname = cvendname
					ELSE
						m.cvendname = 'Unknown'
					ENDIF
		
					THISFORM.oGLMaint.cId		 = m.cvendorid
					THISFORM.oGLMaint.cidType	 = 'V'
					THISFORM.oGLMaint.ccheckno	 = m.ccheckno
					THISFORM.oGLMaint.lPrinted	 = .T.
					THISFORM.oGLMaint.dCheckDate = m.dpmtdate
					THISFORM.oGLMaint.dPostDate	 = m.dpmtdate
					THISFORM.oGLMaint.cSource	 = 'AP'
					THISFORM.oGLMaint.cPayee	 = m.cvendname
					THISFORM.oGLMaint.cEntryType = 'C'
					THISFORM.oGLMaint.cacctno	 = m.cacctno
					THISFORM.oGLMaint.cbatch	 = m.cbatch
					THISFORM.oGLMaint.cidchec    = m.cidchec
		
					*  Create Cash Entry
					THISFORM.oGLMaint.cbatch	  = m.cbatch
					THISFORM.oGLMaint.dGLDate	  = m.dpmtdate
					THISFORM.oGLMaint.cReference  = m.ccheckno
					THISFORM.oGLMaint.cDesc	      = m.cvendname
					THISFORM.oGLMaint.cacctno	  = m.cacctno
					THISFORM.oGLMaint.cId		  = m.cvendorid
					THISFORM.oGLMaint.nAmount	  = m.nAmtPaid * -1     && Assume to be credit
					THISFORM.oGLMaint.updatebatch()
		
					*  Create A/P entry
					THISFORM.oGLMaint.cbatch	  = m.cbatch
					THISFORM.oGLMaint.dGLDate	  = m.dpmtdate
					THISFORM.oGLMaint.cReference  = m.ccheckno
					THISFORM.oGLMaint.cDesc	      = m.cvendname
					THISFORM.oGLMaint.cacctno	  = lcAPAcct
					THISFORM.oGLMaint.cId		  = m.cvendorid
					THISFORM.oGLMaint.nAmount	  = m.nAmtPaid
					THISFORM.oGLMaint.cbunch	  = ''
					THISFORM.oGLMaint.cyear	  = ' '
					THISFORM.oGLMaint.cperiod	  = ' '
		
					THISFORM.oGLMaint.updatebatch()
		
				ENDSCAN
			ENDSCAN
		
		CATCH TO loError
			MESSAGEBOX('Error: ' + loError.MESSAGE + CHR(13) + 'Line No: ' + TRANSFORM(loError.LINENO), 16, 'PostPayments')
			llReturn = .F.
		ENDTRY
		WAIT CLEAR
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE postrcpt
	ENDPROC

	PROCEDURE processcdex		&& Processes the importfile created by the import of a CDEX DAT file.
		LOCAL loError, llReturn, lnBadRecs, lcMessage, lcMessage2
		
		lnBadRecs = 0
		llReturn  = .T.
		STORE '' TO lcMessage, lcMessage2
		
		TRY
		
		    IF NOT USED('importfile')
		        MESSAGEBOX('The import did not complete successfully. Missing the temporary import file to process.', 16, 'Missing Import File')
		        llReturn = .F.
		        EXIT
		    ENDIF
		
		    IF USED('newwells')
		        IF RECCOUNT() > 0
		* There are new wells to process, so add them
		        ENDIF
		    ENDIF
		
		* Create cursor for bad detail lines
		    CREATE CURSOR baddetail ;
		     (cwellid    c(14), ;
		      ccheckno   c(14))
		      
		*    make_copy('csrcthdr', 'temphdr')
		*    make_copy('csrctdet', 'tempdet')
		
		* Get the total of each check
			SELECT  ccompcode, ccheckno, SUM(nownnet+nownnet2) AS ncashamt ;
				FROM importfile ;
				INTO CURSOR curNewChecks ;
				ORDER BY ccompcode, ccheckno ;
				GROUP BY ccompcode, ccheckno
		
		    SELECT curNewChecks
		    SCAN
		        SCATTER MEMVAR
		* Build the header record for the receipt        
		        m.cVendorID   = THISFORM.txtcVendorID.value
		        m.cname       = thisform.txtcVendName.value
		        IF thisform.chkUseDate.Value 
		           m.ddate    = thisform.dcheckdate.value
		        ELSE
		           m.ddate    = m.dcheckdate
		        ENDIF    
		        
		        m.lUploaded   = .T.
		        
		        m.dAdded   = DATETIME()
		        m.cAddedBy = m.goapp.cuser
		
		        INSERT INTO csrcthdr FROM MEMVAR
		
		        m.cbatch = csrcthdr.icsrcthdrpk
		
		* Build the detail records for the receipt
		        SELECT importfile
		        SCAN FOR ccompcode == m.ccompcode AND ccheckno == m.ccheckno
		            SCATTER MEMVAR
		
		            swselect('wells')
		            LOCATE FOR cpropno = m.cwellid
		            IF FOUND()
		                m.cwellid      = cwellid
		                m.cdesc        = cwellname
		                m.cprodperiod  = LEFT(m.cProdDate1, 2)
		                m.cprodyear    = TRANSFORM(YEAR(m.ddate))
		                m.ctype        = m.cprodcode
		                m.ngrossunits  = m.nleaseGrossVol
		                m.nGrossAmount = m.nLeaseNet + m.nLeaseGrossTax
		                m.cOwnType     = m.cTypeInv
		                m.cleasename   = cleasename
		                DO CASE
		                    CASE m.cOwnType = 'W'
		                        m.nNetUnits  = ROUND(m.ngrossunits * (nworknri / 100), 2)
		                        m.nNetAmount = ROUND(m.nGrossAmount * (nworknri / 100), 2)
		                        m.nNetAmount = m.nownnet + m.nOwnNet2
		                    CASE m.cOwnType = 'O' OR m.cOwnType = 'R'
		                        m.nNetUnits  = ROUND(m.ngrossunits * (nroyint / 100), 2)
		                        m.nNetAmount = m.nownnet + m.nOwnNet2
		                    OTHERWISE
		                        m.nNetUnits  = 0
		                        m.nNetAmount = m.nownnet + m.nOwnNet2
		                ENDCASE
		
		                INSERT INTO csrctdet FROM MEMVAR
		            ELSE
		                INSERT INTO baddetail FROM MEMVAR 
		                lnBadRecs = lnBadRecs + 1    
		            ENDIF
		        ENDSCAN
		    ENDSCAN
		    
		* Inform about any recs that couldn't be imported    
		    IF lnBadRecs > 0
		       lcMessage = "There were " + TRANSFORM(lnBadRecs) + " detail lines that could not be imported." + CHR(10) + ;
		                   "The property numbers that couldn't be found in the well records are: " + CHR(10)
		                   
		       SELECT ccheckno, cwellid FROM baddetail INTO CURSOR temp ORDER BY cwellid, ccheckno GROUP BY cwellid, ccheckno
		       SELECT temp 
		       SCAN 
		          SCATTER MEMVAR 
		          lcMessage2 = lcMessage2 + 'Property: ' + m.cwellid + ' Check No: ' + m.ccheckno + CHR(10)
		       ENDSCAN 
		       MESSAGEBOX(lcMessage+lcMessage2,48,'Missing Properties')
		    ELSE
		* Inform about the import's success    
		       lnTotalcks = RECCOUNT('curNewChecks')
		       SELECT SUM(ncashamt) as nTotal from curNewChecks INTO CURSOR temp
		       lnTotal = nTotal
		       MESSAGEBOX('Imported: ' + TRANSFORM(lnTotalCks) + IIF(lnTotalcks > 1,'Checks','Check') + ' Totaling: ' + TRANSFORM(lnTotal,'999,999,999.99'),64,'Import Successful')
		    ENDIF 
		       
		    IF llReturn
		       TABLEUPDATE(.t.,.t.,'Csrcthdr')
		       TABLEUPDATE(.t.,.t.,'Csrctdet')
		    ENDIF 
		    
		CATCH TO loError
		    llReturn = .F.
		    DO errorlog WITH 'ProcessCDEX', loError.LINENO, 'Import', loError.ERRORNO, loError.MESSAGE, '', loError
		    MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		          'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
	ENDPROC

	PROCEDURE processcsv		&& Processes the importfile cursor created by importing an owner relations connect csv file.
		LOCAL llReturn, loError
		LOCAL lcMessage, lcMessage2, lnBadRecs, lnTotal, lnTotalcks
		LOCAL lcTaxType, llFoundLease, lnBillAmt, lnCount
		LOCAL ccatcode, ccode, cexpcode, cexpdesc1, cexpdesc2, cexpdesc3, cexpdesc6, cidterm
		LOCAL cinvtype, citemdesc, cponumber, cprodcode, creference, cwellid, ddiscdate, dinvdate
		LOCAL dpostdate, iappurchhpk, mnotes, nExtension, nSubTotal, ninvbal, npayments, x
		LOCAL cBatch, cOwnType, cProdYear, cType, ccashacct, cdesc, cleasename, cname, copername
		LOCAL cprodperiod, ddate, dentdate, ileasespk, ioperatorpk, nNetUnits, nPrice
		LOCAL oprogress, lcScan, llOneInvoice, oWellInv
		lnBadRecs = 0
		llReturn  = .T.
		
		STORE '' TO m.citemid, m.citemdec, m.ctaxable, m.cleaseid, m.cdeptno, m.cBatch, m.ccatcode, ;
		   m.cProdYear, m.cprodperiod, m.cownerid, m.cleasename, m.cvendorid
		STORE 0  TO m.nPrice, m.nquantity, m.nExtension, m.nsaltbbl
		
		oprogress = .NULL.
		
		llOneInvoice = THISFORM.chkOneInvoice.VALUE
		
		TRY
		   oWellInv = CREATEOBJECT('swbizobj_wellinv')
		
		   swselect('glopt')
		   lcRevClear = cRevClear
		   lcExpClear = cExpClear
		   lcCatchAll = cSuspense
		
		   swselect('apopt')
		   m.capacct = capacct
		
		   IF NOT FILE(m.goapp.cDataFilePath+'importbatch.dbf')
		      CREATE TABLE (m.goapp.cDataFilePath+'importbatch') FREE ;
		         (cImptype       c(4), ;
		         timported      T, ;
		         mkeys          m)
		   ENDIF
		
		   STORE '' TO lcMessage2
		   * Create cursor for bad detail lines
		   CREATE CURSOR baddetail ;
		      ( iRow      I, ;
		      cvendorid  c(10), ;
		      cwellid     c(20), ;
		      cwellname  c(40), ;
		      cDeck      c(10), ;
		      ccatcode   c(7), ;
		      cinvnum    c(14), ;
		      cacctno    c(6), ;
		      namount    N(12, 2))
		
		   IF llOneInvoice
		      SELECT  cinvnum, ;
		         dinvdate, ;
		         dpostdate, ;
		         dduedate, ;
		         SPACE(8) AS cBatch, ;
		         SUM(namount) AS nInvTot ;
		         FROM importfile ;
		         WHERE namount # 0 ;
		         INTO CURSOR curNewBills READWRITE ;
		         ORDER BY dpostdate ;
		         GROUP BY dpostdate
		      REPLACE cinvnum WITH DTOC(THISFORM.dcheckdate.VALUE)
		   ELSE
		      SELECT  cvendorid, ;
		         cinvnum, ;
		         dinvdate, ;
		         dpostdate, ;
		         dduedate, ;
		         SPACE(8) AS cBatch, ;
		         SUM(namount) AS nInvTot ;
		         FROM importfile ;
		         WHERE namount # 0 ;
		         INTO CURSOR curNewBills READWRITE ;
		         ORDER BY cvendorid, cinvnum, dpostdate ;
		         GROUP BY cvendorid, cinvnum, dpostdate
		   ENDIF
		
		   m.cImptype   = 'EXP'
		   m.timported = DATETIME()
		   m.mkeys     = ''
		
		   SELECT importfile
		   lnMax      = RECCOUNT()
		   lnProgress = 1
		   oprogress  = THISFORM.omessage.progressbar('Processing imported records...')
		   oprogress.SetProgressRange(1, lnMax)
		   SELECT curNewBills
		   SCAN
		      SCATTER MEMVAR
		
		      m.cBatch = GetNextPK('BATCH')
		      SELECT curNewBills
		      REPLACE cBatch WITH m.cBatch
		      m.mkeys = m.mkeys + m.cBatch + CHR(13)
		
		      lnBillAmt = 0
		      m.cname   = THISFORM.txtCvendname.VALUE
		
		      IF THISFORM.chkUseDate.VALUE
		         m.dinvdate    = THISFORM.dcheckdate.VALUE
		      ENDIF
		
		      m.dentdate   = DATE()
		      m.nSubTotal  = m.nInvTot
		      m.npayments  = 0
		      m.ninvbal    = m.nInvTot
		      m.ddiscdate  = {}
		      m.creference = 'Imported: ' + DTOC(DATE())
		      m.cinvtype   = ''
		      m.cponumber  = ''
		      m.cidterm    = ''
		      m.mnotes     = ''
		
		      IF EMPTY(m.cvendorid)
		         m.cvendorid = THISFORM.txtcvendorID.VALUE
		      ENDIF
		
		      swselect('vendor')
		      SET ORDER TO cvendorid
		      IF SEEK(m.cvendorid)
		         m.cidterm = cidterm
		      ELSE
		         m.cidterm = ''
		      ENDIF
		
		      IF EMPTY(m.cidterm)
		         swselect('terms')
		         LOCATE FOR ldefterm = .T.
		         IF FOUND()
		            m.cidterm = cidterm
		         ENDIF
		      ENDIF
		      
		      m.dAdded   = DATETIME()
		      m.cAddedBy = m.goapp.cUser
		
		      m.lnoqbpost = THISFORM.chkpostQB.VALUE
		
		      INSERT INTO appurchh FROM MEMVAR
		
		      SELECT appurchh
		      LOCATE FOR cBatch = m.cBatch
		
		      llReturn = THISFORM.ValidateTerms()
		
		      lndetail = 0
		
		      IF llOneInvoice
		         lcScan = '.T.'
		      ELSE
		         SELECT importfile
		         LOCATE FOR NOT EMPTY(cvendorid)
		         IF FOUND()
		            lcScan = 'cinvnum = m.cinvnum and cvendorid = m.cvendorid'
		         ELSE
		            lcScan = 'cinvnum = m.cinvnum'
		         ENDIF
		      ENDIF
		
		      SELECT importfile
		      SCAN FOR &lcScan
		         SCATTER MEMVAR
		         m.cwellid = PADR(ALLTRIM(UPPER(m.cwellid)), 20, ' ')
		         oprogress.updateprogress(lnProgress)
		         lnProgress   = lnProgress + 1
		         llFoundLease = .F.
		         IF NOT EMPTY(m.cwellid)
		            swselect('wells')
		            LOCATE FOR (cPropNo == m.cwellid) OR ;
		               (coilpurchno == m.cwellid) OR ;
		               (cgaspurchno == m.cwellid) OR ;
		               (cothpurchno == m.cwellid) OR ;
		               (cwellid == LEFT(m.cwellid, 10))
		            IF FOUND()
		               m.cunitno   = cwellid
		               m.cwellname = cwellname
		               m.cwellid   = cwellid
		               IF EMPTY(m.cdesc)
		                  m.cdesc  = m.cwellname
		               ENDIF
		               lndetail = lndetail + 1
		               lcTaxType     = ''
		
		               IF NOT EMPTY(m.ccatcode)
		                  IF m.ccatcode = 'PLUG'
		                     MESSAGEBOX('The "PLUG" expense code is designated for the Plugging module ' + ;
		                        'and cannot be processed on an import. Use the Fixed Expenses ' + ;
		                        'or Well Expenses by Well (8/8th) window for any plugging fund ' + ;
		                        'adjustments that need made.', 16, 'Plugging Expense')
		                     llReturn = .F.
		                     EXIT
		                  ENDIF
		                  * Pad with zeros to make sure the code is valid
		                  IF FILE(m.goapp.cCommonFolder+'padexpcode.txt')
		                     IF LEN(ALLTRIM(m.ccatcode)) < 4
		                        m.ccatcode = PADL(ALLTRIM(m.ccatcode),4,'0')
		                     ENDIF
		                  ENDIF
		                  swselect('expcat')
		                  LOCATE FOR ccatcode = ALLTRIM(m.ccatcode)
		                  IF NOT FOUND()
		                     SELECT importtypes
		                     LOCATE FOR ALLTRIM(m.ccatcode) $ importtypes.mtypes
		                     IF FOUND()
		                        m.ccatcode   = ALLTRIM(cType)
		                     ELSE
		                        IF m.namount # 0
		                           MESSAGEBOX('An invalid expense code was found in the import. The code found is: ' + CHR(10) + CHR(10) + ;
		                              m.ccatcode + CHR(10) + CHR(10) + ;
		                              'Please add this code to the appropriate expense code type in the import ' + ;
		                              'code mapping and then try the import again.', 16, 'Invalid Expense Code')
		                           INSERT INTO baddetail FROM MEMVAR
		                           lnBadRecs = lnBadRecs + 1
		                           llReturn = .F.
		                           EXIT
		                        ENDIF
		                     ENDIF
		                  ELSE
		                     m.cacctno     = lcExpClear
		                     m.cAcctListID = lcExpClear
		                     IF EMPTY(m.cdesc)
		                        m.cdesc = ccateg
		                     ENDIF
		                     m.cExpClass = cExpClass
		                  ENDIF
		
		                  IF NOT EMPTY(m.cDeck)
		                     swselect('doidecks')
		                     LOCATE FOR cDeck = m.cDeck AND cwellid = m.cwellid
		                     IF NOT FOUND()
		                        MESSAGEBOX('An invalid DOI Deck was found. The deck being imported: ' + ALLTRIM(m.cDeck) + ;
		                           ' does not exist in the deck file.',16,'DOI Deck Missing')
		                        INSERT INTO baddetail FROM MEMVAR
		                        lnBadRecs = lnBadRecs + 1
		                        llReturn = .F.
		                        EXIT
		                     ENDIF
		                  ENDIF
		
		                  IF NOT EMPTY(m.cownerid)
		                     m.cExpClass = '0' && Force expense class to 0 for one-man items
		                  ENDIF
		
		                  IF EMPTY(m.cProdYear) AND NOT EMPTY(m.dProdDate)
		                     m.cProdYear   = TRANSFORM(YEAR(m.dProdDate))
		                     m.cprodperiod = PADL(TRANSFORM(MONTH(m.dProdDate)), 2, '0')
		                  ENDIF
		
		                  IF EMPTY(m.cDeck)
		                     m.cDeck = oWellInv.DOIDeckNameLookup(m.cProdYear, m.cprodperiod, m.cwellid)
		                  ENDIF
		
		                  m.nExtension = m.namount
		                  m.citemdesc  = m.cdesc
		                  IF NOT EMPTY(m.cprodperiod)
		                     m.cprodperiod = PADL(ALLTRIM(m.cprodperiod), 2, '0')
		                  ENDIF
		
		                  IF NOT EMPTY(m.ccatcode) AND m.nExtension # 0
		                     lnBillAmt = lnBillAmt + m.nExtension
		                     m.cidpurd = GetNextPK('APPURCHD')
		                     INSERT INTO appurchd FROM MEMVAR
		                  ENDIF
		               ELSE
		                  m.ccatcode = ''
		                  IF EMPTY(m.cacctno)
		                     m.cacctno     = lcExpClear
		                     m.cAcctListID = lcExpClear
		                  ENDIF
		                  IF m.goapp.lAMVersion OR m.goapp.lQBVersion
		                     IF m.goapp.lAMVersion
		                        IF NOT EMPTY(m.cacctno) AND m.namount # 0
		                           swselect('coa')
		                           LOCATE FOR cacctno = ALLTRIM(m.cacctno)
		                           IF FOUND()
		                              m.nExtension = m.namount
		                              IF EMPTY(m.cdesc)
		                                 m.citemdesc  = cacctdesc
		                              ELSE
		                                 m.citemdesc  = m.cdesc
		                              ENDIF
		                              m.cidpurd = GetNextPK('APPURCHD')
		                              INSERT INTO appurchd FROM MEMVAR
		                              lnBillAmt = lnBillAmt + m.nExtension
		                           ELSE
		                              INSERT INTO baddetail FROM MEMVAR
		                           ENDIF
		                        ENDIF
		                     ELSE
		                        IF NOT EMPTY(m.cacctno) AND m.namount # 0
		                           swselect('accounts')
		                           LOCATE FOR UPPER(cacctdesc) = UPPER(ALLTRIM(m.cacctno))
		                           IF FOUND()
		                              m.nExtension = m.namount
		                              IF EMPTY(m.cdesc)
		                                 m.citemdesc  = cacctdesc
		                              ELSE
		                                 m.citemdesc  = m.cdesc
		                              ENDIF
		                              m.cAcctListID = clistid
		                              m.cidpurd = GetNextPK('APPURCHD')
		                              INSERT INTO appurchd FROM MEMVAR
		                              lnBillAmt = lnBillAmt + m.nExtension
		                           ELSE
		                              INSERT INTO baddetail FROM MEMVAR
		                              lnBadRecs = lnBadRecs + 1
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ELSE
		                     IF NOT EMPTY(m.cdesc) AND m.namount # 0
		                        m.nExtension = m.namount
		                        IF EMPTY(m.cdesc)
		                           m.citemdesc  = cacctdesc
		                        ELSE
		                           m.citemdesc  = m.cdesc
		                        ENDIF
		                        m.cidpurd = GetNextPK('APPURCHD')
		                        INSERT INTO appurchd FROM MEMVAR
		                        lnBillAmt = lnBillAmt + m.nExtension
		                     ELSE
		                        INSERT INTO baddetail FROM MEMVAR
		                        lnBadRecs = lnBadRecs + 1
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ELSE
		               SELECT baddetail
		               LOCATE FOR cwellid = m.cwellid
		               IF NOT FOUND()
		                  INSERT INTO baddetail FROM MEMVAR
		               ENDIF
		               lnBadRecs = lnBadRecs + 1
		            ENDIF
		         ELSE
		            m.cunitno  = ''
		            m.ccatcode = ''
		            lndetail = lndetail + 1
		            IF m.goapp.lAMVersion
		               IF NOT EMPTY(m.cacctno) AND m.namount # 0
		                  swselect('coa')
		                  LOCATE FOR cacctno = ALLTRIM(m.cacctno)
		                  IF FOUND()
		                     m.nExtension = m.namount
		                     IF EMPTY(m.cdesc)
		                        m.citemdesc  = cacctdesc
		                     ELSE
		                        m.citemdesc  = m.cdesc
		                     ENDIF
		                     m.cidpurd = GetNextPK('APPURCHD')
		                     INSERT INTO appurchd FROM MEMVAR
		                     lnBillAmt = lnBillAmt + m.nExtension
		                  ELSE
		                     INSERT INTO baddetail FROM MEMVAR
		                     lnBadRecs = lnBadRecs + 1
		                  ENDIF
		               ENDIF
		            ELSE
		               IF NOT EMPTY(m.cacctno) AND m.namount # 0
		                  swselect('accounts')
		                  LOCATE FOR UPPER(cacctdesc) = UPPER(ALLTRIM(m.cacctno))
		                  IF FOUND()
		                     m.nExtension = m.namount
		                     IF EMPTY(m.cdesc)
		                        m.citemdesc  = cacctdesc
		                     ELSE
		                        m.citemdesc  = m.cdesc
		                     ENDIF
		                     m.cAcctListID = clistid
		                     m.cidpurd = GetNextPK('APPURCHD')
		                     INSERT INTO appurchd FROM MEMVAR
		                     lnBillAmt = lnBillAmt + m.nExtension
		                  ELSE
		                     m.nExtension = m.namount
		                     IF EMPTY(m.cdesc)
		                        m.citemdesc  = cacctdesc
		                     ELSE
		                        m.citemdesc  = m.cdesc
		                     ENDIF
		                     m.cAcctListID = lcCatchAll
		                     m.cidpurd = GetNextPK('APPURCHD')
		                     INSERT INTO appurchd FROM MEMVAR
		                     lnBillAmt = lnBillAmt + m.nExtension
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDSCAN && importfile
		
		      SELECT appurchh
		      LOCATE FOR cBatch = m.cBatch
		      IF FOUND()
		         IF lndetail = 0
		            DELETE NEXT 1
		            LOOP
		         ENDIF
		         IF nInvTot # lnBillAmt
		            REPLACE nInvTot WITH lnBillAmt, ;
		               nSubTotal WITH lnBillAmt, ;
		               ninvbal  WITH lnBillAmt
		         ENDIF
		      ENDIF
		      THISFORM.nTotalImport = THISFORM.nTotalImport + lnBillAmt
		   ENDSCAN &&curnewbills
		
		   oprogress.closeprogress()
		   * Inform about any recs that couldn't be imported
		   IF lnBadRecs > 0
		      SELECT cwellid FROM baddetail INTO CURSOR temp ORDER BY cwellid GROUP BY cwellid
		      lnBadRecs = _TALLY
		      lcMessage = "There were " + TRANSFORM(lnBadRecs) + " detail lines that could not be imported." + CHR(10) + ;
		         "The property numbers that couldn't be found in the well records are: " + CHR(10)
		
		      SELECT cinvnum, cwellname, cwellid, cacctno FROM baddetail INTO CURSOR temp ORDER BY cwellid, cinvnum GROUP BY cwellid, cinvnum
		      SELECT temp
		      SCAN
		         SCATTER MEMVAR
		         lcMessage2 = lcMessage2 + 'Well: ' + m.cwellid + ' ' + m.cwellname + ' Account: ' + m.cacctno + CHR(10)
		      ENDSCAN
		      MESSAGEBOX(lcMessage + lcMessage2, 48, 'Missing Wells/Account')
		      IF MESSAGEBOX('Do you want to print this list of invalid wells?', 36, 'Missing Wells/Accounts') = 6
		         SELECT  iRow, cinvnum, ;
		            cwellname, ;
		            ccatcode, ;
		            cwellid, ;
		            cacctno, ;
		            namount ;
		            FROM baddetail ;
		            INTO CURSOR temp ;
		            ORDER BY cwellid, ccatcode, cinvnum ;
		            GROUP BY cwellid, ccatcode, cinvnum
		         REPORT FORM baddetaile TO PRINTER PROMPT PREVIEW
		      ENDIF
		      IF MESSAGEBOX('Do you want to continue the import?', 36, 'Continue Import') = 7
		         llReturn = .F.
		      ENDIF
		   ENDIF
		
		   TRY
		      INSERT INTO importbatch FROM MEMVAR
		   CATCH
		   ENDTRY
		
		CATCH TO loError
		   llReturn = .F.
		   IF VARTYPE(oprogress) = 'O'
		      oprogress.closeprogress()
		      RELEASE oprogress
		   ENDIF
		   DO errorlog WITH 'ProcessCSV', loError.LINENO, 'Import Expenses', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the import at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE qbpostbill
	ENDPROC

	PROCEDURE qbpostrec		&& Post receipt to QuickBooks
	ENDPROC

	PROCEDURE validateterms
		*
		*  Validates the terms code in the appurchh record and
		*  calculates the due date and disc date based upon
		*  the terms settings and the appurchh.dinvdate
		*
		LOCAL lcidTerm, lnNetDueIn, lnDiscIn, ldInvDate
		LOCAL llReturn, lnDiscPct, loError
		
		llReturn = .T.
		
		TRY
		   ldInvDate = appurchh.dinvdate
		*
		*  If the invoice date is empty, don't try to calculate
		*  the due date or discount date
		*
		   IF EMPTY(ldInvDate)
		      llReturn = .F.
		      EXIT
		   ENDIF
		*
		*  Get the terms table primary key from the purchase header
		*  record.  
		   lcidTerm  = appurchh.cidterm
		
		*
		*  Lookup the terms code in the terms table to get the
		*  # of days the invoice is due in and the # of days
		*  set for discounts
		*
		   swselect('terms')
		   SET ORDER TO cidterm
		   IF SEEK(lcidTerm)
		      lnNetDueIn = nNetDueIn
		      lnDiscIn   = nDiscIn
		      lnDiscPct  = nDiscPct
		   ELSE
		      * Get the default terms
		      LOCATE FOR lDefTerm
		      IF FOUND()
		         lnNetDueIn = nNetDueIn
		         lnDiscIn   = nDiscIn
		         lnDiscPct  = nDiscPct
		      ELSE    
		         STORE 0 TO lnNetDueIn, lnDiscIn, lnDiscPct
		      ENDIF    
		   ENDIF
		
		
		*  Calculate and set the values of the due date and
		*  discount date fields
		   ldDueDate = ldInvDate + lnNetDueIn
		   ldDiscDate = ldInvDate + lnDiscIn
		   
		   SELECT appurchh
		   REPLACE dDueDate WITH ldDueDate, ;
		           dDiscDate WITH ldDiscDate
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'ValidateTerms', loError.LINENO, 'Enter Bills-d', loError.ERRORNO, loError.MESSAGE, '', loError
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE cboCashAcct.Init
		LOCAL lnX, laBankAcct[1,1], lnCount, lcCashAcct, lnCash, lnAcct
		
		* Get the default payment account from A/P Options
		SELECT apopt
		GO TOP
		lcCashAcct = cAPCash
		lnAcct     = 1
		
		SELECT cAcctNo, cAcctDesc FROM coa WHERE lBankAcct = .T. INTO ARRAY laBankAcct ORDER BY cAcctNo
		
		lnCount = _TALLY
		IF lnCount > 0
		   FOR lnX = 1 TO lnCount
		      IF laBankAcct[lnX,1] = lcCashAcct
		         lnAcct = lnX
		      ENDIF
		      THIS.ADDLISTITEM(laBankAcct[lnX,1]+'-'+TRIM(laBankAcct[lnX,2]),lnX,1)
		      THIS.ADDLISTITEM(laBankAcct[lnX,1],lnX,2)
		   ENDFOR
		   this.ListItemId = lnAcct
		ENDIF
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cboImportMap.Init
		IF DODEFAULT()
		   this.Requery()
		ENDIF 
	ENDPROC

	PROCEDURE cboImportMap.Requery
		IF DODEFAULT()
		   this.Clear()
		   lnx = 1
		   swselect('importmap')
		   SET ORDER to IMPORTNAME   && CIMPORTNAME
		   SET FILTER TO ctype = 'EXP'
		   SCAN
		      this.AddListItem(cimportname,lnx) 
		      lnx = lnx + 1
		   ENDSCAN 
		ENDIF    
	ENDPROC

	PROCEDURE chkImportPmts.Click
		IF this.Value
		   thisform.cboCashAcct.Visible = .t.
		   thisform.lblcashAcct.Visible = .t.
		ELSE
		   thisform.cboCashAcct.Visible = .f.
		   thisform.lblcashAcct.Visible = .f.
		ENDIF 
	ENDPROC

	PROCEDURE chkOneInvoice.Click
		IF this.Value
		   thisform.chkUseDate.Value = .t.
		ENDIF 
	ENDPROC

	PROCEDURE chkVendorid.Click
		IF THIS.VALUE
		   THISFORM.txtcvendname.VISIBLE = .F.
		   THISFORM.lblcvendorid.VISIBLE = .F.
		   THISFORM.txtcvendorID.VISIBLE = .F.
		   THISFORM.cmdVendor.VISIBLE    = .F.
		ELSE
		   THISFORM.txtcvendname.VISIBLE = .T.
		   THISFORM.lblcvendorid.VISIBLE = .T.
		   THISFORM.txtcvendorID.VISIBLE = .T.
		   THISFORM.cmdVendor.VISIBLE    = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdImport.Click
		thisform.import()
		
		
	ENDPROC

	PROCEDURE cmdMap.Click
		m.goStateManager.OpenForm('importexp_map.scx', thisform.cboImportMap.value)
	ENDPROC

	PROCEDURE cmdVendor.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		
		lcList = 'cVendorID,cSortfield'
		
		DO FORM ..\CUSTOM\picklist WITH 'Vendor', lcList, thisform.txtcvendorid.value, 2
		
		IF llOK
		   THISFORM.cmdatamanager.REPLACE('appurchh','cVendorId', Vendor.cVendorID)
		   thisform.txtcVendorID.set('value',vendor.cvendorid)
		   THISFORM.txtcVendName.VALUE = vendor.cvendname
		   THISFORM.txtcVendName.REFRESH()
		   THISFORM.txtcVendorId.REFRESH
		ENDIF
		
		THISFORM.setnextcontrol(THISFORM.txtcVendorId)
		
		ON KEY LABEL F10 _screen.activeform.Save()
		ON KEY LABEL CTRL+A _screen.activeform.New()
		ON KEY LABEL CTRL+D _screen.activeform.Delete()
		ON KEY LABEL CTRL+L _screen.activeform.List()
		
	ENDPROC

	PROCEDURE txtCvendname.When
		DODEFAULT()
		RETURN .F.    
	ENDPROC

	PROCEDURE txtcVendorID.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdVendor.Click()
		DODEFAULT()
	ENDPROC

	PROCEDURE txtcVendorID.InteractiveChange
		IF DODEFAULT()
		   swselect('vendor')
		   LOCATE FOR cvendorid == this.value
		   IF FOUND() 
		      THISFORM.txtcVendName.SET('value',vendor.cvendname)
		   ELSE
		      THISFORM.txtcVendName.SET('value','')
		   ENDIF 
		ENDIF       
		   
		         
		
	ENDPROC

	PROCEDURE txtcVendorID.LostFocus
		ON KEY LABEL F2 *
		
		
	ENDPROC

ENDDEFINE
