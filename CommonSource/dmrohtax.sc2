*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="dmrohtax.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 501
	Left = 219
	Name = "Dataenvironment"
	Top = 269
	Width = 974

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "options", ;
		BufferModeOverride = 5, ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 430, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 668, ;
		Name = "Cursor10", ;
		Top = 28, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "wellhist", ;
		CursorSource = "wellhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "sevtax", ;
		CursorSource = "sevtax", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 231, ;
		Left = 12, ;
		Name = "Cursor4", ;
		Top = 20, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "income", ;
		BufferModeOverride = 5, ;
		CursorSource = "income", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 343, ;
		Left = 389, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "incsusp", ;
		BufferModeOverride = 5, ;
		CursorSource = "incsusp", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 227, ;
		Name = "Cursor6", ;
		Top = 239, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "income1", ;
		CursorSource = "income", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor7", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "incsusp1", ;
		CursorSource = "incsusp", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 544, ;
		Name = "Cursor8", ;
		Top = 155, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "revsrc", ;
		BufferModeOverride = 5, ;
		CursorSource = "revsrc", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 217, ;
		Left = 150, ;
		Name = "Cursor9", ;
		Top = 140, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formdmrohtax AS frmrptcriteria OF "..\source\appforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shpshapecustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBegID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swyear1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swrptlook1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblEndID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="swstates" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="OpgQuarters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="LblBegYear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboSevTax" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboCostRecovery" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkProdPeriod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblAcctNo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcAcctNo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chklNoShowTotal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chklAdjust" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chklProportionate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkSelected" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblSelected" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: calctax1		&& Calculates tax 1
		*m: calctax1qtr		&& Calculate tax 1 by quarter
		*m: calctax2		&& calculate taxes 2
		*m: calctax2qtr		&& Calculate tax 2 by quarter
		*m: calctax3		&& Calculates tax 3
		*m: calctax3qtr		&& Calculates Tax 3 by Quarter
		*m: calctax4		&& Calculates Tax 4
		*m: calctax4qtr		&& Calculates Tax 4 by Quarter
		*m: qbpost
		*p: ctaxtype		&& Tax Type parameter passed to the form.
		*p: odist		&& Distproc object holder
	*</DefinedPropArrayMethod>

	Caption = "Ohio Tax Reporting (Forms SV 3/3A)"
	DoCreate = .T.
	Height = 592
	HelpContextID = 597
	Name = "Formdmrohtax"
	Width = 471
	Swrptcriteriabuttons1.chkExport.Alignment = 0
	Swrptcriteriabuttons1.chkExport.Name = "chkExport"
	Swrptcriteriabuttons1.cmdclose.Name = "cmdclose"
	Swrptcriteriabuttons1.cmdPreview.Name = "cmdPreview"
	Swrptcriteriabuttons1.cmdPrint.Name = "cmdPrint"
	Swrptcriteriabuttons1.Left = 114
	Swrptcriteriabuttons1.Name = "Swrptcriteriabuttons1"
	Swrptcriteriabuttons1.TabIndex = 20
	Swrptcriteriabuttons1.Top = 515
	Swrptcriteriabuttons1.ZOrderSet = 1

	ADD OBJECT 'cboCostRecovery' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		Height = 20, ;
		Left = 242, ;
		Name = "cboCostRecovery", ;
		TabIndex = 6, ;
		Top = 70, ;
		Width = 151, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cboSevTax' AS cbocomboboxcustom WITH ;
		BoundColumn = 2, ;
		Height = 20, ;
		Left = 242, ;
		Name = "cboSevTax", ;
		TabIndex = 4, ;
		Top = 48, ;
		Width = 151, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chklAdjust' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Create adjusting entries based on worksheet numbers", ;
		Left = 91, ;
		Name = "chklAdjust", ;
		TabIndex = 24, ;
		Top = 469, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chklNoShowTotal' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Don't print total on SV 3 form", ;
		Left = 155, ;
		Name = "chklNoShowTotal", ;
		TabIndex = 23, ;
		Top = 468, ;
		Value = .F., ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chklProportionate' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Base adjustments only on wells that didn't meet the required minimum", ;
		Left = 56, ;
		Name = "chklProportionate", ;
		TabIndex = 25, ;
		Top = 487, ;
		Value = .T.
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkProdPeriod' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Use Production Period as Selection Criteria. Otherwise, report is based on accounting date from the Well History file.", ;
		Height = 30, ;
		Left = 73, ;
		Name = "chkProdPeriod", ;
		TabIndex = 10, ;
		Top = 150, ;
		Value = .F., ;
		Width = 317, ;
		WordWrap = .T.
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkSelected' AS chkcheckboxcustom WITH ;
		Alignment = 0, ;
		Caption = "Choose Selected Wells", ;
		Left = 155, ;
		Name = "chkSelected", ;
		TabIndex = 13, ;
		Top = 232, ;
		Value = .F.
		*< END OBJECT: ClassLib="..\..\wellprofits\custom\ccontrol.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 20, ;
		Left = 0, ;
		Name = "Glmaint", ;
		Top = 0, ;
		Width = 13
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'lblAcctNo' AS lbllabelcustom WITH ;
		Caption = "Account #", ;
		Left = 88, ;
		Name = "lblAcctNo", ;
		TabIndex = 21, ;
		Top = 437, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblBegID' AS lbllabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "First Well:", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 91, ;
		Name = "lblBegID", ;
		TabIndex = 15, ;
		Top = 259, ;
		Width = 49, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'LblBegYear' AS lbllabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Year:", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 111, ;
		Name = "LblBegYear", ;
		TabIndex = 12, ;
		Top = 194, ;
		Width = 29, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblEndID' AS lbllabelcustom WITH ;
		AutoSize = .T., ;
		Caption = "Last Well:", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 91, ;
		Name = "lblEndID", ;
		TabIndex = 16, ;
		Top = 311, ;
		Width = 49, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		BackStyle = 1, ;
		Caption = "Quarter", ;
		FontBold = .T., ;
		Left = 52, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 8, ;
		Top = 101, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom3' AS lbllabelcustom WITH ;
		Caption = " Well Product Tax Table:", ;
		Left = 147, ;
		Name = "Lbllabelcustom3", ;
		TabIndex = 2, ;
		Top = 14, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblSelected' AS lbllabelcustom WITH ;
		Caption = "All IDs Selected", ;
		ForeColor = 0,0,255, ;
		Left = 154, ;
		Name = "lblSelected", ;
		TabIndex = 19, ;
		Top = 298, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\..\wellprofits\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom1' AS lbltextcustom WITH ;
		BackStyle = 1, ;
		Caption = "For this tax table", ;
		FontBold = .T., ;
		Left = 52, ;
		Name = "Lbltextcustom1", ;
		TabIndex = 3, ;
		Top = 31, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom2' AS lbltextcustom WITH ;
		Caption = "Severance Tax is set up as:", ;
		Left = 66, ;
		Name = "Lbltextcustom2", ;
		TabIndex = 5, ;
		Top = 50, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom3' AS lbltextcustom WITH ;
		Caption = "Cost Recovery Fee is set up as:", ;
		Left = 66, ;
		Name = "Lbltextcustom3", ;
		TabIndex = 7, ;
		Top = 72, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom4' AS lbltextcustom WITH ;
		Caption = " What to Print:", ;
		Left = 71, ;
		Name = "Lbltextcustom4", ;
		TabIndex = 18, ;
		Top = 363
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'opgPrint' AS opgoptiongroupcustom WITH ;
		AutoSize = .F., ;
		BorderStyle = 0, ;
		ButtonCount = 3, ;
		Height = 69, ;
		Left = 149, ;
		Name = "opgPrint", ;
		TabIndex = 17, ;
		Top = 357, ;
		Value = 1, ;
		Width = 186, ;
		Option1.AutoSize = .T., ;
		Option1.BackStyle = 0, ;
		Option1.Caption = "Cost Recovery Fee worksheet", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 5, ;
		Option1.Value = 1, ;
		Option1.Width = 166, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Cost Recovery Schedule (SV 3A)", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 26, ;
		Option2.Width = 181, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "Severance Tax Return (SV 3)", ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 5, ;
		Option3.Name = "Option4", ;
		Option3.Top = 47, ;
		Option3.Width = 162
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'OpgQuarters' AS opgoptiongroupcustom WITH ;
		BorderStyle = 1, ;
		ButtonCount = 4, ;
		Height = 35, ;
		Left = 45, ;
		Name = "OpgQuarters", ;
		TabIndex = 9, ;
		Top = 107, ;
		Width = 373, ;
		ZOrderSet = 9, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "1st (Jan - Mar)", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Q1", ;
		Option1.Top = 11, ;
		Option1.Width = 89, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "2nd (Apr - Jun)", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 96, ;
		Option2.Name = "Q2", ;
		Option2.Top = 11, ;
		Option2.Width = 92, ;
		Option3.AutoSize = .T., ;
		Option3.Caption = "3rd (Jul - Sep)", ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 192, ;
		Option3.Name = "Q3", ;
		Option3.Top = 11, ;
		Option3.Width = 87, ;
		Option4.AutoSize = .T., ;
		Option4.Caption = "4th (Oct - Dec)", ;
		Option4.FontSize = 8, ;
		Option4.Height = 16, ;
		Option4.Left = 281, ;
		Option4.Name = "Q4", ;
		Option4.Top = 11, ;
		Option4.Width = 90
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'Shpshapecustom1' AS shpshapecustom WITH ;
		Height = 62, ;
		Left = 45, ;
		Name = "Shpshapecustom1", ;
		Top = 38, ;
		Width = 373, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'Swrptlook1' AS swrptlook WITH ;
		Left = 155, ;
		Name = "Swrptlook1", ;
		TabIndex = 14, ;
		Top = 254, ;
		ZOrderSet = 4, ;
		Swlookupbutton1.Name = "Swlookupbutton1", ;
		Swlookupbutton2.Name = "Swlookupbutton2", ;
		txtBegID.clistexpression = wells.cwellid, ;
		txtBegID.clistworkarea = wells, ;
		txtBegID.Name = "txtBegID", ;
		TxtBegName.Name = "TxtBegName", ;
		txtEndID.clistexpression = wells.cwellid, ;
		txtEndID.clistworkarea = wells, ;
		txtEndID.Name = "txtEndID", ;
		TxtEndName.Name = "TxtEndName"
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="container" />

	ADD OBJECT 'swstates' AS cbocomboboxcustom WITH ;
		BoundColumn = 1, ;
		BoundTo = .F., ;
		ColumnCount = 1, ;
		ControlSource = "", ;
		FontName = "Courier New", ;
		Height = 20, ;
		Left = 271, ;
		Margin = 2, ;
		Name = "swstates", ;
		RowSource = "", ;
		RowSourceType = 0, ;
		TabIndex = 1, ;
		Top = 11, ;
		Width = 45, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'Swyear1' AS swyear WITH ;
		Height = 20, ;
		Left = 155, ;
		MaxLength = 4, ;
		Name = "Swyear1", ;
		TabIndex = 11, ;
		Top = 192, ;
		Width = 40, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcAcctNo' AS txttextboxcustom WITH ;
		ControlSource = "options.ccomprptno", ;
		Left = 155, ;
		Name = "txtcAcctNo", ;
		TabIndex = 22, ;
		Top = 435, ;
		Visible = .F.
		*< END OBJECT: ClassLib="..\..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE builddata
		LOCAL tcYear, tcWellID1, tcWellID2, tnQuarter, lnWellCnt, ldDate1, tcTaxNumberS, tcTaxNumberC
		LOCAL tlProdPeriod, lcBetween, lnOilRate, lnGasRate, lnTotBBL, lnTotMCF, lnOilRateC, lnGasRateC, lnWellCount
		LOCAL lcAcctNo, llWellID, llAdjust, lnTotalTax, lnTotalMin, lnAdjust, llProportionate
		LOCAL lnTotal, lnWellsProcessed, lnAdjustPct, lnWellCountAdj, lnTaxTotAdj, lnTotalAdjustAmt
		LOCAL lCsTran, lDirGasPurch, lDirOilPurch, lNoShowTotal, lSev1G, lSev1O, lcPeriod1, lcPeriod2
		LOCAL lnCount
		LOCAL cAcctNo, cBatch, cPeriod, cPeriodRange, cRefID, cRevKey, cRevName, cSource, cYear, cidinco
		LOCAL cidincs, dRevDate, jCount, jMax, nBBL, nBBLSevTax, nCostRec, nMCF, nMCFSevTax, nTotalInc
		LOCAL oProgress, tcState
		LOCAL llReturn, loError
		
		PUBLIC ldDate2, lcBatch, lnTotalAdjust, llSendToAllocate
		
		llReturn = .T.
		
		TRY
		
		   getstateformats('OH')
		   
		   tcYear          = THISFORM.swyear1.VALUE
		   tcWellID1       = THISFORM.swrptlook1.txtBegID.VALUE
		   tcWellID2       = THISFORM.swrptlook1.txtEndID.VALUE
		   tcState         = LEFT(THISFORM.swStates.VALUE, 2)
		   tcTaxNumberS    = THISFORM.cboSevTax.VALUE
		   tcTaxNumberC    = THISFORM.cbocostRecovery.VALUE
		   tlProdPeriod    = THISFORM.chkProdPeriod.VALUE
		   lcAcctNo        = THISFORM.txtcAcctNo.VALUE
		   llAdjust        = THISFORM.chklAdjust.VALUE
		   llProportionate = THISFORM.chklproportionate.VALUE
		   llSelected      = thisform.chkselected.value
		
		   IF NOT llSelected
		      SELECT cwellid as cid FROM wells ;
		         INTO CURSOR selected ;
		         WHERE BETWEEN(cwellid,tcWellID1,tcWellID2) ;
		         ORDER BY cid
		   ENDIF 
		
		   * Fix ohsvdata if needed to add cwellstat field
		   IF FILE(m.goapp.cdatafilepath + 'ohsvdata.dbf')
		      IF USED('ohsvdata')
		         USE IN ohsvdata
		      ENDIF
		      USE (m.goapp.cdatafilepath + 'ohsvdata.dbf') EXCLUSIVE IN 0
		      SELECT ohsvdata
		      lnFields  = AFIELDS(laFields, 'ohsvdata')
		      llFoundIt = .F.
		      FOR lnx = 1 TO lnFields
		         IF LOWER(laFields(lnx, 1)) = 'cwellstat'
		            llFoundIt = .T.
		         ENDIF
		      ENDFOR
		      IF NOT llFoundIt
		         swselect('wells')
		         SET ORDER TO cwellid
		         SELECT ohsvdata
		         ALTER TABLE ohsvdata ADD COLUMN cwellstat c(1)
		         SCAN
		            m.cwellid = cwellid
		            SELECT wells
		            IF SEEK(m.cwellid)
		               m.cwellstat = cwellstat
		            ELSE
		               m.cwellstat = 'A'
		            ENDIF
		            SELECT ohsvdata
		            REPLACE cwellstat WITH m.cwellstat
		         ENDSCAN
		      ENDIF
		      USE IN ohsvdata
		   ENDIF
		
		   *  Store the setting for whether to send all income/expense to allocation file, so if
		   *  any adjustments need made, we know whether to put them in income or incsusp
		   SELECT options
		   llSendToAllocate = lSendToAllocate
		
		   *
		   *  Create the oDist object - for netrev purposes below, depending on well options
		   *
		   THISFORM.odist = CREATEOBJECT('distproc', tcWellID1, tcWellID2, ;
		      '12', tcYear, '00', 'W', DATE(), .T., 0)
		
		   tnQuarter  = THISFORM.opgQuarters.VALUE
		
		   CREATE CURSOR taxtemp ;
		      (cwellid        c(10), ;
		      cwellname      c(30), ;
		      cwellstat      c(1), ;
		      nWellCount     N(2, 0),  ;
		      cAcctNo        c(15),  ;
		      nBBL           N(12, 2),  ;
		      nMCF           N(12, 2),  ;
		      nSevTaxOil     N(12, 2),  ;
		      nSevTaxGas     N(12, 2),  ;
		      nCostRecOil    N(12, 2),  ;
		      nCROil         N(12, 2),  ;
		      nCostRecGas    N(12, 2),  ;
		      nCRGas         N(12, 2),  ;
		      cPeriodRange   c(25),  ;
		      cPRange        c(25),  ;
		      nAdjust        N(12, 2),  ;
		      lEvenSplit     L,  ;
		      nWellCountAdj  N(5, 0),  ;
		      nWCAdjust      N(5, 0),  ;
		      nTaxTotAdj     N(12, 2),  ;
		      nWellMin       N(12, 2),  ;
		      cYear          c(4),  ;
		      nQuarter       N(1, 0),  ;
		      lProd          L)
		   INDEX ON cwellid TAG cwellid
		
		
		   *  Set the date ranges for each quarter
		   DO CASE
		      CASE tnQuarter = 1
		         ldDate1   = CTOD('01/01/' + tcYear)
		         ldDate2   = CTOD('03/31/' + tcYear)
		         lcPeriod1 = ALLTRIM(tcYear) + '01'
		         lcPeriod2 = ALLTRIM(tcYear) + '03'
		      CASE tnQuarter = 2
		         ldDate1   = CTOD('04/01/' + tcYear)
		         ldDate2   = CTOD('06/30/' + tcYear)
		         lcPeriod1 = ALLTRIM(tcYear) + '04'
		         lcPeriod2 = ALLTRIM(tcYear) + '06'
		      CASE tnQuarter = 3
		         ldDate1   = CTOD('07/01/' + tcYear)
		         ldDate2   = CTOD('09/30/' + tcYear)
		         lcPeriod1 = ALLTRIM(tcYear) + '07'
		         lcPeriod2 = ALLTRIM(tcYear) + '09'
		      CASE tnQuarter = 4
		         ldDate1   = CTOD('10/01/' + tcYear)
		         ldDate2   = CTOD('12/31/' + tcYear)
		         lcPeriod1 = ALLTRIM(tcYear) + '10'
		         lcPeriod2 = ALLTRIM(tcYear) + '12'
		   ENDCASE
		
		   IF tlProdPeriod
		      SELECT  cwellid,;
		         cwellname,;
		         cwellstat,;
		         IIF(nWellCount = 0, 1, nWellCount) AS nWellCount,  ;
		         cPermit1,;
		         cPermit2,;
		         cPermit3,;
		         cPermit4,;
		         cPermit5,;
		         cPermit6,  ;
		         ALLTRIM(DTOC(ldDate1)) + ' - ' + DTOC(ldDate2) AS cPeriodRange,  ;
		         ALLTRIM(DTOC(ldDate1)) + ' - ' + DTOC(ldDate2) AS cPRange,  ;
		         IIF(tcYear < '2020',15,0) AS nWellMin,;
		         NOT llProportionate AS lEvenSplit,;
		         lcAcctNo AS cAcctNo,  ;
		         tcYear AS cYear,;
		         tnQuarter AS nQuarter,;
		         tlProdPeriod AS lProd  ;
		         FROM wells ;
		         WHERE cwellid in (SELECT cid FROM selected)  ;
		         AND cState = 'OH'  ;
		         AND cTable = tcState  ;
		         AND lthird_prty = .F. ;
		         ORDER BY cwellname ;
		         INTO CURSOR temp
		   ELSE
		      SELECT  cwellid,;
		         cwellname,;
		         cwellstat,;
		         IIF(nWellCount = 0, 1, nWellCount) AS nWellCount,  ;
		         cPermit1,;
		         cPermit2,;
		         cPermit3,;
		         cPermit4,;
		         cPermit5,;
		         cPermit6,  ;
		         ALLTRIM(DTOC(ldDate1)) + ' - ' + DTOC(ldDate2) AS cPeriodRange,  ;
		         ALLTRIM(DTOC(ldDate1)) + ' - ' + DTOC(ldDate2) AS cPRange,  ;
		         IIF(tcYear < '2020',15,0) AS nWellMin,;
		         NOT llProportionate AS lEvenSplit,;
		         lcAcctNo AS cAcctNo, ;
		         tcYear AS cYear,;
		         tnQuarter AS nQuarter,;
		         tlProdPeriod AS lProd  ;
		         FROM wells ;
		         WHERE cwellid in (SELECT cid FROM selected)  ;
		         AND cState = 'OH'  ;
		         AND cTable = tcState  ;
		         AND lthird_prty = .F. ;
		         ORDER BY cwellname ;
		         INTO CURSOR temp
		
		   ENDIF
		
		   IF _TALLY = 0
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   SELECT taxtemp
		   APPEND FROM DBF('temp')
		
		   lnWellCnt = _TALLY
		
		   *  If the ohsvdata.dbf file exists, don't do any new calculations, and replace the taxtemp file with the ohsvdata stuff
		   IF FILE(m.goapp.cdatafilepath + 'ohsvdata.dbf')
		      swselect('ohsvdata')
		      SELECT  * ;
		         FROM ohsvdata  ;
		         WHERE cYear = tcYear ;
		         AND nQuarter = tnQuarter ;
		         AND lProd = tlProdPeriod  ;
		         AND cwellid in (SELECT cid FROM selected)  ;
		         INTO CURSOR temp
		
		      USE IN ohsvdata
		
		      IF _TALLY > 0
		         CREATE CURSOR taxtemp ;
		            (cwellid        c(10), ;
		            cwellname      c(30), ;
		            cwellstat      c(1), ;
		            nWellCount     N(2, 0),  ;
		            cAcctNo        c(15),  ;
		            nBBL           N(12, 2),  ;
		            nMCF           N(12, 2),  ;
		            nSevTaxOil     N(12, 2),  ;
		            nSevTaxGas     N(12, 2),  ;
		            nCostRecOil    N(12, 2),  ;
		            nCROil         N(12, 2),  ;
		            nCostRecGas    N(12, 2),  ;
		            nCRGas         N(12, 2),  ;
		            cPeriodRange   c(25),  ;
		            cPRange        c(25),  ;
		            nAdjust        N(12, 2),  ;
		            lEvenSplit     L,  ;
		            nWellCountAdj  N(5, 0),  ;
		            nWCAdjust      N(5, 0),  ;
		            nTaxTotAdj     N(12, 2),  ;
		            nWellMin       N(12, 2),  ;
		            cYear          c(4),  ;
		            nQuarter       N(1, 0),  ;
		            lProd          L)
		         INDEX ON cwellid TAG cwellid
		
		         SELECT taxtemp
		         APPEND FROM DBF('temp')
		
		         *  Due to long field name issues, a shortened version was included in the taxtemp cursor and the OHSVDATA external file created.
		         *  Once we append the data back in, we just have to copy the 4 long fields back to the right spot, and we're good to go.
		         SELECT taxtemp
		         REPLACE nCostRecOil WITH nCROil, nCostRecGas WITH nCRGas, cPeriodRange WITH cPRange, nWellCountAdj WITH nWCAdjust ALL
		
		      ENDIF
		   ENDIF
		
		
		   oProgress = THISFORM.oMessage.ProgressBar('Calculating Quarterly Taxes...')
		   jMax      = lnWellCnt
		   jCount    = 1
		   oProgress.SetProgressRange(0, jMax)
		
		   SELECT taxtemp
		   SET ORDER TO cwellid
		   SELECT wells
		   SET ORDER TO cwellid
		
		
		   IF tlProdPeriod
		      lcBetween = "between(hYear+hPeriod,lcPeriod1,lcPeriod2)"
		   ELSE
		      lcBetween = "BETWEEN(hdate,ldDate1,ldDate2)"
		   ENDIF
		
		   SELECT  cwellid,  ;
		      SUM(nTotBBL) AS nBBL,  ;
		      SUM(nTotMCF) AS nMCF,  ;
		      SUM(ntotbbltx&tcTaxNumberS) AS nSevTaxOil, ;
		      SUM(ntotmcftx&tcTaxNumberS) AS nSevTaxGas, ;
		      SUM(ntotbbltx&tcTaxNumberC) AS nCostRecOil, ;
		      SUM(ntotbbltx&tcTaxNumberC) AS nCROil, ;
		      SUM(ntotmcftx&tcTaxNumberC) AS nCostRecGas, ;
		      SUM(ntotmcftx&tcTaxNumberC) AS nCRGas ;
		      FROM wellhist  ;
		      WHERE cwellid in (SELECT cid FROM selected)  ;
		      AND &lcBetween  ;
		      AND cwellid IN(SELECT  cwellid ;
		      FROM wells ;
		      WHERE cTable = tcState)  ;
		      INTO CURSOR histtemp READWRITE  ;
		      GROUP BY cwellid  ;
		      ORDER BY cwellid
		
		
		   *  If they have the cost recovery set us as tax 4, we need to look at the runs
		   *  with accounting dates in this quarter, and then scan the income table for
		   *  those runs, and back out any adjustment entries, so they're not showing as
		   *  an amount collected for this quarter, since it technically is for the previous
		   *  quarter's production. Remove it from histtemp, before it does the netting below.
		   IF tcTaxNumberC = '4'
		      SELECT sysctl
		      SCAN FOR BETWEEN(dAcctDate, ldDate1, ldDate2) AND cTypeClose = 'R'
		         SELECT income
		         SCAN FOR nRunNo = sysctl.nRunNo AND cRunYear = sysctl.cRunYear  ;
		               AND cSource = 'OTAX4' AND cRevKey = 'COST'
		            SELECT histtemp
		            LOCATE FOR cwellid == income.cwellid
		            IF FOUND()
		               *  nCostRecOil is positive, the number from income is negative, so add them together
		               REPLACE nCostRecOil WITH nCostRecOil + income.nTotalInc
		            ENDIF
		         ENDSCAN
		      ENDSCAN
		   ENDIF
		
		   * Remove inactive and plugged wells that had no production
		   SELECT taxtemp
		   SCAN FOR NOT INLIST(cwellstat, 'A', 'N')
		      m.cwellid = cwellid
		      SELECT histtemp
		      LOCATE FOR cwellid = m.cwellid
		      IF NOT FOUND()
		         SELECT taxtemp
		         DELETE NEXT 1
		      ENDIF
		   ENDSCAN
		
		   SELECT histtemp
		   SCAN
		      SCATTER MEMVAR
		
		      SELECT taxtemp
		      IF SEEK(m.cwellid)
		         * If they didn't have any production and they're not active or shut-in, delete the record
		         IF m.nBBL = 0 AND m.nMCF = 0 AND NOT INLIST(taxtemp.cwellstat, 'A', 'N')
		            DELETE NEXT 1
		            LOOP
		         ENDIF
		
		         REPLACE nBBL WITH m.nBBL, ;
		            nMCF WITH m.nMCF, ;
		            nSevTaxOil WITH m.nSevTaxOil, ;
		            nSevTaxGas WITH m.nSevTaxGas, ;
		            nCostRecOil WITH m.nCostRecOil, ;
		            nCROil WITH m.nCROil, ;
		            nCostRecGas WITH m.nCostRecGas, ;
		            nCRGas WITH m.nCRGas
		
		         SELECT wells
		         IF SEEK(m.cwellid)
		            m.lDirOilPurch = lDirOilPurch
		            m.lDirGasPurch = lDirGasPurch
		            m.lSev1O       = lSev1O
		            m.lSev1G       = lSev1G
		         ELSE
		            m.lDirOilPurch = .F.
		            m.lDirGasPurch = .F.
		            m.lSev1O       = .F.
		            m.lSev1G       = .F.
		         ENDIF
		
		         IF m.lSev1O
		            SELECT taxtemp
		            REPLACE nBBL WITH 0
		         ELSE
		            *  If the purchaser withholds taxes on direct pays, remove the bbl
		            IF m.lDirOilPurch
		               SELECT taxtemp
		               REPLACE nBBL WITH THISFORM.odist.netrev(m.cwellid, m.nBBL, 'O')
		            ENDIF
		         ENDIF
		
		
		         IF m.lSev1G
		            SELECT taxtemp
		            REPLACE nMCF WITH 0
		         ELSE
		            IF m.lDirGasPurch
		               SELECT taxtemp
		               REPLACE nMCF WITH THISFORM.odist.netrev(m.cwellid, m.nMCF, 'G')
		            ENDIF
		         ENDIF
		
		      ENDIF
		      oProgress.UpdateProgress(jCount)
		      jCount = jCount + 1
		   ENDSCAN
		
		   oProgress.CloseProgress()
		
		   DO CASE
		         *  Cost Recovery Fee Worksheet
		      CASE THISFORM.opgPrint.VALUE = 1
		
		         THISFORM.cTitle1         = 'Ohio Form SV 3A Worksheet'
		         THISFORM.cTitle2         = 'For Year ' + tcYear + ', ' + IIF(tnQuarter = 1, 'First', IIF(tnQuarter = 2, 'Second', IIF(tnQuarter = 3, 'Third', 'Fourth'))) + ' Quarter'
		         IF tcYear < '2020'
		            THISFORM.cReportName     = 'commonsource\dmrohtax'
		         ELSE
		            THISFORM.cReportName     = 'commonsource\dmrohtax1'
		         ENDIF    
		         THISFORM.cSelectCriteria = ''
		         THISFORM.cSortOrder      = 'Well ID'
		
		         *  Calculate each well's portion of any adjustments
		         WAIT WINDOW NOWAIT 'Calculating well amounts'
		
		         *  Total minimum that needs collected
		         SELECT taxtemp
		         
		         IF tcYear < '2020'
		            SUM(nWellCount) * 15 TO lnTotalMin
		         ELSE
		            lnTotalMin = 0
		         ENDIF    
		         *  Total amount collected
		         SUM(nSevTaxOil + nSevTaxGas + nCostRecOil + nCostRecGas) TO lnTotalTax
		
		         *  We only care about splitting stuff if the amount collected is less than the minimum
		         IF tcYear < '2020'
		            IF lnTotalTax < lnTotalMin
		               lnTotalAdjust = lnTotalMin - lnTotalTax
		               IF llProportionate
		                  SELECT taxtemp
		                  SCAN
		                     IF nSevTaxOil + nSevTaxGas + nCostRecOil + nCostRecGas < nWellMin * nWellCount
		                        REPLACE nAdjust WITH (nWellMin * nWellCount) - (nSevTaxOil + nSevTaxGas + nCostRecOil + nCostRecGas)
		                     ELSE
		                        REPLACE nAdjust WITH 0
		                     ENDIF
		                  ENDSCAN
		
		                  *  Now that we know how much each well that didn't meet the minimum SHOULD pay, we'll add that
		                  *  to the amount already collected, and only adjust the remainder
		                  SUM(nAdjust) TO lnTotalAdjustAmt
		                  lnAdjustPct = swround((lnTotalMin - lnTotalTax) / lnTotalAdjustAmt, 10)
		
		                  SELECT taxtemp
		                  SCAN FOR nAdjust # 0
		                     REPLACE nAdjust WITH swround(nAdjust * lnAdjustPct, 2)
		                  ENDSCAN
		
		                  *  Now that we've adjusted them all, add up the total again, and the adjust the last well
		                  *  to make sure the total comes out to the amount we need to meet the minimum
		                  SELECT taxtemp
		                  SUM(nSevTaxOil + nSevTaxGas + nCostRecOil + nCostRecGas + nAdjust) TO lnTotal
		
		                  *  Find last record that actually got an adjustment
		                  GO BOTT
		                  DO WHILE nAdjust = 0
		                     SKIP - 1
		                  ENDDO
		
		                  REPLACE nAdjust WITH nAdjust + (lnTotalMin - lnTotal)
		
		                  *  Add up how many wells with adjustments there are, and what their total taxes are
		                  SUM(nWellCount) TO lnWellCountAdj FOR nAdjust # 0
		                  SUM(nSevTaxOil + nSevTaxGas + nCostRecOil + nCostRecGas) TO lnTaxTotAdj FOR nAdjust # 0
		
		                  REPLACE nWellCountAdj WITH lnWellCountAdj, nWCAdjust WITH lnWellCountAdj, nTaxTotAdj WITH lnTaxTotAdj ALL
		
		               ELSE
		                  *  Not proportionate, so we'll just split any adjustment evenly
		                  SELECT taxtemp
		
		                  *  Total number of wells to create adjustments for
		                  SUM(nWellCount) TO lnWellCount
		
		                  *  Running total as it adds the adjustments
		                  STORE 0 TO lnTotal, lnWellsProcessed
		
		                  IF lnTotalTax < lnTotalMin
		                     lnAdjust = ROUND((lnTotalMin - lnTotalTax) / lnWellCount, 2)
		
		                     SELECT taxtemp
		                     SCAN
		                        lnWellsProcessed = lnWellsProcessed + taxtemp.nWellCount
		                        *  If we're not at the last well, just add it to each line, and update the running total
		                        IF lnWellsProcessed # lnWellCount
		                           REPLACE taxtemp.nAdjust WITH lnAdjust * nWellCount
		                           lnTotal = lnTotal + (lnAdjust * nWellCount)
		                        ELSE
		                           REPLACE taxtemp.nAdjust WITH (lnTotalMin - lnTotalTax) - lnTotal
		                        ENDIF
		                     ENDSCAN
		                  ENDIF
		               ENDIF
		            ELSE
		               IF llAdjust AND (m.goapp.lAMVersion OR m.goapp.lQBVersion)
		                  THISFORM.oMessage.Warning('The taxes collected exceeded the minimum required, so there will be no adjusting entries created or posted.')
		               ENDIF
		            ENDIF
		
		
		            *  If creating the adjustment
		            IF llAdjust AND lnTotalTax < lnTotalMin
		
		               * Check to make sure all wells are marked that oTax4 is withheld by purchaser.
		               swselect('wells')
		               LOCATE FOR cwellstat = 'A' AND cState = 'OH' AND NOT lsev4o
		               IF FOUND()
		                  REPLACE lsev4o WITH .T. FOR cwellstat = 'A' AND cState = 'OH' AND NOT lsev4o
		               ENDIF
		
		               *  Check to make sure the date at the end of the quarter isn't in a closed fiscal year/period.
		               IF m.goapp.lAMVersion
		                  IF NOT THISFORM.glmaint.CheckPeriod(ldDate2, .T.)
		                     THISFORM.oMessage.Warning('The adjustments will post with a date that is the last day in the quarter the report is based on. Either the fiscal year or period represented by this date has been closed, so no adjustments can be made.')
		                     llReturn = .F.
		                     EXIT
		                  ENDIF
		               ENDIF
		
		               *  Check for existing entries, and warn them if they already exist
		               SELECT income
		               LOCATE FOR cRevKey = 'COST' AND nRunNo = 0
		               IF FOUND()
		                  IF NOT THISFORM.oMessage.CONFIRM('There appear to be cost recovery fee adjustments in the New Run already.  Continue creating them?')
		                     llReturn = .F.
		                     EXIT
		                  ENDIF
		               ELSE
		                  SELECT incsusp
		                  LOCATE FOR cRevKey = 'COST'
		                  IF FOUND()
		                     IF NOT THISFORM.oMessage.CONFIRM('There appear to be cost recovery fee adjustments created already.  Continue creating them?')
		                        llReturn = .F.
		                        EXIT
		                     ENDIF
		                  ENDIF
		               ENDIF
		
		               *  Add a bogus cost recovery purchaser to put on the entries, if it doesn't already exist
		               SELECT revsrc
		               LOCATE FOR cRevKey = 'COST'
		               IF NOT FOUND()
		                  m.cRevKey  = 'COST'
		                  m.cRevName = 'Cost Recovery Adjust'
		                  INSERT INTO revsrc FROM MEMVAR
		                  = TABLEUPDATE(.T.)
		               ENDIF
		
		               m.cBatch = THISFORM.oregistry.incrementcounter('%Shared.Counters.Batch')
		               lcBatch  = m.cBatch
		
		               *  Check posting accounts for the AM, and kick it back if they're not specified
		               IF m.goapp.lAMVersion
		                  swselect('glmaster', .T.)
		                  swselect('options')
		                  GO TOP
		                  IF EMPTY(cTaxAcct4)
		                     THISFORM.oMessage.Warning('The correcting entries will post as OTAX4 entries. Please specify the Product Tax 4 Payable account in Preferences before attempting to create the correcting entries.')
		                     llReturn = .F.
		                     EXIT
		                  ENDIF
		                  swselect('glopt')
		                  GO TOP
		                  IF EMPTY(cRevClear)
		                     THISFORM.oMessage.Warning('Please specify the Revenue Clearing Account on the Edit >> Preferences screen before creating the correcting entries.')
		                     llReturn = .F.
		                     EXIT
		                  ENDIF
		
		                  *  Set the shared properties of the glmaint object for posting
		                  THISFORM.glmaint.cSource    = 'DM'
		                  THISFORM.glmaint.cBatch     = m.cBatch
		                  THISFORM.glmaint.dGLDate    = ldDate2
		                  THISFORM.glmaint.cReference = IIF(tnQuarter = 1, '1st', IIF(tnQuarter = 2, '2nd', IIF(tnQuarter = 3, '3rd', '4th'))) + ' Quarter, ' + tcYear
		                  THISFORM.glmaint.cBunch     = ''
		                  THISFORM.glmaint.cDesc      = 'Cost Recovery Fee Adjustment'
		                  THISFORM.glmaint.cId        = ''
		                  THISFORM.glmaint.cCatCode   = ''
		                  THISFORM.glmaint.cdeptno    = ''
		               ENDIF
		
		               IF m.goapp.lQBVersion AND NOT m.goapp.lQBActive
		                  THISFORM.oMessage.Warning('There is no active connection to QB, so no adjustments can be made. Connect to QB, and try again.')
		                  llReturn = .T.
		                  EXIT
		               ENDIF
		
		
		               SELECT taxtemp
		               SCAN
		                  SCATTER MEMVAR
		
		                  WAIT WINDOW NOWAIT 'Creating adjustment for well: ' + m.cwellid
		
		                  m.nTotalInc = m.nAdjust
		
		                  *  Gross up the amounts by the amount of dummy ownership in the well
		                  *  Should only be getting grossed based on dummy ownership, not DP, based on Keith's testing
		                  m.nTotalInc = THISFORM.odist.netrev(m.cwellid, m.nTotalInc, 'O4', .T., .F., .T.) * -1
		
		                  m.cYear    = tcYear
		                  m.cPeriod  = RIGHT(ALLTRIM(lcPeriod2), 2)
		                  m.dRevDate = ldDate2
		                  m.cSource  = 'OTAX4'
		                  m.cRevKey  = 'COST'
		                  m.cRefID   = 'Cost Rec'
		
		                  *  Set as coming from a prod receipt, so that it can't be deleted easily
		                  m.lCsTran = .T.
		
		                  IF m.nTotalInc # 0
		                     IF llSendToAllocate
		                        m.cidincs    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		                        SELECT incsusp1
		                        SET DELE OFF
		                        SET ORDER TO cidincs
		                        DO WHILE SEEK(m.cidincs)
		                           m.cidincs    = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		                        ENDDO
		                        SET DELE ON
		                        INSERT INTO incsusp FROM MEMVAR
		                     ELSE
		                        m.cidinco = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		                        SELECT income1
		                        SET DELETED OFF
		                        SET ORDER TO cidinco
		                        DO WHILE SEEK(m.cidinco)
		                           m.cidinco = THISFORM.oregistry.incrementcounter('%Shared.Counters.Income')
		                        ENDDO
		                        SET DELE ON
		                        INSERT INTO income FROM MEMVAR
		                     ENDIF
		                  ENDIF
		
		                  *  Create posting entries for each individual well
		                  IF m.goapp.lAMVersion
		                     THISFORM.glmaint.cAcctNo = glopt.cRevClear
		                     THISFORM.glmaint.cUnitNo = m.cwellid
		                     THISFORM.glmaint.nAmount = m.nAdjust  &&  Use taxtemp.nadjust, since that's the net amount before grossing up.
		                     THISFORM.glmaint.updatebatch()
		                  ENDIF
		               ENDSCAN
		
		
		               SELECT income
		               = TABLEUPDATE(.T.)
		               SELECT incsusp
		               = TABLEUPDATE(.T.)
		
		               WAIT CLEAR
		
		               IF m.goapp.lAMVersion
		                  *  Create the GL entry for the total, to the sevtax4 payable account
		
		                  SELECT taxtemp
		                  SUM(nAdjust) TO lnTotal
		
		                  THISFORM.glmaint.cAcctNo = options.cTaxAcct4
		                  THISFORM.glmaint.cUnitNo = ''
		                  THISFORM.glmaint.nAmount = lnTotal * -1
		                  THISFORM.glmaint.updatebatch()
		
		                  SELECT glmaster
		                  = TABLEUPDATE(.T.)
		               ENDIF
		
		               IF m.goapp.lQBVersion
		                  *  If the QB posting fails, delete the income entries created
		                  IF NOT THISFORM.QBPost()
		                     SELECT income
		                     SCAN FOR cBatch = m.cBatch
		                        DELETE NEXT 1
		                     ENDSCAN
		                     SELECT incsusp
		                     SCAN FOR cBatch = m.cBatch
		                        DELETE NEXT 1
		                     ENDSCAN
		                     SELECT income
		                     = TABLEUPDATE(.T.)
		                     SELECT incsusp
		                     = TABLEUPDATE(.T.)
		                  ELSE
		                     *  Update the transaction IDs in the inctxnid file, so they can be unposted later, if necessary
		                     SELECT inctxnid
		                     = TABLEUPDATE(.T.)
		                  ENDIF
		               ENDIF
		
		               THISFORM.oMessage.DISPLAY('Finished creating the adjustments for each well.')
		
		            ENDIF
		         ENDIF
		
		
		         *  If we're creating the adjustments, store the values from taxtemp into an external table.
		         *  If we're reprinting it later, we just pull the values from the external table
		         IF llAdjust
		            WAIT WINDOW NOWAIT 'Saving records...'
		            IF FILE(m.goapp.cdatafilepath + 'ohsvdata.dbf')
		               *  We've found an existing ohsvdata file, so check to see if there are records for this quarter.
		               *  If it exists, delete it, and replace it with the current taxtemp data
		               swselect('ohsvdata.dbf')
		               SCAN FOR cYear = tcYear AND nQuarter = tnQuarter AND lProd = tlProdPeriod
		                  DELETE NEXT 1
		               ENDSCAN
		
		               SELECT taxtemp
		               SCAN
		                  SCATTER MEMVAR
		                  INSERT INTO ohsvdata FROM MEMVAR
		               ENDSCAN
		            ELSE
		               *  Table doesn't exist, so we'll create it
		               SELECT  * ;
		                  FROM taxtemp  ;
		                  INTO CURSOR temp
		
		               IF _TALLY > 0
		                  SELECT temp
		                  COPY TO m.goapp.cdatafilepath + 'ohsvdata'
		               ENDIF
		            ENDIF
		         ENDIF
		
		         SELECT taxtemp
		         DELETE FOR nBBL = 0 AND nMCF = 0 AND NOT INLIST(cwellstat, 'A', 'N')
		
		         *  Add up how many wells with adjustments there are, and what their total taxes are
		         SUM(nWellCount) TO lnWellCountAdj FOR nAdjust # 0
		         SUM(nSevTaxOil + nSevTaxGas + nCostRecOil + nCostRecGas) TO lnTaxTotAdj FOR nAdjust # 0
		         REPLACE nWellCountAdj WITH lnWellCountAdj, nWCAdjust WITH lnWellCountAdj, nTaxTotAdj WITH lnTaxTotAdj ALL
		
		         SELECT taxtemp
		         COUNT FOR NOT DELETED() TO lnCount
		         IF lnCount > 0
		            llReturn = .T.
		         ELSE
		            llReturn = .F.
		         ENDIF
		
		         *  Cost Recovery Schedule (SV 3A) or Severance Tax Return (SV 3)
		      CASE THISFORM.opgPrint.VALUE = 2 OR THISFORM.opgPrint.VALUE = 3
		         *  Get the current sev tax rates for oil/gas, so we can do the calcs for the wells on the worksheet, so
		         *  that number can be plugged into line 1 of the sv 3a report.
		
		         IF EMPTY(lcAcctNo)
		            THISFORM.oMessage.Warning('Printing either the SV3 or SV3A report without a valid account number can delay its processing or cause it to be rejected by the state.')
		         ENDIF
		
		         SELECT sevtax
		         LOCATE FOR cTable = tcState
		         IF FOUND()
		            DO CASE
		               CASE tcTaxNumberS = '1'
		                  lnOilRate = nTaxBBL1
		                  lnGasRate = nTaxMCF1
		               CASE tcTaxNumberS = '2'
		                  lnOilRate = nTaxBBL2
		                  lnGasRate = nTaxMCF2
		               CASE tcTaxNumberS = '3'
		                  lnOilRate = nTaxBBL3
		                  lnGasRate = nTaxMCF3
		               CASE tcTaxNumberS = '4'
		                  lnOilRate = nTaxBBL4
		                  lnGasRate = nTaxMCF4
		            ENDCASE
		            DO CASE
		               CASE tcTaxNumberC = '1'
		                  lnOilRateC = nTaxBBL1
		                  lnGasRateC = nTaxMCF1
		               CASE tcTaxNumberC = '2'
		                  lnOilRateC = nTaxBBL2
		                  lnGasRateC = nTaxMCF2
		               CASE tcTaxNumberC = '3'
		                  lnOilRateC = nTaxBBL3
		                  lnGasRateC = nTaxMCF3
		               CASE tcTaxNumberC = '4'
		                  lnOilRateC = nTaxBBL4
		                  lnGasRateC = nTaxMCF4
		            ENDCASE
		         ELSE
		            lnOilRate  = .1
		            lnGasRate  = .025
		            lnOilRateC = .1
		            lnGasRateC = .005
		         ENDIF
		
		         *  Sum the total BBLs and MCF from the taxtemp cursor
		         SELECT taxtemp
		         SUM(nBBL) TO lnTotBBL
		         SUM(nMCF) TO lnTotMCF
		         SUM(nWellCount) TO lnWellCount
		
		         SELECT  ROUND(lnTotBBL * lnOilRate, 2) + ROUND(lnTotMCF * lnGasRate, 2) AS nSevTaxes,  ;
		            lnTotBBL AS nBBL,  ;
		            lnTotMCF AS nMCF,  ;
		            lcAcctNo AS cAcctNo,  ;
		            ROUND(lnTotBBL * lnOilRateC, 2) AS nBBLTax,  ;
		            ROUND(lnTotMCF * lnGasRateC, 2) AS nMCFTax,  ;
		            cPeriodRange,  ;
		            SUM(nWellCount) AS nWellCount,  ;
		            IIF(tcYear < '2020',lnWellCount * 15,0) AS nTotalMin  ;
		            FROM taxtemp  ;
		            INTO CURSOR ohsv3atemp
		
		         STORE '' TO THISFORM.cTitle1, THISFORM.cTitle2, THISFORM.cSelectCriteria, THISFORM.cSortOrder
		
		         IF THISFORM.opgPrint.VALUE = 2
		            THISFORM.cReportName = m.goapp.cRptsFolder + 'ohformsv3a'
		
		            SELECT ohsv3atemp
		            IF RECCOUNT() > 0
		               llReturn = .T.
		               EXIT
		            ELSE
		               llReturn = .F.
		               EXIT
		            ENDIF
		         ELSE
		            CREATE CURSOR ohsv3temp  ;
		               (nBBLSevTax  N(12, 2),  ;
		               nMCFSevTax   N(12, 2),  ;
		               nBBL         N(12, 2),  ;
		               nMCF         N(12, 2),  ;
		               nCostRec     N(12, 2),  ;
		               cPeriodRange c(25),  ;
		               cAcctNo     c(15),  ;
		               lNoShowTotal L)
		
		            m.nBBLSevTax   = ROUND(lnTotBBL * lnOilRate, 2)
		            m.nMCFSevTax   = ROUND(lnTotMCF * lnGasRate, 2)
		            m.cPeriodRange = ALLTRIM(DTOC(ldDate1)) + ' - ' + DTOC(ldDate2)
		            SELECT ohsv3atemp
		            m.nCostRec = nBBLTax + nMCFTax
		            IF nTotalMin > (m.nCostRec + m.nBBLSevTax + m.nMCFSevTax)
		               m.nCostRec = nTotalMin - m.nBBLSevTax - m.nMCFSevTax
		            ENDIF
		            m.lNoShowTotal = THISFORM.chklNoShowTotal.VALUE
		            m.cAcctNo      = lcAcctNo
		            m.nBBL         = lnTotBBL
		            m.nMCF         = lnTotMCF
		
		            INSERT INTO ohsv3temp FROM MEMVAR
		
		            THISFORM.cReportName = m.goapp.cRptsFolder + 'ohformsv3'
		
		            SELECT ohsv3temp
		            IF RECCOUNT() > 0
		               llReturn = .T.
		               EXIT
		            ELSE
		               llReturn = .F.
		               EXIT
		            ENDIF
		         ENDIF
		   ENDCASE
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'BuildData', loError.LINENO, 'DMROHTAX', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
	ENDPROC

	PROCEDURE calctax1		&& Calculates tax 1
	ENDPROC

	PROCEDURE calctax1qtr		&& Calculate tax 1 by quarter
	ENDPROC

	PROCEDURE calctax2		&& calculate taxes 2
	ENDPROC

	PROCEDURE calctax2qtr		&& Calculate tax 2 by quarter
	ENDPROC

	PROCEDURE calctax3		&& Calculates tax 3
	ENDPROC

	PROCEDURE calctax3qtr		&& Calculates Tax 3 by Quarter
	ENDPROC

	PROCEDURE calctax4		&& Calculates Tax 4
	ENDPROC

	PROCEDURE calctax4qtr		&& Calculates Tax 4 by Quarter
	ENDPROC

	PROCEDURE Init
		LPARA tcTaxType
		
		IF TYPE('tcTaxType') <> 'C'
		   tcTaxType = 'S'
		ENDIF
		
		SET DELETED ON
		
		
		SELECT wells
		SET ORDER TO cWellID
		
		GO TOP
		THISFORM.swrptlook1.txtBegName.VALUE = cwellname
		THISFORM.swrptlook1.txtBegID.VALUE = cWellID
		
		GO BOTTOM
		THISFORM.swrptlook1.txtEndName.VALUE = cwellname
		THISFORM.swrptlook1.txtEndID.VALUE = cWellID
		
		THISFORM.swyear1.lenabled = .T.
		
		SELECT sevtax
		LOCATE FOR cTable = 'OH' OR 'OHIO' $ UPPER(cDescription)
		IF FOUND()
		   THISFORM.swstates.VALUE = cTable+' - '+cDescription
		
		   *  Try and figure out what tax calculation is sev and which is cost recovery,
		   *  and change the dropdown settings accordingly.
		   *  Only need to check for something other than severance being #1
		   *  and cost recovery being #2, since that's how they are by default.
		   DO CASE
		      CASE 'SEVERANCE' $ UPPER(cNameBBL2) OR 'SEVERANCE' $ UPPER(cNameMCF2)
		         THISFORM.cbosevTax.LISTITEMID = 2
		      CASE 'SEVERANCE' $ UPPER(cNameBBL3) OR 'SEVERANCE' $ UPPER(cNameMCF3)
		         THISFORM.cbosevTax.LISTITEMID = 3
		      CASE 'SEVERANCE' $ UPPER(cNameBBL4) OR 'SEVERANCE' $ UPPER(cNameMCF4)
		         THISFORM.cbosevTax.LISTITEMID = 4
		   ENDCASE
		
		   DO CASE
		      CASE 'RECOVERY' $ UPPER(cNameBBL1) OR 'RECOVERY' $ UPPER(cNameMCF1)
		         THISFORM.cboCostRecovery.LISTITEMID = 1
		      CASE 'RECOVERY' $ UPPER(cNameBBL3) OR 'RECOVERY' $ UPPER(cNameMCF3)
		         THISFORM.cboCostRecovery.LISTITEMID = 3
		      CASE 'RECOVERY' $ UPPER(cNameBBL4) OR 'RECOVERY' $ UPPER(cNameMCF4)
		         THISFORM.cboCostRecovery.LISTITEMID = 4
		   ENDCASE
		ENDIF
		
		*  Set date and quarter automatically to the last quarter, to try and prevent people from creating adjustments
		*  for the current quarter instead of the last one.
		DO CASE
		   CASE BETWEEN(MONTH(DATE()),1,3)
		      THISFORM.opgquarters.VALUE = 4
		      THISFORM.swyear1.VALUE = ALLTRIM(STR(YEAR(DATE())-1))
		   CASE BETWEEN(MONTH(DATE()),4,6)
		      THISFORM.opgquarters.VALUE = 1
		   CASE BETWEEN(MONTH(DATE()),7,9)
		      THISFORM.opgquarters.VALUE = 2
		   OTHERWISE
		      THISFORM.opgquarters.VALUE = 3
		ENDCASE
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE qbpost
		LOCAL lnTotal
		
		STORE 0 TO lnTotal
		
		swselect('options')
		GO TOP
		IF EMPTY(cTaxAcct4)
		   THISFORM.oMessage.Warning('The correcting entries will post as OTAX4 entries. Please specify the Product Tax 4 Payable account in Preferences before attempting to create the correcting entries.')
		   RETURN .F.
		ENDIF
		
		swselect('glopt')
		GO TOP
		IF EMPTY(cRevClear)
		   THISFORM.oMessage.Warning('Please specify the Revenue Clearing Account on the Edit >> Preferences screen before creating the correcting entries.')
		   RETURN .F.
		ENDIF
		
		*
		*  Create the G/L journal entries for this invoice
		*
		
		IF m.goapp.oQB.lqbactive
		
		   IF m.goapp.oQB.oqbsm.IsErrorRecoveryInfo()
		      loresp = m.goapp.oQB.oqbsm.geterrorrecoverystatus()
		      lcxml  = loresp.toxmlstring()
		      loresponse = loresp.responselist.getat(0)
		      IF loresponse.statuscode = 0
		         lcreq  = m.goapp.oQB.oqbsm.getsavedmsgsetrequest()
		         m.goapp.oQB.oqbsm.ClearErrorRecovery()
		      ELSE
		         MESSAGEBOX(lcxml,48,'Error Recovery Info')
		      ENDIF
		   ENDIF
		
		   * get a message set request object (version 1.1 xml)
		   loRequest = m.goapp.oQB.oQBRequest
		
		   * set the on error attribute for the request
		   loRequest.ATTRIBUTES.OnError = 1
		   loRequest.clearrequests()
		
		   *  Setup the receipt add request
		   loRcptAdd = loRequest.AppendJournalEntryAddRq()
		
		   loRcptAdd.RefNumber.SetValue('')
		   loRcptAdd.TxnDate.SetValue(ldDate2)
		
		   *loDebit.EntityRef.ListID.SetValue('')
		
		   *  Add detail lines
		   IF llSendToAllocate
		      SELECT incsusp
		   else
		      SELECT income
		   ENDIF 
		   SCAN FOR cbatch == lcBatch
		      SCATTER MEMVAR
		
		      *  Net back down the entry here, eliminating only dummy owners
		      m.nTotalInc = THISFORM.odist.netrev(m.cwellid, m.nTotalInc, 'O1', .F.,.F.,.T.) * -1
		
		      lnTotal = lnTotal + m.nTotalInc
		
		      IF m.nTotalInc > 0  &&  It should be
		         IF m.goapp.oQB.qbfcversion > ' 4.0'
		            loEntry = loRcptAdd.orjournallinelist.APPEND.JournalDebitLine
		         ELSE
		            loEntry = loRcptAdd.JournalDebitLineList.APPEND
		         ENDIF
		
		         loEntry.AccountRef.ListID.SetValue(glopt.cRevClear)
		         loEntry.Amount.SetValue(ROUND(m.nTotalInc,2))
		      ENDIF
		
		      IF NOT EMPTY(m.cwellid)
		         SELE wells
		         LOCATE FOR cwellid = m.cwellid
		         IF FOUND()
		            IF EMPTY(ALLT(wells.cListID))
		               THISFORM.oMessage.Warning('The entry cannot be saved.  The wells file needs to be synchronized with QuickBooks.')
		               loRequest.clearrequests()
		               RETURN .F.
		            ENDIF
		            loEntry.ClassRef.ListID.SetValue(wells.cListID)
		         ENDIF
		      ENDIF
		
		
		      loEntry.MEMO.SetValue('Cost Recovery Fee Adjustment')
		   ENDSCAN
		   
		   *  Lump sum into the tax payable account
		   IF m.goapp.oQB.qbfcversion > ' 4.0'
		      loEntry = loRcptAdd.orjournallinelist.APPEND.JournalCreditLine
		   ELSE
		      loEntry = loRcptAdd.JournalCreditLineList.APPEND
		   ENDIF
		   loEntry.AccountRef.ListID.SetValue(options.cTaxAcct4)
		   loEntry.Amount.SetValue(ROUND(lnTotal,2))
		
		
		   loresponse = m.goapp.oQB.oqbsm.DoRequests(loRequest)
		   loAddResp  = loresponse.responselist.getat(0)
		
		   IF loAddResp.statuscode = 0
		      WAIT WIND NOWAIT 'Receipt successfully added in QuickBooks'
		
		      loNewCheck = loAddResp.DETAIL
		      m.ctxnid  = loNewCheck.TxnID.getvalue()
		
		      SELECT income
		      SCAN FOR cbatch = lcBatch
		         swselect('inctxnid',.T.)
		         LOCATE FOR cidinco = income.cidinco
		         IF FOUND()
		            REPL ctxnid WITH m.ctxnid
		         ELSE
		            INSERT INTO inctxnid FROM MEMVAR
		         ENDIF
		      ENDSCAN
		      
		      SELECT incsusp
		      SCAN FOR cbatch = lcBatch
		         swselect('inctxnid',.T.)
		         LOCATE FOR cidinco = incsusp.cidincs
		         IF FOUND()
		            REPL ctxnid WITH m.ctxnid
		         ELSE
		            INSERT INTO inctxnid FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		      m.goapp.oQB.oqbsm.ClearErrorRecovery()
		   ELSE
		      IF 'object' $ LOWER(loAddResp.statusmessage)
		         lcListID = SUBSTR(loAddResp.statusmessage,AT('"',loAddResp.statusmessage)+1,AT('"',loAddResp.statusmessage,2)-(AT('"',loAddResp.statusmessage)+1))
		         llResult = m.goapp.oQB.QBListID(lcListID,THISFORM.DATASESSIONID)
		         IF llResult
		            SELECT QBListID
		            IF QBListID.cType = 'Account'
		               lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' specified in the ' + ;
		                  'QB Posting Preferences was not found in QuickBooks. Please select a new account ' + ;
		                  'and try to save the receipt again.'
		            ELSE
		               lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' was not found in QuickBooks. ' + ;
		                  'Please synchronize the ' + ALLTRIM(QBListID.cType) + ' file and try to save the receipt again.'
		            ENDIF
		         ELSE
		            lcMessage = loAddResp.statusmessage
		         ENDIF
		         THISFORM.oMessage.severe(lcMessage)
		      ELSE
		         THISFORM.oMessage.severe(loAddResp.statusmessage)
		      ENDIF
		      m.goapp.oQB.oqbsm.ClearErrorRecovery()
		      RETURN .F.
		   ENDIF
		ENDIF
		
		
	ENDPROC

	PROCEDURE cboCostRecovery.Init
		this.addlistitem('Tax Calculation 1',1,1)
		this.addlistitem('1',1,2)
		this.addlistitem('Tax Calculation 2',2,1)
		this.addlistitem('2',2,2)
		this.addlistitem('Tax Calculation 3',3,1)
		this.addlistitem('3',3,2)
		this.addlistitem('Tax Calculation 4',4,1)
		this.addlistitem('4',4,2)
		
		this.listitemid = 2
	ENDPROC

	PROCEDURE cboSevTax.Init
		this.addlistitem('Tax Calculation 1',1,1)
		this.addlistitem('1',1,2)
		this.addlistitem('Tax Calculation 2',2,1)
		this.addlistitem('2',2,2)
		this.addlistitem('Tax Calculation 3',3,1)
		this.addlistitem('3',3,2)
		this.addlistitem('Tax Calculation 4',4,1)
		this.addlistitem('4',4,2)
		
		this.listitemid = 1
	ENDPROC

	PROCEDURE chklAdjust.Click
		IF this.Value
		   thisform.oMessage.warning('This option should only be selected after reviewing the numbers shown on the worksheet. It will create entries for each well in the New Run equal to the amount shown as an adjustment on the worksheet.')
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE chkSelected.Click
		IF this.Value
		   DO FORM commonsource\selected-ids WITH 'WELL' LINKED 
		   lnCount = RECCOUNT('selected')
		   thisform.lblselected.Caption = TRANSFORM(lnCount) + ' Wells Selected'
		   thisform.lblselected.Visible = .T.
		   thisform.lblbegID.Visible = .F.
		   thisform.lblendID.Visible = .F.
		   thisform.swrptlook1.Visible = .F.
		ELSE
		   thisform.lblselected.Visible = .F.
		   thisform.lblbegID.Visible = .T.
		   thisform.lblendID.Visible = .T.
		   thisform.swrptlook1.Visible = .T.
		ENDIF 
	ENDPROC

	PROCEDURE opgPrint.Click
		thisform.chklNoShowTotal.Visible = .f.
		thisform.chklAdjust.Visible = .f.
		
		IF this.Value = 2 OR this.Value = 3
		   thisform.lblAcctNo.Visible = .t.
		   thisform.txtcAcctNo.Visible = .t.
		   IF this.value = 3
		      thisform.chklNoShowTotal.Visible = .t.
		   ENDIF    
		ELSE
		   IF this.Value = 1
		      thisform.chklAdjust.Visible = .t.
		   ENDIF 
		   
		   thisform.lblAcctNo.Visible = .f.
		   thisform.txtcAcctNo.Visible = .f.
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE OpgQuarters.Init
		this.q1.value = 1
	ENDPROC

	PROCEDURE OpgQuarters.Q1.GotFocus
		THISFORM.opgQuarters.VALUE = 1
		
	ENDPROC

	PROCEDURE OpgQuarters.Q2.GotFocus
		THISFORM.opgQuarters.VALUE = 2
	ENDPROC

	PROCEDURE OpgQuarters.Q3.GotFocus
		THISFORM.opgQuarters.VALUE = 3
	ENDPROC

	PROCEDURE OpgQuarters.Q4.GotFocus
		THISFORM.opgQuarters.VALUE = 4
	ENDPROC

	PROCEDURE Swrptlook1.Swlookupbutton1.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .F.
		lcList = 'cwellid,cwellname,cgroup,cwellstat'
		DO FORM ..\custom\picklist WITH 'Wells', lcList, thisform.swrptlook1.txtbegid.value, 4
		
		IF llOK
		   thisform.swrptlook1.txtBegId.value = cwellid
		   thisform.swrptlook1.txtBegName.value = cwellname
		   thisform.swrptlook1.txtBegId.refresh()
		   thisform.swrptlook1.txtBegName.refresh()
		ENDIF   
		
		thisform.setnextcontrol(thisform.swrptlook1.txtBegId)
		
	ENDPROC

	PROCEDURE Swrptlook1.Swlookupbutton2.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .F.
		lcList = 'cwellid,cwellname,cgroup,cwellstat'
		DO FORM ..\custom\picklist WITH 'Wells', lcList, thisform.swrptlook1.txtendid.value, 4
		
		IF llOK
		   thisform.swrptlook1.txtEndId.value = cwellid
		   thisform.swrptlook1.txtEndName.value = cwellname
		   thisform.swrptlook1.txtEndId.refresh()
		   thisform.swrptlook1.txtEndName.refresh()
		ENDIF   
		
		thisform.setnextcontrol(thisform.swrptlook1.txtEndId)
		
	ENDPROC

	PROCEDURE swstates.Init
		
		*
		*  Load the laStates Array
		*
		SELE cTable+' - '+cDescription AS cTable FROM sevtax INTO ARRAY laStates ORDER BY cTable
		
		IF _tally > 0
		   FOR lnx = 1 TO _tally
		      this.addlistitem(laStates[lnX])
		   ENDFOR
		      
		  * Set default item to 1st
		  this.listitemid = 1
		
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE txtcAcctNo.Valid
		DODEFAULT()
		
		SELECT options
		=TABLEUPDATE(.t.)
	ENDPROC

ENDDEFINE
