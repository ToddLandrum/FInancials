*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="pluggingrel.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 448
	Left = 83
	Name = "Dataenvironment"
	Top = 58
	Width = 729

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "apopt", ;
		CursorSource = "apopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor1", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "groups", ;
		CursorSource = "groups", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 538, ;
		Name = "Cursor10", ;
		Top = 21, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "vendor", ;
		CursorSource = "vendor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 416, ;
		Name = "Cursor11", ;
		Top = 152, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "plugwell", ;
		CursorSource = "plugwell", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 422, ;
		Name = "Cursor12", ;
		Top = 288, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "expense1", ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor13", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor2", ;
		Top = 20, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor3", ;
		Top = 21, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "expense", ;
		BufferModeOverride = 5, ;
		CursorSource = "expense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor4", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor5", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 140, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 10, ;
		Name = "Cursor7", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "sysctl", ;
		CursorSource = "sysctl", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor8", ;
		Order = "yrprdgrp", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "expcat", ;
		CursorSource = "expcat", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 415, ;
		Name = "Cursor9", ;
		Top = 21, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

ENDDEFINE

DEFINE CLASS formpluggingrel AS frmformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Lbltextcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbltextcustom5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swgroup" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swyear" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Swperiod" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDate1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: process		&& Releases the fixed expenses
		*m: processqb		&& Posts when called by the DMIE
		*p: lqberror
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Release Plugging Fund Charges"
	DataSession = 2
	DoCreate = .T.
	Height = 312
	HelpContextID = 102
	lqberror = .F.
	Name = "FormPluggingRel"
	Visible = .T.
	Width = 468
	_memberdata = <VFPData>
		<memberdata name="processqb" display="ProcessQB"/>
		<memberdata name="lqberror" display="lQBerror"/>
		</VFPData>		&& XML Metadata for customizable properties
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Left = 456
	Mwresize1.Name = "Mwresize1"
	Mwresize1.Top = 300

	ADD OBJECT 'cboProcess' AS cbocomboboxcustom WITH ;
		Height = 20, ;
		Left = 146, ;
		Name = "cboProcess", ;
		TabIndex = 9, ;
		Top = 172, ;
		Width = 204
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdExit' AS cmdcommandbuttoncustom WITH ;
		Caption = "E\<xit", ;
		Default = .F., ;
		Height = 48, ;
		Left = 252, ;
		Name = "cmdExit", ;
		TabIndex = 12, ;
		Top = 240, ;
		Width = 73
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdProcess' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<Process", ;
		Height = 48, ;
		Left = 157, ;
		Name = "cmdProcess", ;
		TabIndex = 11, ;
		Top = 240, ;
		Width = 76
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Height = 19, ;
		Left = 12, ;
		Name = "Glmaint", ;
		Top = 240, ;
		Width = 21
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = " Well Group:", ;
		Left = 76, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 2, ;
		Top = 46
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom2' AS lbllabelcustom WITH ;
		Caption = "Process:", ;
		Left = 92, ;
		Name = "Lbllabelcustom2", ;
		TabIndex = 10, ;
		Top = 174
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom2' AS lbltextcustom WITH ;
		Caption = "Period/Year:", ;
		Left = 75, ;
		Name = "Lbltextcustom2", ;
		TabIndex = 6, ;
		Top = 89
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom3' AS lbltextcustom WITH ;
		Caption = "Acct. Date:", ;
		Left = 81, ;
		Name = "Lbltextcustom3", ;
		TabIndex = 8, ;
		Top = 134
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbltextcustom5' AS lbltextcustom WITH ;
		Caption = "/", ;
		FontBold = .T., ;
		FontSize = 10, ;
		Height = 18, ;
		Left = 173, ;
		Name = "Lbltextcustom5", ;
		TabIndex = 5, ;
		Top = 88, ;
		Width = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Swgroup' AS swgroup WITH ;
		Left = 146, ;
		lexcludeall = .F., ;
		Name = "Swgroup", ;
		TabIndex = 1, ;
		Top = 44
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'Swperiod' AS swperiod WITH ;
		Left = 146, ;
		Name = "Swperiod", ;
		TabIndex = 3, ;
		Top = 87
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'Swyear' AS swyear WITH ;
		Left = 182, ;
		Name = "Swyear", ;
		TabIndex = 4, ;
		Top = 87
		*< END OBJECT: ClassLib="..\custom\swcontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtDate1' AS dpk WITH ;
		ControlSource = "", ;
		Height = 20, ;
		lcheckdate = .T., ;
		Left = 146, ;
		lmorethan90 = .T., ;
		Name = "txtDate1", ;
		TabIndex = 8, ;
		Top = 132, ;
		Visible = .T., ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />
	
	PROCEDURE Error
		LPARAMETERS nerror,cmethod,nline
		
		if between(m.nerror,1426,1429)
		   aerror(aerrinfo)
		   messagebox(aerrinfo[3],0,'QuickBooks Error')
		   this.lqberror = .t.
		else
		   dodefault(nerror,cmethod,nline)
		endif   
		
	ENDPROC

	PROCEDURE Init
		IF DODEFAULT()
		   * Recall Fixed expenses if they've somehow gotten deleted
		   IF m.goapp.RecallFixedExpenses()
		      MESSAGEBOX('A problem was found with your Fixed Expenses. We have recovered this problem for you. Please check your fixed expense listing ' + ;
		                 'by going to Reports, Well Reports, Fixed Expense Listing to verify your fixed expenses before releasing them.',48,'Fixed Expenses')
		   ENDIF               
		ENDIF 
		
	ENDPROC

	PROCEDURE process		&& Releases the fixed expenses
		LOCAL lcGroup, llAllWells, lcYear, lcPeriod, ldExpDate, llSepClose
		LOCAL lnFixed, lnTotal, lcExpClear, lcAPAcct, oProgress, llNoPost
		LOCAL lAPTran, lFixed, lcDMExp, lcDeptNo, lcWellID1, lcWellID2, llOK, llPostDm, llReturn, lnAmount
		LOCAL lnAmtRel, lnCount, lnMax, loError
		LOCAL cBatch, cCatCode, cRunYearJIB, cRunYearRev, cWellID, cYear, cexpclass, cidexpe, cidexph
		LOCAL cperiod, dAcctDate, dExpdate, nRunNoJIB, nRunnoRev, oPlugging
		
		llReturn = .T.
		
		TRY
		   SET DELETED ON
		
		*  Get the registry object
		   THISFORM.oRegistry = FindGlobalObject('cmRegistry')
		   
		*  Create the plugging object
		   oPlugging = CREATEOBJECT('plugging')
		
		*  Get the separate closing for JIB setting
		   SELECT options
		   lcDeptNo = cDeptNo
		   lcDMExp  = cFixedAcct
		   
		   IF EMPTY(thisform.txtDate1.Value)
		      MESSAGEBOX('The Accounting Date can not be left blank!',16,'Missing Date')
		      llReturn = .F.
		      EXIT 
		   ENDIF 
		
		   IF TYPE('m.goApp') = 'O'
		      llPostDm = m.goApp.lAMVersion
		   ENDIF
		
		*  Get the expense clearing account
		   SELECT glopt
		   lcExpClear = cExpClear
		   lcSuspense = cSuspense
		   IF EMPTY(lcExpClear)
		      lcExpClear = cSuspense
		   ENDIF
		   
		*  Get the A/P account
		    SELECT apopt
		    lcAPAcct = cAPAcct
		
		    IF EMPTY(lcDMExp)
		        lcDMExp = lcAPAcct
		    ENDIF
		
		   llAllWells = .F.
		
		   lcGroup   = LEFT(THISFORM.swGroup.VALUE, 2)
		   lcYear    = THISFORM.swYear.VALUE
		   lcPeriod  = THISFORM.swPeriod.VALUE
		   ldExpDate = THISFORM.txtDate1.VALUE
		
		* See if the date is within a close fiscal period
		   IF NOT THISFORM.glmaint.checkperiod(ldExpDate, .T.)
		      THISFORM.omessage.warning('Unable to release plugging charges. The fiscal year or period represented by this date has been closed.')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		   IF LEFT(THISFORM.cboProcess.VALUE, 1) = 'A'
		      llAllWells = .T.
		   ELSE
		      llAllWells = .F.
		   ENDIF
		
		*  If all wells are to be processed, select them into wellsel
		*  Exclude Inactive, Sold, and Plugged wells, since they won't be processed by the closing anyway
		   IF llAllWells
		      SELECT  cWellID,;
		              ' ' AS temp ;
		          FROM wells  ;
		          WHERE IIF(lcGroup <> '**', cGroup = lcGroup, .T.) ;
		              AND NOT INLIST(cwellstat, 'I', 'S', 'P') ;
		          INTO CURSOR wellsel ;
		          ORDER BY cWellID
		   ELSE
		      DO FORM dmselwells WITH lcGroup
		   ENDIF
		
		*
		*  There were no wells selected
		*
		   SELECT wellsel
		   IF RECC() = 0
		      MESSAGEBOX('You must choose at least one well to have plugging charges release.', 16, 'Unable to Release Plugging Charges')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		*
		*  Check for fixed expenses that have already been released.
		*
		   lnWells = 0
		
		   SELECT wellsel
		   SCAN
		      m.cWellID = cWellID
		      swselect('expense')
		      LOCATE FOR cWellID == m.cWellID ;
		         AND nRunnoRev = 0 AND cCatCode = 'PLUG' ;
		         AND cYear # 'FIXD' ;
		         AND NOT DELETED()
		      IF FOUND()
		         lnWells = lnWells + 1
		      ENDIF
		   ENDSCAN
		
		   IF lnWells > 0
		      IF NOT THISFORM.omessage.CONFIRM('Plugging charges have already been released for the new run for some or all of the wells. ' + ;
		              ' Do you want to continue?')
		         llReturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   SELECT wellsel
		   GO TOP
		   lcWellID1 = cWellID
		   GO BOTT
		   lcWellID2 = cWellID
		
		   SELECT  * ;
		       FROM plugwell ;
		       WHERE NOT lCompleted ;
		           AND cWellID IN (SELECT  cWellID ;
		                               FROM wellsel) ;
		       INTO CURSOR plugtemp ;
		       ORDER BY cWellID
		
		   lnMax = _TALLY
		
		   IF lnMax = 0
		      THISFORM.omessage.DISPLAY('There were no plugging charges found for the wells chosen...')
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		*
		*  Build the properties for the journal entries
		*
		   THISFORM.glmaint.dgldate    = ldExpDate
		   THISFORM.glmaint.cReference = 'Plugging Chg'
		   THISFORM.glmaint.cSource    = 'DM'
		   THISFORM.glmaint.cDeptNo    = lcDeptNo
		   THISFORM.glmaint.cidchec    = ''
		   THISFORM.glmaint.mNotes     = ''
		
		   oProgress = THISFORM.omessage.ProgressBarEX('Releasing Plugging Charges to Period: ' + lcYear + '/' + lcPeriod, '')
		   oProgress.SetProgressRange(0, lnMax)
		   lnCount = 0
		
		   lnAmtRel = 0
		
		** Make sure the wellinv table is open
		** so we can check any one man items
		** below to make sure the owner still
		** has an interest in the well.
		   swselect('wellinv')
		
		   SELECT wellsel
		   SCAN
		      SCATTER MEMVAR
		      SELECT plugtemp
		      SCAN FOR cWellID = m.cWellID
		         SCATTER MEMVAR
		
		         IF m.nAmountRun = 0
		            LOOP
		         ENDIF
		         
		         * Check to see if the current balance is equal or greater than
		         * the plugging target. If it is don't release.
		         IF oPlugging.CurrentBalance(plugwell.cwellid) >= m.nplugamount
		            LOOP
		         ENDIF 
		         
		         * Don't release plugging charges if we're past the target date
		         IF ldExpDate > m.dTargetDate
		            LOOP
		         ENDIF 
		
		         m.nAmount  = m.nAmountRun
		         lcPostAcct = lcDMExp
		
		         IF EMPTY(lcPostAcct)
		            lcPostAcct = lcSuspense
		         ENDIF
		
		         swselect('vendor')
		         LOCATE FOR cVendorID == m.cVendorID
		         IF NOT FOUND()
		            m.cpayee = ''
		         ELSE
		            m.cPayee = cvendname
		         ENDIF
		         oProgress.SetProgressMessage(' Well: ' + m.cWellID)
		         oProgress.UpdateProgress(lnCount)
		         lnCount = lnCount + 1
		
		         swselect('expcat')
		         SET ORDER TO cCatCode
		         IF SEEK('PLUG')
		            m.cCatCode  = cCatCode
		            m.cexpclass = cexpclass
		            m.ccateg    = ccateg
		         ELSE
		            MESSAGEBOX('There is no PLUG expense code set up. Please set up the PLUG expense code and release again.', 16, 'Missing Expense Code')
		            llReturn = .F.
		            EXIT
		         ENDIF
		
		         m.cYear       = lcYear
		         m.cRunYearRev = lcYear
		         m.cRunYearJIB = lcYear
		         m.nRunnoRev   = 0
		         m.nRunNoJIB   = 0
		         m.cperiod     = lcPeriod
		         m.dExpdate    = ldExpDate
		         m.dAcctDate   = ldExpDate
		         m.lFixed      = .T.
		         m.lAPTran     = .F.
		         m.cidexph     =  ''
		         m.cBatch      = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		         m.cidexpe     = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Expense')
		         SET DELETED OFF
		         SELECT expense1
		         SET ORDER TO cidexpe
		         DO WHILE SEEK(m.cidexpe)
		            m.cidexpe = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Expense')
		         ENDDO
		         SET DELETED ON
		         m.cYear     = lcYear
		         m.cperiod   = lcPeriod
		         lnAmtRel    = lnAmtRel + m.nAmount
		         m.cpaidbyck = ''
		         INSERT INTO expense FROM MEMVAR
		
		*  Build the journal entries
		         IF llPostDm 
		            THISFORM.glmaint.cBatch   = m.cBatch
		* Net out "Dummy" owner's share
		            lnAmount = swNetExp(m.nAmount, m.cWellID, .T., m.cexpclass, 'B')
		 
		            THISFORM.glmaint.nAmount  = lnAmount * -1
		            THISFORM.glmaint.cAcctNo  = lcPostAcct
		            THISFORM.glmaint.cUnitNo  = m.cWellID
		            THISFORM.glmaint.cCatCode = m.cCatCode
		            THISFORM.glmaint.cID      = m.cVendorID
		            THISFORM.glmaint.cDesc    = m.ccateg
		            THISFORM.glmaint.updatebatch()
		
		            THISFORM.glmaint.cAcctNo = lcExpClear
		            THISFORM.glmaint.nAmount = lnAmount
		            THISFORM.glmaint.cUnitNo = m.cWellID
		            THISFORM.glmaint.updatebatch()
		         ENDIF
		
		      ENDSCAN
		   ENDSCAN
		
		   llOK = .F.
		   BEGIN TRANSACTION
		   SELE glmaster
		   llOK = TABLEUPDATE(.T., .T.)
		   IF llOK
		      SELE expense
		      llOK = TABLEUPDATE(.T., .T.)
		   ELSE
		      DO errorlog WITH 'Process', 1, 'PluggingRel', 999, 'Unable to commit changes to GLMaster table', ' '
		   ENDIF
		   IF llOK
		      SELE coabal
		      llOK = TABLEUPDATE(.T., .T.)
		      IF NOT llOK
		         DO errorlog WITH 'Process', 1, 'PluggingRel', 999, 'Unable to commit changes to COABal table', ' '
		      ENDIF
		   ELSE
		      DO errorlog WITH 'Process', 1, 'PluggingRel', 999, 'Unable to commit changes to Expense table', ' '
		   ENDIF
		   IF llOK
		      END TRANSACTION
		   ELSE
		      MESSAGEBOX('There was a problem releasing the plugging charges.  All files were reset.' + ;
		           'Check the system log found under the Other Report menu for more information.', 16, 'Problem Found')
		      ROLLBACK
		   ENDIF
		   oProgress.CloseProgress()
		
		   IF llOK
		      MESSAGEBOX('Release of the Plugging Charges for Period ' + lcYear + '/' + lcPeriod + ' Completed.' + CHR(13) + ;
		           'Released:  $' + ALLT(STR(lnAmtRel, 12, 2)) + ' total.', 0, 'Release Plugging Charges')
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Process', loError.LINENO, 'PluggingRel', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the Plugging Charges at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
		
		
		
	ENDPROC

	PROCEDURE processqb		&& Posts when called by the DMIE
		LOCAL lcgroup, llallwells, lcyear, lcperiod, ldexpdate, llsepclose, lnFixedType
		LOCAL lnfixed, lntotal, lcexpclear, lcapacct, oprogress, llnopost, lnJournal
		LOCAL lnAmtRel
		
		SET DELETED ON
		
		STORE 1 TO lnFixedType
		
		*  Get the registry object
		THISFORM.oregistry = findglobalobject('cmRegistry')
		
		*  Get the separate closing for JIB setting
		SELECT options
		llsepclose  = lsepclose
		llpostdm    = lpostdm
		lcfixedacct = cfixedacct
		
		*  Get the expense clearing account
		SELECT glopt
		GO TOP
		lcexpclear  = cexpclear
		llqbpost    = .T.
		llqbpostexp = .T.
		
		IF EMPTY(lcexpclear)
		   lcexpclear = csuspense
		ENDIF
		
		IF EMPTY(lcexpclear)
		   THISFORM.omessage.severe('Fixed Expenses cannot be released.  The expense clearing account has not been setup in the Account Settings.')
		   RETURN
		ENDIF
		
		 IF EMPTY(thisform.txtDate1.Value)
		    MESSAGEBOX('The Accounting Date can not be left blank!',16,'Missing Date')
		    RETURN .f.
		 ENDIF 
		
		*  Get the A/P account
		SELECT apopt
		lcapacct = capacct
		
		IF EMPTY(lcfixedacct)  &&  Don't let them release without specifying the Fixed Expense Account
		   THISFORM.omessage.severe('You cannot release Fixed Expenses without first specifying the Fixed Expense Account on the Edit >> Preferences screen.')
		   RETURN
		ENDIF
		
		llallwells = .F.
		lnAmtRel   = 0
		
		lcgroup   = LEFT(THISFORM.swgroup.VALUE, 2)
		lcyear    = THISFORM.swyear.VALUE
		lcperiod  = THISFORM.swperiod.VALUE
		ldexpdate = THISFORM.txtdate1.VALUE
		
		IF LEFT(THISFORM.cboprocess.VALUE, 1) = 'A'
		   llallwells = .T.
		ELSE
		   llallwells = .F.
		ENDIF
		
		*  If all wells are to be processed, select them into wellsel
		*  Exclude Inactive, Sold, and Plugged wells, since they won't be processed by the closing anyway
		IF llallwells
		   SELECT  cWellID,;
		           ' ' AS temp ;
		       FROM wells  ;
		       WHERE IIF(lcgroup <> '**', cGroup = lcgroup, .T.) ;
		           AND NOT INLIST(cwellstat, 'I', 'S', 'P') ;
		           AND cWellID IN (SELECT  cWellID ;
		                               FROM expense ;
		                               WHERE cyear = 'FIXD') ;
		       INTO CURSOR wellsel ;
		       ORDER BY cWellID
		ELSE
		   DO FORM ..\commonsource\dmselwells WITH lcgroup, lnFixedType
		ENDIF
		
		*
		*  There were no wells selected
		*
		SELECT wellsel
		IF RECC() = 0
		   MESSAGEBOX('You must choose at least one well to have plugging expenses release.', 16, 'Unable to Release Plugging Expenses')
		   RETURN
		ENDIF
		
		IF NOT THISFORM.omessage.CONFIRM('Are you sure you want to release plugging expenses for the chosen wells?')
		   RETURN
		ENDIF
		
		IF NOT m.goapp.oQB.lQBActive
		   MESSAGEBOX('The link to QuickBooks is not active. Plugging expenses cannot be released when not connected to QuickBooks.', 48, 'QuickBooks Link Problem')
		   RETURN
		ENDIF
		
		IF m.goapp.oQB.lQBActive AND llqbpost AND llqbpostexp
		   m.goapp.oQB.oQBSM.ClearErrorRecovery()
		* get a message set request object (version 1.1 xml)
		   lorequest = m.goapp.oQB.oQBRequest
		
		* set the on error attribute for the request
		   lorequest.ATTRIBUTES.onerror = 1
		   lorequest.clearrequests()
		
		ENDIF
		
		*
		*  Check for plugging expenses that have already been released.
		*
		lnfixed = 0
		
		SELECT wellsel
		SCAN
		   m.cWellID = cWellID
		   SELECT expense
		   SCAN FOR cWellID = m.cWellID ;
		         AND nRunnoRev = 0 AND cExpClass = 'P' ;
		         AND NOT DELETED()
		      lnfixed = lnfixed + 1
		   ENDSCAN
		ENDSCAN
		
		IF lnfixed > 0
		   IF NOT THISFORM.omessage.CONFIRM('Plugging expenses have already been released for the new run for some or all of the wells. ' + ;
		           ' Do you want to continue?')
		      RETURN
		   ENDIF
		ENDIF
		
		SELECT wellsel
		GO TOP
		lcwellid1 = cWellID
		GO BOTT
		lcwellid2 = cWellID
		
		SELECT  * ;
		    FROM plugwell ;
		    WHERE NOT lCompleted ;
		        AND cWellID IN (SELECT  cWellID ;
		                            FROM wellsel) ;
		    INTO CURSOR plugtemp ;
		    ORDER BY cWellID
		
		lnMax = _TALLY
		
		IF lnMax = 0
		   THISFORM.omessage.DISPLAY('There were no plugging charges found for the wells chosen...')
		   llReturn = .F.
		   EXIT
		ENDIF
		
		oprogress = THISFORM.omessage.progressbarex('Releasing Plugging Expenses to Period: ' + lcyear + '/' + lcperiod, '')
		oprogress.setprogressrange(0, lnMax)
		lncount = 0
		
		IF m.goapp.oQB.QBFCVersion > ' 4.0'
		   lnJournal = 15
		ELSE
		   lnJournal = 14
		ENDIF
		
		* Create a temp cursor to store all the batch #'s
		* so we can mark them as posted in QBPost
		CREATE CURSOR tempbatch ;
		   (cbatch   c(8))
		
		** Make sure the wellinv table is open
		** so we can check it below for one man
		** items to make sure the owner still
		** has an interest in the well.
		swselect('wellinv')
		
		SELECT wellsel
		SCAN
		   SCATTER MEMVAR
		   SELECT plugtemp
		   SCAN FOR cWellID = m.cWellID
		      SCATTER MEMVAR
		
		      IF m.nAmountRun = 0
		         LOOP
		      ENDIF
		
		      m.nAmount  = m.nAmountRun
		      lcPostAcct = lcFixedAcct
		
		      IF EMPTY(lcPostAcct)
		         lcPostAcct = lcSuspense
		      ENDIF
		
		      swselect('vendor')
		      LOCATE FOR cVendorID == m.cVendorID
		      IF NOT FOUND()
		         m.cpayee = ''
		         lcVendListID = ''
		      ELSE
		         m.cpayee = cvendname
		         lcVendListID = clistid
		      ENDIF
		      oprogress.SetProgressMessage(' Well: ' + m.cWellID)
		      oprogress.UpdateProgress(lncount)
		      lncount = lncount + 1
		
		      swselect('expcat')
		      SET ORDER TO cCatCode
		      IF SEEK('PLUG')
		         m.cCatCode  = cCatCode
		         m.cExpClass = cExpClass
		         m.ccateg    = ccateg
		      ELSE
		         MESSAGEBOX('There is no PLUG expense code set up. Please set up the PLUG expense code and release again.', 16, 'Missing Expense Code')
		         llReturn = .F.
		         EXIT
		      ENDIF
		      
		      SELE wells
		      LOCATE FOR cWellID = m.cWellID
		      IF FOUND()
		         lcwelllistid = clistid
		      ELSE
		         LOOP
		      ENDIF
		
		      oprogress.setprogressmessage(' Well: ' + m.cWellID)
		      oprogress.updateprogress(lncount)
		      lncount = lncount + 1
		
		      m.cyear       = lcyear
		      m.cRunYearRev = lcyear
		      m.cRunYearJIB = lcyear
		      m.nRunnoRev   = 0
		      m.nRunNoJIB   = 0
		      m.cperiod     = lcperiod
		      m.dExpdate    = ldexpdate
		      m.dAcctDate   = ldexpdate
		      m.lFixed      = .T.
		      m.lAPTran     = .F.
		      m.cidexph     =  ''
		      m.cbatch      = THISFORM.oregistry.IncrementCounter('%Shared.Counters.Batch')
		      m.cidexpe     = THISFORM.oregistry.IncrementCounter('%Shared.Counters.Expense')
		      SET DELETED OFF
		      SELECT expense1
		      SET ORDER TO cidexpe
		      DO WHILE SEEK(m.cidexpe)
		         m.cidexpe = THISFORM.oregistry.IncrementCounter('%Shared.Counters.Expense')
		      ENDDO
		      SET DELETED ON
		      m.cyear     = lcyear
		      m.cperiod   = lcperiod
		      lnAmtRel    = lnAmtRel + m.nAmount
		      m.cpaidbyck = ''
		      INSERT INTO expense FROM MEMVAR
		
		
		* Setup the fields for qbpost so we can unpost this allocation if part fails
		      m.cidsysctl = THISFORM.oregistry.IncrementCounter('%Shared.Counters.Batch')
		
		      m.cbatch  = m.cidsysctl  &&  So we can tie all these entries together to be backed out later - BH 4/23/09
		      INSERT INTO tempbatch FROM MEMVAR
		
		*  Build the journal entries
		      IF m.goapp.oQB.lQBActive AND llqbpost AND llqbpostexp AND NOT THISFORM.lqberror
		
		* Net out "Dummy" owner's share
		         lnamount = swNetExp(m.nAmount, m.cWellID, .T., m.cExpClass, 'B')
		
		         IF lnamount = 0
		            LOOP
		         ENDIF
		
		*  Setup the receipt add request
		         lojournaladd = lorequest.appendjournalentryaddrq()
		         lojournaladd.txndate.setvalue(ldexpdate)
		
		         IF lnamount > 0
		            IF m.goapp.oQB.QBFCVersion > ' 4.0'
		               loEntry = lojournaladd.ORJournalLineList.APPEND.JournalDebitLine
		            ELSE
		               loEntry = lojournaladd.journaldebitlinelist.APPEND
		            ENDIF
		         ELSE
		            IF m.goapp.oQB.QBFCVersion > ' 4.0'
		               loEntry = lojournaladd.ORJournalLineList.APPEND.JournalCreditLine
		            ELSE
		               loEntry = lojournaladd.journalcreditlinelist.APPEND
		            ENDIF
		         ENDIF
		
		         loEntry.entityref.listid.setvalue(lcvendlistid)
		         loEntry.accountref.listid.setvalue(lcexpclear)
		         loEntry.classref.listid.setvalue(lcwelllistid)
		         loEntry.amount.setvalue(ABS(lnamount))
		         loEntry.MEMO.setvalue(ALLT(m.ccateg) + ' Prd: ' + lcperiod + '/' + lcyear)
		
		         IF lnamount < 0
		            IF m.goapp.oQB.QBFCVersion > ' 4.0'
		               loEntry = lojournaladd.ORJournalLineList.APPEND.JournalDebitLine
		            ELSE
		               loEntry = lojournaladd.journaldebitlinelist.APPEND
		            ENDIF
		         ELSE
		            IF m.goapp.oQB.QBFCVersion > ' 4.0'
		               loEntry = lojournaladd.ORJournalLineList.APPEND.JournalCreditLine
		            ELSE
		               loEntry = lojournaladd.journalcreditlinelist.APPEND
		            ENDIF
		         ENDIF
		
		         loEntry.entityref.listid.setvalue(lcvendlistid)
		         loEntry.accountref.listid.setvalue(lcfixedacct)
		         loEntry.classref.listid.setvalue(lcwelllistid)
		         loEntry.amount.setvalue(ABS(lnamount))
		         loEntry.MEMO.setvalue('Plugging Expenses - Period: ' + lcperiod + '/' + lcyear)
		
		         loresponse = m.goapp.oQB.oQBSM.dorequests(lorequest)
		
		         IF NOT THIS.lqberror
		            loaddresp  = loresponse.responselist.getat(0)
		
		            IF loaddresp.statuscode = 0
		               lonewcheck = loaddresp.DETAIL
		               m.ctxnid   = lonewcheck.txnid.getvalue()
		
		               swselect('exptxnid',.t.)
		               LOCATE FOR cidexpe = m.cidexpe
		               IF NOT FOUND()
		                  INSERT INTO exptxnid FROM MEMVAR
		               ELSE
		                  REPL ctxnid WITH m.ctxnid
		               ENDIF
		
		               swselect('qbpost')
		               LOCATE FOR cidsysctl = m.cidsysctl AND ntype = lnJournal
		               IF NOT FOUND()
		                  m.ntype   = lnJournal
		                  m.mtxnids = m.ctxnid
		                  INSERT INTO qbpost FROM MEMVAR
		               ELSE
		                  IF NOT EMPTY(ALLT(mtxnids))
		                     REPL mtxnids WITH ALLT(mtxnids) + CHR(13) + m.ctxnid
		                  ELSE
		                     REPL mtxnids WITH m.ctxnid
		                  ENDIF
		               ENDIF
		               m.goapp.oQB.oQBSM.ClearErrorRecovery()
		            ELSE
		               IF 'object' $ LOWER(loaddresp.statusmessage)
		                  lcListID = SUBSTR(loaddresp.statusmessage, AT('"', loaddresp.statusmessage) + 1, AT('"', loaddresp.statusmessage, 2) - (AT('"', loaddresp.statusmessage) + 1))
		                  llResult = m.goapp.oQB.QBListID(lcListID, THISFORM.DATASESSIONID)
		                  IF llResult
		                     SELECT QBListID
		                     IF QBListID.ctype = 'Account'
		                        lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' specified in the ' + ;
		                           'QB Posting Preferences was not found in QuickBooks. Please select a new account ' + ;
		                           'and try to release the plugging again.'
		                     ELSE
		                        lcMessage = 'The ' + ALLTRIM(QBListID.cdescription) + ' was not found in QuickBooks. ' + ;
		                           'Please synchronize the ' + ALLTRIM(QBListID.ctype) + ' file and try to release the expenses again.'
		                     ENDIF
		                     THISFORM.omessage.severe(lcMessage)
		                  ELSE
		                     THISFORM.omessage.severe(loaddresp.statusmessage)
		                  ENDIF
		               ELSE
		                  THISFORM.omessage.severe(loaddresp.statusmessage)
		               ENDIF
		               m.goapp.oQB.csysctlkey = m.cidsysctl
		               m.goapp.oQB.QBUnpostRev()
		               m.goapp.oQB.oQBSM.ClearErrorRecovery()
		               RETURN .F.
		            ENDIF
		            lorequest.clearrequests()
		         ENDIF
		      ENDIF
		   ENDSCAN
		ENDSCAN
		WAIT CLEAR
		
		llok = .T.
		BEGIN TRANSACTION
		SELE expense
		llok = TABLEUPDATE(.T.)
		IF llok
		   swselect('exptxnid',.t.)
		   llok = TABLEUPDATE(.T.)
		ENDIF
		IF llok
		   END TRANSACTION
		   SELECT tempbatch
		   SCAN
		      m.cidsysctl = cbatch
		      swselect('qbpost')
		      REPLACE lPosted WITH .T. FOR cidsysctl = m.cidsysctl
		   ENDSCAN
		ELSE
		   THISFORM.omessage.DISPLAY('There was a problem releasing the plugging expenses.  All files were reset.')
		   ROLLBACK
		ENDIF
		oprogress.closeprogress()
		
		IF llOK
		   MESSAGEBOX('Release of the Plugging Charges for Period ' + lcYear + '/' + lcPeriod + ' Completed.' + CHR(13) + ;
		              'Released:  $' + ALLT(STR(lnAmtRel, 12, 2)) + ' total.', 0, 'Release Plugging Charges')
		ENDIF
		
		
		
		
		
		
	ENDPROC

	PROCEDURE cboProcess.Init
		this.addlistitem('All Wells',1)
		this.addlistitem('Selected Wells',2)
		this.listitemid = 1
		
		DODEFAULT()
	ENDPROC

	PROCEDURE cmdExit.Click
		thisform.release()
	ENDPROC

	PROCEDURE cmdProcess.Click
		IF m.goapp.lQBVersion
		   thisform.processqb()
		ELSE
		   thisform.process()
		ENDIF  
	ENDPROC

	PROCEDURE Swgroup.Init
		DODEFAULT()
		
		this.listitemid = 1
	ENDPROC

	PROCEDURE txtDate1.Refresh
		this.cvaluesource = 'this.value'
		DODEFAULT()
	ENDPROC

ENDDEFINE
