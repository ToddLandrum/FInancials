*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="arrecpmt.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cursor1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor12" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor11" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor13" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor17" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor18" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor19" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor20" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor14" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor21" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor22" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor23" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Relation1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor24" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor25" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor16" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor10" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor15" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor26" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cursor27" UniqueID="" Timestamp="" />

	AutoOpenTables = .F.
	DataSource = .NULL.
	Height = 619
	InitialSelectedAlias = "arpmthdr"
	Left = 10
	Name = "Dataenvironment"
	Top = 17
	Width = 1219

	ADD OBJECT 'Cursor1' AS cursor WITH ;
		Alias = "arpmthdr", ;
		BufferModeOverride = 3, ;
		CursorSource = "arpmthdr", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 34, ;
		Name = "Cursor1", ;
		Order = "cbatch", ;
		Top = 8, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor10' AS cursor WITH ;
		Alias = "coabal", ;
		BufferModeOverride = 5, ;
		CursorSource = "coabal", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 996, ;
		Name = "Cursor10", ;
		Top = 338, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor11' AS cursor WITH ;
		Alias = "invhdr", ;
		BufferModeOverride = 5, ;
		CursorSource = "invhdr", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Filter = "not empty(ccustid)", ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor11", ;
		Order = "cbatch", ;
		Top = 260, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor12' AS cursor WITH ;
		Alias = "checks", ;
		BufferModeOverride = 5, ;
		CursorSource = "checks", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 397, ;
		Name = "Cursor12", ;
		Top = 4, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor13' AS cursor WITH ;
		Alias = "invdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "invdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 418, ;
		Name = "Cursor13", ;
		Top = 253, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor14' AS cursor WITH ;
		Alias = "arpmtdet1", ;
		CursorSource = "arpmtdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 95, ;
		Left = 413, ;
		Name = "Cursor14", ;
		Top = 128, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor15' AS cursor WITH ;
		Alias = "deposits", ;
		CursorSource = "deposits", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 1025, ;
		Name = "Cursor15", ;
		Top = 170, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor16' AS cursor WITH ;
		Alias = "investor", ;
		CursorSource = "investor", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 19, ;
		Name = "Cursor16", ;
		Top = 367, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor17' AS cursor WITH ;
		Alias = "trangroup", ;
		CursorSource = "trangroup", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 704, ;
		Name = "Cursor17", ;
		Top = 133, ;
		Width = 101
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor18' AS cursor WITH ;
		Alias = "options", ;
		CursorSource = "options", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 700, ;
		Name = "Cursor18", ;
		Top = 272, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor19' AS cursor WITH ;
		Alias = "wells", ;
		CursorSource = "wells", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 105, ;
		Left = 850, ;
		Name = "Cursor19", ;
		Top = 3, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor2' AS cursor WITH ;
		Alias = "arpmtdet", ;
		BufferModeOverride = 5, ;
		CursorSource = "arpmtdet", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 78, ;
		Left = 34, ;
		Name = "Cursor2", ;
		Top = 133, ;
		Width = 103
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor20' AS cursor WITH ;
		Alias = "arpmthdr1", ;
		CursorSource = "arpmthdr", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 855, ;
		Name = "Cursor20", ;
		Top = 173, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor21' AS cursor WITH ;
		Alias = "gasinv", ;
		BufferModeOverride = 5, ;
		CursorSource = "gasinv", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 858, ;
		Name = "Cursor21", ;
		Top = 333, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor22' AS cursor WITH ;
		Alias = "gasopt", ;
		CursorSource = "gasopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 102, ;
		Left = 287, ;
		Name = "Cursor22", ;
		Top = 377, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor23' AS cursor WITH ;
		Alias = "wellinv", ;
		CursorSource = "wellinv", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 150, ;
		Name = "Cursor23", ;
		Top = 380, ;
		Width = 91
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor24' AS cursor WITH ;
		Alias = "suspense", ;
		BufferModeOverride = 5, ;
		CursorSource = "suspense", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 333, ;
		Left = 559, ;
		Name = "Cursor24", ;
		Top = 158, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor25' AS cursor WITH ;
		Alias = "disbhist", ;
		CursorSource = "disbhist", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 430, ;
		Name = "Cursor25", ;
		Top = 380, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor26' AS cursor WITH ;
		Alias = "depositd", ;
		CursorSource = "depositd", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 1000, ;
		Name = "Cursor26", ;
		Top = 35, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor27' AS cursor WITH ;
		Alias = "gasown", ;
		CursorSource = "gasown", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 63, ;
		Name = "Cursor27", ;
		Top = 501, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor3' AS cursor WITH ;
		Alias = "glmaster", ;
		BufferModeOverride = 5, ;
		CursorSource = "glmaster", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 556, ;
		Name = "Cursor3", ;
		Top = 23, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor4' AS cursor WITH ;
		Alias = "custs", ;
		CursorSource = "custs", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 292, ;
		Name = "Cursor4", ;
		Order = "ccustid", ;
		Top = 128, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor5' AS cursor WITH ;
		Alias = "coa", ;
		CursorSource = "coa", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 763, ;
		Name = "Cursor5", ;
		Top = 437, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor6' AS cursor WITH ;
		Alias = "glopt", ;
		CursorSource = "glopt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 290, ;
		Name = "Cursor6", ;
		Top = 5, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor7' AS cursor WITH ;
		Alias = "aroutinv", ;
		CursorSource = "aroutinv", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 167, ;
		Name = "Cursor7", ;
		NoDataOnLoad = .T., ;
		Top = 1, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor8' AS cursor WITH ;
		Alias = "custown", ;
		CursorSource = "custown", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 18, ;
		Name = "Cursor8", ;
		Top = 249, ;
		Width = 95
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Cursor9' AS cursor WITH ;
		Alias = "aropt", ;
		CursorSource = "aropt", ;
		Database = ..\datafiles\data\appdata.dbc, ;
		Height = 90, ;
		Left = 288, ;
		Name = "Cursor9", ;
		Top = 249, ;
		Width = 90
		*< END OBJECT: BaseClass="cursor" />

	ADD OBJECT 'Relation1' AS relation WITH ;
		ChildAlias = "arpmtdet", ;
		ChildOrder = "cbatch", ;
		Name = "Relation1", ;
		ParentAlias = "arpmthdr", ;
		RelationalExpr = "cbatch"
		*< END OBJECT: BaseClass="relation" />

ENDDEFINE

DEFINE CLASS formarrecpmt AS frmdatamanagerformcustom OF "..\custom\cforms.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shpshapecustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNapplied" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNunapp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabelcustom1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCcustid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCustomer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDrecdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCreference" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblCreference" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNpmtamt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblNpmtamt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNapplied" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNunapp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtnBalance" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtcCustName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column1.Txtdate1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column2.Header2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column2.txtInvNum" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column3.Header3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column3.txtnDiscAvail" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column4.Header4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column4.txtnDiscTaken" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column5.Header5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column5.txtnOrigTotal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column6.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column6.txtnInvBal" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column7.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdarpmtdet.Column7.txtnPayment" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Grouptran" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Glmaint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboAcct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtAcctDesc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgDeposits" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtdRecDate" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: applypmts		&& Automatically applies the payment amount to outstanding invoices.
		*m: calcapplied
		*m: calctot
		*m: netbalances		&& Gets the balances from suspense for net owners or HG owners
		*m: requeryrecordsource
		*p: cbatch
		*p: ccustsave		&& Saves the current customer ID for validation purposes.
		*p: coldacctno
		*p: cpmttype
		*p: ctype		&& Type of receivable
		*p: laskaboutsuspense
		*p: laskedaboutsuspensealready
		*p: lincludesuspense		&& Include suspense for HG owners.
		*p: lnewbuild
		*p: lrefreshdata		&& Tells whether to requery grid when tabbing through the date field.
		*p: noldapp
		*p: noldunapp
		*p: oldpmtamt
	*</DefinedPropArrayMethod>

	Caption = "Receive Customer Payments"
	cbatch = .F.
	cbunch = 
	clistexpression = arpmthdr.cbatch
	cnavworkarea = arpmthdr
	ctype = ''		&& Type of receivable
	cworkarea = arpmthdr
	DoCreate = .T.
	Height = 434
	HelpContextID = 340
	laskaboutsuspense = .F.
	laskedaboutsuspensealready = .F.
	lexpliciteditmode = .F.
	lincludesuspense = .F.		&& Include suspense for HG owners.
	lrefreshdata = .F.		&& Tells whether to requery grid when tabbing through the date field.
	lrememberposition = .F.
	lremembersize = .F.
	Name = "FormArrecpmt"
	noldapp = 0
	noldunapp = 0
	oldpmtamt = 0
	Visible = .T.
	Width = 637
	_memberdata = <VFPData>
		<memberdata name="netbalances" display="NetBalances"/>
		<memberdata name="lincludesuspense" display="lIncludeSuspense"/>
		</VFPData>
	cmdatamanager.Name = "cmdatamanager"
	cmdatamanager.TabIndex = 1
	cmdatamanager.ZOrderSet = 1
	cmlookupmanager.Name = "cmlookupmanager"
	Mwresize1.lblHighLight.Name = "lblHighLight"
	Mwresize1.lblShading.Name = "lblShading"
	Mwresize1.Name = "Mwresize1"

	ADD OBJECT 'cboAcct' AS cbocomboboxcustom WITH ;
		BoundColumn = 1, ;
		ColumnCount = 2, ;
		ControlSource = "arpmthdr.cacctno", ;
		Height = 22, ;
		Left = 358, ;
		Name = "cboAcct", ;
		TabIndex = 6, ;
		Top = 5, ;
		Visible = .T., ;
		Width = 85
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdCustomer' AS cmdcommandbuttoncustom WITH ;
		Caption = "Customer ID", ;
		Height = 20, ;
		Left = 8, ;
		Name = "cmdCustomer", ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 6, ;
		Width = 64
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Glmaint' AS glmaint WITH ;
		Left = 267, ;
		Name = "Glmaint", ;
		Top = 65
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'grdarpmtdet' AS grdgridcustom WITH ;
		ColumnCount = 7, ;
		cworkarea = .NULL., ;
		Height = 277, ;
		lallowdelete = .F., ;
		lallownew = .F., ;
		lcolumnmemory = .F., ;
		Left = 0, ;
		LinkMaster = "arpmthdr", ;
		Name = "grdarpmtdet", ;
		Panel = 1, ;
		RecordSource = "arpmtdet", ;
		RelationalExpr = "cbatch", ;
		TabIndex = 17, ;
		Top = 132, ;
		Width = 619, ;
		ZOrderSet = 18, ;
		Column1.Bound = .T., ;
		Column1.ControlSource = "arpmtdet.dinvdate", ;
		Column1.Enabled = .T., ;
		Column1.FontSize = 8, ;
		Column1.Name = "Column1", ;
		Column1.SelectOnEntry = .F., ;
		Column1.Width = 77, ;
		Column2.Bound = .T., ;
		Column2.ControlSource = "arpmtdet.cinvnum", ;
		Column2.FontSize = 8, ;
		Column2.Name = "Column2", ;
		Column2.Width = 87, ;
		Column3.Bound = .T., ;
		Column3.ControlSource = "arpmtdet.ndisctot", ;
		Column3.FontSize = 8, ;
		Column3.Name = "Column3", ;
		Column3.Width = 87, ;
		Column4.Bound = .T., ;
		Column4.ControlSource = "arpmtdet.ndistaken", ;
		Column4.FontSize = 8, ;
		Column4.Name = "Column4", ;
		Column4.Width = 89, ;
		Column5.Bound = .T., ;
		Column5.ControlSource = "arpmtdet.ninvtot", ;
		Column5.FontSize = 8, ;
		Column5.Name = "Column5", ;
		Column5.Width = 90, ;
		Column6.Bound = .T., ;
		Column6.ControlSource = "arpmtdet.ninvbal", ;
		Column6.FontSize = 8, ;
		Column6.Name = "Column6", ;
		Column7.BackColor = 255,255,128, ;
		Column7.Bound = .T., ;
		Column7.ControlSource = "arpmtdet.namtapp", ;
		Column7.FontSize = 8, ;
		Column7.Name = "Column7", ;
		Column7.Width = 73
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="grid" />

	ADD OBJECT 'grdarpmtdet.Column1.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Date", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column1.Txtdate1' AS txttextboxcustom WITH ;
		BorderColor = 0,0,0, ;
		Enabled = .T., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 44, ;
		lenabled = .F., ;
		lreadonly = .T., ;
		Name = "Txtdate1", ;
		ReadOnly = .T., ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column2.Header2' AS header WITH ;
		Alignment = 2, ;
		Caption = "Number", ;
		FontSize = 8, ;
		Name = "Header2"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column2.txtInvNum' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 38, ;
		Name = "txtInvNum", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column3.Header3' AS header WITH ;
		Alignment = 2, ;
		Caption = "Disc Avail", ;
		FontSize = 8, ;
		Name = "Header3"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column3.txtnDiscAvail' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 34, ;
		Name = "txtnDiscAvail", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column4.Header4' AS header WITH ;
		Alignment = 2, ;
		Caption = "Disc Taken", ;
		FontSize = 8, ;
		Name = "Header4"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column4.txtnDiscTaken' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 54, ;
		Name = "txtnDiscTaken", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column5.Header5' AS header WITH ;
		Alignment = 2, ;
		Caption = "Orig Total", ;
		FontSize = 8, ;
		Name = "Header5"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column5.txtnOrigTotal' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 60, ;
		Name = "txtnOrigTotal", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column6.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Balance", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column6.txtnInvBal' AS txttextboxcustom WITH ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 25, ;
		Name = "txtnInvBal", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdarpmtdet.Column7.Header1' AS header WITH ;
		Alignment = 2, ;
		BackColor = 255,255,128, ;
		Caption = "Payment", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdarpmtdet.Column7.txtnPayment' AS txttextboxcustom WITH ;
		BackColor = 255,255,128, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Left = 45, ;
		Name = "txtnPayment", ;
		Top = 30
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'Grouptran' AS grouptran WITH ;
		Height = 17, ;
		Left = 12, ;
		Name = "Grouptran", ;
		Top = 36, ;
		Width = 37
		*< END OBJECT: ClassLib="..\custom\swgl.vcx" BaseClass="custom" />

	ADD OBJECT 'lblCreference' AS lblfieldlabelcustom WITH ;
		Caption = "Check No.", ;
		Height = 16, ;
		Left = 223, ;
		Name = "lblCreference", ;
		TabIndex = 16, ;
		Top = 85, ;
		Width = 51, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblDrecdate' AS lblfieldlabelcustom WITH ;
		Caption = "Payment Date", ;
		Height = 16, ;
		Left = 3, ;
		Name = "lblDrecdate", ;
		TabIndex = 5, ;
		Top = 57, ;
		Width = 68, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabelcustom1' AS lbllabelcustom WITH ;
		Caption = "Balance", ;
		Height = 16, ;
		Left = 478, ;
		Name = "Lbllabelcustom1", ;
		TabIndex = 12, ;
		Top = 42, ;
		Width = 41, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNapplied' AS lblfieldlabelcustom WITH ;
		Caption = "Amount Applied", ;
		Height = 16, ;
		Left = 441, ;
		Name = "lblNapplied", ;
		TabIndex = 12, ;
		Top = 65, ;
		Width = 78, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNpmtamt' AS lblfieldlabelcustom WITH ;
		Caption = "Amount", ;
		Height = 16, ;
		Left = 32, ;
		Name = "lblNpmtamt", ;
		TabIndex = 15, ;
		Top = 83, ;
		Width = 39, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblNunapp' AS lblfieldlabelcustom WITH ;
		Caption = "Unapplied Amount", ;
		Height = 16, ;
		Left = 430, ;
		Name = "lblNunapp", ;
		TabIndex = 14, ;
		Top = 89, ;
		Width = 89, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'opgDeposits' AS opgoptiongroupcustom WITH ;
		ButtonCount = 2, ;
		Height = 24, ;
		Left = 168, ;
		Name = "opgDeposits", ;
		TabIndex = 5, ;
		Top = 4, ;
		Visible = .T., ;
		Width = 182, ;
		Option1.Caption = "Group Deposits", ;
		Option1.FontSize = 8, ;
		Option1.Height = 17, ;
		Option1.Left = 7, ;
		Option1.Name = "optGroup", ;
		Option1.Top = 5, ;
		Option1.Width = 107, ;
		Option2.Caption = "Deposit To", ;
		Option2.FontSize = 8, ;
		Option2.Height = 19, ;
		Option2.Left = 108, ;
		Option2.Name = "optDepositTo", ;
		Option2.Top = 3, ;
		Option2.Width = 83
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'Shpshapecustom1' AS shpshapecustom WITH ;
		Height = 79, ;
		Left = 421, ;
		Name = "Shpshapecustom1", ;
		Top = 34, ;
		Width = 203, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'txtAcctDesc' AS txttextboxcustom WITH ;
		BackColor = 212,208,200, ;
		ControlSource = " ", ;
		Height = 20, ;
		Left = 445, ;
		lreadonly = .T., ;
		Name = "txtAcctDesc", ;
		TabIndex = 13, ;
		Top = 6, ;
		Width = 178
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCcustid' AS txtquickfill WITH ;
		ControlSource = "arpmthdr.ccustid", ;
		Height = 20, ;
		InputMask = "XXXXXXXXXX", ;
		Left = 75, ;
		lrequired = .T., ;
		MaxLength = 10, ;
		Name = "txtCcustid", ;
		TabIndex = 3, ;
		Top = 6, ;
		Width = 89, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\cgadget.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtcCustName' AS txttextboxcustom WITH ;
		ControlSource = "", ;
		Height = 20, ;
		Left = 75, ;
		Name = "txtcCustName", ;
		ReadOnly = .T., ;
		TabIndex = 4, ;
		Top = 29, ;
		Width = 233, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtCreference' AS txttextboxcustom WITH ;
		ControlSource = "arpmthdr.creference", ;
		Height = 20, ;
		Left = 279, ;
		MaxLength = 10, ;
		Name = "txtCreference", ;
		TabIndex = 10, ;
		Top = 83, ;
		Width = 79, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtdRecDate' AS dpk WITH ;
		ControlSource = "arpmthdr.drecdate", ;
		Height = 20, ;
		lcheckdate = .T., ;
		Left = 76, ;
		lmorethan90 = .T., ;
		Name = "txtdRecDate", ;
		TabIndex = 8, ;
		Top = 56, ;
		Width = 75
		*< END OBJECT: ClassLib="..\custom\swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNapplied' AS txttextboxcustom WITH ;
		ControlSource = "arpmthdr.napplied", ;
		Height = 20, ;
		Left = 524, ;
		Name = "txtNapplied", ;
		TabIndex = 13, ;
		Top = 64, ;
		Width = 89, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtnBalance' AS txttextboxcustom WITH ;
		Comment = "", ;
		ControlSource = "arpmthdr.ncustbalance", ;
		Height = 20, ;
		Left = 524, ;
		Name = "txtnBalance", ;
		TabIndex = 11, ;
		Top = 40, ;
		Width = 89, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNpmtamt' AS txttextboxcustom WITH ;
		Alignment = 3, ;
		ControlSource = "arpmthdr.npmtamt", ;
		Height = 20, ;
		InputMask = "999999999.99", ;
		Left = 75, ;
		lrequired = .F., ;
		Name = "txtNpmtamt", ;
		TabIndex = 9, ;
		Top = 81, ;
		Value = 0, ;
		Width = 104, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNunapp' AS txttextboxcustom WITH ;
		ControlSource = "arpmthdr.nunapp", ;
		Height = 20, ;
		Left = 524, ;
		Name = "txtNunapp", ;
		TabIndex = 13, ;
		Top = 88, ;
		Width = 89, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		*
		*  Look for the customer/owner/vendor name in
		*  the custownvend view
		*
		lnSelect = SELECT()
		
		thisform.lRefreshData = .t.
		
		swselect('glopt')
		GO TOP
		IF arpmthdr.cacctno = cundepfund
		   THISFORM.opgDeposits.VALUE = 1
		ELSE
		   THISFORM.opgDeposits.VALUE = 2
		ENDIF
		
		SELECT (lnSelect)
		
		RETURN (DODEFAULT())
	ENDPROC

	PROCEDURE applypmts		&& Automatically applies the payment amount to outstanding invoices.
		*
		*  Automatically applies the payment amount entered to
		*  outstanding invoices.  Tries to match to payment amount
		*  to an outstanding invoice.  If an invoice is found with
		*  the same outstanding balance, the payment is applied to
		*  it.  If an invoice is not found with the same balance as
		*  the payment, the payment is applied to invoices starting
		*  with the oldest invoice.
		*
		LOCAL lcBatch, lnPmtAmt, lnInvBal, lnPmtLeft, lnCount, lnSelect, lnApplied
		LOCAL llReturn
		
		llReturn = .T.
		
		TRY
		   lnSelect = SELECT()
		
		   lcBatch   = arpmthdr.cBatch
		   lnPmtAmt  = arpmthdr.nPmtAmt
		   lnPmtLeft = lnPmtAmt
		   lnApplied = arpmthdr.nApplied
		
		*
		*  If the payment has already been applied, exit
		*
		   IF lnPmtAmt = lnApplied
		      llReturn = .F.
		      EXIT
		   ENDIF
		
		* Check to see if pmt amount is same as outstanding balance.
		* If so, apply to all outstanding invoices
		   IF lnPmtAmt = arpmthdr.ncustbalance
		      swselect('arpmtdet')
		      SCAN
		         REPL nAmtApp WITH nInvBal
		      ENDSCAN
		   ELSE
		      swselect('arpmtdet')
		      SCAN FOR cBatch == lcBatch
		         REPLACE nAmtApp WITH 0
		      ENDSCAN
		* 1st look for an exact match
		      swselect('arpmtdet')
		      LOCATE FOR cBatch == lcBatch AND nInvBal = lnPmtAmt
		      IF FOUND()
		         REPL nAmtApp WITH lnPmtAmt
		         lnPmtAmt = 0
		      ELSE
		         swselect('arpmtdet')
		         SCAN FOR cBatch == lcBatch AND nAmtApp = 0
		            lnInvBal = nInvBal
		
		            DO CASE
		               CASE lnInvBal < 0
		                  LOOP
		               CASE lnInvBal < lnPmtLeft
		                  REPL nAmtApp WITH lnInvBal
		                  lnPmtLeft = lnPmtLeft - lnInvBal
		
		               CASE lnInvBal >= lnPmtLeft
		                  REPL nAmtApp WITH lnPmtLeft
		                  lnPmtLeft = 0
		                  EXIT
		            ENDCASE
		         ENDSCAN
		      ENDIF
		   ENDIF
		
		   SELECT (lnSelect)
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'ApplyPmts', loError.LINENO, 'Receive Payments', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the report at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE calcapplied
		LOCAL lnSelect, lcBatch, lnApplied, lnUnapp, lnPayment, llReturn
		*
		*  Calculates the amounts applied to the outstanding
		*  invoices.
		*
		
		llReturn = .T.
		
		TRY
		   lcBatch = arpmthdr.cBatch
		
		   lnSelect = SELECT()
		
		   swselect('arpmtdet')
		   lnRecno = RECNO()
		   SUM(nAmtApp) FOR cBatch == lcBatch TO lnApplied
		   IF lnRecno <= RECCOUNT()
		      GOTO (lnRecno)
		   ENDIF
		
		   lnPayment = THISFORM.txtnPmtAmt.VALUE
		   lnUnapp   = lnPayment - lnApplied
		
		   IF arpmthdr.napplied <> lnApplied
		      THISFORM.cmdatamanager.REPLACE('Arpmthdr', 'Napplied', lnApplied)
		      THISFORM.txtnApplied.REFRESH()
		   ENDIF
		   IF arpmthdr.nunapp <> lnUnapp
		      THISFORM.cmdatamanager.REPLACE('Arpmthdr', 'Nunapp', lnUnapp)
		      THISFORM.txtnUnapp.REFRESH()
		   ENDIF
		
		   SELECT (lnSelect)
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'CalcApplied', loError.LINENO, 'Receive Payments', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the payment at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE calctot
		LOCAL lnSelect, lcBatch, lnBalance, llReturn
		
		llReturn = .T.
		
		TRY
		
		   lnBalance = 0
		   lcBatch   = arpmthdr.cBatch
		   lnSelect  = SELECT()
		   swselect('arpmtdet')
		   lnRecno = RECNO()
		   SUM(nInvBal) FOR cBatch == lcBatch TO lnBalance
		   IF lnRecno <= RECCOUNT()
		      GOTO (lnRecno)
		   ENDIF
		*
		*  Don't update the balance unless it's changed.
		*
		   IF arpmthdr.nCustBalance <> lnBalance
		      THISFORM.cmdatamanager.REPLACE('Arpmthdr', 'Ncustbalance', lnBalance)
		      THISFORM.txtnBalance.REFRESH()
		   ENDIF
		
		   SELECT (lnSelect)
		
		   UNLOCK
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'CalcTot', loError.LINENO, 'Receive Payments', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the payment at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE cancelallchanges
		LPARAMETERS cworkarealist
		
		THISFORM.lNewBuild = .f.
		DODEFAULT(cworkarealist)
	ENDPROC

	PROCEDURE confirmdelete
		LPARAMETERS cWorkarea, cParameter
		
		RETURN .t.
	ENDPROC

	PROCEDURE delete
		LPARAMETERS cWorkarea
		
		thisform.lconfirmdelete = .f.
		
		DODEFAULT(cWorkArea)
	ENDPROC

	PROCEDURE Destroy
		thisform.grouptran.unload()
		RELE lcPmtType
		RETURN DODEFAULT()
	ENDPROC

	PROCEDURE Init
		LPARA tcType
		PUBL lcPmtType
		
		IF TYPE('tcType') <> 'C'  &&  No parameter passed, so assume owner
		   tcType = 'NET'
		ENDIF
		
		THIS.cType = UPPER(tcType)
		
		IF NOT m.goapp.lAMVersion
		   THIS.cboAcct.VISIBLE = .F.
		   THIS.txtAcctDesc.VISIBLE = .F.
		   THIS.opgDeposits.VISIBLE = .F.
		   THISFORM.cmdCustomer.CAPTION = 'Owner ID'
		ENDIF
		
		
		   IF EMPTY(tcType)
		      tcType = 'JIB'
		   ENDIF
		
		   THIS.cType = UPPER(tcType)
		   tcType     = UPPER(tcType)
		
		   DO CASE
		      CASE tcType = 'AR'
		         THIS.CAPTION = 'Receive Customer Payments'
		         swselect('arpmthdr')
		         SET FILT TO cPmtType = 'A'
		*!*         LOCATE FOR cPmtType = 'A'
		*!*	         GO BOTTOM 
		         THIS.HELPCONTEXTID = 570
		         THISFORM.grdarpmtdet.column4.BACKCOLOR = RGB(255,255,128)
		         THISFORM.grdarpmtdet.column4.header4.FONTBOLD = .T.
		      CASE tcType = 'HG'
		         * If we're in demo mode, tell the user that this is an optional module
		         IF m.goapp.ldemo
		            THISFORM.omessage.warning('The House Gas module is an optional module that can be purchased separately.' + ;
		               ' It is included in the demo for evaluation purposes.')
		         ENDIF
		         THIS.CAPTION = 'Receive House Gas Owner Payments'
		         swselect('arpmthdr')
		         SET FILT TO cPmtType = 'H'
		*!*	         LOCATE FOR cPmtType = 'H'
		*!*	         GO BOTTOM 
		         THISFORM.cmdCustomer.CAPTION = 'Owner ID'
		         THIS.HELPCONTEXTID = 596
		      CASE tcType = 'JIB'
		         THIS.CAPTION = 'Receive Owner JIB Payments'
		         THISFORM.cmdCustomer.CAPTION = 'Owner ID'
		         swselect('arpmthdr')
		         SET FILT TO cPmtType = 'J'
		*!*	         LOCATE FOR cPmtType = 'J'
		*!*	         GO BOTT
		         THISFORM.REFRESH()
		         THIS.HELPCONTEXTID = 572
		         THISFORM.grdarpmtdet.column4.BACKCOLOR = RGB(255,255,128)
		         THISFORM.grdarpmtdet.column4.header4.FONTBOLD = .T.
		      OTHERWISE
		         THIS.CAPTION = 'Receive Owner Net Payments'
		         THISFORM.cmdCustomer.CAPTION = 'Owner ID'
		         swselect('arpmthdr')
		         SET FILT TO cPmtType = 'N'
		*!*	         LOCATE FOR cPmtType = 'N'
		*!*	         GO bott
		         THISFORM.grdarpmtdet.column3.header3.FORECOLOR = RGB(128,128,128)
		         THISFORM.grdarpmtdet.column4.header4.FORECOLOR = RGB(128,128,128)
		         THIS.HELPCONTEXTID = 571
		   ENDCASE
		
		   lcPmtType = LEFT(THIS.cType,1)
		
		   SET DELETED ON
		
		   swselect('arpmthdr')
		   IF arpmthdr.cPmtType = 'A'  &&  Look in custs for the name
		      swselect('custs')
		      SET ORDER to ccustid
		      IF SEEK(arpmthdr.ccustid)
		         THISFORM.txtcCustName.VALUE = custs.cCustName
		         THISFORM.txtcCustName.REFRESH()
		      ELSE
		         THISFORM.txtcCustName.VALUE = 'Unknown customer'
		         THISFORM.txtcCustName.REFRESH()
		      ENDIF
		   ELSE  &&  JIB, Net, or HG owner, so use investor
		      swselect('investor')
		      SET ORDER to cownerid
		      IF SEEK(arpmthdr.ccustid)
		         THISFORM.txtcCustName.VALUE = investor.cOwnName
		         THISFORM.txtcCustName.REFRESH()
		      ELSE
		         THISFORM.txtcCustName.VALUE = 'Unknown owner'
		         THISFORM.txtcCustName.REFRESH()
		      ENDIF
		   ENDIF
		   
		   thisform.last('Arpmthdr')
		   
		*!*	   THISFORM.requeryrecordsource()
		*!*	   thisform.cmdatamanager.setinitialposition('Arpmtdet')
		
		   IF THISFORM.cType = 'AR'  &&  Set the quickfill properties based on the type of payment being received
		      THISFORM.txtcCustID.cListExpression = 'ccustid'
		      THISFORM.txtcCustID.cListWorkarea = 'custs'
		   ELSE
		      THISFORM.txtcCustID.cListExpression = 'cownerid'
		      THISFORM.txtcCustID.cListWorkarea = 'investor'
		   ENDIF
		DODEFAULT()
		
	ENDPROC

	PROCEDURE list
		LPARAMETERS cworkarea
		LOCAL lcList, lcBatch, lcSelect, llReturn
		LOCAL lcType, loError
		PRIV llOK
		
		llReturn = .T.
		
		TRY
		   lcSelect = SELECT()
		   lcBatch  = arpmthdr.cbatch
		
		   llOK = .T.
		   DO CASE
		      CASE THISFORM.ctype = 'AR'
		         lcType = 'A'
		      CASE THISFORM.ctype = 'HG'
		         lcType = 'H'
		      CASE THISFORM.ctype = 'NET'
		         lcType = 'N'
		      CASE THISFORM.ctype = 'JIB'
		         lcType = 'J'
		      OTHERWISE
		         lcType = 'A'
		   ENDCASE
		
		   IF THIS.flushcontrolbuffer() AND THIS.beforenav('arpmthdr')
		      IF THISFORM.ctype = 'AR'
				 SELECT  arpmthdr.drecdate, ;
						 arpmthdr.ccustid, ;
						 custs.cCustName AS cname, ;
						 arpmthdr.npmtamt, ;
						 arpmthdr.cbatch ;
					 FROM arpmthdr, custs ;
					 WHERE arpmthdr.cpmttype = lcType ;
						 AND arpmthdr.ccustid = custs.ccustid ;
					 INTO CURSOR temppmt readwrite ;
					 ORDER BY arpmthdr.drecdate, arpmthdr.ccustid, arpmthdr.cbatch ;
					 GROUP BY arpmthdr.drecdate, arpmthdr.ccustid, arpmthdr.cbatch
		      ELSE
				 SELECT  arpmthdr.drecdate, ;
						 arpmthdr.ccustid, ;
						 investor.cSortfield AS cname,  ;
						 arpmthdr.npmtamt, ;
						 arpmthdr.cbatch ;
					 FROM arpmthdr, investor ;
					 WHERE arpmthdr.cpmttype = lcType ;
						 AND arpmthdr.ccustid = investor.cOwnerID ;
					 INTO CURSOR temppmt readwrite ;
					 ORDER BY arpmthdr.drecdate, arpmthdr.ccustid, arpmthdr.cbatch ;
					 GROUP BY arpmthdr.drecdate, arpmthdr.ccustid, arpmthdr.cbatch
		      ENDIF
		
		      IF _TALLY > 0
		         SELECT temppmt
		         INDEX ON cbatch TAG cbatch
		         INDEX ON drecdate  TAG drecdate
		         INDEX ON ccustid   TAG ccustid
		         INDEX ON UPPER(cname) TAG cname
		         INDEX ON npmtamt TAG npmtamt
		
		         lcList = 'cbatch\Batch,drecdate\Date,ccustid\ID,cname\Name,npmtamt\Amount'
		         DO FORM ..\CUSTOM\picklist WITH 'temppmt', lcList, lcBatch, 5, .T., .T.
		
		         IF llOK
		            swselect('arpmthdr')
		            SET ORDER TO cbatch
		            SEEK(temppmt.cbatch)
		            THISFORM.cmdatamanager.setrecordposition('arpmthdr')
		            THISFORM.REFRESH()
		         ENDIF
		      ELSE
		         THISFORM.omessage.DISPLAY('There are no ' + IIF(THISFORM.ctype = 'HG', 'house gas', IIF(THISFORM.ctype = 'AR', 'customer', 'owner')) + ' payments in the payment file.')
		      ENDIF
		
		      IF USED('temppmt1')
		         USE IN temppmt1
		      ENDIF
		
		      IF USED('temppmt')
		         USE IN temppmt
		      ENDIF
		
		   ENDIF
		
		   SELECT (lcSelect)
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'List', loError.LINENO, 'Receive Payments', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the list at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn 
	ENDPROC

	PROCEDURE netbalances		&& Gets the balances from suspense for net owners or HG owners
		LPARAMETERS tlNoZeroWells
		*
		* Get the suspense balances for the owner to be applied as part of the pmt
		*
		LOCAL lNetJIB, lcCustiD
		LOCAL lcBatch, lcPmtType, lnSelect, llReturn
		
		llReturn = .T.
		
		TRY
		   lnSelect  = SELECT()
		   lcCustiD  = arpmthdr.cCustId
		   lcBatch   = THISFORM.cBatch
		   lcPmtType = LEFT(THISFORM.cType, 1)
		
		   CREATE CURSOR auditrecs ;
		      (cYear      C(4), ;
		        dSuspDate  D,    ;
		        cTime      C(8), ;
		        cAction    C(1), ;
		        cGroup     C(2), ;
		        nAmount    N(12, 2), ;
		        cSuspType  C(1), ;
		        dinvdate   D, ;
		        csuspdesc  C(25), ;
		        cownerid   C(10), ;
		        ctypeinv   C(1), ;
		        cwellid    C(10), ;
		        cwellname  C(30), ;
		        cProgCode  C(10), ;
		        cprogname  C(30), ;
		        lProgFlag  L, ;
		        cPeriod    C(2), ;
		        cownname   C(40))
		   INDEX ON cownerid + cwellid TAG ownerwell
		
		   jcount     = 0
		
		   SELECT  MAX(hYear) AS cYear, ;
		           SUM(nNetCheck) AS nAmount, ;
		           cSuspType, ;
		           cTypeInv, ;
				   suspense.cownerid AS cownerid, ;
				   suspense.cwellid AS cwellid, ;
				   MAX(hPeriod) AS cPeriod, ;
				   cGroup, ;
				   MAX(hdate) AS dinvdate, ;
				   investor.cownname AS cownname ;
			   FROM suspense, investor ;
			   WHERE suspense.cownerid = lcCustiD ;
				   AND suspense.cownerid = investor.cownerid ;
			   ORDER BY suspense.cownerid, suspense.cwellid, ctypeinv ;
			   GROUP BY suspense.cownerid, suspense.cwellid, ctypeinv ;
			   INTO CURSOR temp
		   SELECT auditrecs
		   APPEND FROM DBF('temp')
		   GO TOP
		   SCAN
		      m.cwellid = cwellid
		      swselect('wells')
		      SET ORDER TO cwellid
		      SEEK m.cwellid
		      IF FOUND()
		         m.cwellname = cwellname
		         SELECT auditrecs
		         REPLACE cwellname WITH m.cwellname
		      ENDIF
		   ENDSCAN
		
		   SELE auditrecs
		   SCAN
		      SCATTER MEMVAR
		      m.nInvTot   = m.nAmount * -1
		      m.nInvbal   = m.nAmount * -1
		      m.cCustId   = m.cownerid
		      m.cinvnum   = m.cwellid
		      m.cBatch    = lcBatch
		      m.cProdYear = m.cYear
		      m.cProdPrd  = m.cPeriod
		      m.lNetJIB   = .T.
		      m.cInvToken = ''
		      m.cidarpmd  = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		      SET DELETED OFF
		      SELECT arpmtdet1
		      SET ORDER TO cidarpmd
		      DO WHILE INDEXSEEK(m.cidarpmd)
		         m.cidarpmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		      ENDDO
		      SET DELETED ON
		      INSERT INTO arpmtdet FROM MEMVAR
		   ENDSCAN
		
		   IF NOT tlNoZeroWells
		      swselect('wellinv')  &&  Scan through their current interests, and bring in any wells that don't have a balance already, so money can be easily applied to them - BH 9/7/06
		      SCAN FOR cownerid = lcCustiD
		         SELECT auditrecs
		         LOCATE FOR cwellid = wellinv.cwellid  &&  If it doesn't exist, insert a zero record
		         IF NOT FOUND()
		            STORE 0 TO m.nInvTot, m.nInvbal
		            m.cCustId  = lcCustiD
		            m.dinvdate = DATE()  &&  No records, so just use the current date to display
		            m.cinvnum  = wellinv.cwellid
		            m.cBatch   = lcBatch
		            m.lNetJIB  = .T.
		            m.cidarpmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		            SET DELETED OFF
		            SELECT arpmtdet1
		            SET ORDER TO cidarpmd
		            DO WHILE INDEXSEEK(m.cidarpmd)
		               m.cidarpmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		            ENDDO
		            SET DELETED ON
		            INSERT INTO arpmtdet FROM MEMVAR
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'NetBalances', loError.LINENO, 'Receive Payments', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the payment at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn
	ENDPROC

	PROCEDURE new
		LPARAMETERS cWorkarea
		
		thisform.lAskAboutSuspense = .T.
		
		DODEFAULT(cWorkArea)
	ENDPROC

	PROCEDURE requeryrecordsource
		LOCAL lcCustId, lcBatch, lnCount, lnSelect, llReturn
		LOCAL lcPmtType, llRetval, lnInvBal, loError
		
		#DEFINE NoZeroWells .T.
		
		llReturn = .T.
		
		TRY
		*
		*  Check for outstanding invoices for the given customer.
		*
		   lnSelect  = SELECT()
		   lcCustId  = arpmthdr.cCustId
		   lcBatch   = THISFORM.cBatch
		   lcPmtType = LEFT(THISFORM.cType, 1)
		
		   THISFORM.lIncludeSuspense = .F.
		
		   IF THIS.lNewBuild
		      llRetval = araged(lcCustId, lcCustId, {12/31/2099}, .T., 1, THISFORM.cType = 'HG', .F., .F., THISFORM.cType = 'JIB')
		
		      IF llRetval
		         IF THISFORM.cType <> 'HG' AND THISFORM.cType <> 'NET'  &&  Don't do it for house gas invoices, or net owners
		            SELE custbal
		            SCAN
		               m.cBatch = cBatch
		               lnInvBal = nInvbal
		               swselect('invhdr')
		*  Don't include invoices with an invoice date later than the payment date
		               SCAN FOR cBatch == m.cBatch AND nInvbal <> 0 AND dInvDate <= arpmthdr.drecdate
		                  SCATTER MEMVAR
		                  m.nInvbal   = lnInvBal
		                  m.cInvToken = m.cBatch
		                  m.cBatch    = lcBatch
		                  m.cidarpmd  = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		                  SET DELETED OFF
		                  SELECT arpmtdet1
		                  SET ORDER TO cidarpmd
		                  DO WHILE INDEXSEEK(m.cidarpmd)
		                     m.cidarpmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		                  ENDDO
		                  SET DELETED ON
		                  IF m.ndiscTot > 0 AND arpmthdr.drecdate <= m.dDiscDate  &&  If there's a discount available, and within the discount date
		 *                    m.nInvTot   = m.nInvbal
		                     m.nInvbal   = m.nInvbal - m.ndiscTot
		                     m.nDisTaken = m.ndiscTot
		                  ELSE
		                     m.ndiscTot  = 0
		                     m.nDisTaken = 0
		*                     m.nInvTot   = 0
		                  ENDIF
		                  INSERT INTO arpmtdet FROM MEMVAR
		               ENDSCAN
		            ENDSCAN
		         ENDIF
		      ENDIF
		
		      IF THISFORM.cType = 'HG' AND m.goapp.lHouseGasOpt  &&  House gas invoices
		         SELE custbal
		         SCAN
		            m.cBatch = cBatch
		            lnInvBal = nInvbal
		            swselect('gasinv')
		*  Only scan for invoices whose invoice date is on or before the payment date.
		            SCAN FOR gasinv.cidgasinv == m.cBatch AND gasinv.nBalance <> 0 AND gasinv.dInvDate <= arpmthdr.drecdate
		               SCATTER MEMVAR
		               m.nInvbal   = lnInvBal
		               m.cInvToken = m.cBatch
		               m.cBatch    = lcBatch
		               m.cidarpmd  = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		               SET DELETED OFF
		               SELECT arpmtdet1
		               SET ORDER TO cidarpmd
		               DO WHILE INDEXSEEK(m.cidarpmd)
		                  m.cidarpmd = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		               ENDDO
		               SET DELETED ON
		               IF m.ndiscTot > 0 AND arpmthdr.drecdate <= m.dDiscDate  &&  If there's a discount available, and within the discount date
		                  m.nInvTot   = m.nInvbal
		                  m.nInvbal   = m.nInvbal - m.ndiscTot
		                  m.nDisTaken = m.ndiscTot
		               ELSE
		                  m.ndiscTot  = 0
		                  m.nDisTaken = 0
		                  m.nInvTot   = 0
		               ENDIF
		               INSERT INTO arpmtdet FROM MEMVAR
		            ENDSCAN
		         ENDSCAN
		         IF NOT EMPTY(lcCustId) AND ;
		            thisform.cmdatamanager.isnew('Arpmthdr') AND ;
		           (thisform.lAskAboutSuspense = .T. OR thisform.lAskedaboutsuspensealready = .t.)
		            IF NOT thisform.lAskedAboutSuspenseAlready 
		               llSuspense = MESSAGEBOX('Include suspense balances for this owner (if any)?',36,'Include Suspense') = 6
		               thisform.lAskedAboutSuspenseAlready = .t.
		               thisform.lIncludeSuspense = llSuspense
		               IF llSuspense
		                  THISFORM.NetBalances(NoZeroWells)
		               ENDIF    
		            ENDIF 
		            IF thisform.lASkedaboutsuspensealready
		               thisform.lAskAboutSuspense = .F.
		            ENDIF    
		         ENDIF
		      ENDIF
		
		
		*
		*  Check for suspense
		*
		      IF THISFORM.cType = 'NET'
		         THISFORM.NetBalances()
		      ENDIF
		
		      swselect('arpmtdet')
		      GO TOP
		      THISFORM.REFRESH()
		
		
		   ENDIF
		   SELECT (lnSelect)
		
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'RequeryRecordSource', loError.LINENO, 'Receive Payments', loError.ERRORNO, loError.MESSAGE
		   MESSAGEBOX('Unable to process the payment at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llReturn 
	ENDPROC

	PROCEDURE save
		LPARAMETERS cworkarealist
		
		thisform.txtccustid.setfocus()
		thisform.setnextcontrol(thisform.txtccustid)
		thisform.activatenextcontrol()
		
		return(DODEFAULT(cworkarealist))
	ENDPROC

	PROCEDURE cboAcct.afterchange
		swselect('coa')
		SET ORDER to acctno
		IF SEEK(THISFORM.cboAcct.VALUE)
			THISFORM.txtAcctDesc.VALUE = cAcctDesc
			THISFORM.txtAcctDesc.REFRESH()
		ENDIF
		DODEFAULT()
		
		
	ENDPROC

	PROCEDURE cboAcct.Init
		*
		*  Builds the data displayed in the combo list box
		*
		IF m.goapp.lAMVersion
		    SELECT  cAcctNo, cAcctDesc FROM coa INTO ARRAY laAcct  ORDER BY cAcctNo
		    IF _TALLY > 0
		        FOR lnX = 1 TO ALEN(laAcct,1)
		            THIS.ADDLISTITEM(laAcct[lnX,1],lnX,1)
		            THIS.ADDLISTITEM(laAcct[lnX,2],lnX,2)
		        ENDFOR
		        swselect('coa')
		        SET ORDER TO acctno
		        IF SEEK(arpmthdr.cAcctNo)
		            THISFORM.txtacctdesc.VALUE = cAcctDesc
		            THISFORM.txtacctdesc.REFRESH()
		        ELSE
		            THISFORM.txtacctdesc.VALUE = ''
		            THISFORM.txtacctdesc.REFRESH()
		        ENDIF
		        *!*	   THISFORM.txtAcctDesc.VALUE = laAcct[1,2]
		    ENDIF
		ENDIF
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cmdatamanager.afterdelete
		LPARAMETERS cworkarea
		thisform.cmdatamanager.setrecordposition('arpmthdr')
		
		return(DODEFAULT(cworkarea))
	ENDPROC

	PROCEDURE cmdatamanager.afternav
		LPARAMETERS cworkarea
		
		IF m.cworkarea = 'Arpmthdr'
		   IF THISFORM.lNewBuild
		      THISFORM.requeryrecordsource()
		      THISFORM.calctot()
		      THISFORM.txtcCustid.VALID()
		   ENDIF
		   swselect('glopt')
		   GO TOP
		
		   IF m.goapp.lAMVersion
		      IF arpmthdr.cacctno = glopt.cundepfund
		         THISFORM.opgDeposits.VALUE = 1
		         THISFORM.cboAcct.SET('enabled',.F.)
		      ELSE
		         THISFORM.opgDeposits.VALUE = 2
		         THISFORM.cboAcct.SET('enabled',.T.)
		      ENDIF
		      swselect('coa')
		      SET ORDER TO acctno
		      IF SEEK(arpmthdr.cacctno)
		         THISFORM.txtacctdesc.VALUE = cacctdesc
		         THISFORM.txtacctdesc.REFRESH()
		      ELSE
		         THISFORM.txtacctdesc.VALUE = ''
		         THISFORM.txtacctdesc.REFRESH()
		      ENDIF
		   ENDIF
		
		   IF arpmthdr.cPmtType = 'A'  &&  Look in custs for the name
		      SWSELECT('custs')
		      LOCATE FOR ccustid = arpmthdr.ccustid
		      IF FOUND()
		         THISFORM.txtcCustName.VALUE = custs.cCustName
		         THISFORM.txtcCustName.REFRESH()
		      ELSE
		         THISFORM.txtcCustName.VALUE = 'Unknown customer'
		         THISFORM.txtcCustName.REFRESH()
		      ENDIF
		   ELSE  &&  JIB, Net, or HG owner, so use investor
		      SWSELECT('investor')
		      LOCATE FOR cownerid = arpmthdr.ccustid
		      IF FOUND()
		         THISFORM.txtcCustName.VALUE = investor.cOwnName
		         THISFORM.txtcCustName.REFRESH()
		      ELSE
		         THISFORM.txtcCustName.VALUE = 'Unknown owner'
		         THISFORM.txtcCustName.REFRESH()
		      ENDIF
		   ENDIF
		   
		   *  Store the current settings for amount applied and amount unapplied.
		   *  For some kinds of payments, it's necessary to back out and re-apply the payment
		   *  amounts, and if we don't know them, it's FUBAR'ed.
		   *  Also used to remove credit invoices created for HG overpayments.
		   thisform.noldapp = arpmthdr.nApplied   
		   thisform.nOldUnapp = arpmthdr.nUnApp
		ENDIF
		
		swselect('arpmthdr')
		
		RETURN(DODEFAULT(cworkarea))
		
	ENDPROC

	PROCEDURE cmdatamanager.afternew
		LPARAMETERS cworkarea
		
		IF m.cworkarea == 'Arpmthdr'
		   IF EMPTY(THISFORM.coldacctno)
		      THISFORM.cboacct.LISTITEMID = 1
		   ELSE
		      THISFORM.cboacct.SET('value',THISFORM.coldacctno)
		   ENDIF
		
		   thisform.lIncludeSuspense = .f.
		   thisform.laskedaboutsuspensealready = .f. 
		   
		   llSafe = .F.
		   DO WHILE NOT llSafe  &&  Loop through arpmthdr and invhdr to find a mutually safe key, in case of credit invoices
		      lcBatch = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		      SELECT arpmthdr1
		      SET ORDER TO cBatch
		      SET DELE OFF
		      DO WHILE SEEK(lcBatch)
		         lcBatch = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		      ENDDO
		
		      llSafe = .T.
		
		      swselect('invhdr')
		      SET ORDER TO cBatch
		      DO WHILE SEEK(lcBatch)
		         lcBatch = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		         llSafe = .F.
		      ENDDO
		      SET DELE ON
		   ENDDO
		
		   swselect('arpmthdr')
		   REPLACE cBatch  WITH lcBatch, ;
		      cAcctNo WITH THISFORM.cboacct.VALUE, ;
		      dRecDate WITH DATE()
		
		   IF TYPE('thisform.cType') <> 'C'  &&  Not defined yet, so set it as blank
		      THISFORM.cType = 'C'
		   ENDIF
		
		   DO CASE
		      CASE THISFORM.cType = 'HG'
		         REPLACE cPmtType WITH 'H'
		      CASE THISFORM.cType = 'AR'
		         REPLACE cPmtType WITH 'A'
		      CASE thisform.cType = 'JIB'
		         REPLACE cPmtType WITH 'J'
		      OTHERWISE
		         REPLACE cPmtType WITH 'N'
		   ENDCASE
		
		
		   THISFORM.cBatch = lcBatch
		   THISFORM.lNewBuild = .T.
		   thisform.lRefreshdata = .t.
		   *   THISFORM.txtdRecDate.SET('value',DATE())
		   THISFORM.ccustsave  = ''
		   THISFORM.txtcCustName.VALUE = ''
		   THISFORM.cboacct.LISTITEMID = 1
		   THISFORM.opgDeposits.SET('value',2)
		   THISFORM.setnextcontrol(THISFORM.txtcCustID)
		ENDIF
		
		DODEFAULT(m.cworkarea)
		
		
	ENDPROC

	PROCEDURE cmdatamanager.afterupdate
		LPARAMETERS cworkarealist
		
		*
		*  Turn off the new flag
		*
		thisform.lNewBuild = .F.
		
		RETURN (DODEFAULT(m.cWorkarealist))
	ENDPROC

	PROCEDURE cmdatamanager.beforedelete
		LPARAMETERS cworkarea
		LOCAL lcBatch, lcidChec
		
		lcBatch  = arpmthdr.cBatch
		lcidChec = arpmthdr.cidChec
		
		swselect('checks')
		LOCATE FOR cidChec == lcidChec AND lCleared  
		* Make sure the deposit entry hasn't already been cleared before proceeding - BH 9/7/06
		IF FOUND()
		   THISFORM.oMessage.Warning('The deposit created by this payment has been cleared.  It cannot be deleted.')
		   RETURN .F.
		ENDIF
		
		IF THISFORM.cType = 'NET' OR THISFORM.cType = 'HG' 
		* Make sure that the suspense entry created by this payment is not in disbhist.  
		* If it is, it's been processed as part of a closing, and they can't update/delete it. - BH 9/7/06
		   swselect('disbhist')
		   LOCATE FOR cbatch == lcBatch AND cRecType = 'P'
		   IF FOUND()
		      THISFORM.oMessage.Warning('The history entries created by this payment have been processed as part of a revenue run closing.  It cannot be deleted.')
		      RETURN .F.
		   ENDIF
		ENDIF
		
		RETURN(DODEFAULT(cworkarea))
		
	ENDPROC

	PROCEDURE cmdatamanager.beforenew
		LPARAMETERS cworkarea
		
		IF m.cworkarea == 'Arpmthdr'
		   IF m.goapp.lAMVersion
		      swselect('coa')
		      SET ORDER TO acctno
		      IF SEEK(arpmthdr.cacctno) AND lBankAcct
		         THISFORM.coldacctno = arpmthdr.cacctno
		      ELSE
		         THISFORM.coldacctno = ''
		      ENDIF
		   ENDIF
		   thisform.lAskedaboutsuspensealready = .f.
		ENDIF
		
		RETURN(DODEFAULT(cworkarea))
		
	ENDPROC

	PROCEDURE cmdatamanager.beforeupdate
		LPARAMETERS cworkarealist
		LOCAL lcbatch, lcaracct, llreturn, lcselect, lnrecno, lcdefacct, lcMinAcct
		LOCAL lndiscounts, lcdiscacct, lcidchec, lnAppCount
		LOCAL oSuspense AS 'suspense'
		LOCAL lManual, lccheckkey, lcdeptno, lcgasaracct, lcjibacct, llDOI, llDisTaken, lnDetCount
		LOCAL lnDisTaken, lnselect, llOwnerHold
		
		llreturn = .T.
		
		TRY
		   *  Make sure the period or year isn't closed
		   IF NOT THISFORM.glmaint.checkperiod(arpmthdr.drecdate)
		      llreturn = .F.
		      EXIT
		   ENDIF
		
		   lnselect = SELECT()
		
		   IF arpmthdr.nPmtAmt < arpmthdr.nApplied
		      THISFORM.oMessage.Warning('You cannot apply payment amounts that equal more than the total amount of the payment.')
		      llreturn = .F.
		      EXIT
		   ENDIF
		
		   *
		   * Get the default A/R account
		   *
		   swselect('aropt')
		   GO TOP
		   lcaracct   = caracct
		   lcdiscacct = cdiscacct
		
		   IF m.goapp.lAMVersion
		      *  If no discount account exists, check to see if there are any invoices marked to have discounts applied, and don't let them proceed - BH 01/02/07
		      IF EMPTY(lcdiscacct)
		         swselect('arpmtdet')
		         LOCATE FOR cBatch == arpmthdr.cBatch AND nDisTaken <> 0
		         IF FOUND()
		            THISFORM.oMessage.Warning('You have chosen to use a discount, but the Disc Allowed Account ' + ;
		               'has not been specified on the Edit >> Preferences >> Accounts Receivable ' + ;
		               'screen.  Please correct before proceeding.')
		            llreturn = .F.
		            EXIT
		         ENDIF
		      ENDIF
		   ENDIF
		   *
		   * Get the JIB rcv acctc
		   *
		   swselect('options')
		   GO TOP
		   lcjibacct = cjibacct
		   lcdefacct = cdefacct
		   lcMinAcct = cMinAcct
		   lcdeptno  = cdeptno
		
		   swselect('gasopt')
		   GO TOP
		   lcgasaracct = caracct
		   IF EMPTY(lcgasaracct)  &&  If not defined, use the normal receivable account
		      lcgasaracct = lcaracct
		   ENDIF
		
		   lcidchec = arpmthdr.cidchec
		   lcbatch  = arpmthdr.cBatch
		
		   swselect('checks')
		   LOCATE FOR cidchec == lcidchec AND lCleared AND IIF(NOT EMPTY(lcidchec), .T., .F.)  &&  Make sure the deposit entry hasn't already been cleared before proceeding - BH 9/7/06
		   IF FOUND()
		      THISFORM.oMessage.Warning('The deposit created by this payment has been cleared.  No changes can be made to this payment.')
		      llreturn = .F.
		      EXIT
		   ENDIF
		
		   *  Look in disbhist to see if there are entries from this batch in it.  If there are, don't let them save, because those came from suspense
		   *  and have been processed during a run closing.  Otherwise, they'd end up with duplicate entries in suspense.
		   IF THISFORM.cType = 'NET' OR THISFORM.cType = 'HG'
		      swselect('disbhist')
		      LOCATE FOR cBatch == lcbatch AND cRecType = 'P'
		      IF FOUND()
		         THISFORM.oMessage.Warning('You cannot save this payment, because suspense entries created by it have been closed as part of a revenue run.')
		         llreturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   *
		   *  Check to make sure that payments have been applied to outstanding invoices
		   *
		   STORE 0 TO lnDisTaken, lnDetCount, lnAppCount
		   STORE .F. TO llDisTaken
		   swselect('arpmtdet')
		   SCAN FOR cBatch == lcbatch
		      IF nAmtApp <> 0
		         lnAppCount = nAmtApp
		      ENDIF
		      lnDisTaken = lnDisTaken + nDisTaken
		      lnDetCount = lnDetCount + 1
		      IF nDisTaken <> 0 AND nAmtApp = 0
		         llDisTaken = .T.
		      ENDIF
		   ENDSCAN
		   IF lnDetCount > 0
		      IF lnAppCount = 0
		         THISFORM.oMessage.Warning('The payment must be applied to at least one invoice.')
		         llreturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		   IF llDisTaken
		      THISFORM.oMessage.Warning('Discounts cannot be taken when nothing has been applied to the invoice.')
		      llreturn = .F.
		      EXIT
		   ENDIF
		
		   *
		   *  Delete the G/L journal entries for this payment and/or invoice
		   *
		   swselect('arpmthdr')
		   REPL cpmttype WITH THISFORM.cType
		   THISFORM.glmaint.delbatch(lcbatch, 'AR')
		   swselect('gasinv')
		   SCAN FOR cidgasinv = lcbatch  &&  Probably created by a credit, so get rid of it before it gets re-saved
		      REPLACE cidgasinv WITH THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		      DELETE NEXT 1
		   ENDSCAN
		
		   IF THISFORM.cType = 'NET' OR THISFORM.cType = 'HG'
		      swselect('suspense')  &&  Delete the suspense entries from any previous saves - BH 09/07/06
		      SCAN FOR cBatch == lcbatch AND cRecType = 'P'
		         DELE NEXT 1
		      ENDSCAN
		   ENDIF
		
		
		   IF arpmthdr.nunapp <> 0  AND THISFORM.cType = 'NET'  &&  If there are unapplied amounts, don't let them continue - BH 9/7/06
		      THISFORM.oMessage.Warning('You must apply the entire amount of the payment to one or more wells. ' + ;
		         'Please apply the rest of the payment to a well or wells before saving.')
		      llreturn = .F.
		      EXIT
		   ENDIF
		
		   m.ccustid = arpmthdr.ccustid
		
		   swselect('investor')
		   SET ORDER TO cownerid
		   IF SEEK(m.ccustid)
		      m.cinvtype  = 'J'
		      llOwnerHold = lHold
		   ELSE
		      m.cinvtype  = 'I'
		      llOwnerHold = .F.
		   ENDIF
		
		   *  Look for any credit memos that were created by this payment, change the batch, and then delete it.
		   swselect('invhdr')
		   LOCATE FOR cBatch = lcbatch
		   IF FOUND()
		      REPLACE cBatch WITH THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		      DELETE NEXT 1
		   ENDIF
		
		   IF arpmthdr.nunapp > 0 AND THISFORM.cType <> 'NET'  &&  Don't create a credit invoice for net owners
		      IF THISFORM.oMessage.CONFIRM('There is an unapplied amount which will be used to create a credit invoice.  Is this correct?')
		         *************************************
		         *  Creating the invoice header file for the credit invoice
		         *************************************
		         IF THISFORM.cType = 'HG'
		            m.cinvtype = 'HG'
		            * Get the meter no to put on this payment
		            swselect('gasuse')
		            LOCATE FOR cownerid == m.ccustid
		            m.cMeterNo = cMeterNo
		         ENDIF
		
		         swselect('arpmthdr')
		         m.cBatch  = lcbatch
		         m.cinvnum = 'CR' + RIGHT(THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Invoice Number'), 8)
		
		         m.dinvdate   = arpmthdr.drecdate
		         m.dduedate   = arpmthdr.drecdate
		         m.ddiscdate  = arpmthdr.drecdate
		         m.dpostdate  = arpmthdr.drecdate
		         m.creference = 'CREDIT MEMO'
		         m.nsubtotal  = arpmthdr.nunapp * -1
		         m.ninvtot    = arpmthdr.nunapp * -1
		         m.ninvbal    = arpmthdr.nunapp * -1
		         IF THISFORM.cType = 'HG'
		            m.cownerid  = m.ccustid
		            m.nTotal    = m.ninvtot
		            m.nbalance  = m.ninvbal
		            m.cidgasinv = m.cBatch
		            INSERT INTO gasinv FROM MEMVAR
		         ELSE
		            INSERT INTO invhdr FROM MEMVAR
		         ENDIF
		
		         *************************************
		         *  Creating the invoice detail file for the credit invoice
		         *************************************
		         m.cidinvd    = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Invoice Detail')
		         m.citemdesc  = 'CREDIT MEMO'
		         m.cpricecode = '1'
		         m.nprice     = arpmthdr.nunapp * -1
		         m.nquantity  = 1
		         m.nextension = arpmthdr.nunapp * -1
		         m.ctaxable   = 'E'
		         DO CASE
		            CASE THISFORM.cType = 'AR'
		               m.cacctno = lcaracct
		            CASE THISFORM.cType = 'HG'
		               m.cacctno = lcgasaracct
		            CASE THISFORM.cType = 'JIB'
		               m.cacctno = lcjibacct
		            OTHERWISE  &&  Should never get here
		               m.cacctno = lcaracct
		         ENDCASE
		
		         m.cBatch = arpmthdr.cBatch
		         IF THISFORM.cType <> 'HG'
		            INSERT INTO invdet FROM MEMVAR
		         ENDIF
		
		      ELSE
		         llreturn = .F.
		         EXIT
		      ENDIF
		   ENDIF
		
		   WAIT WINDOW NOWAIT 'Saving Changes, Please Wait.....'
		
		   lndiscounts = 0
		   swselect('arpmtdet')
		   SCAN FOR cBatch == lcbatch AND nDisTaken <> 0
		      lndiscounts = lndiscounts + nDisTaken
		   ENDSCAN
		
		   IF THISFORM.cType = 'NET'
		      * Deficit or Legal Suspense Account for Net owners
		      * Get the last suspense type per owner/well
		      oSuspense          = CREATEOBJECT('suspense')
		      oSuspense.cRunYear = TRANSFORM(YEAR(DATE()))
		      oSuspense.nRunNo   = 999
		      oSuspense.GetLastType(.F., .T.)
		   ENDIF
		
		   *  Create deposit entry
		   THISFORM.glmaint.dcheckdate = arpmthdr.drecdate
		   THISFORM.glmaint.dpostdate  = arpmthdr.drecdate
		   THISFORM.glmaint.cpayee     = THISFORM.txtccustname.VALUE
		   THISFORM.glmaint.namount    = arpmthdr.nPmtAmt
		   THISFORM.glmaint.centrytype = 'D'
		   THISFORM.glmaint.cidtype    = 'D'
		   THISFORM.glmaint.cacctno    = arpmthdr.cacctno
		   THISFORM.glmaint.cBatch     = lcbatch
		   THISFORM.glmaint.ccheckno   = arpmthdr.creference
		   THISFORM.glmaint.lprinted   = .T.
		   THISFORM.glmaint.cid        = arpmthdr.ccustid
		
		   *  Delete the current check, if there is one.
		   *  If this is an update to the payment, we
		   *  don't want duplicate checks to show up in
		   *  the register
		   THISFORM.glmaint.delcheck(lcidchec)
		
		   *  Set the source for this entry
		   IF INLIST(THISFORM.cType, 'NET', 'JIB') OR NOT m.goapp.lAMVersion
		      THISFORM.glmaint.csource = 'DM'
		   ELSE
		      THISFORM.glmaint.csource = 'AR'
		   ENDIF
		
		   *  Add the entry to the checks table
		   THISFORM.glmaint.addcheck()
		
		   *  Get the key of the check just created
		   *  and put it in the payment detail rec.
		   lccheckkey = THISFORM.glmaint.GETKEY()
		
		   IF TYPE('lcCheckKey') = 'C'
		      *  Save the primary key of the check in the header table
		      THIS.REPLACE('Arpmthdr', 'Cidchec', lccheckkey)
		   ENDIF
		
		
		   IF m.goapp.lAMVersion
		
		      *  Set the source for this entry
		      IF INLIST(THISFORM.cType, 'NET', 'JIB')  &&  If it's a JIB or net owner payment, make the source DM
		         THISFORM.glmaint.csource = 'DM'
		      ELSE
		         THISFORM.glmaint.csource = 'AR'
		      ENDIF
		      *  Create the G/L journal entries for this payment
		      *
		      *  A/R entry
		      THISFORM.glmaint.cBatch     = lcbatch
		      THISFORM.glmaint.dgldate    = arpmthdr.drecdate
		      THISFORM.glmaint.creference = 'Ref: ' + ALLTRIM(arpmthdr.creference)
		      THISFORM.glmaint.cdesc      = THISFORM.txtccustname.VALUE
		
		      swselect('arpmtdet')
		      SCAN FOR cBatch == lcbatch
		         *  If this is not an AR payment, plug in the DM dept defined in the options table
		         IF THISFORM.cType <> 'AR'
		            THISFORM.glmaint.cdeptno = lcdeptno
		         ELSE
		            THISFORM.glmaint.cdeptno = ' '
		         ENDIF
		
		         DO CASE
		            CASE THISFORM.cType = 'AR'
		               THISFORM.glmaint.cacctno = lcaracct
		            CASE THISFORM.cType = 'HG'
		               IF arpmtdet.lnetjib
		                  * If we're including suspense make sure we post to the legal suspense account
		                  * Might need to post individual lines in the future in case they did make a
		                  * payment and apply suspense in the same transaction. PS 11/17/13
		                  THISFORM.glmaint.cacctno = lcMinAcct
		               ELSE
		                  THISFORM.glmaint.cacctno = lcgasaracct
		               ENDIF
		            CASE THISFORM.cType = 'JIB'
		               THISFORM.glmaint.cacctno = lcjibacct
		            OTHERWISE
		               SELECT curlastsusptype
		               LOCATE FOR cownerid == m.ccustid
		               IF FOUND()
		                  DO CASE
		                     CASE llOwnerHold
		                        THISFORM.glmaint.cacctno = lcMinAcct
		                     CASE curlastsusptype.csusptype = 'D'
		                        THISFORM.glmaint.cacctno = lcdefacct
		                     OTHERWISE
		                        THISFORM.glmaint.cacctno = lcMinAcct
		                  ENDCASE
		               ELSE
		                  IF NOT llOwnerHold
		                     THISFORM.glmaint.cacctno = lcdefacct
		                  ELSE
		                     THISFORM.glmaint.cacctno = lcMinAcct
		                  ENDIF
		               ENDIF
		         ENDCASE
		
		         THISFORM.glmaint.cid     = arpmthdr.ccustid
		         THISFORM.glmaint.cunitno = arpmtdet.cinvnum
		         THISFORM.glmaint.namount = (arpmtdet.nAmtApp + arpmtdet.nDisTaken) * -1
		         THISFORM.glmaint.cbunch  = THISFORM.cbunch
		
		         THISFORM.glmaint.updatebatch()
		      ENDSCAN
		
		      IF arpmthdr.nunapp > 0
		         DO CASE
		            CASE THISFORM.cType = 'JIB'
		               THISFORM.glmaint.cacctno = lcjibacct
		            CASE THISFORM.cType = 'HG'
		               THISFORM.glmaint.cacctno = lcgasaracct
		            OTHERWISE
		               THISFORM.glmaint.cacctno = lcaracct
		         ENDCASE
		         THISFORM.glmaint.namount = arpmthdr.nunapp * -1
		         THISFORM.glmaint.cunitno = ''
		         THISFORM.glmaint.cdesc   = ALLTRIM(THISFORM.txtccustname.VALUE) + ' - Credit Invoice'
		         THISFORM.glmaint.updatebatch()
		      ENDIF
		
		      *  Cash entry
		      THISFORM.glmaint.cBatch     = lcbatch
		      THISFORM.glmaint.dgldate    = arpmthdr.drecdate
		      THISFORM.glmaint.creference = 'Ref: ' + ALLTRIM(arpmthdr.creference)
		      THISFORM.glmaint.cdesc      = THISFORM.txtccustname.VALUE
		      THISFORM.glmaint.cacctno    = arpmthdr.cacctno
		      THISFORM.glmaint.cid        = arpmthdr.ccustid
		      THISFORM.glmaint.namount    = arpmthdr.nPmtAmt
		      THISFORM.glmaint.cdesc      = THISFORM.txtccustname.VALUE
		      THISFORM.glmaint.cunitno = ''
		      THISFORM.glmaint.updatebatch()
		
		   ENDIF
		
		   *  Remove previous payments
		   IF NOT THIS.isnew('arpmthdr')
		      SELECT * FROM arpmtdet WHERE cBatch = lcbatch INTO CURSOR temppmt
		      IF _TALLY > 0
		         SELECT temppmt
		         SCAN
		            SCATTER MEMVAR
		            IF m.nAmtApp = 0
		               LOOP
		            ENDIF
		            swselect('invhdr')
		            SET ORDER TO cBatch
		            IF SEEK(m.cinvtoken)
		               REPLACE invhdr.ninvbal WITH (invhdr.ninvbal + m.nAmtApp), ;
		                  invhdr.npayments WITH (invhdr.npayments - m.nAmtApp)
		            ENDIF
		
		            IF THISFORM.cType = 'HG'
		               swselect('gasinv')
		               SET ORDER TO cidgasinv
		               IF SEEK(m.cinvtoken)
		                  REPLACE gasinv.nbalance WITH (gasinv.nbalance + m.nAmtApp),  ;
		                     gasinv.npmts WITH (gasinv.npmts - m.nAmtApp)
		               ENDIF
		            ENDIF
		         ENDSCAN
		         USE IN temppmt
		      ENDIF
		   ENDIF
		
		   *  Mark Invoices as being paid
		   lndiscounts = 0
		   m.cidchec   = lccheckkey
		 
		   swselect('arpmtdet')
		   SCAN FOR cBatch == lcbatch
		      SCATTER MEMVAR
		      *
		      *  Total the discounts taken
		      *
		      IF m.nDisTaken <> 0
		         lndiscounts = lndiscounts + m.nDisTaken
		      ENDIF
		      *
		      *  Nothing was applied to this invoice
		      *  so loop to next invoice
		      *
		      IF m.nAmtApp = 0
		         LOOP
		      ENDIF
		      *  Update the invoice header to mark the invoice payment
		
		      IF NOT m.lnetjib
		         swselect('invhdr')
		         SET ORDER TO cBatch
		         IF SEEK(m.cinvtoken)
		            REPLACE invhdr.ninvbal WITH (invhdr.ninvbal - m.nAmtApp), ;
		               invhdr.npayments WITH (invhdr.npayments + m.nAmtApp)
		         ENDIF
		
		         IF THISFORM.cType = 'HG'
		            swselect('gasinv')
		            SET ORDER TO cidgasinv
		            IF SEEK(m.cinvtoken)
		               REPLACE gasinv.nbalance WITH (gasinv.nbalance - m.nAmtApp),  ;
		                  gasinv.npmts WITH (gasinv.npmts + m.nAmtApp)
		            ENDIF
		         ENDIF
		      ELSE
		         IF THISFORM.cType = 'HG'
		            swselect('gasinv')
		            SET ORDER TO cidgasinv
		            IF SEEK(m.cinvtoken)
		               REPLACE gasinv.nbalance WITH (gasinv.nbalance - m.nAmtApp),  ;
		                  gasinv.npmts WITH (gasinv.npmts + m.nAmtApp)
		            ENDIF
		         ENDIF
		
		         *  Add the payment to the suspense file
		         m.nNetCheck = arpmtdet.nAmtApp
		         m.cownerid  = arpmthdr.ccustid
		         m.cprogcode = ''
		         m.cRecType  = 'P'  &&  Payment type - BH 9/7/06
		         m.cidchec   = arpmthdr.cidchec
		         m.cwellid   = LEFT(ALLTRIM(m.cinvnum),10)
		         m.lManual   = .T.
		         m.csusptype = 'M'
		
		         IF THISFORM.cType = 'NET'
		            * If the owner is on hold, mark the suspense type as legal suspense "H"
		            swselect('investor')
		            SET ORDER TO cownerid
		            IF SEEK(m.ccustid) AND lHold
		               m.csusptype = 'H'
		            ELSE
		               * Get the last suspense type per owner/well
		               SELECT curlastsusptype
		               LOCATE FOR cownerid == m.ccustid AND cwellid == m.cwellid
		               IF FOUND() AND NOT EMPTY(curlastsusptype.csusptype)
		                  m.csusptype  = curlastsusptype.csusptype  &&  Suspense type - PS 3/31/07
		               ELSE
		                  * Shouldn't get here
		                  m.csusptype = 'D'
		               ENDIF
		            ENDIF
		         ENDIF
		         
		         m.ctypeinv = ''
		
		         *  Get the owner type to put on the record
		         IF EMPTY(m.cTypeInv)
		            swselect('suspense')
		            LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv = 'W'
		            IF FOUND()
		               m.cTypeInv  = suspense.cTypeInv
		               m.cTypeInt  = suspense.cTypeInt
		               m.cprogcode = suspense.cprogcode
		            ELSE
		               LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv # 'W'
		               IF FOUND()
		                  m.cTypeInv  = suspense.cTypeInv
		                  m.cTypeInt  = suspense.cTypeInt
		                  m.cprogcode = suspense.cprogcode
		               ELSE
		                  swselect('wellinv')
		                  LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv = 'W'
		                  IF FOUND()
		                     m.cTypeInv  = wellinv.cTypeInv
		                     m.cTypeInt  = wellinv.cTypeInt
		                     m.cprogcode = wellinv.cprogcode
		                  ELSE
		                     LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv # 'W'
		                     IF FOUND()
		                        m.cTypeInv  = wellinv.cTypeInv
		                        m.cTypeInt  = wellinv.cTypeInt
		                        m.cprogcode = wellinv.cprogcode
		                     ELSE
		                        swselect('disbhist')
		                        LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv = 'W'
		                        IF FOUND()
		                           m.cTypeInv  = disbhist.cTypeInv
		                           m.cTypeInt  = disbhist.cTypeInt
		                           m.cprogcode = disbhist.cprogcode
		                        ELSE  &&  Punt
		                           LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv # 'W'
		                           IF FOUND()
		                              m.cTypeInv  = disbhist.cTypeInv
		                              m.cTypeInt  = disbhist.cTypeInt
		                              m.cprogcode = disbhist.cprogcode
		                           ELSE
		                              m.cTypeInv  = 'W'
		                              m.cTypeInt  = 'B'
		                              m.cprogcode = ''
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               ENDIF
		            ENDIF
		         ELSE
		            swselect('suspense')
		            LOCATE FOR cownerid == m.cownerid AND cwellid == m.cwellid AND cTypeInv = m.ctypeinv
		            IF FOUND()
		               m.cTypeInv  = suspense.cTypeInv
		               m.cTypeInt  = suspense.cTypeInt
		               m.cprogcode = suspense.cprogcode
		            ENDIF 
		         ENDIF
		
		
		         swselect('wells')  &&  Find the current well group, so we can find the last closing for that group, and put that on the suspense entry
		         LOCATE FOR ALLTRIM(cwellid) == ALLTRIM(m.cwellid)
		         IF FOUND()
		            m.cGroup = wells.cGroup
		            swselect('sysctl')
		            SET ORDER TO YearRun DESCENDING
		            GO TOP
		            LOCATE FOR cGroup = m.cGroup AND cTypeClose = 'R' AND nRunNo # 9999  &&  Locate last closing
		            IF FOUND()
		               m.cRunYear    = cRunYear
		               m.nRunNo      = nRunNo
		               m.nRunNo_IN   = nRunNo
		               m.cRunYear_In = cRunYear
		               m.hDate       = dAcctDate
		            ELSE  &&  No closings found, so set it to a very early date, to avoid any data overlap problems that may arise down the road
		               m.cRunYear    = '1980'
		               m.nRunNo      = 1
		               m.nRunNo_IN   = 1
		               m.cRunYear_In = '1980'
		               m.hDate       = {12/31/1980}
		            ENDIF
		         ELSE  &&  Can't find the chosen well, so set some defaults - should never get here
		            m.cGroup      = '00'
		            m.cRunYear    = '1980'
		            m.nRunNo      = 1
		            m.nRunNo_IN   = 1
		            m.cRunYear_In = '1980'
		            m.hDate       = {12/31/1980}
		         ENDIF
		
		
		         swselect('suspense')
		         SET ORDER TO ciddisb
		         m.ciddisb    = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		         SET DELE OFF
		         DO WHILE SEEK(m.ciddisb)
		            m.ciddisb    = THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		         ENDDO
		         SET DELE ON
		
		         IF arpmtdet.nAmtApp <= ninvbal
		            INSERT INTO suspense FROM MEMVAR
		         ELSE
		            *  They paid more than they should have.  We'll leave the overpayment suspense type
		            *  match the payment suspense type. We shouldn't be switching suspense types here
		            *  because the posting hasn't been switched from one account to the other.
		            INSERT INTO suspense FROM MEMVAR
		         ENDIF
		
		      ENDIF
		   ENDSCAN
		
		   * Check to see if this payment zeroed out suspense
		   * If it did then clear the suspense for this owner
		   *!*	    IF THISFORM.cType = 'NET'
		   *!*	       IF VARTYPE(oSuspense) = 'O'
		   *!*	          lnBalance = oSuspense.Owner_Current_Balance(m.cownerid)
		   *!*	          IF lnBalance = 0
		   *!*	          ENDIF
		   *!*	       ENDIF
		   *!*	    ENDIF
		
		   IF lndiscounts <> 0 AND m.goapp.lAMVersion
		      THISFORM.glmaint.cacctno = lcdiscacct
		      THISFORM.glmaint.namount = lndiscounts
		      THISFORM.glmaint.updatebatch()
		   ENDIF
		
		   *  Check to make sure the batch balances
		   IF m.goapp.lAMVersion
		      llreturn = THISFORM.glmaint.chkbalance()
		   ELSE
		      llreturn = .T.
		   ENDIF
		
		   IF llreturn
		      WAIT WINDOW NOWAIT 'Changes Saved....' TIMEOUT 2
		   ELSE
		      WAIT WIND 'The Batch Was Not In Balance...Unable to save payment.'
		   ENDIF
		
		
		   IF THISFORM.cType = 'NET'
		      *  If they paid off a well's entire balance, check the DOI to see if they have an interest in that well yet.
		      *  If they don't, then warn them that they'll need to clear the balance to move it over to disbhist.
		      llDOI = .F.
		
		      CREATE CURSOR BalTemp  ;
		         (cownerid   c(10),  ;
		         cwellid    c(10))
		
		      lnPmtZero = 0
		      swselect('arpmtdet')
		      SCAN FOR cBatch = lcbatch AND ninvbal <> 0 AND nAmtApp <> 0
		         lnPmtZero = lnPmtZero + (ninvbal - nAmtApp)
		      ENDSCAN
		
		      IF lnPmtZero = 0
		         MESSAGEBOX("One or more wells have had their balance paid completely. " + ;
		            "The original suspense entries and the payment will offset each " + ;
		            "other to make a zero balance, but the amounts will still be considered " + ;
		            "in suspense until the next run clears them out.  If you would like " + ;
		            "these totals to affect 1099 and other reports then you will need to " + ;
		            "Clear Owner Suspense for ONLY these wells under the Utilities menu. " + ;
		            "This will move the offsetting entries out of suspense so that they will " + ;
		            "be included on those reports.",48,'Action Needed')
		      ENDIF
		   ENDIF
		
		   swselect('suspense')
		   TABLEUPDATE(.T.)
		   SELECT (lnselect)
		
		CATCH TO loError
		   llreturn = .F.
		   DO errorlog WITH 'BeforeUpdate', loError.LINENO, 'Receive Payments', loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the payment at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		      'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		RETURN llreturn
		
		
		
		
		
		
		
		
		
		
		
	ENDPROC

	PROCEDURE cmdatamanager.delete
		LPARAMETERS cworkarea
		LOCAL lcBatch, lcPmtBatch, lcAmount
		
		*  Make sure the period or year isn't closed
		IF NOT THISFORM.glmaint.CheckPeriod(arpmthdr.drecdate)
		   THISFORM.cmdatamanager.setrecordposition('arpmthdr')
		   RETURN .F.
		ENDIF
		
		IF NOT THISFORM.cmdatamanager.BEFOREDELETE() OR NOT THISFORM.oMessage.CONFIRM('Are you sure you want to delete this payment?')
		   RETURN .F.
		ENDIF
		
		lnSelect = SELECT()
		
		lcPmtBatch = arpmthdr.cbatch
		lcidchec = arpmthdr.cidchec
		
		DO CASE
		   CASE LOWER(m.cworkarea) = 'arpmthdr'
		
		      swselect('depositd')
		      LOCATE FOR cidchec = lcidchec
		      IF FOUND()
		         THISFORM.oMessage.Warning('This payment was grouped with other entries and deposited.  ' + ;
		            'The deposit must be deleted from the Tasks >> Make Deposits screen before deleting the payment.')
		         RETURN .F.
		      ENDIF
		
		      *
		      *  Delete the G/L journal entries for this payment
		      *
		      IF INLIST(THISFORM.cType,'NET','JIB')  &&  If it's a JIB or net owner payment, delete with a source of DM
		         THISFORM.glmaint.delbatch(lcPmtBatch,'DM')
		      ELSE
		         THISFORM.glmaint.delbatch(lcPmtBatch,'AR')
		      ENDIF
		      THISFORM.glmaint.delcheck(lcidchec)
		
		      swselect('invhdr')
		      LOCATE FOR cbatch == arpmthdr.cbatch
		      IF FOUND()
		         DELE NEXT 1
		      ENDIF
		
		      swselect('arpmtdet')
		      SCAN FOR cbatch = lcPmtBatch AND namtapp <> 0
		         lcBatch = arpmtdet.cinvtoken
		         lcBatchInv = arpmtdet.cbatch
		         lnAmount = arpmtdet.namtapp
		         swselect('invhdr')
		         LOCATE FOR cbatch == lcBatch
		         IF FOUND('invhdr')
		            REPLACE npayments WITH npayments - lnAmount
		            REPLACE ninvbal WITH ninvbal + lnAmount
		         ENDIF
		         *  Look for credit invoices and delete if they were created with this payment
		         LOCATE FOR cbatch == lcBatchInv
		         IF FOUND()
		            DELETE NEXT 1
		         ENDIF
		
		         IF m.goapp.lHouseGasOpt AND THISFORM.cType = 'HG'  &&  Delete house gas invoices
		            swselect('gasinv')
		            LOCATE FOR cidgasinv = lcBatch
		            IF FOUND('gasinv')
		               REPLACE nPmts WITH nPmts - lnAmount
		               REPLACE nBalance WITH nBalance + lnAmount
		            ENDIF
		            *  Look for credit invoices and delete if they were created by this payment
		            LOCATE FOR cidgasinv == lcBatchInv
		            IF FOUND()
		               REPLACE cidgasinv WITH THISFORM.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		               DELETE NEXT 1
		            ENDIF
		         ENDIF
		         swselect('arpmtdet')
		         DELETE NEXT 1
		      ENDSCAN
		
		      swselect('checks')
		      LOCATE FOR cbatch = lcPmtBatch
		      IF FOUND('checks')
		         DELETE
		      ENDIF
		
		      * Changed to check that lcidchec is not empty.
		      * Also changed to only delete payment records because they are the
		      * only suspense records that should have a cidchec filled in.
		      * pws - 1/1/13
		      IF THISFORM.cType = 'NET' OR Thisform.cType = 'HG'
		         IF NOT EMPTY(lcidchec)
		            * Delete suspense payment records associated with this payment
		            swselect('suspense')
		            SCAN FOR cidchec == lcidchec AND cRecType = 'P'
		               DELE NEXT 1
		            ENDSCAN
		         ELSE
		            swselect('suspense')
		            SCAN FOR cbatch == lcPmtBatch AND cRecType = 'P'
		               DELE NEXT 1
		            ENDSCAN
		         ENDIF
		      ENDIF
		
		      *  Look for any credit memos that were created by this payment and delete it.
		      swselect('invhdr')
		      LOCATE FOR cbatch = lcPmtBatch
		      IF FOUND()
		         DELETE NEXT 1
		      ENDIF
		
		      swselect('arpmthdr')
		      DELETE NEXT 1
		      =TABLEUPDATE(.T.)
		      swselect('arpmtdet')
		      =TABLEUPDATE(.T.)
		      swselect('invhdr')
		      =TABLEUPDATE(.T.)
		      swselect('invdet')
		      =TABLEUPDATE(.T.)
		      swselect('checks')
		      =TABLEUPDATE(.T.)
		      swselect('suspense')
		      =TABLEUPDATE(.T.)
		
		      IF m.goapp.lAMVersion
		         swselect('coabal')
		         =TABLEUPDATE(.T.)
		         swselect('glmaster')
		         =TABLEUPDATE(.T.)
		      ENDIF
		
		      swselect('gasinv')
		      =TABLEUPDATE(.T.)
		
		      THISFORM.cmdatamanager.revertall()
		      THISFORM.NEXT()
		
		      THISFORM.grouptran.lGroupTran = .F.
		      THISFORM.lchanged = .F.
		
		   CASE LOWER(m.cworkarea) = 'arpmtdet'
		      lcBatch = arpmtdet.cinvtoken
		      lcAmount = arpmtdet.namtapp
		      swselect('invhdr')
		      LOCATE FOR cbatch = lcBatch
		      IF FOUND('invhdr')
		         REPLACE npayments WITH npayments - lcAmount
		         REPLACE ninvbal WITH ninvbal + lcAmount
		      ENDIF
		
		ENDCASE
		
		SELECT (lnSelect)
		
		*!*	IF arpmthdr. > 0
		*!*	   THISFORM.omessage.DISPLAY('There was a credit invoice created by this payment.  Deleting this record will not remove this invoice.')
		*!*	ENDIF
		
		*!*	DODEFAULT(cworkarea)
		
	ENDPROC

	PROCEDURE cmdCustomer.Click
		LOCAL lcList
		PRIV llOK
		
		llOK = .T.
		
		SET SAFETY OFF
		
		DO CASE
		   CASE THISFORM.cType = 'AR'
		      lcList = 'ccustid,cCustName'
		      DO FORM ..\CUSTOM\picklist WITH 'custs', lcList, THISFORM.txtccustid.VALUE, 2
		
		   CASE THISFORM.cType = 'HG'
		      lcList = 'cOwnerID\Owner ID,cSortField\Owner Name'
		      
		      SELECT gasown.cOwnerID , investor.cSortField  ;
		         FROM gasown, investor  ;
		         INTO CURSOR temp READWRITE  ;
		         WHERE gasown.cOwnerID == investor.cOwnerID  ;
		         GROUP BY gasown.cOwnerID 
		
		      INDEX ON cOwnerID TAG cOwnerID
		      INDEX ON cSortField TAG cSortField
		
		      DO FORM ..\CUSTOM\picklist WITH 'temp', lcList, THISFORM.txtccustid.VALUE, 2,.T.,.T.
		
		   OTHERWISE
		      lcList = 'cOwnerID,cSortField'
		      DO FORM ..\CUSTOM\picklist WITH 'investor', lcList, THISFORM.txtccustid.VALUE, 2
		ENDCASE
		
		IF llOK
		   DO CASE
		      CASE THISFORM.cType = 'AR'
		         THISFORM.cmdatamanager.REPLACE('Arpmthdr','Ccustid',custs.cCustID)
		         THISFORM.txtccustid.REFRESH()
		         THISFORM.txtcCustName.VALUE = custs.cCustName
		         THISFORM.txtcCustName.REFRESH()
		      CASE THISFORM.cType = 'HG'
		         THISFORM.cmdatamanager.REPLACE('Arpmthdr','Ccustid',temp.cOwnerID)
		         THISFORM.txtccustid.REFRESH()
		         THISFORM.txtcCustName.VALUE = temp.cSortField
		         THISFORM.txtcCustName.REFRESH()
		      OTHERWISE
		         THISFORM.cmdatamanager.REPLACE('Arpmthdr','Ccustid',investor.cOwnerID)
		         THISFORM.txtccustid.REFRESH()
		         THISFORM.txtcCustName.VALUE = investor.cOwnName
		         THISFORM.txtcCustName.REFRESH()
		   ENDCASE
		   IF THISFORM.lNewBuild
		      swselect('arpmtdet')
		      DELETE FOR cBatch == arpmthdr.cBatch
		      THISFORM.requeryrecordsource()
		      THISFORM.calctot()
		   ENDIF
		
		ENDIF
		
		THISFORM.setnextcontrol(THISFORM.txtccustid)
		
	ENDPROC

	PROCEDURE cmdCustomer.When
		* Don't allow entry into this field when the
		* record is not a new record
		RETURN thisform.lNewBuild
	ENDPROC

	PROCEDURE grdarpmtdet.AfterRowColChange
		LPARAMETERS ncol
		
		if ncol <> 7 AND (INLIST(thisform.cType,'JIB','AR') AND nCol <> 4)
		   this.column7.txtnpayment.setfocus()
		endif   
		
		IF thisform.lChanged
		   thisform.calcapplied()
		ENDIF
		   
		RETURN (DODEFAULT(ncol))
		   
		
	ENDPROC

	PROCEDURE grdarpmtdet.Column1.Txtdate1.GotFocus
		dodefault()
	ENDPROC

	PROCEDURE grdarpmtdet.Column1.Txtdate1.When
		thisform.setnextcontrol(thisform.grdarpmtdet.column7.txtnpayment)
		RETURN .F.
	ENDPROC

	PROCEDURE grdarpmtdet.Column2.txtInvNum.When
		RETURN .F.
	ENDPROC

	PROCEDURE grdarpmtdet.Column3.txtnDiscAvail.When
		RETURN .F.
	ENDPROC

	PROCEDURE grdarpmtdet.Column4.txtnDiscTaken.When
		IF NOT INLIST(thisform.ctype,'JIB','AR')
		   RETURN .F.
		ENDIF
		
		DODEFAULT()
	ENDPROC

	PROCEDURE grdarpmtdet.Column5.txtnOrigTotal.When
		RETURN .F.
	ENDPROC

	PROCEDURE grdarpmtdet.Column6.txtnInvBal.When
		RETURN .F.
	ENDPROC

	PROCEDURE grdarpmtdet.Column7.txtnPayment.DblClick
		IF EMPTY(THIS.VALUE)
		   REPLACE arpmtdet.nAmtApp WITH arpmtdet.nInvBal - arpmtdet.nDisTaken
		ELSE
		   REPLACE arpmtdet.nAmtApp WITH 0
		ENDIF
		
		THIS.REFRESH()
		
		THISFORM.calctot()
		thisform.calcapplied()
	ENDPROC

	PROCEDURE grdarpmtdet.Column7.txtnPayment.KeyPress
		LPARAMETERS nkeycode,nshiftaltctrl
		
		if nkeycode = 13
		   keyboard '{dnarrow}'
		else
		   dodefault(nkeycode,nshiftaltctrl)   
		endif
		
	ENDPROC

	PROCEDURE opgDeposits.Init
		*this.value = 2
		
		dodefault()
		
	ENDPROC

	PROCEDURE opgDeposits.optDepositTo.Click
		thisform.cboAcct.set('enabled',.t.)
		
		DODEFAULT()
	ENDPROC

	PROCEDURE opgDeposits.optGroup.Click
		
		lnSelect = SELECT()
		swselect('glopt')
		IF NOT EMPTY(glopt.cundepfund)
		   swselect('coa')
		   SET ORDER TO acctno
		   SEEK(glopt.cundepfund)
		   IF lbankacct  &&  If it is a bank account
		      THISFORM.cboAcct.VALUE = glopt.cundepfund
		      THISFORM.cmdatamanager.REPLACE('Arpmthdr','Cacctno',glopt.cundepfund)
		      THISFORM.cboAcct.REFRESH()
		      THISFORM.cboAcct.afterchange()
		      thisform.cboAcct.set('enabled',.f.)
		   ELSE  &&  Not a bank account, so don't let them continue
		      THISFORM.oMessage.DISPLAY('Your undeposited funds account is not defined as a bank account.  This must be corrected before any deposits can be grouped.')
		      THIS.PARENT.VALUE = 2
		      THISFORM.cboAcct.LISTITEMID = 1
		      THISFORM.cboAcct.afterchange()
		   ENDIF
		ELSE
		   THISFORM.omessage.warning('The undeposited funds account is not defined in the G/L options. Deposits cannot be grouped.')
		   THISFORM.opgDeposits.VALUE = 2
		ENDIF
		
		SELECT(lnselect)
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtAcctDesc.When
		RETURN .F.    
	ENDPROC

	PROCEDURE txtCcustid.GotFocus
		ON KEY LABEL F2 _screen.activeform.cmdCustomer.Click()
		DODEFAULT()
	ENDPROC

	PROCEDURE txtCcustid.InteractiveChange
		IF DODEFAULT()
		   IF THISFORM.cType = 'AR'
		      swselect('custs')
		      LOCATE FOR cCustId == THIS.VALUE
		      IF FOUND()
		         THISFORM.txtcCustName.SET('value',custs.cCustname)
		      ELSE
		         THISFORM.txtcCustName.SET('value','')
		      ENDIF
		   ELSE
		      swselect('investor')
		      LOCATE FOR cOwnerID == THIS.VALUE
		      IF FOUND()
		         THISFORM.txtcCustName.SET('value',investor.cOwnName)
		      ELSE
		         THISFORM.txtcCustName.SET('value','')
		      ENDIF
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE txtCcustid.LostFocus
		IF THISFORM.lNewBuild
		   IF arpmthdr.ccustid <> THIS.VALUE
		      THISFORM.cmdatamanager.REPLACE('Arpmthdr','Ccustid',this.value)
		      swselect('arpmtdet')
		      DELETE FOR cBatch == arpmthdr.cBatch
		      THISFORM.requeryrecordsource()
		      THISFORM.calctot()
		   ENDIF
		ENDIF
		
		ON KEY LABEL F2 *
		RETURN (DODEFAULT())
		
	ENDPROC

	PROCEDURE txtCcustid.When
		*
		*  Don't allow entry in this field when we're just editing the record
		*
		thisform.cCustSave = this.value
		RETURN thisform.lNewBuild
	ENDPROC

	PROCEDURE txtcCustName.Init
		THISFORM.txtcCustid.VALID()
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtcCustName.When
		RETURN .F.
	ENDPROC

	PROCEDURE txtdRecDate.Click
		thisform.lAskAboutSuspense = .T.
		DODEFAULT()
	ENDPROC

	PROCEDURE txtdRecDate.Valid
		IF THISFORM.lnewbuild
		   * If the value is changed, re-calc the outstanding balances, b/c it may be affecting discounts available 
		   * Don't re-calc anything if it's not a new record - BH 09/24/2008
		   IF (THIS.VALUE <> arpmthdr.dRecDate AND THISFORM.cmdatamanager.isnew('arpmthdr')) OR THISFORM.lRefreshdata  
		      swselect('arpmthdr')
		      REPLACE dRecDate WITH THIS.VALUE  &&  Update date, so the discount calcs will work right
		      swselect('arpmtdet')
		      DELETE FOR cBatch == arpmthdr.cBatch
		      THISFORM.requeryrecordsource()
		      THISFORM.calctot()
		   ENDIF
		
		   THISFORM.lRefreshdata = .F.
		ENDIF
		DODEFAULT()
		
	ENDPROC

	PROCEDURE txtNapplied.When
		RETURN .F.
	ENDPROC

	PROCEDURE txtnBalance.When
		RETURN .F.
	ENDPROC

	PROCEDURE txtNpmtamt.GotFocus
		thisform.Oldpmtamt = this.Value  &&  Store, so we know whether it changes when the focus leaves this object
		
		DODEFAULT()
	ENDPROC

	PROCEDURE txtNpmtamt.LostFocus
		IF THIS.VALUE <> THISFORM.oldpmtamt
		   THISFORM.applypmts()
		ELSE
		   IF MESSAGEBOX('Do you want to automatically apply the payment?',36,'Apply Payment') = 6
		      THISFORM.applypmts()
		   ENDIF    
		ENDIF
		
		THISFORM.calcapplied()
		RETURN (DODEFAULT())
		
	ENDPROC

	PROCEDURE txtNunapp.When
		RETURN .F.
	ENDPROC

ENDDEFINE
