*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="swoldstuff.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS olddistproc AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\ampro\source\appdefs.h"
	*<DefinedPropArrayMethod>
		*m: addhist		&& Adds the current processing to the history files.
		*m: allnetcheck		&& Checks for all net wells and replaces jib runno with rev runno
		*m: buildnetjib		&& Builds a net jib invoice.
		*m: calcround
		*m: calcroundtot
		*m: calcsumbywell		&& Calculates a closing summary by well.
		*m: calcsummary		&& Calculates the closing summary
		*m: calcsuspbalance		&& Calculates Suspense Balances
		*m: calcsuspense		&& Calculates new suspense records.
		*m: checkactivity
		*m: checkbacktax		&& Checks for negative backup and tax withholding and makes corrections if any are found.
		*m: checkhist		&& Checks to see if the period is closed.
		*m: checkhistrun		&& Checks to see if a run no has been closed
		*m: checkquarterly		&& Check for quarterly wells.
		*m: checkquarterlyhist		&& Determines whether quarterly wells were processed for a given run.
		*m: closeproc		&& Closes the revenue period.
		*m: directdeposit		&& Creates the direct deposit file for owners who are direct deposited.
		*m: dp_checkdigit		&& Calculates check digit from bank aba
		*m: expenseupd		&& Marks the expenses as having been paid
		*m: fileio		&& Write low level file
		*m: getflatamt		&& Returns the given flat rate royalty amount.
		*m: gethist		&& Retrieves owner and well history records from closed periods.
		*m: getownflat
		*m: grossuptaxpct
		*m: intonhold
		*m: jibexp		&& Removes JIB portion of expense from an amount passed.
		*m: jibnet		&& Create net JIB invoices
		*m: main		&& Main Processing routine
		*m: netexp		&& Nets the passed expense to take into account "Dummy" owners.
		*m: netrev		&& Nets revenue or grosses revenue based upon directly paid owners.
		*m: netrunexp		&& Net closed expenses.
		*m: ownerchks		&& Create owner checks and places them in the check register to be printed.
		*m: ownerproc		&& Process Owners
		*m: ownerstub		&& Creates stub cursor for check stubs and stub report.
		*m: owner_suspense		&& Processing for suspense when deficits are netted between wells.
		*m: owntotal		&& Calculates the totals for each owner based upon the records in the invtmp table.
		*m: payout		&& Calculates Well Payout
		*m: postjourn		&& Posts the disbursement manager journal entries to the G/L Master file.
		*m: postsummary		&& Posts summary journal entries instead of detail.  This method is called if the postsummary.cfg file exists in the \ampro folder.
		*m: prechk		&& Prints the precheck register.
		*m: printsuspense		&& Prints suspense reports after closing summary
		*m: qbacctcheck		&& Check to make sure all specified QB accounts still exist in QB.
		*m: qberror		&& Handles QuickBooks Errors
		*m: qbpost		&& Posts journal entries to QuickBooks
		*m: qbpostoperator		&& Post operator/owner amounts to qb
		*m: qbpostvendcks		&& Post vendor checks to qb
		*m: qbpostvendop		&& Post vendor/operator amounts to qb
		*m: qbsynccheck		&& Check to see if data files need to be synchronized with QuickBooks
		*m: removeqb		&& Remove QB transactions created during closing
		*m: removetax		&& Removes taxes from well history for tax exempt owners.
		*m: removetaxexempt
		*m: roywork		&& Calculates the split between royalty and working owners for wellhist.
		*m: savesusp		&& Saves the suspense records in the suspense history file.
		*m: setup		&& Creates the work cursors for wells and owners.
		*m: suspcalc		&& Calculate the current suspense balance.
		*m: suspint		&& Look for interests on hold being released.
		*m: susp_by_owner		&& Suspense Processing By Owner
		*m: susp_by_well		&& Suspense Processing By Well
		*m: taxexempt
		*m: timekeeper
		*m: unallrpt		&& Unallocated Revenue and Expense Report
		*m: vendorchks		&& Creates vendor checks and places them in the check register to be printed.
		*m: wellproc		&& Process Wells
		*m: well_suspense		&& Processing for suspense when deficits are not netted among wells.
		*p: cacctprd		&& The accounting period associated with the accounting date passed.
		*p: cacctyear		&& The accounting year associated with the accounting date passed.
		*p: cbegownerid		&& Beginning Owner ID
		*p: cbegwellid		&& Beginning Well ID
		*p: cdeleted		&& Saves the deleted setting
		*p: cdmbatch		&& Disb Mgr Batch Number for the closing
		*p: cendownerid		&& Ending Owner ID
		*p: cendwellid		&& Ending Well ID
		*p: cexpclear		&& Expense Clearing Account
		*p: cgroup		&& The well group to process
		*p: companypost		&& Should only the company's share use the advanced posting date?
		*p: cperiod		&& Period to process
		*p: cprocess		&& Who called us.
		*p: crevclear		&& Revenue Clearing Account
		*p: crunyear		&& Run Year or Production Year
		*p: csysctlkey
		*p: cyear		&& production year to process
		*p: dacctdate		&& The accounting date associated with this production period
		*p: date1
		*p: date2
		*p: dexpdate		&& Date for processing expenses.
		*p: dpostdate
		*p: drevdate		&& Date for processing revenue
		*p: lclose		&& .T. if the period is being closed.
		*p: lcloserun
		*p: lcompressor		&& .T. if we're processing compressors
		*p: ldebug
		*p: lerrorflag		&& .T. = an error occurred in one of the methods.
		*p: lflatrates		&& Flat Rate Processing Flag.
		*p: lqbversion		&& .T. = this is the QuickBooks version
		*p: lquiet		&& Don't display progress bar when .T.
		*p: lrelmin		&& .T. if the minimums should be released.
		*p: lrelqtr		&& Quarterly Wells Released
		*p: lrunclosed
		*p: lsepclose		&& Close JIBs separately from Revenue
		*p: ndirectdeptotal
		*p: nprogress
		*p: nrunno		&& Run No Parameter
		*p: ogl		&& Glmaint object
		*p: omessage
		*p: oprogress
		*p: oregistry
		*p: orequest		&& QBFC Request Object
	*</DefinedPropArrayMethod>

	cbegownerid = ''		&& Beginning Owner ID
	cbegwellid = ''		&& Beginning Well ID
	cdmbatch = ''		&& Disb Mgr Batch Number for the closing
	cendownerid = ''		&& Ending Owner ID
	cendwellid = ''		&& Ending Well ID
	cexpclear = ''		&& Expense Clearing Account
	cgroup = '00'		&& The well group to process
	crevclear = ''		&& Revenue Clearing Account
	crunyear = ''		&& Run Year or Production Year
	csysctlkey = ''
	cyear = ''		&& production year to process
	dacctdate = .F.		&& The accounting date associated with this production period
	dexpdate = .F.		&& Date for processing expenses.
	drevdate = .F.		&& Date for processing revenue
	Height = 37
	Name = "olddistproc"
	omessage = .NULL.
	oregistry = .NULL.
	Width = 128
	
	PROCEDURE addhist		&& Adds the current processing to the history files.
		LOCAL lnMax, lnCount, lnX, oProgress
		
		STORE 0 TO lnMax, lnCount
		
		if this.lDebug
		   this.timekeeper('Starting addhist')  
		endif   
		
		IF this.lErrorFlag 
		   RETURN
		ENDIF
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Adding The Current Run Data to the History Files...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		   
		SELECT invtmp
		COUNT FOR NOT DELETED() AND ctypeinv <> 'S' AND cWellID <> 'ALL ' AND cTypeInv <> 'X' AND cTypeInv <> 'M' TO lnX
		lnMax = lnMax + lnX
		SELECT wellwork
		COUNT FOR NOT DELETED() TO lnX
		lnMax = lnMax + lnX
		
		IF NOT this.lQuiet
		   oProgress = this.oMessage.ProgressBar('Adding the current run data to the history files...')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		SELECT invtmp
		SET ORDER TO 0
		SCAN FOR NOT DELETED() AND ctypeinv <> 'S' AND cWellID <> 'ALL ' AND cTypeInv <> 'X' AND cTypeInv <> 'M'
		   lnCount = lnCount + 1
		   IF NOT this.lQuiet
		      oProgress.UpdateProgress(lnCount)
		   ENDIF
		   SCATTER MEMVAR
		   m.cAcctYr = this.cacctyear
		   m.cAcctPrd  = this.cacctprd
		   m.ciddisb = this.oRegistry.IncrementCounter('%Shared.Counters.Owner History')
		   SELECT disbhist1
		   SET DELETED OFF
		   SET ORDER TO ciddisb
		   DO WHILE SEEK(m.ciddisb)
		      m.ciddisb = this.oRegistry.IncrementCounter('%Shared.Counters.Owner History')
		   ENDDO   
		   INSERT INTO disbhist FROM MEMVAR
		   INSERT INTO ownpcts FROM MEMVAR
		   SET DELETED ON
		ENDSCAN
		SELECT wellwork
		SET ORDER TO 0
		SCAN FOR NOT DELETED()
		   lnCount = lnCount + 1
		   IF NOT this.lQuiet
		      oProgress.UpdateProgress(lnCount)
		   ENDIF
		   SCATTER MEMVAR
		   m.cAcctYr = this.cacctyear
		   m.cAcctPrd  = this.cacctprd
		   m.cidwhst = this.oRegistry.IncrementCounter('%Shared.Counters.Well History')
		   SELECT wellhist1
		   SET DELETED OFF
		   SET ORDER TO cidwhst
		   DO WHILE SEEK(m.cidwhst)
		      m.cidwhst = this.oRegistry.IncrementCounter('%Shared.Counters.Well History')
		   ENDDO   
		   INSERT INTO wellhist FROM MEMVAR
		   SET DELETED ON
		ENDSCAN
		IF NOT this.lQuiet
		   oProgress.CloseProgress()
		   DOEVENTS
		   RELE oProgress
		ENDIF
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Adding The Current Run Data to the History Files...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending addhist')  
		endif   
		
		
	ENDPROC

	PROCEDURE allnetcheck		&& Checks for all net wells and replaces jib runno with rev runno
		*
		*  Check to see if there are any JIB owners in a well.  
		*  If not, assume all owners are net and the expenses that fall into
		*  this run will never be processed in a JIB.  Change cRunYearJIB
		*  to '1900' and nRunNoJIB to match the revenue runno.
		*
		if this.lDebug
		   this.timekeeper('Starting allnetcheck')  
		endif   
		
		if THIS.lClose
		   * This message is not what's really going on, but I couldn't think of
		   * anything better to tell the user.
		   this.oProgress.SetProgressMessage('Removing JIB Expenses from Processing...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		sele wells
		scan for between(cwellid,this.cbegwellid,this.cendwellid)
		   m.cwellid = cwellid
		   sele wellinv
		   locate for cwellid == m.cwellid and ctypeinv = 'W' and ljib = .T.
		   if not found()
		      sele expense
		      scan for cwellid == m.cwellid and nrunnorev == this.nrunno and crunyearrev == this.crunyear and nrunnojib = 0
		          repl nrunnojib with this.nrunno, crunyearjib with '1900'
		      endscan
		   endif
		endscan          
		
		if THIS.lClose
		   * This message is not what's really going on, but I couldn't think of
		   * anything better to tell the user.
		   this.oProgress.SetProgressMessage('Removing JIB Expenses from Processing...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending allnetcheck')  
		endif   
		
		   
		
	ENDPROC

	PROCEDURE buildnetjib		&& Builds a net jib invoice.
		LOCAL lnJibInv, lcRevClear
		
		***************************************************************
		*  Placed return here so this method wouldn't run. pws 10/16/00
		*  Don't want to create net jibs anymore. Too many problems.
		*******
		RETURN
		*******
		
		****************************************************************
		*  Get the beginning JIB invoice number
		****************************************************************
		SELECT aropt
		GO TOP
		lnJIBInv = nJIBInv
		lcCashAcct = cCashAcct
		
		****************************************************************
		*  Get the revenue dist clear acct no
		****************************************************************
		SELECT glopt
		GO TOP
		lcRevClear = cRevClear
		
		SELECT invtotal
		SCAN FOR ntotalck >= 0
		   DELE NEXT 1
		ENDSCAN   
		
		SELECT invtotal
		COUNT FOR NOT DELETED() TO lnMax
		
		lnCount = 1
		
		IF NOT this.lQuiet
		   WAIT WIND NOWAIT 'Building the JIB Net Invoices...'
		ENDIF
		
		SELECT invtotal
		SCAN
		   SCATTER MEMVAR
		   lnCount = lnCount + 1
		   m.ntotalck   = ABS(m.ntotalck)
		   m.cBatch     = this.oregistry.incrementcounter('%Shared.Counters.Batch')
		   m.cinvnum   = 'JIB' + PADL(ALLTRIM(STR(lnJIBInv,6)),6,'0')
		   lnJIBInv    = lnJIBInv + 1
		
		   SELECT investor
		   SET ORDER TO cownerid
		   IF SEEK(m.cownerid)
		      IF lIntegGL OR investor.ldummy
		         * Don't create net jibs for integrated owners
		         LOOP
		      ENDIF   
		      m.cCustId   = m.cownerid
		      m.cCustName = cownname
		      m.cidTerm   = cidTerm
		      m.dInvDate  = this.dacctdate
		      m.dPostDate = this.dPostDate
		      m.nSalesTax = 0
		      m.nDiscTot  = 0
		      m.nSubTotal = m.ntotalck
		      m.npayments = 0
		      m.ninvtot   = m.ntotalck
		      m.ninvbal   = m.ntotalck
		      m.mshiprem  = ' '
		      m.nNetDueIn = 30
		      m.nDiscIn   = 0
		      m.nDiscPct  = 0
		      IF EMPTY(m.cidTerm)
		         SELECT terms
		         SCAN FOR lDefTerm
		            m.cidTerm   = cidTerm
		            m.nNetDueIn = nNetDueIn
		            m.nDiscIn   = nDiscIn
		            m.nDiscPct  = nDiscPct
		            EXIT
		         ENDSCAN
		      ELSE
		         m.nNetDueIn = 30
		         m.nDiscIn   = 0
		         m.nDiscPct  = 0
		      ENDIF
		      m.dDueDate   = m.dInvDate + m.nNetDueIn
		      m.dDiscDate  = m.dInvDate + m.nDiscIn
		      m.nDiscTot   = m.nInvTot * (m.nDiscPct/100)
		      m.cReference = 'JIB: ' + this.cRunYear+'/'+this.cPeriod
		      m.lPrinted   = .F.
		      m.cTaxCode   = ' '
		      m.cInvType   = 'J'
		      m.lPosted    = .F.
		      m.lDeleted   = .F.
		      m.lAging     = .F.
		      m.cProdYear  = this.cRunYear
		      m.cProdPrd   = this.cPeriod
		      m.cGroup     = this.cGroup
		      INSERT INTO invhdr FROM MEMVAR
		
		      lnWellTot = 0
		      *****************************************************************
		      *   Build the invoice detail line
		      *****************************************************************
		      jcInvestid = ' '
		      STORE 0 TO jnWorkInt, jnClass1, jnClass2, jnClass3, jnClass4, jnClass5
		      m.mmiscmemo   = ''
		      m.cperiod     = this.cPeriod
		      m.cyear       = this.cRunYear
		      m.ninvamt     = m.ntotalck
		      m.cidinvd    = this.oregistry.incrementcounter('%Shared.counters.Invoice Detail')
		      m.citemid    = 'ALL '
		      m.citemdesc  = 'Owner Net Deficit For Period: ' + this.cRunYear+'/'+this.cPeriod
		      m.nPrice     = m.ntotalck
		      m.nInterest  = 100.00
		      m.nQuantity  = 1
		      m.nExtension = m.ntotalck
		      m.nDiscPct   = 0
		      m.nDiscount  = 0
		      m.cUnitNo    = 'ALL'
		      m.cDeptNo    = ' '
		      m.cTaxable   = 'E'
		      m.cPriceCode = '1'
		      m.cMeasure   = ' '
		      m.lDeleted   = .F.
		      m.cacctno    = lcRevClear
		      m.cPayee = ' '
		      INSERT INTO invdet FROM MEMVAR
		   ENDIF
		ENDSCAN
		
		WAIT CLEAR
		
		
		****************************************************************
		*  Process amounts coming out of suspense as payments.
		****************************************************************
		SELECT susaudit
		SCAN FOR cyear=this.cRunYear AND cperiod=this.cPeriod AND caction = 'O' AND namount < 0
		   SCATTER MEMVAR
		   m.cCustId = m.cownerid
		   m.nNewAmt = ABS(m.namount)
		   m.nApplied    = m.nNewAmt  
		   m.cBatch = this.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		   lcBatch  = m.cBatch
		   m.cReference = 'Susp Pmt'
		   m.cacctno    = lccashacct
		   m.ndisctot   = 0
		   m.nunapp     = 0
		   m.ncustbalance = 0
		   m.npmtamt    = m.nNewAmt
		   m.cpmttype   = 'J'
		   m.drecdate   = this.dacctdate
		   m.cidchec    = ''
		   INSERT INTO arpmthdr FROM MEMVAR
		   
		   SELECT invhdr
		   SET ORDER TO duecust
		   SCAN FOR cCustId=m.cCustId AND nInvBal > 0
		      SCATTER MEMVAR
		      DO CASE
		         CASE m.nInvBal >= m.nNewAmt
		            m.nNewBal = m.nInvBal - m.nNewAmt
		            m.namtapp = m.nNewAmt
		            m.nNewAmt = 0
		            REPLACE nInvBal WITH m.nNewbal, ;
		                    nPayments WITH nPayments + m.nNewAmt
		         CASE m.nInvbal < m.nNewAmt
		            m.nNewAmt = m.nNewAmt - m.nInvBal
		            m.namtapp = m.nInvBal
		            REPLACE nInvBal WITH 0, ;
		                    nPayments WITH nInvTot
		      ENDCASE      
		      
		      m.cidarpmd = this.oRegistry.IncrementCounter('%Shared.Counters.AR Payment Detail')
		      STORE 0 TO m.ndisctot, m.ndistaken
		      m.cinvtoken = m.cbatch
		      m.cBatch    = lcBatch
		      m.cgroup    = ''
		      m.cprodprd  = ''
		      m.cprodyear = ''
		      m.cdesc     = ''
		      INSERT INTO arpmtdet FROM MEMVAR
		
		   ENDSCAN
		ENDSCAN      
		
		SELECT aropt
		GO TOP
		REPLACE nJIBInv WITH lnJibInv
		
		
		
	ENDPROC

	PROCEDURE calcround
		LPARA tlAll
		LOCAL llRoundHigh,lnMaxRound, lcOwnerID
		
		* If we're not closing, invtmp won't have all owners in it so
		* there's no use in trying to calculate rounding amounts
		IF NOT tlAll
		   RETURN
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Starting calcround')
		ENDIF
		
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Adjusting for Rounding...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		ENDIF
		
		llRoundHigh = options.lRoundHigh
		lnMaxRound = options.nMaxRound
		lcOwnerID  = ''
		m.cDMBatch = THIS.cDMBatch
		
		IF lnMaxRound = 0
		   lnMaxRound = 1.99
		ENDIF
		
		IF NOT USED('roundtmp')
		   USE roundtmp IN 0
		ENDIF
		
		CREATE CURSOR roundtmpx  ;
		   (cwellid    C(10),    ;
		   cDMBatch    C(8),     ;
		   lused       L,        ;
		   cWellName   C(40),    ;
		   cOwnerID    C(10),    ;
		   cOwnName    C(40),    ;
		   ngasrev     N(12,2),  ;
		   noilrev     N(12,2),  ;
		   ntrprev     N(12,2),  ;
		   nothrev     N(12,2),  ;
		   ncompress   N(12,2),  ;
		   ngather     N(12,2),  ;
		   nmktgexp    N(12,2),  ;
		   nmiscrev1   N(12,2),  ;
		   nmiscrev2   N(12,2),  ;
		   nexpense    N(12,2),  ;
		   ntotale1    N(12,2),  ;
		   ntotale2    N(12,2),  ;
		   ntotale3    N(12,2),  ;
		   ntotale4    N(12,2),  ;
		   ntotale5    N(12,2),  ;
		   ntotalea    N(12,2),  ;
		   ntotaleb    N(12,2),  ;
		   noiltax1    N(12,2),  ;
		   noiltax2    N(12,2),  ;
		   noiltax3    N(12,2),  ;
		   noiltax4    N(12,2),  ;
		   ngastax1    N(12,2),  ;
		   ngastax2    N(12,2),  ;
		   ngastax3    N(12,2),  ;
		   ngastax4    N(12,2),  ;
		   nothtax1    N(12,2),  ;
		   nothtax2    N(12,2),  ;
		   nothtax3    N(12,2),  ;
		   nothtax4    N(12,2))
		
		SELECT wellwork
		COUNT FOR NOT DELETED() TO lnMax
		lnCount = 1
		
		IF NOT THIS.lQuiet
		   oProgress = THIS.omessage.progressbarex('Calculating Rounding Amounts...','Processing Well: ')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		SELECT cwellid, ;
		   SUM(nGrossGas) AS nGrossGas, ;
		   SUM(nGrossOil) AS nGrossOil, ;
		   SUM(nTrpInc)   AS nTrpInc, ;
		   SUM(ncompress) AS ncompress, ;
		   SUM(ngather)   AS ngather, ;
		   SUM(ntotmktg)  AS ntotmktg, ;
		   SUM(nMiscInc1) AS nMiscInc1, ;
		   SUM(nMiscInc2) AS nMiscInc2, ;
		   SUM(nOthInc)   AS nOthInc, ;
		   SUM(nTotalE)   AS nNetExp, ;
		   SUM(nExpCl1)   AS nExpCl1, ;
		   SUM(nExpCL2)   AS nExpCL2, ;
		   SUM(nExpCL3)   AS nExpCL3, ;
		   SUM(nExpCL4)   AS nExpCL4, ;
		   SUM(nExpCL5)   AS nExpCL5, ;
		   SUM(nExpCLA)   AS nExpCLA, ;
		   SUM(nExpCLB)   AS nExpCLB, ;
		   SUM(nTotBBLTX1) AS nTotBBLTX1, ;
		   SUM(nTotBBLTX2) AS nTotBBLTX2, ;
		   SUM(nTotBBLTX3) AS nTotBBLTX3, ;
		   SUM(nTotBBLTX4) AS nTotBBLTX4, ;
		   SUM(nTotMCFTX1) AS nTotMCFTX1, ;
		   SUM(nTotMCFTX2) AS nTotMCFTX2, ;
		   SUM(nTotMCFTX3) AS nTotMCFTX3, ;
		   SUM(nTotMCFTX4) AS nTotMCFTX4, ;
		   SUM(nTotOthTX1) AS nTotOthTX1, ;
		   SUM(nTotOthTX2) AS nTotOthTX2, ;
		   SUM(nTotOthTX3) AS nTotOthTX3, ;
		   SUM(nTotOthTX4) AS nTotOthTX4 ;
		   FROM wellwork ;
		   INTO CURSOR wellwrk ;
		   ORDER BY cwellid ;
		   GROUP BY cwellid
		
		SELECT wellwrk
		SCAN
		   SCATTER MEMVAR
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      oProgress.SetProgressMessage('Processing Well: ' + m.cwellid)
		      lnCount = lnCount + 1
		   ENDIF
		*!*	   m.nTotBBLTX1 = THIS.netrev(m.cwellid,m.nTotBBLTX1,'O1',.F.,.T.) &&  Commented out per Phil's instructions - BH 8/25/06
		*!*	   m.nTotBBLTX2 = THIS.netrev(m.cwellid,m.nTotBBLTX2,'O2',.F.,.T.)
		*!*	   m.nTotBBLTX3 = THIS.netrev(m.cwellid,m.nTotBBLTX3,'O3',.F.,.T.)
		*!*	   m.nTotBBLTX4 = THIS.netrev(m.cwellid,m.nTotBBLTX4,'O4',.F.,.T.)
		*!*	   m.nTotMCFTX1 = THIS.netrev(m.cwellid,m.nTotMCFTX1,'G1',.F.,.T.)
		*!*	   m.nTotMCFTX2 = THIS.netrev(m.cwellid,m.nTotMCFTX2,'G2',.F.,.T.)
		*!*	   m.nTotMCFTX3 = THIS.netrev(m.cwellid,m.nTotMCFTX3,'G3',.F.,.T.)
		*!*	   m.nTotMCFTX4 = THIS.netrev(m.cwellid,m.nTotMCFTX4,'G4',.F.,.T.)
		*!*	   m.nTotOthTX1 = THIS.netrev(m.cwellid,m.nTotOthTX1,'P',.F.,.T.)
		*!*	   m.nTotOthTX2 = THIS.netrev(m.cwellid,m.nTotOthTX2,'P',.F.,.T.)
		*!*	   m.nTotOthTX3 = THIS.netrev(m.cwellid,m.nTotOthTX3,'P',.F.,.T.)
		*!*	   m.nTotOthTX4 = THIS.netrev(m.cwellid,m.nTotOthTX4,'P',.F.,.T.)
		
		   SELECT cwellid,  ;
		      SUM(ngasrev) AS ngasrev,  ;
		      SUM(noilrev) AS noilrev,  ;
		      SUM(ntrprev) AS ntrprev,  ;
		      SUM(nothrev) AS nothrev,  ;
		      SUM(ncompress) AS ncompress, ;
		      SUM(ngather)   AS ngather, ;
		      SUM(nmktgexp)  AS nmktgexp, ;
		      SUM(nmiscrev1) AS nmiscrev1,  ;
		      SUM(nmiscrev2) AS nmiscrev2,  ;
		      SUM(nexpense) AS nexpense,  ;
		      SUM(ntotale1) AS ntotale1,  ;
		      SUM(ntotale2) AS ntotale2,  ;
		      SUM(ntotale3) AS ntotale3,  ;
		      SUM(ntotale4) AS ntotale4,  ;
		      SUM(ntotale5) AS ntotale5,  ;
		      SUM(ntotalea) AS ntotalea,  ;
		      SUM(ntotaleb) AS ntotaleb,  ;
		      SUM(noiltax1) AS noiltax1,  ;
		      SUM(noiltax2) AS noiltax2,  ;
		      SUM(noiltax3) AS noiltax3,  ;
		      SUM(noiltax4) AS noiltax4,  ;
		      SUM(ngastax1) AS ngastax1,  ;
		      SUM(ngastax2) AS ngastax2,  ;
		      SUM(ngastax3) AS ngastax3,  ;
		      SUM(ngastax4) AS ngastax4,  ;
		      SUM(nothtax1) AS nothtax1,  ;
		      SUM(nothtax2) AS nothtax2,  ;
		      SUM(nothtax3) AS nothtax3,  ;
		      SUM(nothtax4) AS nothtax4   ;
		      FROM invtmp, investor  ;
		      WHERE cwellid = m.cwellid  ;
		      AND invtmp.cOwnerID = investor.cOwnerID ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR difftmp ;
		      ORDER BY cwellid ;
		      GROUP BY cwellid
		
		   IF _TALLY > 0
		      SELECT difftmp
		      SCAN
		         m.ngasrev = m.nGrossGas - ngasrev
		         m.noilrev = m.nGrossOil - noilrev
		         m.ntrprev = m.nTrpInc - ntrprev
		         m.ncompress = m.ncompress - ncompress
		         m.ngather   = m.ngather - ngather
		         m.nmktgexp  = m.ntotmktg - nmktgexp
		         m.nmiscrev1 = m.nMiscInc1 - nmiscrev1
		         m.nmiscrev2 = m.nMiscInc2 - nmiscrev2
		         m.nothrev  = m.nOthInc - nothrev
		         m.nexpense = m.nNetExp - nexpense
		         m.ntotale1 = m.nExpCl1 - ntotale1
		         m.ntotale2 = m.nExpCL2 - ntotale2
		         m.ntotale3 = m.nExpCL3 - ntotale3
		         m.ntotale4 = m.nExpCL4 - ntotale4
		         m.ntotale5 = m.nExpCL5 - ntotale5
		         m.ntotalea = m.nExpCLA - ntotalea
		         m.ntotaleb = m.nExpCLB - ntotaleb
		         m.noiltax1 = m.nTotBBLTX1 - noiltax1
		         m.noiltax2 = m.nTotBBLTX2 - noiltax2
		         m.noiltax3 = m.nTotBBLTX3 - noiltax3
		         m.noiltax4 = m.nTotBBLTX4 - noiltax4
		         m.ngastax1 = m.nTotMCFTX1 - ngastax1
		         m.ngastax2 = m.nTotMCFTX2 - ngastax2
		         m.ngastax3 = m.nTotMCFTX3 - ngastax3
		         m.ngastax4 = m.nTotMCFTX4 - ngastax4
		         m.nothtax1 = m.nTotOthTX1 - nothtax1
		         m.nothtax2 = m.nTotOthTX2 - nothtax2
		         m.nothtax3 = m.nTotOthTX3 - nothtax3
		         m.nothtax4 = m.nTotOthTX4 - nothtax4
		      ENDSCAN
		      STORE '' TO m.cWellName, m.cOwnName, m.cOwnerID
		      m.lused = .F.
		      INSERT INTO roundtmpx FROM MEMVAR
		   ENDIF
		
		ENDSCAN
		
		SELECT * FROM roundtmpx INTO CURSOR roundtmp1 WHERE (ngasrev <> 0)  ;
		   OR (noilrev <> 0)   OR (ntrprev <> 0)  ;
		   OR (nmiscrev1 <> 0) OR (nmiscrev2 <> 0)  ;
		   OR (nexpense <> 0)  OR (nothrev <> 0)  ;
		   OR (ncompress <> 0) OR (ngather <> 0)  ;
		   OR (ntotale1 <> 0)  OR (ntotale2 <> 0)  ;
		   OR (ntotale3 <> 0)  OR (ntotale4 <> 0)  ;
		   OR (ntotale5 <> 0)  OR (noiltax1 <> 0)  ;
		   OR (noiltax2 <> 0)  OR (noiltax3 <> 0)  ;
		   OR (noiltax4 <> 0)  OR (ngastax1 <> 0)  ;
		   OR (ngastax2 <> 0)  OR (ngastax3 <> 0)  ;
		   OR (ngastax4 <> 0)  OR (nothtax1 <> 0)  ;
		   OR (nothtax2 <> 0)  OR (nothtax3 <> 0)  ;
		   OR (nothtax4 <> 0)  OR (nmktgexp <> 0)  ;
		   OR (ntotalea <> 0)  OR (ntotaleb <> 0)
		
		
		SELECT * FROM roundtmp1 INTO CURSOR roundtmp2 WHERE (ABS(ngasrev) <= lnMaxRound)  ;
		   AND  (ABS(noilrev)  <= lnMaxRound) AND  (ABS(ntrprev)  <= lnMaxRound)  ;
		   AND  (ABS(nmiscrev1)<= lnMaxRound) AND  (ABS(nmiscrev2)<= lnMaxRound)  ;
		   AND  (ABS(ncompress)<= lnMaxRound) AND  (ABS(ngather)  <= lnMaxRound)  ;
		   AND  (ABS(nexpense) <= lnMaxRound) AND  (ABS(nothrev)  <= lnMaxRound)  ;
		   AND  (ABS(ntotale1) <= lnMaxRound) AND  (ABS(ntotale2) <= lnMaxRound)  ;
		   AND  (ABS(ntotale3) <= lnMaxRound) AND  (ABS(ntotale4) <= lnMaxRound)  ;
		   AND  (ABS(ntotale5) <= lnMaxRound) AND  (ABS(noiltax1) <= lnMaxRound)  ;
		   AND  (ABS(noiltax2) <= lnMaxRound) AND  (ABS(noiltax3) <= lnMaxRound)  ;
		   AND  (ABS(noiltax4) <= lnMaxRound) AND  (ABS(ngastax1) <= lnMaxRound)  ;
		   AND  (ABS(ngastax2) <= lnMaxRound) AND  (ABS(ngastax3) <= lnMaxRound)  ;
		   AND  (ABS(ngastax4) <= lnMaxRound) AND  (ABS(nothtax1) <= lnMaxRound)  ;
		   AND  (ABS(nothtax2) <= lnMaxRound) AND  (ABS(nothtax3) <= lnMaxRound)  ;
		   AND  (ABS(nothtax4) <= lnMaxRound) AND  (ABS(nmktgexp) <= lnMaxRound)  ;
		   AND  (ABS(ntotalea) <= lnMaxRound) AND  (ABS(ntotaleb) <= lnMaxRound)
		
		IF _TALLY > 0
		   SELECT roundtmp2
		   USE DBF('roundtmp2') AGAIN IN 0 ALIAS roundtmp3
		   SELECT roundtmp3
		   SCAN
		      SCATTER MEMVAR
		      SELECT wells
		      LOCATE FOR cwellid = roundtmp3.cwellid
		      IF FOUND('wells')
		         SCATTER FIELDS LIKE lSev* MEMVAR
		         IF EMPTY(wells.cOwnerID)  &&  No owner specified to adjust rounding to
		            IF llRoundHigh  &&  If rounding to highest owner
		               SELECT wellinv
		               SET ORDER TO cOwnerID DESC
		               LOCATE FOR cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND nworkint <> 0
		               IF FOUND('wellinv')
		                  lcOwnerID = wellinv.cOwnerID
		               ENDIF
		            ELSE  &&  Rounding to lowest owner
		               SELECT wellinv
		               SET ORDER TO cOwnerID
		               LOCATE FOR cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND nworkint <> 0
		               IF FOUND('wellinv')
		                  lcOwnerID = wellinv.cOwnerID
		               ENDIF
		            ENDIF
		         ELSE  &&  An owner is specified
		            lcOwnerID = wells.cOwnerID
		         ENDIF
		         REPLACE roundtmp3.cOwnerID WITH lcOwnerID
		
		
		         SELECT invtmp  &&  Only fill in rounding entries if there is already that kind of revenue/expense/tax present.  Otherwise, it can screw up reporting - BH 7/14/06
		
		         IF roundtmp3.ngasrev <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ngasrev <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (noilrev <> 0 OR ntrprev <> 0 OR nothrev <> 0 OR nmiscrev1 <> 0 OR nmiscrev2 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ngasrev WITH invtmp.ngasrev + roundtmp3.ngasrev
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.noilrev <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND noilrev <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ngasrev <> 0 OR ntrprev <> 0 OR nothrev <> 0 OR nmiscrev1 <> 0 OR nmiscrev2 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.noilrev WITH invtmp.noilrev + roundtmp3.noilrev
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ntrprev <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ntrprev <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ngasrev <> 0 OR noilrev <> 0 OR nothrev <> 0 OR nmiscrev1 <> 0 OR nmiscrev2 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ntrprev WITH invtmp.ntrprev + roundtmp3.ntrprev
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ncompress <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ncompress <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ngasrev <> 0 OR noilrev <> 0 OR nothrev <> 0 OR nmiscrev1 <> 0 OR nmiscrev2 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ncompress WITH invtmp.ncompress + roundtmp3.ncompress
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ngather <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ngather <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ngasrev <> 0 OR noilrev <> 0 OR nothrev <> 0 OR nmiscrev1 <> 0 OR nmiscrev2 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ngather WITH invtmp.ngather + roundtmp3.ngather
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.nmktgexp <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND nmktgexp <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ngasrev <> 0 OR noilrev <> 0 OR nothrev <> 0 OR nmiscrev1 <> 0 OR nmiscrev2 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.nmktgexp WITH invtmp.nmktgexp + roundtmp3.nmktgexp
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.nmiscrev1 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND nmiscrev1 <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ngasrev <> 0 OR noilrev <> 0 OR nothrev <> 0 OR ntrprev <> 0 OR nmiscrev2 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.nmiscrev1 WITH invtmp.nmiscrev1 + roundtmp3.nmiscrev1
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.nmiscrev2 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND nmiscrev2 <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ngasrev <> 0 OR noilrev <> 0 OR nothrev <> 0 OR ntrprev <> 0 OR nmiscrev1 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.nmiscrev2 WITH invtmp.nmiscrev2 + roundtmp3.nmiscrev2
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.nothrev <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND nothrev <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ngasrev <> 0 OR noilrev <> 0 OR ntrprev <> 0 OR nmiscrev1 <> 0 OR nmiscrev2 <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.nothrev WITH invtmp.nothrev + roundtmp3.nothrev
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		         
		         IF roundtmp3.nexpense <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND nexpense <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of expense
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (ntotale1 <> 0 OR ntotale2 <> 0 OR ntotale3 <> 0 OR ntotale4 <> 0 OR ntotale5 <> 0  ;
		                  OR ntotaleb <> 0 OR ntotalea <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.nexpense WITH invtmp.nexpense + roundtmp3.nexpense
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ntotale1 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ntotale1 <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of expense
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (nexpense <> 0 OR ntotale2 <> 0 OR ntotale3 <> 0 OR ntotale4 <> 0 OR ntotale5 <> 0  ;
		                  OR ntotaleb <> 0 OR ntotalea <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ntotale1 WITH invtmp.ntotale1 + roundtmp3.ntotale1
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ntotale2 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ntotale2 <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of expense
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (nexpense <> 0 OR ntotale1 <> 0 OR ntotale3 <> 0 OR ntotale4 <> 0 OR ntotale5 <> 0  ;
		                  OR ntotaleb <> 0 OR ntotalea <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ntotale2 WITH invtmp.ntotale2 + roundtmp3.ntotale2
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ntotale3 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ntotale3 <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of expense
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (nexpense <> 0 OR ntotale1 <> 0 OR ntotale2 <> 0 OR ntotale4 <> 0 OR ntotale5 <> 0  ;
		                  OR ntotaleb <> 0 OR ntotalea <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ntotale3 WITH invtmp.ntotale3 + roundtmp3.ntotale3
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ntotale4 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ntotale4 <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of expense
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (nexpense <> 0 OR ntotale1 <> 0 OR ntotale2 <> 0 OR ntotale3 <> 0 OR ntotale5 <> 0  ;
		                  OR ntotaleb <> 0 OR ntotalea <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ntotale4 WITH invtmp.ntotale4 + roundtmp3.ntotale4
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ntotale5 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ntotale5 <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of expense
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (nexpense <> 0 OR ntotale1 <> 0 OR ntotale2 <> 0 OR ntotale3 <> 0 OR ntotale4 <> 0  ;
		                  OR ntotaleb <> 0 OR ntotalea <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ntotale5 WITH invtmp.ntotale5 + roundtmp3.ntotale5
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ntotaleb <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ntotaleb <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of expense
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (nexpense <> 0 OR ntotale1 <> 0 OR ntotale2 <> 0 OR ntotale3 <> 0 OR ntotale4 <> 0  ;
		                  OR ntotale5 <> 0 OR ntotalea <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ntotaleb WITH invtmp.ntotaleb + roundtmp3.ntotaleb
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ntotalea <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ntotalea <> 0
		            IF NOT FOUND()  &&  Not found, so find a record with some type of expense
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'  ;
		                  AND (nexpense <> 0 OR ntotale1 <> 0 OR ntotale2 <> 0 OR ntotale3 <> 0 OR ntotale4 <> 0  ;
		                  OR ntotale5 <> 0 OR ntotaleb <> 0)
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ntotalea WITH invtmp.ntotalea + roundtmp3.ntotalea
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.noiltax1 <> 0 OR roundtmp3.noiltax2 <> 0 OR roundtmp3.noiltax3 <> 0 OR roundtmp3.noiltax4 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND (noiltax1 <> 0  ;
		               OR noiltax2 <> 0 OR noiltax3 <> 0 OR noiltax4 <> 0)
		            IF NOT FOUND()  &&  Not found, so find a record with the right kind of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND noilrev <> 0
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.noiltax1 WITH invtmp.noiltax1 + roundtmp3.noiltax1,  ;
		                  invtmp.noiltax2 WITH invtmp.noiltax2 + roundtmp3.noiltax2,  ;
		                  invtmp.noiltax3 WITH invtmp.noiltax3 + roundtmp3.noiltax3,  ;
		                  invtmp.noiltax4 WITH invtmp.noiltax4 + roundtmp3.noiltax4
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.ngastax1 <> 0 OR roundtmp3.ngastax2 <> 0 OR roundtmp3.ngastax3 <> 0 OR roundtmp3.ngastax4 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND (ngastax1 <> 0  ;
		               OR ngastax2 <> 0 OR ngastax3 <> 0 OR ngastax4 <> 0)
		            IF NOT FOUND()  &&  Not found, so find a record with the right kind of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND ngasrev <> 0
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.ngastax1 WITH invtmp.ngastax1 + roundtmp3.ngastax1,  ;
		                  invtmp.ngastax2 WITH invtmp.ngastax2 + roundtmp3.ngastax2,  ;
		                  invtmp.ngastax3 WITH invtmp.ngastax3 + roundtmp3.ngastax3,  ;
		                  invtmp.ngastax4 WITH invtmp.ngastax4 + roundtmp3.ngastax4
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         IF roundtmp3.nothtax1 <> 0 OR roundtmp3.nothtax2 <> 0 OR roundtmp3.nothtax3 <> 0 OR roundtmp3.nothtax4 <> 0  &&  Only do a replace if there is rounding present
		            LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND (nothtax1 <> 0  ;
		               OR nothtax2 <> 0 OR nothtax3 <> 0 OR nothtax4 <> 0)
		            IF NOT FOUND()  &&  Not found, so find a record with the right kind of revenue
		               LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W' AND nothrev <> 0
		               IF NOT FOUND()
		                  LOCATE FOR cOwnerID = lcOwnerID AND cwellid = roundtmp3.cwellid AND cTypeInv = 'W'
		               ENDIF
		            ENDIF
		            IF NOT EOF('invtmp')  &&  If not eof(), it found a record
		               REPLACE invtmp.nothtax1 WITH invtmp.nothtax1 + roundtmp3.nothtax1,  ;
		                  invtmp.nothtax2 WITH invtmp.nothtax2 + roundtmp3.nothtax2,  ;
		                  invtmp.nothtax3 WITH invtmp.nothtax3 + roundtmp3.nothtax3,  ;
		                  invtmp.nothtax4 WITH invtmp.nothtax4 + roundtmp3.nothtax4
		               THIS.CalcRoundTot()  &&  Update Totals with the changes
		            ENDIF
		         ENDIF
		
		         *!*	         IF FOUND('invtmp')  &&  If it doesn't find this owner and this well, somethings's screwy, and this well will have rounding.
		         *!*	            REPLACE invtmp.ngasrev WITH invtmp.ngasrev + roundtmp3.ngasrev,  ;
		         *!*	               invtmp.noilrev WITH invtmp.noilrev + roundtmp3.noilrev,  ;
		         *!*	               invtmp.ntrprev WITH invtmp.ntrprev + roundtmp3.ntrprev,  ;
		         *!*	               invtmp.ncompress WITH invtmp.ncompress + roundtmp3.ncompress, ;
		         *!*	               invtmp.ngather   WITH invtmp.ngather + roundtmp3.ngather, ;
		         *!*	               invtmp.nmktgexp  WITH invtmp.nmktgexp + roundtmp3.nmktgexp, ;
		         *!*	               invtmp.nmiscrev1 WITH invtmp.nmiscrev1 + roundtmp3.nmiscrev1,  ;
		         *!*	               invtmp.nmiscrev2 WITH invtmp.nmiscrev2 + roundtmp3.nmiscrev2,  ;
		         *!*	               invtmp.nothrev WITH invtmp.nothrev + roundtmp3.nothrev,  ;
		         *!*	               invtmp.nIncome WITH invtmp.nIncome+roundtmp3.ngasrev+roundtmp3.noilrev+  ;
		         *!*	               roundtmp3.ntrprev+roundtmp3.nmiscrev1+roundtmp3.nmiscrev2+roundtmp3.nothrev,  ;
		         *!*	               invtmp.nexpense WITH invtmp.nexpense + roundtmp3.nexpense,  ;
		         *!*	               invtmp.ntotale1 WITH invtmp.ntotale1 + roundtmp3.ntotale1,  ;
		         *!*	               invtmp.ntotale2 WITH invtmp.ntotale2 + roundtmp3.ntotale2,  ;
		         *!*	               invtmp.ntotale3 WITH invtmp.ntotale3 + roundtmp3.ntotale3,  ;
		         *!*	               invtmp.ntotale4 WITH invtmp.ntotale4 + roundtmp3.ntotale4,  ;
		         *!*	               invtmp.ntotale5 WITH invtmp.ntotale5 + roundtmp3.ntotale5,  ;
		         *!*	               invtmp.ntotaleA WITH invtmp.ntotaleA + roundtmp3.ntotaleA,  ;
		         *!*	               invtmp.ntotaleB WITH invtmp.ntotaleB + roundtmp3.ntotaleB,  ;
		         *!*	               invtmp.noiltax1 WITH invtmp.noiltax1 + roundtmp3.noiltax1,  ;
		         *!*	               invtmp.noiltax2 WITH invtmp.noiltax2 + roundtmp3.noiltax2,  ;
		         *!*	               invtmp.noiltax3 WITH invtmp.noiltax3 + roundtmp3.noiltax3,  ;
		         *!*	               invtmp.noiltax4 WITH invtmp.noiltax4 + roundtmp3.noiltax4,  ;
		         *!*	               invtmp.ngastax1 WITH invtmp.ngastax1 + roundtmp3.ngastax1,  ;
		         *!*	               invtmp.ngastax2 WITH invtmp.ngastax2 + roundtmp3.ngastax2,  ;
		         *!*	               invtmp.ngastax3 WITH invtmp.ngastax3 + roundtmp3.ngastax3,  ;
		         *!*	               invtmp.ngastax4 WITH invtmp.ngastax4 + roundtmp3.ngastax4,  ;
		         *!*	               invtmp.nothtax1 WITH invtmp.nothtax1 + roundtmp3.nothtax1,  ;
		         *!*	               invtmp.nothtax2 WITH invtmp.nothtax2 + roundtmp3.nothtax2,  ;
		         *!*	               invtmp.nothtax3 WITH invtmp.nothtax3 + roundtmp3.nothtax3,  ;
		         *!*	               invtmp.nothtax4 WITH invtmp.nothtax4 + roundtmp3.nothtax4,  ;
		         *!*	               invtmp.nSevTaxes WITH invtmp.nSevTaxes+roundtmp3.nothtax1+roundtmp3.nothtax2+  ;
		         *!*	               roundtmp3.nothtax3+roundtmp3.nothtax4+roundtmp3.noiltax1+roundtmp3.noiltax2 + ;
		         *!*	               roundtmp3.noiltax3+roundtmp3.noiltax4+roundtmp3.ngastax1+roundtmp3.ngastax2 + ;
		         *!*	               roundtmp3.ngastax3+roundtmp3.ngastax4
		         *!*
		         *!*	         ENDIF
		      ENDIF
		   ENDSCAN
		
		   SELECT roundtmp3
		   USE DBF('roundtmp3') AGAIN IN 0 ALIAS roundtmp4
		   SELECT roundtmp4
		   SCAN
		      SCATTER MEMVAR
		      SELECT wells
		      LOCATE FOR cwellid = roundtmp4.cwellid
		      IF FOUND('wells')
		         IF EMPTY(wells.cOwnerID)  &&  No owner specified to adjust rounding to
		            IF llRoundHigh  &&  If rounding to highest owner
		               SELECT wellinv
		               SET ORDER TO cOwnerID DESC
		               LOCATE FOR cwellid = roundtmp4.cwellid AND cTypeInv = 'W'
		               IF FOUND('wellinv')
		                  lcOwnerID = wellinv.cOwnerID
		               ENDIF
		            ELSE  &&  Rounding to lowest owner
		               SELECT wellinv
		               SET ORDER TO cOwnerID
		               LOCATE FOR cwellid = roundtmp4.cwellid AND cTypeInv = 'W'
		               IF FOUND('wellinv')
		                  lcOwnerID = wellinv.cOwnerID
		               ENDIF
		            ENDIF
		         ELSE  &&  An owner is specified
		            lcOwnerID = wells.cOwnerID
		         ENDIF
		         REPLACE roundtmp4.cOwnerID WITH lcOwnerID
		         REPLACE roundtmp4.cWellName WITH wells.cWellName
		
		         SELECT investor
		         LOCATE FOR cOwnerID = lcOwnerID
		         IF FOUND('Investor')
		            REPLACE roundtmp4.cOwnName WITH investor.cOwnName
		         ENDIF
		      ENDIF
		   ENDSCAN
		
		   IF THIS.lClose
		      SELECT roundtmp
		      APPEND FROM DBF('roundtmp4')
		   ENDIF
		
		ENDIF
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   DOEVENTS
		ENDIF
		
		IF USED('roundtmp1')
		   USE IN roundtmp1
		ENDIF
		IF USED('roundtmp2')
		   USE IN roundtmp2
		ENDIF
		IF USED('roundtmp3')
		   USE IN roundtmp3
		ENDIF
		IF USED('roundtmp4')
		   USE IN roundtmp4
		ENDIF
		
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Adjusting for Rounding...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Ending calcround')
		ENDIF
		
		
		
		
	ENDPROC

	PROCEDURE calcroundtot
		REPLACE invtmp.nIncome WITH invtmp.ngasrev+invtmp.noilrev+  ;
		   invtmp.ntrprev+invtmp.nmiscrev1+invtmp.nmiscrev2+invtmp.nothrev,  ;
		   invtmp.nSevTaxes WITH invtmp.nothtax1+invtmp.nothtax2+  ;
		   invtmp.nothtax3+invtmp.nothtax4+invtmp.noiltax1+invtmp.noiltax2 + ;
		   invtmp.noiltax3+invtmp.noiltax4+invtmp.ngastax1+invtmp.ngastax2 + ;
		   invtmp.ngastax3+invtmp.ngastax4,  ;
		   invtmp.nNetCheck WITH (invtmp.ngasrev + invtmp.noilrev +  ;
		   invtmp.ntrprev+invtmp.nmiscrev1+invtmp.nmiscrev2+invtmp.nothrev) - ;
		   (invtmp.nexpense+invtmp.ntotale1+invtmp.ntotale2+invtmp.ntotale3+invtmp.ntotale4+;
		   invtmp.ntotale5+invtmp.ntotalea+invtmp.ntotaleb) - (invtmp.nothtax1+invtmp.nothtax2+invtmp.nothtax3+invtmp.nothtax4+;
		   invtmp.ngastax1+invtmp.ngastax2+invtmp.ngastax3+invtmp.ngastax4+invtmp.noiltax1+invtmp.noiltax2+invtmp.noiltax3+invtmp.noiltax4) - ;
		   (invtmp.ncompress+invtmp.ngather+invtmp.nmktgexp+nbackwith+ntaxwith)
		
		IF cDirect = 'G' OR cdirect='B'  &&  If direct-pay gas, subtract that money from nnetcheck
		   REPLACE invtmp.nNetCheck WITH invtmp.nNetCheck - invtmp.ngasrev
		ENDIF
		IF cDirect = 'O' OR cdirect='B'  &&  If direct-pay oil, subtract that money from nnetcheck
		   REPLACE invtmp.nNetCheck WITH invtmp.nNetCheck - invtmp.noilrev
		ENDIF
		
		*!*	DO CASE
		*!*	   CASE cDirect = 'O'
		*!*	      IF NOT m.lSev1O
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax1
		*!*	      ENDIF
		*!*	      IF NOT m.lSev2O
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax2
		*!*	      ENDIF
		*!*	      IF NOT m.lSev3O
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax3
		*!*	      ENDIF
		*!*	      IF NOT m.lSev4O
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax4
		*!*	      ENDIF
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck + (invtmp.ngasrev + ;
		*!*	         invtmp.ntrprev+invtmp.nmiscrev1+invtmp.nmiscrev2+invtmp.nothrev) - ;
		*!*	         (invtmp.nexpense+invtmp.ntotale1+invtmp.ntotale2+invtmp.ntotale3+invtmp.ntotale4+;
		*!*	         invtmp.ntotale5+invtmp.ntotalea+invtmp.ntotaleb) - (invtmp.nothtax1+invtmp.nothtax2+invtmp.nothtax3+invtmp.nothtax4+;
		*!*	         invtmp.ngastax1+invtmp.ngastax2+invtmp.ngastax3+invtmp.ngastax4) - ;
		*!*	         (invtmp.ncompress+invtmp.ngather+invtmp.nmktgexp)
		
		*!*	   CASE cDirect = 'G'
		*!*	      IF NOT m.lSev1G
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax1
		*!*	      ENDIF
		*!*	      IF NOT m.lSev2G
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax2
		*!*	      ENDIF
		*!*	      IF NOT m.lSev3G
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax3
		*!*	      ENDIF
		*!*	      IF NOT m.lSev4G
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax4
		*!*	      ENDIF
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck + (invtmp.noilrev+  ;
		*!*	         invtmp.ntrprev+invtmp.nmiscrev1+invtmp.nmiscrev2+invtmp.nothrev) - ;
		*!*	         (invtmp.nexpense+invtmp.ntotale1+invtmp.ntotale2+invtmp.ntotale3+invtmp.ntotale4+;
		*!*	         invtmp.ntotale5+invtmp.ntotalea+invtmp.ntotaleb) - (invtmp.nothtax1+invtmp.nothtax2+invtmp.nothtax3+invtmp.nothtax4+;
		*!*	         invtmp.noiltax1+invtmp.noiltax2+invtmp.noiltax3+invtmp.noiltax4) - ;
		*!*	         (invtmp.ncompress+invtmp.ngather+invtmp.nmktgexp)
		
		*!*	   CASE cDirect = 'B'
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck + (invtmp.ntrprev+invtmp.nmiscrev1+invtmp.nmiscrev2+invtmp.nothrev) - ;
		*!*	         (invtmp.nexpense+invtmp.ntotale1+invtmp.ntotale2+invtmp.ntotale3+invtmp.ntotale4 + ;
		*!*	         invtmp.ntotale5+invtmp.ntotalea+invtmp.ntotaleb) - (invtmp.nothtax1+invtmp.nothtax2+invtmp.nothtax3+invtmp.nothtax4) - ;
		*!*	         (invtmp.ncompress+invtmp.ngather)
		*!*	      IF NOT m.lSev1O
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax1
		*!*	      ENDIF
		*!*	      IF NOT m.lSev2O
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax2
		*!*	      ENDIF
		*!*	      IF NOT m.lSev3O
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax3
		*!*	      ENDIF
		*!*	      IF NOT m.lSev4O
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax4
		*!*	      ENDIF
		*!*	      IF NOT m.lSev1G
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax1
		*!*	      ENDIF
		*!*	      IF NOT m.lSev2G
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax2
		*!*	      ENDIF
		*!*	      IF NOT m.lSev3G
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax3
		*!*	      ENDIF
		*!*	      IF NOT m.lSev4G
		*!*	         REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax4
		*!*	      ENDIF
		
		*!*	   CASE cDirect = 'N'
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax1
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax2
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax3
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.noiltax4
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax1
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax2
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax3
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck - roundtmp3.ngastax4
		*!*	      REPL invtmp.nNetCheck WITH invtmp.nNetCheck + (roundtmp3.ngasrev+roundtmp3.noilrev+  ;
		*!*	         roundtmp3.ntrprev+roundtmp3.nmiscrev1+roundtmp3.nmiscrev2+roundtmp3.nothrev) - ;
		*!*	         (roundtmp3.nexpense+roundtmp3.ntotale1+roundtmp3.ntotale2+roundtmp3.ntotale3+roundtmp3.ntotale4+;
		*!*	         roundtmp3.ntotale5+roundtmp3.ntotalea+roundtmp3.ntotaleb) - (roundtmp3.nothtax1+roundtmp3.nothtax2+roundtmp3.nothtax3+roundtmp3.nothtax4) - ;
		*!*	         (roundtmp3.ncompress+roundtmp3.ngather+roundtmp3.nmktgexp)
		*!*	ENDCASE
		
	ENDPROC

	PROCEDURE calcsumbywell		&& Calculates a closing summary by well.
		LPARA tlExceptions
		LOCAL lcYear, lcPeriod, lcGroup, lnRevEnt, lnExpEnt
		LOCAL lnRevAll, lnExpAll, lcTitle1, lcDMBatch, llSepClose
		LOCAL lnJIBAll, lnJibInv, lnJibInvAmt, llExceptions
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		lcYear   = THIS.cRunYear
		lcGroup  = THIS.cGroup
		lnRunNo  = THIS.nRunNo
		
		llExceptions = tlExceptions
		
		STORE 0 TO lnJIBAll, lnJibInv, lnJibInvAmt
		
		SELECT cWellID FROM wells WHERE cWellStat <> 'A' INTO CURSOR inactwell
		
		SELECT options
		GO TOP
		glGrpName  = lGrpName
		llSepClose = lSepClose
		IF glGrpName
		   SELECT groups
		   SET ORDER TO cGroup
		   IF SEEK(lcGroup)
		      m.cGrpName = cDesc
		   ELSE
		      IF lcGroup = '**'
		         m.cGrpName = 'All Companies'
		      ELSE
		         m.cGrpName = ''
		      ENDIF
		   ENDIF
		ELSE
		   m.cGrpName = ''
		ENDIF
		
		lcTitle1 = 'Revenue Closing Summary By Well'
		
		lcTitle2 = 'For Run No ' + ALLT(STR(lnRunNo)) +'/'+lcYear + ' Group ' + lcGroup
		
		IF TYPE('m.goApp') = 'O'
		   m.cProducer = m.goApp.cCompanyName
		ELSE
		   m.cProducer = 'Development Company'
		ENDIF
		
		m.cProcessor = ''
		
		
		*
		*  Builds the closing summary information
		*
		CREATE CURSOR tempclose ;
		   (cWellID        C(10), ;
		   cWellName      C(30), ;
		   nRevEntered    N(12,2), ;
		   nRevAllocated  N(12,2), ;
		   nExpEntered    N(12,2), ;
		   nExpAllocated  N(12,2), ;
		   nJExpAllocated N(12,2), ;
		   nSevTaxWell    N(9,2), ;
		   nSevTaxOwn     N(9,2))
		INDEX ON cWellID TAG cWellID
		
		CREATE CURSOR closetmp ;
		   (cWellID        C(10), ;
		   cWellName      C(30), ;
		   nRevEntered    N(12,2), ;
		   nRevAllocated  N(12,2), ;
		   nExpEntered    N(12,2), ;
		   nExpAllocated  N(12,2), ;
		   nJExpAllocated N(12,2), ;
		   nSevTaxWell    N(9,2), ;
		   nSevTaxOwn     N(9,2))
		INDEX ON cWellID TAG cWellID
		
		SELECT wells
		SET ORDER TO cWellID
		
		m.nRevEntered    = 0
		m.nRevAllocated  = 0
		m.nExpEntered    = 0
		m.nExpAllocated  = 0
		m.nSevTaxWell    = 0
		m.nSevTaxOwn     = 0
		m.nJExpAllocated = 0
		
		lnRevEnt = 0
		
		
		*  Get the revenue and expenses entered
		WAIT WIND NOWAIT 'Summing revenue entered...'
		SELECT income
		SET ORDER TO 0
		SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear
		   SCATTER MEMVAR
		   SELECT wells
		   IF SEEK(m.cWellID) AND cGroup = lcGroup AND nProcess <> 2
		      *!*	      IF wells.cWellStat <> 'A'
		      *!*	         LOOP
		      *!*	      ENDIF
		      m.cWellName = cWellName
		      DO CASE
		         CASE m.cSource = 'BBL'
		            m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'O',.F.,.T.,.F.,m.cownerid)
		         CASE m.cSource = 'MCF'
		            m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'G',.F.,.T.,.F.,m.cownerid)
		         CASE m.cSource = 'TRANS'
		            m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'T',.F.,.T.,.F.,m.cownerid)
		         CASE m.cSource = 'MISC1'
		            m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'1',.F.,.T.,.F.,m.cownerid)
		         CASE m.cSource = 'MISC2'
		            m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'2',.F.,.T.,.F.,m.cownerid)
		         CASE m.cSource = 'OTH'
		            m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'P',.F.,.T.,.F.,m.cownerid)
		         OTHERWISE
		            IF NOT 'TAX' $ m.cSource
		               m.nRevEntered = m.nTotalInc
		            ELSE
		               LOOP
		            ENDIF
		      ENDCASE
		
		      INSERT INTO closetmp FROM MEMVAR
		   ENDIF
		ENDSCAN
		
		*  Get the revenue and expenses entered for quarterly wells
		IF THIS.lRelQtr
		   SELECT income
		   SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear
		      SCATTER MEMVAR
		      SELECT wells
		      IF SEEK(m.cWellID) AND cGroup == lcGroup AND nProcess = 2
		         *!*	         IF wells.cWellStat <> 'A'
		         *!*	            LOOP
		         *!*	         ENDIF
		         m.cWellName = cWellName
		         DO CASE
		            CASE m.cSource = 'BBL'
		               m.nRevEntered = THIS.w(m.cWellID, m.nTotalInc,'O',.F.,.T.,.F.,m.cownerid)
		            CASE m.cSource = 'MCF'
		               m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'G',.F.,.T.,.F.,m.cownerid)
		            CASE m.cSource = 'MISC1'
		               m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'1',.F.,.T.,.F.,m.cownerid)
		            CASE m.cSource = 'MISC2'
		               m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'2',.F.,.T.,.F.,m.cownerid)
		            CASE m.cSource = 'TRANS'
		               m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'T',.F.,.T.,.F.,m.cownerid)
		            CASE m.cSource = 'OTH'
		               m.nRevEntered = THIS.netrev(m.cWellID, m.nTotalInc,'P',.F.,.T.,.F.,m.cownerid)
		            OTHERWISE
		               IF NOT 'TAX' $ m.cSource
		                  m.nRevEntered = m.nTotalInc
		               ELSE
		                  LOOP
		               ENDIF
		         ENDCASE
		         INSERT INTO closetmp FROM MEMVAR
		      ENDIF
		   ENDSCAN
		ENDIF
		
		sele cwellid from wellhist where nrunno = lnrunno and crunyear = lcyear into cursor tempwell order by cwellid group by cwellid
		
		if _tally > 0
		   sele tempwell
		   scan
		      m.nreventered = 0
		      m.cwellid = cwellid
		      * Add in flat rates paid out
		      sele wellhist
		      scan for nrunno = lnRunNo and cRunYear = lcYear and cwellid == m.cwellid 
		         m.nRevEntered = m.nRevEntered + nflatgas + nflatoil
		      endscan
		      sele closetmp
		      locate for cwellid = m.cwellid
		      if not found()
		         insert into closetmp from memvar
		      endif   
		   endscan
		endif   
		      
		lnExpEnt = 0
		m.nRevEntered    = 0
		m.nRevAllocated  = 0
		m.nExpEntered    = 0
		m.nExpAllocated  = 0
		m.nSevTaxWell    = 0
		m.nSevTaxOwn     = 0
		m.nJExpAllocated = 0
		
		WAIT WIND NOWAIT 'Summing expenses entered...'
		SELECT expense
		SET ORDER TO cWellID
		SCAN FOR (nRunNoRev = lnRunNo AND cRunYearRev = lcYear) OR (nRunnoJIB = lnRunNo AND cRunYearJIB = lcYear AND cRunYearRev = '1900')
		   SCATTER MEMVAR
		   lnExpEnt = 0
		   m.nRevEntered    = 0
		   m.nRevAllocated  = 0
		   m.nExpEntered    = 0
		   m.nExpAllocated  = 0
		   m.nSevTaxWell    = 0
		   m.nSevTaxOwn     = 0
		   m.nJExpAllocated = 0
		
		   SELECT wells
		   IF SEEK(m.cWellID) AND cGroup = lcGroup AND nProcess <> 2
		      *!*	      IF wells.cWellStat <> 'A'
		      *!*	         LOOP
		      *!*	      ENDIF
		      m.cWellName = cWellName
		      IF NOT EMPTY(m.cownerid)
		         SELECT investor
		         LOCATE FOR cownerid == m.cownerid  &&  If it's been allocated to the dummy, ignore it
		         IF FOUND() AND NOT investor.ldummy
		            SELE wellinv
		            LOCATE FOR cownerid = m.cownerid AND cWellID = m.cWellID AND ctypeinv = 'W'
		            IF FOUND() AND lJIB
		               IF llSepClose
		                  m.nJExpAllocated = m.nAmount
		               ENDIF
		            else
		               m.nExpEntered = m.nAmount
		            endif      
		         ENDIF
		      ELSE
		         IF m.cCatCode = 'MKTG'
		            m.nExpEntered = THIS.netrev(m.cWellID, m.nAmount, 'G', .F., .T., .T.)
		         ELSE
		            m.nExpEntered = swNetExp(m.nAmount, m.cWellID, .T., m.cexpclass,'B')
		*!*	            m.nJExpAllocated = swNetExp(m.nAmount, m.cWellID, .T., m.cexpclass,'J')
		         ENDIF
		      ENDIF
		      INSERT INTO closetmp FROM MEMVAR
		   ENDIF
		   SELECT expense
		ENDSCAN
		
		IF THIS.lRelQtr
		   SELECT expense
		   SCAN FOR (nRunNoRev = lnRunNo AND cRunYearRev = lcYear) OR (nRunnoJIB = lnRunNo AND cRunYearJIB = lcYear AND cRunYearRev = '1900')
		      SCATTER MEMVAR
		      SELECT wells
		      IF SEEK(m.cWellID) AND cGroup = lcGroup AND nProcess = 2
		         IF NOT EMPTY(m.cownerid)
		            SELECT investor
		            LOCATE FOR cownerid == m.cownerid  &&  If it's been allocated to the dummy, ignore it
		            IF FOUND() AND NOT investor.ldummy
		               SELE wellinv
		               LOCATE FOR cownerid = m.cownerid AND cWellID = m.cWellID AND ctypeinv = 'W'
		               IF FOUND() AND lJIB
		                  IF llSepClose
		                     m.nJExpAllocated = m.nAmount
		                  ENDIF
		               else
		                  m.nExpEntered = m.nAmount
		               endif      
		            ENDIF
		
		            m.cWellName = cWellName
		            IF llSepClose
		               m.nExpEntered = swNetExp(m.nAmount, m.cWellID, .T., m.cexpclass,'N')
		            ELSE
		               lnAmount = m.nAmount
		               m.nExpEntered = swNetExp(lnAmount, m.cWellID, .T., m.cexpclass,'B')
		            ENDIF
		            INSERT INTO closetmp FROM MEMVAR
		         ENDIF
		         SELECT expense
		      ENDIF
		   ENDSCAN
		ENDIF
		
		*  Get the revenue and expenses allocated
		lnRevAll = 0
		lnExpAll = 0
		lnSevTaxOwn = 0
		m.nRevEntered    = 0
		m.nRevAllocated  = 0
		m.nExpEntered    = 0
		m.nExpAllocated  = 0
		m.nSevTaxWell    = 0
		m.nSevTaxOwn     = 0
		m.nJExpAllocated = 0
		
		WAIT WIND NOWAIT 'Summing revenue and expenses allocated to owners...'
		SELECT disbhist
		SET ORDER TO 0
		SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear AND cRecType = 'R'
		   SCATTER MEMVAR
		   m.cownerid = cownerid
		   m.lExempt = .F.
		   SELECT investor
		   SET ORDER TO cownerid
		   IF SEEK(m.cownerid)
		      m.lExempt = lExempt
		      IF investor.ldummy
		         LOOP
		      ENDIF
		   ENDIF
		   SELECT wells
		   IF SEEK(m.cWellID)
		      *!*	      IF cWellStat <> 'A'
		      *!*	         LOOP
		      *!*	      ENDIF
		      m.ldiroilpurch = ldiroilpurch
		      m.ldirgaspurch = ldirgaspurch
		      m.lSev1O = lSev1O
		      m.lSev2O = lSev2O
		      m.lSev3O = lSev3O
		      m.lSev4O = lSev4O
		      m.lSev1G = lSev1G
		      m.lSev2G = lSev2G
		      m.lSev3G = lSev3G
		      m.lSev4G = lSev4G
		      m.lSev1P = lSev1P
		      m.lSev2P = lSev2P
		      m.lSev3P = lSev3P
		      m.lSev4P = lSev4P
		      m.cWellName = cWellName
		   ENDIF
		   lnIncome = m.nIncome
		   lnIncome = lnIncome - IIF(m.cdirect='O',m.noilrev,0)
		   lnIncome = lnIncome - IIF(m.cdirect='G',m.ngasrev,0)
		   lnIncome = lnIncome - IIF(m.cdirect='B',m.noilrev+m.ngasrev,0)
		   m.nRevAllocated = lnIncome + m.nFlatRate
		   m.nExpAllocated = m.nExpense + m.nTotale1 + m.nTotale2 + m.nTotale3 + m.nTotale4 + m.nTotale5 + m.nTotaleA + m.nTotaleB + m.nMKTGExp
		
		   IF .F.  && m.lexempt
		      m.nSevTaxOwn = 0
		   ELSE
		      DO CASE
		         CASE m.cdirect = 'O' OR m.cdirect = 'B'
		            IF m.ldiroilpurch
		               m.nSevTaxOwn = m.nGasTax1+m.nGasTax2+m.nGasTax3+m.nGasTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		            ELSE
		               m.nSevTaxOwn = m.nOilTax1+m.nOilTax2+m.nOilTax3+m.nOilTax4+m.nGasTax1+m.nGasTax2+m.nGasTax3+m.nGasTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		            ENDIF
		         CASE m.cdirect = 'G' OR m.cdirect = 'B'
		            IF m.ldirgaspurch
		               m.nSevTaxOwn = m.nOilTax1+m.nOilTax2+m.nOilTax3+m.nOilTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		            ELSE
		               m.nSevTaxOwn = m.nOilTax1+m.nOilTax2+m.nOilTax3+m.nOilTax4+m.nGasTax1+m.nGasTax2+m.nGasTax3+m.nGasTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		            ENDIF
		         CASE m.cdirect = 'N'
		            m.nSevTaxOwn = m.nOilTax1+m.nOilTax2+m.nOilTax3+m.nOilTax4+m.nGasTax1+m.nGasTax2+m.nGasTax3+m.nGasTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		      ENDCASE
		   ENDIF
		
		   *   m.nSevTaxOwn = m.nSevTaxes
		   INSERT INTO closetmp FROM MEMVAR
		   SELECT expense
		ENDSCAN
		
		m.nRevEntered    = 0
		m.nRevAllocated  = 0
		m.nExpEntered    = 0
		m.nExpAllocated  = 0
		m.nSevTaxWell    = 0
		m.nSevTaxOwn     = 0
		m.nJExpAllocated = 0
		
		IF NOT llSepClose
		   * Get the JIB expenses allocated
		   SELECT disbhist
		   SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear AND cRecType = 'J'
		      SCATTER MEMVAR
		      SELECT wells
		      IF SEEK(m.cWellID)
		         m.cWellName = cWellName
		      ENDIF
		      *  Net out "Dummy" owners
		      SELECT investor
		      SET ORDER TO cownerid
		      IF SEEK(m.cownerid) AND investor.ldummy
		         LOOP
		      ENDIF
		      SELECT wells
		      IF SEEK(m.cWellID)
		         *!*	         IF cWellStat <> 'A'
		         *!*	            LOOP
		         *!*	         ENDIF
		         m.cWellName = cWellName
		      ENDIF
		      m.nJExpAllocated = m.nExpense + m.nTotale1 + m.nTotale2 + m.nTotale3 + m.nTotale4 + m.nTotale5
		      INSERT INTO closetmp FROM MEMVAR
		   ENDSCAN
		
		ENDIF
		
		m.nRevEntered    = 0
		m.nRevAllocated  = 0
		m.nExpEntered    = 0
		m.nExpAllocated  = 0
		m.nSevTaxWell    = 0
		m.nSevTaxOwn     = 0
		m.nJExpAllocated = 0
		
		*  Get the severance taxes allocated to the well
		WAIT WIND NOWAIT 'Summing severance taxes charged to the wells...'
		lnSevTaxWell = 0
		SELECT wellhist
		SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear AND cGroup = lcGroup AND cRecType = 'R'
		   SCATTER MEMVAR
		   SELECT wells
		   SET ORDER TO cWellID
		   IF SEEK(m.cWellID)
		      *!*	      IF wells.cwellstat <> 'A'
		      *!*	         LOOP
		      *!*	      ENDIF
		      m.lSev1O = lSev1O
		      m.lSev2O = lSev2O
		      m.lSev3O = lSev3O
		      m.lSev4O = lSev4O
		      m.lSev1G = lSev1G
		      m.lSev2G = lSev2G
		      m.lSev3G = lSev3G
		      m.lSev4G = lSev4G
		      m.lSev1P = lSev1P
		      m.lSev2P = lSev2P
		      m.lSev3P = lSev3P
		      m.lSev4P = lSev4P
		      m.ldiroilpurch = ldiroilpurch
		      m.ldirgaspurch = ldirgaspurch
		      STORE 0 TO lnOTax1, lnOTax2, lnOTax3,lnOTax4, lnGTax1, lnGTax2, lnGTax3, lnGTax4,  ;
		         lnPTax1, lnPTax2, lnPTax3, lnPTax4
		
		      SELECT income  &&  Total up the one-man tax entries, so they can be subtracted off before doing the netrev
		      SCAN FOR cWellID == m.cWellID AND nRunNo = m.nRunNo AND cRunYear = m.cRunYear  ;
		            AND cyear+cPeriod = m.hYear+m.hPeriod AND 'TAX' $ csource AND NOT EMPTY(cOwnerID)
		         DO CASE
		            CASE csource = 'OTAX1'
		               lnOTax1 = lnOTax2 + nTotalInc
		            CASE csource = 'OTAX2'
		               lnOTax2 = lnOTax2 + nTotalInc
		            CASE csource = 'OTAX3'
		               lnOTax3 = lnOTax3 + nTotalInc
		            CASE csource = 'OTAX4'
		               lnOTax4 = lnOTax4 + nTotalInc
		            CASE csource = 'GTAX1'
		               lnGTax1 = lnGTax1 + nTotalInc
		            CASE csource = 'GTAX2'
		               lnGTax2 = lnGTax2 + nTotalInc
		            CASE csource = 'GTAX3'
		               lnGTax3 = lnGTax3 + nTotalInc
		            CASE csource = 'GTAX4'
		               lnGTax4 = lnGTax4 + nTotalInc
		            CASE csource = 'PTAX1'
		               lnPTax1 = lnPTax1 + nTotalInc
		            CASE csource = 'PTAX2'
		               lnPTax2 = lnPTax2 + nTotalInc
		            CASE csource = 'PTAX3'
		               lnPTax3 = lnPTax3 + nTotalInc
		            CASE csource = 'PTAX4'
		               lnPTax4 = lnPTax4 + nTotalInc
		         ENDCASE
		      ENDSCAN
		
		      lnOTax1 = lnOTax1*-1  &&  Since the numbers in the income table for taxes are negative, switch the sign before the netrev step
		      lnOTax2 = lnOTax2*-1
		      lnOTax3 = lnOTax3*-1
		      lnOTax4 = lnOTax4*-1
		      lnGTax1 = lnGTax1*-1
		      lnGTax2 = lnGTax2*-1
		      lnGTax3 = lnGTax3*-1
		      lnGTax4 = lnGTax4*-1
		      lnPTax1 = lnPTax1*-1
		      lnPTax2 = lnPTax2*-1
		      lnPTax3 = lnPTax3*-1
		      lnPTax4 = lnPTax4*-1
		
		      IF m.lSev1O OR m.lDirOilPurch
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngBBLTax1-lnOTax1,'O1',.F.,.T.,.F.,.F.,.T.) + lnOTax1
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotBBLTx1-lnOTax1,'O1',.F.,.T.,.T.) + lnOTax1
		      ENDIF
		      IF m.lSev2O OR m.lDirOilPurch
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngBBLTax2-lnOTax2,'O2',.F.,.T.,.F.,.F.,.T.) + lnOTax2
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotBBLTx2-lnOTax2,'O2',.F.,.T.,.T.) + lnOTax2
		      ENDIF
		      IF m.lSev3O OR m.lDirOilPurch
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngBBLTax3-lnOTax3,'O3',.F.,.T.,.F.,.F.,.T.) + lnOTax3
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotBBLTx3-lnOTax3,'O3',.F.,.T.,.T.) + lnOTax3
		      ENDIF
		      IF m.lSev4O OR m.lDirOilPurch
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngBBLTax4-lnOTax4,'O4',.F.,.T.,.F.,.F.,.T.) + lnOTax4
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotBBLTx4-lnOTax4,'O4',.F.,.T.,.T.) + lnOTax4
		      ENDIF
		      IF m.lSev1G OR m.lDirGasPurch
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngMCFTax1-lnGTax1,'G1',.F.,.T.,.F.,.F.,.T.) +lnGTax1
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotMCFTx1-lnGTax1,'G1',.F.,.T.,.T.) + lnGTax1
		      ENDIF
		      IF m.lSev2G OR m.lDirGasPurch
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngMCFTax2-lnGTax2,'G2',.F.,.T.,.F.,.F.,.T.) + lnGTax2
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotMCFTx2-lnGTax2,'G2',.F.,.T.,.T.) + lnGTax2
		      ENDIF
		      IF m.lSev3G OR m.lDirGasPurch
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngMCFTax3-lnGTax3,'G3',.F.,.T.,.F.,.F.,.T.) + lnGTax3
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotMCFTx3-lnGTax3,'G3',.F.,.T.,.T.) + lnGTax3
		      ENDIF
		      IF m.lSev4G OR m.lDirGasPurch
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngMCFTax4-lnGTax4,'G4',.F.,.T.,.F.,.F.,.T.) + lnGTax4
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotMCFTx4-lnGTax4,'G4',.F.,.T.,.T.) + lnGTax4
		      ENDIF
		      IF m.lSev1P
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngOTHTax1-lnPTax1,'P',.F.,.T.,.F.,.F.,.T.) + lnPTax1
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotOthTx1-lnPTax1,'P',.F.,.T.,.T.) + lnPTax1
		      ENDIF
		      IF m.lSev2P
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngOTHTax2-lnPTax2,'P',.F.,.T.,.F.,.F.,.T.) + lnPTax2
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotOthTx2-lnPTax2,'P',.F.,.T.,.T.) + lnPTax2
		      ENDIF
		      IF m.lSev3P
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngOTHTax3-lnPTax3,'P',.F.,.T.,.F.,.F.,.T.) + lnPTax3
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotOthTx3-lnPTax3,'P',.F.,.T.,.T.) + lnPTax3
		      ENDIF
		      IF m.lSev4P
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.ngOTHTax4-lnPTax4,'P',.F.,.T.,.F.,.F.,.T.) + lnPTax4
		      ELSE
		         lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotOthTx4-lnPTax4,'P',.F.,.T.,.T.) + lnPTax4
		      ENDIF
		      lnSevTaxWell = lnSevTaxWell + m.nTotBBLTxr + m.nTotMCFTxr + m.nTotBBLTxw + m.nTotMCFTxw
		   ENDIF
		   m.nSevTaxWell = lnSevTaxWell
		   INSERT INTO closetmp FROM MEMVAR
		   lnSevTaxWell = 0
		ENDSCAN
		
		SELECT closetmp.cWellID, wells.cWellName, ;
		   SUM(nRevEntered) AS nRevEntered, ;
		   SUM(nRevAllocated) AS nRevAllocated, ;
		   SUM(nExpEntered) AS nExpEntered, ;
		   SUM(nExpAllocated) AS nExpAllocated, ;
		   SUM(nSevTaxWell) AS nSevTaxWell, ;
		   SUM(nSevTaxOwn)  AS nSevTaxOwn, ;
		   SUM(nJExpAllocated) AS nJExpAllocated ;
		   FROM closetmp, wells ;
		   WHERE closetmp.cWellID = wells.cWellID ;
		   INTO CURSOR temp ;
		   ORDER BY closetmp.cWellID ;
		   GROUP BY closetmp.cWellID
		
		IF llExceptions
		   SELECT temp
		   SCAN
		      SCATTER MEMVAR
		      IF m.nRevEntered - m.nRevAllocated <= .50 AND m.nRevEntered - m.nRevAllocated >= -.50
		         IF m.nExpEntered - m.nExpAllocated - m.nJExpAllocated <= .50 AND m.nExpEntered - m.nExpAllocated -  m.nJExpAllocated >= -.50
		            IF m.nSevTaxWell - m.nSevTaxOwn <= .50 AND m.nSevTaxWell - m.nSevTaxOwn >= -.50
		               LOOP
		            ENDIF
		         ENDIF
		      ENDIF
		      INSERT INTO tempclose FROM MEMVAR
		   ENDSCAN
		ELSE
		   SELECT temp
		   SCAN
		      SCATTER MEMVAR
		      IF m.nRevEntered = 0 AND m.nExpEntered = 0
		         *
		      ELSE
		         INSERT INTO tempclose FROM MEMVAR
		      ENDIF
		   ENDSCAN
		ENDIF
		WAIT CLEAR
		
		SELECT tempclose
		IF RECC() > 0
		   REPORT FORM dmrclosew.frx PREVIEW
		   IF THIS.oMessage.CONFIRM('Should the report be sent to the printer now?')
		      REPORT FORM dmrclosew TO PRINTER PROMPT NOCONSOLE NOEJECT
		   ENDIF
		ELSE
		   IF llExceptions
		      THIS.oMessage.DISPLAY('There are no wells that have differences > .50 or less than -.50')
		   ELSE
		      THIS.oMessage.DISPLAY('There are no wells that have revenue or expenses for this period.')
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE calcsummary		&& Calculates the closing summary
		LOCAL lcYear, lcPeriod, lcGroup, lnRevEnt, lnExpEnt
		LOCAL lnRevAll, lnExpAll, lcTitle1, lcDMBatch, llSepClose
		LOCAL lnJIBAll, lnJibInv, lnJibInvAmt, lnRunNo, m.ldirgaspurch, m.ldiroilpurch
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Starting calcsummary')
		ENDIF
		
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Creating the Closing Summary Page...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		ENDIF
		
		STORE .F. TO m.ldirgaspurch, m.ldiroilpurch
		
		lcYear   = THIS.cRunYear
		lcGroup  = THIS.cGroup
		lnRunNo  = THIS.nRunNo
		
		STORE 0 TO lnJIBAll, lnJibInv, lnJibInvAmt
		
		SELECT options
		GO TOP
		glGrpName  = lGrpName
		llSepClose = lSepClose
		lnMinimum  = nMinCheck
		
		IF glGrpName
		   SELECT groups
		   SET ORDER TO cGroup
		   IF SEEK(lcGroup)
		      m.cGrpName = cDesc
		   ELSE
		      IF lcGroup = '**'
		         m.cGrpName = 'All Companies'
		      ELSE
		         m.cGrpName = ''
		      ENDIF
		   ENDIF
		ELSE
		   m.cGrpName = ''
		ENDIF
		
		IF THIS.companypost = .T.
		   tdPostDate = THIS.dacctdate
		ELSE
		   tdPostDate = THIS.dPostDate
		ENDIF
		
		lcTitle1 = 'Revenue Closing Summary'
		lcTitle2 = 'For Run No ' + ALLT(STR(lnRunNo)) +'/'+lcYear + ' Group ' + lcGroup + ' Dated: ' + DTOC(tdPostDate)
		
		IF TYPE('m.goApp') = 'O'
		   m.cProducer = m.goApp.cCompanyName
		ELSE
		   m.cProducer = 'Development Company'
		ENDIF
		
		m.cProcessor = ''
		
		*
		*  Builds the closing summary information
		*
		CREATE CURSOR closetemp ;
		   (nRevEntered    N(12,2), ;
		   nRevAllocated  N(12,2), ;
		   nExpEntered    N(12,2), ;
		   nExpAllocated  N(12,2), ;
		   nJExpAllocated N(12,2), ;
		   nJIBInvCount   I, ;
		   nJIBInvAmount  N(12,2), ;
		   nOwnChkCount   I, ;
		   nOwnChkAmt     N(12,2), ;
		   nDirectDep     N(12,2), ;
		   nDirectDepCnt  I, ;
		   nOwnerPost     N(12,2), ;
		   nVendorPost    N(12,2), ;
		   nVendChkCount  I, ;
		   nVendChkAmt    N(12,2), ;
		   nSevTaxWell    N(9,2), ;
		   nSevTaxOwn     N(9,2), ;
		   nGathering     N(12,2), ;
		   nCompression   N(12,2), ;
		   nDefPrior      N(12,2), ;
		   nDefCurr       N(12,2), ;
		   nMinPrior      N(12,2), ;
		   nMinCurr       N(12,2), ;
		   nHoldPrior     N(12,2), ;
		   nHoldCurr      N(12,2), ;
		   nBackWith      N(12,2), ;
		   nTaxWith       N(12,2), ;
		   cRevProdPrds   C(80), ;
		   cExpProdPrds   C(80), ;
		   drevenue       D, ;
		   dexpense       D, ;
		   dPostDate      D)
		
		SELECT wells
		SET ORDER TO cWellID
		
		m.drevenue = THIS.drevdate
		m.dexpense = THIS.dexpdate
		m.dPostDate = THIS.dPostDate
		
		lnRevEnt = 0
		
		CREATE CURSOR tempprd ;
		   (cyear   C(4), ;
		   cPeriod C(2))
		
		SELE income
		SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear
		   m.cyear = cyear
		   m.cPeriod = cPeriod
		   INSERT INTO tempprd FROM MEMVAR
		ENDSCAN
		
		lcRevProdPrds = ''
		SELE cyear, cPeriod FROM tempprd ORDER BY cyear, cPeriod GROUP BY cyear, cPeriod INTO CURSOR temp
		SELE temp
		SCAN
		   lcRevProdPrds = lcRevProdPrds + cyear+'/'+cPeriod + ' '
		ENDSCAN
		
		SELE tempprd
		DELE ALL
		
		SELE expense
		SCAN FOR nRunNoRev = lnRunNo AND cRunYearRev = lcYear
		   m.cyear = cyear
		   m.cPeriod = cPeriod
		   INSERT INTO tempprd FROM MEMVAR
		ENDSCAN
		lcExpProdPrds = ''
		SELE cyear, cPeriod FROM tempprd ORDER BY cyear, cPeriod GROUP BY cyear, cPeriod INTO CURSOR temp
		SELE temp
		SCAN
		   lcExpProdPrds = lcExpProdPrds + cyear+'/'+cPeriod + ' '
		ENDSCAN
		
		
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Closing Summary Page: Summing Revenue Entered...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		
		ENDIF
		
		*  Get the revenue entered for monthly wells
		SELECT income
		SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear AND NOT 'TAX' $ csource
		   SCATTER MEMVAR
		   SELECT wells
		   IF SEEK(m.cWellID) AND cGroup = lcGroup AND nprocess <> 2
		      *!*	      IF wells.cwellstat <> 'A'
		      *!*	         LOOP
		      *!*	      ENDIF
		      DO CASE
		         CASE m.csource = 'BBL'
		            lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'O',.F.,.T.,.F.,m.cOwnerID)
		
		         CASE m.csource = 'MCF'
		            lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'G',.F.,.T.,.F.,m.cOwnerID)
		
		         CASE m.csource = 'MISC1'
		            lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'1',.F.,.T.,.F.,m.cOwnerID)
		
		         CASE m.csource = 'MISC2'
		            lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'2',.F.,.T.,.F.,m.cOwnerID)
		
		         CASE m.csource = 'TRANS'
		            lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'T',.F.,.T.,.F.,m.cOwnerID)
		
		         CASE m.csource = 'OTH'
		            lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'P',.F.,.T.,.F.,m.cOwnerID)
		
		         OTHERWISE
		            IF NOT 'TAX' $ m.csource
		               lnRevEnt = lnRevEnt + m.nTotalInc
		            ENDIF
		      ENDCASE
		   ENDIF
		ENDSCAN
		
		IF THIS.lRelQtr
		   SELECT income
		   SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear
		      SCATTER MEMVAR
		      SELECT wells
		      IF SEEK(m.cWellID) AND cGroup = lcGroup AND nprocess = 2
		         *!*	         IF wells.cwellstat <> 'A'
		         *!*	            LOOP
		         *!*	         ENDIF
		         DO CASE
		            CASE m.csource = 'BBL'
		               lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'O',.F.,.T.,.F.,m.cOwnerID)
		
		            CASE m.csource = 'MCF'
		               lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'G',.F.,.T.,.F.,m.cOwnerID)
		
		            CASE m.csource = 'MISC1'
		               lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'1',.F.,.T.,.F.,m.cOwnerID)
		
		            CASE m.csource = 'MISC2'
		               lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'2',.F.,.T.,.F.,m.cOwnerID)
		
		            CASE m.csource = 'TRANS'
		               lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'T',.F.,.T.,.F.,m.cOwnerID)
		
		            CASE m.csource = 'OTH'
		               lnRevEnt = lnRevEnt + THIS.netrev(m.cWellID, m.nTotalInc,'P',.F.,.T.,.F.,m.cOwnerID)
		
		            OTHERWISE
		               IF NOT 'TAX' $ m.csource
		                  lnRevEnt = lnRevEnt + m.nTotalInc
		               ENDIF
		         ENDCASE
		      ENDIF
		   ENDSCAN
		ENDIF
		
		* Get flat rates paid out
		SELE cWellID FROM income INTO CURSOR tempwell WHERE nRunNo = lnRunNo AND cRunYear= lcYear  AND NOT 'TAX' $ csource ORDER BY cWellID GROUP BY cWellID
		SELE wellhist
		SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear
		   m.cWellID = cWellID
		   SELE tempwell
		   LOCATE FOR cWellID = m.cWellID
		   IF NOT FOUND()
		      SELE wellhist
		      lnRevEnt = lnRevEnt + nFlatGas + nFlatOil
		   ENDIF
		ENDSCAN
		
		lnExpEnt = 0
		
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Closing Summary Page: Summing Expenses Entered...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		
		ENDIF
		
		SELECT expense
		IF llSepClose
		   lcScanFor = "(nRunNoRev = lnRunNo AND cRunYearRev = lcYear) OR (nRunnoJIB = lnRunNo AND cRunYearJIB = lcYear and cRunYearRev = '1900')"
		ELSE
		   lcScanFor = "(nRunNoRev = lnRunNo AND cRunYearRev = lcYear) OR (nRunnoJIB = lnRunNo AND cRunYearJIB = lcYear)"
		ENDIF
		SCAN FOR &lcScanFor
		   SCATTER MEMVAR
		   SELECT wells
		   IF SEEK(m.cWellID) AND cGroup = lcGroup AND nprocess <> 2
		      *!*	      IF wells.cwellstat <> 'A'
		      *!*	         LOOP
		      *!*	      ENDIF
		      IF NOT EMPTY(m.cOwnerID)
		         SELECT investor
		         LOCATE FOR cOwnerID == m.cOwnerID  &&  If it's been allocated to the dummy, ignore it
		         IF FOUND() AND NOT investor.ldummy
		            lnExpEnt = lnExpEnt + m.nAmount
		         ENDIF
		         SELE wellinv
		         LOCATE FOR cOwnerID = m.cOwnerID AND cWellID=m.cWellID AND ctypeinv='W'
		         IF FOUND()
		            IF ljib
		               IF llSepClose
		                  lnJIBAll = lnJIBAll + m.nAmount
		               ENDIF
		            ELSE
		               *               lnExpEnt = lnExpEnt + m.nAmount
		            ENDIF
		         ENDIF
		      ELSE
		         IF llSepClose
		            IF m.cCatCode = 'MKTG'
		               lnExpEnt = lnExpEnt + THIS.netrev(m.cWellID, m.nAmount, 'G', .F., .T., .T.)
		            ELSE
		               lnExpEnt = lnExpEnt + swNetExp(m.nAmount, m.cWellID, .T., m.cexpclass,'B')
		            ENDIF
		            IF m.cCatCode <> 'MKTG'
		               lnJIBAll = lnJIBAll + swNetExp(m.nAmount, m.cWellID, .T., m.cexpclass,'J')
		            ENDIF
		         ELSE
		            lnAmount = m.nAmount
		            lnExpEnt = lnExpEnt + swNetExp(lnAmount, m.cWellID, .T., m.cexpclass,'B')
		         ENDIF
		      ENDIF
		   ENDIF
		   SELECT expense
		ENDSCAN
		
		IF THIS.lRelQtr
		   SELECT expense
		   SCAN FOR (nRunNoRev = lnRunNo AND cRunYearRev = lcYear) OR (nRunnoJIB = lnRunNo AND cRunYearJIB = lcYear AND cRunYearRev = '1900')
		      SCATTER MEMVAR
		      SELECT wells
		      IF SEEK(m.cWellID) AND cGroup = lcGroup AND nprocess = 2
		         *!*	         IF wells.cwellstat <> 'A'
		         *!*	            LOOP
		         *!*	         ENDIF
		         IF NOT EMPTY(m.cOwnerID)
		            SELECT investor
		            LOCATE FOR cOwnerID == m.cOwnerID  &&  If it's been allocated to the dummy, ignore it
		            IF FOUND() AND NOT investor.ldummy
		               lnExpEnt = lnExpEnt + m.nAmount
		            ENDIF
		            SELE wellinv
		            LOCATE FOR cOwnerID = m.cOwnerID AND cWellID=m.cWellID AND ctypeinv='W'
		            IF FOUND()
		               IF ljib
		                  IF llSepClose
		                     lnJIBAll = lnJIBAll + m.nAmount
		                  ENDIF
		               ELSE
		                  *               lnExpEnt = lnExpEnt + m.nAmount
		               ENDIF
		            ENDIF
		         ELSE
		            IF llSepClose
		               lnExpEnt = lnExpEnt + swNetExp(m.nAmount, m.cWellID, .T., m.cexpclass,'B')
		               IF m.cCatCode <> 'MKTG'
		                  lnJIBAll = lnJIBAll + swNetExp(m.nAmount, m.cWellID, .T., m.cexpclass,'J')
		               ENDIF
		            ELSE
		               lnAmount = m.nAmount
		               lnExpEnt = lnExpEnt + swNetExp(lnAmount, m.cWellID, .T., m.cexpclass,'B')
		            ENDIF
		         ENDIF
		      ENDIF
		      SELECT expense
		   ENDSCAN
		ENDIF
		
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Closing Summary Page: Summing Direct Deposits...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		
		ENDIF
		
		* Get the direct deposit totals and count
		lnDirectDep = 0
		lnDirectDepCnt = 0
		IF FILE(m.goApp.cdatafilepath+'dirdep.dbf')
		   IF NOT USED('dirdep')
		      USE (m.goApp.cdatafilepath+'dirdep') IN 0
		   ENDIF
		   SELECT dirdep
		   LOCATE FOR nRunNo = THIS.nRunNo AND cRunYear = THIS.cRunYear
		   IF FOUND()
		      SCATTER MEMVAR
		
		      lnDirectDep    = m.nAmount
		      lnDirectDepCnt = m.nCount
		   ENDIF
		ELSE
		   lnDirectDep    = 0
		   lnDirectDepCnt = 0
		ENDIF
		
		*  Get the revenue and expenses allocated
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Closing Summary Page: Summing Revenue/Expenses Allocated...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		
		ENDIF
		
		lnRevAll = 0
		lnExpAll = 0
		lnSevTaxOwn = 0
		lnOwnerPost = 0
		SELECT disbhist
		SET ORDER TO 0
		SCAN FOR nRunNo = lnRunNo AND cRecType = 'R' AND cRunYear = lcYear
		   SCATTER MEMVAR
		   m.cOwnerID = cOwnerID
		   m.cWellID  = cWellID
		   m.lExempt = .F.
		   SELECT investor
		   SET ORDER TO cOwnerID
		   IF SEEK(m.cOwnerID)
		      m.lExempt = lExempt
		      m.lDirectDep = lDirectDep
		      m.lIntegGL   = lIntegGL
		      IF investor.ldummy
		         LOOP
		      ENDIF
		   ENDIF
		   SELE wells
		   LOCATE FOR cWellID = m.cWellID
		   IF FOUND()
		      m.ldiroilpurch = ldiroilpurch
		      m.ldirgaspurch = ldirgaspurch
		      SCATTER FIELDS LIKE lSev* MEMVAR
		   ELSE
		      LOOP
		   ENDIF
		
		   lnIncome = m.nIncome
		   lnIncome = lnIncome - IIF(m.cdirect='O',m.noilrev,0)
		   lnIncome = lnIncome - IIF(m.cdirect='G',m.ngasrev,0)
		   lnIncome = lnIncome - IIF(m.cdirect='B',m.noilrev+m.ngasrev,0)
		   lnRevAll = lnRevAll + lnIncome + m.nFlatRate
		   lnExpAll = lnExpAll + m.nExpense + m.nTotale1 + m.nTotale2 + m.nTotale3 + m.nTotale4 + m.nTotale5 + m.nTotaleA + m.nTotaleB + m.nMKTGExp
		
		   IF m.lIntegGL
		      lnOwnerPost = lnOwnerPost + m.nNetCheck
		   ENDIF
		   IF m.lExempt
		      LOOP
		   ELSE
		      DO CASE
		         CASE m.cdirect = 'O' OR m.cdirect = 'B'
		            IF m.ldiroilpurch
		               lnSevTaxOwn = lnSevTaxOwn +  m.nGasTax1+m.nGasTax2+m.nGasTax3+m.nGasTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		            ELSE
		               lnSevTaxOwn = lnSevTaxOwn +  m.nOilTax1+m.nOilTax2+m.nOilTax3+m.nOilTax4+m.nGasTax1+m.nGasTax2+m.nGasTax3+m.nGasTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		            ENDIF
		         CASE m.cdirect = 'G' OR m.cdirect = 'B'
		            IF m.ldirgaspurch
		               lnSevTaxOwn = lnSevTaxOwn +  m.nOilTax1+m.nOilTax2+m.nOilTax3+m.nOilTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		            ELSE
		               lnSevTaxOwn = lnSevTaxOwn +  m.nOilTax1+m.nOilTax2+m.nOilTax3+m.nOilTax4+m.nGasTax1+m.nGasTax2+m.nGasTax3+m.nGasTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		            ENDIF
		         CASE m.cdirect = 'N'
		            lnSevTaxOwn = lnSevTaxOwn +  m.nOilTax1+m.nOilTax2+m.nOilTax3+m.nOilTax4+m.nGasTax1+m.nGasTax2+m.nGasTax3+m.nGasTax4+m.nOthTax1+m.nOthTax2+m.nOthTax3+m.nOthTax4
		      ENDCASE
		   ENDIF
		ENDSCAN
		
		IF NOT llSepClose
		   IF NOT THIS.lClose
		      WAIT WIND NOWAIT 'Summing Expenses Allocated to JIB Owners...'
		   ENDIF
		   * Get the JIB expenses allocated
		   SELECT disbhist
		   SCAN FOR nRunNo = lnRunNo AND cRecType = 'J' AND cRunYear = lcYear
		      SCATTER MEMVAR
		      *  Net out "Dummy" owners
		      SELECT investor
		      SET ORDER TO cOwnerID
		      IF SEEK(m.cOwnerID) AND investor.ldummy
		         LOOP
		      ENDIF
		      lnJIBAll = lnJIBAll + m.nExpense + m.nTotale1 + m.nTotale2 + m.nTotale3 + m.nTotale4 + m.nTotale5
		   ENDSCAN
		
		   * Get the count of JIB Invoices
		   SELECT invhdr
		   COUNT FOR nRunNo = lnRunNo AND cGroup = lcGroup AND cInvType = 'J' AND NOT lNetJIB TO lnJibInv
		
		   * Get the amount of JIB Invoices
		   SELECT SUM(nInvTot) AS nInvTot FROM invhdr, investor ;
		      WHERE nRunNo = lnRunNo AND cRunYear = lcYear ;
		      AND cGroup = lcGroup ;
		      AND cInvType = 'J' ;
		      AND cCustID = investor.cOwnerID ;
		      AND NOT lNetJIB ;
		      AND NOT investor.ldummy ;
		      INTO ARRAY laTotal
		   IF _TALLY > 0
		      lnJibInvAmt = laTotal[1]
		   ELSE
		      lnJibInvAmt = 0
		   ENDIF
		ENDIF
		
		lnGathering = 0
		lnCompression = 0
		
		*  Get the severance taxes allocated to the well
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Closing Summary Page: Summing Well Taxes...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		
		ENDIF
		
		lnSevTaxWell = 0
		SELECT wellhist
		SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear AND cGroup = lcGroup AND cRecType = 'R'
		   SCATTER MEMVAR
		   SELECT wells
		   SET ORDER TO cWellID
		   IF SEEK(m.cWellID)
		      *!*	      IF wells.cwellstat <> 'A'
		      *!*	         LOOP
		      *!*	      ENDIF
		      m.lSev1O = lSev1O
		      m.lSev2O = lSev2O
		      m.lSev3O = lSev3O
		      m.lSev4O = lSev4O
		      m.lSev1G = lSev1G
		      m.lSev2G = lSev2G
		      m.lSev3G = lSev3G
		      m.lSev4G = lSev4G
		      m.lSev1P = lSev1P
		      m.lSev2P = lSev2P
		      m.lSev3P = lSev3P
		      m.lSev4P = lSev4P
		      m.ldiroilpurch = ldiroilpurch
		      m.ldirgaspurch = ldirgaspurch
		
		      lnGathering   = lnGathering + THIS.netrev(m.cWellID,m.ngather,'G',.F.,.T.,.T.)
		      lnCompression = lnCompression + THIS.netrev(m.cWellID,m.nCompress,'G',.F.,.T.,.T.)
		
		      STORE 0 TO lnOTax1, lnOTax2, lnOTax3,lnOTax4, lnGTax1, lnGTax2, lnGTax3, lnGTax4,  ;
		         lnPTax1, lnPTax2, lnPTax3, lnPTax4
		
		
		      SELECT income  &&  Total up the one-man tax entries, so they can be subtracted off before doing the netrev
		      SCAN FOR cWellID == m.cWellID AND nRunNo = m.nRunNo AND cRunYear = m.cRunYear  ;
		            AND cyear+cPeriod = m.hYear+m.hPeriod AND 'TAX' $ csource AND NOT EMPTY(cOwnerID)
		         DO CASE
		            CASE csource = 'OTAX1'
		               lnOTax1 = lnOTax1 + nTotalInc
		            CASE csource = 'OTAX2'
		               lnOTax2 = lnOTax2 + nTotalInc
		            CASE csource = 'OTAX3'
		               lnOTax3 = lnOTax3 + nTotalInc
		            CASE csource = 'OTAX4'
		               lnOTax4 = lnOTax4 + nTotalInc
		            CASE csource = 'GTAX1'
		               lnGTax1 = lnGTax1 + nTotalInc
		            CASE csource = 'GTAX2'
		               lnGTax2 = lnGTax2 + nTotalInc
		            CASE csource = 'GTAX3'
		               lnGTax3 = lnGTax3 + nTotalInc
		            CASE csource = 'GTAX4'
		               lnGTax4 = lnGTax4 + nTotalInc
		            CASE csource = 'PTAX1'
		               lnPTax1 = lnPTax1 + nTotalInc
		            CASE csource = 'PTAX2'
		               lnPTax2 = lnPTax2 + nTotalInc
		            CASE csource = 'PTAX3'
		               lnPTax3 = lnPTax3 + nTotalInc
		            CASE csource = 'PTAX4'
		               lnPTax4 = lnPTax4 + nTotalInc
		         ENDCASE
		      ENDSCAN
		
		      lnOTax1 = lnOTax1*-1  &&  Since the numbers in the income table for taxes are negative, switch the sign before the netrev step
		      lnOTax2 = lnOTax2*-1
		      lnOTax3 = lnOTax3*-1
		      lnOTax4 = lnOTax4*-1
		      lnGTax1 = lnGTax1*-1
		      lnGTax2 = lnGTax2*-1
		      lnGTax3 = lnGTax3*-1
		      lnGTax4 = lnGTax4*-1
		      lnPTax1 = lnPTax1*-1
		      lnPTax2 = lnPTax2*-1
		      lnPTax3 = lnPTax3*-1
		      lnPTax4 = lnPTax4*-1
		
		
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotBBLTx1-lnOTax1,'O1',.F.,.T.,.T.) + lnOTax1
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotBBLTx2-lnOTax2,'O2',.F.,.T.,.T.) + lnOTax2
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotBBLTx3-lnOTax3,'O3',.F.,.T.,.T.) + lnOTax3
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotBBLTx4-lnOTax4,'O4',.F.,.T.,.T.) + lnOTax4
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotMCFTx1-lnGTax1,'G1',.F.,.T.,.T.) + lnGTax1
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotMCFTx2-lnGTax2,'G2',.F.,.T.,.T.) + lnGTax2
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotMCFTx3-lnGTax3,'G3',.F.,.T.,.T.) + lnGTax3
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotMCFTx4-lnGTax4,'G4',.F.,.T.,.T.) + lnGTax4
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotOthTx1-lnPTax1,'P',.F.,.T.,.T.) + lnPTax1
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotOthTx2-lnPTax2,'P',.F.,.T.,.T.) + lnPTax2
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotOthTx3-lnPTax3,'P',.F.,.T.,.T.) + lnPTax3
		      lnSevTaxWell = lnSevTaxWell + THIS.netrev(m.cWellID,m.nTotOthTx4-lnPTax4,'P',.F.,.T.,.T.) + lnPTax4
		
		      lnSevTaxWell = lnSevTaxWell + m.nTotBBLTxr + m.nTotMCFTxr + m.nTotBBLTxw + m.nTotMCFTxw
		   ENDIF
		ENDSCAN
		
		STORE 0 TO m.nOwnChkCount, m.nVendChkCount
		STORE 0 TO m.nOwnChkAmt, m.nVendChkAmt
		STORE 0 TO m.nDefPrior, m.nDefCurr, m.nMinPrior, m.nMinCurr
		STORE 0 TO m.nHoldPrior, m.nHoldCurr, m.nBackWith, m.nTaxWith
		
		*  Get the amount of vendor posting
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Closing Summary Page: Summing Vendor Amounts Posted...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		
		ENDIF
		lnVendorPost = 0
		SELE vendor
		SELE cvendorid INTO CURSOR tempvend FROM vendor WHERE lIntegGL ORDER BY cvendorid
		IF _TALLY > 0
		   SELE tempvend
		   SCAN
		      m.cvendorid = cvendorid
		      SELE expense
		      SCAN FOR cRunYearRev = lcYear AND nRunNoRev = lnRunNo AND NOT lAPTran AND cvendorid = m.cvendorid
		         m.nAmount = nAmount
		         m.cWellID = cWellID
		         m.cexpclass = cexpclass
		         lnVendorPost = lnVendorPost + swNetExp(m.nAmount,m.cWellID,.T.,m.cexpclass,'B')
		      ENDSCAN
		   ENDSCAN
		ENDIF
		
		*  Get the check counts and amounts
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Closing Summary Page: Summing Check Counts and Totals...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		
		ENDIF
		SELECT sysctl
		LOCATE FOR cyear = lcYear AND nRunNo = lnRunNo AND cTypeClose = 'R'
		IF FOUND()
		   lcDMBatch = cDMBatch
		   SELECT checks
		   SCAN FOR cBatch = lcDMBatch AND cidtype = 'I'
		      m.nOwnChkCount = m.nOwnChkCount + 1
		      m.nOwnChkAmt   = m.nOwnChkAmt + nAmount
		   ENDSCAN
		   SCAN FOR cBatch = lcDMBatch AND cidtype = 'V'
		      m.nVendChkCount = m.nVendChkCount + 1
		      m.nVendChkAmt   = m.nVendChkAmt + nAmount
		   ENDSCAN
		
		   *  Get the suspense Amounts
		   IF THIS.lClose
		      THIS.oProgress.SetProgressMessage('Closing Summary Page: Summing Suspense Amounts...')
		      THIS.oProgress.UpdateProgress(THIS.nprogress)
		      THIS.nprogress = THIS.nprogress + 1
		
		   ENDIF
		
		   SELECT susaudit
		   SCAN FOR cBatch = lcDMBatch AND csusptype = 'D'
		
		      WAIT WINDOW NOWAIT 'Record # ' + cidsusa
		
		      m.cOwnerID = cOwnerID
		      SELECT investor
		      SET ORDER TO cOwnerID
		      IF SEEK(m.cOwnerID) AND investor.ldummy
		         LOOP
		      ENDIF
		      SELECT susaudit
		      IF cAction = 'O'
		         m.nDefPrior = m.nDefPrior + nAmount
		      ELSE
		         m.nDefCurr = m.nDefCurr + nAmount
		      ENDIF
		   ENDSCAN
		   SCAN FOR cBatch = lcDMBatch AND csusptype = 'M'
		      m.cOwnerID = cOwnerID
		      SELECT investor
		      SET ORDER TO cOwnerID
		      IF SEEK(m.cOwnerID) AND investor.ldummy
		         LOOP
		      ENDIF
		      SELECT susaudit
		      IF cAction = 'O'
		         m.nMinPrior = m.nMinPrior + nAmount
		      ELSE
		         m.nMinCurr = m.nMinCurr + nAmount
		      ENDIF
		   ENDSCAN
		   SCAN FOR cBatch = lcDMBatch AND (csusptype = 'H' OR csusptype = 'I')
		      m.cOwnerID = cOwnerID
		      SELECT investor
		      SET ORDER TO cOwnerID
		      IF SEEK(m.cOwnerID) AND investor.ldummy
		         LOOP
		      ENDIF
		      SELECT susaudit
		      IF cAction = 'O'
		         m.nHoldPrior = m.nHoldPrior + nAmount
		      ELSE
		         m.nHoldCurr = m.nHoldCurr + nAmount
		      ENDIF
		   ENDSCAN
		
		   SELE investor
		   COUNT FOR lBackwith TO lnTaxWith
		   sele wellinv
		   count for ntaxpct <> 0 to lnpctcnt
		   lntaxwith = lntaxwith + lnpctcnt
		   IF lnTaxWith > 0
		      IF NOT THIS.lClose
		         WAIT WIND NOWAIT 'Summing Tax Withholding Totals...'
		      ENDIF
		      SELECT disbhist
		      SCAN FOR nRunNo = lnRunNo AND cRunYear = lcYear AND cRecType = 'R' AND (nTaxWith <> 0 OR nBackWith <> 0)
		         m.cOwnerID = cOwnerID
		         m.nTax  = nTaxWith
		         m.nBack = nBackWith
		         SELECT investor
		         SET ORDER TO cOwnerID
		         IF SEEK(m.cOwnerID) AND investor.ldummy
		            LOOP
		         ENDIF
		         m.nTaxWith = m.nTaxWith + m.nTax
		         m.nBackWith = m.nBackWith + m.nBack
		      ENDSCAN
		   ENDIF
		ENDIF
		
		
		m.nRevEntered    = lnRevEnt
		m.nRevAllocated  = lnRevAll
		m.nExpEntered    = lnExpEnt
		m.nExpAllocated  = lnExpAll
		m.nSevTaxWell    = lnSevTaxWell
		m.nSevTaxOwn     = lnSevTaxOwn
		m.nJExpAllocated = lnJIBAll
		m.nJIBInvCount   = lnJibInv
		m.nJIBInvAmount  = lnJibInvAmt
		m.cRevProdPrds   = lcRevProdPrds
		m.cExpProdPrds   = lcExpProdPrds
		m.nDirectDep     = lnDirectDep
		m.nDirectDepCnt  = lnDirectDepCnt
		m.nOwnerPost     = lnOwnerPost
		m.nVendorPost    = lnVendorPost
		m.nGathering     = lnGathering
		m.nCompression   = lnCompression
		WAIT CLEAR
		
		SET SAFETY OFF
		SELE closetemp
		ZAP
		INSERT INTO closetemp FROM MEMVAR
		SELECT closetemp
		
		IF THIS.lClose
		   THIS.oProgress.CloseProgress()
		   THIS.oProgress = .NULL.
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Ending calcsummary')
		ENDIF
		
		LOCAL lcPreviewWindowName
		lcPreviewWindowName=SYS(2015)
		DEFINE WINDOW (lcPreviewWindowName) ;
		   FROM 0,0 TO SROWS(),SCOLS() ;
		   TITLE "Report Preview" ;
		   SYSTEM CLOSE FLOAT GROW MINIMIZE ZOOM
		ZOOM WINDOW (lcPreviewWindowName) MAX
		
		REPORT FORM dmrcloser.frx TO PRINTER PROMPT PREVIEW WINDOW (lcPreviewWindowName) RANGE 1,1
		RELEASE WINDOWS (lcPreviewWindowName)
		IF THIS.oMessage.CONFIRM('Should the report be sent to the printer now?')
		   REPORT FORM dmrcloser TO PRINTER PROMPT NOCONSOLE NOEJECT RANGE 1,1
		ENDIF
		
	ENDPROC

	PROCEDURE calcsuspbalance		&& Calculates Suspense Balances
		*
		*  Calculates current outstanding suspense balances by owner and well
		*
		LPARA tcType
		*  tcType   = 'W' - by owner and well, 'P' - by owner and program, 'O' - by owner
		LOCAL jCount
		
		if this.lDebug
		   this.timekeeper('Starting calcsuspbalance')  
		endif   
		
		tcRunYear = this.cRunYear
		tcPeriod  = THIS.cPeriod
		lnRunNo   = THIS.nRunNo
		
		IF lnRunNo = 0
		   tcRunYear = ALLT(STR(YEAR(this.dacctdate)))
		   lnRunNo   = getrunno(tcRunYear,.T.,'R')
		ENDIF   
		
		IF tcType <> 'P'
		   CREATE CURSOR suspbalown ;
		      (cOwnerID   C(10), ;
		      cWellID    C(10), ;
		      cProgCode  C(10), ;
		      cType      C(1),  ;
		      nIncome    N(12,2), ;
		      nTaxes     N(9,2), ;
		      nExpense   N(12,2), ;
		      nNetOwn    N(12,2))
		
		   CREATE CURSOR suspbalwell ;
		      (cOwnerID   C(10), ;
		      cWellID    C(10), ;
		      cProgCode  C(10), ;
		      cType      C(1),  ;
		      nIncome    N(12,2), ;
		      nTaxes     N(9,2), ;
		      nExpenses  N(12,2), ;
		      nNetWell   N(12,2), ;
		      nNewInc    N(12,2), ;
		      nNewTax    N(9,2), ;
		      nNewExp    N(12,2), ;
		      nNewNet    N(12,2), ;
		      nNetPct    N(16,12))
		ELSE
		   CREATE CURSOR suspbalownP ;
		      (cOwnerID   C(10), ;
		      cWellID    C(10), ;
		      cProgCode  C(10), ;
		      cType      C(1),  ;
		      nIncome    N(12,2), ;
		      nTaxes     N(9,2), ;
		      nExpense   N(12,2), ;
		      nNetOwn    N(12,2))
		
		   CREATE CURSOR suspbalwellP ;
		      (cOwnerID   C(10), ;
		      cWellID    C(10), ;
		      cProgCode  C(10), ;
		      cType      C(1),  ;
		      nIncome    N(12,2), ;
		      nTaxes     N(9,2), ;
		      nExpenses  N(12,2), ;
		      nNetWell   N(12,2), ;
		      nNewInc    N(12,2), ;
		      nNewTax    N(9,2), ;
		      nNewExp    N(12,2), ;
		      nNewNet    N(12,2), ;
		      nNetPct    N(11,7))
		ENDIF
		
		*  Get the balance by owner first
		DO CASE
		   CASE tcType = 'O'
		      * Keep track of suspense on an owner basis. This is where
		      * deficits are netted among an owner's wells
		      SELECT cOwnerID, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetOwn ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND cGroup = THIS.cGroup ;
		         AND NOT INLIST(cSuspType,'B','T','P') ;
		         AND cTypeInv <> 'V' ;
		         AND cProgCode NOT IN (SELECT cProgCode FROM programs WHERE lProgNet = .F.) ;
		         INTO CURSOR temp ;
		         ORDER BY cOwnerID ;
		         GROUP BY cOwnerID
		      jCount = _TALLY
		      
		      SELECT cOwnerID, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetOwn ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND csusptype <> 'P' ;
		         AND cGroup = THIS.cGroup ;
		         AND cTypeInv <> 'V' ;
		         AND cProgCode NOT IN (SELECT cProgCode FROM programs WHERE lProgNet = .F.) ;
		         INTO CURSOR temp1 ;
		         ORDER BY cOwnerID ;
		         GROUP BY cOwnerID 
		
		   CASE tcType = 'W'
		      * Keep track of suspense on a well by well basis. This is where
		      * deficits are not netted between wells.
		      SELECT cOwnerID, ;
		         cWellID, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetOwn ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND cGroup = THIS.cGroup ;
		         AND NOT INLIST(cSuspType,'B','I','T','P') ;
		         AND cTypeInv <> 'V' ;
		         INTO CURSOR temp ;
		         ORDER BY cOwnerID, cWellID ;
		         GROUP BY cOwnerID, cWellID
		      jCount = _TALLY
		      
		      SELECT cOwnerID, ;
		         cWellID, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetOwn ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND cGroup = THIS.cGroup ;
		         AND csusptype <> 'P' ;
		         AND cTypeInv <> 'V' ;
		         INTO CURSOR temp1 ;
		         ORDER BY cOwnerID ;
		         GROUP BY cOwnerID
		
		   CASE tcType = 'P'
		      SELECT programs
		      COUNT FOR NOT DELETED() AND lProgNet = .F. TO lnCount
		      IF lnCount = 0
		         RETURN .F.
		      ENDIF
		      * Keep track of suspense on an owner basis. This is where
		      * deficits are netted among an owner's wells
		      SELECT cOwnerID, ;
		         cProgCode, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetOwn ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND cGroup = THIS.cGroup ;
		         AND NOT INLIST(cSuspType,'B','I','T','P') ;
		         AND cTypeInv <> 'V' ;
		         AND cProgCode IN (SELECT cProgCode FROM programs WHERE lProgNet = .F.) ;
		         INTO CURSOR temp ;
		         ORDER BY cOwnerID, cProgCode ;
		         GROUP BY cOwnerID, cProgCode
		      jCount = _TALLY
		      
		      SELECT cOwnerID, ;
		         cProgCode, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetOwn ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND cGroup = THIS.cGroup ;
		         AND csusptype <> 'P' ;
		         AND cTypeInv <> 'V' ;
		         INTO CURSOR temp1 ;
		         ORDER BY cOwnerID ;
		         GROUP BY cOwnerID
		ENDCASE
		
		
		IF jCount > 0
		   IF tcType <> 'P'
		      SELECT suspbalown
		   ELSE
		      SELECT suspbalownP
		   ENDIF
		   APPEND FROM DBF('temp')
		ENDIF
		
		DO CASE
		   CASE tcType = 'O'
		
		      SELECT cOwnerID, ;
		         cWellID,  ;
		         cProgCode, ;
		         tcType                                         AS cType, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetWell ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND cGroup = THIS.cGroup ;
		         AND NOT INLIST(cSuspType,'B','I','T','P') ;
		         AND cTypeInv <> 'V' ;
		         AND cProgCode NOT IN (SELECT cProgCode FROM programs WHERE lProgNet = .F.) ;
		         INTO CURSOR temp ;
		         ORDER BY cOwnerID, cWellID ;
		         GROUP BY cOwnerID, cWellID
		         
		         
		   case tcType = 'W'  &&  By well, so we don't care about the program setting for netting - BH 10/17/06
		   
		      SELECT cOwnerID, ;
		         cWellID,  ;
		         cProgCode, ;
		         tcType                                         AS cType, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetWell ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND cGroup = THIS.cGroup ;
		         AND NOT INLIST(cSuspType,'B','I','T','P') ;
		         AND cTypeInv <> 'V' ;
		         INTO CURSOR temp ;
		         ORDER BY cOwnerID, cWellID ;
		         GROUP BY cOwnerID, cWellID
		         
		
		   CASE tcType = 'P'
		
		      SELECT cOwnerID, ;
		         cWellID,  ;
		         cProgCode, ;
		         tcType                                         AS cType, ;
		         SUM(IIF(cAction='I',nIncome,nIncome*-1))       AS nIncome, ;
		         SUM(IIF(cAction='I',nTaxes,nTaxes*-1))         AS nTaxes, ;
		         SUM(IIF(cAction='I',nExpenses,nExpenses*-1))   AS nExpenses, ;
		         SUM(IIF(cAction='I',nAmount,nAmount*-1)    )   AS nNetWell ;
		         FROM susaudit ;
		         WHERE cRunYear+STR(nRunNo) < tcRunYear+STR(lnRunNo);
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         AND cProgCode IN (SELECT cProgCode FROM programs WHERE lProgNet = .F.) ;
		         AND cGroup = THIS.cGroup ;
		         AND NOT INLIST(cSuspType,'B','I','T','P') ;
		         AND cTypeInv <> 'V' ;
		         INTO CURSOR temp ;
		         ORDER BY cOwnerID, cProgCode, cWellID ;
		         GROUP BY cOwnerID, cProgCode, cWellID
		
		ENDCASE
		
		IF _TALLY > 0
		   IF tcType <> 'P'
		      SELECT suspbalwell
		   ELSE
		      SELECT suspbalwellP
		   ENDIF
		   APPEND FROM DBF('temp')
		
		ENDIF
		
		*
		*  Remove suspbalwell entries if the owner's suspense balance is zero
		*
		DO CASE
		   CASE tcType = 'O'
		      SELECT suspbalown
		      SCAN FOR nNetOwn = 0
		         SCATTER MEMVAR
		         SELECT suspbalwell
		         SCAN FOR cOwnerID = m.cOwnerID
		            DELE NEXT 1
		         ENDSCAN
		      ENDSCAN
		      
		      SELE temp1
		      SCAN FOR nNetOwn = 0
		         SCATTER MEMVAR
		         SELE suspbalown
		         LOCATE FOR cownerid = m.cOwnerID
		         IF FOUND()
		            REPL nNetOwn WITH 0
		            SELE suspbalwell
		            SCAN FOR cOwnerID = m.cOwnerID
		               DELE NEXT 1
		            ENDSCAN   
		         ENDIF
		      ENDSCAN      
		
		   CASE tcType = 'W'
		      SELECT suspbalown
		      SCAN FOR nNetOwn = 0
		         SCATTER MEMVAR
		         SELECT suspbalwell
		         SCAN FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		            DELE NEXT 1
		         ENDSCAN
		      ENDSCAN
		      
		      SELE temp1
		      SCAN FOR nNetOwn = 0
		         SCATTER MEMVAR
		         SELE suspbalown
		         LOCATE FOR cownerid = m.cOwnerID
		         IF FOUND()
		            REPL nNetOwn WITH 0
		            SELE suspbalwell
		            SCAN FOR cOwnerID = m.cOwnerID
		               DELE NEXT 1
		            ENDSCAN   
		         ENDIF
		      ENDSCAN      
		
		   CASE tcType = 'P'
		      SELECT suspbalownP
		      SCAN FOR nNetOwn = 0
		         SCATTER MEMVAR
		         SELECT suspbalwellP
		         SCAN FOR cOwnerID = m.cOwnerID AND cProgCode = m.cProgCode
		            DELE NEXT 1
		         ENDSCAN
		      ENDSCAN
		      
		      SELE temp1
		      SCAN FOR nNetOwn = 0
		         SCATTER MEMVAR
		         SELE suspbalownP
		         LOCATE FOR cownerid = m.cOwnerID
		         IF FOUND()
		            REPL nNetOwn WITH 0
		            SELE suspbalwellP
		            SCAN FOR cOwnerID = m.cOwnerID
		               DELE NEXT 1
		            ENDSCAN   
		         ENDIF
		      ENDSCAN      
		ENDCASE
		
		if this.lDebug
		   this.timekeeper('Ending calcsuspbalance')  
		endif   
		
		RETURN .T.
	ENDPROC

	PROCEDURE calcsuspense		&& Calculates new suspense records.
		LPARA tcType
		* tcType = 'W' - Calculate by owner and well,  'P' - Calculate by owner and program, 'O' - Calculate by owner
		
		if this.lDebug
		   this.timekeeper('Starting calcsuspense')  
		endif   
		
		*
		*  Determines what items are covered in suspense
		*
		DO CASE
		   CASE tcType = 'O'
		      SELECT cOwnerID, SUM(nNetCheck) AS nTotal ;
		         FROM invtmp ;
		         WHERE EMPTY(ALLT(cProgCode)) OR invtmp.lProgNet = .T. ;
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         INTO CURSOR totals ;
		         ORDER BY cOwnerID ;
		         GROUP BY cOwnerID
		   CASE tcType = 'P'
		      SELECT cOwnerID, cProgCode, SUM(nNetCheck) AS nTotal ;
		         FROM invtmp ;
		         WHERE NOT EMPTY(ALLT(cProgCode)) AND invtmp.lProgNet = .F. ;
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         INTO CURSOR totals ;
		         ORDER BY cOwnerID, cProgCode ;
		         GROUP BY cOwnerID, cProgCode
		   CASE tcType = 'W'
		      SELECT cOwnerID, cWellID, SUM(nNetCheck) AS nTotal ;
		         FROM invtmp ;
		         WHERE EMPTY(ALLT(cProgCode)) OR invtmp.lProgNet = .T. ;
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		         INTO CURSOR totals ;
		         ORDER BY cOwnerID, cWellID ;
		         GROUP BY cOwnerID, cWellID
		ENDCASE
		
		*  Calculate net pct
		IF tcType <> 'P'
		   SELECT suspbalown
		   SCAN
		      SCATTER MEMVAR
		      SELECT suspbalwell
		      DO CASE
		         CASE tcType = 'O'
		            SCAN FOR cOwnerID = m.cOwnerID
		               IF m.nNetOwn < 0
		                  m.nNetPct = swround(nNetWell/m.nNetOwn,12)
		                  IF nNetWell < 0 AND m.nNetOwn < 0
		                     m.nNetPct = m.nNetPct * -1
		                  ENDIF
		                  IF nNetWell > 0 AND m.nNetOwn < 0
		                     m.nNetPct = m.nNetPct * -1
		                  ENDIF
		               ELSE
		                  IF m.nNetOwn > 0
		                     m.nNetPct = 1
		                  ELSE
		                     m.nNetPct = 0
		                  ENDIF
		               ENDIF
		               REPL nNetPct WITH m.nNetPct
		               *
		               *  If minimums are being released plug in the minimum amount
		               *
		               IF THIS.lRelMin AND m.nNetOwn > 0
		                  REPL nNewNet WITH nNetWell
		               ELSE
		                  * If the total owner suspense is positive, clear all well entries
		                  IF m.nNetOwn > 0 AND nNetWell > 0
		                     REPL nNewNet WITH nNetWell
		                  ENDIF
		               ENDIF
		            ENDSCAN
		         CASE tcType = 'W'
		            SCAN FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		               IF m.nNetOwn < 0
		                  m.nNetPct = nNetWell/m.nNetOwn
		                  IF nNetWell < 0 AND m.nNetOwn < 0
		                     m.nNetPct = m.nNetPct * -1
		                  ENDIF
		                  IF nNetWell > 0 AND m.nNetOwn < 0
		                     m.nNetPct = m.nNetPct * -1
		                  ENDIF
		               ELSE
		                  IF m.nNetOwn > 0
		                     m.nNetPct = 1
		                  ELSE
		                     m.nNetPct = 0
		                  ENDIF
		               ENDIF
		               REPL nNetPct WITH m.nNetPct
		               *
		               *  If minimums are being released plug in the minimum amount
		               *
		               IF THIS.lRelMin AND m.nNetOwn > 0
		                  REPL nNewNet WITH nNetWell
		               ELSE
		                  IF m.nNetOwn > 0 AND nNetWell > 0
		                     REPL nNewNet WITH nNetWell
		                  ENDIF
		               ENDIF
		            ENDSCAN
		      ENDCASE
		   ENDSCAN
		ELSE
		   SELECT suspbalownP
		   SCAN
		      SCATTER MEMVAR
		      SELECT suspbalwellP
		      SCAN FOR cOwnerID = m.cOwnerID AND cProgCode = m.cProgCode
		         IF m.nNetOwn < 0
		            m.nNetPct = nNetWell/m.nNetOwn
		            IF nNetWell < 0 AND m.nNetOwn < 0
		               m.nNetPct = m.nNetPct * -1
		            ENDIF
		            IF nNetWell > 0 AND m.nNetOwn < 0
		               m.nNetPct = m.nNetPct * -1
		            ENDIF
		         ELSE
		            IF m.nNetOwn > 0
		               m.nNetPct = 1
		            ELSE
		               m.nNetPct = 0
		            ENDIF
		         ENDIF
		         REPL nNetPct WITH m.nNetPct
		         *
		         *  If minimums are being released plug in the minimum amount
		         *
		         IF THIS.lRelMin AND m.nNetOwn > 0
		            REPL nNewNet WITH nNetWell
		         ELSE
		            IF m.nNetOwn > 0 
		               REPL nNewNet WITH nNetWell
		            ENDIF
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		ENDIF
		*
		*  Look to see what can be covered with the current months positive amount
		*
		SELECT totals
		SCAN FOR nTotal >= 0
		   SCATTER MEMVAR
		   IF tcType <> 'P'
		      SELECT suspbalown
		      LOCATE FOR cOwnerID = m.cOwnerID
		   ELSE
		      SELECT suspbalownP
		      LOCATE FOR cOwnerID = m.cOwnerID AND cProgCode = m.cProgCode
		   ENDIF
		   IF FOUND()
		      m.nNetOwn = nNetOwn
		   ELSE
		      m.nNetOwn = 0
		   ENDIF
		
		   DO CASE
		      CASE tcType = 'O'
		         SELECT suspbalwell
		         SCAN FOR cOwnerID = m.cOwnerID
		            SCATTER MEMVAR
		            IF m.nNetOwn > 0
		               m.nNewNet = m.nNetWell
		            ELSE
		               IF m.nTotal >= ABS(m.nNetOwn)
		                  * There's enough revenue to cover all deficits
		                  m.nNewNet = m.nNetWell
		               ELSE
		                  * There's not enough revenue to cover all deficits
		                  m.nNewNet = swROUND(m.nNetPct * m.nTotal,2)
		               ENDIF
		            ENDIF
		
		            IF m.nNetWell <> 0
		               lnPct = swround(m.nNewNet / m.nNetWell,12)
		            ELSE
		               lnPct = 0
		            ENDIF
		
		            m.nNewInc  = swROUND(m.nIncome * lnPct,2)
		            m.nNewTax  = swROUND(m.nTaxes  * lnPct,2)
		            m.nNewExp  = swROUND(m.nExpenses * lnPct,2)
		
		            SELECT suspbalwell
		            REPL nNewInc WITH m.nNewInc, ;
		               nNewTax WITH m.nNewTax, ;
		               nNewExp WITH m.nNewExp, ;
		               nNewNet WITH m.nNewNet
		
		         ENDSCAN
		      CASE tcType = 'P'
		         SELECT suspbalwellP
		         SCAN FOR cOwnerID = m.cOwnerID  AND cProgCode = m.cProgCode
		            SCATTER MEMVAR
		            SELECT suspbalownP
		            LOCATE FOR cOwnerID = m.cOwnerID AND cProgCode = m.cProgCode
		            IF FOUND()
		               m.nNetOwn = nNetOwn
		            ELSE
		               m.nNetOwn = 0
		            ENDIF
		            IF m.nNetOwn > 0
		               m.nNewNet = m.nNetWell
		            ELSE
		               IF m.nTotal >= ABS(m.nNetOwn)
		                  * There's enough revenue to cover all deficits
		                  m.nNewNet = nNetWell
		               ELSE
		                  * There's not enough revenue to cover all deficits
		                  m.nNewNet = swROUND(m.nNetPct * m.nTotal,2)
		               ENDIF
		            ENDIF
		
		            IF m.nNetWell <> 0
		               lnPct = m.nNewNet / m.nNetWell
		            ELSE
		               lnPct = 0
		            ENDIF
		
		            m.nNewInc  = swROUND(m.nIncome * lnPct,2)
		            m.nNewTax  = swROUND(m.nTaxes  * lnPct,2)
		            m.nNewExp  = swROUND(m.nExpenses * lnPct,2)
		
		            SELECT suspbalwellP
		            REPL nNewInc WITH m.nNewInc, ;
		               nNewTax WITH m.nNewTax, ;
		               nNewExp WITH m.nNewExp, ;
		               nNewNet WITH m.nNewNet
		
		         ENDSCAN
		      CASE tcType = 'W'
		         SELECT suspbalwell
		         SCAN FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		            SCATTER MEMVAR
		            SELECT suspbalown
		            LOCATE FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		            IF FOUND()
		               m.nNetOwn = nNetOwn
		            ELSE
		               m.nNetOwn = 0
		            ENDIF
		            IF m.nNetOwn > 0
		               m.nNewNet = m.nNetWell
		            ELSE
		               IF m.nTotal >= ABS(m.nNetOwn)
		                  * There's enough revenue to cover all deficits
		                  m.nNewNet = nNetWell
		               ELSE
		                  * There's not enough revenue to cover all deficits
		                  m.nNewNet = swROUND(m.nNetPct * m.nTotal,2)
		               ENDIF
		            ENDIF
		
		            IF m.nNetWell <> 0
		               lnPct = m.nNewNet / m.nNetWell
		            ELSE
		               lnPct = 0
		            ENDIF
		
		            m.nNewInc  = swROUND(m.nIncome * lnPct,2)
		            m.nNewTax  = swROUND(m.nTaxes  * lnPct,2)
		            m.nNewExp  = swROUND(m.nExpenses * lnPct,2)
		
		            SELECT suspbalwell
		            REPL nNewInc WITH m.nNewInc, ;
		               nNewTax WITH m.nNewTax, ;
		               nNewExp WITH m.nNewExp, ;
		               nNewNet WITH m.nNewNet
		
		         ENDSCAN
		   ENDCASE
		ENDSCAN
		
		sele cownerid, sum(nnewnet) as nnewnet from suspbalwell into cursor tempbalwell order by cownerid group by cownerid 
		
		sele tempbalwell
		scan for nnewnet < 0
		   scatter memvar
		   sele totals
		   locate for cownerid=m.cownerid
		   if found() and ntotal > 0
		      m.ntotal = ntotal
		      lnDiff = m.nTotal + m.nNewNet
		      if lnDiff <> 0 and ABS(lnDiff) <= .05
		         sele suspbalwell
		         locate for cownerid = m.cownerid
		         if found()
		            repl nNewNet with nNewNet - lnDiff
		         endif
		      endif
		   endif
		endscan            
		         
		if this.lDebug
		   this.timekeeper('Ending calcsuspense')  
		endif   
		         
	ENDPROC

	PROCEDURE checkactivity
		****************************************************************************
		*  Check for Any Activity During Period Range
		****************************************************************************
		if this.lDebug
		   this.timekeeper('Starting checkactivity')  
		endif   
		
		lnCount = 0
		STORE 0 TO m.counti, m.counte
		SELECT welltemp
		SCAN
		   m.cWellID = cWellID
		   SELECT wells
		   SET ORDER TO cWellID
		   IF SEEK(m.cWellID)
		      SELE wellwork
		      SCAN FOR cWellID = m.cWellID
		         m.cYEAR   = hyear
		         m.cPeriod = hperiod
		         SELECT income
		            SCAN FOR cWellID = m.cWellID AND (nRunNo = 0 OR (nRunNo = THIS.nRunNo AND cRunYear = THIS.cRunYear))
		               m.counti = m.counti + 1
		            ENDSCAN
		            SELE expense
		            SCAN FOR cWellID = m.cWellID AND (nRunNoRev = 0 OR (nRunNoRev = THIS.nRunNo AND cRunYearRev = THIS.cRunYear))
		               m.counte = m.counte + 1
		            ENDSCAN
		         lnCount = lnCount + m.counti + m.counte
		         IF lnCount > 0
		            SELECT welltemp
		            GO bott
		         ENDIF 
		      ENDSCAN
		   ENDIF
		   lnFlatO = THIS.getflatamt(m.cWellID,'O')
		   lnFlatG = THIS.getflatamt(m.cWellID,'G')
		   IF lnFlatO+lnFlatG > 0
		      lnCount = 1
		   ENDIF
		ENDSCAN
		
		
		if this.lDebug
		   this.timekeeper('Ending checkactivity')  
		endif   
		
		IF lnCount = 0
		   IF NOT THIS.lquiet
		*      THIS.oMessage.Warning('%msgNoActivity')
		   ENDIF
		   RETURN .F.
		ELSE
		   RETURN .T.
		ENDIF
		
	ENDPROC

	PROCEDURE checkbacktax		&& Checks for negative backup and tax withholding and makes corrections if any are found.
		*
		*  Build a cursor of backup and tax withholding totals for the run by owner
		*
		if this.lDebug
		   this.timekeeper('Starting checkbacktax')  
		endif   
		
		sele cownerid, sum(nbackwith) as nbackwith, sum(ntaxwith) as ntaxwith ;
		   from invtmp ;
		   into cursor backtax ;
		   order by cownerid ;
		   group by cownerid
		   
		if _Tally > 0
		 
		   *  Scan through the totals looking for negative backup and/or tax withholding amounts
		   sele backtax
		   scan 
		      scatter memvar
		      
		      * If there are negative backup withholding amounts, add them back into the netcheck and zero them out
		      if m.nbackwith < 0
		         sele invtmp
		         scan for cownerid = m.cownerid
		           repl nnetcheck with nnetcheck + nbackwith, ;
		                nbackwith with 0
		         endscan
		      endif
		      
		      * If there are negative tax withholding amounts, add them back into the netcheck and zero them out
		      if m.ntaxwith < 0
		         sele invtmp
		         scan for cownerid = m.cownerid
		           repl nnetcheck with nnetcheck + ntaxwith, ;
		                ntaxwith  with 0
		         endscan
		      endif
		   endscan
		endif      
		            
		if this.lDebug
		   this.timekeeper('Ending checkbacktax')  
		endif   
		           
	ENDPROC

	PROCEDURE checkhist		&& Checks to see if the period is closed.
		LOCAL llHist, llSepClose, lcDeleted
		*
		*  Checks to see if the given period is closed
		*  Returns .T. if the period is closed
		*
		IF this.lErrorFlag 
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting checkhist')  
		endif   
		
		lcDeleted = SET('DELETED')
		SET DELETED ON
		
		llHist = .F.
		
		IF this.cGroup = '**'
		   SELECT sysctl
		   LOCATE FOR cyear+cperiod = this.cRunYear+this.cPeriod AND lDisbMan AND cTypeClose = 'R'
		   IF FOUND()
		      llHist = .T.
		      this.lRelMin = sysctl.lRelMin
		      this.cdmbatch = sysctl.cdmbatch
		   ENDIF   
		ELSE
		   SELECT sysctl
		   SET ORDER TO yrprdgrp
		   IF SEEK(this.cRunYear+this.cPeriod+this.cGroup+'YR')
		      llHist = .T.
		      this.lRelMin = sysctl.lRelMin
		      this.cdmbatch = sysctl.cdmbatch
		   ENDIF
		ENDIF
		
		SET DELETED &lcDeleted
		
		if this.lDebug
		   this.timekeeper('Ending checkhist')  
		endif   
		
		RETURN (llHist)
		
	ENDPROC

	PROCEDURE checkhistrun		&& Checks to see if a run no has been closed
		LOCAL llHist, llSepClose, lcDeleted
		*
		*  Checks to see if the given period is closed
		*  Returns .T. if the period is closed
		*
		IF this.lErrorFlag 
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting checkhistrun')  
		endif   
		
		lcDeleted = SET('DELETED')
		SET DELETED ON
		
		llHist = .F.
		
		IF this.cGroup = '**'
		   SELECT sysctl
		   LOCATE FOR cYear == this.cRunYear AND nRunNo = THIS.nRunNo AND lDisbMan AND cTypeClose = 'R'
		   IF FOUND()
		      llHist = .T.
		      this.lRelMin = sysctl.lRelMin
		      this.lRelQtr = sysctl.lRelQtr
		   ENDIF   
		ELSE
		   SELECT sysctl
		   LOCATE FOR cYear == this.cRunYear AND nRunNo = this.nrunno AND cGroup = THIS.cGroup AND cTypeClose='R'
		   IF FOUND()
		      llHist = .T.
		      this.lRelMin = sysctl.lRelMin
		      this.lRelQtr = sysctl.lRelQtr
		   ENDIF
		ENDIF
		
		SET DELETED &lcDeleted
		
		if this.lDebug
		   this.timekeeper('Ending checkhistrun')  
		endif   
		
		RETURN (llHist)
		
	ENDPROC

	PROCEDURE checkquarterly		&& Check for quarterly wells.
		*
		*  Checks for quarterly wells in the wells table
		*
		
		if this.lDebug
		   this.timekeeper('Starting checkquarterly')  
		endif   
		
		IF NOT THIS.CheckHistRun()
		   SELE wells
		   LOCATE FOR nProcess = 2
		   IF FOUND()
		      THIS.lRelQtr = THIS.omessage.CONFIRM('Should the quarterly wells be released during this run?')   
		   ENDIF   
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Ending checkquarterly')  
		endif   
		
		
		
		
		
	ENDPROC

	PROCEDURE checkquarterlyhist		&& Determines whether quarterly wells were processed for a given run.
	ENDPROC

	PROCEDURE closeproc		&& Closes the revenue period.
		LOCAL oProgress, llReturn1, llReturn2
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		STORE .T. TO llReturn1, llReturn2
		
		*
		*  Mark the Revenue period as being closed
		*
		m.cDMBatch   = THIS.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		
		m.cidsysctl  = THIS.oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		SET DELETED OFF
		SELECT sysctl
		SET ORDER TO cidsysctl
		DO WHILE SEEK(m.cidsysctl)
		   m.cidsysctl  = THIS.oRegistry.IncrementCounter('%Shared.Counters.Sysctl')
		ENDDO
		
		SET DELETED ON
		THIS.cSysCtlKey = m.cidsysctl
		THIS.cDMBatch = m.cDMBatch
		m.cPeriod    = THIS.cPeriod
		m.cYear      = THIS.cRunYear
		m.cRunYear   = THIS.cRunYear
		m.dAcctDate  = THIS.dAcctDate
		m.dPostDate  = THIS.dPostDate
		m.dRevDate   = THIS.dRevDate
		m.dExpDate   = THIS.dExpDate
		m.cGroup     = THIS.cGroup
		m.dDateClose = DATE()
		m.cTimeClose = TIME()
		m.cTypeClose = 'R'
		m.lRelMin    = THIS.lRelMin
		m.lRelQtr    = THIS.lRelQtr
		m.lCloseYear = .F.
		m.lDisbMan   = .T.
		m.nRunNo     = THIS.nRunNo
		m.lCompanyPost = THIS.CompanyPost
		INSERT INTO sysctl FROM MEMVAR
		
		THIS.calcround(.T.)
		
		*
		*  Check for non-jib wells, replace jib runno with rev runno if well is all net
		*
		this.allnetcheck()
		
		*
		*  Add the owner history and well history records.
		*
		llReturn1 = THIS.addhist()
		
		*
		*  Plug in the royalty and working interest totals to wellhist
		*
		THIS.roywork()
		
		*
		*  Perform suspense processing
		*
		SELECT groups
		SET ORDER TO cGroup
		IF SEEK(THIS.cGroup)
		   llNetDef = lNetDef
		ELSE
		   llNetDef = .T.
		ENDIF
		
		IF llNetDef
		   THIS.susp_by_owner()
		ELSE
		   THIS.susp_by_well()
		ENDIF
		
		IF this.lQBVersion
		   *  Save suspense history
		   THIS.savesusp()
		   *   Create Investor and Vendor Checks
		   THIS.ownerchks()
		   THIS.vendorchks()
		   this.directdeposit()
		ENDIF   
		
		*
		*  Mark the expense entries as being tied to this DM batch
		*
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Marking Expenses as Processed...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		SELECT expense
		SCAN FOR nRunNoRev = THIS.nRunNo ;
		      AND cRunYearRev = THIS.cRunYear ;
		      AND EMPTY(expense.cBatch)
		   SELECT expense
		   REPL cBatch WITH THIS.cDMBatch
		ENDSCAN
		
		*
		*  Store check keys in owner history
		*
		*!*	SELE invtmp
		*!*	SCAN FOR NOT EMPTY(cidchec)
		*!*	   m.cownerid = cownerid
		*!*	   WAIT WIND NOWAIT 'Storing Check Keys In Owner History.... ' + m.cownerid
		*!*	   m.cidchec  = cidchec
		*!*	   sele disbhist
		*!*	   scan for cownerid = m.cownerid and nrunno = this.nrunno and crunyear=this.crunyear
		*!*	      repl cidchec with m.cidchec
		*!*	   endscan    
		*!*	ENDSCAN
		*!*	WAIT CLEAR   
		
		*
		*  Create the journal entries
		*
		
		IF NOT THIS.lQBVersion
		   if file('summarypost.cfg')
		      llReturn2 = THIS.postsummary()
		   else
		      llReturn2 = THIS.postjourn()
		   endif      
		ENDIF
		
		IF NOT llReturn1 OR NOT llReturn2 OR THIS.lErrorFlag
		   *
		   *  Rollback the entries
		   *
		   sele sysctl
		   dele for cidsysctl = this.csysctlkey
		   RETURN .F.
		ELSE
		   *
		   *  Save the entries
		   *
		   this.oProgress.SetProgressMessage('Committing File Changes...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		      IF NOT THIS.lQBVersion
		      llOK = .T.
		      BEGIN TRANSACTION
		      SELE disbhist
		      llOK = TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE ownpcts
		      llOK = TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE glmaster
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE wellhist
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE susaudit
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE sysctl
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE coabal
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE checks
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE expense
		      llOK = TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE income
		      llOK = TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      END TRANSACTION
		   ELSE
		      llOK = .T.
		      BEGIN TRANSACTION
		      SELE disbhist
		      llOK = TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE ownpcts
		      llOK = TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE wellhist
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE susaudit
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE sysctl
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE checks
		      llOK =TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE expense
		      llOK = TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      SELE income
		      llOK = TABLEUPDATE(.T.)
		      IF NOT llOK
		         ROLLBACK
		         RETURN .F.
		      ENDIF
		      END TRANSACTION
		
		   ENDIF
		   THIS.calcsummary()
		   WAIT WIND NOWAIT 'Calculating the suspense summary reports...'
		   THIS.printsuspense()
		
		   IF THIS.omessage.CONFIRM('Should a register of checks created this period be printed?')
		      THIS.prechk()
		   ENDIF
		
		   IF m.goApp.lAMVersion
		      IF THIS.omessage.CONFIRM('Should a report of unallocated revenue and expenses as of this period be printed?')
		         THIS.unallrpt()
		      ENDIF
		   ENDIF
		
		   WAIT CLEAR
		   RETURN .T.
		ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		LOCAL lcDeleted
		
		lcDeleted = this.cdeleted
		if used('debugtime')
		   use in debugtime
		endif   
		SET DELETED &lcDeleted
		
		DODEFAULT()
	ENDPROC

	PROCEDURE directdeposit		&& Creates the direct deposit file for owners who are direct deposited.
	ENDPROC

	PROCEDURE dp_checkdigit		&& Calculates check digit from bank aba
		lpara tcABA
		local lndig1, lndig2, lndig3, lndig4, lndig5, lndig6, lndig7, lndig8
		local lndigits, lnfactor, lncheckdigit, lccheckdigit
		
		if not type('tcaba') = 'C'
		   wait wind 'The Bank ABA number must be passed to dp_checkdigit'
		   return
		endif
		
		
		lndig1 = val(subst(tcABA,1,1)) * 3
		lndig2 = val(subst(tcABA,2,1)) * 7
		lndig3 = val(subst(tcABA,3,1)) * 1
		lndig4 = val(subst(tcABA,4,1)) * 3
		lndig5 = val(subst(tcABA,5,1)) * 7
		lndig6 = val(subst(tcABA,6,1)) * 1
		lndig7 = val(subst(tcABA,7,1)) * 3
		lndig8 = val(subst(tcABA,8,1)) * 7
		
		lnDigits = lndig1 + lndig2 + lndig3 + lndig4 + lndig5 + lndig6 + lndig7 + lndig8
		
		lnFactor = lnDigits/10
		
		lnFactor = ROUND(lnFactor,0)
		
		lnFactor = lnFactor * 10
		
		lnCheckDigit = lnFactor - lnDigits
		
		lcCheckDigit = str(lnCheckDigit,1)
		
		RETURN(lcCheckDigit)
		
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		LOCAL lnLevel, lnX
		
		THIS.lErrorFlag = .T.
		
		=AERROR(gaerrors)
		
		DO errorlog WITH m.cMethod, m.nLine, 'DISTPROC'
		
		*
		*  Remove the QuickBooks Transactions
		*
		
		* add a request to delete the receipt
		IF this.lQBversion AND TYPE('THIS.oRequest') = 'O'
		   lcXml = THIS.oRequest.toxmlstring()
		   IF NOT USED('qbxml')
		      USE (m.goapp.cCommonFolder+'qbxml') IN 0
		   ENDIF
		   IF USED('qbxml')
		      INSERT INTO qbxml VALUES('Error',DATETIME(),lcXml)
		   ENDIF 
		   *  Get a message set request object (version 3.0 xml)
		   THIS.oRequest = m.goApp.oQB.oQBRequest
		
		   * set the on error attribute for the request
		   THIS.oRequest.ATTRIBUTES.OnError = 1
		   THIS.oRequest.ClearRequests()
		
		   WAIT WIND NOWAIT 'Cleaning Up QuickBooks Journal Entries...'
		   SELE sysctl
		   LOCATE FOR cDMBatch = THIS.cDMBatch
		   IF FOUND()
		      m.cidsysctl = cidsysctl
		      SELE qbpost
		      LOCATE FOR cidsysctl = m.cidsysctl and not deleted()
		      IF FOUND()
		         lcTxnIDs = mtxnids
		         m.ntype = ntype
		         lnCount = ALINES(laTxnid,lcTxnIDs)
		         IF lnCount > 0
		            FOR lnX = 1 TO lnCount
		               lcTxnID = PADR(ALLT(laTxnid[lnX]),36,' ')
		               loJournalDel = THIS.oRequest.AppendTxnDelRq()
		               loJournalDel.TxnDelType.SetValue(m.ntype)
		               loJournalDel.TxnID.SetValue(lcTxnID)
		
		               loResponse = m.goApp.oQB.oQBSM.DoRequests(THIS.oRequest)
		               loDelResp  = loResponse.responselist.getat(0)
		               IF loDelResp.StatusCode <> 0
		*                  wait wind nowait loDelResp.StatusMessage
		               ENDIF
		               m.goApp.oQB.oQBSM.ClearErrorRecovery()
		               THIS.oRequest.ClearRequests()
		            ENDFOR
		            SELE qbpost
		            DELE NEXT 1
		         ENDIF
		      ENDIF
		      WAIT CLEAR
		   ENDIF
		ENDIF
		
		IF BETWEEN(m.nError,1426,1429)
		   THIS.qberror()
		ELSE
		
		   lnLevel = TXNLEVEL()
		
		   IF lnLevel > 0
		      FOR lnX = 1 TO lnLevel
		         ROLLBACK
		      ENDFOR
		   ENDIF
		
		   DODEFAULT(nError,cMethod,nLine)
		ENDIF
		
	ENDPROC

	PROCEDURE expenseupd		&& Marks the expenses as having been paid
		LPARA tcVendor, tcidChec
		LOCAL tcYear, tcPeriod, tcGroup
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting expenseupd')  
		endif   
		
		tcYear   = THIS.cRunYear
		tcPeriod = THIS.cPeriod
		tcGroup  = THIS.cGroup
		
		SELE expense
		SCAN FOR nRunNoRev = THIS.nRunNo ;
		      AND cRunYearRev = tcYear ;
		      AND cVendorID = tcVendor ;
		      AND EMPTY(cPaidByCk) ;
		      AND lAPTran = .F.
		
		   m.cwellid = cwellid
		   SELE wells
		   LOCATE FOR cwellid = m.cwellid
		   IF FOUND() AND nProcess = 2
		      IF NOT THIS.lrelqtr
		         LOOP
		      ENDIF
		   ENDIF
		   SELE expense
		   REPLACE cPaidByCk WITH tcidChec
		ENDSCAN
		
		if this.lDebug
		   this.timekeeper('Ending expenseupd')  
		endif   
		
		
		
		
	ENDPROC

	PROCEDURE fileio		&& Write low level file
		LPARA handle, bytes
		
		=FWRITE(handle,bytes)
		IF ferror() > 0
		   DO CASE
		      CASE ferror() = 4
		           m.msg = 'TOO MANY FILE OPEN (OUT OF HANDLES)'
		      CASE ferror() = 5
		           m.msg = 'FILE ACCESS DENIED'
		      CASE ferror() = 8
		           m.msg = 'OUT OF MEMORY'
		      CASE ferror() = 29
		           m.msg = 'DISK FULL (OUT OF SPACE)'
		      CASE ferror() = 31
		           m.msg = 'GENERAL FAILURE'
		      OTHERWISE     
		           m.msg = 'UNKNOWN DISK FAILURE' + STR(ferror(),3)
		   ENDCASE                            
		   WAIT WIND 'FILE WRITE ERROR: ' + m.msg
		ENDIF  
		
		RETURN 
		
	ENDPROC

	PROCEDURE getflatamt		&& Returns the given flat rate royalty amount.
		LPARA tcWellId, tcType
		LOCAL lcCurrent, lnCount, lnBBL, lnMCF, lnAmount, lcAcctMonth, ldAcctdate
		
		STORE 0 TO lnBBL, lnMCF, lnAmount
		
		IF THIS.lErrorFlag
		   RETURN (0)
		ENDIF
		
		if not this.lFlatRates
		   RETURN 0
		ENDIF
		
		   
		ldAcctdate = THIS.dAcctDate
		IF TYPE('ldAcctDate') <> 'D'
		   ldAcctdate = DATE()
		ENDIF
		
		* Check for flat rates in this well, if none exist return zero.
		SELECT wellinv
		LOCATE FOR cWellID = tcWellId AND lFlat = .T.
		IF NOT FOUND()
		   RETURN (0)
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting getflatamt')  
		endif   
		
		lcAcctMonth = PADL(ALLTRIM(STR(MONTH(ldAcctdate),2)),2,'0')
		lcCurrent = SELECT()
		
		SELECT ctypeint, cFlatStart, nFlatFreq, SUM(nflatrate) AS nflatrate FROM wellinv ;
		   WHERE cWellID = tcWellId AND lFlat ;
		   ORDER BY cFlatStart, nFlatFreq ;
		   GROUP BY cFlatStart, nFlatFreq ;
		   INTO CURSOR temp
		IF _TALLY > 0
		   SELECT temp
		   SCAN
		      if ctypeint <> 'B' and cTypeint <> tcType
		         loop
		      endif   
		      DO CASE
		         CASE ctypeint = 'B' and tctype = 'O'
		            lnamount = 0
		         CASE nFlatFreq = 1 OR nFlatFreq = 0
		            lnAmount = lnAmount + nflatrate
		         CASE nFlatFreq = 2
		            DO CASE
		               CASE LEFT(cFlatStart,2) = '01'
		                  lcQtr1 = '01'
		                  lcQtr2 = '04'
		                  lcQtr3 = '07'
		                  lcQtr4 = '10'
		               CASE LEFT(cFlatStart,2) = '02'
		                  lcQtr1 = '02'
		                  lcQtr2 = '05'
		                  lcQtr3 = '08'
		                  lcQtr4 = '11'
		               CASE LEFT(cFlatStart,2) = '03'
		                  lcQtr1 = '03'
		                  lcQtr2 = '06'
		                  lcQtr3 = '09'
		                  lcQtr4 = '12'
		               CASE LEFT(cFlatStart,2) = '04'
		                  lcQtr1 = '04'
		                  lcQtr2 = '07'
		                  lcQtr3 = '10'
		                  lcQtr4 = '01'
		               CASE LEFT(cFlatStart,2) = '05'
		                  lcQtr1 = '05'
		                  lcQtr2 = '08'
		                  lcQtr3 = '11'
		                  lcQtr4 = '02'
		               CASE LEFT(cFlatStart,2) = '06'
		                  lcQtr1 = '06'
		                  lcQtr2 = '09'
		                  lcQtr3 = '12'
		                  lcQtr4 = '03'
		               CASE LEFT(cFlatStart,2) = '07'
		                  lcQtr1 = '07'
		                  lcQtr2 = '10'
		                  lcQtr3 = '01'
		                  lcQtr4 = '04'
		               CASE LEFT(cFlatStart,2) = '08'
		                  lcQtr1 = '08'
		                  lcQtr2 = '11'
		                  lcQtr3 = '02'
		                  lcQtr4 = '05'
		               CASE LEFT(cFlatStart,2) = '09'
		                  lcQtr1 = '09'
		                  lcQtr2 = '12'
		                  lcQtr3 = '03'
		                  lcQtr4 = '06'
		               CASE LEFT(cFlatStart,2) = '10'
		                  lcQtr1 = '10'
		                  lcQtr2 = '01'
		                  lcQtr3 = '04'
		                  lcQtr4 = '07'
		               CASE LEFT(cFlatStart,2) = '11'
		                  lcQtr1 = '11'
		                  lcQtr2 = '02'
		                  lcQtr3 = '05'
		                  lcQtr4 = '08'
		               CASE LEFT(cFlatStart,2) = '12'
		                  lcQtr1 = '12'
		                  lcQtr2 = '03'
		                  lcQtr3 = '06'
		                  lcQtr4 = '09'
		               OTHERWISE
		                  lcQtr1 = '01'
		                  lcQtr2 = '04'
		                  lcQtr3 = '07'
		                  lcQtr4 = '10'
		            ENDCASE
		            IF INLIST(lcAcctMonth,lcQtr1,lcQtr2,lcQtr3,lcQtr4)
		               lnAmount = lnAmount + nflatrate
		            ENDIF
		         CASE nFlatFreq = 3
		            DO CASE
		               CASE LEFT(cFlatStart,2) = '01'
		                  lcSem1 = '01'
		                  lcSem2 = '07'
		               CASE LEFT(cFlatStart,2) = '02'
		                  lcSem1 = '02'
		                  lcSem2 = '08'
		               CASE LEFT(cFlatStart,2) = '03'
		                  lcSem1 = '03'
		                  lcSem2 = '09'
		               CASE LEFT(cFlatStart,2) = '04'
		                  lcSem1 = '04'
		                  lcSem2 = '10'
		               CASE LEFT(cFlatStart,2) = '05'
		                  lcSem1 = '05'
		                  lcSem2 = '11'
		               CASE LEFT(cFlatStart,2) = '06'
		                  lcSem1 = '06'
		                  lcSem2 = '12'
		               CASE LEFT(cFlatStart,2) = '07'
		                  lcSem1 = '07'
		                  lcSem2 = '01'
		               CASE LEFT(cFlatStart,2) = '08'
		                  lcSem1 = '08'
		                  lcSem2 = '02'
		               CASE LEFT(cFlatStart,2) = '09'
		                  lcSem1 = '09'
		                  lcSem2 = '03'
		               CASE LEFT(cFlatStart,2) = '10'
		                  lcSem1 = '10'
		                  lcSem2 = '04'
		               CASE LEFT(cFlatStart,2) = '11'
		                  lcSem1 = '11'
		                  lcSem2 = '05'
		               CASE LEFT(cFlatStart,2) = '12'
		                  lcSem1 = '12'
		                  lcSem2 = '06'
		               OTHERWISE
		                  lcSem1 = '01'
		                  lcSem2 = '07'
		            ENDCASE
		            IF INLIST(lcAcctMonth,lcSem1,lcSem2)
		               lnAmount = lnAmount + nflatrate
		            ENDIF
		         CASE nFlatFreq = 4
		            IF LEFT(cFlatStart,2) = lcAcctMonth
		               lnAmount = lnAmount + nflatrate
		            ENDIF
		         OTHERWISE
		            lnAmount = lnAmount + nflatrate
		      ENDCASE
		   ENDSCAN
		ELSE
		   lnAmount = 0
		ENDIF
		
		STORE 0 TO lnMCF, lnBBL
		
		*  Get total mcf for this run if we have flat rate per mcf owners
		SELECT wellinv
		LOCATE FOR cWellID = tcWellId AND lFlat and nFlatMCF <> 0
		IF FOUND()
		   SELE sum(nunits) AS nTotMCF FROM income ;
		      WHERE cSource = 'MCF' AND (nrunno = 0 OR (nrunno = THIS.nrunno AND crunyear=THIS.crunyear)) AND drevdate <= THIS.dRevDate ;
		        AND cwellid == tcWellID ;
		      INTO CURSOR inctmp 
		   sele inctmp
		   go top
		   lnMCF = nTotMCF   
		ENDIF
		
		* Get total bbl for this run if we have flat rate per bbl owners
		SELECT wellinv
		LOCATE FOR cWellID = tcWellId AND lFlat and nFlatBBL <> 0
		IF FOUND()
		   SELE sum(nunits) AS nTotBBL FROM income ;
		      WHERE cSource = 'BBL' AND (nrunno = 0 OR (nrunno = THIS.nrunno AND crunyear=THIS.crunyear)) AND drevdate <= THIS.dRevDate ;
		        AND cwellid == tcWellID ;
		      INTO CURSOR inctmp 
		   sele inctmp
		   go top
		   lnBBL = nTotBBL
		ENDIF
		
		STORE 0 TO lnFlatMCF, lnFlatBBL
		
		*  Calculate the total flat rate per mcf total for the well
		IF tcType = 'G'
		   SELECT wellinv
		   SCAN FOR cWellID = tcWellId AND lFlat and nFlatMCF <> 0
		      lnFlatMCF = lnFlatMCF + ROUND(nFlatMCF * lnMCF,2)
		   ENDSCAN
		ENDIF   
		
		*  Calculate the total flat rate per bbl total for the well
		IF tcType = 'O'
		   SELECT wellinv
		   SCAN FOR cWellID = tcWellId AND lFlat and nFlatBBL <> 0
		      lnFlatBBL = lnFlatBBL + ROUND(nFlatBBL * lnBBL,2)
		   ENDSCAN
		ENDIF   
		
		* Add the flat rate, flat rate per mcf and flat rate per bbl totals
		lnAmount = lnAmount + lnFlatMCF + lnFlatBBL
		
		SELECT (lcCurrent)
		
		if this.lDebug
		   this.timekeeper('Ending getflatamt')  
		endif   
		
		RETURN (lnAmount)
		
	ENDPROC

	PROCEDURE gethist		&& Retrieves owner and well history records from closed periods.
		LOCAL lnCount, lnMax, lnX, lcBegID, lcEndID, lcRunYear
		
		lcRunYear = this.crunyear+PADL(TRANSFORM(this.nrunno),3,'0')
		
		STORE 0 TO lnCount, lnMax, lnX
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Starting gethist')
		ENDIF
		
		****************************************************************
		*   Create Temp Investor Disbursement File
		****************************************************************
		SWSELECT('disbhist')
		lnX=AFIELDS(latempx)
		SWSELECT('ownpcts')
		lny=AFIELDS(latempy)
		DIMENSION laTemp[lnx+lny-1,18]
		FOR x = 1 TO lnX
		   FOR Y = 1 TO 18
		      laTemp[x,y] = latempx[x,y]
		   ENDFOR
		ENDFOR
		FOR x = 1 TO lny - 1
		   FOR Y = 1 TO 18
		      laTemp[x+lnx,y] = latempy[x+1,y]
		   ENDFOR
		ENDFOR
		FOR x = 1 TO lnX+lny - 1
		   laTemp[X,7] = ''
		   laTemp[X,8] = ''
		   laTemp[X,9] = ''
		   laTemp[X,10] = ''
		   laTemp[X,11] = ''
		   laTemp[X,12] = ''
		   laTemp[X,13] = ''
		   laTemp[X,14] = ''
		   laTemp[X,15] = ''
		   laTemp[X,18] = ''
		ENDFOR
		CREATE CURSOR invtmp FROM ARRAY laTemp
		
		IF NOT THIS.lQuiet
		   IF THIS.cGroup = '**'
		      SELECT disbhist
		      COUNT FOR cRunYear+PADL(TRANSFORM(nrunno),3,'0') = lcRunYear    ;
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) AND cRecType = 'R' TO lnX
		      lnMax = lnMax + lnX
		      SELECT wellhist
		      COUNT FOR nRunNo = THIS.nRunNo AND cRunYear = THIS.cRunYear   ;
		         AND BETWEEN(cWellID,THIS.cBegWellID,THIS.cEndWellID) AND cRecType = 'R'  TO lnX
		      lnMax = lnMax + lnX
		   ELSE
		      SELECT disbhist
		      COUNT FOR cRunYear+PADL(TRANSFORM(nrunno),3,'0') = lcRunYear    ;
		         AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) AND cRecType = 'R'  ;
		         AND cGroup = THIS.cGroup TO lnX
		      lnMax = lnMax + lnX
		      SELECT wellhist
		      COUNT FOR  nRunNo = THIS.nRunNo AND cRunYear = THIS.cRunYear     ;
		         AND BETWEEN(cWellID,THIS.cBegWellID,THIS.cEndWellID) AND cRecType = 'R'  ;
		         AND cGroup = THIS.cGroup TO lnX
		      lnMax = lnMax + lnX
		   ENDIF
		   IF NOT THIS.lQuiet
		      oProgress = THIS.oMessage.ProgressBar('Retrieving history records...')
		      oProgress.SetProgressRange(0,lnMax)
		   ENDIF
		ENDIF
		
		SELECT disbhist
		IF THIS.cGroup = '**'          && All Groups
		   SELECT disbhist.*, ownpcts.* FROM disbhist, ownpcts ;
		      WHERE  cRunYear+PADL(TRANSFORM(nrunno),3,'0') = lcRunYear    ;
		      AND cRecType = 'R'  ;
		      AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		      AND  disbhist.ciddisb = ownpcts.ciddisb ;      
		      INTO CURSOR temp
		   IF _TALLY > 0
		      SELECT temp
		      SCAN
		         SCATTER MEMVAR
		         IF NOT THIS.lQuiet
		            oProgress.UpdateProgress(lnCount)
		            lnCount = lnCount + 1
		         ENDIF
		         INSERT INTO invtmp FROM MEMVAR
		      ENDSCAN
		      THIS.dacctdate = m.hdate
		   ENDIF
		ELSE
		   SELECT disbhist.*, ownpcts.* FROM disbhist, ownpcts ;
		      WHERE  cRunYear+PADL(TRANSFORM(nrunno),3,'0') = lcRunYear    ;
		      AND BETWEEN(cOwnerID,THIS.cBegOwnerID,THIS.cEndOwnerID) ;
		      AND cRecType = 'R' ;
		      AND cGroup = THIS.cGroup ;
		      AND disbhist.ciddisb = ownpcts.ciddisb ;
		      INTO CURSOR temp
		   IF _TALLY > 0
		      SELECT temp
		      SCAN
		         SCATTER MEMVAR
		         IF NOT THIS.lQuiet
		            oProgress.UpdateProgress(lnCount)
		            lnCount = lnCount + 1
		         ENDIF
		         INSERT INTO invtmp FROM MEMVAR
		      ENDSCAN
		      THIS.dacctdate = m.hdate
		   ENDIF
		ENDIF
		
		SET SAFETY OFF
		SELECT invtmp
		INDEX ON cWellID+cOwnerID TAG wellinv
		INDEX ON cOwnerID+cWellID TAG invwell
		INDEX ON cOwnerID+cWellID+ctypeinv+ctypeint+cprogcode TAG invtype
		INDEX ON cWellID TAG cWellID
		INDEX ON cOwnerID+cprogcode+cWellID TAG invprog
		INDEX ON cprogcode TAG cprogcode
		INDEX ON hyear+hperiod TAG yearprd
		INDEX ON cOwnerID+cprogcode+cWellID+ctypeinv TAG ownertype
		INDEX ON DELETED() TAG _deleted
		
		*
		****************************************************************
		*   Create Temp Well Production History File
		****************************************************************
		*
		SELECT wellhist
		lnX=AFIELDS(laTemp)
		FOR x = 1 TO lnX
		   laTemp[X,7] = ''
		   laTemp[X,8] = ''
		   laTemp[X,9] = ''
		   laTemp[X,10] = ''
		   laTemp[X,11] = ''
		   laTemp[X,12] = ''
		   laTemp[X,13] = ''
		   laTemp[X,14] = ''
		   laTemp[X,15] = ''
		   laTemp[X,16] = ''
		ENDFOR
		CREATE CURSOR wellwork FROM ARRAY laTemp
		
		
		SELECT wellwork
		INDEX ON cWellID TAG cWellID
		INDEX ON hyear+hperiod TAG yearprd
		INDEX ON DELETED() TAG _deleted
		INDEX ON cWellID+hyear+hperiod+crectype TAG wellprd
		
		SELECT wellhist
		SELECT * FROM wellhist ;
		   WHERE  nRunNo = THIS.nRunNo ;
		   AND  cRunYear = THIS.cRunYear ;
		   AND cRecType = 'R' ;
		   AND BETWEEN(cWellID,THIS.cBegWellID,THIS.cEndWellID) ;
		   INTO CURSOR temp
		IF _TALLY > 0
		   SELECT temp
		   SCAN
		      SCATTER MEMVAR
		      IF NOT THIS.lQuiet
		         oProgress.UpdateProgress(lnCount)
		         lnCount = lnCount + 1
		      ENDIF
		      INSERT INTO wellwork FROM MEMVAR
		   ENDSCAN
		ELSE
		   SELECT * FROM wellhist ;
		      WHERE  nRunNo = THIS.nRunNo ;
		      AND  cRunYear = THIS.cRunYear ;
		      AND BETWEEN(cWellID,THIS.cBegWellID,THIS.cEndWellID) ;
		      AND cRecType = 'R' ;
		      AND cGroup = THIS.cGroup ;
		      INTO CURSOR temp
		   IF _TALLY > 0
		      SELECT temp
		      SCAN
		         SCATTER MEMVAR
		         IF NOT THIS.lQuiet
		            oProgress.UpdateProgress(lnCount)
		            lnCount = lnCount + 1
		         ENDIF
		         INSERT INTO wellwork FROM MEMVAR
		      ENDSCAN
		   ENDIF
		ENDIF
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   RELE oProgress
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Ending gethist')
		ENDIF
		
		RETURN
		
		
	ENDPROC

	PROCEDURE getownflat
		LPARA tcWellId, tcOwner, tcType, tciddisb
		LOCAL lcCurrent, lnCount, lnBBL, lnMCF, lnAmount, lcAcctMonth, ldAcctdate, lnFlatRate
		
		STORE 0 TO lnBBL, lnMCF, lnAmount, lnFlatRate
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		IF NOT THIS.lFlatRates
		   RETURN 0
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting getownflat')  
		endif   
		
		ldAcctdate = THIS.dAcctDate
		IF TYPE('ldAcctDate') <> 'D'
		   ldAcctdate = DATE()
		ENDIF
		
		lcAcctMonth = PADL(ALLTRIM(STR(MONTH(ldAcctdate),2)),2,'0')
		lcCurrent = SELECT()
		
		SELECT wellinv
		SET ORDER TO cidwinv
		IF SEEK(tciddisb)
		   lcWellID = cWellID
		   IF INLIST(ctypeinv,'L','O')
		      lnFlatRate = nFlatRate
		      lnFlatFreq = nFlatFreq
		      lcFlatStart = cFlatStart
		      lnFlatRateMCF = nFlatMCF
		      lnFlatRateBBL = nFlatBBL
		   ELSE
		      lnFlatRate = 0
		      lnFlatFreq = 1
		      lcFlatStart = '01'
		      lnFlatRateMCF = 0
		      lnFlatRateBBL = 0
		   ENDIF
		ELSE
		   lcWellID = '@@@@***'
		   lnFlatRate = 0
		   lnFlatFreq = 1
		   lcFlatStart = '01'
		   lnFlatRateMCF = 0
		   lnFlatRateBBL = 0
		ENDIF
		
		DO CASE
		   CASE lnFlatRate > 0
		      DO CASE
		         CASE lnFlatFreq = 1 OR lnFlatFreq = 0
		
		         CASE lnFlatFreq = 2
		            DO CASE
		               CASE LEFT(lcFlatStart,2) = '01'
		                  lcQtr1 = '01'
		                  lcQtr2 = '04'
		                  lcQtr3 = '07'
		                  lcQtr4 = '10'
		               CASE LEFT(lcFlatStart,2) = '02'
		                  lcQtr1 = '02'
		                  lcQtr2 = '05'
		                  lcQtr3 = '08'
		                  lcQtr4 = '11'
		               CASE LEFT(lcFlatStart,2) = '03'
		                  lcQtr1 = '03'
		                  lcQtr2 = '06'
		                  lcQtr3 = '09'
		                  lcQtr4 = '12'
		               CASE LEFT(lcFlatStart,2) = '04'
		                  lcQtr1 = '04'
		                  lcQtr2 = '07'
		                  lcQtr3 = '10'
		                  lcQtr4 = '01'
		               CASE LEFT(lcFlatStart,2) = '05'
		                  lcQtr1 = '05'
		                  lcQtr2 = '08'
		                  lcQtr3 = '11'
		                  lcQtr4 = '02'
		               CASE LEFT(lcFlatStart,2) = '06'
		                  lcQtr1 = '06'
		                  lcQtr2 = '09'
		                  lcQtr3 = '12'
		                  lcQtr4 = '03'
		               CASE LEFT(lcFlatStart,2) = '07'
		                  lcQtr1 = '07'
		                  lcQtr2 = '10'
		                  lcQtr3 = '01'
		                  lcQtr4 = '04'
		               CASE LEFT(lcFlatStart,2) = '08'
		                  lcQtr1 = '08'
		                  lcQtr2 = '11'
		                  lcQtr3 = '02'
		                  lcQtr4 = '05'
		               CASE LEFT(lcFlatStart,2) = '09'
		                  lcQtr1 = '09'
		                  lcQtr2 = '12'
		                  lcQtr3 = '03'
		                  lcQtr4 = '06'
		               CASE LEFT(lcFlatStart,2) = '10'
		                  lcQtr1 = '10'
		                  lcQtr2 = '01'
		                  lcQtr3 = '04'
		                  lcQtr4 = '07'
		               CASE LEFT(lcFlatStart,2) = '11'
		                  lcQtr1 = '11'
		                  lcQtr2 = '02'
		                  lcQtr3 = '05'
		                  lcQtr4 = '08'
		               CASE LEFT(lcFlatStart,2) = '12'
		                  lcQtr1 = '12'
		                  lcQtr2 = '03'
		                  lcQtr3 = '06'
		                  lcQtr4 = '09'
		               OTHERWISE
		                  lcQtr1 = '01'
		                  lcQtr2 = '04'
		                  lcQtr3 = '07'
		                  lcQtr4 = '10'
		            ENDCASE
		            IF NOT INLIST(lcAcctMonth,lcQtr1,lcQtr2,lcQtr3,lcQtr4)
		               lnFlatRate = 0
		            ENDIF
		         CASE lnFlatFreq = 3
		            DO CASE
		               CASE LEFT(lcFlatStart,2) = '01'
		                  lcSem1 = '01'
		                  lcSem2 = '07'
		               CASE LEFT(lcFlatStart,2) = '02'
		                  lcSem1 = '02'
		                  lcSem2 = '08'
		               CASE LEFT(lcFlatStart,2) = '03'
		                  lcSem1 = '03'
		                  lcSem2 = '09'
		               CASE LEFT(lcFlatStart,2) = '04'
		                  lcSem1 = '04'
		                  lcSem2 = '10'
		               CASE LEFT(lcFlatStart,2) = '05'
		                  lcSem1 = '05'
		                  lcSem2 = '11'
		               CASE LEFT(lcFlatStart,2) = '06'
		                  lcSem1 = '06'
		                  lcSem2 = '12'
		               CASE LEFT(lcFlatStart,2) = '07'
		                  lcSem1 = '07'
		                  lcSem2 = '01'
		               CASE LEFT(lcFlatStart,2) = '08'
		                  lcSem1 = '08'
		                  lcSem2 = '02'
		               CASE LEFT(lcFlatStart,2) = '09'
		                  lcSem1 = '09'
		                  lcSem2 = '03'
		               CASE LEFT(lcFlatStart,2) = '10'
		                  lcSem1 = '10'
		                  lcSem2 = '04'
		               CASE LEFT(lcFlatStart,2) = '11'
		                  lcSem1 = '11'
		                  lcSem2 = '05'
		               CASE LEFT(lcFlatStart,2) = '12'
		                  lcSem1 = '12'
		                  lcSem2 = '06'
		               OTHERWISE
		                  lcSem1 = '01'
		                  lcSem2 = '07'
		            ENDCASE
		            IF NOT INLIST(lcAcctMonth,lcSem1,lcSem2)
		               lnFlatRate = 0
		            ENDIF
		         CASE lnFlatFreq = 4
		            IF LEFT(lcFlatStart,2) <> lcAcctMonth
		               lnFlatRate = 0
		            ENDIF
		         OTHERWISE
		            lnFlatRate = 0
		      ENDCASE
		   CASE lnFlatRateMCF <> 0 AND tcType = 'G'
		      SELE SUM(nunits) AS nTotMCF FROM income ;
		         WHERE cSource = 'MCF' AND (nrunno = 0 OR (nrunno = THIS.nrunno AND crunyear=THIS.crunyear)) AND drevdate <= THIS.drevdate ;
		         AND cWellID == lcWellID ;
		         INTO CURSOR inctmp
		      SELE inctmp
		      GO TOP
		      lnMCF = nTotMCF
		      lnFlatRate = ROUND(lnMCF * lnFlatRateMCF,2)
		   CASE lnFlatRateBBL <> 0 AND tcType = 'O'
		      SELE SUM(nunits) AS nTotBBL FROM income ;
		         WHERE cSource = 'BBL' AND (nrunno = 0 OR (nrunno = THIS.nrunno AND crunyear=THIS.crunyear)) AND drevdate <= THIS.drevdate ;
		         AND cWellID == lcWellID ;
		         INTO CURSOR inctmp
		      SELE inctmp
		      GO TOP
		      lnBBL = nTotBBL
		      lnFlatRate = ROUND(lnBBL * lnFlatRateBBL,2)
		   CASE tcType = 'B'
		      IF lnFlatRateMCF <> 0
		         SELE SUM(nunits) AS nTotMCF FROM income ;
		            WHERE cSource = 'MCF' AND (nrunno = 0 OR (nrunno = THIS.nrunno AND crunyear=THIS.crunyear)) AND drevdate <= THIS.drevdate ;
		            AND cWellID == lcWellID ;
		            INTO CURSOR inctmp
		         SELE inctmp
		         GO TOP
		         lnMCF = nTotMCF
		         lnFlatRate = ROUND(lnMCF * lnFlatRateMCF,2)
		      ENDIF
		      IF lnFlatRateBBL <> 0
		         SELE SUM(nunits) AS nTotBBL FROM income ;
		            WHERE cSource = 'BBL' AND (nrunno = 0 OR (nrunno = THIS.nrunno AND crunyear=THIS.crunyear)) AND drevdate <= THIS.drevdate ;
		            AND cWellID == lcWellID ;
		            INTO CURSOR inctmp
		         SELE inctmp
		         GO TOP
		         lnBBL = nTotBBL
		         lnFlatRate = lnFlatRate + ROUND(lnBBL * lnFlatRateBBL,2)
		      ENDIF
		ENDCASE
		
		SELECT (lcCurrent)
		
		if this.lDebug
		   this.timekeeper('Ending getownflat')  
		endif   
		
		RETURN (lnFlatRate)
		
	ENDPROC

	PROCEDURE grossuptaxpct
		LPARA tcWellID, tnPct, tcType
		LOCAL lnPct, lnNewPct
		*
		*  Gross up the given percentage to account for tax exempt owners
		*
		
		if this.lDebug
		   this.timekeeper('Starting grossuptaxpct')  
		endif   
		
		lnPct = 0
		lnNewPct = 0
		
		sele investor
		set order to cownerid
		
		sele wellinv
		scan for cwellid == tcwellid
		   m.cownerid = cownerid
		   
		   sele investor
		   if seek(m.cownerid) and lExempt
		      if tcType = 'G'
		         lnpct = lnPct + wellinv.nrevtax2
		      else
		         lnpct = lnpct + wellinv.nrevtax1
		      endif
		   endif
		endscan
		
		if lnPct <> 0
		   lnNewPct = tnPct/(100-lnPct) * 100
		else
		   lnNewPct = tnPct
		endif
		
		if this.lDebug
		   this.timekeeper('Ending grossuptaxpct')  
		endif   
		
		return(lnNewPct)   
		         
	ENDPROC

	PROCEDURE Init
		LPARA tcbegid, tcendid, tcperiod, tcyear, tcgroup, tcprocess, tdacctdate, tlquiet, tnrunno, tlClose
		LOCAL odist
		
		THIS.cdeleted   = SET('DELETED')
		THIS.lerrorflag = .F.
		
		IF FILE('debug.dat')
		   SET SAFETY OFF
		   THIS.lDebug = .T.
		   CREATE TABLE debugtime FREE ;
		      (cdesc           c(40), ;
		        ntime           N(12, 3))
		   THIS.timekeeper('Starting Init')
		ENDIF
		
		SET DELETED ON
		SET MULTILOCKS ON
		
		THIS.dPostDate = {01/01/1980}
		
		* Check to see if this is the QB version
		THIS.lqbversion = m.goapp.lqbversion
		
		
		IF TYPE('tcBegID') <> 'C'
		   WAIT WIND 'An invalid beginning owner was passed to distproc'
		   RETURN .F.
		ENDIF
		IF TYPE('tcEndID') <> 'C'
		   WAIT WIND 'An invalid ending owner was passed to distproc'
		   RETURN .F.
		ENDIF
		IF TYPE('tcPeriod') <> 'C'
		   WAIT WIND 'An invalid production period was passed to distproc'
		   RETURN .F.
		ENDIF
		IF TYPE('tcYear') <> 'C'
		   WAIT WIND 'An invalid production year was passed to distproc'
		   RETURN .F.
		ENDIF
		IF TYPE('tcGroup') <> 'C'
		   WAIT WIND 'An invalid well group was passed to distproc'
		   RETURN .F.
		ENDIF
		IF TYPE('tcProcess') <> 'C'
		   WAIT WIND 'An invalid process type was passed to distproc'
		   RETURN .F.
		ENDIF
		IF TYPE('tdAcctDate') <> 'D'
		   WAIT WIND 'An invalid accounting date was passed to distproc'
		   RETURN .F.
		ENDIF
		IF TYPE('tnRunNo') <> 'N'
		   tnrunno = 0
		ENDIF
		
		*
		*  Setup the registry object
		*
		THIS.oregistry = IIF(ISNULL(THIS.oregistry), findglobalobject('cmRegistry'), .NULL.)
		
		*
		*  Setup the message object
		*
		THIS.omessage = IIF(ISNULL(THIS.omessage), findglobalobject('cmMessage'), .NULL.)
		
		*
		*  Create the qbxml file if it doesn't exist
		*
		IF THIS.lqbversion
		   TRY
		      IF NOT FILE(m.goapp.cCommonFolder + 'qbxml.dbf')
		         CREATE TABLE (m.goapp.cCommonFolder + 'qbxml') FREE ;
		            (cid       c(10), ;
		              cdatetime T, ;
		              cxml      m)
		      ENDIF
		   CATCH
		   ENDTRY
		ENDIF
		
		*
		*  Setup the parameters as properties so all methods can use them
		*
		THIS.cperiod   = PADL(ALLT(STR(MONTH(tdacctdate))), 2, '0')
		THIS.cyear     = STR(YEAR(tdacctdate), 4)
		THIS.cprocess  = tcprocess
		THIS.cgroup    = tcgroup
		THIS.dacctdate = tdacctdate
		*  Are we supposed to display the progressbars?
		THIS.lquiet = tlquiet
		
		*  What run no is this processing associated with
		THIS.nrunno   = tnrunno
		THIS.crunyear = tcyear
		lcRunYear     = tcyear + PADL(TRANSFORM(tnrunno), 3, '0')
		*
		*  Open the tables needed
		*
		IF TYPE('m.goApp') = 'O'
		   IF NOT USED('glopt')
		      lcfile = m.goapp.getfilepath('glopt')
		      USE (lcfile) IN 0
		   ENDIF
		   IF NOT USED('wells')
		      lcfile = m.goapp.getfilepath('wells')
		      USE (lcfile) IN 0 ORDER cwellid
		   ENDIF
		   IF NOT USED('investor')
		      lcfile = m.goapp.getfilepath('investor')
		      USE (lcfile) IN 0 ORDER cownerid
		   ENDIF
		   IF NOT USED('options')
		      lcfile = m.goapp.getfilepath('options')
		      USE (lcfile) IN 0
		   ENDIF
		   IF NOT USED('wellhist')
		      lcfile = m.goapp.getfilepath('wellhist')
		      USE (lcfile) IN 0 ORDER wellprd
		      SELE wellhist
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('wellhist1')
		      lcfile = m.goapp.getfilepath('wellhist')
		      USE (lcfile) IN 0 ORDER wellprd AGAIN ALIAS wellhist1
		      SELE wellhist1
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('disbhist')
		      lcfile = m.goapp.getfilepath('disbhist')
		      USE (lcfile) IN 0
		      SELE disbhist
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('ownpcts')
		      lcfile = m.goapp.getfilepath('ownpcts')
		      USE (lcfile) IN 0
		      SELE ownpcts
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('checks')
		      lcfile = m.goapp.getfilepath('checks')
		      USE (lcfile) IN 0
		      SELE checks
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('disbhist1')
		      lcfile = m.goapp.getfilepath('disbhist')
		      USE (lcfile) IN 0 AGAIN ALIAS disbhist1
		      SELE disbhist1
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('susaudit')
		      lcfile = m.goapp.getfilepath('susaudit')
		      USE (lcfile) IN 0
		      SELE susaudit
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('sysctl')
		      lcfile = m.goapp.getfilepath('sysctl')
		      USE (lcfile) IN 0 ORDER yrprdgrp
		      SELE sysctl
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('income')
		      lcfile = m.goapp.getfilepath('income')
		      USE (lcfile) IN 0
		      SELE income
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('expense')
		      lcfile = m.goapp.getfilepath('expense')
		      USE (lcfile) IN 0
		      SELE expense
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('sevtax')
		      lcfile = m.goapp.getfilepath('sevtax')
		      USE (lcfile) IN 0 ORDER ctable
		   ENDIF
		   IF NOT USED('expcat')
		      lcfile = m.goapp.getfilepath('expcat')
		      USE (lcfile) IN 0 ORDER ccatcode
		   ENDIF
		   IF NOT USED('groups')
		      lcfile = m.goapp.getfilepath('groups')
		      USE (lcfile) IN 0 ORDER cgroup
		   ENDIF
		   IF NOT USED('programs')
		      lcfile = m.goapp.getfilepath('programs')
		      USE (lcfile) IN 0 ORDER cprogcode
		   ENDIF
		   IF NOT USED('vendor')
		      lcfile = m.goapp.getfilepath('vendor')
		      USE (lcfile) IN 0 ORDER cvendorid
		   ENDIF
		   IF NOT USED('wellinv')
		      lcfile = m.goapp.getfilepath('wellinv')
		      USE (lcfile) IN 0
		   ENDIF
		   IF NOT USED('stmtnote')
		      lcfile = m.goapp.getfilepath('stmtnote')
		      USE (lcfile) IN 0
		   ENDIF
		ELSE
		   IF NOT USED('glopt')
		      lcfile =  'data\glopt'
		      USE (lcfile) IN 0 ORDER cwellid
		   ENDIF
		   IF NOT USED('wells')
		      lcfile =  'data\wells'
		      USE (lcfile) IN 0 ORDER cwellid
		   ENDIF
		   IF NOT USED('investor')
		      lcfile =  'data\investor'
		      USE (lcfile) IN 0 ORDER cownerid
		   ENDIF
		   IF NOT USED('options')
		      lcfile =  'data\options'
		      USE (lcfile) IN 0
		   ENDIF
		   IF NOT USED('wellhist')
		      lcfile =  'data\wellhist'
		      USE (lcfile) IN 0
		      SELE wellhist
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('disbhist')
		      lcfile =  'data\disbhist'
		      USE (lcfile) IN 0
		      SELE disbhist
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('susaudit')
		      lcfile =  'data\susaudit'
		      USE (lcfile) IN 0
		      SELE susaudit
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('sysctl')
		      lcfile =  'data\sysctl'
		      USE (lcfile) IN 0
		      SELE sysctl
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('income')
		      lcfile =  'data\income'
		      USE (lcfile) IN 0
		      SELE income
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('expense')
		      lcfile =  'data\expense'
		      USE (lcfile) IN 0
		      SELE expense
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		   IF NOT USED('sevtax')
		      lcfile =  'data\sevtax'
		      USE (lcfile) IN 0 ORDER ctable
		   ENDIF
		   IF NOT USED('expcat')
		      lcfile =  'data\expcat'
		      USE (lcfile) IN 0 ORDER ccatcode
		   ENDIF
		   IF NOT USED('groups')
		      lcfile =  'data\groups'
		      USE (lcfile) IN 0
		   ENDIF
		   IF NOT USED('programs')
		      lcfile =  'data\programs'
		      USE (lcfile) IN 0
		   ENDIF
		   IF NOT USED('vendor')
		      lcfile =  'data\vendor'
		      USE (lcfile) IN 0 ORDER cvendorid
		   ENDIF
		   IF NOT USED('wellinv')
		      lcfile =  'data\wellinv'
		      USE (lcfile) IN 0
		   ENDIF
		   IF NOT USED('stmtnote')
		      lcfile = 'data\stmtnote'
		      USE (lcfile) IN 0
		   ENDIF
		   IF NOT USED('checks')
		      lcfile = m.goapp.getfilepath('checks')
		      USE (lcfile) IN 0
		      SELE checks
		      = CURSORSETPROP("Buffering", 5)
		   ENDIF
		ENDIF
		
		*
		*  Get clearing accounts
		*
		SELECT glopt
		THIS.crevclear = crevclear
		THIS.cexpclear = cexpclear
		
		*
		*  Instantiate the glmaint object
		*
		THIS.ogl = CREATEOBJECT('glmaint')
		
		*  Get the accounting year and period
		IF NOT m.goapp.lAMVersion
		   THIS.cacctyear = STR(YEAR(tdacctdate), 4)
		   THIS.cacctprd  = PADL(ALLT(STR(MONTH(tdacctdate), 2)), 2, '0')
		ELSE
		   THIS.cacctyear = THIS.ogl.getperiod(tdacctdate, .T.)
		   THIS.cacctprd  = THIS.ogl.getperiod(tdacctdate, .F.)
		ENDIF
		
		*
		*  Fill in the beginning and ending owner and well ids
		*
		DO CASE
		   CASE tcprocess = 'O'
		      THIS.cbegownerid = tcbegid
		      THIS.cendownerid = tcendid
		
		*
		*  Get the list of wells that these owners are in
		*
		      IF tcgroup = '**'
				 SELECT  cwellid ;
					 FROM wellinv ;
					 WHERE BETWEEN(cownerid, tcbegid, tcendid) ;
					 INTO CURSOR welltemp ;
					 ORDER BY cwellid ;
					 GROUP BY cwellid
		      ELSE
		         DO CASE
		            CASE tnrunno = 0 OR tlClose  &&  If a new run or closing a run, get interests from wellinv, otherwise, get them from disbhist and ownhist - BH 3/8/05
					   SELECT  cwellid ;
						   FROM wellinv ;
						   WHERE BETWEEN(cownerid, tcbegid, tcendid) ;
							   AND cwellid IN (SELECT  cwellid ;
												   FROM wells ;
												   WHERE cgroup = tcgroup) ;
						   INTO CURSOR welltemp ;
						   ORDER BY cwellid ;
						   GROUP BY cwellid
		            OTHERWISE
					   SELECT  cwellid ;
						   FROM disbhist ;
						   WHERE crunyear + PADL(TRANSFORM(nrunno), 3, '0') = lcRunYear ;
							   AND BETWEEN(cownerid, tcbegid, tcendid) ;
							   AND cwellid IN (SELECT  cwellid ;
												   FROM wellhist ;
												   WHERE crunyear = tcyear ;
													   AND nrunno = tnrunno ;
													   AND cgroup = tcgroup) ;
						   INTO CURSOR welltemp ;
						   ORDER BY cwellid ;
						   GROUP BY cwellid
		         ENDCASE
		      ENDIF
		
		      SELECT welltemp
		      GO TOP
		      THIS.cbegwellid = cwellid
		      GO BOTT
		      THIS.cendwellid = cwellid
		
		*
		*  Put the list of owners in the owner temp cursor
		*
			  SELECT  cownerid ;
				  FROM investor ;
				  WHERE BETWEEN(cownerid, tcbegid, tcendid) ;
				  INTO CURSOR owntemp ;
				  ORDER BY cownerid ;
				  GROUP BY cownerid
		
		   CASE tcprocess = 'W'
		
		      THIS.cbegwellid = tcbegid
		      THIS.cendwellid = tcendid
		
		*
		*  Put the list of wells in the welltemp cursor
		*
		      IF tcgroup = '**'
				 SELECT  cwellid ;
					 FROM wells ;
					 WHERE BETWEEN(cwellid, tcbegid, tcendid) ;
					 INTO CURSOR welltemp ;
					 ORDER BY cwellid ;
					 GROUP BY cwellid
		      ELSE
				 SELECT  cwellid ;
					 FROM wells ;
					 WHERE BETWEEN(cwellid, tcbegid, tcendid) ;
						 AND cgroup = tcgroup ;
					 INTO CURSOR welltemp ;
					 ORDER BY cwellid ;
					 GROUP BY cwellid
		      ENDIF
		
			  SELECT  cownerid ;
				  FROM wellinv ;
				  WHERE BETWEEN(cwellid, tcbegid, tcendid) ;
				  INTO CURSOR owntemp ;
				  ORDER BY cownerid ;
				  GROUP BY cownerid
		
		      SELECT owntemp
		      GO TOP
		      THIS.cbegownerid = cownerid
		      GO BOTT
		      THIS.cendownerid = cownerid
		ENDCASE
		
		IF NOT tlquiet
		   WAIT CLEAR
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Ending Init')
		ENDIF
		RETURN (DODEFAULT())
		
		
	ENDPROC

	PROCEDURE intonhold
		
		IF this.lErrorFlag 
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting intonhold')  
		endif   
		
		CREATE CURSOR suspbal ;
		  (cOwnerID   C(10), ;
		   cWellID     C(10), ;
		   cprogcode   C(10), ;
		   ctypeinv    C(1), ;
		   cgroup      C(2), ;
		   nincome     N(12,2), ;
		   nexpenses   N(12,2), ;
		   ntaxes      N(9,2), ;
		   namount     N(12,2))
		INDEX ON cownerid TAG cownerid
		
		IF this.nrunno = 0
		   lnRunNo = getrunno(THIS.cRunYear,.t.)
		ELSE
		   lnRunNo = THIS.nRunNo
		ENDIF
		      
		SELECT cOwnerID, ;
		       cWellID,   ;
		       cprogcode, ;
		       ctypeinv,  ;
		       cgroup,    ;
		       SUM(IIF(cAction='I',nincome,nincome*-1)) AS nIncome, ;
		       SUM(IIF(cAction='I',nExpenses,nExpenses*-1)) AS nExpenses, ;
		       SUM(IIF(cAction='I',nTaxes,nTaxes*-1)) AS nTaxes, ;
		       SUM(IIF(cAction='I',namount,namount*-1)) AS nAmount ;
		  FROM susaudit  ;
		  WHERE csusptype = 'I' ;
		    AND cRunYear+str(nrunno) < this.cRunYear+str(lnrunno) ;
		    AND cGroup = this.cGroup ;
		  INTO CURSOR temp ;  
		  ORDER BY cOwnerID, cWellID, cTypeInv ;
		  GROUP BY cOwnerID, cWellID, cTypeInv        
		         
		IF _tally > 0
		   SELECT suspbal
		   APPEND FROM DBF('temp')
		ENDIF   
		
		USE IN temp
		
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBar('Processing interests on hold...')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		SELECT suspbal
		IF RECC() > 0
		   SCAN FOR nAmount <> 0
		      SCATTER MEMVAR
		      IF NOT THIS.lQuiet
		         oProgress.UpdateProgress(lnCount)
		         lnCount = lnCount + 1
		      ENDIF
		
		      SELECT wellinv
		      SCAN FOR cOwnerID = m.cOwnerID ;
		            AND cWellID   = m.cWellID   ;
		            AND ctypeinv  = m.ctypeinv  ;
		            AND cProgCode = m.cProgCode ;
		            AND cGroup    = m.cGroup
		
		         * Check to see if the owner is still on hold
		         IF wellinv.lOnHold
		            LOOP
		         ENDIF
		
		         sele susaudit
		         repl csusptype with 'M' FOR csusptype='I' ;
		            AND cOwnerID = m.cOwnerID ;
		            AND cWellID   = m.cWellID   ;
		            AND ctypeinv  = m.ctypeinv  ;
		            AND cProgCode = m.cProgCode ;
		            AND cGroup    = m.cGroup
		            
		      ENDSCAN
		   ENDSCAN
		ENDIF
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   RELE oProgress
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Ending intonhold')  
		endif   
		
	ENDPROC

	PROCEDURE jibexp		&& Removes JIB portion of expense from an amount passed.
		LPARA tcWellID, tcCatCode, tnAmount, tlJIB
		LOCAL lcExpClass, lnInterest, lnAmount
		
		lnAmount   = 0
		lnInterest = 0
		lcExpClass = 'x'
		
		if this.lDebug
		   this.timekeeper('Starting jibexp')  
		endif   
		
		*
		*  Either removes a JIB portion from the expense passed
		*  or removes the non-JIB portion
		*
		
		SELECT expcat
		SET ORDER TO cCatCode
		IF SEEK(tcCatCode)
		   lcExpClass = cExpClass
		ELSE
		   WAIT WIND NOWAIT 'A bad expense category code was passed to JIBEXP'
		ENDIF
		   
		IF tlJIB
		         
		   DO CASE
		      CASE lcExpClass = '0'      
		         SELECT SUM(nWorkInt) AS nInterest ;
		           FROM wellinv ;
		           WHERE cTypeInv = 'W' ;
		             AND lJIB = .T. ;
		             AND cWellID  = tcWellID ;
		           INTO CURSOR lctemp
		       
		      CASE lcExpClass = '1'      
		         SELECT SUM(nIntClass1) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .T. ;
		           INTO CURSOR lctemp    
		      
		      CASE lcExpClass = '2'      
		         SELECT SUM(nIntClass2) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .T. ;
		           INTO CURSOR lctemp        
		           
		      CASE lcExpClass = '3'      
		         SELECT SUM(nIntClass3) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .T. ;
		           INTO CURSOR lctemp 
		           
		      CASE lcExpClass = '4'      
		         SELECT SUM(nIntClass4) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .T. ;
		           INTO CURSOR lctemp 
		           
		       CASE lcExpClass = '5'      
		         SELECT SUM(nIntClass5) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .T. ;
		           INTO CURSOR lctemp        
		       OTHERWISE
		         SELECT SUM(nWorkInt) AS nInterest ;
		           FROM wellinv ;
		           WHERE cTypeInv = 'W' ;
		             AND lJIB = .T. ;
		             AND cWellID  = tcWellID ;
		           INTO CURSOR lctemp                              
		   ENDCASE
		   
		   IF _tally > 0
		      SELECT lctemp
		      GO TOP
		      lnInterest = nInterest
		   ELSE
		      lnInterest = 0
		   ENDIF
		   
		   lnAmount = tnAmount * (lnInterest/100)
		   
		ELSE
		
		   DO CASE
		      CASE lcExpClass = '0'      
		         SELECT SUM(nWorkInt) AS nInterest ;
		           FROM wellinv ;
		           WHERE cTypeInv = 'W' ;
		             AND lJIB = .F. ;
		             AND cWellID  = tcWellID ;
		           INTO CURSOR lctemp
		       
		      CASE lcExpClass = '1'      
		         SELECT SUM(nIntClass1) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .F. ;
		           INTO CURSOR lctemp    
		      
		      CASE lcExpClass = '2'      
		         SELECT SUM(nIntClass2) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .F. ;
		           INTO CURSOR lctemp        
		           
		      CASE lcExpClass = '3'      
		         SELECT SUM(nIntClass3) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .F. ;
		           INTO CURSOR lctemp 
		           
		      CASE lcExpClass = '4'      
		         SELECT SUM(nIntClass4) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .F. ;
		           INTO CURSOR lctemp 
		           
		       CASE lcExpClass = '5'      
		         SELECT SUM(nIntClass5) AS nInterest ;
		           FROM wellinv ;
		           WHERE cWellID  = tcWellID ;
		             AND lJIB = .F. ;
		           INTO CURSOR lctemp                                    
		   ENDCASE
		   
		   IF _tally > 0
		      SELECT lctemp
		      GO TOP
		      lnInterest = nInterest
		   ELSE
		      lnInterest = 0
		   ENDIF
		   
		   lnAmount = tnAmount * (lnInterest/100)
		ENDIF         
		
		if this.lDebug
		   this.timekeeper('Ending jibexp')  
		endif   
		
		RETURN (lnAmount)
	ENDPROC

	PROCEDURE jibnet		&& Create net JIB invoices
	ENDPROC

	PROCEDURE main		&& Main Processing routine
		LPARA tlClose, tlRpt
		* tlClose = Closing the production period
		* tlRpt   = Produce the rounding report
		
		LOCAL llNetDef, llClosed, llPeriodClosed
		
		*  Save the close flag
		THIS.lClose = tlClose
		llClosed       = .F.
		llPeriodClosed = .F.
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		if tlClose
		   this.lquiet = .t.
		   this.nprogress = 1 
		   this.oProgress = THIS.omessage.progressbarex('Processing Revenue Closing for Run: ' + padl(transform(this.nrunno),3,'0')+'/'+this.crunyear,' ')
		   if this.lqbversion
		      this.oProgress.SetProgressRange(0,46)
		   else
		      this.oProgress.SetProgressRange(0,45)
		   endif   
		endif
		
		SELE options
		GO TOP
		
		THIS.lSepClose = lSepClose
		
		IF THIS.lQBVersion
		   IF m.goApp.capplevel <> 'Unlimited'
		      lnwells = 0
		      IF NOT USED('wells')
		         USE wells IN 0
		      ENDIF
		      SELECT wells
		      COUNT FOR NOT DELETED() AND cwellstat <> 'U' TO lnwells
		      IF m.goApp.capplevel = 'Starter' AND lnwells > 10
		         MESSAGEBOX('More than 10 wells were found in the well master file. ' + CHR(10) + ;
		            'This is a starter system. 10 wells is the maximum. ' + CHR(10) + ;
		            'You will not be able to process revenue or JIBs until you upgrade to the next level.',0,'Compliance Problem')
		         RETURN .F.   
		      ENDIF
		      IF m.goApp.capplevel = 'Basic' AND lnwells > 20
		         MESSAGEBOX('More than 20 wells were found in the well master file. ' + CHR(10) + ;
		            'This is a basic system. 20 wells is the maximum. ' + CHR(10) + ;
		            'You will not be able to process revenue or JIBs until you upgrade to the next level.',0,'Compliance Problem')
		         RETURN .F.   
		      ENDIF
		   ENDIF
		ENDIF
		
		* Check to see if this Run is closed
		THIS.lRunClosed = THIS.CheckHistRun()
		
		*
		*  Create the work cursors (wellwork) and (invtmp)
		*
		IF NOT THIS.lErrorFlag
		   THIS.SETUP()
		ENDIF
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Checking for Revenue/Expense Activity')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		IF NOT THIS.checkactivity()
		   this.omessage.warning('There were no revenue or expenses entries found for this run.')
		   RETURN .F.
		ELSE
		   ****************************************************************************
		   *  Check to see if the period has already been posted
		   *  If the period has been posted, retrieve the information from the history
		   *  files and rerun the suspense processing.
		   ****************************************************************************
		   IF THIS.lRunClosed = .T.
		      llClosed = .T.
		      SELECT groups
		      SET ORDER TO cGroup
		      IF SEEK(THIS.cGroup)
		         llNetDef = lNetDef
		      ELSE
		         llNetDef = .T.
		      ENDIF
		      THIS.gethist()
		      IF THIS.cProcess = 'O'
		         IF llNetDef
		            THIS.susp_by_owner()
		         ELSE
		            THIS.susp_by_well()
		         ENDIF
		      ENDIF
		   ELSE
		      llClosed = .F.
		      SELECT groups
		      SET ORDER TO cGroup
		      IF SEEK(THIS.cGroup)
		         llNetDef = lNetDef
		      ELSE
		         llNetDef = .T.
		      ENDIF
		
		      *
		      *  Process the wells
		      *
		      IF NOT THIS.lErrorFlag
		         THIS.wellproc()
		      ENDIF
		
		      *
		      *  Process the owners
		      *
		      IF NOT THIS.lErrorFlag
		         THIS.ownerproc()
		      ENDIF
		
		      *
		      *  Remove exempt owners from tax totals in wellwork
		      IF NOT THIS.lErrorFlag
		*         THIS.taxexempt()
		      ENDIF
		
		      *
		      *  Calculate the rounding
		      *
		      IF NOT THIS.lErrorFlag AND tlRpt
		         THIS.calcround(tlRpt)
		      ENDIF
		
		      *
		      * If we're closing the revenue period, add the period
		      * to the history files
		      *
		      IF tlClose AND NOT THIS.lErrorFlag
		         llReturn = THIS.closeproc()
		         IF llReturn AND NOT THIS.lErrorFlag
		            THIS.oMessage.DISPLAY('%msgRevCloseSuccess')
		         ELSE
		            THIS.oMessage.DISPLAY('%msgRevCloseFailure')
		         ENDIF
		      ELSE
		         *
		         *  Process suspense entries
		         *  Only process them for owner processes
		         *
		         IF NOT THIS.lErrorFlag
		            IF THIS.cProcess = 'O'
		               IF llNetDef
		                  THIS.susp_by_owner()
		               ELSE
		                  THIS.susp_by_well()
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDIF
		ENDIF
		
		RETURN .T.
		
	ENDPROC

	PROCEDURE netexp		&& Nets the passed expense to take into account "Dummy" owners.
		LPARA tnGrossAmt, tcwellid, tlDown, tcClass, tcJIB, tlRange, tcOwnerid
		*
		*  tcClass     = the expense class for the given expense category
		*  tcJIB    B  = Net out only "Dummy" owners
		*           J  = Net out "Dummy" and Net interests
		*           N  = Net out "Dummy" and JIB interests
		*           D  = Net out only JIB interests
		*
		LOCAL lcCurrent, lnDummyInt, llEntNet, lnCount, m.cownerid, m.cwellid
		
		IF NOT INLIST(tcJIB,'B','J','N','D')
		   RETURN (tnGrossAmt)
		ENDIF
		
		IF NOT INLIST(tcClass,'0','1','2','3','4','5','A','B')
		   *   WAIT WIND NOWAIT 'An invalid expense class was passed to distproc.netexp....'
		   tcClass = '0'
		ENDIF
		
		IF TYPE('tcOwnerID') <> 'C'
		   tcOwnerID = ''
		ENDIF
		
		IF NOT EMPTY(tcOwnerID)
		   RETURN tnGrossAmt
		ENDIF      
		
		IF TYPE('tnGrossAmt') <> 'N'
		   RETURN 0
		ENDIF
		
		IF TYPE('tcWellID') <> 'C'
		   RETURN 0
		ENDIF
		
		lcCurrent = ALIAS()
		
		IF THIS.lErrorFlag
		   RETURN (tnGrossAmt)
		ENDIF
		
		IF TYPE('tcClass') <> 'C'
		   tcClass = '0'
		ENDIF
		IF TYPE('tcJIB') <> 'C'
		   tcJIB = 'B'
		ENDIF
		
		SELECT wells
		SET ORDER TO cWellID
		IF SEEK(tcwellid)
		   IF cwellstat = 'V'
		      *  If the well is an investment well return the amount passed
		      *  because we don't want to have to setup a doi for investment
		      *  wells.  They will report on whatever was entered for them.
		      RETURN tnGrossAmt
		   ENDIF
		ELSE
		   *  The well wasn't found so don't try to net the amount down or gross it up
		   RETURN tnGrossAmt
		ENDIF
		
		***************************************************************************
		*  Initalize the work variables
		***************************************************************************
		STORE 0 TO lnCount, lnDummyInt
		
		***************************************************************************
		*  Sum the working interests for owners that are marked as dummy
		***************************************************************************
		CREATE CURSOR tempwork ;
		   (nworkint   N(11,7))
		
		DO CASE
		   CASE tlRange
		      DO CASE
		         CASE tcJIB = 'B'
		            DO CASE
		               CASE tcClass = '0'
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nworkint) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND disbhist.ctypeinv  = 'W' ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '1'
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nintclass1) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2);
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '2'
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nintclass2) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '3'
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nintclass3) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '4'
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nintclass4) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '5'
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nintclass5) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'A'
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nacpint) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'B'
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nbcpint) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2);
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               OTHERWISE
		                  SELECT disbhist.cOwnerID, AVG(disbhist.nworkint) AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		            ENDCASE
		
		         CASE tcJIB = 'D'
		            DO CASE
		               CASE tcClass = '0'
		                  SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND disbhist.ctypeinv  = 'W' ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '1'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass1 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '2'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass2 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '3'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass3 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '4'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass4 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '5'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'A'
		                  SELECT disbhist.cOwnerID, disbhist.nacpint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'B'
		                  SELECT disbhist.cOwnerID, disbhist.nbcpint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               OTHERWISE
		                  SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T.) ;
		                     INTO CURSOR tempy
		            ENDCASE
		
		         CASE tcJIB = 'J'
		            DO CASE
		               CASE tcClass = '0'
		                  SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND disbhist.ctypeinv  = 'W' ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '1'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass1 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '2'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass2 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '3'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass3 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '4'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass4 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '5'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'A'
		                  SELECT disbhist.cOwnerID, disbhist.nacpint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'B'
		                  SELECT disbhist.cOwnerID, disbhist.nbcpint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               OTHERWISE
		                  SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		            ENDCASE
		
		         CASE tcJIB = 'N'
		            DO CASE
		               CASE tcClass = '0'
		                  SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND disbhist.ctypeinv  = 'W' ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '1'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass1 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '2'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass2 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '3'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass3 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '4'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass4 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '5'
		                  SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'A'
		                  SELECT disbhist.cOwnerID, disbhist.nacpint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'B'
		                  SELECT disbhist.cOwnerID, disbhist.nbcpint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               OTHERWISE
		                  SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		                     FROM disbhist, investor ;
		                     WHERE BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype='R' ;
		                     AND disbhist.cWellID   = tcwellid ;
		                     AND disbhist.cOwnerID = investor.cOwnerID ;
		                     AND disbhist.ctypeinv  = 'W' ;
		                     AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		            ENDCASE
		      ENDCASE
		
		   OTHERWISE
		      DO CASE
		         CASE tcJIB = 'B'
		            DO CASE
		               CASE tcClass = '0'
		                  SELECT wellinv.cOwnerID, wellinv.nworkint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND wellinv.ctypeinv  = 'W' ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '1'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass1 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '2'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass2 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '3'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass3 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '4'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass4 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '5'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass5 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'A'
		                  SELECT wellinv.cOwnerID, wellinv.nacpint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'B'
		                  SELECT wellinv.cOwnerID, wellinv.nbcpint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		               OTHERWISE
		                  SELECT wellinv.cOwnerID, wellinv.nintclass5 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND investor.ldummy ;
		                     INTO CURSOR tempy
		
		            ENDCASE
		
		         CASE tcJIB = 'D'
		            DO CASE
		               CASE tcClass = '0'
		                  SELECT wellinv.cOwnerID, wellinv.nworkint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND wellinv.ctypeinv  = 'W' ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '1'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass1 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '2'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass2 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '3'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass3 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '4'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass4 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '5'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass5 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'A'
		                  SELECT wellinv.cOwnerID, wellinv.nacpint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'B'
		                  SELECT wellinv.cOwnerID, wellinv.nbcpint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		
		               OTHERWISE
		                  SELECT wellinv.cOwnerID, wellinv.nintclass5 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T.) ;
		                     INTO CURSOR tempy
		            ENDCASE
		
		         CASE tcJIB = 'J'
		            DO CASE
		               CASE tcClass = '0'
		                  SELECT wellinv.cOwnerID, wellinv.nworkint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND wellinv.ctypeinv  = 'W' ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '1'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass1 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '2'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass2 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '3'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass3 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '4'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass4 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '5'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass5 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'A'
		                  SELECT wellinv.cOwnerID, wellinv.nacpint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'B'
		                  SELECT wellinv.cOwnerID, wellinv.nbcpint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               OTHERWISE
		                  SELECT wellinv.cOwnerID, wellinv.nintclass5 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .F. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		            ENDCASE
		
		         CASE tcJIB = 'N'
		            DO CASE
		               CASE tcClass = '0'
		                  SELECT wellinv.cOwnerID, wellinv.nworkint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND wellinv.ctypeinv  = 'W' ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '1'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass1 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '2'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass2 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '3'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass3 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '4'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass4 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = '5'
		                  SELECT wellinv.cOwnerID, wellinv.nintclass5 AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'A'
		                  SELECT wellinv.cOwnerID, wellinv.nacpint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               CASE tcClass = 'B'
		                  SELECT wellinv.cOwnerID, wellinv.nbcpint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		
		               OTHERWISE
		                  SELECT wellinv.cOwnerID, wellinv.nworkint AS nworkint, investor.cownname ;
		                     FROM wellinv, investor ;
		                     WHERE wellinv.cWellID   = tcwellid ;
		                     AND wellinv.cOwnerID = investor.cOwnerID ;
		                     AND wellinv.ctypeinv  = 'W' ;
		                     AND (wellinv.lJIB = .T. OR investor.ldummy) ;
		                     INTO CURSOR tempy
		            ENDCASE
		      ENDCASE
		
		
		ENDCASE
		
		IF _TALLY = 0
		   SELECT (lcCurrent)
		   IF USED('tempy')
		      USE IN tempy
		   ENDIF
		   IF USED('tempwork')
		      USE IN tempwork
		   ENDIF
		   RETURN (tnGrossAmt)
		ENDIF
		
		SELECT tempy
		SCAN
		   SCATTER MEMVAR
		   INSERT INTO tempwork FROM MEMVAR
		ENDSCAN
		SELECT SUM(nworkint) AS nworkint ;
		   FROM tempwork ;
		   INTO CURSOR tempw
		
		SELECT tempw
		GO TOP
		lnDummyInt = nworkint
		
		IF USED('tempy')
		   USE IN tempy
		ENDIF
		IF USED('tempw')
		   USE IN tempw
		ENDIF
		IF USED('tempwork')
		   USE IN tempwork
		ENDIF
		
		***************************************************************************
		*  Calculate the Gross amount from the net amount
		***************************************************************************
		DO CASE
		   CASE lnDummyInt < 100     && Dummint Interest Amount
		      IF tlDown
		         lnGross = ROUND((tnGrossAmt * ((100 - lnDummyInt)/100)),2)
		      ELSE
		         lnGross = ROUND((tnGrossAmt / ((100 - lnDummyInt)/100)),2)
		      ENDIF
		      SELECT (lcCurrent)
		      RETURN (lnGross)
		   CASE lnDummyInt >= 100    && Dummy Interest Amount
		      SELECT (lcCurrent)
		      RETURN (0)
		ENDCASE
		
	ENDPROC

	PROCEDURE netrev		&& Nets revenue or grosses revenue based upon directly paid owners.
		**********************************************************************************
		*
		*  Processes the revenue amount passed by either grossing it up or
		*  netting it down based on the value of parameter tlUp
		*
		*  Parameters:   tcWellID  = The well the revenue is for
		*                tnAmount  = The revenue amount
		*                tcType    = The type of revenue.  O = oil, G = gas, T = trans
		*                                                  1 = misc1, 2 = misc2, P = other
		*                                                  G1-G4 - Gas Taxes, O1-O4 - Oil Taxes
		*                tlUp      = .T. - gross the revenue up based on direct pays
		*                            .F. - net the revenue down
		*                tlDummy   = .T. - process the revenue based on "Dummy" owners as well as direct pays.
		*                tlDumOnly = .T. - process only the "Dummy" owners
		*                tcOwnerid = The owner id if a one-man item.
		*                tlTaxes   = .T. - the amount passed is a tax amount
		*                tlRange   = .T. - the amount is for a close run. Use history files.
		**********************************************************************************
		LPARA tcWellId, tnAmount, tcType, tlUp, tlDummy, tlDumOnly, tcOwnerid, tlTaxes, tlRange
		LOCAL lcCurrent, lnDirOilAmt, lnDirGasAmt, lnCount, lnTally, lnGross
		LOCAL llInvestment, lnDumMiscAmt, lcExact, llTax, lcDirectExpr, lcTaxExpr
		
		lcCurrent = ALIAS()
		lnTally = 0
		llTax = .F.
		
		lcExact = SET('exact')
		SET EXACT OFF
		
		STORE 0 TO lnDirOilAmt, lnDirGasAmt, lnDumMiscAmt
		
		IF THIS.lErrorFlag
		   RETURN (tnAmount)
		ENDIF
		
		*
		* Check the tcOwnerID parm. If it was passed
		* return the original amount since it should
		* not be grossed up or netted down.
		*
		IF TYPE('tcOwnerID') <> 'C'
		   tcOwnerid = ''
		ELSE
		   IF NOT EMPTY(tcOwnerid)
		      RETURN (tnAmount)
		   ENDIF
		ENDIF
		
		* Don't do any processing if the amount passed is zero.
		IF tnAmount = 0
		   RETURN 0
		ENDIF
		
		STORE 0 TO lnCount, lnDirOil, lnDirGas, lnDumMiscAmt
		
		SELECT wells
		SET ORDER TO cWellID
		IF SEEK(tcWellId)
		   IF cwellstat = 'V'
		      *  If the well is an investment well return the amount passed
		      *  because we don't want to have to setup a doi for investment
		      *  wells.  They will report on whatever was entered for them.
		      RETURN tnAmount
		   ELSE
		      llInvestment = .F.
		   ENDIF
		ELSE
		   RETURN tnAmount
		ENDIF
		
		* Temporary fix to combat a "File tempa does not exist" error
		CREATE CURSOR tempa (junk c(1))
		
		*
		* Determine what fields to include in the select statement
		*
		IF tlRange OR (THIS.nrunno <> 0 and not this.lclose)
		   DO CASE
		      CASE tcType == 'G'
		         lcExpr = 'disbhist.nrevgas'
		      CASE tcType == 'G1'
		         lcExpr = 'disbhist.nrevtax2'
		         llTax  = .T.
		      CASE tcType == 'G2'
		         lcExpr = 'disbhist.nrevtax5'
		         llTax  = .T.
		      CASE tcType == 'G3'
		         lcExpr = 'disbhist.nrevtax8'
		         llTax  = .T.
		      CASE tcType == 'G4'
		         lcExpr = 'disbhist.nrevtax11'
		         llTax  = .T.
		      CASE tcType == 'O'
		         lcExpr = 'disbhist.nrevoil'
		      CASE tcType == 'O1'
		         lcExpr = 'disbhist.nrevtax1'
		         llTax  = .T.
		      CASE tcType == 'O2'
		         lcExpr = 'disbhist.nrevtax4'
		         llTax  = .T.
		      CASE tcType == 'O3'
		         lcExpr = 'disbhist.nrevtax7'
		         llTax  = .T.
		      CASE tcType == 'O4'
		         lcExpr = 'disbhist.nrevtax10'
		         llTax  = .T.
		      CASE tcType == 'P'
		         lcExpr = 'disbhist.nrevoth'
		      CASE tcType == 'P1'
		         lcExpr = 'disbhist.nrevtax3'
		         llTax  = .T.
		      CASE tcType == 'P2'
		         lcExpr = 'disbhist.nrevtax6'
		         llTax  = .T.
		      CASE tcType == 'P3'
		         lcExpr = 'disbhist.nrevtax9'
		         llTax  = .T.
		      CASE tcType == 'P4'
		         lcExpr = 'disbhist.nrevtax12'
		         llTax  = .T.
		      CASE tcType == 'T'
		         lcExpr = 'disbhist.nrevtrp'
		      CASE tcType == '1'
		         lcExpr = 'disbhist.nrevmisc1'
		      CASE tcType == '2'
		         lcExpr = 'disbhist.nrevmisc2'
		   ENDCASE
		ELSE
		   DO CASE
		      CASE tcType == 'G'
		         lcExpr = 'wellinv.nrevgas'
		      CASE tcType == 'G1'
		         lcExpr = 'wellinv.nrevtax2'
		         llTax  = .T.
		      CASE tcType == 'G2'
		         lcExpr = 'wellinv.nrevtax5'
		         llTax  = .T.
		      CASE tcType == 'G3'
		         lcExpr = 'wellinv.nrevtax8'
		         llTax  = .T.
		      CASE tcType == 'G4'
		         lcExpr = 'wellinv.nrevtax11'
		         llTax  = .T.
		      CASE tcType == 'O'
		         lcExpr = 'wellinv.nrevoil'
		      CASE tcType == 'O1'
		         lcExpr = 'wellinv.nrevtax1'
		         llTax  = .T.
		      CASE tcType == 'O2'
		         lcExpr = 'wellinv.nrevtax4'
		         llTax  = .T.
		      CASE tcType == 'O3'
		         lcExpr = 'wellinv.nrevtax7'
		         llTax  = .T.
		      CASE tcType == 'O4'
		         lcExpr = 'wellinv.nrevtax10'
		         llTax  = .T.
		      CASE tcType == 'P'
		         lcExpr = 'wellinv.nrevoth'
		      CASE tcType == 'P1'
		         lcExpr = 'wellinv.nrevtax3'
		         llTax  = .T.
		      CASE tcType == 'P2'
		         lcExpr = 'wellinv.nrevtax6'
		         llTax  = .T.
		      CASE tcType == 'P3'
		         lcExpr = 'wellinv.nrevtax9'
		         llTax  = .T.
		      CASE tcType == 'P4'
		         lcExpr = 'wellinv.nrevtax12'
		         llTax  = .T.
		      CASE tcType == 'T'
		         lcExpr = 'wellinv.nrevtrp'
		      CASE tcType == '1'
		         lcExpr = 'wellinv.nrevmisc1'
		      CASE tcType == '2'
		         lcExpr = 'wellinv.nrevmisc2'
		   ENDCASE
		ENDIF
		
		* Set the default expression for direct paid revenue
		lcDirectExpr = "INLIST(cdirect,LEFT(tcType,1),'B')"
		
		*
		* Setup the selection criteria for exempt owners
		*
		IF llTax
		
		   lcTaxExpr = 'investor.lexempt = .T.'
		   
		   * Get the purchaser withholding options for direct paid tax
		   sele wells
		   locate for cwellid == tcWellID
		   if found()
		      llDirOilPurch = lDirOilPurch
		      llDirGasPurch = lDirGasPurch
		   else
		      llDirOilPurch = .F.
		      llDirGasPurch = .F.
		   endif   
		   
		   * Change the default direct expression if needed.
		   if NOT llDirOilPurch AND inlist(tcType,'O1','O2','O3','O4')
		      lcDirectExpr = '.F.'
		   ENDIF   
		   if NOT llDirGasPurch AND inlist(tcType,'G1','G2','G3','G4')
		      lcDirectExpr = '.F.'
		   ENDIF   
		ELSE
		   lcTaxExpr = '.F.'
		ENDIF
		
		*
		*  Get the pct to gross up or net down by using the parms passed.
		*
		DO CASE
		   CASE tlRange
		      * A date range was passed. Get the DOI that existed during that date range.
		      DO CASE
		         CASE tlDumOnly
		            SELECT SUM(&lcExpr) AS nPct, DTOC(hdate) AS cdate ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID = tcWellId ;
		               AND BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype = 'R' ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (investor.ldummy) ;
		               INTO CURSOR tempx ;
		               GROUP BY hyear, hperiod, cdate
		
		         CASE tlDummy
		            SELECT SUM(&lcExpr) AS nPct, DTOC(hdate) AS cdate ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID = tcWellId ;
		               AND (&lcDirectExpr OR (investor.ldummy) OR &lcTaxExpr) ;
		               AND BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype = 'R' ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               INTO CURSOR tempx ;
		               GROUP BY hyear, hperiod, cdate
		
		         OTHERWISE
		            SELECT SUM(&lcExpr) AS nPct, DTOC(hdate) AS cdate ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID = tcWellId ;
		               AND (&lcDirectExpr OR &lcTaxExpr);
		               AND NOT(investor.ldummy) ;
		               AND BETWEEN(disbhist.hdate,THIS.date1,THIS.date2) AND disbhist.crectype = 'R' ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               INTO CURSOR tempx ;
		               GROUP BY hyear, hperiod, cdate
		      ENDCASE
		
		      SELE AVG(nPct) AS nPct ;
		         FROM tempx ;
		         INTO CURSOR tempa
		
		      lnTally = _TALLY
		
		      IF lnTally = 0
		         SELECT (lcCurrent)
		         if used('tempx')
		            use in tempx
		         endif
		         if used('tempa')
		            use in tempa
		         endif   
		         RETURN (tnAmount)
		      ENDIF
		
		   CASE (THIS.nrunno <> 0 and not this.lclose)
		      * The run is not a new run, so use owner history (Disbhist)
		      DO CASE
		         CASE tlDumOnly
		            SELECT SUM(&lcExpr) AS nPct, DTOC(hdate) AS cdate ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID = tcWellId ;
		               AND disbhist.nrunno = THIS.nrunno AND disbhist.crunyear = THIS.crunyear AND disbhist.crectype = 'R' ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (investor.ldummy) ;
		               INTO CURSOR tempx ;
		               GROUP BY hyear, hperiod, cdate
		
		         CASE tlDummy
		            SELECT SUM(&lcExpr) AS nPct, DTOC(hdate) AS cdate ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID = tcWellId ;
		               AND (&lcDirectExpr OR (investor.ldummy) OR &lcTaxExpr) ;
		               AND disbhist.nrunno = THIS.nrunno AND disbhist.crunyear = THIS.crunyear AND disbhist.crectype = 'R' ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               INTO CURSOR tempx ;
		               GROUP BY hyear, hperiod, cdate
		
		         OTHERWISE
		            SELECT SUM(&lcExpr) AS nPct, DTOC(hdate) AS cdate ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID = tcWellId ;
		               AND (&lcDirectExpr OR &lcTaxExpr);
		               AND NOT(investor.ldummy) ;
		               AND disbhist.nrunno = THIS.nrunno AND disbhist.crunyear = THIS.crunyear AND disbhist.crectype = 'R' ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND &lcTaxExpr ;
		               INTO CURSOR tempx ;
		               GROUP BY hyear, hperiod, cdate
		      ENDCASE
		
		      SELE AVG(nPct) AS nPct ;
		         FROM tempx ;
		         INTO CURSOR tempa
		
		      lnTally = _TALLY
		
		      IF lnTally = 0
		         SELECT (lcCurrent)
		         if used('tempx')
		            use in tempx
		         endif
		         if used('tempa')
		            use in tempa
		         endif   
		         RETURN (tnAmount)
		      ENDIF
		
		   OTHERWISE
		      * Processing a new run
		    
		      DO CASE
		         CASE tlDumOnly
		            SELECT SUM(&lcExpr) AS nPct ;
		               FROM wellinv, investor ;
		               WHERE wellinv.cWellID = tcWellId ;
		               AND wellinv.cOwnerID = investor.cOwnerID ;
		               AND (investor.ldummy) ;
		               INTO CURSOR tempa
		
		         CASE tlDummy
		            SELECT SUM(&lcExpr) AS nPct ;
		               FROM wellinv, investor ;
		               WHERE wellinv.cWellID = tcWellId ;
		               AND wellinv.cOwnerID = investor.cOwnerID ;
		               AND (&lcDirectExpr OR (investor.ldummy) OR &lcTaxExpr) ;
		               INTO CURSOR tempa
		         OTHERWISE
		            SELECT SUM(&lcExpr) AS nPct ;
		               FROM wellinv, investor ;
		               WHERE wellinv.cWellID = tcWellId ;
		               AND (&lcDirectExpr OR &lcTaxExpr);
		               AND NOT (investor.ldummy) ;
		               AND wellinv.cOwnerID = investor.cOwnerID ;
		               INTO CURSOR tempa
		      ENDCASE
		
		      lnTally = _TALLY
		
		      IF lnTally = 0
		         SELECT (lcCurrent)
		         if used('tempx')
		            use in tempx
		         endif
		         if used('tempa')
		            use in tempa
		         endif   
		         RETURN (tnAmount)
		      ENDIF
		ENDCASE
		
		* Get the pct from our temp cursor
		SELE tempa
		lnPct   = nPct
		lnGross = tnAmount
		
		*
		*  Calculate the Gross amount from the net amount
		*
		DO CASE
		   CASE tlUp          && Gross The Amount Up
		      DO CASE
		         CASE lnPct < 100
		            lnGross = SWROUND(tnAmount / ((100-lnPct)/100),2)
		            SELECT (lcCurrent)
		            RETURN (lnGross)
		         CASE lnPct >= 100
		            SELECT (lcCurrent)
		            RETURN (lnGross)
		      ENDCASE
		   CASE NOT tlUp      && Net The Amount Down
		      DO CASE
		         CASE lnPct < 100
		            lnGross = SWROUND((tnAmount * ((100 - lnPct)/100)),2)
		            SELECT (lcCurrent)
		            RETURN (lnGross)
		         CASE lnPct >= 100
		            SELECT (lcCurrent)
		            RETURN (0)
		      ENDCASE
		ENDCASE
		
		
		
	ENDPROC

	PROCEDURE netrunexp		&& Net closed expenses.
		LPARA tnGrossAmt, tcwellid, tlDown, tcClass, tcJIB, tnRunno, tcRunYear, tcTypeClose
		*
		*  tcClass     = the expense class for the given expense category
		*  tcJIB    B  = Net out only "Dummy" owners
		*           J  = Net out "Dummy" and Net interests
		*           N  = Net out "Dummy" and JIB interests
		*           D  = Net out only JIB interests
		*
		LOCAL lcCurrent, lnDummyInt, llEntNet, lnCount
		
		IF NOT INLIST(tcJIB,'B','J','N','D')
		   RETURN (tnGrossAmt)
		ENDIF   
		
		IF NOT INLIST(tcClass,'0','1','2','3','4','5','A','B')
		*   WAIT WIND NOWAIT 'An invalid expense class was passed to distproc.netexp....'
		   tcClass = '0'
		ENDIF   
		
		
		IF TYPE('tnGrossAmt') <> 'N'
		   RETURN 0
		ENDIF
		
		IF TYPE('tcWellID') <> 'C'
		   RETURN 0
		ENDIF      
		   
		lcCurrent = ALIAS()
		
		IF THIS.lErrorFlag
		   RETURN (tnGrossAmt)
		ENDIF
		
		IF TYPE('tcClass') <> 'C'
		   tcClass = '0'
		ENDIF
		IF TYPE('tcJIB') <> 'C'
		   tcJIB = 'B'
		ENDIF
		
		SELECT wells
		SET ORDER TO cWellID
		IF SEEK(tcWellID)
		   IF cwellstat = 'V'
		      *  If the well is an investment well return the amount passed
		      *  because we don't want to have to setup a doi for investment 
		      *  wells.  They will report on whatever was entered for them.
		      RETURN tnGrossAmt
		   ENDIF
		ELSE
		   *  The well wasn't found so don't try to net the amount down or gross it up
		   RETURN tnGrossAmt
		ENDIF            
		
		***************************************************************************
		*  Initalize the work variables
		***************************************************************************
		STORE 0 TO lnCount, lnDummyInt
		
		***************************************************************************
		*  Sum the working interests for owners that are marked as dummy
		***************************************************************************
		CREATE CURSOR tempwork ;
		   (nworkint   N(11,7))
		
		DO CASE
		   CASE tcJIB = 'B'
		      DO CASE
		         CASE tcClass = '0'
		            SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND disbhist.ctypeinv  = 'W' ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '1'
		            SELECT disbhist.cOwnerID, disbhist.nintclass1 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '2'
		            SELECT disbhist.cOwnerID, disbhist.nintclass2 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '3'
		            SELECT disbhist.cOwnerID, disbhist.nintclass3 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '4'
		            SELECT disbhist.cOwnerID, disbhist.nintclass4 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '5'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy
		          
		         CASE tcClass = 'A'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy     
		               
		         CASE tcClass = 'B'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy      
		               
		         OTHERWISE
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND investor.ldummy ;
		               INTO CURSOR tempy            
		
		      ENDCASE
		   
		   CASE tcJIB = 'D'
		      DO CASE
		         CASE tcClass = '0'
		            SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND disbhist.ctypeinv  = 'W' ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '1'
		            SELECT disbhist.cOwnerID, disbhist.nintclass1 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '2'
		            SELECT disbhist.cOwnerID, disbhist.nintclass2 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '3'
		            SELECT disbhist.cOwnerID, disbhist.nintclass3 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '4'
		            SELECT disbhist.cOwnerID, disbhist.nintclass4 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '5'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy
		         
		         CASE tcClass = 'A'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy      
		               
		         CASE tcClass = 'B'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy      
		               
		         OTHERWISE
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T.) ;
		               INTO CURSOR tempy            
		      ENDCASE   
		         
		   CASE tcJIB = 'J'
		      DO CASE
		         CASE tcClass = '0'
		            SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND disbhist.ctypeinv  = 'W' ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '1'
		            SELECT disbhist.cOwnerID, disbhist.nintclass1 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '2'
		            SELECT disbhist.cOwnerID, disbhist.nintclass2 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '3'
		            SELECT disbhist.cOwnerID, disbhist.nintclass3 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '4'
		            SELECT disbhist.cOwnerID, disbhist.nintclass4 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '5'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy
		               
		         CASE tcClass = 'A'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy      
		         
		         CASE tcClass = 'B'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy      
		               
		         OTHERWISE
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .F. OR investor.ldummy) ;
		               INTO CURSOR tempy            
		      ENDCASE   
		       
		   CASE tcJIB = 'N'
		      DO CASE
		         CASE tcClass = '0'
		            SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND disbhist.ctypeinv  = 'W' ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '1'
		            SELECT disbhist.cOwnerID, disbhist.nintclass1 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '2'
		            SELECT disbhist.cOwnerID, disbhist.nintclass2 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '3'
		            SELECT disbhist.cOwnerID, disbhist.nintclass3 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '4'
		            SELECT disbhist.cOwnerID, disbhist.nintclass4 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy
		
		         CASE tcClass = '5'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy
		               
		         CASE tcClass = 'A'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy     
		               
		         CASE tcClass = 'B'
		            SELECT disbhist.cOwnerID, disbhist.nintclass5 AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy      
		
		         OTHERWISE
		            SELECT disbhist.cOwnerID, disbhist.nworkint AS nworkint, investor.cownname ;
		               FROM disbhist, investor ;
		               WHERE disbhist.cWellID   = tcwellid ;
		               AND nrunno = tnrunno and crunyear = tcRunYear and crectype = tcTypeClose ;
		               AND disbhist.cOwnerID = investor.cOwnerID ;
		               AND disbhist.ctypeinv  = 'W' ;
		               AND (disbhist.lJIB = .T. OR investor.ldummy) ;
		               INTO CURSOR tempy
		      ENDCASE      
		ENDCASE
		
		IF _TALLY = 0
		   SELECT (lcCurrent)
		   IF USED('tempy')
		      USE IN tempy
		   ENDIF
		   IF USED('tempwork')   
		      USE IN tempwork
		   ENDIF   
		   RETURN (tnGrossAmt)
		ENDIF
		
		SELECT tempy
		SCAN
		   SCATTER MEMVAR
		   INSERT INTO tempwork FROM MEMVAR
		ENDSCAN
		SELECT SUM(nworkint) AS nworkint ;
		   FROM tempwork ;
		   INTO CURSOR tempw
		
		SELECT tempw
		GO TOP
		lnDummyInt = nworkint
		
		IF USED('tempy')
		   USE IN tempy
		ENDIF
		IF USED('tempw')
		   USE IN tempw
		ENDIF
		IF USED('tempwork')
		   USE IN tempwork
		ENDIF
		
		***************************************************************************
		*  Calculate the Gross amount from the net amount
		***************************************************************************
		DO CASE
		   CASE lnDummyInt < 100     && Dummint Interest Amount
		      IF tlDown
		         lnGross = ROUND((tnGrossAmt * ((100 - lnDummyInt)/100)),2)
		      ELSE
		         lnGross = ROUND((tnGrossAmt / ((100 - lnDummyInt)/100)),2)
		      ENDIF
		      SELECT (lcCurrent)
		      RETURN (lnGross)
		   CASE lnDummyInt >= 100    && Dummy Interest Amount
		      SELECT (lcCurrent)
		      RETURN (0)
		ENDCASE
		
	ENDPROC

	PROCEDURE ownerchks		&& Create owner checks and places them in the check register to be printed.
		LOCAL  tcYear, tcPeriod, tdCheckDate, tcGroup, tcBatch, tdPostDate
		LOCAL  m.nTotalChk, oProgress
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting ownerchks')  
		endif   
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Creating Owner Checks...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		ENDIF   
		
		tcYear      = this.cRunYear
		tcPeriod    = THIS.cPeriod
		tcGroup     = THIS.cGroup
		tcBatch     = THIS.cDMBatch
		tdCheckDate = THIS.dAcctDate
		
		if this.companypost = .t.
		   tdPostDate = this.dacctdate
		else
		   tdPostDate = this.dPostDate
		endif   
		
		tlRelMin    = THIS.lRelMin
		
		m.nTotalChk = 0
		
		*
		*  Build the owner check totals
		*
		SELECT invtmp.cOwnerID, ;
		       investor.cOwnName AS cPayee, ;
		       investor.lHold, ;
		       investor.ndisbfreq, ;
		       investor.ninvmin, ;
		       investor.linteggl, ;
		   SUM(invtmp.nNetCheck) AS nTotalCK ;
		   FROM invtmp, investor ;
		   WHERE investor.cownerid = invtmp.cownerid ;
		     and investor.ldirectdep = .f. ;
		     AND investor.ldummy = .f. ;
		     AND investor.linteggl = .f. ;
		   INTO CURSOR invtotal ;
		   ORDER BY invtmp.cOwnerID ;
		   GROUP BY invtmp.cOwnerID
		
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBarex('Creating the owner checks...',' ')
		ENDIF
		
		*
		*  Get the Accounting Month
		*
		lcAcctPrd = PADL(ALLTRIM(STR(MONTH(tdCheckDate),2)),2,'0')
		
		*
		*  Get the Disbursements checking account
		*
		SELECT options
		GO TOP
		lcDisbAcct = cDisbAcct
		lnMinCheck = nMinCheck
		IF NOT this.lQBVersion
		   lcDeptNo   = cDeptNo
		ELSE
		   lcDeptNo   = ''
		ENDIF      
		
		SELECT glopt
		GO TOP
		lcRevClear = cRevClear
		lcExpClear = cExpClear
		
		m.cYear = tcYear
		lnTotal = 0
		
		SELECT investor
		SET ORDER TO cOwnerID
		
		SELECT invtotal
		COUNT FOR nTotalCk > 0 TO lnMax
		lnCount = 1
		lnTotal = 0
		
		IF NOT THIS.lQuiet
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		THIS.oGL.cReference = 'Period: ' + tcYear+'/'+tcPeriod+'/'+tcGroup
		
		THIS.oGL.cYear      = this.oGL.GetPeriod(tdCheckDate,.t.)
		THIS.oGL.cPeriod    = this.oGL.GetPeriod(tdCheckDate,.f.)
		
		THIS.oGL.dcheckdate = tdCheckDate
		THIS.oGL.dGLDate    = tdPostDate
		THIS.oGL.dPostDate  = tdPostDate
		THIS.oGL.cGroup     = tcGroup
		THIS.oGL.cAcctNo    = lcDisbAcct
		THIS.oGL.cidtype    = 'I'
		THIS.oGL.cSource    = 'DM'
		THIS.oGL.cUnitNo    = ''
		THIS.oGL.cDeptNo    = lcDeptNo
		THIS.oGL.cEntryType = 'C'
		
		lnChkAmt = 0
		
		SELECT invtotal
		SCAN FOR nTotalCK > 0
		   SCATTER MEMVAR
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      oProgress.SetProgressMessage(m.cPayee)
		      lnCount = lnCount + 1
		   ENDIF
		   
		   if THIS.lClose
		      this.oProgress.SetProgressMessage('Creating Owner Checks...'+m.cownerid)
		   endif
		
		   *
		   *  Setup the minimum check amount
		   *
		   IF m.ninvmin = 0
		      jnMinCheck = lnMinCheck
		   ELSE
		      jnMinCheck = m.ninvmin
		   ENDIF
		
		   *
		   *  Reset the minimum amount to hold this owner's check
		   *  if it's not to be disbursed monthly or he's on hold.
		   *
		   DO CASE
		      CASE m.lhold                   && Owner on hold
		         jnMinCheck = 99999999
		      CASE m.nDisbFreq = 2          && Quarterly
		         IF NOT INLIST(lcAcctPrd,'03','06','09','12')
		            jnMinCheck = 99999999
		         ELSE
		            IF tlRelMin
		               jnMinCheck = 0
		            ENDIF      
		         ENDIF
		         
		      CASE m.nDisbFreq = 3          && SemiAnnually
		         IF NOT INLIST(lcAcctPrd,'06','12')
		            jnMinCheck = 99999999
		         ELSE
		            IF tlRelMin
		               jnMinCheck = 0
		            ENDIF         
		         ENDIF
		      CASE m.nDisbFreq = 4          && Annually
		         IF lcAcctPrd <> '12'
		            jnMinCheck = 99999999
		         ELSE
		            IF tlRelMin
		               jnMinCheck = 0
		            ENDIF         
		         ENDIF
		      CASE tlRelMin                 && Release minimums
		         jnMinCheck = 0
		   ENDCASE
		      
		   IF m.nTotalCK <> 0 AND m.nTotalCK >= jnMinCheck
		
		      * Add the check to the check register
		      THIS.oGL.cid        = m.cOwnerID
		      THIS.oGL.namount    = m.nTotalCK
		      THIS.oGL.cPayee     = m.cPayee
		      THIS.oGL.cBatch     = tcBatch
		      THIS.oGL.cAcctNo    = lcDisbAcct
		      THIS.oGL.addcheck(.T.)
		      lcidchec = this.ogl.cidchec
		
		      * Plug in the check key
		*!*	      wait wind nowait 'Storing check key in owner history for: ' + m.cownerid
		*!*	      SELECT disbhist
		*!*	      set order to 0
		*!*	      SCAN FOR nRunNo = THIS.nRunNo AND cRunYear = THIS.cRunYear AND cOwnerID = m.cOwnerID
		*!*	         REPL cidchec WITH lcidchec
		*!*	      ENDSCAN
		*!*	      wait clear
		      SELE invtmp
		      SCAN FOR cOwnerID = m.cOwnerID
		         REPL cidchec WITH lcidchec
		      ENDSCAN
		   ENDIF
		ENDSCAN
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   DOEVENTS
		ENDIF
		
		oProgress = .NULL.
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Creating Owner Checks...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending ownerchks')  
		endif   
		
	ENDPROC

	PROCEDURE ownerproc		&& Process Owners
		LOCAL lnflatoilamt, lnflatgasamt, lcsaveprd1, lcsaveprd2, oprogress, lnrunno, llrelqtr, llFlatReleased, llFlatAllocated
		
		IF THIS.lerrorflag
		   RETURN
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Starting ownerproc')
		ENDIF
		
		IF THIS.lClose
		   THIS.oprogress.SetProgressMessage('Allocating Revenue and Expenses to the Owners...')
		   THIS.oprogress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		ENDIF
		
		IF NOT THIS.lquiet
		   oprogress = THIS.omessage.progressbarex('Allocating revenue and expenses to the owners...',' ')
		ENDIF
		
		lcsaveprd1 = THIS.cperiod
		lcsaveprd2 = lcsaveprd1
		lcyear1    = THIS.crunyear
		lcyear2    = THIS.crunyear
		lnrunno    = THIS.nrunno
		
		*
		*  Get options
		*
		SELECT options
		gncompress = ncompress
		gngather   = ngather
		llroycomp  = lroycomp
		llExpSum   = lexpsum
		
		SELECT expense
		lnX=AFIELDS(latemp)
		FOR x = 1 TO lnX
		   latemp[X,7] = ''
		   latemp[X,8] = ''
		   latemp[X,9] = ''
		   latemp[X,10] = ''
		   latemp[X,11] = ''
		   latemp[X,12] = ''
		   latemp[X,13] = ''
		   latemp[X,14] = ''
		   latemp[X,15] = ''
		   latemp[X,16] = ''
		ENDFOR
		CREATE CURSOR exptemp FROM ARRAY latemp
		CREATE CURSOR mktgtemp FROM ARRAY latemp
		
		SELE expcat
		SET ORDER TO ccatcode
		
		****************************************************************************
		*  Setup the expense file. Either create a summary of expenses or a temp
		*  work cursor.
		****************************************************************************
		IF llExpSum         && Summarize expenses
		   SELECT expense
		   SCAN FOR BETWEEN(cwellid,THIS.cbegwellid,THIS.cendwellid) ;
		         AND IIF(THIS.nrunno=0,nrunnorev=0,nrunnorev=THIS.nrunno AND crunyearrev=THIS.crunyear) ;
		         AND dexpdate <= THIS.dexpdate AND cYear <> 'FIXD'
		      SCATTER MEMVAR
		
		      SELE expcat
		      IF SEEK(m.ccatcode)
		         m.cdescrip  = cdescrip
		         *!*  Commented out 8/17/05 - pws
		         *!*    - to implement the ability to specify the class at data entry time.
		         *         m.cexpclass = cexpclass
		      ELSE
		         LOOP
		      ENDIF
		      m.loneman = .F.
		      SELE exptemp
		      LOCATE FOR cwellid = m.cwellid AND ;
		         ccatcode == m.ccatcode AND cownerid = m.cownerid AND cExpClass = m.cExpClass
		      IF FOUND()
		         REPL namount WITH namount + m.namount
		      ELSE
		         INSERT INTO exptemp FROM MEMVAR
		      ENDIF
		   ENDSCAN
		
		   SELECT expense
		   SCAN FOR ccatcode = 'MKTG' ;
		         AND BETWEEN(expense.cwellid,THIS.cbegwellid,THIS.cendwellid) ;
		         AND dexpdate <= THIS.drevdate ;
		         AND IIF(THIS.nrunno=0,nrunnorev=0,nrunnorev=THIS.nrunno AND crunyearrev=THIS.crunyear)
		      SCATTER MEMVAR
		
		      SELE expcat
		      IF SEEK(m.ccatcode)
		         m.cdescrip  = cdescrip
		         *!*  Commented out 8/17/05 - pws
		         *!*    - to implement the ability to specify the class at data entry time.
		         *        m.cexpclass = cexpclass
		      ELSE
		         LOOP
		      ENDIF
		      m.loneman = .F.
		      SELE mktgtemp
		      LOCATE FOR cwellid = m.cwellid AND cYear+cperiod = m.cYear+m.cperiod AND ;
		         ccatcode == m.ccatcode AND cownerid = m.cownerid AND cExpClass = m.cExpClass
		      IF FOUND()
		         REPL namount WITH namount + m.namount
		      ELSE
		         INSERT INTO mktgtemp FROM MEMVAR
		      ENDIF
		   ENDSCAN
		ELSE
		   SELECT expense
		   SCAN FOR BETWEEN(cwellid,THIS.cbegwellid,THIS.cendwellid) ;
		         AND IIF(THIS.nrunno=0,nrunnorev=0,nrunnorev=THIS.nrunno AND crunyearrev=THIS.crunyear) ;
		         AND dexpdate <= THIS.dexpdate
		      SCATTER MEMVAR
		      m.loneman = .F.
		      SELE expcat
		      IF SEEK(m.ccatcode)
		         m.cdescrip  = cdescrip
		         *!*  Commented out 8/17/05 - pws
		         *!*    - to implement the ability to specify the class at data entry time.
		         *         m.cexpclass = cexpclass
		      ELSE
		         LOOP
		      ENDIF
		
		      INSERT INTO exptemp FROM MEMVAR
		   ENDSCAN
		   SELECT expense
		   SCAN FOR ccatcode = 'MKTG' AND BETWEEN(cwellid,THIS.cbegwellid,THIS.cendwellid) ;
		         AND IIF(THIS.nrunno=0,nrunnorev=0,nrunnorev=THIS.nrunno AND crunyearrev=THIS.crunyear) ;
		         AND dexpdate <= THIS.drevdate
		      SCATTER MEMVAR
		      m.loneman = .F.
		      SELE expcat
		      IF SEEK(m.ccatcode)
		         m.cdescrip  = cdescrip
		         *!*  Commented out 8/17/05 - pws
		         *!*    - to implement the ability to specify the class at data entry time.
		         *       m.cexpclass = cexpclass
		      ELSE
		         LOOP
		      ENDIF
		
		      INSERT INTO mktgtemp FROM MEMVAR
		   ENDSCAN
		ENDIF
		
		
		****************************************************************************
		*  Calculate individual working and royalty interest shares by owner
		****************************************************************************
		
		lncount = 1
		SELECT wells
		SET ORDER TO cwellid
		
		*
		*  Process revenue into temp cursor
		*
		SELECT income
		lnX=AFIELDS(latemp)
		FOR x = 1 TO lnX
		   latemp[X,7] = ''
		   latemp[X,8] = ''
		   latemp[X,9] = ''
		   latemp[X,10] = ''
		   latemp[X,11] = ''
		   latemp[X,12] = ''
		   latemp[X,13] = ''
		   latemp[X,14] = ''
		   latemp[X,15] = ''
		   latemp[X,16] = ''
		ENDFOR
		CREATE CURSOR inctemp FROM ARRAY latemp
		
		SELE * FROM income ;
		   WHERE (nrunno = 0 OR (nrunno = THIS.nrunno AND crunyear=THIS.crunyear)) AND drevdate <= THIS.drevdate ;
		   AND BETWEEN(cwellid,THIS.cbegwellid,THIS.cendwellid) ;
		   INTO CURSOR inctmp ;
		   ORDER BY cwellid
		IF _TALLY > 0
		   SELE inctmp
		   SCAN
		      SCATTER MEMVAR
		      m.loneman = .F.
		      INSERT INTO inctemp FROM MEMVAR
		   ENDSCAN
		   SELE inctemp
		   INDEX ON cwellid TAG cwellid
		   INDEX ON cYear+cperiod TAG yearprd
		ENDIF
		
		STORE .F. TO m.lexempt, m.ltaxwith, m.lbackwith, m.ltaxgross
		STORE 0 TO m.ntaxpct, m.nbackpct
		
		jcownerid = '  '
		SELECT invtmp
		COUNT FOR NOT DELETED() TO lnmax
		IF NOT THIS.lquiet
		   oprogress.setprogressrange(0,lnmax)
		ENDIF
		
		jcwellid = '  '
		llFlatReleased  = .F.
		llFlatAllocated = .F.
		
		********************************************************************
		*  Start the scan through the invtmp file to process each interest.
		********************************************************************
		SELECT invtmp
		SET ORDER TO invprog
		SCAN FOR BETWEEN(cownerid,THIS.cbegownerid,THIS.cendownerid)
		   SCATTER MEMVAR
		
		   IF THIS.lClose
		      * Show progressbar only when closing the run.
		      THIS.oprogress.SetProgressMessage('Allocating Revenue and Expenses to the Owners...'+m.cownerid)
		   ENDIF
		
		
		   IF m.cownerid <> jcownerid
		      * Look up the owner info when the owner changes.
		      jcownerid = m.cownerid
		      SELECT investor
		      SET ORDER TO cownerid
		      IF SEEK(jcownerid)
		         m.lexempt   = lexempt
		         m.lbackwith = lbackwith
		         m.nbackpct  = nbackpct
		         m.ltaxgross = ltaxgross
		         llFlatReleased  = .F.
		         llFlatAllocated = .F.
		      ELSE
		         *  Shouldn't ever get here
		         LOOP
		      ENDIF
		   ENDIF
		
		   IF m.cwellid <> jcwellid
		      jcwellid = m.cwellid
		      * Reset Flat Income flags when the well changes.
		      llFlatReleased = .F.
		      llFlatAllocated = .F.
		   ENDIF
		
		   STORE 0 TO lnwelltot, lntotinc, lntotexp, m.ninvamt, jinvcnt, lnoilinc, ;
		      lngasinc, lnothinc, lntrpinc, lntaxes, jnflatcount, lnmi1inc, lnmi2inc, ;
		      lncompress, lngather, lnoilexp, lngasexp
		   STORE 0 TO lngastax1, lnoiltax1, lnothtax1, lnoiltax2, lngastax2, lnothtax2, ;
		      lngastax3, lnoiltax3, lnothtax3, lnoiltax4, lngastax4, lnothtax4
		
		   IF NOT THIS.lquiet
		      oprogress.UpdateProgress(lncount)
		      oprogress.SetProgressMessage(jcownerid)
		      lncount = lncount + 1
		   ENDIF
		
		   SELECT invtmp
		   lcdirect = m.cdirect
		   jnworkint = m.nworkint
		   STORE 0 TO lnflatoilamt, lnflatgasamt
		
		   *
		   *  Check to see if this owner is paid a flat rate
		   *
		   IF m.lflat AND NOT llFlatReleased
		      m.nflatrate = THIS.getownflat(m.cwellid, jcownerid, m.ctypeint, m.ciddisb)
		      SELECT invtmp
		      REPL nrevoil WITH 0, nrevgas WITH 0
		      * Set the flat released flag so that a flat rate is only released
		      * once per owner/well combination.
		      llFlatReleased = .T.
		   ELSE
		      m.nflatrate = 0
		   ENDIF
		
		   *
		   *  Determine if the owner is a royalty owner
		   *
		   IF m.ctypeinv = 'L' OR m.ctypeinv = 'O'
		      llroyaltyowner = .T.
		   ELSE
		      llroyaltyowner = .F.
		   ENDIF
		
		   STORE 0 TO jflatcnt
		   STORE 'N' TO m.cdirect
		
		   *
		   * Get the well information for the well being processed
		   *
		   SELE wells
		   SET ORDER TO cwellid
		   IF SEEK(m.cwellid)
		      llroysevtx = lroysevtx
		      lcowner = m.cownerid
		      SCATTER MEMVAR
		      m.cownerid  = lcowner
		      m.nroyint   = m.nlandpct+m.noverpct
		   ELSE
		      * Should never get here...
		      LOOP
		   ENDIF
		
		   *
		   *  Get the taxes calculated for the well
		   *
		   SELECT wellwork
		   SET ORDER TO wellprd
		   IF SEEK (m.cwellid+m.hyear+m.hperiod+'R')
		      m.nprodwell  = ngasinc+noilinc+ntrpinc
		      m.ntotbbltx2 = ngbbltax2
		      m.ntotmcftx2 = ngmcftax2
		      m.ntotbbltx1 = ngbbltax1
		      m.ntotmcftx1 = ngmcftax1
		      m.ntotbbltx3 = ngbbltax3
		      m.ntotmcftx3 = ngmcftax3
		      m.ntotbbltx4 = ngbbltax4
		      m.ntotmcftx4 = ngmcftax4
		      m.ntotothtx1 = ntotothtx1
		      m.ntotothtx2 = ntotothtx2
		      m.ntotothtx3 = ntotothtx3
		      m.ntotothtx4 = ntotothtx4
		      m.ntotbbltxr = ntotbbltxr
		      m.ntotmcftxr = ntotmcftxr
		      m.ntotbbltxw = ntotbbltxw
		      m.ntotmcftxw = ntotmcftxw
		      lngasrevenue = ngrossgas
		      lnoilrevenue = ngrossoil
		      lnflatoilamt = nFlatOil
		      lnflatgasamt = nFlatGas
		      m.nroyalty   = nroyint
		      m.nprocess   = nprocess
		      jncompress   = ncompress
		      jngather     = ngather
		      m.nexpcl1    = nexpcl1
		      m.nexpcl2    = nexpcl2
		      m.nexpcl3    = nexpcl3
		      m.nexpcl4    = nexpcl4
		      m.nexpcl5    = nexpcl5
		      m.nexpcla    = nexpcla
		      m.nexpclb    = nexpclb
		   ELSE
		      * Should never really get here...
		      m.nprodwell  = 0
		      STORE 0 TO m.ntotbbltx1, m.ntotbbltx2, m.ntotbbltx3, m.ntotbbltx4
		      STORE 0 TO m.ntotmcftx1, m.ntotmcftx2, m.ntotmcftx3, m.ntotmcftx4
		      STORE 0 TO m.ntotothtx1, m.ntotothtx2, m.ntotothtx3, m.ntotothtx4
		      STORE 0 TO m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		      STORE 0 TO m.nexpcla, m.nexpclb, m.ntotbbltxr, m.ntotmcftxr
		      STORE 0 TO m.ntotbbltxw, m.ntotmcftxw, m.ntotal, m.nroyalty
		      STORE 0 TO jncompress, jngather, lngasrevenue, lnoilrevenue, lnflatgasamt, lnflatoilamt
		      m.nprocess   = 1
		   ENDIF
		
		   **********************************************************
		   *  Process income
		   **********************************************************
		   SELECT inctemp
		   SET ORDER TO 0
		   jflatcnt = 0
		   llincome = .F.
		   STORE 0 TO m.ngasrev, m.noilrev, m.ntrprev, m.nmiscrev1, m.nmiscrev2, m.nothrev
		   SCAN FOR cwellid = m.cwellid AND cYear+cperiod = m.hyear+m.hperiod
		      m.ctype = csource
		
		      * Check to make sure this owner has the interest type required to process this
		      * revenue entry. If he doesn't, loop out.
		      DO CASE
		         CASE m.ctype = 'BBL'
		            IF m.ctypeint = 'G'
		               LOOP
		            ENDIF
		         CASE m.ctype = 'MCF'
		            IF m.ctypeint = 'O'
		               LOOP
		            ENDIF
		      ENDCASE
		
		      * Save the original interests so we can manipulate the interests
		      * for one-man items.
		      jnrevoil  = m.nrevoil
		      jnrevgas  = m.nrevgas
		      jnrevoth  = m.nrevoth
		      jnrevtax1 = m.nrevtax1
		      jnrevtax2 = m.nrevtax2
		      jnrevtax3 = m.nrevtax3
		      jnrevtax4 = m.nrevtax4
		      jnrevtax5 = m.nrevtax5
		      jnrevtax6 = m.nrevtax6
		      jnrevtax7 = m.nrevtax7
		      jnrevtax8 = m.nrevtax8
		      jnrevtax9 = m.nrevtax9
		      jnrevtax10 = m.nrevtax10
		      jnrevtax11 = m.nrevtax11
		      jnrevtax12 = m.nrevtax12
		      jnrevm1   = m.nrevmisc1
		      jnrevm2   = m.nrevmisc2
		      *
		      *  Check for one-man-items
		      *
		      DO CASE
		         CASE cownerid = jcownerid AND NOT loneman
		            * The owner on this income record matches the owner
		            * we're processing and we haven't processed this entry
		            * for the owner yet.
		            REPLACE loneman WITH .T.
		            DO CASE
		               CASE m.ctype = 'BBL'
		                  m.nrevoil = 100
		               CASE m.ctype = 'MCF'
		                  m.nrevgas = 100
		               CASE m.ctype = 'OTH'
		                  m.nrevoth = 100
		               CASE m.ctype = 'EXO'
		                  m.nrevoil = 100
		               CASE m.ctype = 'EXG'
		                  m.nrevgas = 100
		               CASE m.ctype = 'OTAX1'
		                  m.nrevtax1 = 100
		               CASE m.ctype = 'GTAX1'
		                  m.nrevtax2 = 100
		               CASE m.ctype = 'PTAX1'
		                  m.nrevtax3 = 100
		               CASE m.ctype = 'OTAX2'
		                  m.nrevtax4 = 100
		               CASE m.ctype = 'GTAX2'
		                  m.nrevtax5 = 100
		               CASE m.ctype = 'PTAX2'
		                  m.nrevtax6 = 100
		               CASE m.ctype = 'OTAX3'
		                  m.nrevtax7 = 100
		               CASE m.ctype = 'GTAX3'
		                  m.nrevtax8 = 100
		               CASE m.ctype = 'PTAX3'
		                  m.nrevtax9 = 100
		               CASE m.ctype = 'OTAX4'
		                  m.nrevtax10 = 100
		               CASE m.ctype = 'GTAX4'
		                  m.nrevtax11 = 100
		               CASE m.ctype = 'PTAX4'
		                  m.nrevtax12 = 100
		               CASE m.ctype = 'MISC1'
		                  m.nrevmisc1 = 100
		               CASE m.ctype = 'MISC2'
		                  m.nrevmisc2 = 100
		            ENDCASE
		
		         CASE cownerid = ' '
		            * There is no ownerid on the income entry.
		            * It's not a one-man item.
		         CASE cownerid <> jcownerid
		            * The owner on the record doesn't match the
		            * owner we're processing....loop out.
		            LOOP
		         CASE cownerid = jcownerid AND loneman
		            * We've already processed this entry for this owner.
		            LOOP
		      ENDCASE
		
		      ***********************************************************
		      *  Plug in the correct interest for the revenue
		      *  being processed.
		      ***********************************************************
		      DO CASE
		         CASE m.ctype = 'BBL'
		            m.nrevint = m.nrevoil
		            llincome = .T.
		         CASE m.ctype = 'MCF'
		            m.nrevint = m.nrevgas
		            llincome = .T.
		         CASE m.ctype = 'OTH'
		            m.nrevint = m.nrevoth
		            llincome = .T.
		         CASE m.ctype = 'TRANS'
		            m.nrevint = m.nrevtrp
		         CASE m.ctype = 'NOT'
		            m.nrevint = 1
		         CASE m.ctype = 'MISC1'
		            m.nrevint = m.nrevmisc1
		         CASE m.ctype = 'MISC2'
		            m.nrevint = m.nrevmisc2
		         CASE m.ctype = 'OTAX1'
		            m.noiltax1 = m.noiltax1 + ntotalinc
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax1
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax1
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'GTAX1'
		            m.ngastax1 = m.ngastax1 + ntotalinc
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax2
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax2
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'PTAX1'
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax3
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax3
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'OTAX2'
		            m.noiltax2 = m.noiltax2 + ntotalinc
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax4
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax4
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'GTAX2'
		            m.ngastax2 = m.ngastax2 + ntotalinc
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax5
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax5
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'PTAX2'
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax6
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax6
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'OTAX3'
		            m.noiltax3 = m.noiltax3 + ntotalinc
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax7
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax7
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'GTAX3'
		            m.ngastax3 = m.ngastax3 + ntotalinc
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax8
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax8
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'PTAX3'
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax9
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax9
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'OTAX4'
		            m.noiltax4 = m.noiltax4 + ntotalinc
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax10
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax10
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'GTAX4'
		            m.ngastax4 = m.ngastax4 + ntotalinc
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax11
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax11
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'PTAX4'
		            IF NOT llroyaltyowner
		               IF llroysevtx
		                  m.nrevint = m.nworkint
		               ELSE
		                  m.nrevint = m.nrevtax12
		               ENDIF
		            ELSE
		               IF llroysevtx
		                  m.nrevint = 0
		               ELSE
		                  m.nrevint = m.nrevtax12
		               ENDIF
		            ENDIF
		         CASE m.ctype = 'EXG'
		            m.nrevint = m.nworkint
		         CASE m.ctype = 'EXO'
		            m.nrevint = m.nworkint
		         OTHERWISE
		            m.nrevint = m.nrevgas
		      ENDCASE
		
		      *  If the interest type is oil and gas is being processed,
		      *  change the interests to zero.
		      IF m.ctypeint = 'O' AND INLIST(m.ctype,'MCF','GTAX1','GTAX2','GTAX3','GTAX4','EXG')
		         m.nrevint = 0
		         m.nrevgas = 0
		      ENDIF
		
		      *  If the interest type is gas and oil is being processed,
		      *  change the interests to zero.
		      IF m.ctypeint = 'G' AND INLIST(m.ctype,'BBL','OTAX1','OTAX2','OTAX3','OTAX4','EXO')
		         m.nrevint = 0
		         m.nrevoil = 0
		      ENDIF
		
		      * Setup the revenue variables used in processing
		      SELE inctemp
		      jgross = ntotalinc
		      junits = nunits
		      m.nworktot = 0
		
		      *
		      *  Check if this investor is a direct pay
		      *
		      DO CASE
		         CASE INLIST(lcdirect,'O','B') AND INLIST(m.ctype,'BBL','OTAX1','OTAX2','OTAX3','OTAX4','EXO') AND NOT m.lflat
		            *
		            *  If the owner is directly paid oil revenue and oil is being processed, zero out his totals on revenue
		            *
		            m.ninvamt = 0
		            m.ntotal  = 0
		            m.nworktot = 0
		            DO CASE
		               CASE m.ctype = 'OTAX1'
		                  IF m.lexempt
		                     * Owner is exempt from tax. Zero out taxes
		                     m.nworktot = 0
		                     lnoiltax1 = 0
		                  ELSE
		                     IF NOT m.lSev1O
		                        * Purchaser doesn't withhold, so subtract it
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser pays revenue directly, so mark as directly paid
		                        IF NOT m.lDirOilPurch
		                           * Purchaser doesn't withhold tax on directly paid owners
		                           m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                        ELSE
		                           * Purchaser withholds tax on direct paid revenue
		                           m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               CASE m.ctype = 'OTAX2'
		                  IF m.lexempt
		                     * Owner is exempt from tax. Zero out taxes
		                     m.nworktot = 0
		                     lnoiltax2 = 0
		                  ELSE
		                     IF NOT m.lSev2O
		                        * Purchaser doesn't pay, so subtract it
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser pays directly, so mark as directly paid
		                        IF NOT m.lDirOilPurch
		                           * Purchaser doesn't withhold tax on directly paid owners
		                           m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                        ELSE
		                           * Purchaser withholds tax on direct paid revenue
		                           m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               CASE m.ctype = 'OTAX3'
		                  IF m.lexempt
		                     * Owner is exempt from tax. Zero out taxes
		                     m.nworktot = 0
		                     lnoiltax3 = 0
		                  ELSE
		                     IF NOT m.lSev3O
		                        * Purchaser doesn't pay, so subtract it
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser pay, so mark as directly paid
		                        IF NOT m.lDirOilPurch
		                           * Purchaser doesn't withhold tax on directly paid owners
		                           m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                        ELSE
		                           * Purchaser withholds tax on direct paid revenue
		                           m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               CASE m.ctype = 'OTAX4'
		                  IF m.lexempt
		                     * Owner is exempt from tax. Zero out taxes
		                     m.nworktot = 0
		                     lnoiltax4 = 0
		                  ELSE
		                     IF NOT m.lSev4O
		                        * Purchaser doesn't pay directly, so subtract it
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser pays directly, so mark as directly paid
		                        IF NOT m.lDirOilPurch
		                           * Purchaser doesn't withhold tax on directly paid owners
		                           m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                        ELSE
		                           * Purchaser withholds tax on direct paid revenue
		                           m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               OTHERWISE
		                  * Oil Revenue, not taxes
		                  m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		            ENDCASE
		
		         CASE INLIST(lcdirect,'G','B') AND INLIST(m.ctype,'MCF','GTAX1','GTAX2','GTAX3','GTAX4','EXG') AND NOT m.lflat
		            *
		            *  If the owner is directly paid gas revenue and gas is being processed, zero out his totals on income
		            *
		            m.ninvamt = 0
		            m.ntotal  = 0
		            DO CASE
		               CASE m.ctype = 'GTAX1'
		                  IF m.lexempt
		                     * Owner is exempt from tax. Zero out taxes
		                     m.nworktot = 0
		                     lngastax1 = 0
		                  ELSE
		                     IF NOT m.lSev1G
		                        * Purchaser doesn't withhold, so subtract it
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser withholds, so mark as directly paid
		                        IF NOT m.lDirGasPurch
		                           * Purchaser doesn't withhold tax on directly paid owners
		                           m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                        ELSE
		                           * Purchaser withholds tax on direct paid tax
		                           m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               CASE m.ctype = 'GTAX2'
		                  IF m.lexempt
		                     * Owner is exempt from tax. Zero out taxes
		                     m.nworktot = 0
		                     lngastax2 = 0
		                  ELSE
		                     IF NOT m.lSev2G
		                        * Purchaser doesn't withhold, so subtract it
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser withholds, so mark as directly paid
		                        IF NOT m.lDirGasPurch
		                           * Purchaser doesn't withhold tax on directly paid owners
		                           m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                        ELSE
		                           * Purchaser withholds tax on direct paid tax
		                           m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               CASE m.ctype = 'GTAX3'
		                  IF m.lexempt
		                     * Owner is exempt from tax. Zero out taxes
		                     m.nworktot = 0
		                     lngastax3 = 0
		                  ELSE
		                     IF NOT m.lSev3G
		                        * Purchaser doesn't withhold, so subtract it
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser withholds, so mark as directly paid
		                        IF NOT m.lDirGasPurch
		                           * Purchaser doesn't withhold tax on directly paid owners
		                           m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                        ELSE
		                           * Purchaser withholds tax on direct paid tax
		                           m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               CASE m.ctype = 'GTAX4'
		                  IF m.lexempt
		                     * Owner is exempt from tax. Zero out taxes
		                     m.nworktot = 0
		                     lngastax4 = 0
		                  ELSE
		                     IF NOT m.lSev4G
		                        * Purchaser doesn't withhold, so subtract it
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser withholds, so mark as directly paid
		                        IF NOT m.lDirGasPurch
		                           * Purchaser doesn't withhold tax on directly paid owners
		                           m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                        ELSE
		                           * Purchaser withholds tax on direct paid tax
		                           m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                        ENDIF
		                     ENDIF
		                  ENDIF
		               OTHERWISE
		                  m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		            ENDCASE
		
		         CASE INLIST(lcdirect,'G','B') AND m.ctype = 'MCF' AND m.lflat AND m.ctypeint = 'G'
		            *
		            *  This owner is a gas owner and paid a flat rate
		            *
		            IF jflatcnt = 0
		               m.ninvamt = SWROUND(m.nflatrate * (m.nworkint/100),2)
		               m.ntotal  = 0
		               m.nworktot = m.nflatrate
		               jflatcnt = 1
		            ELSE
		               m.ninvamt = 0
		               m.nworktot = 0
		            ENDIF
		         CASE INLIST(lcdirect,'O','B') AND m.ctype = 'BBL' AND m.lflat AND m.ctypeint = 'O'
		            *
		            *  This owner is an oil owner and paid a flat rate
		            *
		            IF jflatcnt = 0
		               m.ninvamt = SWROUND(m.nflatrate * (m.nworkint/100),2)
		               m.ntotal  = 0
		               m.nworktot = m.nflatrate
		               jflatcnt = 1
		            ELSE
		               m.ninvamt = 0
		               m.nworktot = 0
		            ENDIF
		
		         OTHERWISE
		            *
		            *  The owner is not directly paid,
		            *  So the revenue is processed normally.
		            *
		            m.ntotal  = jgross
		            m.ninvamt = 0
		            m.nworktot = 0
		            IF m.lflat AND jnflatcount = 0
		               m.ninvamt = m.nflatrate
		               jnflatcount = 1
		            ELSE
		               IF 'TAX' $ m.ctype AND m.lexempt
		                  m.ninvamt = 0
		               ELSE
		                  m.ninvamt =  SWROUND((jgross*(m.nrevint/100)),2)
		               ENDIF
		            ENDIF
		      ENDCASE
		
		      m.ntotal   = jgross             && Re-establish total
		
		      *
		      *  Check to see if this owner gets gas or oil interest
		      *  If not, don't show that income on his statement
		      *
		      DO CASE
		         CASE m.ctype = 'BBL' AND m.nrevoil <> 0
		            IF m.nworktot <> 0
		               lntotinc = lntotinc + m.nworktot
		               lnoilinc  = lnoilinc + m.nworktot
		            ELSE
		               lntotinc  = lntotinc + m.ninvamt
		               lnoilinc  = lnoilinc + m.ninvamt
		            ENDIF
		            lnwelltot = lnwelltot + m.ninvamt
		         CASE m.ctype = 'EXO' AND m.nrevoil <> 0
		            IF m.nworktot <> 0
		               lntotinc = lntotinc + m.nworktot
		               lnoilexp = lnoilexp + m.nworktot
		            ELSE
		               lntotinc  = lntotinc + m.ninvamt
		               lnoilexp = lnoilexp + m.nworktot
		            ENDIF
		            lnwelltot = lnwelltot + m.ninvamt
		         CASE m.ctype = 'EXG' AND m.nrevgas <> 0
		            IF m.nworktot <> 0
		               lntotinc = lntotinc + m.nworktot
		               lngasexp = lngasexp + m.nworktot
		            ELSE
		               lntotinc  = lntotinc + m.ninvamt
		               lngasexp = lngasexp + m.nworktot
		            ENDIF
		            lnwelltot = lnwelltot + m.ninvamt
		         CASE m.ctype = 'MCF' AND m.nrevgas <> 0
		            IF m.nworktot <> 0
		               lntotinc = lntotinc + m.nworktot
		               lngasinc  = lngasinc + m.nworktot
		            ELSE
		               lntotinc  = lntotinc + m.ninvamt
		               lngasinc  = lngasinc + m.ninvamt
		            ENDIF
		            lnwelltot = lnwelltot + m.ninvamt
		         CASE m.ctype = 'OTH' AND m.nrevoth <> 0
		            IF m.nworktot <> 0
		               lntotinc = lntotinc + m.nworktot
		               lnothinc  = lnothinc + m.nworktot
		            ELSE
		               lntotinc  = lntotinc + m.ninvamt
		               lnothinc  = lnothinc + m.ninvamt
		            ENDIF
		            lnwelltot = lnwelltot + m.ninvamt
		         CASE m.ctype = 'OTAX1' AND m.nrevtax1 <> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + m.nworktot*-1
		            ELSE
		               lntaxes = lntaxes + m.ninvamt*-1
		            ENDIF
		            lnoiltax1 = lnoiltax1 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               IF llroyaltyowner
		                  IF lcdirect = 'B' OR lcdirect = 'O'
		                     lnwelltot = lnwelltot + m.ninvamt
		                  ELSE
		                     lnwelltot = lnwelltot + m.ninvamt
		                  ENDIF
		               ELSE
		                  IF lcdirect = 'B' OR lcdirect = 'O'
		                     lnwelltot = lnwelltot + m.ninvamt
		                  ELSE
		                     lnwelltot = lnwelltot + m.ninvamt
		                  ENDIF
		               ENDIF
		            ENDIF
		
		         CASE m.ctype = 'OTAX2' AND m.nrevtax4<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lnoiltax2 = lnoiltax2 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		
		         CASE m.ctype = 'OTAX3' AND m.nrevtax7<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lnoiltax3 = lnoiltax3 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		
		         CASE m.ctype = 'OTAX4' AND m.nrevtax10<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lnoiltax4 = lnoiltax4 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		
		         CASE m.ctype = 'GTAX1' AND m.nrevtax2 <> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lngastax1 = lngastax1 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               IF llroyaltyowner
		                  IF lcdirect = 'B' OR lcdirect = 'G'
		                     lnwelltot = lnwelltot + m.ninvamt
		                  ELSE
		                     lnwelltot = lnwelltot + m.ninvamt
		                  ENDIF
		               ELSE
		                  IF lcdirect = 'B' OR lcdirect = 'G'
		                     lnwelltot = lnwelltot + m.ninvamt
		                  ELSE
		                     lnwelltot = lnwelltot + m.ninvamt
		                  ENDIF
		               ENDIF
		            ENDIF
		
		         CASE m.ctype = 'GTAX2' AND m.nrevtax5<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lngastax2 = lngastax2 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		
		         CASE m.ctype = 'GTAX3' AND m.nrevtax8<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lngastax3 = lngastax3 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		
		         CASE m.ctype = 'GTAX4' AND m.nrevtax11<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lngastax4 = lngastax4 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		
		         CASE m.ctype = 'PTAX1' AND m.nrevtax3 <> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lnothtax1 = lnothtax1 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		         CASE m.ctype = 'PTAX2' AND m.nrevtax6<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lnothtax2 = lnothtax2 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		         CASE m.ctype = 'PTAX3' AND m.nrevtax9<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lnothtax3 = lnothtax3 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		
		         CASE m.ctype = 'PTAX4' AND m.nrevtax12<> 0
		            IF m.nworktot <> 0
		               lntaxes = lntaxes + (m.nworktot*-1)
		            ELSE
		               lntaxes = lntaxes + (m.ninvamt*-1)
		            ENDIF
		            lnothtax4 = lnothtax4 + (m.ninvamt*-1)
		            IF NOT m.lexempt
		               lnwelltot = lnwelltot + m.ninvamt
		            ENDIF
		
		         CASE m.ctype = 'TRANS' AND m.nrevtrp<> 0
		            lntrpinc  = lntrpinc + m.ninvamt
		            lntotinc  = lntotinc + m.ninvamt
		            lnwelltot = lnwelltot + m.ninvamt
		
		         CASE m.ctype = 'MISC1' AND m.nrevmisc1<> 0
		            lnmi1inc  = lnmi1inc + m.ninvamt
		            lntotinc  = lntotinc + m.ninvamt
		            lnwelltot = lnwelltot + m.ninvamt
		
		         CASE m.ctype = 'MISC2' AND m.nrevmisc2<> 0
		            lnmi2inc  = lnmi2inc + m.ninvamt
		            lntotinc  = lntotinc + m.ninvamt
		            lnwelltot = lnwelltot + m.ninvamt
		
		         CASE m.lflat
		            lnwelltot = lnwelltot + m.ninvamt
		      ENDCASE
		      STORE 0 TO m.ninvamt, m.ntotal, m.nprice, m.nunits, m.nrevint, jgross, ;
		         m.ngasrev, m.noilrev, m.nothrev, m.ntrprev, m.nworktot, m.nmiscrev1, m.nmiscrev2
		      STORE ' ' TO m.ctype, m.cdescript, m.cmiscmemo
		      m.nrevoil   = jnrevoil
		      m.nrevgas   = jnrevgas
		      m.nrevoth   = jnrevoth
		      m.nrevtax1  = jnrevtax1
		      m.nrevtax2  = jnrevtax2
		      m.nrevtax3  = jnrevtax3
		      m.nrevtax4  = jnrevtax4
		      m.nrevtax5  = jnrevtax5
		      m.nrevtax6  = jnrevtax6
		      m.nrevtax7  = jnrevtax7
		      m.nrevtax8  = jnrevtax8
		      m.nrevtax9  = jnrevtax9
		      m.nrevtax10 = jnrevtax10
		      m.nrevtax11 = jnrevtax11
		      m.nrevtax12 = jnrevtax12
		      m.nrevmisc1 = jnrevm1
		      m.nrevmisc2 = jnrevm2
		   ENDSCAN && Inctemp
		
		   STORE ' ' TO m.ctype, m.csource
		   IF NOT llincome AND m.lflat
		      lnwelltot = lnwelltot + m.nflatrate
		      llincome = .F.
		   ENDIF
		
		   **********************************************************
		   *  Process flat-rate royalties
		   **********************************************************
		   IF (lnflatgasamt <> 0 OR lnflatoilamt <> 0) AND NOT llroyaltyowner AND NOT llFlatAllocated
		      * Process Flat Gas
		      m.nrevint = m.nworkint
		      jwrk = lnflatgasamt * (m.nworkint/100)
		      IF lcdirect = 'G' OR lcdirect = 'B'
		         m.ninvamt = 0
		         m.ntotal  = 0
		         m.nworktot = jwrk * -1
		      ELSE
		         m.ninvamt = jwrk * -1
		      ENDIF
		      m.cdirect = lcdirect
		      lngasinc  = lngasinc + m.ninvamt
		      lntotinc  = lntotinc + m.ninvamt
		      lnwelltot = lnwelltot + m.ninvamt
		
		      * Process Flat Oil
		      jwrk = lnflatoilamt * (m.nworkint/100)
		      IF lcdirect = 'O' OR lcdirect = 'B'
		         m.ninvamt = 0
		         m.ntotal  = 0
		         m.nworktot = jwrk * -1
		      ELSE
		         m.ninvamt = jwrk * -1
		      ENDIF
		      m.cdirect = lcdirect
		      lnoilinc  = lnoilinc + m.ninvamt
		      lntotinc  = lntotinc + m.ninvamt
		      lnwelltot = lnwelltot + m.ninvamt
		      llFlatAllocated = .T.
		   ENDIF
		   STORE 0 TO lnflatoilamt, lnflatgasamt
		   STORE ' ' TO m.ctype
		   **********************************************************
		   *  Process taxes
		   **********************************************************
		   *
		   *  We check the lnTax variables to see if they are zero.
		   *  If they are, then no taxes were entered manually for
		   *  that product and we can calculate them here.  If the
		   *  variable is not zero, then it means the tax was entered
		   *  manually and we don't want to calculate it here for that
		   *  product.
		
		   SELECT wells
		   SET ORDER TO cwellid
		   IF SEEK (m.cwellid)
		      SCATTER MEMVAR
		      llroycomp = lExclRoyComp
		   ELSE
		      LOOP
		   ENDIF
		   IF m.nroyint <> 0
		      m.nrevotax = (m.nrevoil/m.nroyint) * 100
		      m.nrevgtax = (m.nrevgas/m.nroyint) * 100
		   ELSE
		      m.nrevotax = 0
		      m.nrevgtax = 0
		   ENDIF
		
		   SELE temptax
		   LOCATE FOR cwellid == m.cwellid AND hyear+hperiod = invtmp.hyear+invtmp.hperiod
		   IF NOT FOUND()
		      STORE 0 TO m.noiltax1, m.ngastax1, m.noiltax2, m.ngastax2, m.noiltax3, m.ngastax3, m.noiltax4, m.ngastax4
		   ENDIF
		
		   SELECT sevtax
		   SET ORDER TO ctable
		   IF NOT m.lusesev
		      IF (NOT EMPTY(m.ctable) AND SEEK(m.ctable))
		         SCATTER MEMVAR
		         IF m.lexempt             && Owner is Tax Exempt
		            m.ninvamt = 0
		            STORE 0 TO lnoiltax1, lnoiltax2, lnoiltax3, lnoiltax4
		            STORE 0 TO lngastax1, lngastax2, lngastax3, lngastax4
		            STORE 0 TO lnothtax1, lnothtax2, lnothtax3, lnothtax4
		         ELSE
		            IF INLIST(m.ctypeint,'B','O')     && Oil Interest
		               IF lnoiltax1 = 0     && Oil Tax 1 has not been entered by user
		                  IF m.lusesev  && Use well tax rates
		                     IF llroyaltyowner    && Owner is a royalty owner
		                        lnoiltax1  = SWROUND(((lnoilrevenue*(m.nroysevo/100))*(m.nrevoil/100)),2)
		                        lntaxes = lntaxes + lnoiltax1
		                     ELSE
		                        lnoiltax1  = SWROUND(((lnoilrevenue*(m.nwrksevo/100))*(m.nrevoil/100)),2)
		                        lntaxes = lntaxes + lnoiltax1
		                     ENDIF
		                  ELSE
		                     *  If the purchaser pays the tax, we don't calculate it here
		                     IF m.lSev1O AND INLIST(lcdirect,'O','B') AND m.lDirOilPurch
		                        lnoiltax1 = 0
		                     ELSE
		                        IF NOT llroyaltyowner AND m.lroysevtx
		                           IF m.cstate = 'NM'  AND FILE('nm.cfg')
		                              lnPct = m.nworkint
		                              lnPct = THIS.grossuptaxpct(m.cwellid,lnPct,'O')
		                           ELSE
		                              lnPct = m.nworkint
		                           ENDIF
		                           * The royalty owner is excluded from severance taxes
		                           lnoiltax1   = (SWROUND((m.ntotbbltx1-temptax.noiltax1)*(lnPct/100),2))
		                        ELSE
		                           IF llroyaltyowner AND m.lroysevtx
		                              lnoiltax1 = 0
		                           ELSE
		                              IF m.cstate = 'NM' AND FILE('nm.cfg')
		                                 lnPct = m.nrevtax1
		                                 lnPct = THIS.grossuptaxpct(m.cwellid,lnPct,'O')
		                              ELSE
		                                 lnPct = m.nrevtax1
		                              ENDIF
		                              lnoiltax1   = (SWROUND((m.ntotbbltx1-temptax.noiltax1)*(lnPct/100),2))
		                           ENDIF
		                        ENDIF
		                        lntaxes = lntaxes + lnoiltax1
		                     ENDIF
		                  ENDIF
		                  IF lnoiltax1 # 0 AND NOT m.lSev1O
		                     lnwelltot = lnwelltot - lnoiltax1
		                     m.ninvamt = 0
		                  ENDIF
		               ENDIF
		               IF lnoiltax2 = 0     && Oil Tax 2 has not been entered by user
		                  IF m.lSev2O AND INLIST(lcdirect,'O','B') AND m.lDirOilPurch
		                     lnoiltax2 = 0
		                  ELSE
		                     IF NOT llroyaltyowner AND m.lroysevtx
		                        lnoiltax2   = (SWROUND((m.ntotbbltx2-temptax.noiltax2)*(m.nworkint/100),2))
		                     ELSE
		                        IF llroyaltyowner AND m.lroysevtx
		                           lnoiltax2 = 0
		                        ELSE
		                           lnoiltax2   = (SWROUND((m.ntotbbltx2-temptax.noiltax2)*(m.nrevtax4/100),2))
		                        ENDIF
		                     ENDIF
		                     lntaxes = lntaxes + lnoiltax2
		                  ENDIF
		                  IF lnoiltax2  # 0 AND NOT m.lSev2O
		                     lnwelltot = lnwelltot - lnoiltax2
		                     m.ninvamt = 0
		                  ENDIF
		               ENDIF
		               IF lnoiltax3 = 0     && Oil Tax 3 has not been entered by user
		                  IF m.lSev3O AND INLIST(lcdirect,'O','B') AND m.lDirOilPurch
		                     lnoiltax3 = 0
		                  ELSE
		                     IF NOT llroyaltyowner AND m.lroysevtx
		                        lnoiltax3   = (SWROUND((m.ntotbbltx3-temptax.noiltax3)*(m.nworkint/100),2))
		                     ELSE
		                        IF llroyaltyowner AND m.lroysevtx
		                           lnoiltax3 = 0
		                        ELSE
		                           lnoiltax3   = (SWROUND((m.ntotbbltx3-temptax.noiltax3)*(m.nrevtax7/100),2))
		                        ENDIF
		                     ENDIF
		                     lntaxes = lntaxes + lnoiltax3
		                  ENDIF
		                  IF lnoiltax3  # 0 AND NOT m.lSev3O
		                     lnwelltot = lnwelltot - lnoiltax3
		                     m.ninvamt = 0
		                  ENDIF
		               ENDIF
		               IF lnoiltax4 = 0     && Oil Tax 4 has not been entered by user
		                  IF m.lSev4O AND INLIST(lcdirect,'O','B') AND m.lDirOilPurch
		                     lnoiltax4 = 0
		                  ELSE
		                     IF NOT llroyaltyowner AND m.lroysevtx
		                        lnoiltax4   = (SWROUND((m.ntotbbltx4-temptax.noiltax4)*(m.nworkint/100),2))
		                     ELSE
		                        IF llroyaltyowner AND m.lroysevtx
		                           lnoiltax4 = 0
		                        ELSE
		                           lnoiltax4   = (SWROUND((m.ntotbbltx4-temptax.noiltax4)*(m.nrevtax10/100),2))
		                        ENDIF
		                     ENDIF
		                     lntaxes = lntaxes + lnoiltax4
		                  ENDIF
		                  IF lnoiltax4  # 0 AND NOT m.lSev4O
		                     lnwelltot = lnwelltot - lnoiltax4
		                     m.ninvamt = 0
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            *****************************************************************************
		            *  Calculate gas taxes
		            *****************************************************************************
		            IF INLIST(m.ctypeint,'B','G')
		               IF lngastax1 = 0      && User did not enter gas tax 1
		                  IF m.lusesev  && Use well tax rates
		                     IF llroyaltyowner    && Owner is a royalty owner
		                        lngastax1  = SWROUND(((lngasrevenue*(m.nroysevg/100))*(m.nrevgas/100)),2)
		                        lntaxes = lntaxes + lngastax1
		                     ELSE
		                        lngastax1  = SWROUND(((lngasrevenue*(m.nwrksevg/100))*(m.nrevgas/100)),2)
		                        lntaxes = lntaxes + lngastax1
		                     ENDIF
		                  ELSE
		                     *  If the purchaser pays the tax, we don't calculate it here
		                     IF m.lSev1G AND INLIST(lcdirect,'G','B') AND m.lDirGasPurch
		                        lngastax1 = 0
		                     ELSE
		                        IF NOT llroyaltyowner AND m.lroysevtx
		                           IF m.cstate = 'NM' AND FILE('nm.cfg')
		                              lnPct = m.nworkint
		                              lnPct = THIS.grossuptaxpct(m.cwellid,lnPct,'O')
		                           ELSE
		                              lnPct = m.nworkint
		                           ENDIF
		                           lngastax1   = (SWROUND((m.ntotmcftx1-temptax.ngastax1)*(m.nworkint/100),2))
		                        ELSE
		                           IF llroyaltyowner AND m.lroysevtx
		                              lngastax1 = 0
		                           ELSE
		                              IF m.cstate = 'NM' AND FILE('nm.cfg')
		                                 lnPct = m.nrevtax2
		                                 lnPct = THIS.grossuptaxpct(m.cwellid,lnPct,'O')
		                              ELSE
		                                 lnPct = m.nrevtax2
		                              ENDIF
		                              lngastax1   = (SWROUND((m.ntotmcftx1-temptax.ngastax1)*(lnPct/100),2))
		                           ENDIF
		                        ENDIF
		                        lntaxes = lntaxes + lngastax1
		                     ENDIF
		                  ENDIF
		                  IF lngastax1 # 0 AND NOT m.lSev1G
		                     lnwelltot = lnwelltot - lngastax1
		                     m.ninvamt = 0
		                  ENDIF
		               ENDIF
		               IF lngastax2 = 0      && User did not enter gas tax 2
		                  IF m.lSev2G AND INLIST(lcdirect,'G','B') AND m.lDirGasPurch
		                     lngastax2 = 0
		                  ELSE
		                     IF NOT llroyaltyowner AND m.lroysevtx
		                        lngastax2   = (SWROUND((m.ntotmcftx2-temptax.ngastax2)*(m.nworkint/100),2))
		                     ELSE
		                        IF llroyaltyowner AND m.lroysevtx
		                           lngastax2 = 0
		                        ELSE
		                           lngastax2   = (SWROUND((m.ntotmcftx2-temptax.ngastax2)*(m.nrevtax5/100),2))
		                        ENDIF
		                     ENDIF
		                     lntaxes = lntaxes + lngastax2
		                  ENDIF
		                  IF lngastax2 # 0 AND NOT m.lSev2G
		                     lnwelltot = lnwelltot - lngastax2
		                     m.ninvamt = 0
		                  ENDIF
		               ENDIF
		               IF lngastax3 = 0      && User did not enter gas tax 3
		                  IF m.lSev3G AND INLIST(lcdirect,'G','B') AND m.lDirGasPurch
		                     lngastax3 = 0
		                  ELSE
		                     IF NOT llroyaltyowner AND m.lroysevtx
		                        lngastax3   = (SWROUND((m.ntotmcftx3-temptax.ngastax3)*(m.nworkint/100),2))
		                     ELSE
		                        IF llroyaltyowner AND m.lroysevtx
		                           lngastax3 = 0
		                        ELSE
		                           lngastax3   = (SWROUND((m.ntotmcftx3-temptax.ngastax3)*(m.nrevtax8/100),2))
		                        ENDIF
		                     ENDIF
		                     lntaxes = lntaxes + lngastax3
		                  ENDIF
		                  IF lngastax3 # 0 AND NOT m.lSev3G
		                     lnwelltot = lnwelltot - lngastax3
		                     m.ninvamt = 0
		                  ENDIF
		               ENDIF
		               IF lngastax4 = 0      && User did not enter gas tax 4
		                  IF m.lSev4G AND INLIST(lcdirect,'G','B') AND m.lDirGasPurch
		                     lngastax4 = 0
		                  ELSE
		                     IF NOT llroyaltyowner AND m.lroysevtx
		                        lngastax4   = (SWROUND((m.ntotmcftx4-temptax.ngastax4)*(m.nworkint/100),2))
		                     ELSE
		                        IF llroyaltyowner AND m.lroysevtx
		                           lngastax4 = 0
		                        ELSE
		                           lngastax4   = (SWROUND((m.ntotmcftx4-temptax.ngastax4)*(m.nrevtax11/100),2))
		                        ENDIF
		                     ENDIF
		                     lntaxes = lntaxes + lngastax4
		                  ENDIF
		                  IF lngastax4 # 0 AND NOT m.lSev4G
		                     lnwelltot = lnwelltot - lngastax4
		                     m.ninvamt = 0
		                  ENDIF
		               ENDIF
		            ENDIF
		            *****************************************************************************
		            *  Calculate other product taxes
		            *****************************************************************************
		            IF lnothtax1 = 0
		               IF m.lsev1p
		                  m.ntotothtx1 = 0
		               ELSE
		                  lnothtax1 = (SWROUND(m.ntotothtx1*(m.nrevtax3/100),2))
		                  lntaxes   = lntaxes + lnothtax1
		               ENDIF
		               IF lnothtax1 # 0 AND NOT m.lsev1p
		                  lnwelltot = lnwelltot - lnothtax1
		               ENDIF
		            ENDIF
		            IF lnothtax2 = 0
		               IF m.lsev2p
		                  m.ntotothtx2 = 0
		               ELSE
		                  lnothtax2 = (SWROUND(m.ntotothtx2*(m.nrevtax6/100),2))
		                  lntaxes   = lntaxes + lnothtax2
		               ENDIF
		               IF lnothtax1 # 0 AND NOT m.lsev2p
		                  lnwelltot = lnwelltot - lnothtax2
		               ENDIF
		            ENDIF
		            IF lnothtax3 = 0
		               IF m.lsev3p
		                  m.ntotothtx3 = 0
		               ELSE
		                  lnothtax3 = (SWROUND(m.ntotothtx3*(m.nrevtax9/100),2))
		                  lntaxes   = lntaxes + lnothtax3
		               ENDIF
		               IF lnothtax3 # 0 AND NOT m.lsev3p
		                  lnwelltot = lnwelltot - lnothtax3
		               ENDIF
		            ENDIF
		            IF lnothtax4 = 0
		               IF m.lsev4p
		                  m.ntotothtx4 = 0
		               ELSE
		                  lnothtax4 = (SWROUND(m.ntotothtx4*(m.nrevtax12/100),2))
		                  lntaxes   = lntaxes + lnothtax4
		               ENDIF
		               IF lnothtax4 # 0 AND NOT m.lsev4p
		                  lnwelltot = lnwelltot - lnothtax4
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ELSE
		      IF m.lexempt             && Owner is Tax Exempt
		         m.ninvamt = 0
		         STORE 0 TO lnoiltax1, lnoiltax2, lnoiltax3, lnoiltax4
		         STORE 0 TO lngastax1, lngastax2, lngastax3, lngastax4
		         STORE 0 TO lnothtax1, lnothtax2, lnothtax3, lnothtax4
		      ELSE
		         IF INLIST(m.ctypeint,'B','O')     && Oil Interest
		            IF lnoiltax1 = 0     && Oil Tax 1 has not been entered by user
		               IF m.lusesev  && Use well tax rates
		                  IF llroyaltyowner    && Owner is a royalty owner
		                     lnoiltax1  = SWROUND(((lnoilrevenue*(m.nroysevo/100))*(m.nrevoil/100)),2)
		                     lntaxes = lntaxes + lnoiltax1
		                  ELSE
		                     lnoiltax1  = SWROUND(((lnoilrevenue*(m.nwrksevo/100))*(m.nrevoil/100)),2)
		                     lntaxes = lntaxes + lnoiltax1
		                  ENDIF
		               ENDIF
		               IF lnoiltax1 # 0 AND NOT m.lSev1O
		                  lnwelltot = lnwelltot - lnoiltax1
		                  m.ninvamt = 0
		               ENDIF
		            ENDIF
		         ENDIF
		         *****************************************************************************
		         *  Calculate gas taxes
		         *****************************************************************************
		         IF INLIST(m.ctypeint,'B','G')
		            IF lngastax1 = 0      && User did not enter gas tax 1
		               IF m.lusesev  && Use well tax rates
		                  IF llroyaltyowner    && Owner is a royalty owner
		                     lngastax1  = SWROUND(((lngasrevenue*(m.nroysevg/100))*(m.nrevgas/100)),2)
		                     lntaxes = lntaxes + lngastax1
		                  ELSE
		                     lngastax1  = SWROUND(((lngasrevenue*(m.nwrksevg/100))*(m.nrevgas/100)),2)
		                     lntaxes = lntaxes + lngastax1
		                  ENDIF
		               ENDIF
		               IF lngastax1 # 0 AND NOT m.lSev1G
		                  lnwelltot = lnwelltot - lngastax1
		                  m.ninvamt = 0
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDIF
		
		   STORE 0 TO m.ntotal, m.ninvamt, m.nrevint
		   STORE ' ' TO m.csource, m.ctype
		
		   **********************************************************
		   *  Process compression and gathering charges
		   **********************************************************
		   IF INLIST(m.ctypeint,'B','G')
		      *  Gathering
		      IF (llroyaltyowner AND NOT llroycomp) OR NOT llroyaltyowner
		         IF NOT llroyaltyowner AND llroycomp
		            m.ninvamt = SWROUND(jngather*(m.nworkint/100),2)
		         ELSE
		            m.ninvamt = SWROUND(jngather*(m.nrevgas/100),2)
		         ENDIF
		         lngather = lngather + m.ninvamt
		      ELSE
		         m.ninvamt = 0
		      ENDIF
		      m.nrevint   = m.nrevgas
		      IF m.ninvamt # 0
		         lnwelltot = lnwelltot - m.ninvamt
		         m.ninvamt = 0
		      ENDIF
		
		      *  Compression
		      IF (llroyaltyowner AND NOT llroycomp) OR NOT llroyaltyowner
		         IF NOT llroyaltyowner AND llroycomp
		            m.ninvamt = SWROUND(jncompress*(m.nworkint/100),2)
		         ELSE
		            m.ninvamt = SWROUND(jncompress*(m.nrevgas/100),2)
		         ENDIF
		         lncompress = lncompress + m.ninvamt
		         m.nrevint   = m.nrevgas
		      ELSE
		         m.ninvamt = 0
		      ENDIF
		      IF m.ninvamt # 0
		         lnwelltot = lnwelltot - m.ninvamt
		         m.ninvamt = 0
		      ENDIF
		   ENDIF
		   STORE 0 TO m.ntotal, m.ninvamt, m.nrevint
		   STORE ' ' TO m.csource, m.ctype
		
		   **********************************************************
		   *  Process expenses
		   **********************************************************
		   STORE 0 TO m.ntotale1, m.ntotale2, m.ntotale3, m.ntotale4, m.ntotale5, m.ntotalea, m.ntotaleb
		
		   IF NOT m.lJIB
		      SELECT exptemp
		      SCAN FOR cwellid = m.cwellid AND cYear+cperiod = m.hyear+m.hperiod
		         SCATTER MEMVAR
		
		         *  Don't process marketing expenses here.
		         IF m.ccatcode = 'MKTG'
		            LOOP
		         ENDIF
		
		         *!*  Commented out 8/17/05 - pws
		         *!*    - to implement the ability to specify the class at data entry time.
		         *!*	         SELECT expcat
		         *!*	         SET ORDER TO ccatcode
		         *!*	         IF SEEK(m.ccatcode)
		         *!*	            m.cexpclass = cexpclass
		         *!*	         ELSE
		         *!*	            LOOP
		         *!*	         ENDIF
		         SELECT exptemp
		         IF llroyaltyowner AND m.cExpClass = '0' AND EMPTY(cownerid)
		            * Royalty owners don't get working interest expenses (unless it's a one-man item)....
		            LOOP
		         ENDIF
		         m.category = m.ccateg
		         *  Store original interests so we can change for one-man-items.  pws 3/11/97
		         jnworkint = m.nworkint
		         jnclass1  = m.nintclass1
		         jnclass2  = m.nintclass2
		         jnclass3  = m.nintclass3
		         jnclass4  = m.nintclass4
		         jnclass5  = m.nintclass5
		         jnclassa  = m.nacpint
		         jnclassb  = m.nbcpint
		         DO CASE
		            CASE m.cownerid = jcownerid AND NOT m.loneman
		               * If this is a royalty owner and they also have a working interest,
		               * don't process one man item for royalty interest.  pws 7/27/05
		               IF m.ctypeinv <> 'W'
		                  SELE wellinv
		                  LOCATE FOR cwellid == m.cwellid AND cownerid == jcownerid AND ctypeinv = 'W'
		                  IF FOUND()
		                     LOOP
		                  ENDIF
		               ENDIF
		               SELECT exptemp
		               REPLACE loneman WITH .T.
		               DO CASE
		                  CASE m.cExpClass = '0'
		                     m.nworkint = 100
		                  CASE m.cExpClass = '1'
		                     m.nintclass1 = 100
		                  CASE m.cExpClass = '2'
		                     m.nintclass2 = 100
		                  CASE m.cExpClass = '3'
		                     m.nintclass3 = 100
		                  CASE m.cExpClass = '4'
		                     m.nintclass4 = 100
		                  CASE m.cExpClass = '5'
		                     m.nintclass5 = 100
		                  CASE m.cExpClass = 'A'
		                     m.nacpint = 100
		                  CASE m.cExpClass = 'B'
		                     m.nbcpint = 100
		               ENDCASE
		            CASE m.cownerid = ' '
		               * Don't do anything if the cOwnerID is blank
		            CASE m.cownerid <> jcownerid
		               LOOP
		            CASE m.cownerid = jcownerid AND loneman
		               LOOP
		         ENDCASE
		         DO CASE
		            CASE m.cExpClass = '0'
		               m.ninvamt   = SWROUND(m.namount*(m.nworkint/100),2)
		               lntotexp   = lntotexp + m.ninvamt
		               IF NOT m.lJIB
		                  lnwelltot  = lnwelltot - m.ninvamt
		               ENDIF
		               STORE 0 TO m.ninvamt
		
		            CASE m.cExpClass = '1' AND m.nexpcl1 <> 0
		               m.ninvamt   = SWROUND((m.namount * (m.nintclass1/100)),2)
		               m.ntotale1  = m.ntotale1 + m.ninvamt
		               IF NOT m.lJIB
		                  lnwelltot  = lnwelltot - m.ninvamt
		               ENDIF
		               STORE 0 TO m.ninvamt
		
		            CASE m.cExpClass = '2' AND m.nexpcl2 <> 0
		               m.ninvamt   = SWROUND((m.namount * (m.nintclass2/100)),2)
		               m.ntotale2  = m.ntotale2 + m.ninvamt
		               IF NOT m.lJIB
		                  lnwelltot  = lnwelltot - m.ninvamt
		               ENDIF
		               STORE 0 TO m.ninvamt
		
		            CASE m.cExpClass = '3' AND m.nexpcl3 <> 0
		               m.ninvamt   = SWROUND((m.namount * (m.nintclass3/100)),2)
		               m.ntotale3  = m.ntotale3 + m.ninvamt
		               IF NOT m.lJIB
		                  lnwelltot  = lnwelltot - m.ninvamt
		               ENDIF
		               STORE 0 TO m.ninvamt
		
		            CASE m.cExpClass = '4' AND m.nexpcl4 <> 0
		               m.ninvamt   = SWROUND((m.namount * (m.nintclass4/100)),2)
		               m.ntotale4  = m.ntotale4 + m.ninvamt
		               IF NOT m.lJIB
		                  lnwelltot  = lnwelltot - m.ninvamt
		               ENDIF
		               STORE 0 TO m.ninvamt
		
		            CASE m.cExpClass = '5' AND m.nexpcl5 <> 0
		               m.ninvamt   = SWROUND((m.namount * (m.nintclass5/100)),2)
		               m.ntotale5  = m.ntotale5 + m.ninvamt
		               IF NOT m.lJIB
		                  lnwelltot  = lnwelltot - m.ninvamt
		               ENDIF
		               STORE 0 TO m.ninvamt
		
		            CASE m.cExpClass = 'A' AND m.nexpcla <> 0
		               m.ninvamt   = SWROUND((m.namount * (m.nacpint/100)),2)
		               m.ntotalea  = m.ntotalea + m.ninvamt
		               IF NOT m.lJIB
		                  lnwelltot  = lnwelltot - m.ninvamt
		               ENDIF
		               STORE 0 TO m.ninvamt
		
		            CASE m.cExpClass = 'B' AND m.nexpclb <> 0
		               m.ninvamt   = SWROUND((m.namount * (m.nbcpint/100)),2)
		               m.ntotaleb  = m.ntotaleb + m.ninvamt
		               IF NOT m.lJIB
		                  lnwelltot  = lnwelltot - m.ninvamt
		               ENDIF
		               STORE 0 TO m.ninvamt
		         ENDCASE
		         *  Restore original interests in case one-man-item logic changed them. pws 3/11/97
		         m.nworkint   = jnworkint
		         m.nintclass5 = jnclass5
		         m.nintclass4 = jnclass4
		         m.nintclass3 = jnclass3
		         m.nintclass2 = jnclass2
		         m.nintclass1 = jnclass1
		         m.nacpint    = jnclassa
		         m.nbcpint    = jnclassb
		      ENDSCAN  && exptemp
		   ENDIF
		   WAIT CLEAR
		
		   *************************************************************
		   *  Process marketing expenses
		   *************************************************************
		   STORE 0 TO lnMKTGExp
		   SELECT mktgtemp
		   SCAN FOR cwellid = m.cwellid AND cYear+cperiod = m.hyear+m.hperiod
		      SCATTER MEMVAR
		      m.ninvamt   = SWROUND(m.namount*(m.nrevgas/100),2)
		      lnMKTGExp   = lnMKTGExp + m.ninvamt
		      lnwelltot  = lnwelltot - m.ninvamt
		   ENDSCAN  && exptemp
		
		   *************************************************************
		   *  Process well net total
		   *************************************************************
		   m.nworkint = jnworkint
		   *
		   * Calculate tax withholding
		   *
		   IF m.ntaxpct <> 0
		      IF m.cdirect = 'O'
		         lntaxgross = lntotinc - lnoilinc
		      ELSE
		         lntaxgross = lntotinc
		      ENDIF
		      IF m.cdirect = 'G'
		         lntaxgross = lntotinc - lngasinc
		      ELSE
		         lntaxgross = lntotinc
		      ENDIF
		      IF m.cdirect = 'B'
		         lntaxgross = lntotinc - lngasinc - lnoilinc
		      ELSE
		         lntaxgross = lntotinc
		      ENDIF
		      m.ntaxwith = SWROUND(lntaxgross * (m.ntaxpct/100),2)
		   ELSE
		      m.ntaxwith = 0
		   ENDIF
		
		   *
		   * Calculate backup withholding
		   *
		   IF m.lbackwith
		      m.nbackwith = SWROUND(lnwelltot * (m.nbackpct/100),2)
		   ELSE
		      m.nbackwith = 0
		   ENDIF
		
		   *
		   *  Subtract the tax withholding and backup withholding from net total
		   *
		   lnwelltot = lnwelltot - m.ntaxwith - m.nbackwith
		
		   SELECT invtmp
		   REPLACE hperiod   WITH m.hperiod, ;
		      hyear      WITH m.hyear, ;
		      hdate      WITH THIS.dacctdate, ;
		      noilrev    WITH lnoilinc, ;
		      ngasrev    WITH lngasinc, ;
		      ntrprev    WITH lntrpinc, ;
		      nothrev    WITH lnothinc, ;
		      nmiscrev1  WITH lnmi1inc, ;
		      nmiscrev2  WITH lnmi2inc, ;
		      nMKTGExp   WITH lnMKTGExp, ;
		      noilexp    WITH lnoilexp, ;
		      ngasexp    WITH lngasexp, ;
		      nincome    WITH lntotinc, ;
		      nexpense   WITH lntotexp, ;
		      nflatrate  WITH m.nflatrate, ;
		      ntotale1   WITH m.ntotale1, ;
		      ntotale2   WITH m.ntotale2, ;
		      ntotale3   WITH m.ntotale3, ;
		      ntotale4   WITH m.ntotale4, ;
		      ntotale5   WITH m.ntotale5, ;
		      ntotalea   WITH m.ntotalea, ;
		      ntotaleb   WITH m.ntotaleb, ;
		      nrevtax1   WITH m.nrevtax1, ;
		      nrevtax2   WITH m.nrevtax2, ;
		      nrevtax3   WITH m.nrevtax3, ;
		      nrevtax4   WITH m.nrevtax4, ;
		      nrevtax5   WITH m.nrevtax5, ;
		      nrevtax6   WITH m.nrevtax6, ;
		      nrevtax7   WITH m.nrevtax7, ;
		      nrevtax8   WITH m.nrevtax8, ;
		      nrevtax9   WITH m.nrevtax9, ;
		      nrevtax10  WITH m.nrevtax10, ;
		      nrevtax11  WITH m.nrevtax11, ;
		      nrevtax12  WITH m.nrevtax12, ;
		      nnetcheck  WITH lnwelltot, ;
		      nsevtaxes  WITH lntaxes, ;
		      noiltax1   WITH lnoiltax1, ;
		      ngastax1   WITH lngastax1, ;
		      nothtax1   WITH lnothtax1, ;
		      noiltax2   WITH lnoiltax2, ;
		      ngastax2   WITH lngastax2, ;
		      nothtax2   WITH lnothtax2, ;
		      noiltax3   WITH lnoiltax3, ;
		      ngastax3   WITH lngastax3, ;
		      nothtax3   WITH lnothtax3, ;
		      noiltax4   WITH lnoiltax4, ;
		      ngastax4   WITH lngastax4, ;
		      nothtax4   WITH lnothtax4, ;
		      ngather    WITH lngather, ;
		      ncompress  WITH lncompress, ;
		      nbackwith  WITH m.nbackwith, ;
		      ntaxwith   WITH m.ntaxwith
		
		   STORE 0 TO m.ntotale1, m.ntotale2, m.ntotale3, m.ntotale4, m.ntotale5, lnoiltax, lngastax1, ;
		      lnmi1inc, lnmi2inc, lnoilinc, lngasinc, lntrpinc, lntotinc, lntotexp, ;
		      lnoilexp, lngasexp, m.nbackwith, m.ntaxwith, m.ntotalea, m.ntotaleb
		   lcperiod1 = lcsaveprd1
		   lcperiod2 = lcsaveprd2
		ENDSCAN
		
		* Check for negative backup and/or tax withholding amounts for the run and remove them.
		THIS.checkbacktax()
		
		IF NOT THIS.lquiet
		   oprogress.closeprogress()
		   RELE oprogress
		   DOEVENTS
		ENDIF
		
		*
		*  Get rid of zero records
		*
		SELECT invtmp
		SCAN FOR hperiod = '13'
		   *   DELETE NEXT 1
		ENDSCAN
		
		SET SAFETY OFF
		INDEX ON cwellid+cownerid TAG wellinv
		INDEX ON cownerid+cwellid TAG invwell
		INDEX ON cwellid TAG cwellid
		INDEX ON cownerid+cwellid+ctypeinv+ctypeint+cprogcode TAG invtype
		INDEX ON nrunno TAG nrunno
		INDEX ON crunyear TAG crunyear
		INDEX ON cownerid TAG cownerid
		
		IF THIS.lClose
		   THIS.oprogress.SetProgressMessage('Allocating Revenue and Expenses to the Owners...')
		   THIS.oprogress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Ending ownerproc')
		ENDIF
		
	ENDPROC

	PROCEDURE ownerstub		&& Creates stub cursor for check stubs and stub report.
		LPARA tlStubRpt, tcRunYear, tnRunNo, tcOwner1, tcOwner2
		*  tlStubRpt - .T. = called from owner stub report
		*  tcRunYear - the run year when called from stub report
		*  tnRunNo   - the run no when called from stub report
		*  tcOwner1  - the 1st owner to include in the report
		*  tcOwner2  - the last owner to include in the report
		LOCAL lnCount, lnMaxLines, lcidChec, lnMax, lnProcess, llDistProc, tcFirst, tcLast, lcOldWellName
		LOCAL ldAcctDate, m.cIntType, tcYear, tcPeriod, tcGroup, llEcho
		
		WAIT WIND NOWAIT 'Starting stub processing....'
		
		STORE ' ' TO tcFirst, tcLast, m.cIntType
		STORE {}  TO ldAcctDate
		
		IF FILE('echo.cfg')
		   llEcho = .T.
		ELSE
		   llEcho = .F.
		ENDIF
		
		IF USED('invtmp')
		   USE IN invtmp
		ENDIF
		IF USED('invtmp1')
		   USE IN invtmp1
		ENDIF
		
		*
		*  Setup Global Options
		*
		SELECT options
		GO TOP
		glVouchMsg   = lvouchmsg
		glSkipPerf   = lSkipPerf
		gnStubLine   = nStubLine
		llVoidNext   = lVoidNext
		llDupStub    = lDupStub
		llSplitWell  = lAdjMin           &&  Need to change this variable name in the future.
		llHideComp   = lHideComp
		llChgPrice   = lChgPrice
		
		IF gnStubLine = 0
		   gnStubLine = 12
		ENDIF
		
		CREATE CURSOR stub ;
		   (cid           C(10), ;
		   cidtype        C(1), ;
		   cpayee         C(60), ;
		   cprogcode      C(10), ;
		   ccheckno       C(10), ;
		   cidchec        C(8), ;
		   crptgroup      C(2), ;
		   cwellid        C(11), ;
		   cwellname      C(60), ;
		   ccounty        C(25), ;
		   cstate         C(2), ;
		   nincome        N(9,2), ;
		   nbbl           N(12,2), ;
		   cIncType       C(1), ;
		   nmcf           N(12,2), ;
		   nbblprice      N(12,6), ;
		   nmcfprice      N(12,6), ;
		   noilrev        N(12,2), ;
		   ngasrev        N(12,2), ;
		   cIntType       C(1), ;
		   cDesc          C(60), ;
		   cinvnum        C(20), ;
		   dinvdate       D, ;
		   dcheckdate     D, ;
		   ninvtot        N(12,2), ;
		   namtpaid       N(12,2), ;
		   ndisctot       N(12,2), ;
		   nAmount        N(12,2), ;
		   dproddate      D, ;
		   nexpense       N(9,2), ;
		   ntax           N(9,2), ;
		   ntaxes         N(9,2), ;
		   nnetcheck      N(9,2), ;
		   creference     C(20), ;
		   nother         N(9,2), ;
		   cprodprd       C(5), ;
		   crefid         C(20), ;
		   cyear          C(4), ;
		   cperiod        C(2), ;
		   nunits         N(12,2), ;
		   nprice         N(12,4), ;
		   ntotalinc      N(12,2), ;
		   ntax1          N(12,2), ;
		   ntax2          N(12,2), ;
		   ntax3          N(12,2), ;
		   ntax4          N(12,2), ;
		   nexpcl0        N(12,2), ;
		   nexpcl1        N(12,2), ;
		   nexpcl2        N(12,2), ;
		   nexpcl3        N(12,2), ;
		   nexpcl4        N(12,2), ;
		   nexpcl5        N(12,2), ;
		   nowntax        N(12,2), ;
		   nnetval        N(12,2), ;
		   ninterest      N(11,7), ;
		   nowngross      N(12,2), ;
		   nWellGath      N(12,2), ;
		   nWellComp      N(12,2), ;
		   lskip          L, ;
		   npageno        I, ;
		   cGROUP         C(2))
		INDEX ON cid+cGROUP+cprogcode TAG cid
		IF NOT tlStubRpt  &&  Index on cid if doing the stub report, since the cidchec doesn't get set when doing a stub rpt, and really screws up the order that the statements print in - BH 06/02/2004
		   IF llVoidNext &&OR (glSkipPerf and NOT llDupStub)  &&  Set order to the order added to the table, which keeps spacing and blank lines in correct place
		      INDEX ON RECNO() TAG cidchec
		   ELSE
		      INDEX ON cidchec+crptgroup+cwellid+cprodprd TAG cidchec
		   ENDIF
		ELSE
		   INDEX ON cid+crptgroup+cwellid+cprodprd TAG cidchec
		ENDIF
		
		
		* Don't allow more than 12 lines per stub if
		* we're doing duplicate stubs. This keeps from
		* printing an extra check for the duplicate stub.
		IF llDupStub
		   gnStubLine = 12
		ENDIF
		
		*  If the stub splits the wellname to the 1st line and paid info on the 2nd line
		*  the # of lines needs to be manipulated to account for it.
		IF llSplitWell = .T.
		   gnStubLine = gnStubLine/2
		ENDIF
		
		llDistProc = .F.
		
		CREATE CURSOR tempprds ;
		   (cyear    C(4), ;
		   nRunNo   I, ;
		   cGROUP    C(2), ;
		   dAcctDate D, ;
		   cDMBatch  C(8))
		
		lnProcess = 1
		
		IF NOT tlStubRpt
		   SELECT pickchks
		   lnMax = RECC()
		
		   * If printing check stubs, we need to know what run the checks came from so
		   * that they can be matched up with records from distproc
		   SELECT DISTINCT cbatch FROM pickchks ;
		      INTO CURSOR laPeriod
		
		   IF _TALLY = 1
		      SELECT laPeriod
		      lcDMBatch = cbatch
		      SELECT sysctl
		      SET ORDER TO cDMBatch
		      IF SEEK(lcDMBatch)
		         m.cDMBatch  = cDMBatch
		         m.cyear     = cyear
		         m.nRunNo    = nRunNo
		         m.cGROUP    = cGROUP
		         m.dAcctDate = dAcctDate
		         ldAcctDate  = dAcctDate
		         INSERT INTO tempprds FROM MEMVAR
		      ELSE
		         SELECT pickchks
		         m.cyear   = cyear
		         m.cperiod = cperiod
		         m.cGROUP  = cGROUP
		         m.cDMBatch = ''
		         m.dAcctDate = {}
		         INSERT INTO tempprds FROM MEMVAR
		      ENDIF
		      SELECT pickchks
		      GO TOP
		      tcFirst  = cid
		      GO BOTT
		      tcLast   = cid
		   ELSE
		      llDistProc = .F.
		      SELECT laPeriod
		      SCAN
		         lcDMBatch = cbatch
		         SELECT sysctl
		         SET ORDER TO cDMBatch
		         IF SEEK(lcDMBatch)
		            m.cDMBatch  = cDMBatch
		            m.cyear     = cyear
		            m.nRunNo    = nRunNo
		            m.cGROUP    = cGROUP
		            m.dAcctDate = dAcctDate
		            ldAcctDate  = dAcctDate
		            m.dcheckdate = dAcctDate
		            INSERT INTO tempprds FROM MEMVAR
		         ENDIF
		      ENDSCAN
		
		      SELECT pickchks
		      GO TOP
		      tcFirst  = cid
		      GO BOTT
		      tcLast   = cid
		      SELECT disbhist.* FROM disbhist ;
		         WHERE BETWEEN(cOwnerID,tcFirst,tcLast) ;
		         AND cRunYear+PADL(transform(nRunNo),3,'0') IN (SELECT cyear+PADL(transform(nRunNo),3,'0') FROM tempprds) ;
		         AND lOnHold = .F. ;
		         INTO CURSOR invtmp1 ;
		         ORDER BY cOwnerID, disbhist.cwellid
		      IF USED('invtmp')
		         USE IN invtmp
		      ENDIF
		      USE DBF('invtmp1') AGAIN IN 0 ALIAS invtmp
		
		      SELECT tempprds
		      SCAN
		         SCATTER MEMVAR
		         lcRunYear = m.cyear
		         lnRunNo   = m.nRunNo
		         SELECT susaudit
		         SCAN FOR cRunYear = lcRunYear AND nRunNo = lnRunNo AND caction = 'O' AND BETWEEN(cOwnerID,tcFirst,tcLast)
		            SELECT invtmp
		            SCATTER MEMVAR BLANK
		            SELECT susaudit
		            SCATTER MEMVAR
		            m.cTypeInv = 'S'
		            m.nnetcheck = m.nAmount
		            m.hYear   = m.cyear
		            m.hPeriod = m.cperiod
		            INSERT INTO invtmp FROM MEMVAR
		         ENDSCAN
		      ENDSCAN
		   ENDIF
		ELSE
		   SELE sysctl
		   LOCATE FOR cRunYear = tcRunYear AND nRunNo = tnRunNo AND ctypeclose = 'R'
		   IF FOUND()
		      m.cDMBatch  = cDMBatch
		      m.cyear     = cyear
		      m.nRunNo    = nRunNo
		      m.cGROUP    = cGROUP
		      m.dAcctDate = dAcctDate
		      ldAcctDate  = dAcctDate
		      m.dcheckdate = dAcctDate
		      INSERT INTO tempprds FROM MEMVAR
		   ELSE
		      RETURN
		   ENDIF
		   tcFirst = tcOwner1
		   tcLast  = tcOwner2
		ENDIF
		
		IF NOT USED('invtmp1')
		   WAIT WIND NOWAIT 'Building stub work files....'
		   SELECT disbhist.* FROM disbhist ;
		      WHERE BETWEEN(cOwnerID,tcFirst,tcLast) ;
		      AND cRunYear+STR(nRunNo) IN (SELECT cyear+STR(nRunNo) FROM tempprds) ;
		      AND lOnHold = .F. ;
		      INTO CURSOR invtmp1 ;
		      ORDER BY cOwnerID, disbhist.cwellid
		ENDIF
		
		llDistProc = .T.
		IF USED('invtmp')
		   USE IN invtmp
		ENDIF
		USE DBF('invtmp1') AGAIN IN 0 ALIAS invtmp
		
		SELECT tempprds
		SCAN
		   SCATTER MEMVAR
		   SELECT groups
		   LOCATE FOR cGROUP == m.cGROUP AND lNetDef = .T.  &&  Netting, so skip out of the processing to delete negative wells
		   IF FOUND()
		      LOOP
		   ELSE  &&  Not netting, so delete the negative wells - sum the totals for each well first, and then delete the negs
		
		      IF USED('temp')
		         USE IN temp
		      ENDIF
		
		      SELE cOwnerID,cwellid,SUM(nnetcheck) AS nnetcheck FROM invtmp   ;
		         WHERE cRunYear = m.cyear AND nRunNo = m.nRunNo AND cGROUP = m.cGROUP  ;
		         INTO CURSOR temp GROUP BY cOwnerID,cwellid
		
		      SELECT temp
		      SCAN FOR nnetcheck < 0
		         SELECT invtmp
		         SCAN FOR cOwnerID = temp.cOwnerID AND cwellid = temp.cwellid AND cRunYear = m.cyear AND nRunNo = m.nRunNo
		            DELETE NEXT 1
		         ENDSCAN
		      ENDSCAN
		
		   ENDIF
		ENDSCAN
		
		SELECT tempprds
		SCAN
		   SCATTER MEMVAR
		   lcRunYear = m.cyear
		   lnRunNo   = m.nRunNo
		   SELECT susaudit
		   SCAN FOR cRunYear = lcRunYear AND nRunNo = lnRunNo AND caction = 'O' AND BETWEEN(cOwnerID,tcFirst,tcLast)
		      SELECT invtmp
		      SCATTER MEMVAR BLANK
		      SELECT susaudit
		      SCATTER MEMVAR
		      m.cTypeInv = 'S'
		      m.nnetcheck = m.nAmount
		      m.hYear = m.cyear
		      m.hPeriod = m.cperiod
		      SELE invtmp
		      LOCATE FOR cTypeInv = 'S' AND cwellid == m.cwellid AND cOwnerID == m.cOwnerID AND nnetcheck == m.nnetcheck
		      IF NOT FOUND()
		         INSERT INTO invtmp FROM MEMVAR
		      ENDIF
		   ENDSCAN
		ENDSCAN
		
		SELE invtmp
		lnMax = RECC()
		
		WAIT CLEAR
		
		*
		*  Set up the progress bar
		*
		oProgress = THIS.oMessage.ProgressBar('Building check stubs for the selected owners...')
		oProgress.SetProgressRange(0,lnMax)
		oProgress.UpdateProgress(lnProcess)
		
		*
		*  Get the fiscal year and period
		*
		IF m.goApp.lAMVersion
		   oGL = CREATEOBJECT('glmaint')
		   lcYear   = oGL.getperiod(ldAcctDate,.T.)
		   lcPeriod = oGL.getperiod(ldAcctDate,.F.)
		ENDIF
		
		IF tlStubRpt
		   CREATE CURSOR pickchks ;
		      (cid     C(10), ;
		      cichec  C(8), ;
		      lnostub L, ;
		      cbatch  C(8))
		   SELE cOwnerID AS cid, m.cDMBatch AS cbatch, SPACE(8) AS cidchec, lnostubdetail AS lnostub FROM investor WHERE BETWEEN(cOwnerID,tcOwner1,tcOwner2) INTO CURSOR tempown ORDER BY cOwnerID
		   m.cbatch = m.cDMBatch
		   m.cidchec = ''
		   SELE pickchks
		   APPEND FROM DBF('tempown')
		ENDIF
		
		IF USED('invtmp')
		   *
		   *  Get Income Info
		   *
		   SELECT cwellid, cyear, cperiod, csource, ;
		      dRevDate, SUM(ntotalinc) AS ntotalinc, ;
		      SUM(nunits) AS nunits, nprice AS nrate, ;
		      '     ' AS cprodprd, crefid ;
		      FROM income ;
		      WHERE cRunYear+STR(nRunNo) IN (SELECT cyear+STR(nRunNo) FROM tempprds) ;
		      AND (EMPTY(cOwnerID)) ;
		      INTO CURSOR tempinc ;
		      ORDER BY cwellid, cyear, cperiod, csource ;
		      GROUP BY cwellid, cyear, cperiod, csource
		   INDEX ON cwellid+cyear+cperiod+csource TAG wellprd
		
		   *  Special option for Echo Drilling   1/3/2005 pws
		   IF llEcho
		      INDEX ON cwellid+cyear+cperiod+csource+crefid TAG wellprd
		   ENDIF
		
		   *
		   *  Use the cursor again to make it r/w
		   *
		   IF USED('rwinc')
		      USE IN rwinc
		   ENDIF
		   USE DBF('tempinc') AGAIN IN 0 ALIAS rwinc
		   *
		   *  Plug in the fiscal period
		   *
		   IF m.goApp.lAMVersion
		      m.cprodprd = lcPeriod +'/'+ RIGHT(lcYear,2)
		   ENDIF
		
		   *
		   *  Get stub info from invtmp
		   *
		   SELECT invtmp.cOwnerID AS cid, ;
		      invtmp.cwellid, ;
		      invtmp.nincome, ;
		      SUM(invtmp.nexpense) AS ntotale,  ;
		      SUM(invtmp.nsevtaxes) AS ntaxes, ;
		      SUM(invtmp.nnetcheck) AS nnetcheck, ;
		      SUM(invtmp.nmiscrev1+invtmp.nmiscrev2) AS nmiscrev, ;
		      invtmp.cdirect, ;
		      invtmp.cprogcode, ;
		      invtmp.cGROUP, ;
		      invtmp.hYear, ;
		      invtmp.hPeriod, ;
		      invtmp.cTypeInv AS cIntType, ;
		      invtmp.ctypeint AS cProdType, ;
		      invtmp.ljib, ;
		      invtmp.nrevgas, ;
		      invtmp.nworkint, ;
		      invtmp.nrevoil, ;
		      invtmp.nrevtrp, ;
		      invtmp.nrevoth, ;
		      invtmp.nrevmisc1, ;
		      invtmp.nrevmisc2, ;
		      invtmp.ntaxwith, ;
		      invtmp.nbackwith, ;
		      invtmp.cRunYear, ;
		      invtmp.nRunNo, ;
		      0000.00 AS nmcf, ;
		      0000.00 AS nbbl, ;
		      000000.00 AS nexpcl0, ;
		      000000.00 AS nexpcl1, ;
		      000000.00 AS nexpcl2, ;
		      000000.00 AS nexpcl3, ;
		      000000.00 AS nexpcl4, ;
		      000000.00 AS nexpcl5, ;
		      SUM(invtmp.noilrev) AS noilrev, ;
		      SUM(invtmp.ngasrev) AS ngasrev, ;
		      SUM(invtmp.nothrev) AS nothrev, ;
		      SUM(invtmp.ntrprev) AS ntrprev, ;
		      SUM(invtmp.nmiscrev1) AS nmiscrev1, ;
		      SUM(invtmp.nmiscrev2) AS nmiscrev2, ;
		      SUM(invtmp.nmktgexp) AS nmktgexp, ;
		      SUM(invtmp.ntotale1) AS ntotale1, ;
		      SUM(invtmp.ntotale2) AS ntotale2, ;
		      SUM(invtmp.ntotale3) AS ntotale3, ;
		      SUM(invtmp.ntotale4) AS ntotale4, ;
		      SUM(invtmp.ntotale5) AS ntotale5, ;
		      SUM(invtmp.nTotaleA) AS nTotaleA,  ;
		      SUM(invtmp.nTotaleB) AS nTotaleB,  ;
		      invtmp.lsevpurch, ;
		      invtmp.noiltax1 AS nWellotax1, ;
		      invtmp.ngastax1 AS nWellgtax1, ;
		      invtmp.nothtax1 AS nWellptax1, ;
		      invtmp.noiltax2 AS nWellotax2, ;
		      invtmp.ngastax2 AS nWellgtax2, ;
		      invtmp.nothtax2 AS nWellptax2, ;
		      invtmp.noiltax3 AS nWellotax3, ;
		      invtmp.ngastax3 AS nWellgtax3, ;
		      invtmp.nothtax3 AS nWellptax3, ;
		      invtmp.noiltax4 AS nWellotax4, ;
		      invtmp.ngastax4 AS nWellgtax4, ;
		      invtmp.nothtax4 AS nWellptax4, ;
		      SUM(invtmp.noiltax1) AS noiltax1, ;
		      SUM(invtmp.ngastax1) AS ngastax1, ;
		      SUM(invtmp.nothtax1) AS nothtax1, ;
		      SUM(invtmp.noiltax2) AS noiltax2, ;
		      SUM(invtmp.ngastax2) AS ngastax2, ;
		      SUM(invtmp.nothtax2) AS nothtax2, ;
		      SUM(invtmp.noiltax3) AS noiltax3, ;
		      SUM(invtmp.ngastax3) AS ngastax3, ;
		      SUM(invtmp.nothtax3) AS nothtax3, ;
		      SUM(invtmp.noiltax4) AS noiltax4, ;
		      SUM(invtmp.ngastax4) AS ngastax4, ;
		      SUM(invtmp.nothtax4) AS nothtax4, ;
		      SUM(invtmp.ngather)  AS ngather, ;
		      SUM(invtmp.ncompress) AS ncompress, ;
		      000000.00 AS nWellComp, ;
		      000000.00 AS nWellGath, ;
		      000000.00 AS ntax1, ;
		      000000.00 AS ntax2, ;
		      000000.00 AS ntax3, ;
		      000000.00 AS ntax4, ;
		      invtmp.nrevtax1, ;
		      invtmp.nrevtax2, ;
		      invtmp.nrevtax3, ;
		      invtmp.nrevtax4, ;
		      invtmp.nrevtax5, ;
		      invtmp.nrevtax6, ;
		      invtmp.nrevtax7, ;
		      invtmp.nrevtax8, ;
		      invtmp.nrevtax9, ;
		      invtmp.nrevtax10, ;
		      invtmp.nrevtax11, ;
		      invtmp.nrevtax12, ;
		      invtmp.nflatrate, ;
		      wells.lgather, ;
		      wells.ngather AS ngathrate, ;
		      wells.lcompress, ;
		      wells.ncompress AS ncomprate, ;
		      'I' AS cidtype, ;
		      wells.cwellname, ;
		      investor.cOwnname AS cpayee,  ;
		      investor.lExempt ;
		      FROM invtmp  ;
		      LEFT OUTER JOIN wells  ;
		      ON invtmp.cwellid == wells.cwellid  ;
		      JOIN investor   ;
		      ON invtmp.cOwnerID == investor.cOwnerID ;
		      WHERE invtmp.crectype <> 'J' ;
		      INTO CURSOR disbchkx ;
		      ORDER BY invtmp.cOwnerID, invtmp.cwellid, invtmp.hYear, invtmp.hPeriod, invtmp.cGROUP, invtmp.cTypeInv, invtmp.ctypeint, invtmp.cprogcode, invtmp.cGROUP, invtmp.ciddisb ;
		      GROUP BY invtmp.cOwnerID, invtmp.cwellid, invtmp.hYear, invtmp.hPeriod, invtmp.cGROUP, invtmp.cTypeInv, invtmp.ctypeint, invtmp.cprogcode, invtmp.cGROUP, invtmp.ciddisb
		
		   IF _TALLY # 0
		      IF USED('disbchks')
		         USE IN disbchks
		      ENDIF
		      USE DBF('disbchkx') AGAIN ALIAS disbchks IN 0
		
		      SELECT pickchks
		      SCAN
		         lcidChec = cidchec
		         m.cidchec = cidchec
		         lcOwner   = cid
		         lcBatch   = cbatch
		         llNoStub  = lnostub
		
		         SELECT sysctl
		         LOCATE FOR cDMBatch == lcBatch
		         IF FOUND()
		            lcRunYear = cyear
		            lnRunNo   = nRunNo
		         ELSE
		            lcRunYear = ''
		            lnRunNo   = 0
		         ENDIF
		         lnProcess = lnProcess + 1
		         oProgress.UpdateProgress(lnProcess)
		
		         SELECT disbchks
		         SCAN FOR cid = lcOwner AND cRunYear = lcRunYear AND nRunNo = lnRunNo
		            SCATTER MEMVAR
		
		            SELECT wellhist
		            LOCATE FOR cwellid+hYear+hPeriod = m.cwellid+m.hYear+m.hPeriod  AND crectype = 'R' AND nRunNo= lnRunNo AND cRunYear= lcRunYear
		            IF FOUND()
		               m.cwellid = cwellid
		               SELECT wells
		               SET ORDER TO cwellid
		               SELECT wellhist
		               m.nbbl = ntotbbl * (m.nrevoil/100)
		               m.nmcf = ntotmcf * (m.nrevgas/100)
		               m.nWellotax1 = ngbbltax1 + ntotbbltxw + ntotbbltxr
		               m.nWellgtax1 = ngmcftax1 + ntotmcftxw + ntotmcftxr
		               m.nWellptax1 = ngothtax1
		               m.nWellotax2 = ngbbltax2
		               m.nWellgtax2 = ngmcftax2
		               m.nWellptax2 = ngothtax2
		               m.nWellotax3 = ngbbltax3
		               m.nWellgtax3 = ngmcftax3
		               m.nWellptax3 = ngothtax3
		               m.nWellotax4 = ngbbltax4
		               m.nWellgtax4 = ngmcftax4
		               m.nWellptax4 = ngothtax4
		               m.ntax1    = ntotbbltx1 + ntotmcftx1 + ntotothtx1
		               m.ntax2    = ntotbbltx2 + ntotmcftx2 + ntotothtx2
		               m.ntax3    = ntotbbltx3 + ntotmcftx3 + ntotothtx3
		               m.ntax4    = ntotbbltx4 + ntotmcftx4 + ntotothtx4
		               m.nexpcl0  = ntotale
		               m.nexpcl1  = nexpcl1
		               m.nexpcl2  = nexpcl2
		               m.nexpcl3  = nexpcl3
		               m.nexpcl4  = nexpcl4
		               m.nexpcl5  = nexpcl5
		               m.nWellComp = ncompress
		               m.nWellGath = ngather
		
		               SELECT disbchks
		               REPLACE nbbl WITH m.nbbl, ;
		                  nmcf     WITH m.nmcf, ;
		                  ntax1    WITH m.ntax1, ;
		                  ntax2    WITH m.ntax2, ;
		                  ntax3    WITH m.ntax3, ;
		                  ntax4    WITH m.ntax4, ;
		                  nWellotax1 WITH m.nWellotax1, ;
		                  nWellgtax1 WITH m.nWellgtax1, ;
		                  nWellptax1 WITH m.nWellptax1, ;
		                  nWellotax2 WITH m.nWellotax2, ;
		                  nWellgtax2 WITH m.nWellgtax2, ;
		                  nWellptax2 WITH m.nWellptax2, ;
		                  nWellotax3 WITH m.nWellotax3, ;
		                  nWellgtax3 WITH m.nWellgtax3, ;
		                  nWellptax3 WITH m.nWellptax3, ;
		                  nWellotax4 WITH m.nWellotax4, ;
		                  nWellgtax4 WITH m.nWellgtax4, ;
		                  nWellptax4 WITH m.nWellptax4, ;
		                  nexpcl0  WITH m.nexpcl0, ;
		                  nexpcl1  WITH m.nexpcl1, ;
		                  nexpcl2  WITH m.nexpcl2, ;
		                  nexpcl3  WITH m.nexpcl3, ;
		                  nexpcl4  WITH m.nexpcl4, ;
		                  nexpcl5  WITH m.nexpcl5, ;
		                  nWellComp WITH m.nWellComp, ;
		                  nWellGath WITH m.nWellGath
		            ENDIF
		         ENDSCAN
		         SELECT disbchks
		         lnCount = 1
		         m.cid = ' '
		         llOverflow = .F.
		
		
		         SCAN FOR cid = lcOwner AND cRunYear = lcRunYear AND nRunNo = lnRunNo
		            *
		            *  Remove non producing wells
		            *
		
		            IF nnetcheck = 0
		               LOOP
		            ENDIF
		
		            m.cyear   = hYear
		            m.cperiod = hPeriod
		
		            SELE wells
		            LOCATE FOR cwellid == disbchks.cwellid
		            IF FOUND()
		               llRoySevExempt = lroysevtx
		               SCATTER FIELDS LIKE lsev* MEMVAR
		               m.lDirGasPurch = lDirGasPurch
		               m.lDirOilPurch = lDirOilPurch
		            ELSE
		               llRoySevExempt = .F.
		               STORE .F. TO m.lSev1O, m.lSev2O, m.lSev3O, m.lSev4O
		               STORE .F. TO m.lSev1G, m.lSev2G, m.lSev3G, m.lSev4G
		               STORE .F. TO m.lSev1P, m.lSev2P, m.lSev3P, m.lSev4P
		            ENDIF
		
		            IF NOT m.goApp.lAMVersion
		               m.cprodprd = m.cperiod +'/'+ RIGHT(m.cyear,2)
		            ENDIF
		
		            *
		            *  If msg should be printed on wrk int stubs
		            *  remove detail and put msg in
		            *
		            SELE disbchks
		            IF NOT tlStubRpt
		               IF llNoStub
		                  IF m.cid <> cid
		                     m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                     m.cprodprd  = ' '
		                     m.cIncType = ' '
		                     m.crptgroup = 'AA'
		                     STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                     STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                        m.nowngross, m.nexpense, m.ninterest, m.nowntax
		                     INSERT INTO stub FROM MEMVAR
		                     m.cid = cid
		                     LOOP
		                  ELSE
		                     m.cid = cid
		                     LOOP
		                  ENDIF
		               ENDIF
		            ENDIF
		            IF m.cid <> cid
		               lnCount = 1
		               lcid = m.cid
		               STORE 0 TO m.nBack
		               SELECT disbchkx
		               SCAN FOR nbackwith <> 0 AND cid = lcOwner AND cRunYear = lcRunYear AND nRunNo = lnRunNo AND cIntType <> 'S'
		                  m.nBack = m.nBack + nbackwith
		                  m.cprodprd = hPeriod+'/'+RIGHT(hYear,2)
		               ENDSCAN
		               m.cwellid = 'ALL'
		               m.cprogcode = ' '
		               m.crptgroup = 'AA'
		               m.cwellname = 'Backup Withholding Deducted'
		               m.nnetcheck = m.nBack * -1
		               m.cid = lcOwner
		               IF m.nnetcheck <> 0
		                  INSERT INTO stub FROM MEMVAR
		                  lnCount = lnCount + 1
		               ENDIF
		               STORE 0 TO m.nincome, m.nexpense, m.nother, m.ntaxes, m.nmcf, m.nbbl, m.ntax
		               STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                  m.nowngross, m.nexpense, m.ninterest, m.nowntax
		
		               STORE 0 TO m.ntaxes
		               SELECT disbchkx
		               SCAN FOR ntaxwith <> 0 AND cid = lcOwner AND cRunYear = lcRunYear AND nRunNo = lnRunNo AND cIntType <> 'S'
		                  m.cwellid = 'ALL'
		                  m.ntaxes = m.ntaxes + ntaxwith
		                  m.cprodprd = hPeriod+'/'+RIGHT(hYear,2)
		               ENDSCAN
		               m.cprogcode = ' '
		               m.crptgroup = 'AA'
		               m.cwellname = 'Tax Withholding Deducted'
		               m.nnetcheck = m.ntaxes * -1
		               m.cid = lcOwner
		               IF m.nnetcheck <> 0
		                  INSERT INTO stub FROM MEMVAR
		                  lnCount = lnCount + 1
		               ENDIF
		               STORE 0 TO m.nincome, m.nexpense, m.nother, m.ntaxes, m.nmcf, m.nbbl
		               STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                  m.nowngross, m.nexpense, m.ninterest, m.nowntax
		
		               llOverflow = .F.
		               m.cid = lcid
		            ENDIF
		
		            SELECT disbchks
		            SCATTER MEMVAR
		
		            IF ISNULL(m.cwellname)  &&  Reset to character if .NULL.
		               m.cwellname = ''
		            ENDIF
		
		            IF m.cIntType <> 'W'
		               llRoyaltyOwner = .T.
		            ELSE
		               llRoyaltyOwner = .F.
		            ENDIF
		
		            IF NOT tlStubRpt
		               IF NOT llVoidNext
		                  IF gnStubLine = 0
		                     lnMaxLines = 12
		                  ELSE
		                     lnMaxLines = gnStubLine
		                  ENDIF
		               ELSE
		                  lnMaxLines = 99999
		               ENDIF
		            ELSE
		               lnMaxLines = 999999999
		            ENDIF
		            *
		            *  Take away any direct paid income
		            *
		            DO CASE
		               CASE m.cdirect = 'O'
		                  m.nincome = m.nincome - m.noilrev
		                  IF m.lSev1O
		                     m.ntaxes = m.ntaxes - ABS(m.noiltax1)
		                  ENDIF
		                  IF m.lSev2O
		                     m.ntaxes = m.ntaxes - ABS(m.noiltax2)
		                  ENDIF
		                  IF m.lSev3O
		                     m.ntaxes = m.ntaxes - ABS(m.noiltax3)
		                  ENDIF
		                  IF m.lSev4O
		                     m.ntaxes = m.ntaxes - ABS(m.noiltax4)
		                  ENDIF
		               CASE m.cdirect = 'G'
		                  m.nincome = m.nincome - m.ngasrev
		                  IF m.lSev1G
		                     m.ntaxes = m.ntaxes - ABS(m.ngastax1)
		                  ENDIF
		                  IF m.lSev2G
		                     m.ntaxes = m.ntaxes - ABS(m.ngastax2)
		                  ENDIF
		                  IF m.lSev3G
		                     m.ntaxes = m.ntaxes - ABS(m.ngastax3)
		                  ENDIF
		                  IF m.lSev4G
		                     m.ntaxes = m.ntaxes - ABS(m.ngastax4)
		                  ENDIF
		               CASE m.cdirect = 'B'
		                  m.nincome = m.nincome - m.ngasrev - m.noilrev
		                  IF m.lSev1O
		                     m.ntaxes = m.ntaxes - ABS(m.noiltax1)
		                  ENDIF
		                  IF m.lSev2O
		                     m.ntaxes = m.ntaxes - ABS(m.noiltax2)
		                  ENDIF
		                  IF m.lSev3O
		                     m.ntaxes = m.ntaxes - ABS(m.noiltax3)
		                  ENDIF
		                  IF m.lSev4O
		                     m.ntaxes = m.ntaxes - ABS(m.noiltax4)
		                  ENDIF
		                  IF m.lSev1G
		                     m.ntaxes = m.ntaxes - ABS(m.ngastax1)
		                  ENDIF
		                  IF m.lSev2G
		                     m.ntaxes = m.ntaxes - ABS(m.ngastax2)
		                  ENDIF
		                  IF m.lSev3G
		                     m.ntaxes = m.ntaxes - ABS(m.ngastax3)
		                  ENDIF
		                  IF m.lSev4G
		                     m.ntaxes = m.ntaxes - ABS(m.ngastax4)
		                  ENDIF
		            ENDCASE
		            *
		            *  Report on deficits or minimums that affect check
		            *
		
		            DO CASE
		               CASE m.cIntType = 'S'
		
		                  IF m.nnetcheck > 0
		                     m.cwellid   = 'M-'+ALLT(m.cwellid)
		                     m.cIncType  = 'M'
		                  ELSE
		                     m.cwellid   = 'D-'+ALLT(m.cwellid)
		                     m.cIncType  = 'D'
		                  ENDIF
		                  STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                     m.nowngross, m.nexpense, m.ninterest, m.nowntax
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           IF m.nnetcheck <> 0
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           ENDIF
		                        CASE lnCount = lnMaxLines
		                           m.cwellname    = '*See Statement For Overflow*'
		                           m.cwellid   = '{'
		                           m.crptgroup    = 'AA'
		                           llOverflow = .T.
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           LOOP
		                        OTHERWISE
		                           LOOP
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  LOOP
		               CASE m.cwellid = 'ADJUST'
		                  m.cwellname = 'Adjustment for Deficits'
		                  STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                     m.nowngross, m.nexpense, m.ninterest, m.nowntax
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           IF m.nnetcheck <> 0
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           ENDIF
		                        CASE lnCount = lnMaxLines
		                           m.cwellname    = '*See Statement For Overflow*'
		                           m.cwellid   = '{'
		                           m.crptgroup = 'AA'
		                           llOverflow = .T.
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           LOOP
		                        OTHERWISE
		                           LOOP
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  LOOP
		               CASE m.cwellid = 'ROUND'
		                  m.cwellname = 'Adjustment for Rounding'
		                  STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                     m.nowngross, m.nexpense, m.ninterest, m.nowntax
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           IF m.nnetcheck <> 0
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           ENDIF
		                        CASE lnCount = lnMaxLines
		                           m.cwellname    = '*See Statement For Overflow*'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           LOOP
		                        OTHERWISE
		                           LOOP
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  LOOP
		               CASE m.cwellid = 'ALL '
		                  IF m.nnetcheck > 0
		                     m.cwellname = 'Prior Period Minimum Amount'
		                  ELSE
		                     m.cwellname = 'Prior Period Deficit Amount'
		                  ENDIF
		                  STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                     m.nowngross, m.nexpense, m.ninterest, m.nowntax
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           IF m.nnetcheck <> 0
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           ENDIF
		                        CASE lnCount = lnMaxLines
		                           m.cwellname    = '*See Statement For Overflow*'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           LOOP
		                        OTHERWISE
		                           LOOP
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  LOOP
		            ENDCASE
		
		            llExp = .F.
		            IF llRoyaltyOwner
		               IF NOT llChgPrice
		                  m.nexpense = m.ntotale1+m.ntotale2+m.ntotale3+m.ntotale4+m.ntotale5+m.ntotale+m.nTotaleA+m.nTotaleB + m.ncompress + m.ngather
		               ELSE
		                  m.nexpense = m.ntotale1+m.ntotale2+m.ntotale3+m.ntotale4+m.ntotale5+m.ntotale+m.nTotaleA+m.nTotaleB
		               ENDIF
		            ELSE
		               IF NOT llHideComp
		                  m.nexpense = m.ntotale1+m.ntotale2+m.ntotale3+m.ntotale4+m.ntotale5+m.ntotale+m.nTotaleA+m.nTotaleB + m.ncompress + m.ngather
		               ELSE
		                  m.nexpense = m.ntotale1+m.ntotale2+m.ntotale3+m.ntotale4+m.ntotale5+m.ntotale+m.nTotaleA+m.nTotaleB
		               ENDIF
		            ENDIF
		
		            m.crptgroup = 'AA'
		
		            llFound = .F.  &&  Flag to tell whether it finds any MCF entries, so it can adjust the GTax figure accordingly
		            *******************************************************
		            *  Start of actual stub detail processing
		            *******************************************************
		            IF NOT INLIST(m.cdirect,'G','B')
		
		               IF INLIST(m.cProdType,'G','B') AND m.ngasrev <> 0
		                  SELECT tempinc
		                  SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND csource = 'MCF'
		                     llExp = .T.
		                     llFound = .T.
		                     m.cIncType   = 'G'
		                     m.ntotalinc = ntotalinc
		                     m.crefid    = crefid
		                     IF m.lgather AND m.nWellGath <> 0
		                        IF llRoyaltyOwner
		                           IF llChgPrice
		                              m.ntotalinc = m.ntotalinc - m.nWellGath
		                           ENDIF
		                        ELSE
		                           IF llHideComp
		                              m.ntotalinc = m.ntotalinc - m.nWellGath
		                              m.ngasrev   = m.ngasrev - m.ngather
		                           ENDIF
		                        ENDIF
		                     ENDIF
		
		                     IF m.lcompress AND m.nWellComp <> 0
		                        IF llRoyaltyOwner
		                           IF llChgPrice
		                              m.ntotalinc = m.ntotalinc - m.nWellComp
		                           ENDIF
		                        ELSE
		                           IF llHideComp
		                              m.ntotalinc = m.ntotalinc - m.nWellComp
		                              m.ngasrev   = m.ngasrev - m.ncompress
		                           ENDIF
		                        ENDIF
		                     ENDIF
		
		                     m.nmcfprice  = nrate
		                     IF nunits <> 0
		                        m.nprice     = (m.ntotalinc/nunits)
		                     ELSE
		                        m.nprice = 0
		                     ENDIF
		
		                     m.nunits     = nunits
		                     m.ntax1      = m.nWellgtax1
		                     m.ntax2      = m.nWellgtax2
		                     m.ntax3      = m.nWellgtax3
		                     m.ntax4      = m.nWellgtax4
		                     m.ntaxes    = m.ntax1 + m.ntax2 + m.ntax3 + m.ntax4
		                     m.ninterest = m.nrevgas
		
		                     IF llRoyaltyOwner AND llRoySevExempt
		                        STORE 0 TO m.ngastax1, m.ngastax2, m.ngastax3, m.ngastax4, m.ntaxes, m.ntax1, m.ntax2, m.ntax3, m.ntax4
		                     ENDIF
		
		                     IF NOT m.lExempt
		                        m.nnetval   = m.ntotalinc - m.ntaxes
		                        m.nowntax   = m.ngastax1+m.ngastax2+m.ngastax3+m.ngastax4
		                     ELSE
		                        m.nnetval   = m.ntotalinc
		                        m.nowntax   = 0
		                     ENDIF
		                     IF llRoyaltyOwner
		                        IF llChgPrice
		                           m.nowngross = m.ngasrev - m.nowntax - m.ncompress - m.ngather
		                        ELSE
		                           m.nowngross = m.ngasrev - m.nowntax
		                        ENDIF
		                     ELSE
		                        IF llHideComp
		                           m.nowngross = m.ngasrev - m.nowntax - m.ncompress - m.ngather
		                        ELSE
		                           m.nowngross = m.ngasrev - m.nowntax
		                        ENDIF
		                     ENDIF
		                     IF NOT m.ljib
		                        m.nnetcheck  = m.nowngross - m.nexpense - m.nmktgexp
		                        m.nexpense   = m.nexpense + m.nmktgexp
		                     ELSE
		                        m.nnetcheck  = m.nowngross - m.ncompress - m.ngather - m.nmktgexp
		                        m.nexpense   = m.ncompress + m.ngather + m.nmktgexp
		                     ENDIF
		                     m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                     m.dproddate = tempinc.dRevDate
		
		                     IF NOT tlStubRpt
		                        DO CASE
		                           CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                              lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                              m.cwellname    = ' '
		                              STORE '' TO m.cprodprd, m.cIncType
		                              STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                              STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                                 m.nowngross, m.nexpense, m.ninterest
		                              m.lskip = .T.
		                              IF NOT llDupStub
		                                 m.cwellid = ALLT(m.cwellid)+ '{'
		                                 INSERT INTO stub FROM MEMVAR
		                                 INSERT INTO stub FROM MEMVAR
		                                 INSERT INTO stub FROM MEMVAR
		                                 m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                              ENDIF
		                              m.lskip = .F.
		                              lnCount = lnCount + 3
		                              m.cwellname = lcOldWellName
		                           CASE lnCount < lnMaxLines
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           CASE lnCount = lnMaxLines
		                              m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                              m.cwellid   = '{'
		                              llOverflow = .T.
		                              m.crptgroup='AA'
		                              STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                              STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                                 m.nowngross, m.nexpense, m.ninterest
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           CASE lnCount > lnMaxLines
		                              lnCount = lnCount + 1
		                        ENDCASE
		                     ELSE
		                        INSERT INTO stub FROM MEMVAR
		                     ENDIF
		                     STORE 0 TO m.nexpcl0, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		                  ENDSCAN
		               ENDIF
		            ELSE
		               *
		               *  The owner is direct paid.  Report any taxes that haven't been withheld
		               m.cIncType  = 'G'
		               llInsert = .F.
		               STORE 0 TO m.nowntax
		               IF NOT m.lSev1G
		                  m.ntax1      = m.nWellgtax1
		                  m.nowntax    = m.ngastax1
		                  llInsert     = .T.
		               ENDIF
		               IF NOT m.lSev2G
		                  m.ntax2      = m.nWellgtax2
		                  m.nowntax    = m.nowntax + m.ngastax2
		                  llInsert     = .T.
		               ENDIF
		               IF NOT m.lSev3G
		                  m.ntax3      = m.nWellgtax3
		                  m.nowntax    = m.nowntax + m.ngastax3
		                  llInsert     = .T.
		               ENDIF
		               IF NOT m.lSev4G
		                  m.ntax4      = m.nWellgtax4
		                  m.nowntax    = m.nowntax + m.ngastax4
		                  llInsert     = .T.
		               ENDIF
		               m.ntaxes    = m.ntax1 + m.ntax2 + m.ntax3 + m.ntax4
		               m.ninterest = m.nrevgas
		
		               IF llRoyaltyOwner AND llRoySevExempt
		                  STORE 0 TO m.ngastax1, m.ngastax2, m.ngastax3, m.ngastax4, m.ntaxes, m.ntax1, m.ntax2, m.ntax3, m.ntax4
		               ENDIF
		
		               IF NOT m.lExempt
		                  m.nnetval   = 0 - m.ntaxes
		                  m.nowntax   = m.ngastax1+m.ngastax2+m.ngastax3+m.ngastax4
		               ELSE
		                  m.nnetval   = 0
		                  m.nowntax   = 0
		               ENDIF
		               IF llRoyaltyOwner
		                  IF llChgPrice
		                     m.nowngross = 0 - m.nowntax - m.ncompress - m.ngather
		                  ELSE
		                     m.nowngross = 0 - m.nowntax
		                  ENDIF
		               ELSE
		                  IF llHideComp
		                     m.nowngross = 0 - m.nowntax - m.ncompress - m.ngather
		                  ELSE
		                     m.nowngross = 0 - m.nowntax
		                  ENDIF
		               ENDIF
		               IF NOT m.ljib
		                  m.nnetcheck  = m.nowngross - m.nexpense - m.nmktgexp
		                  m.nexpense   = m.nexpense + m.nmktgexp
		               ELSE
		                  m.nnetcheck  = m.nowngross - m.ncompress - m.ngather - m.nmktgexp
		                  m.nexpense   = m.ncompress + m.ngather + m.nmktgexp
		               ENDIF
		               m.cprodprd  = THIS.cperiod+'/'+RIGHT(THIS.cyear,2)
		               m.dproddate = tempinc.dRevDate
		               IF llInsert
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		               ENDIF
		               STORE 0 TO m.nexpcl0, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		            ENDIF
		
		            IF NOT llFound
		               m.nnetcheck = 0
		            ENDIF
		
		            IF NOT INLIST(m.cdirect,'G','B') AND INLIST(m.cProdType,'G','B') AND m.ngasrev = 0
		               SELECT tempinc
		               SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND LEFT(csource,4) = 'GTAX'
		                  IF llRoyaltyOwner AND llRoySevExempt
		                     LOOP
		                  ENDIF
		                  llExp = .T.
		                  m.cIncType  = 'G'
		                  m.nmcfprice = 0
		                  m.nprice     = 0
		                  m.nunits     = 0
		                  m.ntotalinc  = 0
		                  m.ntax1      = ntotalinc
		                  m.ntax2      = 0
		                  m.ntax3      = 0
		                  m.ntax4      = 0
		                  m.ntaxes    = m.ntax1 + m.ntax2 + m.ntax3 + m.ntax4
		
		                  m.ninterest = m.nrevgas
		                  m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                  m.dproddate = tempinc.dRevDate
		                  IF NOT m.lExempt
		                     m.nnetval   = ntotalinc - m.ntaxes
		                     m.nowntax   = m.ngastax1+m.ngastax2+m.ngastax3+m.ngastax4
		                     m.nowngross = m.ngasrev - m.nowntax
		                     IF m.nnetcheck = 0
		                        m.nnetcheck = m.nowngross
		                     ENDIF
		                  ELSE
		                     m.nnetval   = m.ntotalinc
		                     m.nowngross = m.ngasrev
		                  ENDIF
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           SELE stub
		                           LOCATE FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND cIncType = 'G'
		                           IF FOUND()
		                              IF NOT m.lExempt
		                                 REPL ntaxes WITH ntaxes - m.ntaxes, ;
		                                    nnetval WITH nnetval + m.ntaxes
		                              ENDIF
		                           ELSE
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           ENDIF
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  STORE 0 TO m.nexpcl0, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		               ENDSCAN
		            ENDIF
		
		            llFound = .F.  &&  Flag to tell whether it finds any BBL entries, so it can adjust the OTax figure accordingly
		
		            IF NOT INLIST(m.cdirect,'O','B')
		               IF INLIST(m.cProdType,'O','B') AND m.noilrev <> 0
		                  SELECT tempinc
		                  SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND csource = 'BBL'
		                     IF llExp
		                        m.nexpense = 0
		                     ELSE
		                        llExp = .T.
		                     ENDIF
		                     llFound = .T.
		                     m.cIncType  = 'O'
		                     m.nbblprice = nrate
		                     IF nunits <> 0
		                        m.nprice     = (ntotalinc/nunits)
		                     ELSE
		                        m.nprice = 0
		                     ENDIF
		                     m.nunits    = nunits
		                     m.ntotalinc = ntotalinc
		                     m.ntax1     = m.nWellotax1
		                     m.ntax2     = m.nWellotax2
		                     m.ntax3     = m.nWellotax3
		                     m.ntax4     = m.nWellotax4
		                     m.ntaxes    = m.ntax1 + m.ntax2 + m.ntax3 + m.ntax4
		                     m.ninterest = m.nrevoil
		                     m.crefid    = crefid
		                     STORE 0 TO m.nWellGath, m.nWellComp
		
		                     IF llRoyaltyOwner AND llRoySevExempt
		                        STORE 0 TO m.noiltax1, m.noiltax2, m.noiltax3, m.noiltax4, m.ntaxes, m.ntax1, m.ntax2, m.ntax3, m.ntax4
		                     ENDIF
		
		                     IF NOT m.lExempt
		                        m.nnetval   = m.ntotalinc - m.ntaxes
		                        m.nowntax   = m.noiltax1+m.noiltax2+m.noiltax3+m.noiltax4
		                        m.nowngross = m.noilrev - m.nowntax
		                     ELSE
		                        m.nnetval   = m.ntotalinc
		                        m.nowngross = m.noilrev
		                     ENDIF
		                     IF NOT m.ljib
		                        m.nnetcheck  = m.nowngross - m.nexpense
		                     ELSE
		                        m.nnetcheck  = m.nowngross
		                     ENDIF
		                     m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                     m.dproddate = tempinc.dRevDate
		                     SELECT disbchks
		                     IF NOT tlStubRpt
		                        DO CASE
		                           CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                              lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                              m.cwellname    = ' '
		                              STORE '' TO m.cprodprd, m.cIncType
		                              STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                              STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                                 m.nowngross, m.nexpense, m.ninterest
		                              m.lskip = .T.
		                              IF NOT llDupStub
		                                 m.cwellid = ALLT(m.cwellid)+ '{'
		                                 INSERT INTO stub FROM MEMVAR
		                                 INSERT INTO stub FROM MEMVAR
		                                 INSERT INTO stub FROM MEMVAR
		                                 m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                              ENDIF
		                              m.lskip = .F.
		                              lnCount = lnCount + 3
		                              m.cwellname = lcOldWellName
		                           CASE lnCount < lnMaxLines
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           CASE lnCount = lnMaxLines
		                              m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                              m.cwellid   = '{'
		                              llOverflow = .T.
		                              m.crptgroup = 'AA'
		                              STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                              STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                                 m.nowngross, m.nexpense, m.ninterest
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           CASE lnCount > lnMaxLines
		                              lnCount = lnCount + 1
		                        ENDCASE
		                     ELSE
		                        INSERT INTO stub FROM MEMVAR
		                     ENDIF
		                     STORE 0 TO m.nexpcl0, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		                  ENDSCAN
		               ENDIF
		            ELSE
		               *
		               * Report on any taxes that weren't direct paid
		               *
		               llInsert = .F.
		               m.cIncType  = 'O'
		               STORE 0 TO m.nowntax
		               IF NOT m.lSev1O AND m.noiltax1 <> 0
		                  m.ntax1      = m.nWellotax1
		                  m.nowntax    = m.noiltax1
		                  llInsert     = .T.
		               ENDIF
		               IF NOT m.lSev2O AND m.noiltax2 <> 0
		                  m.ntax2      = m.nWellotax2
		                  m.nowntax    = m.nowntax + m.noiltax2
		                  llInsert     = .T.
		               ENDIF
		               IF NOT m.lSev3O AND m.noiltax3 <> 0
		                  m.ntax3      = m.nWellotax3
		                  m.nowntax    = m.nowntax + m.noiltax3
		                  llInsert     = .T.
		               ENDIF
		               IF NOT m.lSev4O AND m.noiltax4 <> 0
		                  m.ntax4      = m.nWellotax4
		                  m.nowntax    = m.nowntax + m.noiltax4
		                  llInsert     = .T.
		               ENDIF
		               m.nnetval   = m.ntaxes * -1
		               m.nunits    = 0
		               m.ntotalinc = 0
		               m.ntaxes    = m.ntax1 + m.ntax2 + m.ntax3 + m.ntax4
		               m.ninterest = m.nrevoil
		
		               IF llRoyaltyOwner AND llRoySevExempt
		                  STORE 0 TO m.noiltax1, m.noiltax2, m.noiltax3, m.noiltax4, m.ntaxes, m.ntax1, m.ntax2, m.ntax3, m.ntax4
		               ENDIF
		
		               IF NOT m.lExempt
		                  m.nnetval   = 0 - m.ntaxes
		                  m.nowntax   = m.noiltax1+m.noiltax2+m.noiltax3+m.noiltax4
		               ELSE
		                  m.nnetval   = 0
		                  m.nowntax   = 0
		               ENDIF
		               m.nowngross = 0 - m.nowntax
		               IF NOT m.ljib
		                  m.nnetcheck  = m.nowngross - m.nexpense
		                  m.nexpense   = m.nexpense + m.nmktgexp
		               ELSE
		                  m.nnetcheck  = m.nowngross
		                  m.nexpense   = 0
		               ENDIF
		               m.cprodprd  = THIS.cperiod+'/'+RIGHT(THIS.cyear,2)
		               m.dproddate = tempinc.dRevDate
		               IF llInsert
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		               ENDIF
		               STORE 0 TO m.nexpcl0, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		            ENDIF
		
		            IF NOT llFound
		               m.nnetcheck = 0
		            ENDIF
		
		            IF NOT INLIST(m.cdirect,'O','B') AND INLIST(m.cProdType,'O','B') AND m.noilrev = 0
		               SELECT tempinc
		               SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND LEFT(csource,4) = 'OTAX'
		                  IF llRoyaltyOwner AND llRoySevExempt
		                     LOOP
		                  ENDIF
		                  llExp = .T.
		                  m.cIncType   = 'O'
		                  m.nmcfprice  = 0
		                  m.nprice     = 0
		                  m.nunits     = 0
		                  m.ntotalinc  = 0
		                  m.ntax1      = ntotalinc
		                  m.ntax2      = 0
		                  m.ntax3      = 0
		                  m.ntax4      = 0
		                  m.ntaxes    = m.ntax1 + m.ntax2 + m.ntax3 + m.ntax4
		                  m.ninterest = m.nrevoil
		                  m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                  m.dproddate = tempinc.dRevDate
		                  m.crefid    = crefid
		                  IF NOT m.lExempt
		                     m.nnetval   = ntotalinc - m.ntaxes
		                     m.nowntax   = m.noiltax1+m.noiltax2+m.noiltax3+m.noiltax4
		                     m.nowngross = m.ngasrev - m.nowntax
		                     IF m.nnetcheck = 0
		                        m.nnetcheck = m.nowngross
		                     ENDIF
		                  ELSE
		                     m.nnetval   = m.ntotalinc
		                     m.nowngross = m.noilrev
		                  ENDIF
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           SELE stub
		                           LOCATE FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND cIncType = 'G'
		                           IF FOUND()
		                              IF NOT m.lExempt
		                                 REPL ntaxes WITH ntaxes - m.ntaxes, ;
		                                    nnetval WITH nnetval + m.ntaxes
		                              ENDIF
		                           ELSE
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           ENDIF
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  STORE 0 TO m.nexpcl0, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		               ENDSCAN
		            ENDIF
		
		            llFound = .F.  &&  Flag to tell whether it finds any BBL entries, so it can adjust the OTax figure accordingly
		
		            IF m.nothrev <> 0
		               SELECT tempinc
		               SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND csource = 'OTH'
		                  IF llExp
		                     m.nexpense = 0
		                  ELSE
		                     llExp = .T.
		                  ENDIF
		                  llFound = .T.
		                  m.cIncType  = 'P'
		                  m.nbblprice = nrate
		                  IF nunits <> 0
		                     m.nprice     = (ntotalinc/nunits)
		                  ELSE
		                     m.nprice = 0
		                  ENDIF
		                  m.nunits    = nunits
		                  m.ntotalinc = ntotalinc
		                  m.ntax1     = m.nWellptax1
		                  m.ntax2     = m.nWellptax2
		                  m.ntax3     = m.nWellptax3
		                  m.ntax4     = m.nWellptax4
		                  m.ntaxes    = m.ntax1 + m.ntax2 + m.ntax3 + m.ntax4
		                  m.ninterest = m.nrevoth
		                  m.crefid    = crefid
		                  STORE 0 TO m.nWellGath, m.nWellComp
		
		                  IF llRoyaltyOwner AND llRoySevExempt
		                     STORE 0 TO m.nothtax1, m.nothtax2, m.nothtax3, m.nothtax4, m.ntaxes, m.ntax1, m.ntax2, m.ntax3, m.ntax4
		                  ENDIF
		
		                  IF NOT m.lExempt
		                     m.nnetval   = m.ntotalinc - m.ntaxes
		                     m.nowntax   = m.nothtax1+m.nothtax2+m.nothtax3+m.nothtax4
		                     m.nowngross = m.nothrev - m.nowntax
		                  ELSE
		                     m.nnetval   = m.ntotalinc
		                     m.nowngross = m.nothrev
		                  ENDIF
		                  IF NOT m.ljib
		                     m.nnetcheck  = m.nowngross - m.nexpense
		                  ELSE
		                     m.nnetcheck  = m.nowngross
		                  ENDIF
		                  m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                  m.dproddate = tempinc.dRevDate
		                  SELECT disbchks
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  STORE 0 TO m.nexpcl0, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		               ENDSCAN
		            ENDIF
		
		            IF NOT llFound
		               m.nnetcheck = 0
		            ENDIF
		
		            IF m.nothrev = 0
		               SELECT tempinc
		               SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND LEFT(csource,4) = 'PTAX'
		                  IF llRoyaltyOwner AND llRoySevExempt
		                     LOOP
		                  ENDIF
		                  llExp = .T.
		                  m.cIncType  = 'P'
		                  m.nmcfprice = 0
		                  m.nprice     = 0
		                  m.nunits     = 0
		                  m.ntotalinc  = 0
		                  m.ntax1      = ntotalinc
		                  m.ntax2      = 0
		                  m.ntax3      = 0
		                  m.ntax4      = 0
		                  m.ntaxes    = m.ntax1 + m.ntax2 + m.ntax3 + m.ntax4
		                  m.ninterest = m.nrevoth
		                  m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                  m.dproddate = tempinc.dRevDate
		                  m.crefid    = crefid
		                  IF NOT m.lExempt
		                     m.nnetval   = ntotalinc - m.ntaxes
		                     m.nowntax   = m.nothtax1+m.nothtax2+m.nothtax3+m.nothtax4
		                     m.nowngross = m.nothrev - m.nowntax
		                     IF m.nnetcheck = 0
		                        m.nnetcheck = m.nowngross
		                     ENDIF
		                  ELSE
		                     m.nnetval   = m.ntotalinc
		                     m.nowngross = m.nothrev
		                  ENDIF
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           SELE stub
		                           LOCATE FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND cIncType = 'G'
		                           IF FOUND()
		                              IF NOT m.lExempt
		                                 REPL ntaxes WITH ntaxes - m.ntaxes, ;
		                                    nnetval WITH nnetval + m.ntaxes
		                              ENDIF
		                           ELSE
		                              INSERT INTO stub FROM MEMVAR
		                              lnCount = lnCount + 1
		                           ENDIF
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		                  STORE 0 TO m.nexpcl0, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5
		               ENDSCAN
		            ENDIF
		
		            IF m.nrevtrp <> 0
		               SELECT tempinc
		               SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND csource = 'TRANS'
		                  m.nexpense   = 0
		                  m.cIncType  = 'M'
		                  m.nbblprice = nrate
		                  m.nprice     = nrate
		                  m.nunits     = nunits
		                  m.ntotalinc  = ntotalinc
		                  STORE 0 TO m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.ntaxes, m.nowntax
		                  m.nnetval   = m.ntotalinc
		                  m.ninterest = m.nrevtrp
		                  m.nowngross = m.ntrprev
		                  m.nnetcheck  = m.nowngross
		                  m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                  m.dproddate = tempinc.dRevDate
		                  SELECT disbchks
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		               ENDSCAN
		            ENDIF
		
		            IF m.nrevmisc1 <> 0
		               SELECT tempinc
		               SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND csource = 'MISC1'
		                  IF llExp
		                     m.nexpense = 0
		                  ELSE
		                     llExp = .T.
		                  ENDIF
		                  m.cIncType  = 'M'
		                  m.nbblprice = nrate
		                  m.nprice     = nrate
		                  m.nunits     = nunits
		                  m.ntotalinc  = ntotalinc
		                  STORE 0 TO m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.ntaxes, m.nowntax
		                  m.nnetval   = m.ntotalinc
		                  m.ninterest = m.nrevmisc1
		                  m.nowngross = ROUND(m.ntotalinc * (m.ninterest/100),2)
		                  m.nnetcheck  = m.nowngross - m.nexpense
		                  m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                  m.dproddate = tempinc.dRevDate
		                  SELECT disbchks
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		               ENDSCAN
		            ENDIF
		
		            IF m.nrevmisc2 <> 0
		               SELECT tempinc
		               SCAN FOR cwellid = m.cwellid AND cyear+cperiod = m.hYear+m.hPeriod AND csource = 'MISC2'
		                  IF llExp
		                     m.nexpense = 0
		                  ELSE
		                     llExp = .T.
		                  ENDIF
		                  m.cIncType  = 'M'
		                  m.nbblprice = nrate
		                  m.nprice     = nrate
		                  m.nunits     = nunits
		                  m.ntotalinc  = ntotalinc
		                  STORE 0 TO m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.ntaxes, m.nowntax
		                  m.nnetval   = m.ntotalinc
		                  m.ninterest = m.nrevmisc2
		                  m.nowngross = ROUND(m.ntotalinc * (m.ninterest/100),2)
		                  m.nnetcheck  = m.nowngross - m.nexpense
		                  m.cprodprd  = cperiod+'/'+RIGHT(cyear,2)
		                  m.dproddate = tempinc.dRevDate
		                  SELECT disbchks
		                  IF NOT tlStubRpt
		                     DO CASE
		                        CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                           lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                           m.cwellname    = ' '
		                           STORE '' TO m.cprodprd, m.cIncType
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           m.lskip = .T.
		                           IF NOT llDupStub
		                              m.cwellid = ALLT(m.cwellid)+ '{'
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              INSERT INTO stub FROM MEMVAR
		                              m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                           ENDIF
		                           m.lskip = .F.
		                           lnCount = lnCount + 3
		                           m.cwellname = lcOldWellName
		                        CASE lnCount < lnMaxLines
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount = lnMaxLines
		                           m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                           m.cwellid   = '{'
		                           llOverflow = .T.
		                           m.crptgroup = 'AA'
		                           STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                           STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                              m.nowngross, m.nexpense, m.ninterest
		                           INSERT INTO stub FROM MEMVAR
		                           lnCount = lnCount + 1
		                        CASE lnCount > lnMaxLines
		                           lnCount = lnCount + 1
		                     ENDCASE
		                  ELSE
		                     INSERT INTO stub FROM MEMVAR
		                  ENDIF
		               ENDSCAN
		            ENDIF
		
		            *
		            * Process expenses when there is no revenue
		            *
		            IF m.ngasrev = 0 AND m.noilrev = 0 AND m.nothrev = 0 AND m.nmiscrev1 = 0 AND m.nmiscrev2 = 0 AND (m.nflatrate <> 0 OR m.nexpense <> 0)
		               IF m.nflatrate <> 0
		                  m.cIncType = 'F'
		                  m.nnetcheck = m.nflatrate
		               ELSE
		                  m.cIncType  = 'E'
		                  m.nnetcheck  = m.nexpense * -1
		               ENDIF
		               m.nbblprice = 0
		               m.nprice     = 0
		               m.nunits     = 0
		               m.ntotalinc  = 0
		               STORE 0 TO m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nowntax, m.ntaxes
		               m.nnetval   = 0
		               m.ninterest = m.nworkint
		               m.nowngross = 0
		               m.cprodprd  = m.hPeriod+'/'+RIGHT(m.hYear,2)
		               m.dproddate = {}
		               SELECT disbchks
		               IF NOT tlStubRpt
		                  DO CASE
		                     CASE (lnCount = 13 OR (MOD(lnCount-13,gnStubLine) = 0) AND lnCount >= 13) AND glSkipPerf AND IIF(NOT llVoidNext,lnCount <= gnStubLine, .T.)  &&  Do calc to determine where the perf skipping should occur on 2nd and subsequent pages
		                        INSERT INTO stub FROM MEMVAR
		                        lnCount = lnCount + 1
		                        lcOldWellName = m.cwellname  &&  Store the name, so we don't have to look it up later - BH 8/31/06
		                        m.cwellname    = ' '
		                        STORE '' TO m.cprodprd, m.cIncType
		                        STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                        STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax, m.ntax1, m.nnetval, ;
		                           m.nowngross, m.nexpense, m.ninterest
		                        m.lskip = .T.
		                        IF NOT llDupStub
		                           m.cwellid = ALLT(m.cwellid)+ '{'
		                           INSERT INTO stub FROM MEMVAR
		                           INSERT INTO stub FROM MEMVAR
		                           INSERT INTO stub FROM MEMVAR
		                           m.cwellid = SUBSTR(m.cwellid,1,LEN(ALLT(m.cwellid))-1)
		                        ENDIF
		                        m.lskip = .F.
		                        lnCount = lnCount + 3
		                        m.cwellname = lcOldWellName
		                     CASE lnCount < lnMaxLines
		                        INSERT INTO stub FROM MEMVAR
		                        lnCount = lnCount + 1
		                     CASE lnCount = lnMaxLines
		                        m.cwellname = '** SEE DISTRIBUTION STATEMENT FOR MORE DETAIL**'
		                        m.cwellid   = '{'
		                        llOverflow = .T.
		                        m.crptgroup = 'AA'
		                        STORE 0 TO m.nincome, m.nexpense, m.ntaxes, m.nother, m.nnetcheck, m.nbbl, m.nmcf
		                        STORE 0 TO m.nprice, m.nunits, m.ntotalinc, m.ntax1, m.ntax2, m.ntax3, m.ntax4, m.nnetval, ;
		                           m.nowngross, m.nexpense, m.ninterest
		                        INSERT INTO stub FROM MEMVAR
		                        lnCount = lnCount + 1
		                     CASE lnCount > lnMaxLines
		                        lnCount = lnCount + 1
		                  ENDCASE
		               ELSE
		                  INSERT INTO stub FROM MEMVAR
		               ENDIF
		            ENDIF
		         ENDSCAN
		
		      ENDSCAN
		      oProgress.CloseProgress()
		   ENDIF
		ENDIF
		
		SELE stub
		SCAN
		   m.cwellid = allt(cwellid)
		   SELE wells
		   SET ORDER TO cwellid
		   IF SEEK(m.cwellid)
		      m.ccounty = ccounty
		      m.cstate  = cstate
		      SELE stub
		      REPL ccounty WITH m.ccounty, ;
		         cstate  WITH m.cstate
		   ENDIF
		   SELECT stub
		   IF EMPTY(cwellname) AND 'ALL ' $ m.cwellid  &&  Fill in well name, so the report doesn't skip it
		      SELECT stub
		      REPLACE cwellname WITH 'Previous Suspense'
		   ENDIF
		ENDSCAN
		
		IF llDupStub AND NOT tlStubRpt
		   SELE cidchec, cid, cwellid, COUNT(cidchec) AS ncount FROM stub INTO CURSOR stubcnt ORDER BY cidchec GROUP BY cidchec
		   SELE stub
		   SCATTER MEMVAR BLANK
		   SELE stubcnt
		   SCAN
		      SCATTER MEMVAR
		      IF NOT llVoidNext  &&  Don't add additional lines if voiding next check - will really screw things up - BH 04/27/2004
		         FOR lnx = 1 TO (lnMaxLines - m.ncount)
		            m.lskip = .T.
		            m.crptgroup = 'AA'
		            m.cprodprd = '99/99'
		            m.cwellid = '}'  &&  Use character at the end of the ASCII table, so it will always be last, after the regular well IDs - BH 11/12/2004
		            INSERT INTO stub FROM MEMVAR
		         ENDFOR
		      ENDIF
		   ENDSCAN
		
		   SELE * FROM stub INTO CURSOR temp
		   SELE temp
		   SCAN
		      SCATTER MEMVAR
		      m.crptgroup = 'BB'
		      INSERT INTO stub FROM MEMVAR
		   ENDSCAN
		
		   SELE stub
		   SET ORDER TO 0
		   SCAN
		      IF crptgroup <> 'AA'
		         REPL crptgroup WITH 'BB'
		      ENDIF
		      REPL ntax WITH ntaxes
		   ENDSCAN
		   SET ORDER TO cidchec
		ENDIF
		
		
		IF llVoidNext AND NOT tlStubRpt  &&  If voiding next check for overflow, pad the stub to the max lines setting before advancing to the next check
		
		   WAIT WIND NOWAIT 'Processing Voided Checks...'
		
		   IF gnStubLine = 0  &&  Initialize, if it's never been defined on the DMOption screen
		      gnStubLine = 12
		   ENDIF
		
		   CREATE CURSOR stub1 ;  &&  New dummy stub file to dump the data, plus appropriately spaced blank lines into
		   (cid           C(10), ;
		      cidtype        C(1), ;
		      cpayee         C(60), ;
		      cprogcode      C(10), ;
		      ccheckno       C(10), ;
		      cidchec        C(8), ;
		      npageno        I, ;
		      crptgroup      C(2), ;
		      cwellid        C(10), ;
		      cwellname      C(60), ;
		      ccounty        C(25), ;
		      cstate         C(2), ;
		      nincome        N(9,2), ;
		      nbbl           N(12,2), ;
		      cIncType       C(1), ;
		      nmcf           N(12,2), ;
		      nbblprice      N(12,6), ;
		      nmcfprice      N(12,6), ;
		      noilrev        N(12,2), ;
		      ngasrev        N(12,2), ;
		      cIntType       C(1), ;
		      cDesc          C(60), ;
		      cinvnum        C(20), ;
		      dinvdate       D, ;
		      dcheckdate     D, ;
		      ninvtot        N(12,2), ;
		      namtpaid       N(12,2), ;
		      ndisctot       N(12,2), ;
		      nAmount        N(12,2), ;
		      dproddate      D, ;
		      nexpense       N(9,2), ;
		      ntax           N(9,2), ;
		      ntaxes         N(9,2), ;
		      nnetcheck      N(9,2), ;
		      creference     C(20), ;
		      nother         N(9,2), ;
		      cprodprd       C(5), ;
		      cyear          C(4), ;
		      cperiod        C(2), ;
		      nunits         N(12,2), ;
		      nprice         N(12,4), ;
		      ntotalinc      N(12,2), ;
		      ntax1          N(12,2), ;
		      ntax2          N(12,2), ;
		      ntax3          N(12,2), ;
		      ntax4          N(12,2), ;
		      nexpcl0        N(12,2), ;
		      nexpcl1        N(12,2), ;
		      nexpcl2        N(12,2), ;
		      nexpcl3        N(12,2), ;
		      nexpcl4        N(12,2), ;
		      nexpcl5        N(12,2), ;
		      nowntax        N(12,2), ;
		      nnetval        N(12,2), ;
		      ninterest      N(11,7), ;
		      nowngross      N(12,2), ;
		      nWellGath      N(12,2), ;
		      nWellComp      N(12,2), ;
		      lskip          L, ;
		      cGROUP         C(2))
		
		   SELECT checktmp
		   SCAN
		      SELECT * FROM stub INTO CURSOR tmpa WHERE cidchec = checktmp.cidchec AND (crptgroup = 'AA' OR EMPTY(crptgroup)) ;  &&  Pull all A records first, or empty ones if we're not doing duplicate stubs
		
		      IF llDupStub  &&  Only get the B recs if doing a duplicate stub, since there won't be any otherwise
		         SELECT * FROM stub INTO CURSOR tmpb WHERE cidchec = checktmp.cidchec AND crptgroup = 'BB' ORDER BY cidchec, crptgroup, cwellid, cprodprd  &&  Pull all B records next
		      ENDIF
		
		      lnMaxPages   = CEILING(_TALLY/gnStubLine)       &&  Figure out how many pages will be needed
		      lnTotalLines = gnStubLine - (MOD(_TALLY,gnStubLine))  &&  Figure out the max number of blank lines that will need to be added
		      SELECT checktmp
		      REPLACE ncount WITH lnMaxPages  &&  Plug in the number of extra checks, so we know how many to void later
		
		      FOR lnx = 1 TO lnMaxPages
		         SELECT tmpa
		         SCAN FOR BETWEEN(RECNO(),((lnx-1)*gnStubLine)+1,gnStubLine*lnx)  &&  Add the A records back into the stub1 cursor
		            SCATTER MEMVAR
		            m.npageno = lnx
		            INSERT INTO stub1 FROM MEMVAR
		         ENDSCAN
		         SELE stub1
		         SCATTER MEMVAR BLANK
		         m.npageno = lnx
		         m.cidchec = checktmp.cidchec
		         m.cid     = checktmp.cid
		         m.cwellid = '{'
		         m.crptgroup = IIF(llDupStub,'AA','')
		         m.cprodprd = '99/99'
		
		         IF lnx = lnMaxPages   &&  Insert two blank lines if we're not on the last page, otherwise, fill the stub with blanks
		            FOR lnZ = 1 TO (lnTotalLines)
		               INSERT INTO stub1 FROM MEMVAR
		            ENDFOR
		         ENDIF
		
		         IF llDupStub  &&  Only append from the tmpb cursor if we're doing duplicate stubs, otherwise, it won't be created
		            SELECT tmpb
		            SCAN FOR BETWEEN(RECNO(),(lnx-1)*gnStubLine,gnStubLine*lnx)
		               SCATTER MEMVAR
		               m.npageno = lnx
		               INSERT INTO stub1 FROM MEMVAR
		            ENDSCAN
		            SELECT stub1
		            SCATTER MEMVAR BLANK
		            m.npageno = lnx
		            m.cidchec = checktmp.cidchec
		            m.cid     = checktmp.cid
		            m.cwellid = '{'
		            m.crptgroup = 'BB'
		            m.cprodprd = '99/99'
		
		            IF lnx = lnMaxPages
		               FOR lnZ = 1 TO (lnTotalLines)
		                  INSERT INTO stub1 FROM MEMVAR
		               ENDFOR
		            ENDIF
		
		         ENDIF
		      ENDFOR
		   ENDSCAN
		
		
		   SELECT checktmp  &&  Increment check numbers if any checks have gone to multiple pages - figure out a better way of doing this some time...
		   LOCATE FOR ncount > 1  &&  See if there's any multiple page checks, so we know whether to create the chkvoid cursor
		   IF FOUND()
		      CREATE CURSOR chkvoid  ;
		         (cEntryType C(1),   ;
		         cid        C(10),  ;
		         cpayee     C(60),  ;
		         csource    C(2),   ;
		         cGROUP     C(2),   ;
		         dcheckdate D,      ;
		         cDesc      C(10),  ;
		         ccheckno   C(10))
		      SELECT checktmp
		      GO TOP
		      SCAN FOR ncount > 1
		         FOR lnx = 1 TO (ncount-1)
		            SCATTER MEMVAR
		            m.cDesc = 'VOID'
		            m.cpayee = ALLT(m.cpayee) + ' - Check Overflow'
		            m.ccheckno = PADL(ALLT(STR(VAL(ccheckno)+lnx)),10,' ')
		            INSERT INTO chkvoid FROM MEMVAR
		         ENDFOR
		         SELECT checktmp
		         lnRecno = RECNO()
		         lnCount = ncount-1
		         SKIP 1  &&  Go to the next record and begin updating check numbers
		         REPLACE ccheckno WITH PADL(ALLT(STR(VAL(ccheckno)+(lnCount))),10,' ') REST
		         GOTO lnRecno
		      ENDSCAN
		   ENDIF
		
		   SELECT stub
		   USE
		   USE DBF('stub1') AGAIN IN 0 ALIAS stub
		   SELE stub
		   INDEX ON cidchec++STR(npageno)+crptgroup+cwellid TAG cidchec
		ENDIF
		
		IF USED('checktmp')
		   SELECT checktmp  &&  Scan for checktmp entries with no stub entries, and create one to avoid printing problems - BH 09-26-06
		   SCAN
		      SELECT stub
		      SCATTER MEMVAR BLANK
		      LOCATE FOR cidchec == checktmp.cidchec
		      IF NOT FOUND()  &&  No record in the stub cursor, so make one
		         m.cidchec = checktmp.cidchec
		         m.cwellname = '**  No stub detail available  **'
		         INSERT INTO stub FROM MEMVAR
		      ENDIF
		   ENDSCAN
		ENDIF
		
		SELE stub
		SET ORDER TO 0
		SCAN FOR EMPTY(crptgroup)
		   REPL crptgroup WITH 'AA'
		ENDSCAN
		SELE stub
		SET ORDER TO cidchec
		WAIT CLEAR
		
		
	ENDPROC

	PROCEDURE owner_suspense		&& Processing for suspense when deficits are netted between wells.
	ENDPROC

	PROCEDURE owntotal		&& Calculates the totals for each owner based upon the records in the invtmp table.
		*
		*  Build the invtotal file.  This file contains 1 record per owner of their net check total.
		*
		
		IF this.lErrorFlag 
		   RETURN
		ENDIF
		
		CREATE CURSOR invtotal ;
		   (cOwnerID   C(10), ;
		   cprogcode   C(10), ;
		   cGROUP      C(2), ;
		   ntotalck    N(12,2))
		INDEX ON cOwnerID TAG cOwnerID
		
		**-
		**-  Check for any records in the programs file.  If there's not any,
		**-  don't look at programs when getting the invtotal file, because
		**-  if we do, the invtotal file will always be empty.
		**-
		SELECT programs
		COUNT FOR NOT EMPTY(cprogcode) AND NOT DELETED() TO lnCount
		
		IF lnCount > 0
		   SELECT cOwnerID, ' ' AS cprogcode, SUM(ROUND(nnetcheck,2)) AS ntotalck, cGROUP  ;
		      FROM invtmp ;
		      WHERE invtmp.lProgNet = .T. ;
		      INTO CURSOR tmptotal ;
		      GROUP BY cOwnerID
		   SELECT invtotal
		   APPEND FROM DBF('tmptotal')
		   SELECT cOwnerID, ' ' AS cprogcode, SUM(ROUND(nnetcheck,2)) AS ntotalck, cGROUP  ;
		      FROM invtmp ;
		      WHERE invtmp.cProgCode NOT IN ;
		      (SELECT cprogcode FROM programs) ;
		      INTO CURSOR tmptotal ;
		      GROUP BY cOwnerID ;
		      ORDER BY cOwnerID
		   SELECT invtotal
		   SET ORDER TO cOwnerID
		   SELECT tmptotal
		   GO TOP
		   SCAN
		      SCATTER MEMVAR
		      SELECT invtotal
		      SEEK m.cOwnerID
		      IF FOUND()
		         REPLACE ntotalck WITH ntotalck + m.ntotalck
		      ELSE
		         INSERT INTO invtotal FROM MEMVAR
		      ENDIF
		      SELECT tmptotal
		   ENDSCAN
		ELSE
		   SELECT cOwnerID, ' ' AS cprogcode, SUM(ROUND(nnetcheck,2)) AS ntotalck, cGROUP  ;
		      FROM invtmp ;
		      INTO CURSOR tmptotal ;
		      GROUP BY cOwnerID ;
		      ORDER BY cOwnerID
		   SELECT invtotal
		   APPEND FROM DBF('tmptotal')
		ENDIF
		
		SELECT invtotal
		
	ENDPROC

	PROCEDURE payout		&& Calculates Well Payout
		*
		*  Calculates the well payout based upon the original investments and net cash paid to date
		*
		LPARA tcWellID1, tcWellID2, tdDate
		
		IF TYPE('tcWellID') <> 'C'
		   tcWellID = ''
		ENDIF
		IF TYPE('tdDate') <> 'D'
		   tdDate = {}
		ENDIF
		
		CREATE CURSOR payout ;
		 (cWellID     C(10), ;
		  cWellName   C(30), ;
		  nInvestment N(12,2), ;
		  dDate       D, ;
		  nRevenue    N(12,2), ;
		  nTaxes      N(12,2), ;
		  nExpenses   N(12,2), ;
		  nPayout     N(12,2))
		  
		
		SELECT wellinv.cwellid, wells.cwellname, SUM(wellinv.nInvAmount) AS nInvestment ;
		  FROM wellinv, wells ;
		  WHERE BETWEEN(wellinv.cwellid,tcWellID1,tcWellID2) ;
		    AND wells.cwellid = wellinv.cwellid ;
		  INTO CURSOR tempinv ;
		  ORDER BY wellinv.cwellid ;
		  GROUP BY wellinv.cwellid
		  
		IF _tally > 0
		   SELECT payout
		   APPEND FROM DBF('tempinv')
		
		   USE IN tempinv
		ENDIF
		
		   
		SELECT wellhist
		SCAN FOR BETWEEN(cwellid,tcWellID1,tcWellID2) AND cRecType = 'R' 
		  REPL ntotale WITH swNetExp(ntotale,cwellid,.t.,'0','D'), ;
		       nexpcl1 WITH swNetExp(nexpcl1,cwellid,.t.,'1','D'), ;
		       nexpcl2 WITH swNetExp(nexpcl2,cwellid,.t.,'1','D'), ;
		       nexpcl3 WITH swNetExp(nexpcl3,cwellid,.t.,'1','D'), ;
		       nexpcl4 WITH swNetExp(nexpcl4,cwellid,.t.,'1','D'), ;
		       nexpcl5 WITH swNetExp(nexpcl5,cwellid,.t.,'1','D'), ;
		       nexpcla WITH swNetExp(nexpcla,cwellid,.t.,'1','D'), ;
		       nexpclb WITH swNetExp(nexpclb,cwellid,.t.,'1','D')
		ENDSCAN  
		   
		SELECT cwellid, SUM(IIF(crectype='R',nOilinc+nGasInc+nTrpInc+nOthInc+nMiscInc1+nMiscInc2,000000000.00)) AS nRevenue, ;
		                SUM(nTotale+nExpcl1+nExpcl2+nExpcl3+nExpcl4+nExpcl5+nExpclA+nExpclB) AS nExpenses, ;
		                SUM(nTotbblTx1+nTotbbltx2+nTotbbltx3+ntotbblTx4+nTotmcftx1+nTotmcftx2+nTotmcftx3+nTotmcftx4 + ;
		                    nTotOthtx1+nTotothtx2+nTotOthtx3+nTotothtx4) AS nTaxes ;
		   FROM wellhist ;
		   WHERE hdate <= tdDate ;
		     AND BETWEEN(cwellid,tcWellID1,tcWellID2) ;
		   INTO CURSOR temphist ;
		   ORDER BY cwellid ;
		   GROUP BY cwellid
		
		IF _tally > 0
		   SELECT temphist
		   SCAN
		      SCATTER MEMVAR
		      SELECT payout
		      LOCATE FOR cWellID = m.cWellID
		      IF FOUND()
		         REPL nRevenue WITH m.nRevenue, ;
		              nTaxes   WITH m.nTaxes, ;
		              nExpenses WITH m.nExpenses, ;
		              nPayout   WITH nInvestment - (m.nRevenue - m.nTaxes - m.nExpenses)
		      ENDIF
		   ENDSCAN        
		   USE IN temphist     
		ENDIF
		
		
		
		             
		      
		                       
		       
	ENDPROC

	PROCEDURE postjourn		&& Posts the disbursement manager journal entries to the G/L Master file.
	ENDPROC

	PROCEDURE postsummary		&& Posts summary journal entries instead of detail.  This method is called if the postsummary.cfg file exists in the \ampro folder.
	ENDPROC

	PROCEDURE prechk		&& Prints the precheck register.
		LOCAL tcAccount
		
		SELE options
		tcAccount = cDisbAcct
		
		SET DELETED ON
		
		m.cProducer  = m.goApp.cCompanyName
		m.cProcessor = ''
		IF THIS.lClose
		   lcTitle1     = 'Checks Created for Run No: ' + this.cRunYear+'/'+ALLT(STR(THIS.nRunNo)) + ' Group: ' + THIS.cgroup
		ELSE
		   lcTitle1     = 'Checks Created for Period: ' + this.cRunYear+'/'+THIS.cperiod + ' Group: ' + THIS.cgroup
		ENDIF   
		lcTitle2     = 'For Account ' + ALLTRIM(tcAccount)
		lcSelect     = ''
		lcSortOrder  = ''
		
		CREATE CURSOR tempchk ;
		    (cidtype    C(1), ;
		    cid        C(10), ;
		    cpayee     C(40), ;
		    dcheckdate D, ;
		    cyear      C(4), ;
		    cperiod    C(2), ;
		    namount    N(12,2))
		
		IF m.goApp.lAMVersion
		    SELECT cidtype, cid, cpayee, dcheckdate, cyear, cperiod, namount ;
		        FROM checks ;
		        WHERE lPrinted = .F. ;
		        AND cEntryType = 'C' ;
		        AND cAcctNo = tcAccount ;
		        AND cBatch  = THIS.cDMBatch ;
		        INTO CURSOR tempchk ;
		        ORDER BY cidtype, cid
		ELSE
		    SELECT cidtype, cid, cpayee, dcheckdate, cyear, cperiod, namount ;
		        FROM checks ;
		        WHERE lPrinted = .F. ;
		        AND cEntryType = 'C' ;
		        AND cBatch  = THIS.cDMBatch ;
		        INTO CURSOR tempchk ;
		        ORDER BY cidtype, cid
		ENDIF
		
		SELECT tempchk
		REPORT FORM csprechk.frx PREVIEW
		IF this.omessage.confirm('Should the report be sent to the printer?')
		   REPORT FORM csprechk.frx TO PRINTER PROMPT NOCONSOLE NOEJECT
		ENDIF   
		
	ENDPROC

	PROCEDURE printsuspense		&& Prints suspense reports after closing summary
		tcYear   = THIS.cRunYear
		tcPeriod = THIS.cPeriod
		tcGroup  = THIS.cGroup
		tnRunNo  = THIS.nRunNo
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		SELECT options
		GO TOP
		glGrpName = lGrpName
		llCloseRun = .T.
		
		IF glGrpName
		   SELECT groups
		   SET ORDER TO cGroup
		   IF SEEK(tcGroup)
		      m.cGrpName = cDesc
		   ELSE
		      IF tcGroup = '**'
		         m.cGrpName = 'All Companies'
		      ELSE
		         m.cGrpName = ''
		      ENDIF
		   ENDIF
		ELSE
		   m.cGrpName = ''
		ENDIF
		
		IF TYPE('m.cProducer') <> 'C'
		   m.cProducer = 'Development Company'
		ENDIF
		
		*
		*  Create cursor for suspense report thats tacked on to closing summary
		*
		CREATE CURSOR audclose  ;
		   (crptgroup    C(2),    ;
		   cownerid     C(10),   ;
		   cwellid      C(10),   ;
		   csuspdesc    C(45),   ;
		   cprogcode    C(10),   ;
		   namount      N(12,2), ;
		   cAction      C(1),    ;
		   csusptype    C(1),    ;
		   cownname     C(30),   ;
		   cwellname    C(30))
		
		
		IF NOT llCloseRun
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      investor.cownname,     ;
		      'IA' AS crptgroup   ;
		      FROM susaudit, investor  ;
		      WHERE susaudit.cYear     = tcYear  ;
		      AND susaudit.cPeriod   = tcPeriod;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.namount   > 0 ;
		      AND susaudit.cAction   = 'I' ;
		      AND susaudit.cownerid = investor.cownerid ;
		      AND susaudit.cTypeInv  <> 'V' ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.csusptype, susaudit.cownerid, susaudit.cwellid
		ELSE
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      investor.cownname,     ;
		      'IA' AS crptgroup   ;
		      FROM susaudit, investor  ;
		      WHERE susaudit.cRunYear  = tcYear  ;
		      AND susaudit.nRunNo    = tnRunNo ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.namount   > 0 ;
		      AND susaudit.cAction   = 'I' ;
		      AND susaudit.cownerid = investor.cownerid ;
		      AND susaudit.cTypeInv  <> 'V' ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.csusptype, susaudit.cownerid, susaudit.cwellid
		
		ENDIF
		
		SELECT audclose
		APPEND FROM DBF('audclosx')
		
		USE IN audclosx
		
		IF NOT llCloseRun
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      investor.cownname,     ;
		      'IB' AS crptgroup   ;
		      FROM susaudit, investor  ;
		      WHERE susaudit.cYear     = tcYear  ;
		      AND susaudit.cPeriod   = tcPeriod;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.namount   < 0 ;
		      AND susaudit.cAction   = 'I' ;
		      AND susaudit.cownerid = investor.cownerid ;
		      AND susaudit.cTypeInv  <> 'V' ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.cownerid, susaudit.cwellid
		ELSE
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      investor.cownname,     ;
		      'IB' AS crptgroup   ;
		      FROM susaudit, investor  ;
		      WHERE susaudit.cRunYear  = tcYear  ;
		      AND susaudit.nRunNo    = tnRunNo ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.namount   < 0 ;
		      AND susaudit.cAction   = 'I' ;
		      AND susaudit.cownerid = investor.cownerid ;
		      AND susaudit.cTypeInv  <> 'V' ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.cownerid, susaudit.cwellid
		ENDIF
		SELECT audclose
		APPEND FROM DBF('audclosx')
		USE IN audclosx
		
		IF NOT llCloseRun
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      investor.cownname,     ;
		      'OB' AS crptgroup   ;
		      FROM susaudit, investor  ;
		      WHERE susaudit.cYear     = tcYear  ;
		      AND susaudit.cPeriod   = tcPeriod;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.namount   < 0 ;
		      AND susaudit.cAction   = 'O' ;
		      AND susaudit.cownerid = investor.cownerid ;
		      AND susaudit.cTypeInv  <> 'V' ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.cownerid, susaudit.cwellid
		ELSE
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      investor.cownname,     ;
		      'OB' AS crptgroup   ;
		      FROM susaudit, investor  ;
		      WHERE susaudit.cRunYear  = tcYear  ;
		      AND susaudit.nRunNo    = tnRunNo ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.namount   < 0 ;
		      AND susaudit.cAction   = 'O' ;
		      AND susaudit.cownerid = investor.cownerid ;
		      AND susaudit.cTypeInv  <> 'V' ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.cownerid, susaudit.cwellid
		ENDIF
		SELECT audclose
		APPEND FROM DBF('audclosx')
		USE IN audclosx
		
		IF NOT llCloseRun
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      investor.cownname,     ;
		      'OA' AS crptgroup   ;
		      FROM susaudit, investor  ;
		      WHERE susaudit.cYear     = tcYear  ;
		      AND susaudit.cPeriod   = tcPeriod;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.namount   > 0 ;
		      AND susaudit.cAction   = 'O' ;
		      AND susaudit.cownerid = investor.cownerid ;
		      AND susaudit.cTypeInv  <> 'V' ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.csusptype, susaudit.cownerid, susaudit.cwellid
		ELSE
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      investor.cownname,     ;
		      'OA' AS crptgroup   ;
		      FROM susaudit, investor  ;
		      WHERE susaudit.cRunYear  = tcYear  ;
		      AND susaudit.nRunNo    = tnRunNo ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.namount   > 0 ;
		      AND susaudit.cAction   = 'O' ;
		      AND susaudit.cownerid = investor.cownerid ;
		      AND susaudit.cTypeInv  <> 'V' ;
		      AND NOT investor.ldummy ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.csusptype, susaudit.cownerid, susaudit.cwellid
		ENDIF
		
		SELECT audclose
		APPEND FROM DBF('audclosx')
		USE IN audclosx
		
		IF NOT llCloseRun
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      vendor.cvendname AS cownname,     ;
		      'IC' AS crptgroup   ;
		      FROM susaudit, vendor  ;
		      WHERE susaudit.cYear     = tcYear  ;
		      AND susaudit.cPeriod   = tcPeriod   ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.cAction   = 'I' ;
		      AND susaudit.namount   > 0 ;
		      AND susaudit.cTypeInv  = 'V' ;
		      AND susaudit.cownerid = vendor.cvendorid ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.csusptype, susaudit.cownerid, susaudit.cwellid
		ELSE
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      vendor.cvendname AS cownname,     ;
		      'IC' AS crptgroup   ;
		      FROM susaudit, vendor  ;
		      WHERE susaudit.cRunYear  = tcYear  ;
		      AND susaudit.nRunNo    = tnRunNo ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.cAction   = 'I' ;
		      AND susaudit.namount   > 0 ;
		      AND susaudit.cTypeInv  = 'V' ;
		      AND susaudit.cownerid = vendor.cvendorid ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.csusptype, susaudit.cownerid, susaudit.cwellid
		ENDIF
		
		SELECT audclose
		APPEND FROM DBF('audclosx')
		USE IN audclosx
		
		IF NOT llCloseRun
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      vendor.cvendname AS cownname,     ;
		      'OC' AS crptgroup   ;
		      FROM susaudit, vendor  ;
		      WHERE susaudit.cYear     = tcYear  ;
		      AND susaudit.cPeriod   = tcPeriod   ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.cAction   = 'O' ;
		      AND susaudit.namount   < 0 ;
		      AND susaudit.cTypeInv  = 'V' ;
		      AND susaudit.cownerid = vendor.cvendorid ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.cownerid, susaudit.cwellid
		ELSE
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      vendor.cvendname AS cownname,     ;
		      'OC' AS crptgroup   ;
		      FROM susaudit, vendor  ;
		      WHERE susaudit.cRunYear  = tcYear  ;
		      AND susaudit.nRunNo    = tnRunNo ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.cAction   = 'O' ;
		      AND susaudit.namount   < 0 ;
		      AND susaudit.cTypeInv  = 'V' ;
		      AND susaudit.cownerid = vendor.cvendorid ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.cownerid, susaudit.cwellid
		ENDIF
		
		SELECT audclose
		APPEND FROM DBF('audclosx')
		USE IN audclosx
		
		IF NOT llCloseRun
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      vendor.cvendname AS cownname,     ;
		      'OC' AS crptgroup   ;
		      FROM susaudit, vendor  ;
		      WHERE susaudit.cYear     = tcYear  ;
		      AND susaudit.cPeriod   = tcPeriod   ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.cAction   = 'O' ;
		      AND susaudit.namount   > 0 ;
		      AND susaudit.cTypeInv  = 'V' ;
		      AND susaudit.cownerid = vendor.cvendorid ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.cownerid, susaudit.cwellid
		ELSE
		   SELECT susaudit.cownerid, ;
		      susaudit.cwellid,   ;
		      susaudit.namount,   ;
		      susaudit.cAction,   ;
		      susaudit.cprogcode, ;
		      susaudit.csusptype, ;
		      vendor.cvendname AS cownname,     ;
		      'OC' AS crptgroup   ;
		      FROM susaudit, vendor  ;
		      WHERE susaudit.cRunYear  = tcYear  ;
		      AND susaudit.nRunNo    = tnRunNo ;
		      AND susaudit.cGroup    = tcGroup ;
		      AND susaudit.cAction   = 'O' ;
		      AND susaudit.namount   > 0 ;
		      AND susaudit.cTypeInv  = 'V' ;
		      AND susaudit.cownerid = vendor.cvendorid ;
		      INTO CURSOR audclosx ;
		      ORDER BY susaudit.cAction, susaudit.cownerid, susaudit.cwellid
		
		ENDIF
		
		SELECT audclose
		APPEND FROM DBF('audclosx')
		USE IN audclosx
		
		SELECT wells
		SCAN
		   jwell = cwellid
		   jname = cwellname
		   SELECT audclose
		   SCAN FOR cwellid = jwell
		      REPLACE cwellname WITH jname
		   ENDSCAN
		   SELECT wells
		ENDSCAN
		
		SELECT audclose
		SCAN
		   jnAmount = namount
		   jcAction = cAction
		   jkey     = csusptype+cAction
		   DO CASE
		      CASE jkey = 'BI'
		         m.csuspdesc = 'Backup Withholding'
		      CASE jkey = 'DI'
		         m.csuspdesc = 'Deficits Not Covered This Period'
		      CASE jkey = 'DO'
		         m.csuspdesc = 'Deficits Covered This Period'
		      CASE jkey = 'MI'
		         m.csuspdesc = 'Minimum Check Amounts This Period'
		      CASE jkey = 'MO'
		         m.csuspdesc = 'Minimum Check Amounts Released This Period'
		      CASE jkey = 'HI'
		         m.csuspdesc = 'Owner Amounts Held This Period'
		      CASE jkey = 'HO'
		         m.csuspdesc = 'Owner Amounts Released From Hold This Period'
		      CASE jkey = 'QI'
		         m.csuspdesc = 'Quarterly Pays Held'
		      CASE jkey = 'QO'
		         m.csuspdesc = 'Quarterly Pays Released'
		      CASE jkey = 'SI'
		         m.csuspdesc = 'Semi-Annual Pays Held'
		      CASE jkey = 'SO'
		         m.csuspdesc = 'Semi-Annual Pays Released'
		      CASE jkey = 'AI'
		         m.csuspdesc = 'Annual Pays Held'
		      CASE jkey = 'AO'
		         m.csuspdesc = 'Annual Pays Released'
		      CASE jkey = 'II'
		         m.csuspdesc = 'Interests On Hold This Period'
		      CASE jkey = 'IO'
		         m.csuspdesc = 'Interests On Hold Released This Period'
		      CASE jkey = 'TI'
		         m.csuspdesc = 'Tax Withholding This Period'
		      OTHERWISE
		         m.csuspdesc = 'Unknown Suspense Type'
		   ENDCASE
		   REPLACE crptgroup WITH jkey, ;
		      csuspdesc WITH m.csuspdesc
		ENDSCAN
		
		lcTitle1 = 'Period Suspense Activity'
		IF llCloseRun
		   lcTitle2 = 'For Run No ' + THIS.cRunYear + '/' + ALLT(STR(THIS.nRunNo)) + ' Group ' + THIS.cGroup
		ELSE
		   lcTitle2 = 'For Period ' + THIS.cRunYear + '/' + THIS.cPeriod + ' Group ' + THIS.cGroup
		ENDIF   
		
		SELECT audclose
		INDEX ON crptgroup+csusptype TAG audkey
		
		IF RECC() > 0
		   LOCAL lcPreviewWindowName
		         lcPreviewWindowName=SYS(2015)
		   DEFINE WINDOW (lcPreviewWindowName) ;
		      FROM 0,0 TO SROWS(),SCOLS() ;
		      TITLE "Report Preview" ;
		      SYSTEM CLOSE FLOAT GROW MINIMIZE ZOOM
		   ZOOM WINDOW (lcPreviewWindowName) MAX
		
		   REPORT FORM dmsuspcls PREVIEW WINDOW (lcPreviewWindowName)
		   release windows (lcPreviewWindowName)
		   IF THIS.oMessage.CONFIRM('Should the report be sent to the printer now?')
		      SELECT audclose
		      REPORT FORM dmsuspcls TO PRINTER PROMPT NOCONSOLE NOEJECT
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE qbacctcheck		&& Check to make sure all specified QB accounts still exist in QB.
	ENDPROC

	PROCEDURE qberror		&& Handles QuickBooks Errors
		
		tcDMBatch = this.cdmbatch
		
		SELE sysctl
		LOCATE FOR cdmbatch = tcdmbatch
		IF FOUND()
		   repl lposted with .f.
		endif   
		
		=AERROR[aerrinfo]
		
		MESSAGEBOX(aerrinfo[3],0,'QuickBooks Error')
		
		
	ENDPROC

	PROCEDURE qbpost		&& Posts journal entries to QuickBooks
		LPARA tcdmbatch
		LOCAL tcyear, tcperiod, tdcheckdate, tcgroup, tdpostdate, oprogress
		LOCAL lnmax, lncount, lntotal, lcname, lnjibinv, m.ccustname, lcdmbatch, llsepclose
		LOCAL lcrevclear, lcsuspense, m.cdisbacct, m.cvendcomp, m.cgathacct, m.cbackwith
		LOCAL llintegcomp, llsepclose, lcapacct, lcacctyear, lcacctmonth, lcidchec
		LOCAL loresponse, llSDK5, lnJournal, lnCheck
		
		IF THIS.lerrorflag
		   RETURN
		ENDIF
		
		THIS.cdmbatch = tcdmbatch
		
		* Get the sdk version from goApp
		llSDK5 = m.goApp.lSDK5
		
		* Choose the correct txndeltype depending on the SDK.
		IF m.goApp.lSDK5
		   lnJournal = 15
		   lnCheck   = 6
		ELSE
		   lnJournal = 14
		   lnCheck   = 11
		ENDIF
		
		this.lquiet = .t.
		this.nprogress = 1 
		this.oProgress = THIS.omessage.progressbarex('Processing Revenue Closing for Run: ' + padl(transform(this.nrunno),3,'0')+'/'+this.crunyear,' ')
		this.oProgress.SetProgressRange(0,7)
		
		SELE sysctl
		LOCATE FOR cdmbatch = tcdmbatch
		IF FOUND()
		   THIS.csysctlkey = cidsysctl
		   m.cidsysctl = cidsysctl
		ELSE
		   THISFORM.omessage.severe('The closing control information cannot be found...')
		   RETURN
		ENDIF
		
		* get a message set request object (version 3.0 xml)
		THIS.oRequest = m.goApp.oQB.oQBRequest
		
		* set the on error attribute for the request
		THIS.oRequest.ATTRIBUTES.onerror = 1
		
		* Clear any previous requests
		THIS.oRequest.ClearRequests()
		
		lnmax   = 0
		lncount = 0
		lntotal = 0
		lcname  = 'Owner'
		m.ccustname = ' '
		lcidchec = ''
		
		lcacctyear  = STR(YEAR(THIS.dPostdate),4)
		lcacctmonth = PADL(ALLTRIM(STR(MONTH(THIS.dPostdate),2)),2,'0')
		
		IF THIS.companypost = .T.
		   tdCompanyPost = THIS.dPostdate
		   tdpostdate    = THIS.dAcctDate
		ELSE
		   tdCompanyPost = THIS.dPostdate
		   tdpostdate    = THIS.dPostdate
		ENDIF
		
		*
		*  Get the suspense account from glopt
		*
		SELECT glopt
		lcrevclear = crevclear
		lcexpclear = cexpclear
		llqbpost   = NOT ldmnopost
		lcsuspense = csuspense
		
		IF EMPTY(lcrevclear)
		   MESSAGEBOX('The revenue clearing account needs to be specified in Account Settings ' + ;
		      'please specify the account and then close the revenue period again.',0,'Setup Problem')
		   RETURN .F.
		ENDIF
		IF EMPTY(lcexpclear)
		   MESSAGEBOX('The expense clearing account needs to be specified in Account Settings ' + ;
		      'please specify the account and then close the revenue period again.',0,'Setup Problem')
		   RETURN .F.
		ENDIF
		
		*
		*  Get the A/P account
		*
		SELECT apopt
		lcapacct = capacct
		
		*
		*  Set up the parameters used by processing in this method
		*
		tcyear   = THIS.crunyear
		tcperiod = THIS.cperiod
		tcgroup  = THIS.cgroup
		
		IF EMPTY(lcsuspense)
		   MESSAGEBOX('The "Catch-All" account has not been specified in the Account Defaults.  Please specify a catch-all account before continuing.',0,'Account Problem')
		   RETURN .F.
		ENDIF
		
		*  Open the QB Transaction Table
		IF THIS.lqbversion
		   IF NOT USED('qbpost')
		      lcfile = m.goApp.getfilepath('qbpost')
		      USE (lcfile) IN 0
		   ENDIF
		ENDIF
		
		****************************************************************
		*   Get Disbursement Checking Acct Number
		****************************************************************
		SELECT options
		GO TOP
		m.cdisbacct = cdisbacct
		IF EMPTY(ALLT(m.cdisbacct))
		   m.cdisbacct = lcsuspense
		ENDIF
		m.cvendcomp = cvendcomp
		IF EMPTY(ALLT(m.cvendcomp))
		   m.cvendcomp = lcsuspense
		ENDIF
		m.cgathacct = cgathacct
		IF EMPTY(ALLT(m.cgathacct))
		   m.cgathacct = lcsuspense
		ENDIF
		m.cbackwith = cbackacct
		IF EMPTY(ALLT(m.cbackwith))
		   m.cbackwith = lcsuspense
		ENDIF
		m.ctaxwith = ctaxacct
		IF EMPTY(ALLT(m.ctaxwith))
		   m.ctaxwith = lcsuspense
		ENDIF
		m.ctaxacct1  = ctaxacct1
		IF EMPTY(ALLT(m.ctaxacct1))
		   m.ctaxacct1 = lcsuspense
		ENDIF
		m.ctaxacct2  = ctaxacct2
		IF EMPTY(ALLT(m.ctaxacct2))
		   m.ctaxacct2 = lcsuspense
		ENDIF
		m.ctaxacct3  = ctaxacct3
		IF EMPTY(ALLT(m.ctaxacct3))
		   m.ctaxacct3 = lcsuspense
		ENDIF
		m.ctaxacct4 = ctaxacct4
		IF EMPTY(ALLT(m.ctaxacct4))
		   m.ctaxacct4 = lcsuspense
		ENDIF
		m.cdefacct  = cdefacct
		IF EMPTY(ALLT(m.cdefacct))
		   m.cdefacct = lcsuspense
		ENDIF
		m.cminacct  = cminacct
		IF EMPTY((m.cminacct))
		   m.cminacct = lcsuspense
		ENDIF
		
		*  Get the account fixed expenses and well expenses by well expenses are to be posted to.
		lcdmexp = cfixedacct
		IF EMPTY(lcdmexp)
		   lcdmexp = lcapacct
		ENDIF
		
		IF EMPTY(lcdmexp)
		   MESSAGEBOX('The fixed expense clearing account needs to be specified in Disbursement and JIB Options.' + ;
		      'please specify the account and then close the revenue period again.',0,'Setup Problem')
		   RETURN .F.
		ENDIF
		
		llsepclose  = lsepclose
		
		******************************************************************
		*   Check to see if vendor compression & gathering is to be posted
		******************************************************************
		llintegcomp = .F.
		
		IF NOT EMPTY(m.cvendcomp)
		   SELECT vendor
		   SET ORDER TO cvendorid
		   IF SEEK(m.cvendcomp)
		      IF linteggl
		         llintegcomp = .T.
		      ENDIF
		   ENDIF
		ENDIF
		
		   IF NOT THIS.lquiet
		      this.oProgress.SetProgressMessage('Removing Zero Amount Records From Temp Owner Activity...')
		      this.oProgress.UpdateProgress(this.nprogress)
		      this.nprogress = this.nprogress + 1
		   endif
		   
		*
		*  Remove zero records from invtmp
		*
		wait wind nowait 'Removing records with no activity...'
		SELE invtmp
		set order to 0
		SCAN
		   SCATTER MEMVAR
		   IF m.nincome = 0 AND m.nexpense = 0 AND m.nsevtaxes = 0 AND m.nnetcheck = 0
		      DELE NEXT 1
		   ENDIF
		ENDSCAN
		wait clear
		*********************************************************************
		*   Post owner checks to register
		*********************************************************************
		SELECT wells
		SET ORDER TO cwellid
		
		IF m.goapp.oQB.lqbactive AND llqbpost
		      this.oProgress.SetProgressMessage('Posting Owner Checks to QuickBooks...')
		      this.oProgress.UpdateProgress(this.nprogress)
		      this.nprogress = this.nprogress + 1
		   CREATE CURSOR tmpowners ;
		      (cownerid   c(10), ;
		      cidchec   c(8), ;
		      ntotal     N(12,2),  ;
		      ntotinc    N(12,2),  ;
		      ntotexp    N(12,2),  ;
		      ntottax    N(12,2))
		
		   INDEX ON cownerid TAG owner
		
		   * Make sure cidchec is correct in invtmp
		   SELE invtmp
		   SCAN
		      lcidchec = cidchec
		      m.cownerid = cownerid
		      SELE checks
		      LOCATE FOR cbatch = tcdmbatch AND cid = m.cownerid
		      IF FOUND()
		         IF cidchec <> lcidchec
		            SELE invtmp
		            REPL cidchec WITH checks.cidchec
		         ENDIF
		      ELSE
		         SELE invtmp
		         REPL cidchec WITH ''
		      ENDIF
		   ENDSCAN
		
		   * Get a cursor of owners to be posted from invtmp
		   SELECT cownerid, cidchec, SUM(nnetcheck) AS ntotal, ;
		      SUM(nincome) AS ntotinc, SUM(nexpense+ntotale1+ntotale2+ntotale3+ntotale4+ntotale5+ntotalea+ntotaleb) AS ntotexp, ;
		      SUM(nsevtaxes) AS ntottax  ;
		      FROM invtmp WHERE NOT EMPTY(cidchec) ORDER BY cownerid GROUP BY cownerid  INTO CURSOR tmp
		   lnmax = _TALLY
		   IF lnmax > 0
		      SELE tmpowners
		      APPEND FROM DBF('tmp')
		   ENDIF
		
		   lncount = 1
		
		   IF NOT THIS.lquiet
		      oprogress = THIS.omessage.progressbarex('Posting owner checks to QuickBooks...',' ')
		      oprogress.setprogressrange(0,lnmax)
		   ENDIF
		   SELECT tmpowners
		   SCAN FOR ntotal > 0
		      m.cownerid = cownerid
		      m.ntotal   = ntotal
		      lcidchec   = cidchec
		      IF ntotinc = 0 AND ntotexp = 0 AND ntottax = 0 AND ntotal = 0
		         LOOP
		      ENDIF
		      m.lExempt = .f.
		      SELECT investor
		      SET ORDER TO cownerid
		      IF SEEK(m.cownerid)
		         m.cownname     = cownname
		         lcownerlistid  = clistid
		         m.lExempt      = lExempt
		         IF EMPTY(clistid)
		            MESSAGEBOX('The owner file needs to be synchronized with QuickBooks. ' + ;
		               'please synchronize and then close the revenue period again.',0,'Synchronization Problem')
		            RETURN .F.
		         ENDIF
		         * Don't post owners that are transfered to G/L here.
		         IF linteggl
		            LOOP
		         ENDIF
		         IF NOT THIS.lquiet
		            oprogress.setprogressmessage(ALLT(m.cownerid) + ' - ' + ALLT(m.cownname))
		            oprogress.updateprogress(lncount)
		            lncount = lncount + 1
		         ENDIF
		         * Don't post "Dummy" owner amounts
		         IF investor.ldummy
		            LOOP
		         ENDIF
		      ELSE
		         LOOP
		      ENDIF
		
		      SELE checks
		      LOCATE FOR cidchec = lcidchec
		      IF FOUND()
		         lcCheckNo = cCheckNo
		      ELSE
		         LOOP
		      ENDIF
		
		      *  Set the post flag
		      llpostqb = .F.
		
		      *  Setup the check add request
		      loCheckAdd = THIS.oRequest.appendcheckaddrq()
		      loCheckAdd.txndate.setvalue(tdpostdate)
		      loCheckAdd.payeeentityref.listid.setvalue(lcownerlistid)
		      loCheckAdd.accountref.listid.setvalue(m.cdisbacct)
		      loCheckAdd.istobeprinted.setvalue(0)
		      loCheckAdd.refnumber.setvalue(lcCheckNo)
		
		      m.cidchec = ' '
		
		      lccheckkey = lcidchec
		
		      STORE 0 TO lnolddef
		      SELECT invtmp
		      SCAN FOR cownerid = m.cownerid AND nnetcheck <> 0
		         SCATTER MEMVAR
		
		         SELECT wells
		         IF SEEK(m.cwellid)
		            SCATTER FIELDS LIKE lsev* MEMVAR
		            m.ldiroilpurch = ldiroilpurch
		            m.ldirgaspurch = ldirgaspurch
		            lcwelllistid    = wells.clistid
		            IF EMPTY(wells.clistid)
		               MESSAGEBOX('The wells file needs to be synchronized with QuickBooks. ' + ;
		                  'please synchronize and then close the revenue period again.',0,'Synchronization Problem')
		               RETURN .F.
		            ENDIF
		            llvalidwell = .T.
		         ELSE
		            m.ldiroilpurch = .F.
		            m.ldirgaspurch = .F.
		            STORE .F. TO m.lsev1o, m.lsev2o, m.lsev3o, m.lsev4o
		            STORE .F. TO m.lsev1g, m.lsev2g, m.lsev3g, m.lsev4g
		            STORE .F. TO m.lsev1p, m.lsev2p, m.lsev3p, m.lsev4p
		            lcwelllistid = ''
		            llvalidwell = .F.
		         ENDIF
		
		         * Don't post prior deficits or minimums in this section
		         IF m.ctypeinv <> 'X' AND m.ctypeinv <> 'M' AND m.ctypeinv <> 'I'
		            lnincome   = m.nincome
		            *  Remove direct paid amounts
		            DO CASE
		               CASE m.cdirect = 'O'
		                  lnincome = lnincome - m.noilrev
		               CASE m.cdirect = 'G'
		                  lnincome = lnincome - m.ngasrev
		               CASE m.cdirect = 'B'
		                  lnincome = lnincome - m.noilrev - m.ngasrev
		            ENDCASE
		            lnincome = ROUND(lnincome,2)
		            * Post the Revenue
		            IF NOT m.lflat
		               IF lnincome <> 0
		                  loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                  loexpenseline.amount.setvalue(ROUND(lnincome,2))
		                  loexpenseline.accountref.listid.setvalue(lcrevclear)
		                  llpostqb = .T.
		                  IF llvalidwell
		                     loexpenseline.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loexpenseline.MEMO.setvalue('Revenue')
		               ENDIF
		            ELSE
		               IF m.nflatrate <> 0
		                  loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                  loexpenseline.amount.setvalue(ROUND(m.nflatrate,2))
		                  loexpenseline.accountref.listid.setvalue(lcrevclear)
		                  llpostqb = .T.
		                  IF llvalidwell
		                     loexpenseline.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loexpenseline.MEMO.setvalue('Flat-Rate Royalty')
		               ENDIF
		            ENDIF
		
		            * If the owner is exempt, make sure no taxes post
		            if m.lExempt
		               store 0 to m.noiltax1, m.noiltax2, m.noiltax3, m.noiltax4
		               store 0 to m.ngastax1, m.ngastax2, m.ngastax3, m.ngastax4
		               store 0 to m.nothtax1, m.nothtax2, m.nothtax3, m.nothtax4
		            endif
		            
		            * Post the sev taxes
		            IF m.noiltax1 <> 0
		               IF NOT m.lsev1o
		                  IF INLIST(m.cdirect,'B','O')
		                     IF NOT m.ldiroilpurch
		                        loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                        loexpenseline.amount.setvalue(ROUND(m.noiltax1,2)*-1)
		                        loexpenseline.accountref.listid.setvalue(m.ctaxacct1)
		                        llpostqb = .T.
		                        IF llvalidwell
		                           loexpenseline.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loexpenseline.MEMO.setvalue('Oil Tax 1')
		                     ENDIF
		                  ELSE
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.noiltax1,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(m.ctaxacct1)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Oil Tax 1')
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','O')
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.noiltax1,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(lcrevclear)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Oil Tax 1')
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.ngastax1 <> 0
		               IF NOT m.lsev1g
		                  IF INLIST(m.cdirect,'B','G')
		                     IF NOT m.ldirgaspurch
		                        loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                        loexpenseline.amount.setvalue(ROUND(m.ngastax1,2)*-1)
		                        loexpenseline.accountref.listid.setvalue(m.ctaxacct1)
		                        llpostqb = .T.
		                        IF llvalidwell
		                           loexpenseline.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loexpenseline.MEMO.setvalue('Gas Tax 1')
		                     ENDIF
		                  ELSE
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.ngastax1,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(m.ctaxacct1)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Gas Tax 1')
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','G')
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.ngastax1,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(lcrevclear)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Gas Tax 1')
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.nothtax1 <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.nothtax1,2)*-1)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Other Tax 1')
		               IF NOT m.lsev1p
		                  loexpenseline.accountref.listid.setvalue(m.ctaxacct1)
		               ELSE
		                  loexpenseline.accountref.listid.setvalue(lcrevclear)
		               ENDIF
		            ENDIF
		
		            IF m.noiltax2 <> 0
		               IF NOT m.lsev2o
		                  IF INLIST(m.cdirect,'B','O')
		                     IF NOT m.ldiroilpurch
		                        loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                        loexpenseline.amount.setvalue(ROUND(m.noiltax2,2)*-1)
		                        loexpenseline.accountref.listid.setvalue(m.ctaxacct2)
		                        llpostqb = .T.
		                        IF llvalidwell
		                           loexpenseline.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loexpenseline.MEMO.setvalue('Oil Tax 2')
		                     ENDIF
		                  ELSE
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.noiltax2,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(m.ctaxacct2)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Oil Tax 2')
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','O')
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.noiltax2,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(lcrevclear)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Oil Tax 2')
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.ngastax2 <> 0
		               IF NOT m.lsev1g
		                  IF INLIST(m.cdirect,'B','G')
		                     IF NOT m.ldirgaspurch
		                        loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                        loexpenseline.amount.setvalue(ROUND(m.ngastax2,2)*-1)
		                        loexpenseline.accountref.listid.setvalue(m.ctaxacct2)
		                        llpostqb = .T.
		                        IF llvalidwell
		                           loexpenseline.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loexpenseline.MEMO.setvalue('Gas Tax 2')
		                     ENDIF
		                  ELSE
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.ngastax2,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(m.ctaxacct2)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Gas Tax 2')
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','G')
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.ngastax2,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(lcrevclear)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Gas Tax 2')
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.nothtax2 <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.nothtax2,2)*-1)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Other Tax 2')
		               IF NOT m.lsev1p
		                  loexpenseline.accountref.listid.setvalue(m.ctaxacct2)
		               ELSE
		                  loexpenseline.accountref.listid.setvalue(lcrevclear)
		               ENDIF
		            ENDIF
		
		            * Post the sev taxes
		            IF m.noiltax3 <> 0
		               IF NOT m.lsev3o
		                  IF INLIST(m.cdirect,'B','O')
		                     IF NOT m.ldiroilpurch
		                        loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                        loexpenseline.amount.setvalue(ROUND(m.noiltax3,2)*-1)
		                        loexpenseline.accountref.listid.setvalue(m.ctaxacct3)
		                        llpostqb = .T.
		                        IF llvalidwell
		                           loexpenseline.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loexpenseline.MEMO.setvalue('Oil Tax 3')
		                     ENDIF
		                  ELSE
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.noiltax3,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(m.ctaxacct3)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Oil Tax 3')
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','O')
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.noiltax3,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(lcrevclear)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Oil Tax 3')
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.ngastax3 <> 0
		               IF NOT m.lsev3g
		                  IF INLIST(m.cdirect,'B','G')
		                     IF NOT m.ldirgaspurch
		                        loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                        loexpenseline.amount.setvalue(ROUND(m.ngastax3,2)*-1)
		                        loexpenseline.accountref.listid.setvalue(m.ctaxacct3)
		                        llpostqb = .T.
		                        IF llvalidwell
		                           loexpenseline.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loexpenseline.MEMO.setvalue('Gas Tax 3')
		                     ENDIF
		                  ELSE
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.ngastax3,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(m.ctaxacct3)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Gas Tax 3')
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','G')
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.ngastax3,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(lcrevclear)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Gas Tax 3')
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.nothtax3 <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.nothtax3,2)*-1)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Other Tax 3')
		               IF NOT m.lsev1p
		                  loexpenseline.accountref.listid.setvalue(m.ctaxacct3)
		               ELSE
		                  loexpenseline.accountref.listid.setvalue(lcrevclear)
		               ENDIF
		            ENDIF
		
		            * Post the sev taxes
		            IF m.noiltax4 <> 0
		               IF NOT m.lsev4o
		                  IF INLIST(m.cdirect,'B','O')
		                     IF NOT m.ldiroilpurch
		                        loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                        loexpenseline.amount.setvalue(ROUND(m.noiltax4,2)*-1)
		                        loexpenseline.accountref.listid.setvalue(m.ctaxacct4)
		                        llpostqb = .T.
		                        IF llvalidwell
		                           loexpenseline.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loexpenseline.MEMO.setvalue('Oil Tax 4')
		                     ENDIF
		                  ELSE
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.noiltax4,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(m.ctaxacct4)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Oil Tax 4')
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','O')
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.noiltax4,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(lcrevclear)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Oil Tax 4')
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.ngastax4 <> 0
		               IF NOT m.lsev4g
		                  IF INLIST(m.cdirect,'B','G')
		                     IF NOT m.ldirgaspurch
		                        loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                        loexpenseline.amount.setvalue(ROUND(m.ngastax4,2)*-1)
		                        loexpenseline.accountref.listid.setvalue(lcrevclear)
		                        llpostqb = .T.
		                        IF llvalidwell
		                           loexpenseline.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loexpenseline.MEMO.setvalue('Gas Tax 4')
		                     ENDIF
		                  ELSE
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.ngastax4,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(m.ctaxacct4)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Gas Tax 4')
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','G')
		                     loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		                     loexpenseline.amount.setvalue(ROUND(m.ngastax4,2)*-1)
		                     loexpenseline.accountref.listid.setvalue(lcrevclear)
		                     llpostqb = .T.
		                     IF llvalidwell
		                        loexpenseline.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loexpenseline.MEMO.setvalue('Gas Tax 4')
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.nothtax4 <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.nothtax4,2)*-1)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Other Tax 4')
		               IF NOT m.lsev1p
		                  loexpenseline.accountref.listid.setvalue(m.ctaxacct4)
		               ELSE
		                  loexpenseline.accountref.listid.setvalue(lcrevclear)
		               ENDIF
		            ENDIF
		
		            *
		            *  Post compression and gathering
		            *
		            IF m.ncompress <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.ncompress,2)*-1)
		               loexpenseline.accountref.listid.setvalue(lcrevclear)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Compression Charge')
		            ENDIF
		
		            IF m.ngather <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.ngather,2)*-1)
		               loexpenseline.accountref.listid.setvalue(lcrevclear)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Gathering Charge')
		            ENDIF
		
		            *
		            *  Post marketing expenses
		            *
		            IF m.nMKTGExp <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.nMKTGExp,2)*-1)
		               loexpenseline.accountref.listid.setvalue(lcexpclear)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Marketing Expense')
		            ENDIF
		
		            *  Post the Expenses
		            lnexpense = m.nexpense + m.ntotale1 + m.ntotale2 + m.ntotale3 + m.ntotale4 + m.ntotale5 + m.ntotalea + m.ntotaleb
		
		            IF lnexpense <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(lnexpense,2)*-1)
		               loexpenseline.accountref.listid.setvalue(lcexpclear)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Operating Expenses: ' + m.hyear+'/'+m.hperiod)
		            ENDIF
		
		            *  Post Backup Withholding
		            IF m.nbackwith <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.nbackwith,2)*-1)
		               loexpenseline.accountref.listid.setvalue(m.cbackwith)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Backup Withholding')
		            ENDIF
		
		            *  Post Tax Withholding
		            IF m.ntaxwith <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.ntaxwith,2)*-1)
		               loexpenseline.accountref.listid.setvalue(m.ctaxwith)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Income Tax W/H')
		            ENDIF
		         ENDIF
		
		         *  Post Prior Period Deficits
		         IF m.ctypeinv = 'X' AND m.nnetcheck <> 0
		            lnolddef = lnolddef + m.nnetcheck
		         ENDIF
		
		         *  Post Prior Period Minimums
		         IF m.ctypeinv = 'M' AND m.nnetcheck <> 0
		            loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		            loexpenseline.amount.setvalue(ROUND(m.nnetcheck,2))
		            loexpenseline.accountref.listid.setvalue(m.cminacct)
		            llpostqb = .T.
		            IF llvalidwell
		               loexpenseline.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loexpenseline.MEMO.setvalue('Prior Minimums')
		         ENDIF
		
		         *  Post Interest on Hold being released
		         IF m.ctypeinv = 'I' AND m.nnetcheck <> 0
		            loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		            loexpenseline.amount.setvalue(ROUND(m.nnetcheck,2))
		            loexpenseline.accountref.listid.setvalue(m.cminacct)
		            llpostqb = .T.
		            IF llvalidwell
		               loexpenseline.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loexpenseline.MEMO.setvalue('Interest On Hold Released')
		
		            *  Post Backup Withholding
		            IF m.nbackwith <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.nbackwith,2)*-1)
		               loexpenseline.accountref.listid.setvalue(m.cbackwith)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Backup Withholding')
		            ENDIF
		
		            *  Post Tax Withholding
		            IF m.ntaxwith <> 0
		               loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		               loexpenseline.amount.setvalue(ROUND(m.ntaxwith,2)*-1)
		               loexpenseline.accountref.listid.setvalue(m.ctaxwith)
		               llpostqb = .T.
		               IF llvalidwell
		                  loexpenseline.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loexpenseline.MEMO.setvalue('Income Tax W/H')
		            ENDIF
		         ENDIF
		      ENDSCAN
		
		      IF lnolddef <> 0
		         m.nnetcheck = ROUND(lnolddef,2)
		         loexpenseline = loCheckAdd.expenselineaddlist.APPEND
		         loexpenseline.amount.setvalue(ROUND(m.nnetcheck,2))
		         loexpenseline.accountref.listid.setvalue(m.cdefacct)
		         loexpenseline.customerref.listid.setvalue(lcownerlistid)
		         llpostqb = .T.
		         IF llvalidwell
		            loexpenseline.classref.listid.setvalue(lcwelllistid)
		         ENDIF
		         loexpenseline.MEMO.setvalue('Prior Deficit')
		         lnolddef = 0
		      ENDIF
		
		      lcxml = THIS.oRequest.toxmlstring()
		      IF NOT USED('qbxml')
		         USE (m.goapp.cCommonFolder+'qbxml') IN 0
		      ENDIF
		      IF USED('qbxml')
		         INSERT INTO qbxml VALUES(m.cownerid,DATETIME(),lcxml)
		      ENDIF    
		      loresponse = m.goApp.oQB.oqbsm.dorequests(THIS.oRequest)
		      loaddresp  = loresponse.responselist.getat(0)
		
		      IF loaddresp.statuscode <> 0
		         MESSAGEBOX(loaddresp.statusmessage,0,'QuickBooks Posting Error')
		         *         MESSAGEBOX(lcXml,0,'Owner Post Error')
		         if not this.lquiet
		            oprogress.closeprogress()
		         endif   
		         m.goApp.oQB.oQBSM.ClearErrorRecovery()
		         RETURN .F.
		      ELSE
		         lonewbill = loaddresp.detail
		         m.ctxnid  = lonewbill.txnid.getvalue()
		         SELE qbpost
		         LOCATE FOR cidsysctl = THIS.csysctlkey AND ntype = lnCheck
		         IF NOT FOUND()
		            m.ntype = lnCheck
		            m.mtxnids = m.ctxnid
		            INSERT INTO qbpost FROM MEMVAR
		         ELSE
		            IF NOT EMPTY(ALLT(mtxnids))
		               REPL mtxnids WITH ALLT(mtxnids)+CHR(13)+m.ctxnid
		            ELSE
		               REPL mtxnids WITH m.ctxnid
		            ENDIF
		         ENDIF
		         
		         m.goApp.oQB.oQBSM.ClearErrorRecovery() 
		
		         SELE checks
		         LOCATE FOR cbatch = THIS.cdmbatch AND cid = m.cownerid
		         IF FOUND()
		            REPL ctxnid WITH m.ctxnid
		         ENDIF
		      ENDIF
		      THIS.oRequest.ClearRequests()
		   ENDSCAN
		
		   IF NOT THIS.lquiet
		      oprogress.closeprogress()
		      DOEVENTS
		      RELE oprogress
		   ENDIF
		ENDIF
		
		
		*********************************************************************
		*   Post owner amounts to G/L
		*********************************************************************
		SELECT wells
		SET ORDER TO cwellid
		
		IF m.goapp.oQB.lqbactive AND llqbpost
		      this.oProgress.SetProgressMessage('Posting Owner Amounts to QuickBooks...')
		      this.oProgress.UpdateProgress(this.nprogress)
		      this.nprogress = this.nprogress + 1
		   
		   CREATE CURSOR tmpowners ;
		      (cownerid   c(10), ;
		      ntotal     N(12,2),  ;
		      ntotinc    N(12,2),  ;
		      ntotexp    N(12,2),  ;
		      ntottax    N(12,2))
		
		   INDEX ON cownerid TAG owner
		
		   * Get a cursor of owners to be posted from invtmp
		   SELECT cownerid, SUM(nnetcheck) AS ntotal, SUM(nincome) AS ntotinc, SUM(nexpense) AS ntotexp, SUM(nsevtaxes) AS ntottax  ;
		      FROM invtmp WHERE EMPTY(cidchec) ORDER BY cownerid GROUP BY cownerid INTO CURSOR tmp
		   lnmax = _TALLY
		   IF lnmax > 0
		      SELE tmpowners
		      APPEND FROM DBF('tmp')
		   ENDIF
		
		   * Get a cursor of owners to be posted from invsusp
		   SELECT cownerid, SUM(nnetcheck) AS ntotal, SUM(nincome) AS ntotinc, SUM(nexpense) AS ntotexp, SUM(nsevtaxes) AS ntottax  ;
		      FROM invsusp ORDER BY cownerid GROUP BY cownerid INTO CURSOR tmp
		   lnmax = lnmax + _TALLY
		   SELE tmp
		   SCAN
		      SCATTER MEMVAR
		      SELE tmpowners
		      LOCATE FOR cownerid = m.cownerid
		      IF NOT FOUND()
		         INSERT INTO tmpowners FROM MEMVAR
		      ELSE
		         IF ntotal = 0
		            REPL ntotal WITH ntotal + m.ntotal
		         ENDIF
		      ENDIF
		   ENDSCAN
		   FLUSH
		   lncount = 1
		
		   IF NOT THIS.lquiet
		      oprogress = THIS.omessage.progressbarex('Posting owner amounts to QuickBooks...',' ')
		      oprogress.setprogressrange(0,lnmax)
		   ENDIF
		
		   SELECT tmpowners
		   SCAN
		      m.cownerid = cownerid
		      THIS.oRequest.ClearRequests()
		
		      m.ntotal   = ntotal
		      lnBalance = 0
		      IF ntotinc = 0 AND ntotexp = 0 AND ntottax = 0 AND ntotal = 0
		         LOOP
		      ENDIF
		      m.lExempt = .f.
		      m.lDirectDep = .F.
		      SELECT investor
		      SET ORDER TO cownerid
		      IF SEEK(m.cownerid)
		         m.cownname     = cownname
		         lcownerlistid  = clistid
		         m.lExempt      = lExempt
		         m.lDirectDep   = lDirectDep
		         IF EMPTY(clistid)
		            MESSAGEBOX('The owner file needs to be synchronized with QuickBooks. ' + ;
		               'please synchronize and then close the revenue period again.',0,'Synchronization Problem')
		            RETURN .F.
		         ENDIF
		         IF NOT THIS.lquiet
		            oprogress.setprogressmessage(ALLT(m.cownerid) + ' - ' + ALLT(m.cownname))
		            oprogress.updateprogress(lncount)
		            lncount = lncount + 1
		         ENDIF
		         * Don't post "Dummy" owner amounts
		         IF investor.ldummy
		            LOOP
		         ENDIF
		         * Don't post owners that are transfered to G/L here.
		         IF linteggl
		            LOOP
		         ENDIF
		      ELSE
		         LOOP
		      ENDIF
		
		      *  Set the post flag
		      llpostqb = .F.
		
		      *  Setup the journal add request
		      loentryadd = THIS.oRequest.appendjournalentryaddrq()
		      loentryadd.txndate.setvalue(tdpostdate)
		
		      m.cidchec = ' '
		      llPostInvTmp = .F.
		      STORE 0 TO lnolddef
		
		      SELECT invtmp
		      SCAN FOR cownerid = m.cownerid AND nnetcheck <> 0 AND EMPTY(cidchec)
		         SCATTER MEMVAR
		         llFoundInvTmp = .T.
		         SELECT wells
		         IF SEEK(m.cwellid)
		            SCATTER FIELDS LIKE lsev* MEMVAR
		            m.ldiroilpurch = ldiroilpurch
		            m.ldirgaspurch = ldirgaspurch
		            lcwelllistid    = wells.clistid
		            IF EMPTY(wells.clistid)
		               MESSAGEBOX('The wells file needs to be synchronized with QuickBooks. ' + ;
		                  'please synchronize and then close the revenue period again.',0,'Synchronization Problem')
		               RETURN .F.
		            ENDIF
		            llvalidwell = .T.
		         ELSE
		            m.ldiroilpurch = .F.
		            m.ldirgaspurch = .F.
		            STORE .F. TO m.lsev1o, m.lsev2o, m.lsev3o, m.lsev4o
		            STORE .F. TO m.lsev1g, m.lsev2g, m.lsev3g, m.lsev4g
		            STORE .F. TO m.lsev1p, m.lsev2p, m.lsev3p, m.lsev4p
		            lcwelllistid = ''
		            llvalidwell = .F.
		         ENDIF
		
		         * Don't post prior deficits or minimums in this section
		         IF m.ctypeinv <> 'X' AND m.ctypeinv <> 'M' AND m.ctypeinv <> 'I'
		            lnincome   = m.nincome
		            *  Remove direct paid amounts
		            DO CASE
		               CASE m.cdirect = 'O'
		                  lnincome = lnincome - m.noilrev
		               CASE m.cdirect = 'G'
		                  lnincome = lnincome - m.ngasrev
		               CASE m.cdirect = 'B'
		                  lnincome = lnincome - m.noilrev - m.ngasrev
		            ENDCASE
		            lnincome = ROUND(lnincome,2)
		            * Post the Revenue
		            IF NOT m.lflat
		               IF lnincome <> 0
		                  IF lnincome > 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  loentry.MEMO.setvalue('Revenue')
		                  loentry.amount.setvalue(ABS(lnincome))
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  lnBalance = lnBalance + lnincome
		               ENDIF
		            ELSE
		               IF m.nflatrate <> 0
		                  IF m.nflatrate > 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.nflatrate = ROUND(m.nflatrate,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.nflatrate))
		                  loentry.MEMO.setvalue('Flat-Rate Royalty')
		                  lnBalance = lnBalance + m.nflatrate
		               ENDIF
		            ENDIF
		
		            * If the owner is exempt, make sure no taxes post
		            if m.lExempt
		               store 0 to m.noiltax1, m.noiltax2, m.noiltax3, m.noiltax4
		               store 0 to m.ngastax1, m.ngastax2, m.ngastax3, m.ngastax4
		               store 0 to m.nothtax1, m.nothtax2, m.nothtax3, m.nothtax4
		            endif
		            
		            * Post the sev taxes
		            IF m.noiltax1 <> 0
		               IF NOT m.lsev1o
		                  IF INLIST(m.cdirect,'B','O')
		                     IF NOT m.ldiroilpurch
		                        IF m.noiltax1 < 0
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                           ELSE
		                              loentry = loentryadd.journaldebitlinelist.APPEND
		                           ENDIF
		                        ELSE
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                           ELSE
		                              loentry = loentryadd.journalcreditlinelist.APPEND
		                           ENDIF
		                        ENDIF
		                        llpostqb = .T.
		                        m.noiltax1 = ROUND(m.noiltax1,2)
		                        IF llvalidwell
		                           loentry.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loentry.entityref.listid.setvalue(lcownerlistid)
		                        loentry.accountref.listid.setvalue(m.ctaxacct1)
		                        loentry.amount.setvalue(ABS(m.noiltax1))
		                        loentry.MEMO.setvalue('Oil Tax 1')
		                        lnBalance = lnBalance - m.noiltax1
		                     ENDIF
		                  ELSE
		                     IF m.noiltax1 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax1 = ROUND(m.noiltax1,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct1)
		                     loentry.amount.setvalue(ABS(m.noiltax1))
		                     loentry.MEMO.setvalue('Oil Tax 1')
		                     lnBalance = lnBalance - m.noiltax1
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','O')
		                     IF m.noiltax1 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax1 = ROUND(m.noiltax1,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(lcrevclear)
		                     loentry.amount.setvalue(ABS(m.noiltax1))
		                     loentry.MEMO.setvalue('Oil Tax 1')
		                     lnBalance = lnBalance - m.noiltax1
		                  ENDIF
		               ENDIF
		            ENDIF
		            IF m.ngastax1 <> 0
		               IF NOT m.lsev1g
		                  IF INLIST(m.cdirect,'B','G')
		                     IF NOT m.ldirgaspurch
		                        IF m.ngastax1 < 0
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                           ELSE
		                              loentry = loentryadd.journaldebitlinelist.APPEND
		                           ENDIF
		                        ELSE
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                           ELSE
		                              loentry = loentryadd.journalcreditlinelist.APPEND
		                           ENDIF
		                        ENDIF
		                        llpostqb = .T.
		                        m.ngastax1 = ROUND(m.ngastax1,2)
		                        IF llvalidwell
		                           loentry.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loentry.entityref.listid.setvalue(lcownerlistid)
		                        loentry.accountref.listid.setvalue(m.ctaxacct1)
		                        loentry.amount.setvalue(ABS(m.ngastax1))
		                        loentry.MEMO.setvalue('Gas Tax 1')
		                        lnBalance = lnBalance - m.ngastax1
		                     ENDIF
		                  ELSE
		                     IF m.ngastax1 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax1 = ROUND(m.ngastax1,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct1)
		                     loentry.amount.setvalue(ABS(m.ngastax1))
		                     loentry.MEMO.setvalue('Gas Tax 1')
		                     lnBalance = lnBalance - m.ngastax1
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','G')
		                     IF m.ngastax1 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax1 = ROUND(m.ngastax1,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(lcrevclear)
		                     loentry.amount.setvalue(ABS(m.ngastax1))
		                     loentry.MEMO.setvalue('Gas Tax 1')
		                     lnBalance = lnBalance - m.ngastax1
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.nothtax1 <> 0
		               IF m.nothtax1 < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               IF NOT m.lsev1p
		                  loentry.accountref.listid.setvalue(m.ctaxacct1)
		               ELSE
		                  loentry.accountref.listid.setvalue(lcrevclear)
		               ENDIF
		               m.nothtax1 = ROUND(m.nothtax1,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.amount.setvalue(ABS(m.nothtax1))
		               loentry.MEMO.setvalue('Other Tax 1')
		               lnBalance = lnBalance - m.nothtax1
		            ENDIF
		
		            IF m.noiltax2 <> 0
		               IF NOT m.lsev2o
		                  IF INLIST(m.cdirect,'B','O')
		                     IF NOT m.ldiroilpurch
		                        IF m.noiltax2 < 0
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                           ELSE
		                              loentry = loentryadd.journaldebitlinelist.APPEND
		                           ENDIF
		                        ELSE
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                           ELSE
		                              loentry = loentryadd.journalcreditlinelist.APPEND
		                           ENDIF
		                        ENDIF
		                        llpostqb = .T.
		                        m.noiltax1 = ROUND(m.noiltax2,2)
		                        IF llvalidwell
		                           loentry.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loentry.entityref.listid.setvalue(lcownerlistid)
		                        loentry.accountref.listid.setvalue(m.ctaxacct2)
		                        loentry.amount.setvalue(ABS(m.noiltax2))
		                        loentry.MEMO.setvalue('Oil Tax 2')
		                        lnBalance = lnBalance - m.noiltax2
		                     ENDIF
		                  ELSE
		                     IF m.noiltax2 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax1 = ROUND(m.noiltax2,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct1)
		                     loentry.amount.setvalue(ABS(m.noiltax2))
		                     loentry.MEMO.setvalue('Oil Tax 2')
		                     lnBalance = lnBalance - m.noiltax2
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','O')
		                     IF m.noiltax2 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax1 = ROUND(m.noiltax2,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(lcrevclear)
		                     loentry.amount.setvalue(ABS(m.noiltax2))
		                     loentry.MEMO.setvalue('Oil Tax 2')
		                     lnBalance = lnBalance - m.noiltax2
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.ngastax2 <> 0
		               IF NOT m.lsev2g
		                  IF INLIST(m.cdirect,'B','G')
		                     IF NOT m.ldirgaspurch
		                        IF m.ngastax2 < 0
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                           ELSE
		                              loentry = loentryadd.journaldebitlinelist.APPEND
		                           ENDIF
		                        ELSE
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                           ELSE
		                              loentry = loentryadd.journalcreditlinelist.APPEND
		                           ENDIF
		                        ENDIF
		                        llpostqb = .T.
		                        m.ngastax1 = ROUND(m.ngastax2,2)
		                        IF llvalidwell
		                           loentry.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loentry.entityref.listid.setvalue(lcownerlistid)
		                        loentry.accountref.listid.setvalue(m.ctaxacct2)
		                        loentry.amount.setvalue(ABS(m.ngastax2))
		                        loentry.MEMO.setvalue('Gas Tax 2')
		                        lnBalance = lnBalance - m.ngastax2
		                     ENDIF
		                  ELSE
		                     IF m.ngastax2 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax2 = ROUND(m.ngastax2,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct2)
		                     loentry.amount.setvalue(ABS(m.ngastax2))
		                     loentry.MEMO.setvalue('Gas Tax 2')
		                     lnBalance = lnBalance - m.ngastax2
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','G')
		                     IF m.ngastax2 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax2 = ROUND(m.ngastax2,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(lcrevclear)
		                     loentry.amount.setvalue(ABS(m.ngastax2))
		                     loentry.MEMO.setvalue('Gas Tax 2')
		                     lnBalance = lnBalance - m.ngastax2
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.nothtax2 <> 0
		               IF m.nothtax2 < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               IF NOT m.lsev2p
		                  loentry.accountref.listid.setvalue(m.ctaxacct2)
		               ELSE
		                  loentry.accountref.listid.setvalue(lcrevclear)
		               ENDIF
		               llpostqb = .T.
		               m.nothtax2 = ROUND(m.nothtax2,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.amount.setvalue(ABS(m.nothtax2))
		               loentry.MEMO.setvalue('Other Tax 2')
		               lnBalance = lnBalance - m.nothtax2
		            ENDIF
		
		            IF m.noiltax3 <> 0
		               IF NOT m.lsev3o
		                  IF INLIST(m.cdirect,'B','O')
		                     IF NOT m.ldiroilpurch
		                        IF m.noiltax3 < 0
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                           ELSE
		                              loentry = loentryadd.journaldebitlinelist.APPEND
		                           ENDIF
		                        ELSE
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                           ELSE
		                              loentry = loentryadd.journalcreditlinelist.APPEND
		                           ENDIF
		                        ENDIF
		                        llpostqb = .T.
		                        m.noiltax3 = ROUND(m.noiltax3,2)
		                        IF llvalidwell
		                           loentry.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loentry.entityref.listid.setvalue(lcownerlistid)
		                        loentry.accountref.listid.setvalue(m.ctaxacct3)
		                        loentry.amount.setvalue(ABS(m.noiltax3))
		                        loentry.MEMO.setvalue('Oil Tax 3')
		                        lnBalance = lnBalance - m.noiltax3
		                     ENDIF
		                  ELSE
		                     IF m.noiltax3 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax3 = ROUND(m.noiltax3,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct3)
		                     loentry.amount.setvalue(ABS(m.noiltax3))
		                     loentry.MEMO.setvalue('Oil Tax 3')
		                     lnBalance = lnBalance - m.noiltax3
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','O')
		                     IF m.noiltax3 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax3 = ROUND(m.noiltax3,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(lcrevclear)
		                     loentry.amount.setvalue(ABS(m.noiltax3))
		                     loentry.MEMO.setvalue('Oil Tax 3')
		                     lnBalance = lnBalance - m.noiltax3
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.ngastax3 <> 0
		               IF NOT m.lsev3g
		                  IF INLIST(m.cdirect,'B','G')
		                     IF NOT m.ldirgaspurch
		                        IF m.ngastax3 < 0
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                           ELSE
		                              loentry = loentryadd.journaldebitlinelist.APPEND
		                           ENDIF
		                        ELSE
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                           ELSE
		                              loentry = loentryadd.journalcreditlinelist.APPEND
		                           ENDIF
		                        ENDIF
		                        llpostqb = .T.
		                        m.ngastax3 = ROUND(m.ngastax3,2)
		                        IF llvalidwell
		                           loentry.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loentry.entityref.listid.setvalue(lcownerlistid)
		                        loentry.accountref.listid.setvalue(m.ctaxacct3)
		                        loentry.amount.setvalue(ABS(m.ngastax3))
		                        loentry.MEMO.setvalue('Gas Tax 3')
		                        lnBalance = lnBalance - m.ngastax3
		                     ENDIF
		                  ELSE
		                     IF m.ngastax3 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax3 = ROUND(m.ngastax3,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct3)
		                     loentry.amount.setvalue(ABS(m.ngastax3))
		                     loentry.MEMO.setvalue('Gas Tax 3')
		                     lnBalance = lnBalance - m.ngastax3
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','G')
		                     IF m.ngastax3 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax3 = ROUND(m.ngastax3,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(lcrevclear)
		                     loentry.amount.setvalue(ABS(m.ngastax3))
		                     loentry.MEMO.setvalue('Gas Tax 3')
		                     lnBalance = lnBalance - m.ngastax3
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.nothtax3 <> 0
		               IF m.nothtax3 < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               IF NOT m.lsev3p
		                  loentry.accountref.listid.setvalue(m.ctaxacct3)
		               ELSE
		                  loentry.accountref.listid.setvalue(lcrevclear)
		               ENDIF
		               llpostqb = .T.
		               m.nothtax3 = ROUND(m.nothtax3,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.amount.setvalue(ABS(m.nothtax3))
		               loentry.MEMO.setvalue('Other Tax 3')
		               lnBalance = lnBalance - m.nothtax3
		            ENDIF
		
		            IF m.noiltax4 <> 0
		               IF NOT m.lsev4o
		                  IF INLIST(m.cdirect,'B','O')
		                     IF NOT m.ldiroilpurch
		                        IF m.noiltax4 < 0
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                           ELSE
		                              loentry = loentryadd.journaldebitlinelist.APPEND
		                           ENDIF
		                        ELSE
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                           ELSE
		                              loentry = loentryadd.journalcreditlinelist.APPEND
		                           ENDIF
		                        ENDIF
		                        llpostqb = .T.
		                        m.noiltax4 = ROUND(m.noiltax4,2)
		                        IF llvalidwell
		                           loentry.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loentry.entityref.listid.setvalue(lcownerlistid)
		                        loentry.accountref.listid.setvalue(m.ctaxacct4)
		                        loentry.amount.setvalue(ABS(m.noiltax4))
		                        loentry.MEMO.setvalue('Oil Tax 4')
		                        lnBalance = lnBalance - m.noiltax4
		                     ENDIF
		                  ELSE
		                     IF m.noiltax4 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax4 = ROUND(m.noiltax4,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct4)
		                     loentry.amount.setvalue(ABS(m.noiltax4))
		                     loentry.MEMO.setvalue('Oil Tax 4')
		                     lnBalance = lnBalance - m.noiltax4
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','O')
		                     IF m.noiltax4 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax4 = ROUND(m.noiltax4,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(lcrevclear)
		                     loentry.amount.setvalue(ABS(m.noiltax4))
		                     loentry.MEMO.setvalue('Oil Tax 4')
		                     lnBalance = lnBalance - m.noiltax4
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.ngastax4 <> 0
		               IF NOT m.lsev4g
		                  IF INLIST(m.cdirect,'B','G')
		                     IF NOT m.ldirgaspurch
		                        IF m.ngastax4 < 0
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                           ELSE
		                              loentry = loentryadd.journaldebitlinelist.APPEND
		                           ENDIF
		                        ELSE
		                           IF llSDK5
		                              loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                           ELSE
		                              loentry = loentryadd.journalcreditlinelist.APPEND
		                           ENDIF
		                        ENDIF
		                        llpostqb = .T.
		                        m.ngastax4 = ROUND(m.ngastax4,2)
		                        IF llvalidwell
		                           loentry.classref.listid.setvalue(lcwelllistid)
		                        ENDIF
		                        loentry.entityref.listid.setvalue(lcownerlistid)
		                        loentry.accountref.listid.setvalue(m.ctaxacct4)
		                        loentry.amount.setvalue(ABS(m.ngastax4))
		                        loentry.MEMO.setvalue('Gas Tax 4')
		                        lnBalance = lnBalance - m.ngastax4
		                     ENDIF
		                  ELSE
		                     IF m.ngastax4 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax4 = ROUND(m.ngastax4,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct4)
		                     loentry.amount.setvalue(ABS(m.ngastax4))
		                     loentry.MEMO.setvalue('Gas Tax 4')
		                     lnBalance = lnBalance - m.ngastax4
		                  ENDIF
		               ELSE
		                  IF NOT INLIST(m.cdirect,'B','G')
		                     IF m.ngastax4 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax4 = ROUND(m.ngastax4,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(lcrevclear)
		                     loentry.amount.setvalue(ABS(m.ngastax4))
		                     loentry.MEMO.setvalue('Gas Tax 4')
		                     lnBalance = lnBalance - m.ngastax4
		                  ENDIF
		               ENDIF
		            ENDIF
		
		            IF m.nothtax4 <> 0
		               IF m.nothtax4 < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               IF NOT m.lsev4p
		                  loentry.accountref.listid.setvalue(m.ctaxacct4)
		               ELSE
		                  loentry.accountref.listid.setvalue(lcrevclear)
		               ENDIF
		               llpostqb = .T.
		               m.nothtax4 = ROUND(m.nothtax4,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.amount.setvalue(ABS(m.nothtax4))
		               loentry.MEMO.setvalue('Other Tax 4')
		               lnBalance = lnBalance - m.nothtax4
		            ENDIF
		
		            *
		            *  Post Marketing Expenses
		            *
		            IF m.nMKTGExp <> 0
		               IF m.nMKTGExp < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               m.nMKTGExp = ROUND(m.nMKTGExp,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(lcexpclear)
		               loentry.amount.setvalue(ABS(m.nMKTGExp))
		               loentry.MEMO.setvalue('Marketing Expense')
		               lnBalance = lnBalance - m.nMKTGExp
		            ENDIF
		
		
		            *
		            *  Post compression and gathering
		            *
		            IF m.ncompress <> 0
		               IF m.ncompress < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               m.ncompress = ROUND(m.ncompress,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(lcrevclear)
		               loentry.amount.setvalue(ABS(m.ncompress))
		               loentry.MEMO.setvalue('Compression Charge')
		               lnBalance = lnBalance - m.ncompress
		            ENDIF
		
		            IF m.ngather <> 0
		               IF m.ngather < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               m.ngather = ROUND(m.ngather,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(lcrevclear)
		               loentry.amount.setvalue(ABS(m.ngather))
		               loentry.MEMO.setvalue('Gathering Charge')
		               lnBalance = lnBalance - m.ngather
		            ENDIF
		
		            *  Post the Expenses
		            lnexpense = m.nexpense + m.ntotale1 + m.ntotale2 + m.ntotale3 + m.ntotale4 + m.ntotale5 + m.ntotalea + m.ntotaleb
		
		            IF lnexpense <> 0
		               IF lnexpense < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               lnexpense = ROUND(lnexpense,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(lcexpclear)
		               loentry.amount.setvalue(ABS(lnexpense))
		               loentry.MEMO.setvalue('Operating Expenses: ' + m.hyear+'/'+m.hperiod )
		               lnBalance = lnBalance - lnexpense
		            ENDIF
		
		            *  Post Backup Withholding
		            IF m.nbackwith <> 0
		               IF m.nbackwith < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               m.nbackwith = ROUND(m.nbackwith,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(m.cbackwith)
		               loentry.amount.setvalue(ABS(m.nbackwith))
		               loentry.MEMO.setvalue('Backup Withholding')
		               lnBalance = lnBalance - m.nbackwith
		            ENDIF
		
		            *  Post Tax Withholding
		            IF m.ntaxwith <> 0
		               IF m.ntaxwith < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               m.ntaxwith = ROUND(m.ntaxwith,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(m.ctaxwith)
		               loentry.amount.setvalue(ABS(m.ntaxwith))
		               loentry.MEMO.setvalue('Income Tax W/H')
		               lnBalance = lnBalance - m.ntaxwith
		            ENDIF
		         ENDIF
		
		         *  Post Prior Period Deficits
		         IF m.ctypeinv = 'X' AND m.nnetcheck <> 0
		            lnolddef = lnolddef + m.nnetcheck
		         ENDIF
		
		         *  Post Prior Period Minimums
		         IF m.ctypeinv = 'M' AND m.nnetcheck <> 0
		            IF m.nnetcheck > 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            llpostqb = .T.
		            m.nnetcheck = ROUND(m.nnetcheck,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(m.cminacct)
		            loentry.amount.setvalue(ABS(m.nnetcheck))
		            loentry.MEMO.setvalue('Prior Minimums')
		         ENDIF
		
		         *  Post Interest on Hold being released
		         IF m.ctypeinv = 'I' AND m.nnetcheck <> 0
		            IF m.nnetcheck > 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            llpostqb = .T.
		            m.nnetcheck = ROUND(m.nnetcheck,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(m.cminacct)
		            loentry.amount.setvalue(ABS(m.nnetcheck))
		            loentry.MEMO.setvalue('Interest On Hold Released')
		
		            *  Post Backup Withholding
		            IF m.nbackwith <> 0
		               IF m.nbackwith < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               m.nbackwith = ROUND(m.nbackwith,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(m.cbackwith)
		               loentry.amount.setvalue(ABS(m.nbackwith))
		               loentry.MEMO.setvalue('Backup W/H')
		            ENDIF
		
		            *  Post Tax Withholding
		            IF m.ntaxwith <> 0
		               IF m.ntaxwith < 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               m.ntaxwith = ROUND(m.ntaxwith,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(m.ctaxwith)
		               loentry.amount.setvalue(ABS(m.ntaxwith))
		               loentry.MEMO.setvalue('Income Tax W/H')
		            ENDIF
		         ENDIF
		      ENDSCAN
		
		      IF lnolddef <> 0
		         m.nnetcheck = ROUND(lnolddef,2)
		         IF m.nnetcheck > 0
		            IF llSDK5
		               loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		            ELSE
		               loentry = loentryadd.journaldebitlinelist.APPEND
		            ENDIF
		         ELSE
		            IF llSDK5
		               loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		            ELSE
		               loentry = loentryadd.journalcreditlinelist.APPEND
		            ENDIF
		         ENDIF
		         llpostqb = .T.
		         IF llvalidwell
		            loentry.classref.listid.setvalue(lcwelllistid)
		         ENDIF
		         loentry.entityref.listid.setvalue(lcownerlistid)
		         loentry.accountref.listid.setvalue(m.cdefacct)
		         loentry.amount.setvalue(ABS(m.nnetcheck))
		         loentry.MEMO.setvalue('Prior Deficit')
		         lnolddef = 0
		      ENDIF
		
		      *  Check for minimum amount checks and post
		
		      DO CASE
		         CASE m.ntotal > 0
		            SELECT cwellid, SUM(nnetcheck) AS namount FROM invtmp ;
		               WHERE cownerid = m.cownerid AND EMPTY(cidchec) ;
		               INTO CURSOR tempwell
		            SELECT tempwell
		            SCAN
		               SCATTER MEMVAR
		               SELE wells
		               LOCATE FOR cwellid = m.cwellid
		               IF FOUND()
		                  lcwelllistid = clistid
		                  IF EMPTY(wells.clistid)
		                     MESSAGEBOX('The wells file needs to be synchronized with QuickBooks. ' + ;
		                        'please synchronize and then close the revenue period again.',0,'Synchronization Problem')
		                     RETURN .F.
		                  ENDIF
		                  llvalidwell = .T.
		               ELSE
		                  lcwellistid = ''
		                  llvalidwell = .F.
		               ENDIF
		               IF m.namount <> 0
		                  IF m.namount < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.namount = ROUND(m.namount,2)
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  if m.lDirectDep
		                     loentry.accountref.listid.setvalue(m.cdisbacct)
		                     loentry.MEMO.setvalue('Direct Deposit')                     
		                  else
		                     loentry.accountref.listid.setvalue(m.cminacct)
		                     loentry.MEMO.setvalue('Under Minimum')                     
		                  endif       
		                  loentry.amount.setvalue(ABS(m.namount))
		
		               ENDIF
		            ENDSCAN
		         CASE m.ntotal < 0
		            SELECT cwellid, SUM(nnetcheck) AS namount FROM invtmp ;
		               WHERE cownerid == m.cownerid AND EMPTY(cidchec) ;
		               INTO CURSOR tempwell
		            SELECT tempwell
		            SCAN
		               SCATTER MEMVAR
		               SELE wells
		               LOCATE FOR cwellid = m.cwellid
		               IF FOUND()
		                  lcwelllistid = clistid
		                  IF EMPTY(wells.clistid)
		                     MESSAGEBOX('The wells file needs to be synchronized with QuickBooks. ' + ;
		                        'please synchronize and then close the revenue period again.',0,'Synchronization Problem')
		                     RETURN .F.
		                  ENDIF
		                  llvalidwell = .T.
		               ELSE
		                  llvalidwell = .F.
		               ENDIF
		               IF m.namount <> 0
		                  IF m.namount < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.namount = ROUND(m.namount,2)
		                  *                     loentry.classref.listid.setvalue(lcwelllistid)
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  IF m.ntotal < -.05
		                     loentry.accountref.listid.setvalue(m.cdefacct)
		                     loentry.MEMO.setvalue('Deficit')
		                  ELSE
		                     loentry.accountref.listid.setvalue(lcsuspense)
		                     loentry.MEMO.setvalue('Rounding')
		                  ENDIF
		                  loentry.amount.setvalue(ABS(m.namount))
		               ENDIF
		            ENDSCAN
		      ENDCASE
		
		      lcidchec = ''
		
		      STORE 0 TO lnnewdef
		      SELECT invsusp
		      SCAN FOR cownerid = m.cownerid
		         SCATTER MEMVAR
		
		         SELECT wells
		         IF SEEK(m.cwellid)
		            SCATTER FIELDS LIKE lsev* MEMVAR
		            lcwelllistid    = wells.clistid
		            IF EMPTY(wells.clistid)
		               MESSAGEBOX('The wells file needs to be synchronized with QuickBooks. ' + ;
		                  'please synchronize and then close the revenue period again.',0,'Synchronization Problem')
		               RETURN .F.
		            ENDIF
		            m.ldirgaspurch = ldirgaspurch
		            m.ldiroilpurch = ldiroilpurch
		            llvalidwell = .T.
		         ELSE
		            m.ldiroilpurch = .F.
		            m.ldirgaspurch = .F.
		            STORE .F. TO m.lsev1o, m.lsev2o, m.lsev3o, m.lsev4o
		            STORE .F. TO m.lsev1g, m.lsev2g, m.lsev3g, m.lsev4g
		            STORE .F. TO m.lsev1p, m.lsev2p, m.lsev3p, m.lsev4p
		            llvalidwell = .F.
		         ENDIF
		
		         * Don't post prior deficits or minimums in this section
		         lnrevenue = 0000000.00
		         lnincome   = m.nincome
		         *  Remove direct paid amounts
		         DO CASE
		            CASE m.cdirect = 'O'
		               lnincome = lnincome - m.noilrev
		            CASE m.cdirect = 'G'
		               lnincome = lnincome - m.ngasrev
		            CASE m.cdirect = 'B'
		               lnincome = lnincome - m.noilrev - m.ngasrev
		         ENDCASE
		         lnincome = ROUND(lnincome,2)
		         * Post the Revenue
		         IF NOT m.lflat
		            IF lnincome <> 0
		               IF lnincome > 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(lcrevclear)
		               loentry.amount.setvalue(ABS(lnincome))
		               loentry.MEMO.setvalue('Revenue')
		               lnBalance = lnBalance + lnincome
		            ENDIF
		         ELSE
		            IF m.nflatrate <> 0
		               IF m.nflatrate > 0
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                  ELSE
		                     loentry = loentryadd.journaldebitlinelist.APPEND
		                  ENDIF
		               ELSE
		                  IF llSDK5
		                     loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                  ELSE
		                     loentry = loentryadd.journalcreditlinelist.APPEND
		                  ENDIF
		               ENDIF
		               llpostqb = .T.
		               m.nflatrate = ROUND(m.nflatrate,2)
		               IF llvalidwell
		                  loentry.classref.listid.setvalue(lcwelllistid)
		               ENDIF
		               loentry.entityref.listid.setvalue(lcownerlistid)
		               loentry.accountref.listid.setvalue(lcrevclear)
		               loentry.amount.setvalue(ABS(m.nflatrate))
		               loentry.MEMO.setvalue('Flat-Rate Royalty')
		               lnBalance = lnBalance + m.nflatrate
		            ENDIF
		         ENDIF
		
		         * Post the sev taxes
		         IF m.noiltax1 <> 0
		            IF NOT m.lsev1o
		               IF INLIST(m.cdirect,'B','O')
		                  IF NOT m.ldiroilpurch
		                     IF m.noiltax1 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax1 = ROUND(m.noiltax1,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct1)
		                     loentry.amount.setvalue(ABS(m.noiltax1))
		                     loentry.MEMO.setvalue('Oil Tax 1')
		                     lnBalance = lnBalance - m.noiltax1
		                  ENDIF
		               ELSE
		                  IF m.noiltax1 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.noiltax1 = ROUND(m.noiltax1,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(m.ctaxacct1)
		                  loentry.amount.setvalue(ABS(m.noiltax1))
		                  loentry.MEMO.setvalue('Oil Tax 1')
		                  lnBalance = lnBalance - m.noiltax1
		               ENDIF
		            ELSE
		               IF NOT INLIST(m.cdirect,'B','O')
		                  IF m.noiltax1 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.noiltax1 = ROUND(m.noiltax1,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.noiltax1))
		                  loentry.MEMO.setvalue('Oil Tax 1')
		                  lnBalance = lnBalance - m.noiltax1
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF m.ngastax1 <> 0
		            IF NOT m.lsev1g
		               IF INLIST(m.cdirect,'B','G')
		                  IF NOT m.ldirgaspurch
		                     IF m.ngastax1 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax1 = ROUND(m.ngastax1,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct1)
		                     loentry.amount.setvalue(ABS(m.ngastax1))
		                     loentry.MEMO.setvalue('Gas Tax 1')
		                     lnBalance = lnBalance - m.ngastax1
		                  ENDIF
		               ELSE
		                  IF m.ngastax1 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.ngastax1 = ROUND(m.ngastax1,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(m.ctaxacct1)
		                  loentry.amount.setvalue(ABS(m.ngastax1))
		                  loentry.MEMO.setvalue('Gas Tax 1')
		                  lnBalance = lnBalance - m.ngastax1
		               ENDIF
		            ELSE
		               IF NOT INLIST(m.cdirect,'B','G')
		                  IF m.ngastax1 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.ngastax1 = ROUND(m.ngastax1,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.ngastax1))
		                  loentry.MEMO.setvalue('Gas Tax 1')
		                  lnBalance = lnBalance - m.ngastax1
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF m.nothtax1 <> 0
		            IF m.nothtax1 < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            IF NOT m.lsev1p
		               loentry.accountref.listid.setvalue(m.ctaxacct1)
		            ELSE
		               loentry.accountref.listid.setvalue(lcrevclear)
		            ENDIF
		            llpostqb = .T.
		            m.nothtax1 = ROUND(m.nothtax1,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.amount.setvalue(ABS(m.nothtax1))
		            loentry.MEMO.setvalue('Other Tax 1')
		            lnBalance = lnBalance - m.nothtax1
		         ENDIF
		
		         IF m.noiltax2 <> 0
		            IF NOT m.lsev2o
		               IF INLIST(m.cdirect,'B','O')
		                  IF NOT m.ldiroilpurch
		                     IF m.noiltax2 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax1 = ROUND(m.noiltax2,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct2)
		                     loentry.amount.setvalue(ABS(m.noiltax2))
		                     loentry.MEMO.setvalue('Oil Tax 2')
		                     lnBalance = lnBalance - m.noiltax2
		                  ENDIF
		               ELSE
		                  IF m.noiltax2 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.noiltax1 = ROUND(m.noiltax2,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(m.ctaxacct1)
		                  loentry.amount.setvalue(ABS(m.noiltax2))
		                  loentry.MEMO.setvalue('Oil Tax 2')
		                  lnBalance = lnBalance - m.noiltax2
		               ENDIF
		            ELSE
		               IF NOT INLIST(m.cdirect,'B','O')
		                  IF m.noiltax2 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.noiltax1 = ROUND(m.noiltax2,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.noiltax2))
		                  loentry.MEMO.setvalue('Oil Tax 2')
		                  lnBalance = lnBalance - m.noiltax2
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF m.ngastax2 <> 0
		            IF NOT m.lsev2g
		               IF INLIST(m.cdirect,'B','G')
		                  IF NOT m.ldirgaspurch
		                     IF m.ngastax2 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax2 = ROUND(m.ngastax2,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct2)
		                     loentry.amount.setvalue(ABS(m.ngastax2))
		                     loentry.MEMO.setvalue('Gas Tax 2')
		                     lnBalance = lnBalance - m.ngastax2
		                  ENDIF
		               ELSE
		                  IF m.ngastax2 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.ngastax2 = ROUND(m.ngastax2,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(m.ctaxacct2)
		                  loentry.amount.setvalue(ABS(m.ngastax2))
		                  loentry.MEMO.setvalue('Gas Tax 2')
		                  lnBalance = lnBalance - m.ngastax2
		               ENDIF
		            ELSE
		               IF NOT INLIST(m.cdirect,'B','G')
		                  IF m.ngastax2 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.ngastax2 = ROUND(m.ngastax2,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.ngastax2))
		                  loentry.MEMO.setvalue('Gas Tax 2')
		                  lnBalance = lnBalance - m.ngastax2
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF m.nothtax2 <> 0
		            IF m.nothtax2 < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            IF NOT m.lsev2p
		               loentry.accountref.listid.setvalue(m.ctaxacct2)
		            ELSE
		               loentry.accountref.listid.setvalue(lcrevclear)
		            ENDIF
		            llpostqb = .T.
		            m.nothtax2 = ROUND(m.nothtax2,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.amount.setvalue(ABS(m.nothtax2))
		            loentry.MEMO.setvalue('Other Tax 2')
		            lnBalance = lnBalance - m.nothtax2
		         ENDIF
		
		         IF m.noiltax3 <> 0
		            IF NOT m.lsev3o
		               IF INLIST(m.cdirect,'B','O')
		                  IF NOT m.ldiroilpurch
		                     IF m.noiltax3 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax3 = ROUND(m.noiltax3,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct3)
		                     loentry.amount.setvalue(ABS(m.noiltax3))
		                     loentry.MEMO.setvalue('Oil Tax 3')
		                     lnBalance = lnBalance - m.noiltax3
		                  ENDIF
		               ELSE
		                  IF m.noiltax3 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.noiltax3 = ROUND(m.noiltax3,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(m.ctaxacct3)
		                  loentry.amount.setvalue(ABS(m.noiltax3))
		                  loentry.MEMO.setvalue('Oil Tax 3')
		                  lnBalance = lnBalance - m.noiltax3
		               ENDIF
		            ELSE
		               IF NOT INLIST(m.cdirect,'B','O')
		                  IF m.noiltax3 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.noiltax3 = ROUND(m.noiltax3,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.noiltax3))
		                  loentry.MEMO.setvalue('Oil Tax 3')
		                  lnBalance = lnBalance - m.noiltax3
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF m.ngastax3 <> 0
		            IF NOT m.lsev3g
		               IF INLIST(m.cdirect,'B','G')
		                  IF NOT m.ldirgaspurch
		                     IF m.ngastax3 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax3 = ROUND(m.ngastax3,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct3)
		                     loentry.amount.setvalue(ABS(m.ngastax3))
		                     loentry.MEMO.setvalue('Gas Tax 3')
		                     lnBalance = lnBalance - m.ngastax3
		                  ENDIF
		               ELSE
		                  IF m.ngastax3 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.ngastax3 = ROUND(m.ngastax3,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(m.ctaxacct3)
		                  loentry.amount.setvalue(ABS(m.ngastax3))
		                  loentry.MEMO.setvalue('Gas Tax 3')
		                  lnBalance = lnBalance - m.ngastax3
		               ENDIF
		            ELSE
		               IF NOT INLIST(m.cdirect,'B','G')
		                  IF m.ngastax3 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.ngastax3 = ROUND(m.ngastax3,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.ngastax3))
		                  loentry.MEMO.setvalue('Gas Tax 3')
		                  lnBalance = lnBalance - m.ngastax3
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF m.nothtax3 <> 0
		            IF m.nothtax3 < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            IF NOT m.lsev3p
		               loentry.accountref.listid.setvalue(m.ctaxacct3)
		            ELSE
		               loentry.accountref.listid.setvalue(lcrevclear)
		            ENDIF
		            llpostqb = .T.
		            m.nothtax3 = ROUND(m.nothtax3,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.amount.setvalue(ABS(m.nothtax3))
		            loentry.MEMO.setvalue('Other Tax 3')
		            lnBalance = lnBalance - m.nothtax3
		         ENDIF
		
		         IF m.noiltax4 <> 0
		            IF NOT m.lsev4o
		               IF INLIST(m.cdirect,'B','O')
		                  IF NOT m.ldiroilpurch
		                     IF m.noiltax4 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.noiltax4 = ROUND(m.noiltax4,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct4)
		                     loentry.amount.setvalue(ABS(m.noiltax4))
		                     loentry.MEMO.setvalue('Oil Tax 4')
		                     lnBalance = lnBalance - m.noiltax4
		                  ENDIF
		               ELSE
		                  IF m.noiltax4 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.noiltax4 = ROUND(m.noiltax4,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(m.ctaxacct4)
		                  loentry.amount.setvalue(ABS(m.noiltax4))
		                  loentry.MEMO.setvalue('Oil Tax 4')
		                  lnBalance = lnBalance - m.noiltax4
		               ENDIF
		            ELSE
		               IF NOT INLIST(m.cdirect,'B','O')
		                  IF m.noiltax4 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.noiltax4 = ROUND(m.noiltax4,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.noiltax4))
		                  loentry.MEMO.setvalue('Oil Tax 4')
		                  lnBalance = lnBalance - m.noiltax4
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF m.ngastax4 <> 0
		            IF NOT m.lsev4g
		               IF INLIST(m.cdirect,'B','G')
		                  IF NOT m.ldirgaspurch
		                     IF m.ngastax4 < 0
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                        ELSE
		                           loentry = loentryadd.journaldebitlinelist.APPEND
		                        ENDIF
		                     ELSE
		                        IF llSDK5
		                           loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                        ELSE
		                           loentry = loentryadd.journalcreditlinelist.APPEND
		                        ENDIF
		                     ENDIF
		                     llpostqb = .T.
		                     m.ngastax4 = ROUND(m.ngastax4,2)
		                     IF llvalidwell
		                        loentry.classref.listid.setvalue(lcwelllistid)
		                     ENDIF
		                     loentry.entityref.listid.setvalue(lcownerlistid)
		                     loentry.accountref.listid.setvalue(m.ctaxacct4)
		                     loentry.amount.setvalue(ABS(m.ngastax4))
		                     loentry.MEMO.setvalue('Gas Tax 4')
		                     lnBalance = lnBalance - m.ngastax4
		                  ENDIF
		               ELSE
		                  IF m.ngastax4 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.ngastax4 = ROUND(m.ngastax4,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(m.ctaxacct4)
		                  loentry.amount.setvalue(ABS(m.ngastax4))
		                  loentry.MEMO.setvalue('Gas Tax 4')
		                  lnBalance = lnBalance - m.ngastax4
		
		               ENDIF
		            ELSE
		               IF NOT INLIST(m.cdirect,'B','G')
		                  IF m.ngastax4 < 0
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		                     ELSE
		                        loentry = loentryadd.journaldebitlinelist.APPEND
		                     ENDIF
		                  ELSE
		                     IF llSDK5
		                        loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		                     ELSE
		                        loentry = loentryadd.journalcreditlinelist.APPEND
		                     ENDIF
		                  ENDIF
		                  llpostqb = .T.
		                  m.ngastax4 = ROUND(m.ngastax4,2)
		                  IF llvalidwell
		                     loentry.classref.listid.setvalue(lcwelllistid)
		                  ENDIF
		                  loentry.entityref.listid.setvalue(lcownerlistid)
		                  loentry.accountref.listid.setvalue(lcrevclear)
		                  loentry.amount.setvalue(ABS(m.ngastax4))
		                  loentry.MEMO.setvalue('Gas Tax 4')
		                  lnBalance = lnBalance - m.ngastax4
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF m.nothtax4 <> 0
		            IF m.nothtax4 < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            IF NOT m.lsev4p
		               loentry.accountref.listid.setvalue(m.ctaxacct4)
		            ELSE
		               loentry.accountref.listid.setvalue(lcrevclear)
		            ENDIF
		            llpostqb = .T.
		            m.nothtax4 = ROUND(m.nothtax4,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.amount.setvalue(ABS(m.nothtax4))
		            loentry.MEMO.setvalue('Other Tax 4')
		            lnBalance = lnBalance - m.nothtax4
		         ENDIF
		
		         *
		         *  Post compression and gathering
		         *
		         IF m.ncompress <> 0
		            IF m.ncompress < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            llpostqb = .T.
		            m.ncompress = ROUND(m.ncompress,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(lcrevclear)
		            loentry.amount.setvalue(ABS(m.ncompress))
		            loentry.MEMO.setvalue('Compression Charge')
		            lnBalance = lnBalance - m.ncompress
		         ENDIF
		
		         IF m.ngather <> 0
		            IF m.ngather < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            llpostqb = .T.
		            m.ngather = ROUND(m.ngather,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(lcrevclear)
		            loentry.amount.setvalue(ABS(m.ngather))
		            loentry.MEMO.setvalue('Gathering Charge')
		            lnBalance = lnBalance - m.ngather
		         ENDIF
		
		         *
		         *  Post Marketing Expenses
		         *
		         IF m.nMKTGExp <> 0
		            IF m.nMKTGExp < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            llpostqb = .T.
		            m.nMKTGExp = ROUND(m.nMKTGExp,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(lcexpclear)
		            loentry.amount.setvalue(ABS(m.nMKTGExp))
		            loentry.MEMO.setvalue('Marketing Expense')
		            lnBalance = lnBalance - m.nMKTGExp
		         ENDIF
		
		         *  Post the Expenses
		         lnexpense = m.nexpense + m.ntotale1 + m.ntotale2 + m.ntotale3 + m.ntotale4 + m.ntotale5 + m.ntotalea + m.ntotaleb
		
		         IF lnexpense <> 0
		            IF lnexpense < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            llpostqb = .T.
		            lnexpense = ROUND(lnexpense,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(lcexpclear)
		            loentry.amount.setvalue(ABS(lnexpense))
		            loentry.MEMO.setvalue('Operating Expenses: ' + m.hyear+'/'+m.hperiod )
		            lnBalance = lnBalance - lnexpense
		         ENDIF
		
		         *  Post Backup Withholding
		         IF m.nbackwith <> 0
		            IF m.nbackwith < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            llpostqb = .T.
		            m.nbackwith = ROUND(m.nbackwith,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(m.cbackwith)
		            loentry.amount.setvalue(ABS(m.nbackwith))
		            loentry.MEMO.setvalue('Backup Withholding')
		            lnBalance = lnBalance - m.nbackwith
		         ENDIF
		
		         *  Post Tax Withholding
		         IF m.ntaxwith <> 0
		            IF m.ntaxwith < 0
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		               ELSE
		                  loentry = loentryadd.journaldebitlinelist.APPEND
		               ENDIF
		            ELSE
		               IF llSDK5
		                  loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		               ELSE
		                  loentry = loentryadd.journalcreditlinelist.APPEND
		               ENDIF
		            ENDIF
		            llpostqb = .T.
		            m.ntaxwith = ROUND(m.ntaxwith,2)
		            IF llvalidwell
		               loentry.classref.listid.setvalue(lcwelllistid)
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(m.ctaxwith)
		            loentry.amount.setvalue(ABS(m.ntaxwith))
		            loentry.MEMO.setvalue('Income Tax W/H')
		            lnBalance = lnBalance - m.ntaxwith
		         ENDIF
		
		         *  Post Net Check
		         IF m.nnetcheck <> 0
		            lnnewdef = lnnewdef + m.nnetcheck
		         ENDIF
		
		      ENDSCAN
		
		      IF lnnewdef < 0
		         llpostqb = .T.
		         IF lnBalance <> lnnewdef
		            IF ABS(lnBalance - lnnewdef) < .10
		               m.nnetcheck = ROUND(lnBalance,2)
		            ELSE
		               m.nnetcheck = ROUND(lnnewdef,2)
		            ENDIF
		         ELSE
		            m.nnetcheck = ROUND(lnnewdef,2)
		         ENDIF
		         IF llSDK5
		            loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		         ELSE
		            loentry = loentryadd.journaldebitlinelist.APPEND
		         ENDIF
		         loentry.entityref.listid.setvalue(lcownerlistid)
		         loentry.accountref.listid.setvalue(m.cdefacct)
		         loentry.amount.setvalue(ABS(m.nnetcheck))
		         loentry.MEMO.setvalue('Deficit')
		      ELSE
		         IF lnnewdef <> 0
		            m.nnetcheck = ROUND(lnnewdef,2)
		            IF llSDK5
		               loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		            ELSE
		               loentry = loentryadd.journalcreditlinelist.APPEND
		            ENDIF
		            loentry.entityref.listid.setvalue(lcownerlistid)
		            loentry.accountref.listid.setvalue(m.cminacct)
		            loentry.amount.setvalue(ABS(m.nnetcheck))
		            loentry.MEMO.setvalue('Interest On Hold')
		            llpostqb = .T.
		         ENDIF
		      ENDIF
		
		      IF llpostqb
		         lcxml = THIS.oRequest.toxmlstring()
		         IF NOT USED('qbxml')
		            USE (m.goapp.cCommonFolder+'qbxml') IN 0
		         ENDIF
		         IF USED('qbxml')
		            INSERT INTO qbxml VALUES(m.cownerid,DATETIME(),lcxml)
		         ENDIF 
		         loresponse = m.goApp.oQB.oqbsm.dorequests(THIS.oRequest)
		         loaddresp  = loresponse.responselist.getat(0)
		
		         IF loaddresp.statuscode <> 0
		            MESSAGEBOX(loaddresp.statusmessage,0,'QuickBooks Posting Error')
		            *         MESSAGEBOX(lcXml,0,'Owner Post Error')
		            if not this.lquiet
		               oprogress.closeprogress()
		            endif   
		            m.goApp.oQB.oQBSM.ClearErrorRecovery()
		            RETURN .F.
		         ELSE
		            lonewbill = loaddresp.detail
		            m.ctxnid  = lonewbill.txnid.getvalue()
		            SELE qbpost
		            LOCATE FOR cidsysctl = THIS.csysctlkey AND ntype = lnJournal
		            IF NOT FOUND()
		               m.ntype = lnJournal
		               m.mtxnids = m.ctxnid
		               INSERT INTO qbpost FROM MEMVAR
		            ELSE
		               IF NOT EMPTY(ALLT(mtxnids))
		                  REPL mtxnids WITH ALLT(mtxnids)+CHR(13)+m.ctxnid
		               ELSE
		                  REPL mtxnids WITH m.ctxnid
		               ENDIF
		            ENDIF
		            m.goApp.oQB.oQBSM.ClearErrorRecovery()
		         ENDIF
		      ENDIF
		      THIS.oRequest.ClearRequests()
		   ENDSCAN
		
		   IF NOT THIS.lquiet
		      oprogress.closeprogress()
		      DOEVENTS
		      RELE oprogress
		   ENDIF
		
		   THIS.oRequest.ClearRequests()
		ENDIF
		
		*
		*   Process compression & gathering charges
		*
		SELECT SUM(ncompress+ngather) AS ntot FROM wellhist ;
		   WHERE nrunno = THIS.nrunno ;
		   AND crunyear = THIS.crunyear ;
		   AND cgroup = tcgroup ;
		   INTO CURSOR temp
		SELE temp
		GO TOP
		lnactivity = ntot
		IF lnactivity <> 0
		   *  Setup the journal add request
		   loentryadd = THIS.oRequest.appendjournalentryaddrq()
		   loentryadd.txndate.setvalue(tdpostdate)
		   *   loentryadd.MEMO.setvalue('** DO NOT CHANGE OR DELETE THIS ENTRY IN QUICKBOOKS **')
		ENDIF
		
		   IF NOT THIS.lquiet
		      this.oProgress.SetProgressMessage('Posting Compression/Gathering to QuickBooks...')
		      this.oProgress.UpdateProgress(this.nprogress)
		      this.nprogress = this.nprogress + 1
		   endif
		   
		lncompgath = 0
		SELECT wellhist
		SCAN FOR nrunno = THIS.nrunno ;
		      AND crunyear = THIS.crunyear ;
		      AND cgroup = tcgroup
		   lncompgath = ROUND(ncompress + ngather,2)
		
		   SELECT wells
		   LOCATE FOR cwellid = wellhist.cwellid
		   IF FOUND()
		      lcwelllistid = clistid
		      IF EMPTY(wells.clistid)
		         MESSAGEBOX('The wells file needs to be synchronized with QuickBooks. ' + ;
		            'please synchronize the file and then close the revenue period again.',0,'Synchronization Problem')
		         RETURN .F.
		      ENDIF
		   ELSE
		      LOOP
		   ENDIF
		   IF lncompgath <> 0
		      IF lncompgath > 0
		         IF llSDK5
		            loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		         ELSE
		            loentry = loentryadd.journaldebitlinelist.APPEND
		         ENDIF
		      ELSE
		         IF llSDK5
		            loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		         ELSE
		            loentry = loentryadd.journalcreditlinelist.APPEND
		         ENDIF
		      ENDIF
		      loentry.classref.listid.setvalue(lcwelllistid)
		      loentry.accountref.listid.setvalue(lcrevclear)
		      loentry.amount.setvalue(ABS(lncompgath))
		      loentry.MEMO.setvalue('Compression & Gathering')
		
		      IF lncompgath < 0
		         IF llSDK5
		            loentry = loentryadd.ORJournalLineList.APPEND.JournalDebitLine
		         ELSE
		            loentry = loentryadd.journaldebitlinelist.APPEND
		         ENDIF
		      ELSE
		         IF llSDK5
		            loentry = loentryadd.ORJournalLineList.APPEND.JournalCreditLine
		         ELSE
		            loentry = loentryadd.journalcreditlinelist.APPEND
		         ENDIF
		      ENDIF
		      loentry.classref.listid.setvalue(lcwelllistid)
		      loentry.accountref.listid.setvalue(m.cgathacct)
		      loentry.amount.setvalue(ABS(lncompgath))
		      loentry.MEMO.setvalue('Compression & Gathering')
		   ENDIF
		ENDSCAN
		
		IF lnActivity <> 0
		   lcxml = THIS.oRequest.toxmlstring()
		   loresponse = m.goApp.oQB.oqbsm.dorequests(THIS.oRequest)
		   loaddresp  = loresponse.responselist.getat(0)
		
		   IF loaddresp.statuscode <> 0
		      IF NOT USED('qbxml')
		         USE (m.goapp.cCommonFolder+'qbxml') IN 0
		      ENDIF
		      IF USED('qbxml')
		         INSERT INTO qbxml VALUES(m.cwellid,DATETIME(),lcxml)
		      ENDIF 
		      WAIT WIND NOWAIT 'Posting Comp/Gath for Well: '+m.cwellid
		      m.goApp.oQB.oQBSM.ClearErrorRecovery()
		      MESSAGEBOX(loaddresp.statusmessage,0,'QuickBooks Error')
		      *         MESSAGEBOX(lcXml,0,'Comp/Gath Post Error')
		      RETURN .F.
		   ELSE
		      lonewbill = loaddresp.detail
		      m.ctxnid  = lonewbill.txnid.getvalue()
		      SELE qbpost
		      LOCATE FOR cidsysctl = THIS.csysctlkey AND ntype = lnJournal
		      IF NOT FOUND()
		         m.ntype = lnJournal
		         m.mtxnids = m.ctxnid
		         INSERT INTO qbpost FROM MEMVAR
		      ELSE
		         IF NOT EMPTY(ALLT(mtxnids))
		            REPL mtxnids WITH ALLT(mtxnids)+CHR(13)+m.ctxnid
		         ELSE
		            REPL mtxnids WITH m.ctxnid
		         ENDIF
		      ENDIF
		      m.goApp.oQB.oQBSM.ClearErrorRecovery()
		   ENDIF
		
		   THIS.oRequest.ClearRequests()
		ENDIF
		
		***********************************************************************
		*   Post the Vendor amounts that are designated to be posted.
		***********************************************************************
		   IF NOT THIS.lquiet
		      this.oProgress.SetProgressMessage('Posting Vendor Amounts to QuickBooks...')
		      this.oProgress.UpdateProgress(this.nprogress)
		      this.nprogress = this.nprogress + 1
		   endif
		   
		THIS.qbpostvendop()
		
		***********************************************************************
		*  Post the operator/owner checks to qb
		***********************************************************************
		   IF NOT THIS.lquiet
		      this.oProgress.SetProgressMessage('Posting Operator Amounts to QuickBooks...')
		      this.oProgress.UpdateProgress(this.nprogress)
		      this.nprogress = this.nprogress + 1
		   endif
		   
		IF NOT THIS.qbpostoperator()
		   RETURN .F.
		ENDIF
		
		***********************************************************************
		*  Post the vendor checks to QB
		***********************************************************************
		   IF NOT THIS.lquiet
		      this.oProgress.SetProgressMessage('Posting Vendor Checks to QuickBooks...')
		      this.oProgress.UpdateProgress(this.nprogress)
		      this.nprogress = this.nprogress + 1
		   endif
		   
		IF NOT THIS.qbpostvendcks()
		   RETURN .F.
		ENDIF
		
		IF NOT THIS.lerrorflag
		   SELE sysctl
		   LOCATE FOR cdmbatch = THIS.cdmbatch
		   IF FOUND()
		      REPL lposted WITH .T.
		   ENDIF
		ELSE
		   RETURN .F.
		ENDIF
		
		
		
		
		
		
	ENDPROC

	PROCEDURE qbpostoperator		&& Post operator/owner amounts to qb
	ENDPROC

	PROCEDURE qbpostvendcks		&& Post vendor checks to qb
	ENDPROC

	PROCEDURE qbpostvendop		&& Post vendor/operator amounts to qb
	ENDPROC

	PROCEDURE qbsynccheck		&& Check to see if data files need to be synchronized with QuickBooks
	ENDPROC

	PROCEDURE removeqb		&& Remove QB transactions created during closing
	ENDPROC

	PROCEDURE removetax		&& Removes taxes from well history for tax exempt owners.
	ENDPROC

	PROCEDURE removetaxexempt
		LPARA tcWellID, tcType, tnAmount
		LOCAL lnShare, m.cownerid, m.nrevoil, m.nrevgas
		
		*
		* Removes the tax exempt owners share from the gross amount before taxes
		* are calculated on the gross.  - For New Mexico Wells
		*
		
		lnShare = 0
		
		SELECT wellinv
		SCAN FOR cwellid == tcwellid
		   m.cownerid = cownerid
		   m.nrevoil = nrevoil
		   m.nrevgas = nrevgas
		   SELECT investor
		   SET ORDER TO cownerid
		   IF SEEK(m.cownerid) AND lexempt
		     do case
		        case tcType = 'BBL'
		           lnShare = lnShare + swround((tnAmount * m.nrevoil/100),2)
		        case tcType = 'MCF'
		           lnShare = lnShare + swround((tnAmount * m.nrevgas/100),2)   
		     endcase      
		  ENDIF
		ENDSCAN  
		
		lnAmount = tnAmount - lnShare
		
		RETURN (lnAmount)
		        
	ENDPROC

	PROCEDURE roywork		&& Calculates the split between royalty and working owners for wellhist.
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Processing Working and Royalty Interest Totals...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		* Get the working interest totals
		Select cwellid, hyear, hperiod, 0.00 AS nroyalty, sum(nnetcheck) AS nworking ;
		   FROM invtmp ;
		   WHERE ctypeinv = 'W' AND lProgram = .F. ;
		   INTO CURSOR temphistw ;
		   ORDER BY cwellid, hyear, hperiod ;
		   GROUP BY cwellid, hyear, hperiod
		   
		* Get the royalty totals   
		Select cwellid, hyear, hperiod, 0.00 AS nworking, sum(nnetcheck) AS nroyalty ;
		   FROM invtmp ;
		   WHERE ctypeinv = 'L' OR ctypeinv = 'O' AND lProgram = .F. ;
		   INTO CURSOR temphistr ;
		   ORDER BY cwellid, hyear, hperiod ;
		   GROUP BY cwellid, hyear, hperiod
		
		CREATE CURSOR fixhist ;
		 (cwellid    C(10), ;
		  hyear     C(4), ;
		  hperiod   C(2), ;
		  nroyalty   N(12,2), ;
		  nworking   N(12,2))
		INDEX ON cwellid+hyear+hperiod TAG wellprd  
		
		SELECT fixhist
		APPEND FROM DBF('temphistw')
		
		SELECT temphistr
		GO TOP
		SCAN
		  SCATTER MEMVAR
		  lckey = m.cwellid+m.hyear+m.hperiod
		  SELECT fixhist
		  SET ORDER TO wellprd
		  SEEK lckey
		  IF FOUND()
		     REPLACE nroyalty WITH m.nroyalty
		  ELSE
		     m.nworking = 0
		     INSERT INTO fixhist FROM MEMVAR
		  ENDIF
		  SELECT temphistr
		ENDSCAN
		
		SELECT temphistr
		USE
		SELECT temphistw
		USE
		
		SELECT wellhist
		SET ORDER TO wellprd
		
		SELECT fixhist
		GO TOP
		SCAN 
		   SCATTER MEMVAR
		   lckey = m.cwellid+m.hyear+m.hperiod
		   SELECT wellhist
		   SEEK lckey
		   IF FOUND()
		      REPLACE nroyint WITH m.nroyalty, ;
		              nwrkint WITH m.nworking
		   ENDIF
		   SELECT fixhist
		ENDSCAN              
		
		IF USED('fixhist')
		   SELECT fixhist
		   USE
		ENDIF   
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Processing Working and Royalty Interest Totals...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		         
	ENDPROC

	PROCEDURE savesusp		&& Saves the suspense records in the suspense history file.
		LOCAL oprogress
		*
		*  Save the suspense records in the suspense history file
		*
		IF THIS.lerrorflag
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting savesusp')  
		endif   
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Adding Suspense Entries to History Files...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		ENDIF   
		
		lcacctyr  = THIS.cacctyear
		lcacctprd = THIS.cacctprd
		
		IF USED('invsusp')
		   IF NOT THIS.lquiet
		      oprogress = THIS.omessage.progressbar('Posting Suspense History Information')
		   ENDIF
		   SELECT invsusp
		   COUNT FOR NOT DELETED() TO lnmax
		   SELE cownerid, SUM(nnetcheck) AS nnetcheck ;
		      FROM invsusp ;
		      WHERE NOT lonhold ;
		      INTO CURSOR susptemp ;
		      ORDER BY cownerid ;
		      GROUP BY cownerid
		
		   IF NOT THIS.lquiet
		      oprogress.setprogressrange(0,lnmax)
		   ENDIF
		   lncount = 1
		
		   * Set the suspense type as a deficit
		   m.csusptype = 'D'
		
		   * Set the action as "Into Suspense"
		   m.caction   = 'I'
		
		   *  Get the DMBatch
		   m.cbatch = THIS.cdmbatch
		
		   * Only save the deficit records.  The minimum and hold records
		   * were saved in the suspense processing.
		   SELE susptemp
		   SCAN FOR nnetcheck < 0
		      m.cownerid = cownerid
		      SELE invsusp
		      SCAN FOR cownerid = m.cownerid AND NOT lonhold
		         SCATTER MEMVAR
		         SELECT investor
		         SET ORDER TO cownerid
		         IF SEEK(m.cownerid) AND investor.ldummy
		            LOOP
		         ENDIF
		         m.nincome   = IIF(m.cdirect='O',m.nincome-m.noilrev,m.nincome)
		         m.namount   = m.nnetcheck
		         m.nexpenses = m.nexpense+m.nGather+m.nCompress
		         SELE wells
		         LOCATE FOR cwellid = m.cwellid
		         IF FOUND()
		            IF ldiroilpurch
		               m.ntaxes = IIF(m.cdirect='O',m.nsevtaxes-m.noiltax1-m.noiltax2-m.noiltax3-m.noiltax4,m.nsevtaxes)
		            ELSE
		               m.ntaxes = m.nsevtaxes + m.nTaxWith
		            ENDIF
		         ELSE
		            m.ntaxes = m.nsevtaxes + m.nTaxWith
		         ENDIF
		         *  Fill in the program codes
		         IF EMPTY(m.cProgCode)
		            SELE wellinv
		            LOCATE FOR cwellid = m.cwellid AND cownerid=m.cownerid AND ctypeinv = m.ctypeinv
		            IF FOUND()
		               m.cProgCode = cProgCode
		            ENDIF
		         ENDIF
		         * Fill in the owner type if not valid
		         IF NOT INLIST(m.ctypeinv,'L','O','W')
		            SELE wellinv
		            LOCATE FOR cwellid == m.cwellid AND cownerid == m.cownerid
		            IF FOUND()
		               IF ctypeinv = 'W'
		                  * Since this is a deficit, the owner type should be working interest
		                  m.ctypeinv = 'W'
		               ELSE
		                  * Save the owner type in case there's not a working interest record
		                  lctypeinv = ctypeinv
		                  CONT
		                  IF FOUND()
		                     m.ctypeinv = ctypeinv
		                  ELSE
		                     m.ctypeinv = lctypeinv
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		         m.dsuspdate = DATE()
		         m.dAcctDate = THIS.dAcctDate
		         m.csusptime = TIME()
		         m.cRunyear  = THIS.cRunyear
		         m.cgroup    = THIS.cgroup
		         m.nrunno    = THIS.nrunno
		         m.cYear     = m.hYear
		         m.cPeriod   = m.hPeriod
		         m.ccomment  = 'Current Period Deficit'
		         m.cacctyr   = lcacctyr
		         m.cacctprd  = lcacctprd
		         m.cidsusa   = THIS.oregistry.incrementcounter('%Shared.Counters.Suspense')
		         SET DELETED OFF
		         SELECT susaudit
		         SET ORDER TO cidsusa
		         DO WHILE SEEK(m.cidsusa)
		            m.cidsusa = THIS.oregistry.incrementcounter('%Shared.Counters.Suspense')
		         ENDDO
		         SET DELETED ON
		         INSERT INTO susaudit FROM MEMVAR
		         IF NOT THIS.lquiet
		            oprogress.updateprogress(lncount)
		            lncount = lncount + 1
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		   IF NOT THIS.lquiet
		      oprogress.closeprogress()
		      RELE oprogress
		   ENDIF
		ENDIF
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Adding Suspense Entries to History Files...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending savesusp')  
		endif   
		
	ENDPROC

	PROCEDURE setup		&& Creates the work cursors for wells and owners.
		LOCAL lcRunYear
		
		lcRunYear = this.crunyear+PADL(TRANSFORM(this.nrunno),3,'0')
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Creating Temporary Work Files')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		IF THIS.lerrorflag
		   RETURN
		ENDIF
		
		SET DELETED ON
		if not THIS.lClose
		   WAIT WIND NOWAIT 'Preparing work files....'
		endif   
		
		if this.lDebug
		   this.timekeeper('Starting setup')  
		endif   
		
		IF TYPE('this.dRevDate') <> 'D'
		   THIS.dRevDate = THIS.dAcctDate
		ENDIF
		
		IF TYPE('this.dExpDate') <> 'D'
		   THIS.dExpDate = THIS.dAcctDate
		ENDIF
		
		*
		*  Check to see if the quarterly wells should be released
		*
		THIS.checkquarterly()
		
		*
		****************************************************************************
		* Prepare the wellwork cursor
		****************************************************************************
		*
		IF THIS.lrelqtr
		   SELE wellinv.cwellid, income.cyear, income.cperiod, ;
		      wells.cgroup, ;
		      THIS.nRunno, ;
		      THIS.crunyear AS crunyear, ;
		      wells.lroysevtx  AS lroysevtx, ;
		      wells.nprocess   AS nprocess  ;
		      FROM wellinv, income, wells ;
		      WHERE ((income.nRunno = 0 AND income.dRevDate <= THIS.dRevDate) OR (income.nRunno = THIS.nRunno AND income.crunyear = THIS.crunyear)) ;
		      AND wellinv.cwellid = income.cwellid ;
		      AND income.cwellid = wells.cwellid ;
		      AND iif(this.nrunno=0 or this.lclose,wells.cgroup = THIS.cgroup,.t.) ;
		      AND NOT INLIST(wells.cwellstat,'I','S','P') ;
		      INTO CURSOR tempinc ;
		      ORDER BY income.cwellid, cyear, cperiod ;
		      GROUP BY income.cwellid, cyear, cperiod
		
		   SELE wellinv.cwellid, expense.cyear, expense.cperiod, ;
		      wells.cgroup, ;
		      THIS.nRunno, ;
		      THIS.crunyear AS crunyear, ;
		      wells.lroysevtx  AS lroysevtx, ;
		      wells.nprocess   AS nprocess  ;
		      FROM wellinv, expense, wells ;
		      WHERE ((expense.nrunnorev = 0 AND expense.dExpDate <= THIS.dExpDate) OR (expense.nrunnorev = THIS.nRunno AND expense.crunyearrev = THIS.crunyear)) ;
		      AND expense.cyear <> 'FIXD' ;
		      AND wellinv.cwellid = expense.cwellid ;
		      AND expense.cwellid = wells.cwellid ;
		      AND iif(this.nrunno=0 or this.lclose,wells.cgroup = THIS.cgroup,.t.) ;
		      AND NOT INLIST(wells.cwellstat,'I','S','P') ;
		      INTO CURSOR tempexp ;
		      ORDER BY expense.cwellid, cyear, cperiod ;
		      GROUP BY expense.cwellid, cyear, cperiod
		ELSE
		   SELE wellinv.cwellid, income.cyear, income.cperiod, ;
		      wells.cgroup, ;
		      THIS.nRunno, ;
		      THIS.crunyear AS crunyear, ;
		      wells.lroysevtx  AS lroysevtx, ;
		      wells.nprocess   AS nprocess  ;
		      FROM wellinv, income, wells ;
		      WHERE ((income.nRunno = 0 AND income.dRevDate <= THIS.dRevDate) OR (income.nRunno = THIS.nRunno AND income.crunyear = THIS.crunyear)) ;
		      AND wellinv.cwellid = income.cwellid ;
		      AND iif(this.nrunno=0 or this.lclose,wells.cgroup = THIS.cgroup,.t.) ;
		      AND income.cwellid = wells.cwellid ;
		      AND iif(this.nrunno = 0 or this.lclose,wells.nprocess <> 2,.t.) ;  &&  We only care about the frequency if it's a new run
		      AND NOT INLIST(wells.cwellstat,'I','S','P') ;
		   INTO CURSOR tempinc ;
		      ORDER BY income.cwellid, cyear, cperiod ;
		      GROUP BY income.cwellid, cyear, cperiod
		
		   SELE wellinv.cwellid, expense.cyear, expense.cperiod, ;
		      wells.cgroup, ;
		      THIS.nRunno, ;
		      THIS.crunyear AS crunyear, ;
		      wells.lroysevtx  AS lroysevtx, ;
		      wells.nprocess   AS nprocess  ;
		      FROM wellinv, expense, wells ;
		      WHERE ((expense.nrunnorev = 0 AND expense.dExpDate <= THIS.dExpDate) OR (expense.nrunnorev = THIS.nRunno AND expense.crunyearrev = THIS.crunyear)) ;
		      AND expense.cyear <> 'FIXD' ;
		      AND wellinv.cwellid = expense.cwellid ;
		      AND expense.cwellid = wells.cwellid ;
		      AND iif(this.nrunno=0 or this.lclose,wells.cgroup = THIS.cgroup,.t.) ;
		      AND iif(this.nrunno=0 or this.lclose,wells.nprocess <> 2,.t.) ;  &&  We only care about the frequency if it's a new run
		      AND NOT INLIST(wells.cwellstat,'I','S','P') ;
		   INTO CURSOR tempexp ;
		      ORDER BY expense.cwellid, cyear, cperiod ;
		      GROUP BY expense.cwellid, cyear, cperiod
		ENDIF
		
		CREATE CURSOR tempflat ;
		   (cwellid     c(10), ;
		   cyear       c(4), ;
		   cperiod     c(2), ;
		   cgroup      c(2), ;
		   nRunno      i, ;
		   crunyear    c(4), ;
		   lroysevtx   l, ;
		   nprocess    i)
		
		SELE wells
		SCAN FOR BETWEEN(cwellid, THIS.cbegwellid,THIS.cendwellid) and cGroup = this.cGroup
		   m.cwellid = cwellid
		   m.lroysevtx = lroysevtx
		   m.nprocess  = nprocess
		   IF NOT THIS.lrelqtr
		      IF m.nprocess = 2
		         LOOP
		      ENDIF
		   ENDIF
		   m.nRunno    = 0
		   m.crunyear = ALLT(STR(YEAR(THIS.dAcctDate)))
		   m.cyear    = m.crunyear
		   m.cperiod  = PADL(ALLT(STR(MONTH(THIS.dAcctDate))),2,'0')
		   m.cgroup   = cgroup
		   lnflato = THIS.getflatamt(m.cwellid,'O')
		   lnflatg = THIS.getflatamt(m.cwellid,'G')
		   IF lnflato+lnflatg > 0
		      INSERT INTO tempflat FROM MEMVAR
		   ENDIF
		ENDSCAN
		
		*
		****************************************************************
		*   Create Temp Well Production History File
		****************************************************************
		SELECT wellhist
		lnx=AFIELDS(latemp)
		FOR x = 1 TO lnx
		   latemp[X,7] = ''
		   latemp[X,8] = ''
		   latemp[X,9] = ''
		   latemp[X,10] = ''
		   latemp[X,11] = ''
		   latemp[X,12] = ''
		   latemp[X,13] = ''
		   latemp[X,14] = ''
		   latemp[X,15] = ''
		   latemp[X,16] = ''
		ENDFOR
		CREATE CURSOR wellwork FROM ARRAY latemp
		
		SELECT tempinc
		SCAN
		   SCATTER MEMVAR
		   m.nRunno  = THIS.nRunno
		   m.hyear   = m.cyear
		   m.hperiod = m.cperiod
		   m.crectype = 'R'
		   INSERT INTO wellwork FROM MEMVAR
		ENDSCAN
		SELECT wellwork
		INDEX on cwellid+hyear+hperiod+crectype TAG wellprd 
		
		SELECT wellwork
		SET ORDER to WELLPRD   && CWELLID+HYEAR+HPERIOD
		
		SELECT tempexp
		SCAN
		   SCATTER MEMVAR
		   m.nRunno = THIS.nRunno
		   m.hyear   = m.cyear
		   m.hperiod = m.cperiod
		   m.crectype = 'R'
		   SELE wellwork
		   IF NOT SEEK(m.cwellid+m.hyear+m.hperiod+'R')
		      INSERT INTO wellwork FROM MEMVAR
		   ENDIF
		ENDSCAN
		
		SELE tempflat
		SCAN
		   SCATTER MEMVAR
		   m.nRunno = THIS.nRunno
		   m.hyear   = m.cyear
		   m.hperiod = m.cperiod
		   m.crectype = 'R'
		   SELE wellwork
		   IF NOT SEEK(m.cwellid+m.hyear+m.hperiod)
		      INSERT INTO wellwork FROM MEMVAR
		   ENDIF
		ENDSCAN
		
		SET SAFETY OFF
		SELECT wellwork
		INDEX ON cwellid TAG cwellid
		INDEX ON hyear+hperiod TAG yearprd
		
		****************************************************************************
		*  Build invtmp table
		****************************************************************************
		*
		IF THIS.lRunCLosed
		   *  Look at disbhist
		   SELECT THIS.nRunno   AS nRunno, ;
		      THIS.crunyear AS crunyear, ;
		      {^1980-01-01} AS hdate, ;
		      disbhist.cownerid, ;
		      disbhist.cwellid, ;
		      THIS.cgroup AS cgroup, ;
		      ownpcts.nworkint, ;
		      disbhist.ciddisb as cidwinv, ;
		      ownpcts.nintclass1, ;
		      ownpcts.nintclass2, ;
		      ownpcts.nintclass3, ;
		      ownpcts.nintclass4, ;
		      ownpcts.nintclass5, ;
		      ownpcts.nacpint, ;
		      ownpcts.nbcpint, ;
		      ownpcts.nrevoil, ;
		      ownpcts.nrevgas, ;
		      ownpcts.nrevtrp, ;
		      ownpcts.nrevoth, ;
		      ownpcts.nrevtax1, ;
		      ownpcts.nrevtax2, ;
		      ownpcts.nrevtax3, ;
		      ownpcts.nrevtax4, ;
		      ownpcts.nrevtax5, ;
		      ownpcts.nrevtax6, ;
		      ownpcts.nrevtax7, ;
		      ownpcts.nrevtax8, ;
		      ownpcts.nrevtax9, ;
		      ownpcts.nrevtax10, ;
		      ownpcts.nrevtax11, ;
		      ownpcts.nrevtax12, ;
		      disbhist.ctypeinv, ;
		      disbhist.ctypeint, ;
		      disbhist.cdirect, ;
		      disbhist.lflat, ;
		      disbhist.nflatrate, ;
		      disbhist.cflatstart, ;
		      disbhist.nflatfreq, ;
		      disbhist.cprogcode, ;
		      ownpcts.nrevmisc1, ;
		      ownpcts.nrevmisc2, ;
		      disbhist.ljib, ;
		      disbhist.lonhold, ;
		      disbhist.ciddisb, ;
		      wells.cstate, ;
		      'R'  AS crectype, ;
		      .F.  AS lused, ;
		      .F.  AS lprognet, ;
		      000000.00 AS nbbltot, ;
		      000000.00 AS nmcftot, ;
		      000000.00 AS nothtot, ;
		      000000.00 AS nincome, ;
		      000000.00 AS ngasrev, ;
		      000000.00 AS noilrev, ;
		      000000.00 AS ntrprev, ;
		      000000.00 AS nmiscrev1, ;
		      000000.00 AS nmiscrev2, ;
		      000000.00 AS nexpense, ;
		      000000.00 AS ntotale1, ;
		      000000.00 AS ntotale2, ;
		      000000.00 AS ntotale3, ;
		      000000.00 AS ntotale4, ;
		      000000.00 AS ntotale5, ;
		      000000.00 AS ntotalea, ;
		      000000.00 AS ntotaleb, ;
		      000000.00 AS nnetcheck, ;
		      000000.00 AS nsevtaxes, ;
		      00.00     AS ntaxpct, ;
		      wells.nlandpct, ;
		      wells.noverpct, ;
		      wells.lroysevtx, ;
		      wells.lusesev, ;
		      wells.ldiroilpurch AS ldiropurch, ;
		      wells.ldirgaspurch AS ldirgpurch, ;
		      disbhist.lprogram ;
		      FROM disbhist, wells, ownpcts ;
		      WHERE disbhist.crunyear+PADL(TRANSFORM(disbhist.nrunno),3,'0') == lcRunYear ;
		      AND disbhist.cownerid IN (SELECT cownerid FROM owntemp) ;
		      AND disbhist.cwellid IN (SELECT cwellid FROM welltemp) ;
		      AND disbhist.cwellid = wells.cwellid ;
		      AND IIF(THIS.cgroup<>'**',wells.cgroup = THIS.cgroup,.T.) ;
		      AND NOT INLIST(wells.cwellstat,'I','S','P','V') ;
		      AND disbhist.ciddisb = ownpcts.ciddisb ;
		      INTO CURSOR invtmpx ;
		      ORDER BY disbhist.cownerid, disbhist.cwellid
		ELSE
		   SELECT THIS.nRunno   AS nRunno, ;
		      THIS.crunyear AS crunyear, ;
		      {^1980-01-01} AS hdate, ;
		      wellinv.cownerid, ;
		      wellinv.cwellid, ;
		      THIS.cgroup AS cgroup, ;
		      wellinv.nworkint, ;
		      wellinv.cidwinv, ;
		      wellinv.nintclass1, ;
		      wellinv.nintclass2, ;
		      wellinv.nintclass3, ;
		      wellinv.nintclass4, ;
		      wellinv.nintclass5, ;
		      wellinv.nacpint, ;
		      wellinv.nbcpint, ;
		      wellinv.nrevoil, ;
		      wellinv.nrevgas, ;
		      wellinv.nrevtrp, ;
		      wellinv.nrevoth, ;
		      wellinv.nrevtax1, ;
		      wellinv.nrevtax2, ;
		      wellinv.nrevtax3, ;
		      wellinv.nrevtax4, ;
		      wellinv.nrevtax5, ;
		      wellinv.nrevtax6, ;
		      wellinv.nrevtax7, ;
		      wellinv.nrevtax8, ;
		      wellinv.nrevtax9, ;
		      wellinv.nrevtax10, ;
		      wellinv.nrevtax11, ;
		      wellinv.nrevtax12, ;
		      wellinv.ctypeinv, ;
		      wellinv.ctypeint, ;
		      wellinv.cdirect, ;
		      wellinv.lflat, ;
		      wellinv.nflatrate, ;
		      wellinv.cflatstart, ;
		      wellinv.nflatfreq, ;
		      wellinv.cprogcode, ;
		      wellinv.nrevmisc1, ;
		      wellinv.nrevmisc2, ;
		      wellinv.ljib, ;
		      wellinv.lonhold, ;
		      wellinv.ntaxpct, ;
		      wellinv.cidwinv AS ciddisb, ;
		      'R'  AS crectype, ;
		      .F.  AS lused, ;
		      .F.  AS lprognet, ;
		      000000.00 AS nbbltot, ;
		      000000.00 AS nmcftot, ;
		      000000.00 AS nothtot, ;
		      000000.00 AS nincome, ;
		      000000.00 AS ngasrev, ;
		      000000.00 AS noilrev, ;
		      000000.00 AS ntrprev, ;
		      000000.00 AS nmiscrev1, ;
		      000000.00 AS nmiscrev2, ;
		      000000.00 AS nexpense, ;
		      000000.00 AS ntotale1, ;
		      000000.00 AS ntotale2, ;
		      000000.00 AS ntotale3, ;
		      000000.00 AS ntotale4, ;
		      000000.00 AS ntotale5, ;
		      000000.00 AS ntotalea, ;
		      000000.00 AS ntotaleb, ;
		      000000.00 AS nnetcheck, ;
		      000000.00 AS nsevtaxes, ;
		      wells.cstate, ;
		      wells.nlandpct, ;
		      wells.noverpct, ;
		      wells.lroysevtx, ;
		      wells.lusesev, ;
		      wells.ldiroilpurch AS ldiropurch, ;
		      wells.ldirgaspurch AS ldirgpurch, ;
		      wellinv.lprogram ;
		      FROM wellinv, wells ;
		      WHERE wellinv.cownerid IN (SELECT cownerid FROM owntemp) ;
		      AND wellinv.cwellid IN (SELECT cwellid FROM welltemp) ;
		      AND wellinv.cwellid = wells.cwellid ;
		      AND IIF(THIS.cgroup<>'**',wells.cgroup = THIS.cgroup,.T.) ;
		      AND NOT INLIST(wells.cwellstat,'I','S','P','V') ;
		      INTO CURSOR invtmpx ;
		      ORDER BY wellinv.cownerid, wellinv.cwellid
		ENDIF
		
		****************************************************************
		*   Create Temp Investor Disbursement File
		****************************************************************
		SWSELECT('disbhist')
		lnx=AFIELDS(latempx)
		SWSELECT('ownpcts')
		lny=AFIELDS(latempy)
		DIMENSION laTemp[lnx+lny-1,18]
		FOR x = 1 TO lnx
		   FOR y = 1 TO 18
		      laTemp[x,y] = laTempx[x,y]
		   ENDFOR
		ENDFOR 
		FOR x = 1 TO lny - 1
		   FOR y = 1 TO 18
		      laTemp[x+lnx,y] = laTempy[x+1,y]
		   ENDFOR
		ENDFOR    
		FOR x = 1 TO lnx+lny - 1
		   latemp[X,7] = ''
		   latemp[X,8] = ''
		   latemp[X,9] = ''
		   latemp[X,10] = ''
		   latemp[X,11] = ''
		   latemp[X,12] = ''
		   latemp[X,13] = ''
		   latemp[X,14] = ''
		   latemp[X,15] = ''
		   latemp[X,18] = ''
		ENDFOR
		
		SET SAFETY OFF
		CREATE CURSOR invtmp FROM ARRAY latemp
		
		**-
		**- Append records to the owner work cursor
		**-
		SELE wellwork
		SCAN
		   m.cwellid = cwellid
		   m.hyear   = hyear
		   m.hperiod = hperiod
		   SELE invtmpx
		   SCAN FOR cwellid = m.cwellid
		      SCATTER MEMVAR
		      INSERT INTO invtmp FROM MEMVAR
		   ENDSCAN
		ENDSCAN
		
		* Create index tags after the data has been appended. (Faster)
		SELECT invtmp
		INDEX ON cownerid+cprogcode+cwellid+hyear+hperiod TAG invprog
		INDEX ON cprogcode TAG cprogcode
		INDEX ON hyear+hperiod TAG yearprd
		INDEX ON cownerid+cprogcode+cwellid+ctypeinv TAG ownertype
		INDEX ON cownerid+cwellid TAG invwell
		
		**-
		**-  Flag the programs as being netted outside the program or not
		**-
		SELECT invtmp
		SCAN FOR NOT EMPTY(cprogcode)
		   m.cprogcode = cprogcode
		   SELECT programs
		   SET ORDER TO cprogcode
		   IF SEEK(m.cprogcode)
		      m.lprognet = lprognet
		   ELSE
		      m.lprognet = .F.
		   ENDIF
		   SELECT invtmp
		   REPLACE lprognet WITH m.lprognet
		ENDSCAN
		
		WAIT CLEAR
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Creating Temporary Work Files')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending setup')  
		endif   
		
	ENDPROC

	PROCEDURE suspcalc		&& Calculate the current suspense balance.
		LPARA tcPrd, tlProgram, tlOverAll, tlIncBack, tlNoNet
		LOCAL lnCount, lcYear, lcPeriod, lcGroup
		
		IF this.lErrorFlag 
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting suspcalc')  
		endif   
		
		if this.nRunNo = 0
		   lcYear  = ALLT(STR(YEAR(DATE()),4))
		   lnRunNo = getrunno(lcYear,.t.,'R')
		ELSE   
		   lcYear   = this.cRunYear
		   lnRunNo  = this.nRunNo  
		ENDIF  
		
		lcGroup  = this.cGroup
		lcPeriod = this.cPeriod
		
		SELECT groups
		SET ORDER TO cGroup
		IF SEEK(lcGroup)
		   llNetDef = lNetDef
		ELSE
		   llNetDef = .T.
		ENDIF
		
		IF llNetDef = .T.
		   IF tlNoNet
		      llNetDef = .F.
		   ENDIF
		ENDIF      
		   
		SELECT cProgCode, lprognet ;
		  FROM invtmp ;
		  WHERE NOT EMPTY(cprogcode) ;
		  INTO CURSOR tempprog ;
		  ORDER BY cprogcode ;
		  GROUP BY cprogcode
		INDEX ON cprogcode TAG cprogcode  
		
		CREATE CURSOR susptmp1 ;
		  (cOwnerID   C(10), ;
		   cWellID     C(10), ;
		   cprogcode   C(10), ;
		   ctypeinv    C(1), ;
		   cgroup      C(2), ;
		   namount     N(12,2))
		   
		CREATE CURSOR suspbal ;
		  (cOwnerID   C(10), ;
		   cWellID     C(10), ;
		   cprogcode   C(10), ;
		   ctypeinv    C(1), ;
		   cgroup      C(2), ;
		   namount     N(12,2))
		
		DO CASE
		   CASE llNetDef        && Net deficits with other income
		      DO CASE
		         CASE tcPrd = '**' AND tlProgram = .F. AND tlOverAll = .F.  && Overall balance without programs
		            SELECT programs
		            COUNT FOR NOT DELETED() TO lnCount
		            IF lnCount > 0
		               IF lcGroup = '**'
		                  SELECT cOwnerID, ctypeinv, ' ' AS cprogcode, SUM(namount) AS namount, cgroup ;
		                    FROM susaudit, tempprog ;
		                    WHERE cAction='I' ;
		                      AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND susaudit.cProgCode = tempprog.cProgCode  ;
		                      AND tempprog.lProgNet = .T. ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                      AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp2
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp2')  
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                    FROM susaudit ;
		                    WHERE cAction='I'  ;
		                      AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND (susaudit.cProgCode = ' ' OR susaudit.cProgCode = 'NONE') ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                      AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp2
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp2')  
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                    FROM susaudit, tempprog ;
		                    WHERE cAction='O' ;
		                      AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND susaudit.cProgCode = tempprog.cProgCode ;
		                      AND tempprog.lProgNet = .T. ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                      AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp3   
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp3')
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                    FROM susaudit ;
		                    WHERE cAction='O'  ;
		                      AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND (susaudit.cProgCode = ' ' OR susaudit.cProgCode = 'NONE') ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                      AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp3
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp3')  
		               ELSE
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                    FROM susaudit, tempprog ;
		                    WHERE cAction='I' ;
		                      AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND cGroup = lcGroup  ;
		                      AND susaudit.cProgCode = tempprog.cProgCode ;
		                      AND tempprog.lProgNet = .T. ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                      AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp2
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp2')  
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                    FROM susaudit ;
		                    WHERE cAction='I' ;
		                      AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND cGroup = lcGroup  ;
		                      AND susaudit.cProgCode NOT IN (SELECT cprogcode FROM tempprog) ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                      AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp2
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp2')  
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                    FROM susaudit, tempprog ;
		                    WHERE cAction='O'  ;
		                      AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND susaudit.cProgCode = tempprog.cProgCode  ;
		                      AND cGroup = lcGroup   ;
		                      AND tempprog.lProgNet = .T. ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                      AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp3   
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp3')
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                    FROM susaudit ;
		                    WHERE cAction='O'  ;
		                      AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND cGroup = lcGroup  ;
		                      AND susaudit.cProgCode NOT IN (SELECT cProgCode FROM tempprog) ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                      AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp3
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp3')  
		               ENDIF
		            ELSE
		               IF lcGroup = '**'
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                     FROM susaudit ;
		                     WHERE cAction='I'  ;
		                       AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                       AND susaudit.cSuspType <> 'T' ;
		                     GROUP BY cOwnerID ;
		                     INTO CURSOR susptmp2
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                     FROM susaudit ;
		                     WHERE cAction='O'  ;
		                       AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                       AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp3
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp2')
		                  APPEND FROM DBF('susptmp3')
		               ELSE
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                     FROM susaudit ;
		                     WHERE cAction='I' ;
		                       AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                       AND cGroup = lcGroup  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                       AND susaudit.cSuspType <> 'T' ;
		                      GROUP BY cOwnerID ;
		                     INTO CURSOR susptmp2
		                  SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                     FROM susaudit ;
		                     WHERE cAction='O' ;
		                       AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                       AND cGroup = lcGroup ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                       AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                    INTO CURSOR susptmp3
		                  SELECT susptmp1
		                  APPEND FROM DBF('susptmp2')
		                  APPEND FROM DBF('susptmp3')
		               ENDIF      
		            ENDIF                 
		                 
		            SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		              FROM susptmp1 ;
		              GROUP BY cOwnerID ;
		              INTO CURSOR suspbalx  
		              
		         CASE tcPrd = '**' AND tlProgram = .F. AND tlOverAll = .T.  && Overall balance without tempprog
		            IF lcGroup = '**'
		               SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='I' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp2
		                SELECT susptmp1
		                APPEND FROM DBF('susptmp2')  
		                SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='I'  ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp2
		                SELECT susptmp1
		                APPEND FROM DBF('susptmp2')  
		                SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='O' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp3   
		                SELECT susptmp1
		                APPEND FROM DBF('susptmp3')
		                SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='O' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp3
		                SELECT susptmp1
		                APPEND FROM DBF('susptmp3')  
		            ELSE
		               SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='I' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                    AND cGroup = lcGroup   ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp2
		                SELECT susptmp1
		                APPEND FROM DBF('susptmp2')  
		                SELECT cOwnerID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='O' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                    AND cGroup = lcGroup   ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp3   
		                SELECT susptmp1
		                APPEND FROM DBF('susptmp3')
		            ENDIF                 
		                 
		            SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		              FROM susptmp1 ;
		              GROUP BY cOwnerID ;
		              INTO CURSOR suspbalx  
		              
		         CASE tcPrd = '**' AND tlProgram = .T.   && Overall balance by program
		            IF lcGroup = '**'
		               SELECT cOwnerID, cTypeInv, susaudit.cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                 FROM susaudit, tempprog ;
		                 WHERE cAction='I' ;
		                   AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                   AND susaudit.cProgCode = tempprog.cProgCode  ;
		                   AND tempprog.lProgNet = .F. ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                   AND susaudit.cSuspType <> 'T' ;
		                  GROUP BY susaudit.cOwnerID, susaudit.cProgCode ;
		                 INTO CURSOR susptmp2
		               SELECT cOwnerID, cTypeInv, susaudit.cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                 FROM susaudit, tempprog ;
		                 WHERE cAction='O' ;
		                   AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                   AND susaudit.cProgCode = tempprog.cProgCode ;
		                   AND tempprog.lProgNet = .F. ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                   AND susaudit.cSuspType <> 'T' ;
		                  GROUP BY susaudit.cOwnerID, susaudit.cProgCode ;
		                 INTO CURSOR susptmp3
		               SELECT susptmp1
		               APPEND FROM DBF('susptmp2')
		               APPEND FROM DBF('susptmp3')
		               SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susptmp1 ;
		                  GROUP BY cOwnerID, cProgCode ;
		                  INTO CURSOR suspbalx       
		            ELSE
		               SELECT cOwnerID, cTypeInv, susaudit.cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit, tempprog ;
		                  WHERE cAction='I' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                    AND cGroup = lcGroup  ;
		                    AND susaudit.cProgCode = tempprog.cProgCode ;
		                    AND tempprog.lProgNet = .F. ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY susaudit.cOwnerID, susaudit.cProgCode ;
		                  INTO CURSOR susptmp2
		               SELECT cOwnerID, cTypeInv, susaudit.cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit, tempprog ;
		                  WHERE cAction='O' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                    AND cGroup = lcGroup ;
		                    AND susaudit.cProgCode = tempprog.cProgCode ;
		                    AND tempprog.lProgNet = .F. ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY susaudit.cOwnerID, susaudit.cProgCode ;
		                  INTO CURSOR susptmp3
		               SELECT susptmp1
		               APPEND FROM DBF('susptmp2')
		               APPEND FROM DBF('susptmp3')
		               SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susptmp1 ;
		                  GROUP BY cOwnerID, cProgCode ;
		                  INTO CURSOR suspbalx       
		            ENDIF    
		              
		         CASE tcPrd <> '**'            && Period Balance
		            IF lcGroup = '**'
		               SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='I' ;
		                    AND cYear+cPeriod = tcPrd  ;
		                    AND IIF(tlIncBack,susaudit.cSuspType <> 'X', susaudit.cSuspType <> 'B') ;
		                    AND susaudit.cSuspType <> 'T' ;
		                  GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp2
		               SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='O' ;
		                    AND cYear+cPeriod = tcPrd  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp3  
		               SELECT susptmp1
		               APPEND FROM DBF('susptmp2')
		               APPEND FROM DBF('susptmp3')
		               SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susptmp1 ;
		                  GROUP BY cOwnerID ;
		                  INTO CURSOR suspbalx       
		            ELSE
		               SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='I' ;
		                    AND cYear+cPeriod = tcPrd ;
		                    AND cGroup = lcGroup ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp2
		               SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='O' ;
		                    AND cYear+cPeriod = tcPrd ;
		                    AND cGroup = lcGroup ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID ;
		                  INTO CURSOR susptmp3  
		               SELECT susptmp1
		               APPEND FROM DBF('susptmp2')
		               APPEND FROM DBF('susptmp3')
		               SELECT cOwnerID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susptmp1 ;
		                  GROUP BY cOwnerID ;
		                  INTO CURSOR suspbalx       
		            ENDIF     
		      ENDCASE 
		               
		   CASE NOT llNetDef        && Each well has its own suspense
		      DO CASE
		         CASE tcPrd = '**'            && Overall balance
		            IF lcGroup = '**'
		               SELECT cOwnerID, cWellID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='I' ; 
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR susptmp2
		               SELECT cOwnerID, cWellID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='O'  ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR susptmp3  
		               SELECT susptmp1
		               APPEND FROM DBF('susptmp2')
		               APPEND FROM DBF('susptmp3')
		               SELECT cOwnerID, cTypeInv, cWellID, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susptmp1 ;
		                  GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR suspbalx  
		           ELSE
		              SELECT cOwnerID, cWellID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='I' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                    AND cGroup = lcGroup ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR susptmp2
		              SELECT cOwnerID, cWellID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='O' ;
		                    AND cRunYear+STR(nRunNo) < lcYear+STR(lnRunNo)  ;
		                    AND cGroup = lcGroup ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR susptmp3  
		              SELECT susptmp1
		              APPEND FROM DBF('susptmp2')
		              APPEND FROM DBF('susptmp3')
		              SELECT cOwnerID, cTypeInv, cWellID, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susptmp1 ;
		                  GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR suspbalx  
		           ENDIF     
		              
		         CASE tcPrd <> '**'            && Period Balance
		            IF lcGroup = '**'
		               SELECT cOwnerID, cWellID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                   FROM susaudit ;
		                   WHERE cAction='I' ;
		                     AND cYear+cPeriod = tcPrd  ; 
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                     AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID, cWellID ;
		                   INTO CURSOR susptmp2
		               SELECT cOwnerID, cWellID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                   FROM susaudit ;
		                   WHERE cAction='O' ;
		                     AND cYear+cPeriod = tcPrd  ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                     AND susaudit.cSuspType <> 'T' ;
		                    GROUP BY cOwnerID, cWellID ;
		                   INTO CURSOR susptmp3  
		               SELECT susptmp1
		               APPEND FROM DBF('susptmp2')
		               APPEND FROM DBF('susptmp3')
		               SELECT cOwnerID, cWellID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                   FROM susptmp1 ;
		                   GROUP BY cOwnerID, cWellID ;
		                   INTO CURSOR suspbalx       
		           ELSE
		              SELECT cOwnerID, cWellID, cTypeInv, ' ' AS cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='I' ;
		                    AND cYear+cPeriod = tcPrd ; 
		                    AND cGroup = lcGroup ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR susptmp2
		              SELECT cOwnerID, cWellID, cTypeInv, ' ' AS cProgCode, SUM(nAmount*-1) AS nAmount, cGroup ;
		                  FROM susaudit ;
		                  WHERE cAction='O' ;
		                    AND cYear+cPeriod = tcPrd ;
		                    AND cGroup = lcGroup ;
		                      AND IIF(tlIncBack,susaudit.cSuspType <> 'P', NOT INLIST(susaudit.cSuspType,'P','B')) ;
		                    AND susaudit.cSuspType <> 'T' ;
		                   GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR susptmp3  
		              SELECT susptmp1
		              APPEND FROM DBF('susptmp2')
		              APPEND FROM DBF('susptmp3')
		              SELECT cOwnerID, cWellID, cTypeInv, cProgCode, SUM(nAmount) AS nAmount, cGroup ;
		                  FROM susptmp1 ;
		                  GROUP BY cOwnerID, cWellID ;
		                  INTO CURSOR suspbalx       
		           ENDIF      
		      ENDCASE             
		ENDCASE
		
		SELECT suspbal
		APPEND FROM DBF('suspbalx')
		
		SCAN FOR namount = 0
		   DELETE NEXT 1
		ENDSCAN
		   
		SELECT suspbal
		INDEX ON cOwnerID TAG cOwnerID
		INDEX ON cOwnerID+cProgCode TAG invprog
		
		IF NOT llNetDef
		   INDEX ON cOwnerID+cwellid TAG invwell
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending suspcalc')  
		endif   
		
		RETURN      
		
		 
	ENDPROC

	PROCEDURE suspint		&& Look for interests on hold being released.
		IF this.lErrorFlag 
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting suspint')  
		endif   
		
		CREATE CURSOR suspbal ;
		  (cOwnerID   C(10), ;
		   cWellID     C(10), ;
		   cprogcode   C(10), ;
		   ctypeinv    C(1), ;
		   cgroup      C(2), ;
		   nincome     N(12,2), ;
		   nexpenses   N(12,2), ;
		   ntaxes      N(9,2), ;
		   namount     N(12,2))
		INDEX ON cownerid TAG cownerid
		
		IF this.nRunNo = 0
		   this.cRunYear = ALLT(STR(YEAR(this.dacctdate)))
		   this.nRunNo   = getrunno(this.cRunYear,.T.,'R')
		ENDIF   
		      
		SELECT cOwnerID, ;
		       cWellID,   ;
		       cprogcode, ;
		       ctypeinv,  ;
		       cgroup,    ;
		       SUM(IIF(cAction='I',nincome,nincome*-1)) AS nIncome, ;
		       SUM(IIF(cAction='I',nExpenses,nExpenses*-1)) AS nExpenses, ;
		       SUM(IIF(cAction='I',nTaxes,nTaxes*-1)) AS nTaxes, ;
		       SUM(IIF(cAction='I',namount,namount*-1)) AS nAmount ;
		  FROM susaudit  ;
		  WHERE csusptype = 'I' ;
		    AND cRunYear+str(nrunno) < this.cRunYear+str(this.nrunno) ;
		    AND cGroup = this.cGroup ;
		  INTO CURSOR temp ;  
		  ORDER BY cOwnerID, cWellID, cTypeInv ;
		  GROUP BY cOwnerID, cWellID, cTypeInv        
		         
		IF _tally > 0
		   SELECT suspbal
		   APPEND FROM DBF('temp')
		ENDIF   
		
		USE IN temp
		
		if this.lDebug
		   this.timekeeper('Ending suspint')  
		endif   
		
	ENDPROC

	PROCEDURE susp_by_owner		&& Suspense Processing By Owner
		LOCAL lnCount, lnMax, m.cDefType, m.lBackWith, m.lTaxWith, lnMinCheck, llRelMin, tlClose
		LOCAL lcBatch, m.lTaxGross, lcAcctYear, lcAcctPrd, oProgress, lcYear, lcPeriod
		LOCAL m.cRunYear
		
		tlClose = THIS.lClose
		m.cBatch = THIS.cDMBatch
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting susp_by_owner')  
		endif   
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Processing Suspense by Owner...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		lcAcctYr   = THIS.cacctyear
		lcAcctPrd  = THIS.cAcctPrd
		m.cRunYear = THIS.cRunYear
		lnRunNo    = THIS.nRunNo
		
		IF EMPTY(THIS.cRunYear)
		   m.cRunYear = STR(YEAR(DATE()),4)
		   lnRunNo    = getrunno(m.cRunYear,.T.)
		ENDIF
		
		SELECT options
		lnMinCheck = nMinCheck
		lcMinAcct  = cMinAcct
		lcDefAcct  = cDefAcct
		
		SELECT glopt
		lcRevClear = cRevClear
		lcExpClear = cExpClear
		
		*  Set up added information
		m.dAdded    = DATETIME()
		m.cUserAdd  = 'SYSTEM'
		
		llRelMin = this.lRelMin
		
		m.cGroup = THIS.cGroup
		m.cDefType = 'D'
		m.lBackWith = .F.
		m.lTaxWith  = .F.
		m.lTaxGross = .F.
		
		sele max(hperiod) as cperiod, max(hyear) as cyear from invtmp into cursor temp
		if _tally > 0
		   lcPeriod = cperiod
		   lcYear   = cyear
		else
		   lcPeriod = this.cperiod
		   lcYear   = this.cyear
		endif      
		
		*
		*  Fix the suspense history for programs
		*  Quarterly, Annual, Semi-Annual shouldn't have
		*  a program associated with them.
		*  Removed holds from this 9/17/03 - was screwing up Kastle
		*
		SELE susaudit
		SCAN FOR INLIST(cSuspType,'Q','A','S') AND NOT EMPTY(cProgCode)
		*   REPL cProgCode WITH ''
		ENDSCAN
		
		*
		*  Get the list of owners that are to be posted to G/L
		*
		SELECT cOwnerID FROM investor WHERE lIntegGL = .T. INTO CURSOR owngl
		
		*
		****************************************************************
		*   Create temp suspense file
		****************************************************************
		*
		SWSELECT('disbhist')
		lnx=AFIELDS(latempx)
		SWSELECT('ownpcts')
		lny=AFIELDS(latempy)
		DIMENSION laTemp[lnx+lny-1,18]
		FOR x = 1 TO lnx
		   FOR y = 1 TO 18
		      laTemp[x,y] = laTempx[x,y]
		   ENDFOR
		ENDFOR 
		FOR x = 1 TO lny - 1
		   FOR y = 1 TO 18
		      laTemp[x+lnx,y] = laTempy[x+1,y]
		   ENDFOR
		ENDFOR    
		FOR x = 1 TO lnx+lny - 1
		   latemp[X,7] = ''
		   latemp[X,8] = ''
		   latemp[X,9] = ''
		   latemp[X,10] = ''
		   latemp[X,11] = ''
		   latemp[X,12] = ''
		   latemp[X,13] = ''
		   latemp[X,14] = ''
		   latemp[X,15] = ''
		   latemp[X,18] = ''
		ENDFOR
		
		CREATE CURSOR invsusp FROM ARRAY latemp
		
		SET SAFETY OFF
		SELECT invsusp
		INDEX ON cWellID+cOwnerID TAG wellinv
		INDEX ON cOwnerID+cWellID TAG invwell
		INDEX ON cWellID TAG cWellID
		INDEX ON cOwnerID TAG cOwnerID
		
		SELECT invtmp
		GO TOP
		m.hdate = hdate
		
		*
		*  Get the accounting month
		*
		lcAcctPrd = PADL(ALLTRIM(STR(MONTH(m.hdate),2)),2,'0')
		
		*this.intonhold()
		
		
		******************************************************************
		*  Remove interests on hold
		******************************************************************
		
		SELECT * FROM invtmp INTO CURSOR invhold WHERE lOnHold ORDER BY cOwnerID, cWellID
		IF _TALLY > 0
		   SELECT invhold
		   SCAN
		      SCATTER MEMVAR
		      m.cAcctYr   = lcAcctYr
		      m.cAcctPrd  = lcAcctPrd
		      INSERT INTO invsusp FROM MEMVAR
		      * Remove the record from the owner temp file
		      SELECT invtmp
		      SET ORDER TO invtype
		      IF SEEK(m.cOwnerID+m.cWellID+m.ctypeinv+m.ctypeint+m.cProgCode)
		         DELETE NEXT 1
		      ENDIF
		      SELE invhold
		      IF tlClose AND m.nNetCheck <> 0
		         m.cYear     = lcYear
		         m.cPeriod   = lcPeriod
		         m.cGroup    = THIS.cGroup
		         m.nRunNo    = lnRunNo
		         m.cAction   = 'I'
		         m.cSuspType = 'I'
		         m.nAmount   = m.nNetCheck
		         m.nIncome   = IIF(m.cDirect='O',m.nIncome-m.nOilRev,m.nIncome)
		         m.nExpenses = m.nExpense + m.nTotale1 + m.nTotale2 + m.nTotale3 + m.nTotale4 + m.nTotale5 + m.nTotaleA + m.nTotaleB + m.nCompress + m.nGather
		         m.nTaxes    = m.nSevTaxes + m.nTaxWith 
		         m.cAcctYr   = lcAcctYr
		         m.cAcctPrd  = lcAcctPrd
		         m.cComment  = 'Interest on Hold'
		
		         * Insert the record into the suspense audit file
		         m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		         SELECT susaudit
		         SET DELETED OFF
		         SET ORDER TO cidsusa
		         DO WHILE INDEXSEEK(m.cidsusa)
		            m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		         ENDDO
		         INSERT INTO susaudit FROM MEMVAR
		         SET DELETED ON
		      ENDIF
		   ENDSCAN
		ENDIF
		
		*USE IN invhold
		
		*  Calculate suspense by owner
		THIS.calcsuspbalance('O')
		THIS.calcsuspense('O')
		
		*  Calculate suspense by owner and program
		THIS.calcsuspbalance('P')
		THIS.calcsuspense('P')
		
		
		*
		*************************************************************************
		*  Total each check to see if check amount is below minimum
		*************************************************************************
		*
		IF THIS.lRelMin
		   SELECT investor.cOwnerID, 000000.00 AS nTotalck, THIS.cGroup AS cGroup  ;
		      WHERE investor.lHold = .F. ;
		      FROM investor ;
		      INTO CURSOR invtotal ;
		      GROUP BY investor.cOwnerID ;
		      ORDER BY investor.cOwnerID
		ELSE
		   SELECT invtmp.cOwnerID, SUM(ROUND(nNetCheck,2)) AS nTotalck, cGroup  ;
		      FROM invtmp ;
		      INTO CURSOR invtotal ;
		      GROUP BY invtmp.cOwnerID ;
		      ORDER BY invtmp.cOwnerID
		ENDIF
		
		***********************************************************************
		*   Bring in minimum suspense amounts from previous periods
		***********************************************************************
		*
		SELECT invtotal
		COUNT FOR NOT DELETED() TO lnMax
		lnCount = 1
		
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBar('Processing minimum check amounts...')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		*
		*   Get balance of invsusp by owner
		*
		SELECT invsusp.cOwnerID, SUM(ROUND(nNetCheck,2)) AS nTotalck, cGroup  ;
		   FROM invsusp ;
		   INTO CURSOR cursuspown ;
		   GROUP BY invsusp.cOwnerID ;
		   ORDER BY invsusp.cOwnerID
		
		*
		*   Get balance of invsusp by program
		*
		SELECT invsusp.cOwnerID, cProgCode, SUM(ROUND(nNetCheck,2)) AS nTotalck, cGroup  ;
		   FROM invsusp ;
		   INTO CURSOR cursuspprog ;
		   GROUP BY invsusp.cOwnerID, cProgCode ;
		   ORDER BY invsusp.cOwnerID, cProgCode
		
		*
		*   Get balance of suspbalownp by owner
		*
		IF USED('suspbalownp')
		   SELECT cOwnerID, SUM(ROUND(nNetOwn,2)) AS nNetOwn, cGroup  ;
		      FROM suspbalownp ;
		      INTO CURSOR suspprog ;
		      GROUP BY cOwnerID ;
		      ORDER BY cOwnerID
		ENDIF
		
		store 0 to m.ncompress, m.nGather  &&  Clear some floating memvars that cause reporting issues - BH 10/30/06
		
		SELECT invtotal
		GO TOP
		SCAN
		   m.cDefType = 'M'
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      lnCount = lnCount + 1
		   ENDIF
		   SCATTER MEMVAR
		
		   SELECT investor
		   SET ORDER TO cOwnerID
		   SEEK m.cOwnerID
		   m.lHold     = lHold
		   m.lIntegGL  = lIntegGL
		   m.nDisbFreq = nDisbFreq
		
		
		   *  If the owner is on hold, don't process previous minimums
		   *  If the owner is to posted, don't process previous minimums
		   IF m.lHold OR lIntegGL
		      LOOP
		   ENDIF
		
		   IF investor.ninvmin = 0
		      jnMinCheck = lnMinCheck
		   ELSE
		      jnMinCheck = investor.ninvmin
		   ENDIF
		
		   * All minimums are to be released   
		   if llRelMin
		      jnMinCheck = 0
		   endif   
		
		   *  Check for disbursement frequencies other than monthly.
		   DO CASE
		      CASE m.nDisbFreq = 2          && Quarterly
		         IF NOT INLIST(lcAcctPrd,'03','06','09','12')
		            jnMinCheck = 99999999
		            m.cDefType = 'Q'
		         ELSE
		            m.cDefType = 'Q'
		            m.cComment = 'Quarterly Pmt Released'
		            jnMinCheck = 0
		         ENDIF
		      CASE m.nDisbFreq = 3          && SemiAnnually
		         IF NOT INLIST(lcAcctPrd,'06','12')
		            jnMinCheck = 99999999
		            m.cDefType = 'S'
		         ELSE
		            m.cDefType = 'S'
		            m.cComment = 'Semi-Annual Pmt Released'
		            jnMinCheck = 0
		         ENDIF
		      CASE m.nDisbFreq = 4          && Annually
		         IF lcAcctPrd <> '12'
		            jnMinCheck = 99999999
		            m.cDefType = 'A'
		         ELSE
		            m.cDefType = 'A'
		            m.cComment = 'Annual Pmt Released'
		            jnMinCheck = 0
		         ENDIF
		   ENDCASE
		
		   IF USED('suspbalown')
		      SELECT suspbalown
		      SCAN FOR cOwnerID == m.cOwnerID AND nNetOwn > 0 AND (m.nTotalck + nNetOwn) >= jnMinCheck
		         m.nNetOwn = nNetOwn
		         SELECT cursuspown
		         LOCATE FOR cOwnerID = m.cOwnerID
		         IF FOUND() AND nTotalck + m.nTotalck + m.nNetOwn < jnMinCheck
		            LOOP
		         ENDIF
		         SELECT suspbalwell
		         SCAN FOR cOwnerID = m.cOwnerID
		            m.nAmount   = nNetWell
		            m.nIncome   = nNewInc
		            m.nsevtaxes = nNewTax
		            m.nTaxes    = nNewTax
		            m.nExpenses = nNewExp
		            m.nExpense  = nNewExp
		            m.cWellID   = cWellID
		            m.cPeriod   = lcPeriod
		            m.cYear     = lcYear
		            m.cGroup    = THIS.cGroup
		            m.nRunNo    = lnRunNo
		            m.cWellID   = cWellID
		            SELE wellinv
		            LOCATE FOR cWellID == m.cWellID AND cOwnerID == m.cOwnerID
		            IF FOUND()
		               m.cProgCode = cProgCode
		               lcTypeInv   = cTypeInv
		               * Don't release suspense if this interest is still on hold - pws 6/30/05
		               if lonhold = .t.
		                  loop
		               endif   
		            ELSE
		               m.cProgCode = ''
		               lcTypeInv   = 'W'
		            ENDIF
		
		            * Get the owner type if we don't have it yet.            
		            IF TYPE('m.cTypeInv') <> 'C' OR NOT INLIST(m.ctypeinv,'L','O','W')
		               m.cTypeInv = lcTypeInv
		            ENDIF
		               
		            m.cAcctYr   = lcAcctYr
		            m.cAcctPrd  = lcAcctPrd
		
		            IF tlClose
		               * If this is a close process, take the minimum out of the suspense table.
		               m.cAction   = 'O'
		               m.cSuspType = m.cDefType
		               m.cComment  = 'Prior Minimum Released'
		               IF INLIST(m.cDefType,'Q','A','S')
		*                  m.cProgCode = ''
		               ENDIF
		               IF m.nAmount <> 0
		                  m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                  SELECT susaudit
		                  SET DELETED OFF
		                  SET ORDER TO cidsusa
		                  DO WHILE INDEXSEEK(m.cidsusa)
		                     m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                  ENDDO
		                  INSERT INTO susaudit FROM MEMVAR
		                  SET DELETED ON
		               ENDIF
		            ENDIF
		
		            m.nworkint   = 0
		            m.ctypeint   = 'B'
		            m.nNetCheck  = m.nAmount
		            m.hperiod    = lcPeriod
		            m.hyear      = lcYear
		            m.nRunNo     = lnRunNo
		            m.lUsed      = .F.
		            m.lProgram   = .F.
		            m.cRecType   = 'R'
		            STORE 0 TO m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		               m.nIncome, m.nExpense, m.nSevTaxes, m.nTotale1, m.nTotale2, m.nTotale3, ;
		               m.nTotale4, m.nTotale5
		            m.ctypeinv = 'M'
		            INSERT INTO invtmp FROM MEMVAR
		         ENDSCAN  && suspbalwell
		      ENDSCAN  && susbalown
		   ENDIF
		
		   IF USED('suspbalownp')
		      SELECT suspprog
		      SCAN FOR cOwnerID == m.cOwnerID AND nNetOwn > 0
		         SELE suspbalownp
		         SCAN FOR cOwnerID == m.cOwnerID AND (m.nTotalck + nNetOwn) >= jnMinCheck
		            m.nNetOwn = nNetOwn
		            m.cProgCode = cProgCode
		            SELECT cursuspprog
		            LOCATE FOR cOwnerID == m.cOwnerID
		            IF FOUND() AND nTotalck + m.nTotalck + m.nNetOwn < jnMinCheck AND cProgCode <> m.cProgCode
		               LOOP
		            ENDIF
		            SELECT suspbalwellP
		            SCAN FOR cOwnerID == m.cOwnerID AND cProgCode == m.cProgCode AND nNewNet <> 0
		               m.nAmount  = nNewNet
		               m.nIncome   = nNewInc
		               m.nTaxes    = nNewTax
		               m.nExpenses = nNewExp
		               m.cWellID   = cWellID
		
		               * Get the owner type if we don't have it yet.
		               IF TYPE('m.cTypeInv') <> 'C' OR NOT INLIST(m.ctypeinv,'L','O','W')
		                  SELE wellinv
		                  LOCATE FOR cOwnerID == m.cOwnerID AND cWellID == m.cWellID
		                  IF FOUND()
		                     m.ctypeinv = ctypeinv
		                  ELSE
		                     m.ctypeinv = 'W'
		                  ENDIF
		               ENDIF
		
		               m.cPeriod  = lcPeriod
		               m.cYear    = lcYear
		               m.cGroup   = THIS.cGroup
		               m.nRunNo   = lnRunNo
		               m.cComment = 'Minimum Released'
		               m.cAcctYr  = lcAcctYr
		               m.cAcctPrd = lcAcctPrd
		
		               IF tlClose
		                  *  If this is a close process, take the minimum out of the suspense table.
		                  m.cAction = 'O'
		                  m.cSuspType = m.cDefType
		                  IF m.nAmount <> 0
		                     m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                     SELECT susaudit
		                     SET DELETED OFF
		                     SET ORDER TO cidsusa
		                     DO WHILE INDEXSEEK(m.cidsusa)
		                        m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                     ENDDO
		                     INSERT INTO susaudit FROM MEMVAR
		                     SET DELETED ON
		                  ENDIF
		               ENDIF
		
		               m.nworkint    = 0
		               m.ctypeint    = 'B'
		               m.nNetCheck   = m.nAmount
		               m.hperiod     = m.cPeriod
		               m.hyear       = m.cYear
		               m.nRunNo      = lnRunNo
		               m.lUsed       = .F.
		               m.lProgram    = .F.
		               m.cRecType    = 'R'
		               STORE 0 TO m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		                  m.nIncome, m.nExpense, m.nSevTaxes, m.nTotale1, m.nTotale2, m.nTotale3, ;
		                  m.nTotale4, m.nTotale5
		               m.ctypeinv = 'M'
		               INSERT INTO invtmp FROM MEMVAR
		            ENDSCAN
		         ENDSCAN  && suspbalwellp
		      ENDSCAN  && susbalownp
		   ENDIF
		   SELECT invtotal
		ENDSCAN   && invtotal
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   RELE oProgress
		ENDIF
		
		*
		****************************************************************
		*  Setup progress parms for suspense processing
		****************************************************************
		*
		THIS.owntotal()
		
		SELECT invtotal
		jCount = RECC()
		*IF jCount > 0
		SELECT invtotal
		lnMax = jCount * 3
		lnCount = 0
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBar('Processing suspense records by owner...')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		*
		***********************************************************************
		*   Check for wells in deficit this period...move to temp suspense
		***********************************************************************
		*
		
		SELECT invtotal
		GO TOP
		SCAN FOR nTotalck < 0
		   SCATTER MEMVAR
		   lnCount = lnCount + 1
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		   ENDIF
		
		   SELECT owngl
		   LOCATE FOR cOwnerID = m.cOwnerID
		   IF FOUND()
		      LOOP
		   ENDIF
		   SELECT invtmp
		   SET ORDER TO 0
		   SCAN FOR cOwnerID = m.cOwnerID AND nNetCheck < 0 AND ctypeinv <> 'M' AND ctypeinv <> 'X'
		      SCATTER MEMVAR
		      * If this is a program interest and the program is not netted
		      * outside itself, skip it.  It will be processed later.
		      IF NOT EMPTY(ALLT(m.cProgCode)) AND NOT m.lProgNet
		         LOOP
		      ENDIF
		      m.lUsed = .F.
		      INSERT INTO invsusp FROM MEMVAR
		      SELE invtmp
		      DELETE NEXT 1        && Delete Current Record From invtmp
		   ENDSCAN
		ENDSCAN
		
		*
		***********************************************************************
		*   Bring suspense amounts back in if covered by other wells
		***********************************************************************
		*
		THIS.owntotal()
		
		SELECT invtotal
		GO TOP
		SCAN FOR nTotalck > 0
		   SCATTER MEMVAR
		
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      lnCount = lnCount + 1
		   ENDIF
		
		   SELECT owngl
		   LOCATE FOR cOwnerID = m.cOwnerID
		   IF FOUND()
		      LOOP
		   ENDIF
		
		   SELECT invsusp
		   SET ORDER TO 0
		   SCAN FOR cOwnerID = m.cOwnerID
		      SCATTER MEMVAR
		
		      *  If the interest is on hold, don't process here.
		      sele wellinv
		      locate for cwellid == m.cwellid and cownerid == m.cownerid and ctypeinv == m.ctypeinv
		      if lonhold
		         loop
		      endif
		         
		      IF lOnHold
		         * If the interest is on hold, loop through it
		         LOOP
		      ENDIF
		
		      * If this is a program interest and the program is not netted
		      * outside itself, skip it.  It will be processed later.
		      IF NOT EMPTY(m.cProgCode) AND NOT m.lProgNet
		         LOOP
		      ENDIF
		
		      * If the deficit well can be covered by income this period
		      * bring it back in.  Only as much as can be covered will be
		      * brought in.
		      IF (m.nNetCheck+m.nTotalck) > 0
		         m.lUsed = .T.
		         m.cRecType = 'R'
		         INSERT INTO invtmp FROM MEMVAR
		         m.nTotalck = m.nTotalck + m.nNetCheck
		         SELECT invsusp
		         DELETE NEXT 1
		      ELSE
		         * Save original values
		         lnIncome     = m.nIncome
		         lnOilRev     = m.nOilRev
		         lnGasRev     = m.nGasRev
		         lnTaxes      = m.nSevTaxes
		         lnExpense    = m.nExpense
		         lnCompress   = m.nCompress
		         lnGather     = m.nGather
		         lnMktgExp    = m.nMktgExp
		         lnTotale1    = m.nTotale1
		         lnTotale2    = m.nTotale2
		         lnTotale3    = m.nTotale3
		         lnTotale4    = m.nTotale4
		         lnTotale5    = m.nTotale5
		         lnTotaleA    = m.nTotaleA
		         lnTotaleB    = m.nTotaleB
		         lnNetCheck   = m.nNetCheck
		         lnOilTax1    = m.nOilTax1
		         lnOilTax2    = m.nOilTax2
		         lnOilTax3    = m.nOilTax3
		         lnOilTax4    = m.nOilTax4
		         lnGasTax1    = m.nGasTax1
		         lnGasTax2    = m.nGasTax2
		         lnGasTax3    = m.nGasTax3
		         lnGasTax4    = m.nGasTax4
		         lnOthTax1    = m.nOthTax1
		         lnOthTax2    = m.nOthTax2
		         lnOthTax3    = m.nOthTax3
		         lnOthTax4    = m.nOthTax4
		
		         * Calculate pct total is of well
		         lnPct        = m.nTotalck / ABS(m.nNetCheck)
		
		         * Calculate totals of what can be covered
		         m.nNetCheck  = ROUND(lnPct * m.nNetCheck,2)
		         m.nIncome    = ROUND(lnPct * m.nIncome,2)
		         m.nOilRev    = ROUND(lnPct * m.nOilRev,2)
		         m.nGasRev    = ROUND(lnPct * m.nGasRev,2)
		         m.nSevTaxes  = ROUND(lnPct * m.nSevTaxes,2)
		         m.nCompress  = ROUND(lnPct * m.nCompress,2)
		         m.nGather    = ROUND(lnPct * m.nGather,2)
		         m.nMktgExp   = ROUND(lnPct * m.nMktgExp,2)
		         m.nExpense   = ROUND(lnPct * m.nExpense,2)
		         m.nTotale1   = ROUND(lnPct * m.nTotale1,2)
		         m.nTotale2   = ROUND(lnPct * m.nTotale2,2)
		         m.nTotale3   = ROUND(lnPct * m.nTotale3,2)
		         m.nTotale4   = ROUND(lnPct * m.nTotale4,2)
		         m.nTotale5   = ROUND(lnPct * m.nTotale5,2)
		         m.nTotaleA   = ROUND(lnPct * m.nTotaleA,2)
		         m.nTotaleB   = ROUND(lnPct * m.nTotaleB,2)
		         m.nOilTax1   = ROUND(lnPct * m.nOilTax1,2)
		         m.nOilTax2   = ROUND(lnPct * m.nOilTax2,2)
		         m.nOilTax3   = ROUND(lnPct * m.nOilTax3,2)
		         m.nOilTax4   = ROUND(lnPct * m.nOilTax4,2)
		         m.nGasTax1   = ROUND(lnPct * m.nGasTax1,2)
		         m.nGasTax2   = ROUND(lnPct * m.nGasTax2,2)
		         m.nGasTax3   = ROUND(lnPct * m.nGasTax3,2)
		         m.nGasTax4   = ROUND(lnPct * m.nGasTax4,2)
		         m.nOthTax1   = ROUND(lnPct * m.nOthTax1,2)
		         m.nOthTax2   = ROUND(lnPct * m.nOthTax2,2)
		         m.nOthTax3   = ROUND(lnPct * m.nOthTax3,2)
		         m.nOthTax4   = ROUND(lnPct * m.nOthTax4,2)
		         m.lUsed = .T.
		         m.cRecType = 'R'
		
		         *  Put the amount covered into the temporary owner history file
		         IF m.nNetCheck <> 0
		            INSERT INTO invtmp FROM MEMVAR
		         ENDIF
		
		         *  Calculate whats leftover
		         m.nIncome    = lnIncome - m.nIncome
		         m.nOilRev    = lnOilRev - m.nOilRev
		         m.nGasRev    = lnGasRev - m.nGasRev
		         m.nSevTaxes  = lnTaxes  - m.nSevTaxes
		         m.nCompress  = lnCompress - m.nCompress
		         m.nGather    = lnGather  - m.nGather
		         m.nMktgExp   = lnMktgExp - m.nMktgExp
		         m.nExpense   = lnExpense - m.nExpense
		         m.nTotale1   = lnTotale1 - m.nTotale1
		         m.nTotale2   = lnTotale2 - m.nTotale2
		         m.nTotale3   = lnTotale3 - m.nTotale3
		         m.nTotale4   = lnTotale4 - m.nTotale4
		         m.nTotale5   = lnTotale5 - m.nTotale5
		         m.nTotaleA   = lnTotaleA - m.nTotaleA
		         m.nTotaleB   = lnTotaleB - m.nTotaleB
		         m.nTotalck   = m.nTotalck + m.nNetCheck
		         m.nNetCheck  = lnNetCheck - m.nNetCheck
		         m.nOilTax1   = lnOilTax1 - m.nOilTax1
		         m.nOilTax2   = lnOilTax2 - m.nOilTax2
		         m.nOilTax3   = lnOilTax3 - m.nOilTax3
		         m.nOilTax4   = lnOilTax4 - m.nOilTax4
		         m.nGasTax1   = lnGasTax1 - m.nGasTax1
		         m.nGasTax2   = lnGasTax2 - m.nGasTax2
		         m.nGasTax3   = lnGasTax3 - m.nGasTax3
		         m.nGasTax4   = lnGasTax4 - m.nGasTax4
		         m.nOthTax1   = lnOthTax1 - m.nOthTax1
		         m.nOthTax2   = lnOthTax2 - m.nOthTax2
		         m.nOthTax3   = lnOthTax3 - m.nOthTax3
		         m.nOthTax4   = lnOthTax4 - m.nOthTax4
		
		         SELECT invsusp
		         REPLACE nNetCheck WITH m.nNetCheck, ;
		            nIncome   WITH m.nIncome, ;
		            nOilRev   WITH m.nOilRev, ;
		            nGasRev   WITH m.nGasRev, ;
		            nSevTaxes WITH m.nSevTaxes, ;
		            nCompress WITH m.nCompress, ;
		            nGather   WITH m.nGather, ;
		            nMktgExp  WITH m.nMktgExp, ;
		            nExpense  WITH m.nExpense, ;
		            nTotale1  WITH m.nTotale1, ;
		            nTotale2  WITH m.nTotale2, ;
		            nTotale3  WITH m.nTotale3, ;
		            nTotale4  WITH m.nTotale4, ;
		            nTotale5  WITH m.nTotale5, ;
		            nTotaleA  WITH m.nTotaleA, ;
		            nTotaleB  WITH m.nTotaleB, ;
		            nOilTax1  WITH m.nOilTax1, ;
		            nOilTax2  WITH m.nOilTax2, ;
		            nOilTax3  WITH m.nOilTax3, ;
		            nOilTax4  WITH m.nOilTax4, ;
		            nGasTax1  WITH m.nGasTax1, ;
		            nGasTax2  WITH m.nGasTax2, ;
		            nGasTax3  WITH m.nGasTax3, ;
		            nGasTax4  WITH m.nGasTax4, ;
		            nOthTax1  WITH m.nOthTax1, ;
		            nOthTax2  WITH m.nOthTax2, ;
		            nOthTax3  WITH m.nOthTax3, ;
		            nOthTax4  WITH m.nOthTax4
		      ENDIF
		   ENDSCAN  && invsusp
		ENDSCAN  && invtotal
		SELECT invsusp
		*
		***********************************************************************
		*   Mark negative amounts as used in invtmp
		***********************************************************************
		*
		*  If deficit records still exist in invtmp file at this point, assume
		*  that the deficits are covered by income from other wells and mark
		*  them as being used.
		*
		SELECT invtmp
		GO TOP
		SCAN
		   m.cProgCode = cProgCode
		   m.nNetCheck = nNetCheck
		   m.lProgNet = lProgNet
		   IF m.nNetCheck < 0
		      IF EMPTY(m.cProgCode) OR m.lProgNet
		         SELECT invtmp
		         REPLACE lUsed WITH .T.
		      ENDIF
		   ENDIF
		   SELECT invtmp
		ENDSCAN
		
		*
		***********************************************************************
		*   Bring in suspense amounts from previous periods
		***********************************************************************
		*
		SELECT suspbalown
		*  IF an owner has an outstanding deficit balance, process it here
		SCAN FOR nNetOwn < 0
		   m.cOwnerID = cOwnerID
		   SELECT suspbalwell
		   SCAN FOR cOwnerID = m.cOwnerID AND nNewNet <> 0
		      SCATTER MEMVAR
		      IF NOT THIS.lQuiet
		         oProgress.UpdateProgress(lnCount)
		         lnCount = lnCount + 1
		      ENDIF
		      SELECT invtmp
		      APPEND BLANK
		      REPLACE cOwnerID  WITH m.cOwnerID, ;
		         cWellID    WITH m.cWellID, ;
		         nworkint   WITH 0, ;
		         ctypeinv   WITH 'X', ;
		         cGroup     WITH THIS.cGroup, ;
		         ctypeint   WITH ' ', ;
		         nintclass1 WITH 0, ;
		         nintclass2 WITH 0, ;
		         nintclass3 WITH 0, ;
		         nintclass4 WITH 0, ;
		         nintclass5 WITH 0, ;
		         nTotale1   WITH 0, ;
		         nTotale2   WITH 0, ;
		         nTotale3   WITH 0, ;
		         nTotale4   WITH 0, ;
		         nTotale5   WITH 0, ;
		         nIncome    WITH m.nNewInc, ;
		         nExpense   WITH m.nNewExp, ;
		         nNetCheck  WITH m.nNewNet, ;
		         nSevTaxes  WITH m.nNewTax, ;
		         hperiod    WITH lcPeriod, ;
		         hyear      WITH lcYear, ;
		         cRunYear   WITH this.crunyear, ;
		         nRunNo     WITH lnRunNo, ;
		         hdate      WITH THIS.dAcctDate, ;
		         cRecType   WITH 'R', ;
		         lUsed      WITH .F.
		
		      IF tlClose
		         *  If this is a close process, add a susaudit record
		         *  to take the deficit out of suspense.
		         m.nIncome   = m.nNewInc
		         m.nExpenses = m.nNewExp
		         m.nTaxes    = m.nNewTax
		         m.nAmount   = m.nNewNet
		         m.cAction   = 'O'
		         m.cSuspType = 'D'
		         m.cTime     = TIME()
		         m.dSuspDate = DATE()
		         m.dAcctDate = THIS.dAcctDate
		         m.cGroup    = THIS.cGroup
		         m.cYear     = lcYear
		         m.cPeriod   = lcPeriod
		         m.nRunNo    = lnRunNo
		         m.cComment  = 'Prior Deficit Covered'
		         m.cAcctYr   = lcAcctYr
		         m.cAcctPrd  = lcAcctPrd
		         m.cidsusa   = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		         SELECT susaudit
		         SET DELETED OFF
		         SET ORDER TO cidsusa
		         DO WHILE INDEXSEEK(m.cidsusa)
		            m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		         ENDDO
		         INSERT INTO susaudit FROM MEMVAR
		         SET DELETED ON
		      ENDIF
		      SELECT suspbalwell
		      DELE NEXT 1
		   ENDSCAN   && suspbalwell
		ENDSCAN
		*
		*********************************************************************
		*   Total owner checks to see if suspense procedures needed
		*   this is for the wells that don't have any programs or the
		*   programs can be netted against other income. Totals after
		*   previous period deficit wells are brought back in.
		*********************************************************************
		*
		THIS.owntotal()
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   RELE oProgress
		ENDIF
		*ENDIF   && IF jCount > 0
		*
		***************************************************************************************
		*  Processing for programs that can only be netted with income from within the program.
		***************************************************************************************
		*
		*********************************************************************
		*   Total owner checks to see if suspense procedures needed
		*   this is for the wells that have programs that can only
		*   be netted against income within the program.
		*********************************************************************
		*
		
		SELECT invtmp.cOwnerID, invtmp.cProgCode, SUM(ROUND(nNetCheck,2)) AS nTotalck, cGroup  ;
		   FROM invtmp ;
		   WHERE NOT EMPTY(invtmp.cProgCode) ;
		   AND invtmp.lProgNet = .F. ;
		   AND invtmp.cProgCode IN (SELECT cProgCode FROM programs WHERE lProgNet = .F.) ;
		   INTO CURSOR invtotal ;
		   GROUP BY invtmp.cOwnerID, invtmp.cProgCode ;
		   ORDER BY invtmp.cOwnerID, invtmp.cProgCode
		
		lnCount = _TALLY
		
		SELECT invtotal
		jMax = lnCount
		lnMax = jMax * 3
		lnCount = 1
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBar('Processing suspense records by program...')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		*
		***********************************************************************
		*   Check for wells in deficit this period...move to temp suspense
		***********************************************************************
		*
		SELECT invtotal
		GO TOP
		SCAN FOR nTotalck < 0
		   SCATTER MEMVAR
		   lnCount = lnCount + 1
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		   ENDIF
		   SELECT owngl
		   LOCATE FOR cOwnerID = m.cOwnerID
		   IF FOUND()
		      LOOP
		   ENDIF
		   SELECT invtmp
		   SET ORDER TO 0
		   SCAN FOR cOwnerID = m.cOwnerID AND cProgCode = m.cProgCode
		      SCATTER MEMVAR
		      IF m.nNetCheck < 0
		         m.lUsed = .F.
		         INSERT INTO invsusp FROM MEMVAR
		         DELETE NEXT 1        && Delete Current Record From invtmp
		      ENDIF
		      SELECT invtmp
		   ENDSCAN
		   SELECT invtotal
		ENDSCAN
		
		*
		***********************************************************************
		*   Bring suspense amounts back in if covered by other wells
		***********************************************************************
		*
		SELECT invtmp.cOwnerID, invtmp.cProgCode, SUM(ROUND(nNetCheck,2)) AS nTotalck, cGroup  ;
		   FROM invtmp ;
		   WHERE NOT EMPTY(invtmp.cProgCode) ;
		   AND invtmp.lProgNet = .F. ;
		   INTO CURSOR invtotal ;
		   GROUP BY invtmp.cOwnerID, invtmp.cProgCode ;
		   ORDER BY invtmp.cOwnerID, invtmp.cProgCode
		
		SELECT invtotal
		GO TOP
		SCAN FOR nTotalck > 0
		   SCATTER MEMVAR
		   lnCount = lnCount + 1
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		   ENDIF
		   SELECT owngl
		   LOCATE FOR cOwnerID = m.cOwnerID
		   IF FOUND()
		      LOOP
		   ENDIF
		   SELECT invsusp
		   SCAN FOR cOwnerID = m.cOwnerID AND cProgCode = m.cProgCode
		      SCATTER MEMVAR
		      IF lOnHold
		         * If the interest is on hold, loop through it
		         LOOP
		      ENDIF
		      IF (m.nNetCheck+m.nTotalck) > 0
		         m.lUsed = .T.
		         m.cRecType = 'R'
		         INSERT INTO invtmp FROM MEMVAR
		         m.nTotalck = m.nTotalck + m.nNetCheck
		         SELECT invsusp
		         DELETE NEXT 1
		      ELSE
		         * Save original values
		         lnIncome     = m.nIncome
		         lnOilRev     = m.nOilRev
		         lnGasRev     = m.nGasRev
		         lnTaxes      = m.nSevTaxes
		         lnExpense    = m.nExpense
		         lnCompress   = m.nCompress
		         lnGather     = m.nGather
		         lnMktgExp    = m.nMktgExp
		         lnTotale1    = m.nTotale1
		         lnTotale2    = m.nTotale2
		         lnTotale3    = m.nTotale3
		         lnTotale4    = m.nTotale4
		         lnTotale5    = m.nTotale5
		         lnTotaleA    = m.nTotaleA
		         lnTotaleB    = m.nTotaleB
		         lnNetCheck   = m.nNetCheck
		         lnOilTax1    = m.nOilTax1
		         lnOilTax2    = m.nOilTax2
		         lnOilTax3    = m.nOilTax3
		         lnOilTax4    = m.nOilTax4
		         lnGasTax1    = m.nGasTax1
		         lnGasTax2    = m.nGasTax2
		         lnGasTax3    = m.nGasTax3
		         lnGasTax4    = m.nGasTax4
		         lnOthTax1    = m.nOthTax1
		         lnOthTax2    = m.nOthTax2
		         lnOthTax3    = m.nOthTax3
		         lnOthTax4    = m.nOthTax4
		
		         * Calculate pct total is of well
		         lnPct        = m.nTotalck / ABS(m.nNetCheck)
		
		         * Calculate totals of what can be covered
		         m.nNetCheck  = ROUND(lnPct * m.nNetCheck,2)
		         m.nIncome    = ROUND(lnPct * m.nIncome,2)
		         m.nOilRev    = ROUND(lnPct * m.nOilRev,2)
		         m.nGasRev    = ROUND(lnPct * m.nGasRev,2)
		         m.nSevTaxes  = ROUND(lnPct * m.nSevTaxes,2)
		         m.nCompress  = ROUND(lnPct * m.nCompress,2)
		         m.nGather    = ROUND(lnPct * m.nGather,2)
		         m.nMktgExp   = ROUND(lnPct * m.nMktgExp,2)
		         m.nExpense   = ROUND(lnPct * m.nExpense,2)
		         m.nTotale1   = ROUND(lnPct * m.nTotale1,2)
		         m.nTotale2   = ROUND(lnPct * m.nTotale2,2)
		         m.nTotale3   = ROUND(lnPct * m.nTotale3,2)
		         m.nTotale4   = ROUND(lnPct * m.nTotale4,2)
		         m.nTotale5   = ROUND(lnPct * m.nTotale5,2)
		         m.nTotaleA   = ROUND(lnPct * m.nTotaleA,2)
		         m.nTotaleB   = ROUND(lnPct * m.nTotaleB,2)
		         m.nOilTax1   = ROUND(lnPct * m.nOilTax1,2)
		         m.nOilTax2   = ROUND(lnPct * m.nOilTax2,2)
		         m.nOilTax3   = ROUND(lnPct * m.nOilTax3,2)
		         m.nOilTax4   = ROUND(lnPct * m.nOilTax4,2)
		         m.nGasTax1   = ROUND(lnPct * m.nGasTax1,2)
		         m.nGasTax2   = ROUND(lnPct * m.nGasTax2,2)
		         m.nGasTax3   = ROUND(lnPct * m.nGasTax3,2)
		         m.nGasTax4   = ROUND(lnPct * m.nGasTax4,2)
		         m.nOthTax1   = ROUND(lnPct * m.nOthTax1,2)
		         m.nOthTax2   = ROUND(lnPct * m.nOthTax2,2)
		         m.nOthTax3   = ROUND(lnPct * m.nOthTax3,2)
		         m.nOthTax4   = ROUND(lnPct * m.nOthTax4,2)
		         m.lUsed = .T.
		         m.cRecType = 'R'
		
		         *  Put the amount covered into the temporary owner history file
		         IF m.nNetCheck <> 0
		            INSERT INTO invtmp FROM MEMVAR
		         ENDIF
		
		         *  Calculate whats leftover
		         m.nIncome    = lnIncome - m.nIncome
		         m.nOilRev    = lnOilRev - m.nOilRev
		         m.nGasRev    = lnGasRev - m.nGasRev
		         m.nSevTaxes  = lnTaxes  - m.nSevTaxes
		         m.nCompress  = lnCompress - m.nCompress
		         m.nGather    = lnGather  - m.nGather
		         m.nMktgExp   = lnMktgExp - m.nMktgExp
		         m.nExpense   = lnExpense - m.nExpense
		         m.nTotale1   = lnTotale1 - m.nTotale1
		         m.nTotale2   = lnTotale2 - m.nTotale2
		         m.nTotale3   = lnTotale3 - m.nTotale3
		         m.nTotale4   = lnTotale4 - m.nTotale4
		         m.nTotale5   = lnTotale5 - m.nTotale5
		         m.nTotaleA   = lnTotaleA - m.nTotaleA
		         m.nTotaleB   = lnTotaleB - m.nTotaleB
		         m.nTotalck   = m.nTotalck + m.nNetCheck
		         m.nNetCheck  = lnNetCheck - m.nNetCheck
		         m.nOilTax1   = lnOilTax1 - m.nOilTax1
		         m.nOilTax2   = lnOilTax2 - m.nOilTax2
		         m.nOilTax3   = lnOilTax3 - m.nOilTax3
		         m.nOilTax4   = lnOilTax4 - m.nOilTax4
		         m.nGasTax1   = lnGasTax1 - m.nGasTax1
		         m.nGasTax2   = lnGasTax2 - m.nGasTax2
		         m.nGasTax3   = lnGasTax3 - m.nGasTax3
		         m.nGasTax4   = lnGasTax4 - m.nGasTax4
		         m.nOthTax1   = lnOthTax1 - m.nOthTax1
		         m.nOthTax2   = lnOthTax2 - m.nOthTax2
		         m.nOthTax3   = lnOthTax3 - m.nOthTax3
		         m.nOthTax4   = lnOthTax4 - m.nOthTax4
		         m.ntaxwith   = 0
		         m.nbackwith  = 0
		
		         SELECT invsusp
		         REPLACE nNetCheck WITH m.nNetCheck, ;
		            nIncome   WITH m.nIncome, ;
		            nOilRev   WITH m.nOilRev, ;
		            nGasRev   WITH m.nGasRev, ;
		            nSevTaxes WITH m.nSevTaxes, ;
		            nCompress WITH m.nCompress, ;
		            nGather   WITH m.nGather, ;
		            nExpense  WITH m.nExpense, ;
		            nMktgExp  WITH m.nMktgExp, ;
		            nTotale1  WITH m.nTotale1, ;
		            nTotale2  WITH m.nTotale2, ;
		            nTotale3  WITH m.nTotale3, ;
		            nTotale4  WITH m.nTotale4, ;
		            nTotale5  WITH m.nTotale5, ;
		            nTotaleA  WITH m.nTotaleA, ;
		            nTotaleB  WITH m.nTotaleB, ;
		            nOilTax1  WITH m.nOilTax1, ;
		            nOilTax2  WITH m.nOilTax2, ;
		            nOilTax3  WITH m.nOilTax3, ;
		            nOilTax4  WITH m.nOilTax4, ;
		            nGasTax1  WITH m.nGasTax1, ;
		            nGasTax2  WITH m.nGasTax2, ;
		            nGasTax3  WITH m.nGasTax3, ;
		            nGasTax4  WITH m.nGasTax4, ;
		            nOthTax1  WITH m.nOthTax1, ;
		            nOthTax2  WITH m.nOthTax2, ;
		            nOthTax3  WITH m.nOthTax3, ;
		            nOthTax4  WITH m.nOthTax4
		      ENDIF
		   ENDSCAN  && invsusp
		ENDSCAN  && invtotal
		
		*
		***********************************************************************
		*   Mark negative amounts as used in invtmp
		***********************************************************************
		*
		*  If deficit records still exist in invtmp file at this point, assume
		*  that the deficits are covered by income from other wells and mark
		*  them as being used.
		*
		SELECT invtmp
		GO TOP
		SCAN
		   m.cProgCode = cProgCode
		   m.nNetCheck = nNetCheck
		   m.lProgNet = lProgNet
		   IF m.nNetCheck < 0
		      IF NOT EMPTY(ALLT(m.cProgCode)) AND m.lProgNet = .F.
		         SELECT invtmp
		         REPLACE lUsed WITH .T.
		      ENDIF
		   ENDIF
		   SELECT invtmp
		ENDSCAN
		*
		***********************************************************************
		*   Bring in suspense amounts from previous periods (Programs)
		***********************************************************************
		*
		IF USED('suspbalownP')
		   SELECT suspbalownp
		   SCAN FOR nNetOwn <> 0
		      m.cOwnerID  = cOwnerID
		      m.cProgCode = cProgCode
		      SELE suspprog
		      LOCATE FOR cOwnerID = m.cOwnerID
		      IF FOUND() AND nNetOwn > 0
		         LOOP
		      ENDIF
		      SELECT suspbalwellP
		      SCAN FOR cOwnerID = m.cOwnerID AND nNewNet <> 0 AND cProgCode == m.cProgCode
		         SCATTER MEMVAR
		         if not this.lquiet
		            oProgress.UpdateProgress(lnCount)
		            lnCount = lnCount + 1
		         endif   
		         SELECT invtmp
		         APPEND BLANK
		         REPLACE cOwnerID  WITH m.cOwnerID, ;
		            cWellID    WITH m.cWellID, ;
		            cProgCode  WITH m.cProgCode, ;
		            nworkint   WITH 0, ;
		            ctypeinv   WITH 'X', ;
		            cGroup     WITH THIS.cGroup, ;
		            ctypeint   WITH ' ', ;
		            nintclass1 WITH 0, ;
		            nintclass2 WITH 0, ;
		            nintclass3 WITH 0, ;
		            nintclass4 WITH 0, ;
		            nintclass5 WITH 0, ;
		            nTotale1   WITH 0, ;
		            nTotale2   WITH 0, ;
		            nTotale3   WITH 0, ;
		            nTotale4   WITH 0, ;
		            nTotale5   WITH 0, ;
		            nIncome    WITH m.nNewInc, ;
		            nExpense   WITH m.nNewExp, ;
		            nNetCheck  WITH m.nNewNet, ;
		            nSevTaxes  WITH m.nNewTax, ;
		            hperiod    WITH lcPeriod, ;
		            hyear      WITH lcYear, ;
		            cRunYear   WITH THIS.cRunYear, ;
		            nRunNo     WITH lnRunNo, ;
		            hdate      WITH THIS.dAcctDate, ;
		            cRecType   WITH 'R', ;
		            lUsed      WITH .F.
		
		         IF tlClose
		            m.nIncome   = m.nNewInc
		            m.nExpenses = m.nNewExp
		            m.nTaxes    = m.nNewTax
		            m.nAmount   = m.nNewNet
		            m.cAction   = 'O'
		            m.cSuspType = 'D'
		            m.cTime     = TIME()
		            m.dSuspDate = DATE()
		            m.dAcctDate = THIS.dAcctDate
		            m.cGroup    = THIS.cGroup
		            m.cYear     = lcYear
		            m.cPeriod   = lcPeriod
		            m.nRunNo    = lnRunNo
		            m.cComment  = 'Prog Deficit Covered'
		            m.cAcctYr   = lcAcctYr
		            m.cAcctPrd  = lcAcctPrd
		
		            * Get the owner type if we don't have it yet.
		            IF TYPE('m.cTypeInv') <> 'C' OR NOT INLIST(m.ctypeinv,'L','O','W')
		               SELE wellinv
		               LOCATE FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		               IF FOUND()
		                  m.ctypeinv = ctypeinv
		               ELSE
		                  m.ctypeinv = 'W'
		               ENDIF
		            ENDIF
		
		            m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		            SELECT susaudit
		            SET DELETED OFF
		            SET ORDER TO cidsusa
		            DO WHILE INDEXSEEK(m.cidsusa)
		               m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		            ENDDO
		            INSERT INTO susaudit FROM MEMVAR
		            SET DELETED ON
		         ENDIF
		         SELECT suspbalwellP
		         DELE NEXT 1
		      ENDSCAN   && suspbalwell
		   ENDSCAN
		   IF NOT THIS.lQuiet
		      oProgress.CloseProgress()
		      RELE oProgress
		   ENDIF
		ENDIF   && IF USED('suspbalownP')
		
		
		*****************************************************************
		*  Check for interests on hold having been released
		*****************************************************************
		IF THIS.lRelMin
		   SELECT investor.cOwnerID, 000000.00 AS nTotalck, THIS.cGroup AS cGroup  ;
		      WHERE investor.lHold = .F. ;
		      FROM investor ;
		      INTO CURSOR invtotal ;
		      GROUP BY investor.cOwnerID ;
		      ORDER BY investor.cOwnerID
		ELSE
		   SELECT invtmp.cOwnerID, SUM(ROUND(nNetCheck,2)) AS nTotalck, cGroup  ;
		      FROM invtmp ;
		      INTO CURSOR invtotal ;
		      GROUP BY invtmp.cOwnerID ;
		      ORDER BY invtmp.cOwnerID
		ENDIF
		
		THIS.suspint()
		SELECT suspbal
		COUNT FOR NOT DELETED() TO lnMax
		lnCount = 1
		
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBar('Processing interests on hold...')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		SELE invtotal
		SCAN
		   SCATTER MEMVAR
		   SELECT suspbal
		   IF RECC() > 0
		      SCAN FOR nAmount <> 0 AND cOwnerID = m.cOwnerID
		         SCATTER MEMVAR
		         IF NOT THIS.lQuiet
		            oProgress.UpdateProgress(lnCount)
		            lnCount = lnCount + 1
		         ENDIF
		
		         SELECT invtmp
		         LOCATE FOR cOwnerID = m.cOwnerID ;
		            AND cWellID   = m.cWellID   ;
		            AND ctypeinv  = m.ctypeinv  ;
		            AND cGroup    = m.cGroup
		         IF FOUND() AND NOT invtmp.lOnHold
		            m.cPeriod   = lcPeriod
		            m.cYear     = lcYear
		            m.nRunNo    = lnRunNo
		            m.cAcctYr   = lcAcctYr
		            m.cAcctPrd  = lcAcctPrd
		
		            IF m.nTotalck + m.nAmount >= 0
		               * Check to see if the owner is still on hold
		               IF tlClose
		                  m.cGroup  = THIS.cGroup
		                  m.cAction = 'O'
		                  m.cSuspType = 'I'
		                  IF m.nAmount <> 0
		                     m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                     SELECT susaudit
		                     SET DELETED OFF
		                     SET ORDER TO cidsusa
		                     DO WHILE SEEK(m.cidsusa)
		                        m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                     ENDDO
		                     INSERT INTO susaudit FROM MEMVAR
		                     SET DELETED ON
		                  ENDIF
		               ENDIF
		
		               m.nNetCheck   = m.nAmount
		               m.hperiod     = m.cPeriod
		               m.hyear       = m.cYear
		               m.nRunNo      = lnRunNo
		               m.hdate       = THIS.dAcctDate
		               m.lUsed       = .F.
		               m.ctypeint    = 'B'
		               m.ctypeinv    = 'I'
		               m.cRecType    = 'R'
		               m.lOnHold     = .F.
		               STORE 0 TO m.nworkint, m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		                  m.nSevTaxes, m.nTotale1, m.nTotale2, m.nTotale3, m.nTotale4, m.nTotale5
		               INSERT INTO invtmp FROM MEMVAR
		               m.nTotalck = m.nTotalck + m.nAmount
		            ELSE
		
		               lnIncome  = m.nIncome
		               lnTaxes   = m.nTaxes
		               lnExpense = m.nExpenses
		               lnNetCheck = m.nAmount
		               lnPct     = m.nTotalck / ABS(m.nAmount)
		
		               * Calculate totals of what can be covered
		               m.nNetCheck  = ROUND(lnPct * m.nAmount,2)
		               m.nAmount    = m.nNetcheck
		               m.nIncome    = ROUND(lnPct * m.nIncome,2)
		               m.nSevTaxes  = ROUND(lnPct * m.nTaxes,2)
		               m.nExpense   = ROUND(lnPct * m.nExpenses,2)
		               m.lUsed = .T.
		               m.cRecType = 'R'
		
		               *  Put the amount covered into the temporary owner history file
		               IF m.nNetCheck <> 0
		                  STORE 0 TO m.nworkint, m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		                     m.nTotale1, m.nTotale2, m.nTotale3, m.nTotale4, m.nTotale5
		                  m.hperiod     = m.cPeriod
		                  m.hyear       = m.cYear
		                  m.nRunNo      = lnRunNo
		                  m.hdate       = THIS.dAcctDate
		                  m.lUsed       = .F.
		                  m.ctypeint    = 'B'
		                  m.ctypeinv    = 'I'
		                  m.cRecType    = 'R'
		                  m.lOnHold     = .F.
		                  INSERT INTO invtmp FROM MEMVAR
		               ENDIF
		
		*!*	               *  Calculate whats leftover
		*!*	               m.nIncome    = lnIncome - m.nIncome
		*!*	               m.nSevTaxes  = lnTaxes  - m.nSevTaxes
		*!*	               m.nExpense   = lnExpense - m.nExpenses
		*!*	               m.nTotalck   = m.nTotalck + m.nNetCheck
		*!*	               m.nNetCheck  = lnNetCheck - m.nNetCheck
		
		               IF tlClose
		                  m.cGroup  = THIS.cGroup
		                  m.cAction = 'O'
		                  m.cSuspType = 'I'
		                  IF m.nAmount <> 0
		                     m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                     SELECT susaudit
		                     SET DELETED OFF
		                     SET ORDER TO cidsusa
		                     DO WHILE SEEK(m.cidsusa)
		                        m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                     ENDDO
		                     INSERT INTO susaudit FROM MEMVAR
		                     SET DELETED ON
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDSCAN
		   ENDIF
		ENDSCAN
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   RELE oProgress
		ENDIF
		*
		*************************************************************************
		*  Total each check to see if check amount is below minimum
		*************************************************************************
		*
		SELECT invtmp.cOwnerID, SUM(ROUND(nNetCheck,2)) AS nTotalck, cGroup  ;
		   FROM invtmp ;
		   WHERE invtmp.lProgram = .F. ;
		   INTO CURSOR invtotal ;
		   GROUP BY invtmp.cOwnerID ;
		   ORDER BY invtmp.cOwnerID
		
		*
		************************************************************************
		*  IF total amount of check is less than minimum, add total to temp susp
		************************************************************************
		*
		SELECT invtotal
		COUNT FOR NOT DELETED() TO lnMax
		lnCount = 1
		
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBar('Processing minimum check amounts...')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		SELECT invtotal
		SCAN
		   SCATTER MEMVAR
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		   ENDIF
		
		   lnCount = lnCount + 1
		   m.ctypeinv = ' '
		   SELECT investor
		   SET ORDER TO cOwnerID
		   IF SEEK(m.cOwnerID)
		      * Don't save Dummy suspense records
		      IF investor.ldummy
		         LOOP
		      ENDIF
		
		      m.lHold     = lHold
		      m.lIntegGL  = lIntegGL
		      m.cDefType  = 'M'
		      m.lBackWith = lBackWith
		      m.lTaxWith  = lTaxWith
		      m.nDisbFreq = nDisbFreq
		      m.ninvmin   = ninvmin
		      m.cOwnName  = cOwnName
		   ELSE
		      LOOP
		   ENDIF
		
		   *
		   *  Don't suspense operator owner amounts that should be posted to income.
		   *
		   IF m.lIntegGL
		      LOOP
		   ENDIF
		
		   IF m.ninvmin = 0
		      jnMinCheck = lnMinCheck
		   ELSE
		      jnMinCheck = m.ninvmin
		   ENDIF
		
		   DO CASE
		      CASE m.lHold
		         jnMinCheck = 99999999
		         m.cDefType = 'H'
		         *         m.cProgCode = ''
		      CASE llRelMin
		         jnMinCheck = 0
		      CASE m.nDisbFreq = 2          && Quarterly
		         IF NOT INLIST(lcAcctPrd,'03','06','09','12')
		            jnMinCheck = 99999999
		            m.cDefType  = 'Q'
		         ELSE
		            m.cDefType  = 'Q'
		         ENDIF
		*         m.cProgCode = ''
		      CASE m.nDisbFreq = 3          && SemiAnnually
		         IF NOT INLIST(lcAcctPrd,'06','12')
		            jnMinCheck = 99999999
		            m.cDefType  = 'S'
		         ELSE
		            m.cDefType  = 'S'
		         ENDIF
		*         m.cProgCode = ''
		      CASE m.nDisbFreq = 4          && Annually
		         IF lcAcctPrd <> '12'
		            jnMinCheck = 99999999
		            m.cDefType  = 'A'
		         ELSE
		            m.cDefType  = 'A'
		         ENDIF
		*         m.cProgCode = ''
		   ENDCASE
		
		   SELECT invtotal
		   IF (m.nTotalck > 0 AND m.nTotalck < jnMinCheck)
		
		      IF tlClose                  && Mark Suspense Record
		         m.cYear     = lcYear
		         m.cPeriod   = lcPeriod
		         m.cGroup    = THIS.cGroup
		         m.nRunNo    = lnRunNo
		         m.cAction   = 'I'
		         m.cSuspType = m.cDefType
		         m.nAmount   = m.nTotalck
		         IF m.nAmount <> 0
		            SELECT invtmp
		            SCAN FOR cOwnerID = m.cOwnerID AND nNetCheck <> 0
		               m.cWellID   = cWellID
		               m.nIncome   = nIncome
		               m.ctypeinv  = ctypeinv
		               IF cDirect = 'O'
		                  m.nIncome   = nIncome - nOilRev
		               ENDIF
		               IF cDirect = 'G'
		                  m.nIncome   = nIncome - nGasRev
		               ENDIF
		               IF cDirect = 'B'
		                  m.nIncome   = nIncome - nOilRev - nGasRev
		               ENDIF
		               m.nExpenses = nExpense + nTotale1 + nTotale2 + nTotale3 + nTotale4 + nTotale5 +nTotaleA + nTotaleB + nCompress + nGather
		               m.nTaxes    = invtmp.nSevTaxes + invtmp.ntaxwith
		               m.nNetCheck = invtmp.nNetCheck
		               m.nAmount   = invtmp.nNetCheck
		               m.cidsusa   = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               m.cYear     = lcYear
		               m.cPeriod   = lcPeriod
		               m.nRunNo    = lnRunNo
		               m.cAcctYr   = lcAcctYr
		               m.cAcctPrd  = lcAcctPrd
		               IF INLIST(m.cDefType,'Q','A','S')
		*                  m.cProgCode = ''
		                  m.cProgCode = invtmp.cProgCode
		               ELSE
		                  m.cProgCode = invtmp.cProgCode
		               ENDIF
		               SELECT susaudit
		               SET DELETED OFF
		               SET ORDER TO cidsusa
		               DO WHILE INDEXSEEK(m.cidsusa)
		                  m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               ENDDO
		               INSERT INTO susaudit FROM MEMVAR
		               SET DELETED ON
		            ENDSCAN
		
		            SELECT invtotal
		         ENDIF
		      ENDIF
		   ENDIF
		ENDSCAN
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   DOEVENTS
		   RELE oProgress
		ENDIF
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Processing Suspense by Owner...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending susp_by_owner')  
		endif   
		
		
	ENDPROC

	PROCEDURE susp_by_well		&& Suspense Processing By Well
		LOCAL lnCount, lnMax, m.cDefType, m.lBackWith, m.lTaxWith, lnMinCheck, llRelMin, tlClose
		LOCAL lcBatch, lcWellUsed, llCovered, oProgress, m.cRunYear, lcPeriod, lcYear
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting susp_by_well')  
		endif   
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Processing Suspense by Well...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		tlClose = THIS.lClose
		m.cBatch = THIS.cDMBatch
		
		m.cAcctYr  = THIS.cacctyear
		m.cAcctPrd = THIS.cAcctPrd
		m.cRunYear = THIS.cRunYear
		
		SELECT options
		lnMinCheck = nMinCheck
		lcMinAcct  = cMinAcct
		lcDefAcct  = cDefAcct
		
		SELECT glopt
		lcRevClear = cRevClear
		lcExpClear = cExpClear
		
		*  Set up added information
		m.dAdded    = DATETIME()
		m.cUserAdd  = 'SYSTEM'
		
		llRelMin = THIS.lRelMin
		
		THIS.calcsuspbalance('W')
		THIS.calcsuspense('W')
		
		m.cGroup = THIS.cGroup
		m.cDefType = 'D'
		m.lBackWith = .F.
		m.lTaxWith  = .F.
		
		SELE MAX(hperiod) AS cperiod, MAX(hyear) AS cyear FROM invtmp INTO CURSOR temp
		IF _TALLY > 0
		   lcPeriod = cperiod
		   lcYear   = cyear
		ELSE
		   lcPeriod = THIS.cperiod
		   lcYear   = THIS.cyear
		ENDIF
		WAIT CLEAR
		
		*
		*  Get the list of owners that are to be posted to G/L
		*
		SELECT cOwnerID FROM investor WHERE lIntegGL = .T. INTO CURSOR owngl
		
		*
		*  Calculate the total check amounts
		*
		SELECT cOwnerID, SUM(ROUND(nNetCheck,2)) AS nTotalCk, cGroup  ;
		   FROM invtmp ;
		   INTO CURSOR invtotal ;
		   GROUP BY cOwnerID ;
		   ORDER BY cOwnerID
		*
		****************************************************************
		*   Create temp suspense file
		****************************************************************
		*
		SWSELECT('disbhist')
		lnx=AFIELDS(latempx)
		SWSELECT('ownpcts')
		lny=AFIELDS(latempy)
		DIMENSION laTemp[lnx+lny-1,18]
		FOR x = 1 TO lnx
		   FOR y = 1 TO 18
		      laTemp[x,y] = laTempx[x,y]
		   ENDFOR
		ENDFOR 
		FOR x = 1 TO lny - 1
		   FOR y = 1 TO 18
		      laTemp[x+lnx,y] = laTempy[x+1,y]
		   ENDFOR
		ENDFOR    
		FOR x = 1 TO lnx+lny - 1
		   latemp[X,7] = ''
		   latemp[X,8] = ''
		   latemp[X,9] = ''
		   latemp[X,10] = ''
		   latemp[X,11] = ''
		   latemp[X,12] = ''
		   latemp[X,13] = ''
		   latemp[X,14] = ''
		   latemp[X,15] = ''
		   latemp[X,18] = ''
		ENDFOR
		
		SET SAFETY OFF
		CREATE CURSOR invsusp FROM ARRAY latemp
		SELECT invsusp
		INDEX ON cWellID+cOwnerID TAG wellinv
		INDEX ON cOwnerID+cWellID TAG invwell
		INDEX ON cOwnerID TAG cOwnerID
		INDEX ON cWellID TAG cWellID
		
		SELECT invtmp
		GO TOP
		m.hdate = hdate
		
		*
		*  Get the accounting month
		*
		lcAcctPrd = PADL(ALLTRIM(STR(MONTH(m.hdate),2)),2,'0')
		*
		******************************************************************
		*  Remove interests on hold
		******************************************************************
		*
		SELECT * FROM invtmp INTO CURSOR invhold WHERE lOnHold ORDER BY cOwnerID, cWellID
		
		IF _TALLY > 0
		   SELECT invhold
		   SCAN
		      SCATTER MEMVAR
		      INSERT INTO invsusp FROM MEMVAR
		      IF tlClose
		         m.cyear     = lcYear
		         m.cperiod   = lcPeriod
		         m.cGroup    = THIS.cGroup
		         m.nRunNo    = THIS.nRunNo
		         m.cAction   = 'I'
		         m.cSuspType = 'I'
		         m.nAmount   = m.nNetCheck
		         m.nIncome   = nIncome
		         m.nExpenses = nExpense + nTotale1 + nTotale2 + nTotale3 + nTotale4 + nTotale5 +nTotaleA + nTotaleB+nGather+nCompress
		         m.nTaxes    = nSevtaxes
		         m.cComment = 'Interest On Hold'
		         IF m.nAmount <> 0
		            m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		            SELECT susaudit
		            SET DELETED OFF
		            SET ORDER TO cidsusa
		            DO WHILE SEEK(m.cidsusa)
		               m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		            ENDDO
		            INSERT INTO susaudit FROM MEMVAR
		            SET DELETED ON
		
		         ENDIF
		      ENDIF
		      SELECT invtmp
		      SET ORDER TO invtype
		      IF SEEK(m.cOwnerID+m.cWellID+m.ctypeinv+m.ctypeint+m.cprogcode)
		         DELETE NEXT 1
		      ENDIF
		   ENDSCAN
		ENDIF
		
		*
		****************************************************************************
		*  Setup counters for thermo
		****************************************************************************
		
		SELECT invtmp
		COUNT FOR NOT DELETED() TO jmax
		lnMax = jmax
		SELECT invtotal
		COUNT TO jmax
		lnMax = lnMax + (jmax*2)
		SELECT suspbalwell
		COUNT FOR NOT DELETED() TO jmax
		lnMax = lnMax + jmax
		lnCount = 1
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBarEx('Processing suspense records by well...',' ')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		*
		***********************************************************************
		*   Check for wells in deficit this run...remove them
		***********************************************************************
		SELE cOwnerID, cWellID, SUM(nNetCheck) AS nNetCheck ;
		   FROM invtmp ;
		   INTO CURSOR ownhisttmp ;
		   ORDER BY cOwnerID, cWellID ;
		   GROUP BY cOwnerID, cWellID
		
		if used('invtmp1')
		   use in invtmp1
		endif
		use dbf('invtmp') again in 0 alias invtmp1
		   
		SELECT ownhisttmp
		SET ORDER TO 0
		SCAN FOR nNetCheck < 0
		   SCATTER MEMVAR
		
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      oProgress.SetProgressMessage('Removing Deficit Wells')
		      lnCount = lnCount + 1
		   ENDIF
		   SELECT owngl
		   LOCATE FOR cOwnerID = m.cOwnerID
		   IF FOUND()
		      LOOP
		   ENDIF
		   SELE invtmp1
		   SCAN FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		      SCATTER MEMVAR
		      m.lused  = .F.
		      m.nRunNo  = THIS.nRunNo
		      INSERT INTO invsusp FROM MEMVAR
		      SELECT invtmp1
		      DELETE NEXT 1        && Delete Current Record From invtmp
		   ENDSCAN
		ENDSCAN
		
		*  Set the used flag so owner statements can accurately report
		SELE invtmp
		SCAN FOR nNetCheck < 0
		   REPL lused WITH .T.
		ENDSCAN
		
		*
		***********************************************************************
		*   Total check after deficit wells removed.
		***********************************************************************
		*
		SELECT cOwnerID, SUM(nNetCheck) AS nTotalCk, cGroup  ;
		   FROM invtmp ;
		   INTO CURSOR invtotal ;
		   GROUP BY cOwnerID ;
		   ORDER BY cOwnerID
		
		*
		************************************************************************
		*  Add in well deficits from previous periods if income will cover them.
		************************************************************************
		*
		SELECT suspbalwell
		SCAN FOR nNewNet < 0
		   SCATTER MEMVAR
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      lnCount = lnCount + 1
		      oProgress.SetProgressMessage('Covering Prior Period Deficit Wells')
		   ENDIF
		   SELECT invtmp
		   APPEND BLANK
		   REPLACE cOwnerID  WITH m.cOwnerID, ;
		      cWellID    WITH m.cWellID, ;
		      nworkint   WITH 0, ;
		      ctypeinv   WITH 'X', ;
		      cGroup     WITH THIS.cGroup, ;
		      ctypeint   WITH ' ', ;
		      nintclass1 WITH 0, ;
		      nintclass2 WITH 0, ;
		      nintclass3 WITH 0, ;
		      nintclass4 WITH 0, ;
		      nintclass5 WITH 0, ;
		      nTotale1   WITH 0, ;
		      nTotale2   WITH 0, ;
		      nTotale3   WITH 0, ;
		      nTotale4   WITH 0, ;
		      nTotale5   WITH 0, ;
		      nIncome    WITH m.nNewInc, ;
		      nExpense   WITH m.nNewExp, ;
		      nNetCheck  WITH m.nNewNet, ;
		      nSevtaxes  WITH m.nNewTax, ;
		      nGasRev    WITH 0, ;
		      nOilRev    WITH 0, ;
		      hperiod    WITH THIS.cperiod, ;
		      hyear      WITH THIS.cRunYear, ;
		      nRunNo     WITH THIS.nRunNo, ;
		      hdate      WITH THIS.dAcctDate, ;
		      cRecType   WITH 'R', ;
		      lused      WITH .F.
		
		   IF tlClose
		      IF TYPE('m.cTypeInv') <> 'C' OR NOT INLIST(m.ctypeinv,'L','O','W')
		         SELE wellinv
		         LOCATE FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		         IF FOUND()
		            m.ctypeinv = ctypeinv
		         ELSE
		            m.ctypeinv = 'W'
		         ENDIF
		      ENDIF
		
		      m.nIncome   = m.nNewInc
		      m.nExpenses = m.nNewExp
		      m.nTaxes    = m.nNewTax
		      m.nAmount   = m.nNewNet
		      m.cAction   = 'O'
		      m.cSuspType = 'D'
		      m.cTime     = TIME()
		      m.dSuspDate = DATE()
		      m.dAcctDate = THIS.dAcctDate
		      m.cGroup    = THIS.cGroup
		      m.cyear     = lcYear
		      m.cperiod   = lcPeriod
		      m.nRunNo    = THIS.nRunNo
		      m.cComment  = 'Prior Deficit Covered'
		      m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		      SELECT susaudit
		      SET DELETED OFF
		      SET ORDER TO cidsusa
		      DO WHILE SEEK(m.cidsusa)
		         m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		      ENDDO
		      INSERT INTO susaudit FROM MEMVAR
		      SET DELETED ON
		   ENDIF
		ENDSCAN   && suspbalwell
		
		*
		*********************************************************************
		*   Total after deficit amounts added from previous period
		*********************************************************************
		*
		IF THIS.lRelMin
		   SELECT investor.cOwnerID, 000000.00 AS nTotalCk, THIS.cGroup AS cGroup  ;
		      WHERE investor.lhold = .F. ;
		      FROM investor ;
		      INTO CURSOR invtotal ;
		      GROUP BY investor.cOwnerID ;
		      ORDER BY investor.cOwnerID
		ELSE
		   SELECT invtmp.cOwnerID, SUM(ROUND(nNetCheck,2)) AS nTotalCk, cGroup  ;
		      FROM invtmp ;
		      INTO CURSOR invtotal ;
		      GROUP BY invtmp.cOwnerID ;
		      ORDER BY invtmp.cOwnerID
		ENDIF
		*
		***********************************************************************
		*   Bring in minimum suspense amounts from previous periods
		***********************************************************************
		*
		SELECT cOwnerID, SUM(nNewInc) AS nIncome, SUM(nNewTax) AS nTaxes, SUM(nNewExp) AS nExpenses, SUM(nNewNet) AS nNetWell ;
		   FROM suspbalwell ;
		   INTO CURSOR suspown ;
		   ORDER BY cOwnerID ;
		   GROUP BY cOwnerID
		
		SELECT invtotal
		SCAN
		   SCATTER MEMVAR
		   lnCount = lnCount + 1
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      oProgress.SetProgressMessage('Bringing In Minimum Amounts From Prior Periods')
		   ENDIF
		   SELECT investor
		   SET ORDER TO cOwnerID
		   IF SEEK(m.cOwnerID)
		      IF lIntegGL OR lhold
		         LOOP
		      ENDIF
		      m.nDisbFreq = nDisbFreq
		      IF ninvmin = 0
		         jnMinCheck = lnMinCheck
		      ELSE
		         jnMinCheck = ninvmin
		      ENDIF
		   ELSE
		      LOOP
		   ENDIF
		   
		   DO CASE
		      CASE m.nDisbFreq = 2          && Quarterly
		         IF NOT INLIST(lcAcctPrd,'03','06','09','12')
		            jnMinCheck = 99999999
		         ENDIF
		      CASE m.nDisbFreq = 3          && SemiAnnually
		         IF NOT INLIST(lcAcctPrd,'06','12')
		            jnMinCheck = 99999999
		         ENDIF
		      CASE m.nDisbFreq = 4          && Annually
		         IF lcAcctPrd <> '12'
		            jnMinCheck = 99999999
		         ENDIF
		   ENDCASE
		   *
		   *  If the minimum amounts should be released, set the minimum amount to zero.
		   *
		   IF llRelMin
		      jnMinCheck = 0
		   ENDIF
		   SELE suspown
		   SCAN FOR cOwnerID = m.cOwnerID AND nNetWell > 0 AND (m.nTotalCk + nNetWell) >= jnMinCheck
		      SELECT suspbalwell
		      SCAN FOR cOwnerID = m.cOwnerID AND nNetWell <> 0
		         m.nIncome   = nNewInc
		         m.nExpense  = nNewExp
		         m.nExpenses = nNewExp
		         m.nSevtaxes = nNewTax
		         m.nTaxes    = nNewTax
		         m.cOwnerID  = cOwnerID
		         m.nAmount   = nNewNet
		         m.cperiod   = lcPeriod
		         m.cyear     = lcYear
		         m.nRunNo    = THIS.nRunNo
		         m.cprogcode = cprogcode
		         m.cGroup    = cGroup
		         m.cWellID   = cWellID
		         m.cComment  = 'Prior Minimum Released'
		
		            SELE wellinv
		            LOCATE FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		            IF FOUND()
		               m.ctypeinv = ctypeinv
		            ELSE
		               m.ctypeinv = 'W'
		            ENDIF
		
		         IF tlClose
		            m.cSuspType = 'M'
		            m.cyear   = lcYear
		            m.cperiod = lcPeriod
		            m.cGroup  = THIS.cGroup
		            m.cAction = 'O'
		            IF m.nAmount <> 0
		               m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               SELECT susaudit
		               SET DELETED OFF
		               SET ORDER TO cidsusa
		               DO WHILE SEEK(m.cidsusa)
		                  m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               ENDDO
		               INSERT INTO susaudit FROM MEMVAR
		               SET DELETED ON
		            ENDIF
		         ENDIF
		
		         m.nNetCheck   = m.nAmount
		         m.hperiod     = THIS.cperiod
		         m.hyear       = THIS.cRunYear
		         m.hdate       = THIS.dAcctDate
		         m.lused       = .F.
		         m.ctypeint    = 'B'
		         m.ctypeinv    = 'M'
		         STORE 0 TO m.nworkint, m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		            m.nTotale1, m.nTotale2, m.nTotale3, m.nTotale4, m.nTotale5, m.nGasRev, m.nOilRev
		         INSERT INTO invtmp FROM MEMVAR
		      ENDSCAN
		   ENDSCAN
		   SELECT invtotal
		ENDSCAN
		
		*****************************************************************
		*  Check for interests on hold having been released
		*****************************************************************
		
		THIS.suspint()
		
		SELECT suspbal
		IF RECC() > 0
		   SCAN FOR nAmount > 0
		      SCATTER MEMVAR
		      lcTypeInv = m.ctypeinv
		      SELECT wellinv
		      LOCATE FOR cOwnerID = m.cOwnerID ;
		         AND cWellID   = m.cWellID   ;
		         AND ctypeinv  = m.ctypeinv  ;
		         AND cprogcode = m.cprogcode
		      IF FOUND()
		         IF lOnHold = .F.
		            m.cperiod   = lcPeriod
		            m.cyear     = lcYear
		            m.nRunNo    = THIS.nRunNo
		
		            IF tlClose
		               m.cSuspType = 'I'
		               m.cyear   = lcYear
		               m.cperiod = lcPeriod
		               m.cGroup  = THIS.cGroup
		               m.cAction = 'O'
		               m.cComment  = 'Int On Hold Rel'
		               IF m.nAmount <> 0
		                  m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                  SELECT susaudit
		                  SET DELETED OFF
		                  SET ORDER TO cidsusa
		                  DO WHILE SEEK(m.cidsusa)
		                     m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                  ENDDO
		                  INSERT INTO susaudit FROM MEMVAR
		                  SET DELETED ON
		               ENDIF
		            ENDIF
		            m.nNetCheck   = m.nAmount
		            m.hperiod    = THIS.cperiod
		            m.hyear      = THIS.cyear
		            m.hdate      = THIS.dAcctDate
		            m.lonhold    = .f.
		            m.lused       = .F.
		            m.ctypeinv   = 'I'
		            m.ctypeint    = 'B'
		            STORE 0 TO m.workint, m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		               m.nSevtaxes, m.nTotale1, m.nTotale2, m.nTotale3, m.nTotale4, m.nTotale5
		            INSERT INTO invtmp FROM MEMVAR
		         ENDIF
		      ELSE
		         m.cperiod   = lcPeriod
		         m.cyear     = lcYear
		
		         IF tlClose
		            m.cSuspType = 'I'
		            m.cyear   = lcYear
		            m.cperiod = lcPeriod
		            m.cGroup  = THIS.cGroup
		            m.cAction = 'O'
		            m.cComment  = 'Int On Hold Rel'
		            IF m.nAmount <> 0
		               m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               SELECT susaudit
		               SET DELETED OFF
		               SET ORDER TO cidsusa
		               DO WHILE SEEK(m.cidsusa)
		                  m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               ENDDO
		               INSERT INTO susaudit FROM MEMVAR
		               SET DELETED ON
		            ENDIF
		         ENDIF
		         m.nNetCheck  = m.nAmount
		         m.hperiod    = THIS.cperiod
		         m.hyear      = THIS.cyear
		         m.hdate      = THIS.dAcctDate
		         m.lused      = .F.
		         m.lOnHold    = .F.
		         m.ctypeinv   = 'I'
		         m.ctypeint    = 'B'
		         STORE 0 TO m.workint, m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		            m.nSevtaxes, m.nTotale1, m.nTotale2, m.nTotale3, m.nTotale4, m.nTotale5
		         INSERT INTO invtmp FROM MEMVAR
		
		      ENDIF
		   ENDSCAN
		
		   * Process negative interests on hold
		   SELE suspbal
		   SCAN FOR nAmount < 0
		      SCATTER MEMVAR
		      lcTypeInv = m.ctypeinv
		      SELECT wellinv
		      LOCATE FOR cOwnerID = m.cOwnerID ;
		         AND cWellID   = m.cWellID   ;
		         AND ctypeinv  = m.ctypeinv  ;
		         AND cprogcode = m.cprogcode
		      IF FOUND()
		         IF lOnHold = .F.
		            m.cperiod   = lcPeriod
		            m.cyear     = lcYear
		            m.nRunNo    = THIS.nRunNo
		
		            SELE invtmp
		            LOCATE FOR cWellID = m.cWellID AND cOwnerID = m.cOwnerID
		            IF FOUND()
		               SCATTER MEMVAR
		               IF invtmp.nNetCheck >= ABS(m.nAmount)
		                  m.nNetCheck   = m.nAmount
		                  m.hperiod    = THIS.cperiod
		                  m.hyear      = THIS.cyear
		                  m.hdate      = THIS.dAcctDate
		                  m.lused       = .F.
		                  m.ctypeinv   = 'I'
		                  m.ctypeint    = 'B'
		                  STORE 0 TO m.workint, m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		                     m.nSevtaxes, m.nTotale1, m.nTotale2, m.nTotale3, m.nTotale4, m.nTotale5
		                  INSERT INTO invtmp FROM MEMVAR
		               ELSE
		                  IF invtmp.nNetCheck > 0
		                     m.nNewAmt   = invtmp.nNetCheck - ABS(m.nAmount)
		                     m.nNetCheck = m.nAmount - m.nNewAmt
		                     m.nPct = m.nNetCheck/m.nAmount
		                     m.nIncome    = ROUND(m.nIncome * m.nPct,2)
		                     m.nExpenses  = ROUND((m.nExpenses+m.nGather+m.nCompress) * m.nPct,2)
		                     m.nTaxes     = ROUND(m.nTaxes * m.nPct,2)
		                     m.hperiod    = THIS.cperiod
		                     m.hyear      = THIS.cyear
		                     m.hdate      = THIS.dAcctDate
		                     m.lused       = .F.
		                     m.ctypeinv   = 'I'
		                     m.ctypeint    = 'B'
		                     STORE 0 TO m.workint, m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		                        m.nSevtaxes, m.nTotale1, m.nTotale2, m.nTotale3, m.nTotale4, m.nTotale5
		                     INSERT INTO invtmp FROM MEMVAR
		                     m.nAmount = m.nNetCheck
		                  ENDIF
		               ENDIF
		
		               IF tlClose
		                  m.cSuspType = 'I'
		                  m.cyear   = lcYear
		                  m.cperiod = lcPeriod
		                  m.cGroup  = THIS.cGroup
		                  m.cAction = 'O'
		                  m.cComment  = 'Int On Hold Rel'
		                  m.ctypeinv = lcTypeInv
		                  IF m.nAmount <> 0
		                     m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                     SELECT susaudit
		                     SET DELETED OFF
		                     SET ORDER TO cidsusa
		                     DO WHILE SEEK(m.cidsusa)
		                        m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		                     ENDDO
		                     INSERT INTO susaudit FROM MEMVAR
		                     SET DELETED ON
		                  ENDIF
		               ENDIF
		
		            ENDIF
		         ENDIF
		      ELSE
		         m.cperiod   = lcPeriod
		         m.cyear     = lcYear
		
		         IF tlClose
		            m.cSuspType = 'I'
		            m.cyear   = lcYear
		            m.cperiod = lcPeriod
		            m.cGroup  = THIS.cGroup
		            m.cAction = 'O'
		            m.cComment  = 'Int On Hold Rel'
		            m.ctypeinv = lcTypeInv
		            IF m.nAmount <> 0
		               m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               SELECT susaudit
		               SET DELETED OFF
		               SET ORDER TO cidsusa
		               DO WHILE SEEK(m.cidsusa)
		                  m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               ENDDO
		               INSERT INTO susaudit FROM MEMVAR
		               SET DELETED ON
		            ENDIF
		         ENDIF
		         m.nNetCheck   = m.nAmount
		         m.hperiod    = THIS.cperiod
		         m.hyear      = THIS.cyear
		         m.hdate      = THIS.dAcctDate
		         m.lused       = .F.
		         m.ctypeinv   = 'I'
		         m.ctypeint    = 'B'
		         STORE 0 TO m.workint, m.nintclass1, m.nintclass2, m.nintclass3, m.nintclass4, m.nintclass5, ;
		            m.nSevtaxes, m.nTotale1, m.nTotale2, m.nTotale3, m.nTotale4, m.nTotale5
		         INSERT INTO invtmp FROM MEMVAR
		      ENDIF
		   ENDSCAN
		ENDIF
		
		*
		*********************************************************************
		*   Total after minimum amounts added from previous periods
		*********************************************************************
		*
		SELECT cOwnerID, SUM(nNetCheck) AS nTotalCk, cGroup  ;
		   FROM invtmp ;
		   INTO CURSOR invtotal ;
		   GROUP BY cOwnerID ;
		   ORDER BY cOwnerID
		
		*
		************************************************************************
		*  IF total amount of check is less than minimum, add total to temp susp
		************************************************************************
		*
		SELECT invtotal
		GO TOP
		SCAN
		   SCATTER MEMVAR
		   lnCount = lnCount + 1
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      oProgress.SetProgressMessage('Processing Current Period Minimums')
		   ENDIF
		
		   SELECT investor
		   SET ORDER TO cOwnerID
		   IF SEEK(m.cOwnerID)
		      m.cOwnName = cOwnName
		      * Don't save Dummy suspense records
		      IF investor.ldummy OR investor.lIntegGL
		         LOOP
		      ENDIF
		      m.lhold = lhold
		      m.cSuspType = 'M'
		      m.lBackWith = lBackWith
		      m.lTaxWith  = lTaxWith
		      m.nDisbFreq = nDisbFreq
		      IF ninvmin = 0
		         jnMinCheck = lnMinCheck
		      ELSE
		         jnMinCheck = ninvmin
		      ENDIF
		   ELSE
		      LOOP
		   ENDIF
		
		   DO CASE
		      CASE m.nDisbFreq = 2          && Quarterly
		         IF NOT INLIST(lcAcctPrd,'03','06','09','12')
		            jnMinCheck = 99999999
		            m.cSuspType = 'Q'
		         ENDIF
		      CASE m.nDisbFreq = 3          && SemiAnnually
		         IF NOT INLIST(lcAcctPrd,'06','12')
		            jnMinCheck = 99999999
		            m.cSuspType = 'S'
		         ENDIF
		      CASE m.nDisbFreq = 4          && Annually
		         IF lcAcctPrd <> '12'
		            jnMinCheck = 99999999
		            m.cSuspType = 'A'
		         ENDIF
		   ENDCASE
		
		   IF m.lhold = .T.
		      jnMinCheck = 99999999
		      m.cSuspType = 'H'
		   ELSE
		      *
		      *  If the minimum amounts should be released, set the minimum amount to zero.
		      *
		      IF llRelMin
		         jnMinCheck = 0
		      ENDIF
		   ENDIF
		
		   SELECT invtotal
		   IF (m.nTotalCk < jnMinCheck AND m.nTotalCk > 0)
		      IF tlClose
		         *
		         *  If the period closing process called this routine
		         *  add an audit record to susaudit saying that we added
		         *  the minimum amount to suspense
		         *
		         m.nAmount  = m.nTotalCk
		         m.cyear    = lcYear
		         m.cperiod  = lcPeriod
		         m.cGroup   = THIS.cGroup
		         m.nRunNo   = THIS.nRunNo
		         m.cAction  = 'I'
		         m.cComment = 'Minimum Check Amt'
		
		         IF m.nAmount <> 0
		            SELECT invtmp
		            SCAN FOR cOwnerID = m.cOwnerID AND nNetCheck <> 0
		               SCATTER MEMVAR
		               m.nAmount   = nNetCheck
		
		               IF m.cDirect = 'O'
		                  m.nIncome   = m.nIncome - m.nOilRev
		               ENDIF
		               IF m.cDirect = 'G'
		                  m.nIncome   = m.nIncome - m.nGasRev
		               ENDIF
		               IF m.cDirect = 'B'
		                  m.nIncome   = m.nIncome - m.nOilRev - m.nGasRev
		               ENDIF
		               m.nExpenses = m.nExpense + m.nTotale1 + m.nTotale2 + m.nTotale3 + m.nTotale4 + m.nTotale5 + m.nTotaleA + m.nTotaleB+m.nCompress+m.nGather
		               m.nTaxes    = m.nSevtaxes
		               m.cyear     = lcYear
		               m.cperiod   = lcPeriod
		               m.nRunNo    = THIS.nRunNo
		
		               m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               SELECT susaudit
		               SET DELETED OFF
		               SET ORDER TO cidsusa
		               DO WHILE INDEXSEEK(m.cidsusa)
		                  m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		               ENDDO
		               INSERT INTO susaudit FROM MEMVAR
		               SET DELETED ON
		
		               SELECT invsusp
		*!*	               APPEND BLANK  &&  Commented out because it was double-posting below minimum people - BH 04/20/2005
		*!*	               REPLACE cOwnerID   WITH m.cOwnerID, ;
		*!*	                  cWellID     WITH m.cWellID, ;
		*!*	                  nworkint    WITH 0, ;
		*!*	                  ctypeinv    WITH m.ctypeinv, ;
		*!*	                  cGroup      WITH m.cGroup, ;
		*!*	                  ctypeint    WITH ' ', ;
		*!*	                  nintclass1  WITH 0, ;
		*!*	                  nintclass2  WITH 0, ;
		*!*	                  nintclass3  WITH 0, ;
		*!*	                  nintclass4  WITH 0, ;
		*!*	                  nintclass5  WITH 0, ;
		*!*	                  nTotale1    WITH 0, ;
		*!*	                  nTotale2    WITH 0, ;
		*!*	                  nTotale3    WITH 0, ;
		*!*	                  nTotale4    WITH 0, ;
		*!*	                  nTotale5    WITH 0, ;
		*!*	                  nIncome     WITH m.nIncome, ;
		*!*	                  nExpense    WITH m.nExpenses, ;
		*!*	                  nNetCheck   WITH m.nNetCheck, ;
		*!*	                  nSevtaxes   WITH m.nTaxes, ;
		*!*	                  hperiod     WITH THIS.cperiod, ;
		*!*	                  hyear       WITH THIS.cRunYear, ;
		*!*	                  nRunNo      WITH THIS.nRunNo
		            ENDSCAN
		         ENDIF
		      ENDIF
		      SELECT invtotal
		   ENDIF
		ENDSCAN
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   DOEVENTS
		   RELE oProgress
		ENDIF
		
		SELECT suspbal
		USE
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Processing Suspense by Well...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending susp_by_well')  
		endif   
		
		RETURN
		
	ENDPROC

	PROCEDURE taxexempt
		LPARA tladdback
		
		*  If tlAddBack is True, add the exempt owner taxes back into wellwork
		*  otherwise, remove them.
		
		IF THIS.lerrorflag
		   RETURN
		ENDIF
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Processing Tax Exempt Owners...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		ENDIF   
		
		STORE 0 TO lnoiltax1, lnoiltax2, lnoiltax3, lnoiltax4
		STORE 0 TO lngastax1, lngastax2, lngastax3, lngastax4
		STORE 0 TO lnothtax1, lnothtax2, lnothtax3, lnothtax4
		SELE investor
		LOCATE FOR lexempt
		IF NOT FOUND()
		   RETURN
		ENDIF
		
		IF tladdback = .F.
		   SELECT wellwork
		   SCAN
		      SCATTER MEMVAR
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(m.cwellid)
		         if cstate = 'NM' and FILE('nm.cfg')
		            loop
		         endif   
		         m.lusesev = lusesev
		         m.nroyint = nlandpct + noverpct
		      ELSE
		         LOOP
		      ENDIF
		      SELECT wellinv
		      SCAN FOR cwellid = m.cwellid
		         SCATTER MEMVAR
		         IF INLIST(m.ctypeinv,'L','O')
		            llroyaltyowner = .T.
		         ELSE
		            llroyaltyowner = .F.
		         ENDIF
		
		         if m.nroyint = 0
		            m.nrevotax = 0
		            m.nrevgtax = 0
		         else    
		            m.nrevotax = (m.nrevoil/m.nroyint) * 100
		            m.nrevgtax = (m.nrevgas/m.nroyint) * 100
		         endif   
		
		         SELECT investor
		         SET ORDER TO cownerid
		         IF SEEK(m.cownerid) AND lexempt
		            IF INLIST(m.ctypeint,'B','O')
		               IF m.lusesev  && Use state severance tax table rates
		                  IF llroyaltyowner
		                     lnoiltax1  = (ROUND(m.ntotbbltxr*(m.nrevotax/100),2))
		                  ELSE
		                     lnoiltax1  = (ROUND(m.ntotbbltxw*(m.nworkint/100),2))
		                  ENDIF
		               ELSE
		                  lnoiltax1   = (ROUND(m.ntotbbltx1*(m.nrevtax1/100),2))
		                  lnoiltax2   = (ROUND(m.ntotbbltx2*(m.nrevtax4/100),2))
		                  lnoiltax3   = (ROUND(m.ntotbbltx3*(m.nrevtax7/100),2))
		                  lnoiltax4   = (ROUND(m.ntotbbltx4*(m.nrevtax10/100),2))
		               ENDIF
		               IF lnoiltax1 + lnoiltax2 + lnoiltax3 + lnoiltax4 # 0
		                  SELECT wellwork
		                  REPL ntotbbltx1 WITH ntotbbltx1 - lnoiltax1, ;
		                     ntotbbltx2 WITH ntotbbltx2 - lnoiltax2, ;
		                     ntotbbltx3 WITH ntotbbltx3 - lnoiltax3, ;
		                     ntotbbltx4 WITH ntotbbltx4 - lnoiltax4
		               ENDIF
		            ENDIF
		            IF INLIST(m.ctypeint,'B','G')
		               IF m.lusesev  && Use state severance tax table rates
		                  IF llroyaltyowner
		                     lngastax1  = (ROUND(m.ntotmcftxr*(m.nrevgtax/100),2))
		                  ELSE
		                     lngastax1  = (ROUND(m.ntotmcftxw*(m.nworkint/100),2))
		                  ENDIF
		               ELSE
		                  lngastax1   = (ROUND(m.ntotmcftx1*(m.nrevtax2/100),2))
		                  lngastax2   = (ROUND(m.ntotmcftx2*(m.nrevtax5/100),2))
		                  lngastax3   = (ROUND(m.ntotmcftx3*(m.nrevtax8/100),2))
		                  lngastax4   = (ROUND(m.ntotmcftx4*(m.nrevtax11/100),2))
		               ENDIF
		               IF lngastax1 + lngastax2 + lngastax3 + lngastax4 # 0
		                  SELECT wellwork
		                  REPL ntotmcftx1 WITH ntotmcftx1 - lngastax1, ;
		                     ntotmcftx2 WITH ntotmcftx2 - lngastax2, ;
		                     ntotmcftx3 WITH ntotmcftx3 - lngastax3, ;
		                     ntotmcftx4 WITH ntotmcftx4 - lngastax4
		               ENDIF
		            ENDIF
		            *
		            *  Calculate other product taxes
		            *
		            lnothtax1 = (ROUND(m.ntotothtx1*(m.nrevtax3/100),2))
		            lnothtax2 = (ROUND(m.ntotothtx2*(m.nrevtax6/100),2))
		            lnothtax3 = (ROUND(m.ntotothtx4*(m.nrevtax9/100),2))
		            lnothtax4 = (ROUND(m.ntotothtx4*(m.nrevtax12/100),2))
		            IF lnothtax1 + lnothtax2 + lnothtax3 + lnothtax4 # 0
		               SELECT wellwork
		               REPL ntotothtx1 WITH ntotothtx1 - lnothtax1, ;
		                  ntotothtx2 WITH ntotothtx2 - lnothtax2, ;
		                  ntotothtx3 WITH ntotothtx3 - lnothtax3, ;
		                  ntotothtx4 WITH ntotothtx4 - lnothtax4
		            ENDIF
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		ELSE
		   SELECT wellwork
		   SCAN
		      SCATTER MEMVAR
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(m.cwellid)
		         if cstate = 'NM' and FILE('nm.cfg')
		            loop
		         endif   
		         m.lusesev = lusesev
		         m.nroyint = nlandpct + noverpct
		      ELSE
		         LOOP
		      ENDIF
		      
		      SELECT SUM(nrevtax1) AS nrevtax1, ;
		         SUM(nrevtax2) AS nrevtax2, ;
		         SUM(nrevtax3) AS nrevtax3, ;
		         SUM(nrevtax4) AS nrevtax4, ;
		         SUM(nrevtax5) AS nrevtax5, ;
		         SUM(nrevtax6) AS nrevtax6, ;
		         SUM(nrevtax7) AS nrevtax7, ;
		         SUM(nrevtax8) AS nrevtax8, ;
		         SUM(nrevtax9) AS nrevtax9, ;
		         SUM(nrevtax10) AS nrevtax10, ;
		         SUM(nrevtax11) AS nrevtax11, ;
		         SUM(nrevtax12) AS nrevtax12 ;
		         FROM wellinv, investor ;
		         WHERE cwellid = m.cwellid ;
		         AND wellinv.cownerid = investor.cownerid ;
		         AND investor.lexempt = .T. ;
		         INTO CURSOR exemptowns ;
		         GROUP BY cwellid
		
		      SELE exemptowns
		      SCAN
		         SCATTER MEMVAR
		            
		            lnrevtax1 = 1 - (m.nrevtax1/100)
		            lnrevtax2 = 1 - (m.nrevtax2/100)
		            lnrevtax3 = 1 - (m.nrevtax3/100)
		            lnrevtax4 = 1 - (m.nrevtax4/100)
		            lnrevtax5 = 1 - (m.nrevtax5/100)
		            lnrevtax6 = 1 - (m.nrevtax6/100) 
		            lnrevtax7 = 1 - (m.nrevtax7/100)
		            lnrevtax8 = 1 - (m.nrevtax8/100)
		            lnrevtax9 = 1 - (m.nrevtax9/100)
		            lnrevtax10 = 1 - (m.nrevtax10/100)
		            lnrevtax11 = 1 - (m.nrevtax11/100)
		            lnrevtax12 = 1 - (m.nrevtax12/100)
		            
		            if lnRevTax1 <> 0
		               lnoiltax1   = (ROUND(m.ntotbbltx1/lnrevtax1,2))
		            else
		               lnoiltax1   = 0
		            endif      
		            if lnrevtax4 <> 0
		               lnoiltax2   = (ROUND(m.ntotbbltx2/lnrevtax4,2))
		            else
		               lnoiltax2   = 0
		            endif
		            if lnrevtax7 <> 0        
		               lnoiltax3   = (ROUND(m.ntotbbltx3/lnrevtax7,2))
		            else
		               lnoiltax3   = 0
		            endif
		            if lnrevtax10 <> 0     
		               lnoiltax4   = (ROUND(m.ntotbbltx4/lnrevtax10,2))
		            else
		               lnoiltax4   = 0
		            endif      
		            
		            IF lnoiltax1 + lnoiltax2 + lnoiltax3 + lnoiltax4 # 0
		               SELECT wellwork
		               REPL ntotbbltx1 WITH lnoiltax1, ;
		                  ntotbbltx2 WITH lnoiltax2, ;
		                  ntotbbltx3 WITH lnoiltax3, ;
		                  ntotbbltx4 WITH lnoiltax4
		            ENDIF
		
		            if lnrevtax2 <> 0
		               lngastax1 = (ROUND(m.ntotmcftx1/lnrevtax2,2))
		            else
		               lngastax1 = 0
		            endif   
		            if lnrevtax5 <> 0
		               lngastax2   = (ROUND(m.ntotmcftx2/lnrevtax5,2))
		            else
		               lngastax2 = 0
		            endif
		            if lnrevtax8 <> 0        
		               lngastax3   = (ROUND(m.ntotmcftx3/lnrevtax8,2))
		            else
		               lngastax3 = 0
		            endif
		            if lnrevtax11 <> 0       
		               lngastax4   = (ROUND(m.ntotmcftx4/lnrevtax11,2))
		            else
		               lngastax4 = 0
		            endif      
		
		            IF lngastax1 + lngastax2 + lngastax3 + lngastax4 # 0
		               SELECT wellwork
		               REPL ntotmcftx1 WITH lngastax1, ;
		                  ntotmcftx2 WITH lngastax2, ;
		                  ntotmcftx3 WITH lngastax3, ;
		                  ntotmcftx4 WITH lngastax4
		            ENDIF
		
		         *
		         *  Calculate other product taxes
		         *
		         if lnrevtax3 <> 0
		            lnothtax1 = (ROUND(m.ntotothtx1/lnrevtax3,2))
		         else
		            lnothtax1 = 0
		         endif
		         if lnrevtax6 <> 0      
		            lnothtax2 = (ROUND(m.ntotothtx2/lnrevtax6,2))
		         else
		            lnothtax2 = 0
		         endif
		         if lnrevtax9 <> 0      
		            lnothtax3 = (ROUND(m.ntotothtx4/lnrevtax9,2))
		         else
		            lnothtax3 = 0
		         endif
		         if lnrevtax12 <> 0
		            lnothtax4 = (ROUND(m.ntotothtx4/lnrevtax12,2))
		         else
		            lnothtax4 = 0
		         endif
		               
		         IF lnothtax1 + lnothtax2 + lnothtax3 + lnothtax4 # 0
		            SELECT wellwork
		            REPL ntotothtx1 WITH lnothtax1, ;
		               ntotothtx2 WITH lnothtax2, ;
		               ntotothtx3 WITH lnothtax3, ;
		               ntotothtx4 WITH lnothtax4
		         ENDIF
		      ENDSCAN
		   ENDSCAN
		ENDIF
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Processing Tax Exempt Owners...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		ENDIF   
		
	ENDPROC

	PROCEDURE timekeeper
		lpara tcdescription
		
		m.cdesc = tcdescription
		m.ntime = seconds()
		insert into debugtime from memvar
		
		
	ENDPROC

	PROCEDURE unallrpt		&& Unallocated Revenue and Expense Report
		LOCAL tcWell1, tcWellname1, tcWell2, tcWellname2, tcGroup, tnSort, tnReport
		
		tcWell1 = THIS.cBegWellID
		tcWell2 = THIS.cEndWellID
		tcGroup = THIS.cGroup
		lWhere = 'AND wells.cgroup = tcGroup'
		
		oDist = CREATEOBJECT('distproc',tcWell1,tcWell2, '01','1980', tcGroup, 'W', DATE(), .F.,0)
		
		lOrderby    = 'wells.cwellid'
		lcSortOrder = 'Well ID'
		lBetween = 'BETWEEN(wells.cwellid,tcWell1,tcWell2)'
		
		lcTitle1 = ''
		lcTitle2 = ''
		glgrpname = .f.
		m.cproducer = m.goapp.ccompanyname
		
		CREATE CURSOR unalltmp ;
		   (crptgroup    C(1), ;
		   cwellid      C(10), ;
		   cwellname    C(30), ;
		   cvendorid    C(10), ;
		   cpayee       C(30), ;
		   ccateg       C(30), ;
		   cExpClass    c(1),  ;
		   crefid       C(15), ;
		   nGrossAmt    N(12,2), ;
		   nNetAmt      N(12,2),  ;
		   dDATE        D, ;
		   crevkey      C(10), ;
		   cSOURCE      C(3), ;
		   nunits       N(12,5), ;
		   nprice       N(9,5))
		
		INDEX ON cwellid+crptgroup TAG cwellid
		
		SELECT 'B' AS crptgroup, ;
		   expsusp.cwellid, ;
		   wells.cwellname, ;
		   expsusp.cvendorid, ;
		   expsusp.cpayee, ;
		   expsusp.ccateg, ;
		   expsusp.crefid, ;
		   expsusp.namount as nGrossAmt, ;
		   expsusp.dexpDATE AS dDATE  ;
		   FROM expsusp, wells ;
		   WHERE NOT lAllocated ;
		   AND &lBetween ;
		   AND expsusp.cwellid = wells.cwellid ;
		   &lWhere  ;
		   INTO CURSOR tempAP ;
		   ORDER BY &lOrderby, expsusp.cvendorid
		
		lnCount1 = _TALLY
		
		IF lnCount1 > 0
		   SELECT unalltmp
		   APPEND FROM DBF('tempap')
		ENDIF
		
		SELECT 'A' AS crptgroup, ;
		   incsusp.cwellid, ;
		   wells.cwellname, ;
		   incsusp.crevkey, ;
		   revsrc.crevname AS cpayee, ;
		   incsusp.cSOURCE, ;
		   incsusp.nunits,  ;
		   incsusp.nprice, ;
		   incsusp.crefid, ;
		   incsusp.ntotalinc AS nGrossAmt, ;
		   incsusp.drevDATE AS dDATE  ;
		   FROM incsusp, wells, revsrc ;
		   WHERE NOT lAllocated ;
		   AND &lBetween ;
		   AND incsusp.cwellid = wells.cwellid ;
		   AND incsusp.crevkey = revsrc.crevkey ;
		   &lWhere  ;
		   INTO CURSOR tempRV ;
		   ORDER BY &lOrderby, incsusp.crevkey
		
		lnCount2 = _TALLY
		IF lnCount2 > 0
		   SELECT unalltmp
		   APPEND FROM DBF('temprv')
		ENDIF
		
		lcTitle1 = 'Unallocated Revenue and Expenses'
		lcSelect = 'Group: ' +  tcGroup
		m.cProcessor = ''
		
		SELECT unalltmp
		SCAN
		   m.ngrossamt = nGrossamt
		   m.crptgroup = crptgroup
		   m.cwellid   = cwellid
		   m.cexpclass = cexpclass
		   m.cSOURCE   = cSOURCE
		   m.nNetAmt   = nGrossAmt
		   IF m.crptgroup = 'B'
		      m.nnetamt = swNetExp(m.ngrossamt,m.cwellid,.T.,m.cexpclass,'N')
		   ELSE
		      DO CASE
		         CASE INLIST(m.cSOURCE,'BBL','OTAX1','OTAX2','OTAX3','OTAX4')
		            if m.cSource = 'BBL'
		               m.nnetamt = oDist.Netrev(m.cwellid,m.ngrossamt,'O',.F.,.T.)
		            else
		               m.nnetamt = oDist.Netrev(m.cwellid,m.ngrossamt,'O'+right(trim(m.cSource),1),.F.,.T.)
		            endif
		         CASE INLIST(m.cSOURCE,'MCF','GTAX1','GTAX2','GTAX3','GTAX4')
		            if m.cSource = 'MCF'
		               m.nnetamt = oDist.Netrev(m.cwellid,m.ngrossamt,'G',.F.,.T.)
		            else
		               m.nnetamt = oDist.Netrev(m.cwellid,m.ngrossamt,'G'+right(trim(m.cSource),1),.F.,.T.)
		            endif
		         CASE INLIST(m.cSOURCE,'OTH','PTAX1','PTAX2','PTAX3','PTAX4')
		            m.nnetamt = oDist.Netrev(m.cwellid,m.ngrossamt,'P',.F.,.T.)
		      ENDCASE
		   ENDIF
		   SELE unalltmp
		   REPL nnetamt   WITH m.nnetamt, ;
		        ngrossamt WITH m.nGrossAmt
		ENDSCAN
		
		SELECT unalltmp
		IF RECC()> 0
		
		   REPORT FORM dmrunall.frx PREVIEW
		   IF THIS.omessage.CONFIRM('Should the report be sent to the printer now?')
		      REPORT FORM dmrunall.frx TO PRINTER PROMPT NOCONSOLE NOEJECT
		   ENDIF
		
		ENDIF
		
	ENDPROC

	PROCEDURE vendorchks		&& Creates vendor checks and places them in the check register to be printed.
		LOCAL tcYear, tcPeriod, tdCheckDate, tcGroup, tcBatch, tdPostDate, oProgress
		LOCAL jUnique, lcBatch, llSepClose, lcVendComp, lcDisbAcct
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		if this.lDebug
		   this.timekeeper('Starting vendorchks')  
		endif   
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Creating Vendor Checks...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		ENDIF   
		
		tcYear      = THIS.cRunYear
		tcPeriod    = THIS.cPeriod
		tdCheckDate = THIS.dAcctDate
		tcBatch     = THIS.cDMBatch
		
		if this.companypost = .t.
		   tdPostDate = this.dacctdate
		else
		   tdPostDate = this.dPostDate
		endif   
		
		tcGroup     = THIS.cGroup
		
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBarEx('Creating the vendor checks...',' ')
		ENDIF
		
		SELECT glopt
		llNOPostDM = lDMNoPost
		
		if not used('apopt')  &&  Added b/c there were sporadic errors about "Alias apopt not found" when closing
		   use apopt in 0
		endif
		
		SELE apopt
		lcAPAcct = capacct
		
		*
		*  Get the Disbursements checking account
		*
		SELECT options
		GO TOP
		lcDisbAcct = cDisbAcct
		lcVendComp = cVendComp
		llSepClose = lSepClose
		lcDMExp    = cFixedAcct
		
		IF EMPTY(lcDMExp)
		   lcDMExp = lcAPAcct
		ENDIF
		
		IF llSepClose
		   lcNetType = 'N'
		ELSE
		   lcNetType = 'B'
		ENDIF
		
		IF TYPE('m.goApp') = 'O'
		   IF NOT m.goApp.lAMVersion
		      * Don't create journal entries for stand-alone disb mgr
		      llNOPostDM = .T.
		   ENDIF
		ENDIF
		
		STORE 0 TO lnMax1, lnMax2
		
		**************************************
		*  Net down expenses for dummy owners
		**************************************
		SELECT expense
		lnX=AFIELDS(laTemp)
		FOR x = 1 TO lnX
		   laTemp[X,7] = ''
		   laTemp[X,8] = ''
		   laTemp[X,9] = ''
		   laTemp[X,10] = ''
		   laTemp[X,11] = ''
		   laTemp[X,12] = ''
		   laTemp[X,13] = ''
		   laTemp[X,14] = ''
		   laTemp[X,15] = ''
		   laTemp[X,16] = ''
		ENDFOR
		
		CREATE CURSOR exptemp FROM ARRAY laTemp
		SELECT expense
		SCAN FOR nRunNoRev = THIS.nRunNo AND cRunYearRev = THIS.cRunYear AND EMPTY(cpaidbyck)
		   SCATTER MEMVAR MEMO
		   m.namount = swNetExp(m.namount,m.cwellid,.T.,expense.cexpclass,'B')
		   INSERT INTO exptemp FROM MEMVAR
		ENDSCAN
		
		SELECT exptemp.cvendorid, cYear, cPeriod, wells.nprocess,;
		   SUM(exptemp.namount) AS namount, Vendor.cVendName AS cPayee   ;
		   FROM exptemp, Vendor, wells ;
		   WHERE  nRunNoRev = THIS.nRunNo ;
		   AND cRunYearRev = THIS.cRunYear ;
		   AND Vendor.linteggl = .F. ;
		   AND exptemp.cvendorid = Vendor.cvendorid           ;
		   AND exptemp.cwellid = wells.cwellid                ;
		   AND EMPTY(exptemp.cpaidbyck)                       ;
		   AND exptemp.laptran <> .T.                         ;
		   AND wells.cwellstat = 'A'                         ;
		   AND exptemp.cwellid IN (SELECT DISTINCT cwellid FROM wellinv) ;
		   INTO CURSOR vendc1 ;
		   GROUP BY exptemp.cvendorid ;
		   ORDER BY exptemp.cvendorid
		
		lnMax = _TALLY
		lnCount = 1
		
		CREATE CURSOR vendchks ;
		   (cvendorid    C(10), ;
		   cPayee      C(40), ;
		   cYear        C(4), ;
		   cPeriod      C(2), ;
		   nprocess     N(1), ;
		   namount      N(12,2))
		
		SELECT vendchks
		APPEND FROM DBF('vendc1')
		
		*
		*  Calculate the outstanding minimums for the vendors
		*
		THIS.suspcalc('**')
		
		lnMax = lnMax * 2
		lnTotal = 0
		
		IF NOT THIS.lQuiet
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		*
		*   DO suspense processing for vendor checks
		*
		SELECT vendchks
		SCAN FOR namount > 0
		   SCATTER MEMVAR
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      lnCount = lnCount + 1
		   ENDIF
		   if THIS.lClose
		      this.oProgress.SetProgressMessage('Creating Vendor Checks...'+m.cvendorid)
		      
		   endif
		
		   *
		   *  Update the vendor record with new purchases
		   *
		   *   DO vendupd WITH m.VendorId, m.Amount, tdCheckDate, 'S', 'I'
		
		   *
		   *  Get the minimum check amount for this vendor
		   *
		   SELECT Vendor
		   SET ORDER TO cvendorid
		   IF SEEK(m.cvendorid)
		      m.nMinCheck = nMinCheck
		      IF NOT m.goApp.lAMVersion
		         m.lHold     = .F.
		      ELSE
		         m.lHold     = lHold
		      ENDIF
		      m.linteggl  = linteggl
		      IF NOT llNOPostDM
		         * Don't create a check for this vendor
		         IF lSkipCheck
		            LOOP
		         ENDIF
		      ENDIF
		   ELSE
		      m.nMinCheck = 0
		      m.lHold     = .F.
		      m.linteggl  = .F.
		   ENDIF
		   *
		   *  If this vendor's income should be posted directly to the G/L
		   *  don't create a check.
		   *
		   IF m.linteggl
		      LOOP
		   ENDIF
		   SELECT suspbal
		   SET ORDER TO cOwnerID
		   IF SEEK(m.cvendorid)
		      IF ctypeinv = 'V'
		         m.nBal = namount
		         IF ((m.namount + m.nBal >= m.nMinCheck) OR m.nMinCheck = 0) AND NOT m.lHold
		            m.namount = m.namount + m.nBal
		            SELECT vendchks
		            REPLACE namount WITH m.namount
		            m.cYear = tcYear
		            m.cPeriod = tcPeriod
		            m.nRunNo = THIS.nRunNo
		            m.cGroup  = tcGroup
		            m.cOwnerID = m.cvendorid
		            m.cwellid  = 'ALL'
		            m.caction = 'O'
		            lnamount  = m.namount
		            m.namount = m.nBal
		            m.ctypeinv = 'V'
		            m.cSuspType = 'M'
		            m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		            SELECT susaudit
		            SET DELETED OFF
		            SET ORDER TO cidsusa
		            DO WHILE SEEK(m.cidsusa)
		               m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		            ENDDO
		            SET DELETED ON
		            m.cBatch = THIS.cDMBatch
		            INSERT INTO susaudit FROM MEMVAR
		            m.namount = lnamount
		         ENDIF
		      ENDIF
		   ENDIF
		   *
		   *  Check to see if the vendor check is below the minimum
		   *  if so, add it to the suspense file and don't create a
		   *  check.
		   *
		   IF (m.nMinCheck >= m.namount AND m.nMinCheck <> 0) OR m.lHold
		      m.cYear = tcYear
		      m.cPeriod = tcPeriod
		      m.cGroup  = tcGroup
		      m.nRunNo = THIS.nRunNo
		      m.cOwnerID = m.cvendorid
		      m.cwellid  = 'ALL'
		      m.caction = 'I'
		      m.ctypeinv = 'V'
		      m.cSuspType = 'M'
		      m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		      SELECT susaudit
		      SET DELETED OFF
		      SET ORDER TO cidsusa
		      DO WHILE SEEK(m.cidsusa)
		         m.cidsusa = THIS.oRegistry.IncrementCounter('%Shared.Counters.Suspense')
		      ENDDO
		      SET DELETED ON
		      m.cBatch = THIS.cDMBatch
		      INSERT INTO susaudit FROM MEMVAR
		      SELECT vendchks
		      DELETE NEXT 1
		   ENDIF
		ENDSCAN
		
		lnChkAmt = 0
		
		THIS.oGL.DMBatch    = THIS.cDMBatch
		
		IF NOT llNOPostDM
		   lcBatch             = THIS.oRegistry.IncrementCounter('%Shared.Counters.Batch')
		ENDIF
		
		THIS.oGL.cReference = 'Period: ' + tcYear+'/'+tcPeriod+'/'+tcGroup
		THIS.oGL.cYear      = tcYear
		THIS.oGL.cPeriod    = tcPeriod
		THIS.oGL.dcheckdate = tdCheckDate
		THIS.oGL.dPostDate  = tdPostDate
		THIS.oGL.cidtype    = 'V'
		THIS.oGL.cSource    = 'DM'
		THIS.oGL.cAcctNo    = lcDisbAcct
		THIS.oGL.cGroup     = tcGroup
		THIS.oGL.cEntryType = 'C'
		
		*
		*  Create checks in check register
		*
		SELECT vendchks
		IF RECC() <> 0
		   SCAN FOR namount > 0
		      SCATTER MEMVAR
		
		      SELECT Vendor
		      SET ORDER TO cvendorid
		      IF SEEK(m.cvendorid)
		         lcVendName = cVendName
		         IF this.lQBVersion
		            lcVendListID = cListID
		         ENDIF   
		         IF NOT THIS.lQuiet
		            oProgress.SetProgressMessage(lcVendName)
		            oProgress.UpdateProgress(lnCount)
		            lnCount = lnCount + 1
		         ENDIF
		
		         IF Vendor.linteggl
		            LOOP
		         ENDIF
		         IF Vendor.lSkipCheck
		            LOOP
		         ENDIF
		      ELSE
		         LOOP
		      ENDIF
		         *
		         *  Create a check to pay the vendor's expenses
		         *
		         THIS.oGL.cBatch     = tcBatch
		         THIS.oGL.cid        = m.cvendorid
		         THIS.oGL.cPayee     = lcVendName
		         THIS.oGL.namount    = m.namount
		         THIS.oGL.cAcctNo  = lcDisbAcct         
		         THIS.oGL.cidtype    = 'V'
		         THIS.oGL.addcheck()
		         lcidchec = THIS.oGL.getkey()
		         THIS.oGL.namount  = m.namount *-1
		         THIS.oGL.cidchec  = lcidchec
		         THIS.oGL.UpdateBatch()
		         
		         THIS.oGL.cAcctNo  = lcAPAcct
		         THIS.oGL.cDesc    = 'Vendor Check'
		         THIS.oGL.namount  = m.namount
		         THIS.oGL.UpdateBatch()
		         *
		         *   Update the expense records with the check they were paid with
		         *
		         THIS.expenseupd(m.cvendorid, lcidchec)
		      
		      *
		      *  Add the check to the total so we can post one
		      *  entry to the expense clearing account
		      *
		      lnChkAmt = lnChkAmt + m.namount
		      
		      *
		      *  If this is the QB version, mark the vendor checks as
		      *  having been printed.  They will be printed in QB.
		      *
		*!*	      IF this.lQBVersion
		*!*	         sele checks
		*!*	         set order to cidchec
		*!*	         if seek(lcidchec)
		*!*	            repl lprinted with .t.
		*!*	         endif
		*!*	      endif      
		   ENDSCAN
		
		ENDIF
		
		*
		*   Process compression & gathering charges if a vendor is to be paid
		*
		IF NOT EMPTY(lcVendComp)
		   SELECT Vendor
		   SET ORDER TO cvendorid
		   IF SEEK(lcVendComp) AND NOT linteggl
		      m.cPayee = cVendName
		      SELECT SUM(nCompress+nGather) AS nCompGath ;
		         FROM wellwork ;
		         WHERE nRunNo = THIS.nRunNo AND cRunYear= this.crunyear ;
		         AND cGroup = tcGroup ;
		         INTO ARRAY laGathComp
		      IF _TALLY > 0 AND laGathComp[1] <> 0
		         THIS.oGL.cid        = lcVendComp
		         THIS.oGL.cPayee     = m.cPayee
		         THIS.oGL.cidtype    = 'V'
		         THIS.oGL.cPeriod    = tcPeriod
		         THIS.oGL.cYear      = tcYear
		         THIS.oGL.cMemo      = 'Compression/Gathering '
		         THIS.oGL.cGroup     = tcGroup
		         THIS.oGL.cAcctNo    = lcDisbAcct
		         THIS.oGL.dcheckdate = tdCheckDate
		         THIS.oGL.dPostDate  = tdPostDate
		         THIS.oGL.namount    = laGathComp[1]
		         THIS.oGL.cBatch     = tcBatch
		         THIS.oGL.cSource    = 'DM'
		         THIS.oGL.addcheck()
		         lcidchec = THIS.oGL.getkey()
		
		         *
		         *  Build the G/L
		         *
		*!*	         IF NOT llNOPostDM
		*!*	            THIS.oGL.cBatch   = lcBatch
		*!*	            THIS.oGL.cAcctNo  = lcDisbAcct
		*!*	            THIS.oGL.namount  = laGathComp[1] * -1
		*!*	            THIS.oGL.cDesc    = m.cPayee
		*!*	            THIS.oGL.cidchec  = lcidchec
		*!*	            THIS.oGL.UpdateBatch()
		*!*	            
		*!*	            THIS.oGL.cAcctNo  = lcCompGath
		*!*	            THIS.oGL.namount  = laGathComp[1]
		*!*	            THIS.oGL.UpdateBatch()
		*!*	         ENDIF
		      ENDIF
		   ENDIF
		ENDIF
		
		*!*	*
		*!*	*  Post the total of the vendor checks to the expense
		*!*	*  clearing account
		*!*	*
		*!*	IF lnChkAmt <> 0 AND NOT llNOPostDM
		*!*	   THIS.oGL.cBatch   = lcBatch
		*!*	   THIS.oGL.cAcctNo  = lcAPAcct
		*!*	   THIS.oGL.namount  = lnChkAmt
		*!*	   THIS.oGL.cDesc    = 'Vendor Checks'
		*!*	   THIS.oGL.cidchec  = ''
		*!*	   THIS.oGL.UpdateBatch()
		*!*	ENDIF
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   DOEVENTS
		   RELE oProgress
		ENDIF
		
		if THIS.lClose
		   this.oProgress.SetProgressMessage('Creating Vendor Checks...')
		   this.oProgress.UpdateProgress(this.nprogress)
		   this.nprogress = this.nprogress + 1
		   
		ENDIF   
		
		if this.lDebug
		   this.timekeeper('Ending vendorchks')  
		endif   
		
		
		
	ENDPROC

	PROCEDURE wellproc		&& Process Wells
		LOCAL lnCount, lcSavePrd1, lcSavePrd2, lcYear, lnRunNo
		LOCAL lnCompress, lnGather, llSepClose, oProgress
		
		IF THIS.lErrorFlag
		   RETURN
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Starting wellproc')
		ENDIF
		
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Allocating Revenue and Expenses to Wells...')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		ENDIF
		
		lnCount    = 1
		lnRunNo    = THIS.nRunNo
		lcSavePrd1 = THIS.cPeriod
		lcSavePrd2 = lcSavePrd1
		ldAcctDate = THIS.dAcctDate
		ldPostDate = THIS.dPostDate
		
		
		* Build a cursor of all wells that have JIB owners
		SELE cWellID FROM wellinv WHERE lJIB INTO CURSOR jib_wells ORDER BY cWellID GROUP BY cWellID
		
		* Get the default compression and gathering charges
		SELECT options
		lnCompress = nCompress
		lnGather   = nGather
		llSepClose = lSepClose
		
		IF TYPE('ldAcctDate') <> 'D'
		   ldAcctDate = DATE()
		ENDIF
		
		DO calcint
		
		CREATE CURSOR temptax ;
		   (hyear      c(4), ;
		   hperiod    c(2), ;
		   cWellID    c(10), ;
		   noiltax1   N(9,2), ;
		   noiltax2   N(9,2), ;
		   noiltax3   N(9,2), ;
		   noiltax4   N(9,2), ;
		   ngastax1   N(9,2), ;
		   ngastax2   N(9,2), ;
		   ngastax3   N(9,2), ;
		   ngastax4   N(9,2))
		
		SELECT wellwork
		COUNT FOR NOT DELETED() TO lnMax
		
		IF NOT THIS.lQuiet
		   oProgress = THIS.oMessage.ProgressBar('Allocating revenue and expenses to the wells....')
		   oProgress.SetProgressRange(0,lnMax)
		ENDIF
		
		lcWellFlat = ' x '
		
		SELECT wellwork
		SET ORDER TO wellprd
		SCAN FOR BETWEEN(cWellID,THIS.cbegwellid,THIS.cendwellid)
		   m.cWellID    = cWellID
		   m.nprocess   = nprocess
		   m.ngasint    = ngasint
		   m.noilint    = noilint
		   lcProdPeriod = hperiod
		   lcProdYear   = hyear
		   m.nFlatGas   = 0
		   m.nFlatOil   = 0
		   m.hyear      = hyear
		   m.hperiod    = hperiod
		
		   IF THIS.lClose
		      THIS.oProgress.SetProgressMessage('Allocating Revenue and Expenses to Wells...'+m.cWellID)
		   ENDIF
		
		   IF NOT THIS.lQuiet
		      oProgress.UpdateProgress(lnCount)
		      lnCount = lnCount + 1
		   ENDIF
		
		   *  Get the flat royalty amount of gas and oil to be paid
		   IF m.cWellID <> lcWellFlat OR lcWellFlat = ' x '
		      m.nFlatGas = THIS.getFlatAmt(m.cWellID,'G')
		      m.nFlatOil = THIS.getFlatAmt(m.cWellID,'O')
		   ENDIF
		
		   lcWellFlat = m.cWellID
		
		   STORE 0 TO m.nTotale, m.nGasInc, m.noilinc, m.nTrpInc,  m.nExpgas, m.nExpoil, m.nTotProd
		   STORE 0 TO m.nTotBBL, m.nTotMCF, m.bbltot, m.mcftot, m.nMiscinc1, m.nMiscinc2, m.nOthInc
		   STORE 0 TO m.nGather, m.nCompress, m.nMCFTaxr, m.nMCFTaxw, m.nBBLTaxr, m.nBBLTaxw
		   STORE 0 TO m.nBBLTax1, m.nBBLTax2, m.nBBLTax3, m.nBBLTax4
		   STORE 0 TO m.nMCFTax1, m.nMCFTax2, m.nMCFTax3, m.nMCFTax4
		   STORE 0 TO m.nOthTax1, m.nOthTax2, m.nOthTax3, m.nOthTax4
		
		   SELECT wells
		   SET ORDER TO cWellID
		   IF SEEK (m.cWellID)
		      SCATTER MEMVAR
		      *  Override the global option
		      IF nCompress <> 0
		         lnCompress = nCompress
		      ENDIF
		      IF nGather <> 0
		         lnGather = nGather
		      ENDIF
		      m.nRoyInt      = nlandpct + noverpct && Get the total royalty pct in the well
		      STORE 0 TO m.nGather, m.nCompress
		   ELSE
		      LOOP
		   ENDIF
		
		   SELECT SUM(nrevgas) FROM wellinv INTO ARRAY laArray WHERE INLIST(cTypeInv,'O','L') AND cWellID = m.cWellID
		
		   IF _TALLY > 0
		      m.nRoyInt = laArray[1]
		   ELSE
		      m.nRoyInt = 0
		   ENDIF
		
		   SELECT sevtax
		   SET ORDER TO ctable
		   IF NOT SEEK (m.ctable)
		      **-
		      **-  No severance tax record was found for the current state, so
		      **-  zeros will be used for the tax rates for this well
		      **-
		      m.ntaxbbl1     = 0
		      m.ntaxmcf1     = 0
		      m.ntaxoth1     = 0
		      m.cMethodBBL1  = ' '
		      m.cMethodMCF1  = ' '
		      m.cMethodOTH1  = ' '
		      m.ntaxbbl2     = 0
		      m.ntaxmcf2     = 0
		      m.ntaxoth2     = 0
		      m.cMethodBBL2  = ' '
		      m.cMethodMCF2  = ' '
		      m.cMethodOTH2  = ' '
		      m.ntaxbbl3     = 0
		      m.ntaxmcf3     = 0
		      m.ntaxoth3     = 0
		      m.cMethodBBL3  = ' '
		      m.cMethodMCF3  = ' '
		      m.cMethodOTH3  = ' '
		      m.ntaxbbl4     = 0
		      m.ntaxmcf4     = 0
		      m.ntaxoth4     = 0
		      m.cMethodBBL4  = ' '
		      m.cMethodMCF4  = ' '
		      m.cMethodOTH4  = ' '
		   ELSE
		      SCATTER MEMVAR
		   ENDIF
		
		   IF m.lUseSev
		      STORE 0 TO m.ntaxbbl1, m.ntaxmcf1
		      STORE 'W' TO m.cMethodBBL1, m.cMethodMCF1
		   ENDIF
		
		   *  06/24/2004 - pws
		   *  Get marketing expense totals so that we can subtract them from market value
		   *  of gas before calculating taxes
		   *
		   lnMarketing = 0
		   SELE expense
		   SUM(namount) TO lnMarketing ;
		      FOR cWellID = m.cWellID AND ccatcode='MKTG' ;
		      AND nRunNoRev = 0 ;
		      AND (cYear+cPeriod=lcProdYear+lcProdPeriod) ;
		      AND dExpDate <= THIS.dRevDate
		
		   m.nprodwell = 0
		   lnDaysOn    = 0
		   *
		   * Process statement notes
		   *
		   IF THIS.lClose
		      SELE stmtnote
		      SCAN FOR nRunNo = 0
		         REPL nRunNo    WITH lnRunNo, ;
		            cRunYear  WITH THIS.cRunYear
		      ENDSCAN
		   ENDIF
		
		
		   STORE 0 TO m.noiltax1, m.ngastax1, m.noiltax2, m.ngastax2, m.noiltax3, m.ngastax3, m.noiltax4, m.ngastax4
		
		   *
		   *  Process well income
		   *
		   SELECT income
		   SET ORDER TO 0
		   *
		   *  Scan for all income records that have a runno of zero.  Also look to see if they match
		   *  one of the production periods from wellwork
		   *
		   SCAN FOR cWellID = m.cWellID AND nRunNo = 0 AND (cYear+cPeriod=lcProdYear+lcProdPeriod) AND dRevDate <= THIS.dRevDate
		      SCATTER MEMVAR
		      IF THIS.lClose
		         REPL nRunNo    WITH lnRunNo, ;
		            lClosed   WITH .T., ;
		            cRunYear  WITH THIS.cRunYear, ;
		            cAcctYear WITH THIS.cAcctYear, ;
		            cAcctPrd  WITH THIS.cAcctPrd
		         IF EMPTY(dAcctDate)
		            REPL dAcctDate WITH THIS.dAcctDate
		         ENDIF
		         SELE stmtnote
		         LOCATE FOR cWellID = m.cWellID AND nRunNo = 0
		         IF FOUND()
		            REPL nRunNo    WITH lnRunNo, ;
		               cRunYear  WITH THIS.cRunYear
		         ENDIF
		      ENDIF
		      m.nprodwell = m.nprodwell + m.nTotalInc
		      lnDaysOn    = m.nDaysOn
		      DO CASE
		         CASE m.cSource = "BBL"
		            m.nTotBBL = m.nTotBBL + m.nUnits
		
		            * If the well is not severance tax exempt, calculate the sev taxes
		            IF NOT m.ltaxexempt1
		               DO CASE
		                  CASE m.lSev1O
		                     m.nBBLTax1 = m.nBBLTax1
		                  CASE m.cMethodBBL1 = ' ' OR m.cMethodBBL1 = 'A'   && Rate specified by amount per bbl
		                     m.nBBLTax1 = m.nBBLTax1 + (m.ntaxbbl1*m.nUnits)
		                     m.nBBLTaxr = 0
		                     m.nBBLTaxw = 0
		                  CASE m.cMethodBBL1 = 'P'   && Rate specified by percentage
		                     IF m.cState = 'NM' AND FILE('nm.cfg')
		                        lnAmount = THIS.removetaxexempt(m.cWellID,'BBL',m.nTotalInc)
		                     ELSE
		                        lnAmount = m.nTotalInc
		                     ENDIF
		                     m.nBBLTax1 = m.nBBLTax1 + (m.ntaxbbl1*lnAmount)
		                     m.nBBLTaxr = 0
		                     m.nBBLTaxw = 0
		                  CASE m.cMethodBBL1 = 'W'       && Rate Specified by Well
		                     m.nBBLTaxr = m.nBBLTaxr + (m.nTotalInc*(m.nRoyInt/100)) * (m.nRoySevO/100)
		                     m.nBBLTaxw = m.nBBLTaxw + (m.nTotalInc - (m.nTotalInc*(m.nRoyInt/100))) * (m.nWrkSevO/100)
		                     m.nBBLTax1  = 0
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nBBLTax1, m.nBBLTaxr, m.nBBLTaxw, m.nOilTax1
		            ENDIF
		            * If the well is not exempt from tax2, calculate the taxes
		            IF NOT m.ltaxexempt2
		               DO CASE
		                  CASE m.lSev2O
		                     m.nBBLTax2 = m.nBBLTax2
		                  CASE m.cMethodBBL2 = ' ' OR m.cMethodBBL2 = 'A'
		                     m.nBBLTax2 = m.nBBLTax2 + (m.ntaxbbl2*m.nUnits)
		                  CASE m.cMethodBBL2 = 'P'
		                     m.nBBLTax2 = m.nBBLTax2 + (m.ntaxbbl2*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nBBLTax2, m.nOilTax2
		            ENDIF
		            * If the well is not exempt from tax3, calculate the taxes
		            IF NOT m.ltaxexempt3
		               DO CASE
		                  CASE m.lSev3O
		                     m.nBBLTax3 = m.nBBLTax3
		                  CASE m.cMethodBBL3 = ' ' OR m.cMethodBBL3 = 'A'
		                     m.nBBLTax3 = m.nBBLTax3 + (m.ntaxbbl3*m.nUnits)
		                  CASE m.cMethodBBL3 = 'P'
		                     m.nBBLTax3 = m.nBBLTax3 + (m.ntaxbbl3*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nBBLTax3, m.nOilTax3
		            ENDIF
		            * If the well is not exempt from tax4, calculate the taxes
		            IF NOT m.ltaxexempt4
		               DO CASE
		                  CASE m.lSev4O
		                     m.nBBLTax4 = m.nBBLTax4
		                  CASE m.cMethodBBL4 = ' ' OR m.cMethodBBL4 = 'A'
		                     m.nBBLTax4 = m.nBBLTax4 + (m.ntaxbbl4*m.nUnits)
		                  CASE m.cMethodBBL4 = 'P'
		                     m.nBBLTax4 = m.nBBLTax4 + (m.ntaxbbl4*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nBBLTax4, m.nOilTax4
		            ENDIF
		
		            IF m.nTotalInc <> 0
		               m.noilinc = m.noilinc + m.nTotalInc
		            ENDIF
		         CASE m.cSource = "MCF"
		            m.nTotMCF = m.nTotMCF + m.nUnits
		
		            * If the well is not severance tax exempt, calculate the sev taxes
		            IF NOT m.ltaxexempt1
		               DO CASE
		                  CASE m.lSev1G          && Purchaser withholds gas tax 1
		                     m.nMCFTax1 = m.nMCFTax1
		                  CASE m.cMethodMCF1 = ' ' OR m.cMethodMCF1 = 'A'
		                     m.nMCFTax1 = m.nMCFTax1 + (m.ntaxmcf1*m.nUnits)
		                     m.nMCFTaxr = 0
		                     m.nMCFTaxw = 0
		                  CASE m.cMethodMCF1 = 'P'
		                     IF m.cState = 'NM' AND FILE('nm.cfg')
		                        lnAmount = THIS.removetaxexempt(m.cWellID,'MCF',m.nTotalInc)
		                     ELSE
		                        lnAmount = m.nTotalInc
		                     ENDIF
		                     m.nMCFTax1 = m.nMCFTax1 + (m.ntaxmcf1*lnAmount)
		                     m.nMCFTaxr = 0
		                     m.nMCFTaxw = 0
		                  CASE m.cMethodMCF1 = 'W'
		                     m.nMCFTaxr = m.nMCFTaxr + (m.nTotalInc*(m.nRoyInt/100)) * (m.nRoySevG/100)
		                     m.nMCFTaxw = m.nMCFTaxw + (m.nTotalInc - (m.nTotalInc*(m.nRoyInt/100))) * (m.nWrkSevG/100)
		                     m.nMCFTax1  = 0
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nMCFTax1, m.nMCFTaxr, m.nMCFTaxw, m.nGasTax1
		            ENDIF
		            *  If the well is not exempt from tax 2, calculate the taxes
		            IF NOT m.ltaxexempt2
		               DO CASE
		                  CASE m.lSev2G
		                     m.nMCFTax2 = m.nMCFTax2
		                  CASE m.cMethodMCF2 = ' ' OR m.cMethodMCF2 = 'A'
		                     m.nMCFTax2 = m.nMCFTax2 + (m.ntaxmcf2*m.nUnits)
		                  CASE m.cMethodMCF2 = 'P'
		                     m.nMCFTax2 = m.nMCFTax2 + (m.ntaxmcf2*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nMCFTax2, m.nGasTax2
		            ENDIF
		            *  If the well is not exempt from tax 3, calculate the taxes
		            IF NOT m.ltaxexempt3
		               DO CASE
		                  CASE m.lSev3G
		                     m.nMCFTax3 = m.nMCFTax3
		                  CASE m.cMethodMCF3 = ' ' OR m.cMethodMCF3 = 'A'
		                     m.nMCFTax3 = m.nMCFTax3 + (m.ntaxmcf3*m.nUnits)
		                  CASE m.cMethodMCF3 = 'P'
		                     m.nMCFTax3 = m.nMCFTax3 + (m.ntaxmcf3*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nMCFTax3, m.nGasTax3
		            ENDIF
		            *  If the well is not exempt from tax 4, calculate the taxes
		            IF NOT m.ltaxexempt4
		               DO CASE
		                  CASE m.lSev4G
		                     m.nMCFTax4 = m.nMCFTax4
		                  CASE m.cMethodMCF4 = ' ' OR m.cMethodMCF4 = 'A'
		                     m.nMCFTax4 = m.nMCFTax4 + (m.ntaxmcf4*m.nUnits)
		                  CASE m.cMethodMCF4 = 'P'
		                     m.nMCFTax4 = m.nMCFTax4 + (m.ntaxmcf4*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nMCFTax4, m.nGasTax4
		            ENDIF
		            IF m.lCompress
		               m.nCompress = m.nCompress + (lnCompress*m.nUnits)
		            ENDIF
		            IF m.lGather
		               m.nGather   = m.nGather   + (lnGather*m.nUnits)
		            ENDIF
		
		            IF m.nTotalInc <> 0
		               m.nGasInc = m.nGasInc + m.nTotalInc
		            ENDIF
		         CASE m.cSource = "OTH"    && Other Product Taxes
		            m.nTotProd = m.nTotProd + m.nUnits
		
		            * If the well is not severance tax exempt, calculate the taxes
		            IF NOT m.ltaxexempt1
		               DO CASE
		                  CASE m.lSev1P
		                     m.nOthTax1 = m.nOthTax1
		                  CASE m.cMethodOTH1 = ' ' OR m.cMethodOTH1 = 'A'   && Rate specified by amount per unit
		                     m.nOthTax1 = m.nOthTax1 + (m.ntaxoth1*m.nUnits)
		                  CASE m.cMethodOTH1 = 'P'   && Rate specified by percentage
		                     m.nOthTax1 = m.nOthTax1 + (m.ntaxoth1*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nOthTax1
		            ENDIF
		            * If the well is not exempt from tax2, calculate the taxes
		            IF NOT m.ltaxexempt2
		               DO CASE
		                  CASE m.lSev2P
		                     m.nOthTax2 = m.nOthTax2
		                  CASE m.cMethodOTH2 = ' ' OR m.cMethodOTH2 = 'A'
		                     m.nOthTax2 = m.nOthTax2 + (m.ntaxoth2*m.nUnits)
		                  CASE m.cMethodOTH2 = 'P'
		                     m.nOthTax2 = m.nOthTax2 + (m.ntaxoth2*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nOthTax2
		            ENDIF
		            * If the well is not exempt from tax3, calculate the taxes
		            IF NOT m.ltaxexempt3
		               DO CASE
		                  CASE m.lSev3P
		                     m.nOthTax3 = m.nOthTax3
		                  CASE m.cMethodOTH3 = ' ' OR m.cMethodOTH3 = 'A'
		                     m.nOthTax3 = m.nOthTax3 + (m.ntaxoth3*m.nUnits)
		                  CASE m.cMethodOTH3 = 'P'
		                     m.nOthTax3 = m.nOthTax3 + (m.ntaxoth3*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nOthTax3
		            ENDIF
		            * If the well is not exempt from tax4, calculate the taxes
		            IF NOT m.ltaxexempt4
		               DO CASE
		                  CASE m.lSev4P
		                     m.nOthTax4 = m.nOthTax4
		                  CASE m.cMethodOTH4 = ' ' OR m.cMethodOTH4 = 'A'
		                     m.nOthTax4 = m.nOthTax4 + (m.ntaxoth4*m.nUnits)
		                  CASE m.cMethodOTH4 = 'P'
		                     m.nOthTax4 = m.nOthTax4 + (m.ntaxoth4*m.nTotalInc)
		               ENDCASE
		            ELSE
		               STORE 0 TO m.nOthTax4
		            ENDIF
		
		            IF m.nTotalInc <> 0
		               m.nOthInc = m.nOthInc + m.nTotalInc
		            ENDIF
		         CASE m.cSource = "TRANS"
		            m.nTrpInc = m.nTrpInc + m.nTotalInc
		         CASE m.cSource = "MISC1"
		            m.nMiscinc1 = m.nMiscinc1 + m.nTotalInc
		         CASE m.cSource = "MISC2"
		            m.nMiscinc2 = m.nMiscinc2 + m.nTotalInc
		         CASE m.cSource = "EXG"
		            m.nExpgas = m.nExpgas + m.nTotalInc
		         CASE m.cSource = "EXO"
		            m.nExpoil = m.nExpoil + m.nTotalInc
		         CASE m.cSource = 'OTAX1'
		            m.noiltax1  = m.noiltax1 + m.nTotalInc * -1
		            m.nBBLTax1 = m.nBBLTax1 + (m.nTotalInc * -1)
		         CASE m.cSource = 'GTAX1'
		            m.ngastax1  = m.ngastax1 + m.nTotalInc * -1
		            m.nMCFTax1 = m.nMCFTax1 + (m.nTotalInc * -1)
		         CASE m.cSource = 'PTAX1'
		            m.nOthTax1 = m.nOthTax1 + (m.nTotalInc * -1)
		         CASE m.cSource = 'OTAX2'
		            m.noiltax2  = m.noiltax2 + m.nTotalInc * -1
		            m.nBBLTax2 = m.nBBLTax2 + (m.nTotalInc * -1)
		         CASE m.cSource = 'GTAX2'
		            m.ngastax2  = m.ngastax2 + m.nTotalInc * -1
		            m.nMCFTax2 = m.nMCFTax2 + (m.nTotalInc * -1)
		         CASE m.cSource = 'PTAX2'
		            m.nOthTax2 = m.nOthTax2 + (m.nTotalInc * -1)
		         CASE m.cSource = 'OTAX3'
		            m.noiltax3  = m.noiltax3 + m.nTotalInc * -1
		            m.nBBLTax3 = m.nBBLTax3 + (m.nTotalInc * -1)
		         CASE m.cSource = 'GTAX3'
		            m.ngastax3  = m.ngastax3 + m.nTotalInc * -1
		            m.nMCFTax3 = m.nMCFTax3 + (m.nTotalInc * -1)
		         CASE m.cSource = 'PTAX3'
		            m.nOthTax3 = m.nOthTax3 + (m.nTotalInc * -1)
		         CASE m.cSource = 'OTAX4'
		            m.noiltax4  = m.noiltax4 + m.nTotalInc * -1
		            m.nBBLTax4 = m.nBBLTax4 + (m.nTotalInc * -1)
		         CASE m.cSource = 'GTAX4'
		            m.ngastax4  = m.ngastax4 + m.nTotalInc * -1
		            m.nMCFTax4 = m.nMCFTax4 + (m.nTotalInc * -1)
		         CASE m.cSource = 'PTAX4'
		            m.nOthTax4 = m.nOthTax4 + (m.nTotalInc * -1)
		      ENDCASE
		   ENDSCAN        && income
		   INSERT INTO temptax FROM MEMVAR
		
		   m.nOilTax1 = m.nBBLTax1  &&  Assign these values here, because assigning them before the insert into temptax causes later calcs to zero out the taxes - BH 10/17/2006
		   m.nOilTax2 = m.nBBLTax2
		   m.nOilTax3 = m.nBBLTax3
		   m.nOilTax4 = m.nBBLTax4
		   m.nGasTax1 = m.nMCFTax1
		   m.nGasTax2 = m.nMCFTax2
		   m.nGasTax3 = m.nMCFTax3
		   m.nGasTax4 = m.nMCFTax4
		
		   * 06/24/2004 - pws
		   * Remove marketing expense from gas tax
		   *
		   if m.cmethodmcf1 = 'P'
		      lnMktAmt = lnMarketing * m.ntaxmcf1
		      IF NOT m.lSev1G and not m.ltaxexempt1
		         m.nMCFTax1 = m.nMCFTax1 - lnMktAmt
		      ENDIF
		   endif    
		
		   STORE 0 TO m.nTotale, m.nexpcl1, m.nexpcl2, m.nexpcl3, m.nexpcl4, m.nexpcl5, m.ntotsalt
		   STORE 0 TO m.nexpclA, m.nexpclB
		   **-
		   **-  Process well expenses
		   **-
		   SELECT expense
		   SET ORDER TO 0
		   SCAN FOR cWellID = m.cWellID AND nRunNoRev = 0 AND (cYear+cPeriod=lcProdYear+lcProdPeriod) AND dExpDate <= THIS.dExpDate
		      SCATTER MEMVAR
		
		      * Don't process marketing expenses here
		      IF m.ccatcode = 'MKTG'
		         LOOP
		      ENDIF
		
		      IF THIS.lClose
		         SELE expense
		         REPL nRunNoRev   WITH lnRunNo, ;
		            lClosed     WITH .T., ;
		            cRunYearRev WITH THIS.cRunYear, ;
		            cAcctYear   WITH THIS.cAcctYear, ;
		            cAcctPrd    WITH THIS.cAcctPrd
		         IF EMPTY(dAcctDate)
		            REPL dAcctDate WITH THIS.dAcctDate
		         ENDIF
		      ENDIF
		      *!*  Commented out 8/17/05 - pws
		      *!*    - to implement the ability to specify the class at data entry time.
		      *!*	      SELECT expcat
		      *!*	      SET ORDER TO ccatcode
		      *!*	      IF SEEK(m.ccatcode)
		      *!*	         m.cExpClass = cExpClass
		      *!*	         *  Make sure the exp class in the expense record
		      *!*	         *  matches the expcat exp class.
		      *!*	         SELECT expense
		      *!*	         REPL cexpclass WITH m.cExpClass
		      *!*	      ELSE
		      *!*	         LOOP
		      *!*	      ENDIF
		
		      *  Total the expense classes
		      DO CASE
		         CASE m.cExpClass = '0'
		            m.nTotale = m.nTotale + m.namount
		         CASE m.cExpClass = '1'
		            m.nexpcl1 = m.nexpcl1 + m.namount
		         CASE m.cExpClass = '2'
		            m.nexpcl2 = m.nexpcl2 + m.namount
		         CASE m.cExpClass = '3'
		            m.nexpcl3 = m.nexpcl3 + m.namount
		         CASE m.cExpClass = '4'
		            m.nexpcl4 = m.nexpcl4 + m.namount
		         CASE m.cExpClass = '5'
		            m.nexpcl5 = m.nexpcl5 + m.namount
		         CASE m.cExpClass = 'A'
		            m.nexpclA = m.nexpclA + m.namount
		         CASE m.cExpClass = 'B'
		            m.nexpclB= m.nexpclB + m.namount
		      ENDCASE
		      m.ntotsalt = m.ntotsalt + m.nsaltwater
		   ENDSCAN
		
		   **-
		   **-  Process marketing expenses
		   **-
		   STORE 0 TO m.nTotMKTG
		   SELECT expense
		   SET ORDER TO 0
		   SCAN FOR cWellID = m.cWellID AND nRunNoRev = 0 AND (cYear+cPeriod=lcProdYear+lcProdPeriod) AND dExpDate <= THIS.dRevDate AND ccatcode = 'MKTG'
		      SCATTER MEMVAR
		
		      * Mark as processed if closing
		      IF THIS.lClose
		         SELE expense
		         REPL nRunNoRev   WITH lnRunNo, ;
		            lClosed     WITH .T., ;
		            cRunYearRev WITH THIS.cRunYear, ;
		            cAcctYear   WITH THIS.cAcctYear, ;
		            cAcctPrd    WITH THIS.cAcctPrd
		         IF EMPTY(dAcctDate)
		            REPL dAcctDate WITH THIS.dAcctDate
		         ENDIF
		      ENDIF
		
		      *  Total the expense classes
		      m.nTotMKTG = m.nTotMKTG + m.namount
		   ENDSCAN
		
		   **-
		   **-  Get the net amounts of oil and gas based upon the percentage of
		   **-  non-directly paid owners.  03/06/96 pws
		   **-
		   IF m.noilinc <> 0
		      lnNetOilAmt = THIS.netrev(m.cWellID, m.noilinc,'O')
		   ELSE
		      lnNetOilAmt = 0
		   ENDIF
		   IF m.nGasInc <> 0
		      lnNetGasAmt = THIS.netrev(m.cWellID, m.nGasInc,'G')
		   ELSE
		      lnNetGasAmt = 0
		   ENDIF
		
		   IF m.nOthInc <> 0
		      lnNetOthAmt = THIS.netrev(m.cWellID, m.nOthInc,'P')
		   ELSE
		      lnNetOthAmt = 0
		   ENDIF
		   IF m.nTrpInc <> 0
		      lnNetTrpAmt = THIS.netrev(m.cWellID, m.nTrpInc,'T')
		   ELSE
		      lnNetTrpAmt = 0
		   ENDIF
		   IF m.nBBLTax1 <> 0
		      m.nBBLTax1 = THIS.netrev(m.cWellID,m.nBBLTax1,'O1')
		   ENDIF
		   IF m.nBBLTax2 <> 0
		      m.nBBLTax2 = THIS.netrev(m.cWellID,m.nBBLTax2,'O2')
		   ENDIF
		   IF m.nBBLTax3 <> 0
		      m.nBBLTax3 = THIS.netrev(m.cWellID,m.nBBLTax3,'O3')
		   ENDIF
		   IF m.nBBLTax4 <> 0
		      m.nBBLTax4 = THIS.netrev(m.cWellID,m.nBBLTax4,'O4')
		   ENDIF
		   IF m.nMCFTax1 <> 0
		      m.nMCFTax1 = THIS.netrev(m.cWellID,m.nMCFTax1,'G1')
		   ENDIF
		   IF m.nMCFTax2 <> 0
		      m.nMCFTax2 = THIS.netrev(m.cWellID,m.nMCFTax2,'G2')
		   ENDIF
		   IF m.nMCFTax3 <> 0
		      m.nMCFTax3 = THIS.netrev(m.cWellID,m.nMCFTax3,'G3')
		   ENDIF
		   IF m.nMCFTax4 <> 0
		      m.nMCFTax4 = THIS.netrev(m.cWellID,m.nMCFTax4,'G4')
		   ENDIF
		   IF m.nOthTax1 <> 0
		      m.nOthTax1 = THIS.netrev(m.cWellID,m.nOthTax1,'P1')
		   ENDIF
		   IF m.nOthTax2 <> 0
		      m.nOthTax2 = THIS.netrev(m.cWellID,m.nOthTax2,'P2')
		   ENDIF
		   IF m.nOthTax3 <> 0
		      m.nOthTax3 = THIS.netrev(m.cWellID,m.nOthTax3,'P3')
		   ENDIF
		   IF m.nOthTax4 <> 0
		      m.nOthTax4 = THIS.netrev(m.cWellID,m.nOthTax4,'P4')
		   ENDIF
		
		   IF m.nTotale <> 0
		      *  Net out JIB and Dummy
		      m.nNetExp = swNetExp(m.nTotale, m.cWellID, .T., m.cExpClass, 'N')
		      *  Only net out JIB amounts
		      m.nTotale = swNetExp(m.nTotale, m.cWellID, .T., m.cExpClass, 'D')
		   ELSE
		      m.nNetExp = 0
		   ENDIF
		
		   IF m.nexpcl1 <> 0
		      m.nexpcl1 = swNetExp(m.nexpcl1, m.cWellID, .T., '1', 'D')
		   ENDIF
		   IF m.nexpcl2 <> 0
		      m.nexpcl2 = swNetExp(m.nexpcl2, m.cWellID, .T., '2', 'D')
		   ENDIF
		   IF m.nexpcl3 <> 0
		      m.nexpcl3 = swNetExp(m.nexpcl3, m.cWellID, .T., '3', 'D')
		   ENDIF
		   IF m.nexpcl4 <> 0
		      m.nexpcl4 = swNetExp(m.nexpcl4, m.cWellID, .T., '4', 'D')
		   ENDIF
		   IF m.nexpcl5 <> 0
		      m.nexpcl5 = swNetExp(m.nexpcl5, m.cWellID, .T., '5', 'D')
		   ENDIF
		   IF m.nexpclA <> 0
		      m.nexpclA = swNetExp(m.nexpclA, m.cWellID, .T., 'A', 'D')
		   ENDIF
		   IF m.nexpclB <> 0
		      m.nexpclB = swNetExp(m.nexpclB, m.cWellID, .T., 'B', 'D')
		   ENDIF
		
		   IF TYPE('ldPostDate') <> 'D'
		      ldPostDate = DATE()
		   ENDIF
		
		   SELECT wellwork
		   REPLACE nGasInc WITH  lnNetGasAmt, ;
		      ngrossgas  WITH  m.nGasInc, ;
		      noilinc    WITH  lnNetOilAmt, ;
		      ngrossoil  WITH  m.noilinc, ;
		      nTrpInc    WITH  m.nTrpInc, ;
		      nOthInc    WITH  m.nOthInc, ;
		      nMiscinc1  WITH  m.nMiscinc1, ;
		      nMiscinc2  WITH  m.nMiscinc2, ;
		      nTotMKTG   WITH  m.nTotMKTG, ;
		      nNetExp    WITH  m.nNetExp, ;
		      nTotale    WITH  m.nTotale, ;
		      nexpcl1    WITH  m.nexpcl1, ;
		      nexpcl2    WITH  m.nexpcl2, ;
		      nexpcl3    WITH  m.nexpcl3, ;
		      nexpcl4    WITH  m.nexpcl4, ;
		      nexpcl5    WITH  m.nexpcl5, ;
		      nexpclA    WITH  m.nexpclA, ;
		      nexpclB    WITH  m.nexpclB, ;
		      ntotbbltx1 WITH  m.nBBLTax1, ;
		      ntotmcftx1 WITH  m.nMCFTax1, ;
		      ntotothtx1 WITH  m.nOthTax1, ;
		      ntotbbltx2 WITH  m.nBBLTax2, ;
		      ntotmcftx2 WITH  m.nMCFTax2, ;
		      ntotothtx2 WITH  m.nOthTax2, ;
		      ntotbbltx3 WITH  m.nBBLTax3, ;
		      ntotmcftx3 WITH  m.nMCFTax3, ;
		      ntotothtx3 WITH  m.nOthTax3, ;
		      ntotbbltx4 WITH  m.nBBLTax4, ;
		      ntotmcftx4 WITH  m.nMCFTax4, ;
		      ntotothtx4 WITH  m.nOthTax4, ;
		      ntotbbltxR WITH  m.nBBLTaxr, ;
		      ntotmcftxR WITH  m.nMCFTaxr, ;
		      ntotbbltxW WITH  m.nBBLTaxw, ;
		      ntotmcftxW WITH  m.nMCFTaxw, ;
		      nGather    WITH  m.nGather, ;
		      nCompress  WITH  m.nCompress, ;
		      nOilExp    WITH  m.nExpoil, ;
		      nGasExp    WITH  m.nExpgas, ;
		      nTotBBL    WITH  m.nTotBBL, ;
		      nTotMCF    WITH  m.nTotMCF, ;
		      nTotProd   WITH  m.nTotProd, ;
		      noilint    WITH  m.noilint, ;
		      ngasint    WITH  m.ngasint, ;
		      nDaysOn    WITH  lnDaysOn, ;
		      ntotsalt   WITH  m.ntotsalt,;
		      nFlatGas   WITH  m.nFlatGas, ;
		      nFlatOil   WITH  m.nFlatOil, ;
		      ngbbltax1  WITH  m.nOilTax1, ;
		      ngmcftax1  WITH  m.nGasTax1, ;
		      ngbbltax2  WITH  m.nOilTax2, ;
		      ngmcftax2  WITH  m.nGasTax2, ;
		      ngbbltax3  WITH  m.nOilTax3, ;
		      ngmcftax3  WITH  m.nGasTax3, ;
		      ngbbltax4  WITH  m.nOilTax4, ;
		      ngmcftax4  WITH  m.nGasTax4, ;
		      ngothtax1  WITH  m.nOthTax1, ;
		      ngothtax2  WITH  m.nOthTax2, ;
		      ngothtax3  WITH  m.nOthTax3, ;
		      ngothtax4  WITH  m.nOthTax4, ;
		      hdate      WITH  ldAcctDate
		ENDSCAN
		
		IF NOT THIS.lQuiet
		   oProgress.CloseProgress()
		   RELE oProgress
		   DOEVENTS
		ENDIF
		
		IF THIS.lClose
		   THIS.oProgress.SetProgressMessage('Allocating Revenue and Expenses to Wells')
		   THIS.oProgress.UpdateProgress(THIS.nprogress)
		   THIS.nprogress = THIS.nprogress + 1
		ENDIF
		
		IF THIS.lDebug
		   THIS.timekeeper('Ending wellproc')
		ENDIF
		
		
	ENDPROC

	PROCEDURE well_suspense		&& Processing for suspense when deficits are not netted among wells.
	ENDPROC

ENDDEFINE

DEFINE CLASS oldswownerstmt AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: backtaxwith
		*m: calccompress		&& Calculates compression/gathering charges
		*m: calcexpense		&& Calculates expense section
		*m: calcincome		&& Calculates income section
		*m: calctaxes		&& Calculates tax section
		*m: deficits_own
		*m: deficits_well
		*m: flatowner
		*m: getprevmins
		*m: getrange
		*m: intonhold
		*m: main
		*m: netbalance
		*m: netwelltotalnosplit
		*m: netwelltotalsplit
		*m: prevmins
		*m: pulltype
		*m: removetaxexempt
		*m: rounding
		*m: stmtnotes
		*p: cdmbatch
		*p: cgroup
		*p: cowner1
		*p: cowner2
		*p: cownerid
		*p: cownertype
		*p: cperiod
		*p: cprogcode
		*p: crunyear
		*p: cwellid
		*p: cwellid1
		*p: cwellid2
		*p: cyear
		*p: dacctdate
		*p: lallminsreleased
		*p: lbelowminimum
		*p: lchecksonly
		*p: lclosed
		*p: lcloserun
		*p: lcoldownerid
		*p: ldeficitprocessed
		*p: ldetail
		*p: ldirdeposit
		*p: lemailonly
		*p: lexemptroyalty
		*p: lflatalloc
		*p: lflatrate
		*p: lfreqheld
		*p: lincludechecks
		*p: linterestonhold
		*p: lnetwells
		*p: lnoprod
		*p: lowneronhold
		*p: lownertaxexempt
		*p: lprintdef
		*p: lprintmin
		*p: lroyaltyowner
		*p: lsplitperiods
		*p: lziporder
		*p: nbackupwith
		*p: nbalance
		*p: ncompress
		*p: ngasamount
		*p: ngastax1
		*p: ngastax2
		*p: ngastax3
		*p: ngastax4
		*p: ngather
		*p: noilamount
		*p: noiltax1
		*p: noiltax2
		*p: noiltax3
		*p: noiltax4
		*p: notheramount
		*p: nothtax1
		*p: nothtax2
		*p: nothtax3
		*p: nothtax4
		*p: nownertotal
		*p: nrunno
		*p: ntaxwith
		*p: ntotalbbl
		*p: ntotalmcf
		*p: ntotalother
		*p: ntotinc
		*p: nwelltot
		*p: odist
		*p: oinvtmp
		*p: omessage
		*p: ooptions
		*p: owellwork
		*p: ownergroup
	*</DefinedPropArrayMethod>

	cdmbatch = .F.
	cgroup = .F.
	cowner1 = .F.
	cowner2 = .F.
	cownerid = .F.
	cownertype = .F.
	cperiod = .F.
	cprogcode = .F.
	crunyear = .F.
	cwellid = .F.
	cwellid1 = .F.
	cwellid2 = .F.
	cyear = .F.
	dacctdate = .F.
	Height = 36
	lallminsreleased = .F.
	lbelowminimum = .F.
	lchecksonly = .F.
	lclosed = .F.
	lcloserun = .F.
	ldetail = .F.
	ldirdeposit = .F.
	lemailonly = .F.
	lexemptroyalty = .F.
	lflatrate = .F.
	lfreqheld = .F.
	lincludechecks = .F.
	linterestonhold = .F.
	lnetwells = .F.
	lnoprod = .F.
	lowneronhold = .F.
	lownertaxexempt = .F.
	lprintdef = .F.
	lprintmin = .F.
	lroyaltyowner = .F.
	lsplitperiods = .F.
	lziporder = .F.
	Name = "oldswownerstmt"
	nbackupwith = 0
	nbalance = .F.
	ncompress = .F.
	ngasamount = .F.
	ngastax1 = .F.
	ngastax2 = .F.
	ngastax3 = .F.
	ngastax4 = .F.
	ngather = .F.
	noilamount = .F.
	noiltax1 = .F.
	noiltax2 = .F.
	noiltax3 = .F.
	noiltax4 = .F.
	notheramount = .F.
	nothtax1 = .F.
	nothtax2 = .F.
	nothtax3 = .F.
	nothtax4 = .F.
	nownertotal = .F.
	nrunno = .F.
	ntaxwith = 0
	ntotalbbl = .F.
	ntotalmcf = .F.
	ntotalother = .F.
	ntotinc = 0
	nwelltot = 0
	odist = .F.
	oinvtmp = .F.
	omessage = .F.
	ooptions = .F.
	owellwork = .F.
	ownergroup = .F.
	Width = 142
	
	PROCEDURE backtaxwith
		*************************************************************
		*  Process Tax Withholding
		*************************************************************
		IF THIS.nBackupWith <> 0
		   THIS.nOwnerTotal   = THIS.nOwnerTotal - THIS.nBackupWith
		   m.crptgroup = 'H'
		   m.ctype     = 'PPD'
		   m.nwellnet  = THIS.nbackupWith
		   m.cperiod   = ''
		   m.cyear     = THIS.oWellWork.hYear
		   m.cprogcode = ''
		   m.cwelltype = '}ZZZZZZZ'
		   m.cdescript = 'Backup Withholding Amount Deducted This Period'
		   m.cownerid = THIS.cownerid
		   m.nRunNo = this.nRunNo
		   *********************************************************************************************************
		   *  Insert into the statement file  - Report Group H     (Backup Withholding)
		   *********************************************************************************************************
		   INSERT INTO statemnt FROM MEMVAR
		   m.cdescript = ' '
		ENDIF  && IF m.nBack
		
		*************************************************************
		*  Process Tax Withholding
		*************************************************************
		IF THIS.nTaxWith <> 0
		   THIS.nOwnerTotal   = THIS.nOwnerTotal - THIS.nTaxWith
		   m.crptgroup = 'H'
		   m.ctype     = 'PPD'
		   m.nwellnet  = THIS.ntaxWith
		   m.cperiod   = ''
		   m.cyear     = THIS.oWellWork.hYear
		   m.cprogcode = ''
		   m.cwelltype = '}ZZZZZZZ'
		   m.cdescript = 'Tax Withholding Amount Deducted This Period'
		   m.cownerid = THIS.cownerid
		   m.nRunNo = this.nRunNo
		   *********************************************************************************************************
		   *  Insert into the statement file  - Report Group H     (Tax Withholding)
		   *********************************************************************************************************
		   INSERT INTO statemnt FROM MEMVAR
		   m.cdescript = ' '
		ENDIF  && IF m.nTax
		
	ENDPROC

	PROCEDURE calccompress		&& Calculates compression/gathering charges
		SELE wells
		LOCATE FOR cwellid = THIS.owellwork.cwellid
		IF FOUND()
		   THIS.ooptions.lroycomp = lexclroycomp
		ENDIF
		
		IF THIS.owellwork.nGather <> 0 AND NOT THIS.ooptions.lHidecomp
		   IF THIS.lRoyaltyOwner AND THIS.ooptions.lchgprice
		      * Do Nothing
		   ELSE
		      IF THIS.lRoyaltyOwner AND THIS.ooptions.lroycomp
		         * Do Nothing
		      ELSE
		         m.crptgroup = 'B'
		         m.ctype     = 'MCF'
		         m.cperiod   = ''
		         m.cyear     = THIS.owellwork.hyear
		         m.csource   = 'Gathering Charge'
		         m.nprice    = THIS.nGather
		         m.ntotal    = THIS.owellwork.nGather * -1
		         m.nunits    = THIS.nTotalMCF
		         IF NOT THIS.lRoyaltyOwner AND THIS.ooptions.lroycomp
		            m.nrevint = m.nworkint
		         ELSE
		            m.nrevint   = THIS.oInvTmp.nrevgas
		         ENDIF
		         m.ninvamt = SWROUND(THIS.owellwork.nGather*(m.nrevint/100),2) * -1
		         m.cdescript = ' '
		         m.cownerid = THIS.oInvTmp.cownerid
		         m.nRunNo   = this.nRunNo
		         m.cperiod  = THIS.owellwork.hperiod
		         m.cProgCode = THIS.oInvTmp.cProgCode
		         SELE programs
		         LOCATE FOR cProgCode = m.cProgCode
		         IF FOUND()
		            lcprogname = cProgName
		         ELSE
		            lcprogname = ''
		         ENDIF
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         THIS.nWellTot = THIS.nWellTot + m.ninvamt
		      ENDIF
		   ENDIF
		ENDIF
		
		STORE 0 TO m.ntotal, m.ninvamt, m.nrevint
		STORE ' ' TO m.csource, m.ctype, m.cdescript
		IF THIS.owellwork.nCompress <> 0 AND NOT THIS.ooptions.lHidecomp
		   IF THIS.lRoyaltyOwner AND THIS.ooptions.lchgprice
		      * Do Nothing
		   ELSE
		      IF THIS.lRoyaltyOwner AND THIS.ooptions.lroycomp
		         * Do Nothing
		      ELSE
		         m.crptgroup = 'B'
		         m.ctype     = 'MCF'
		         m.cperiod   = ''
		         m.cyear     = THIS.owellwork.hyear
		         m.csource   = 'Compression Charge'
		         m.nprice    = THIS.nCompress
		         m.ntotal    = THIS.owellwork.nCompress * -1
		         m.nunits    = THIS.nTotalMCF
		         IF NOT THIS.lRoyaltyOwner AND THIS.ooptions.lroycomp
		            m.nrevint = m.nworkint
		         ELSE
		            m.nrevint   = THIS.oInvTmp.nrevgas
		         ENDIF
		         m.cperiod = THIS.owellwork.hperiod
		         m.ninvamt = SWROUND(THIS.owellwork.nCompress*(m.nrevint/100),2) *-1
		         m.cdescript = ' '
		         m.cownerid = THIS.oInvTmp.cownerid
		         m.nRunNo = this.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         THIS.nWellTot = THIS.nWellTot + m.ninvamt
		      ENDIF
		   ENDIF
		ENDIF
		
		STORE 0 TO m.ntotal, m.ninvamt, m.nrevint
		STORE ' ' TO m.csource, m.ctype, m.cdescript
		IF THIS.owellwork.nTotMKTG <> 0
		   sele expcat
		   locate for ccatcode = 'MKTG'
		   if found()
		      if this.oOptions.lAcctDesc = .T. AND NOT EMPTY(cdescrip)
		         m.csource = cdescrip
		      else
		         m.csource = ccateg
		      endif      
		   else
		      m.csource   = 'Marketing Charge'
		   endif   
		   m.crptgroup = 'B'
		   m.ctype     = 'OTH'
		   m.cperiod   = ''
		   m.cyear     = THIS.owellwork.hyear
		   m.nprice    = 0
		   m.ntotal    = THIS.owellwork.nTotMKTG * -1
		   m.nunits    = 0
		   m.nrevint   = THIS.oInvTmp.nrevgas
		   m.cperiod   = THIS.owellwork.hperiod
		   m.ninvamt   = SWROUND(THIS.owellwork.nTotMKTG*(m.nrevint/100),2) *-1
		   m.cdescript = ' '
		   m.cownerid  = THIS.oInvTmp.cownerid
		   m.nRunNo    = this.nRunNo
		   *********************************************************************************************************
		   *  Insert into the statement file  - Report Group B
		   *********************************************************************************************************
		   INSERT INTO statemnt FROM MEMVAR
		   THIS.nWellTot = THIS.nWellTot + m.ninvamt
		ENDIF
		
	ENDPROC

	PROCEDURE calcexpense		&& Calculates expense section
		LOCAL lcScan
		
		IF THIS.oInvTmp.nExpense <> 0
		   SELE exptemp
		   IF THIS.oOptions.lexpsum
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = '0' AND cCatCode <> 'MKTG'"
		   ELSE
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = '0' AND cCatCode <> 'MKTG'"
		   ENDIF
		   SCAN FOR &lcScan
		      IF THIS.oInvTmp.ljib
		         EXIT
		      ENDIF
		
		      SCATTER MEMVAR
		
		      m.ccategory = m.ccateg
		
		      *  Store original interests so we can change for one-man-items.  pws 3/11/97
		      jnworkint  = THIS.oInvTmp.nworkint
		      jnclass1   = THIS.oInvTmp.nintclass1
		      jnclass2   = THIS.oInvTmp.nintclass2
		      jnclass3   = THIS.oInvTmp.nintclass3
		      jnclass4   = THIS.oInvTmp.nintclass4
		      jnclass5   = THIS.oInvTmp.nintclass5
		
		      DO CASE
		         CASE m.cownerid = THIS.cownerid AND NOT m.loneman
		            REPLACE loneman WITH .T.
		            THIS.oInvTmp.nworkint = 100
		         CASE EMPTY(m.cownerid) OR m.cownerid = SPACE(10)
		            * Don't do anything if the cOwnerID is blank
		         CASE m.cownerid <> THIS.cownerid
		            m.cownerid = THIS.cownerid
		            LOOP
		         CASE m.cownerid = THIS.cownerid AND loneman
		            LOOP
		      ENDCASE
		
		      IF THIS.oInvTmp.nworkint = 0
		         LOOP
		      ENDIF
		
		      SELE exptemp
		      REPL lUsed WITH .T.
		
		      m.crptgroup = 'D'
		
		      * Report Category Descript instead of category name
		      IF THIS.oOptions.lacctdesc AND NOT EMPTY(m.cdescrip)
		         m.ccategory = m.cdescrip
		      ENDIF
		
		      *  Use the item description from the A/P bill for the category.
		      IF THIS.oOptions.lBillDesc AND NOT EMPTY(m.cmemo) AND m.laptran
		         m.ccategory = m.cmemo
		         m.cmemo = ''
		      ENDIF
		
		      *  Include the reference id on the expense line
		      IF THIS.oOptions.lRefid
		         IF NOT EMPTY(m.cmemo)
		            m.cmiscmemo = ALLTRIM(m.crefid) + ' - ' + ALLTRIM(m.cmemo)
		         ELSE
		            m.cmiscmemo = ALLTRIM(m.crefid)
		         ENDIF
		      ELSE
		         m.cmiscmemo = ALLTRIM(m.cmemo)
		      ENDIF
		
		      *  Print the vendor's name on the expense line
		      IF THIS.oOptions.lShowVendor
		         IF THIS.oOptions.lRefid
		            m.cmiscmemo = ALLT(m.crefid)+'-'+m.cpayee
		         ELSE
		            m.cmiscmemo = m.cpayee
		         ENDIF
		      ENDIF
		
		      * Calculate the owner's share of the expense
		      m.ninvamt   = SWROUND(m.namount*(THIS.oInvTmp.nworkint/100),2)
		
		      * Calculate the running well total of income - expesnes
		      THIS.nWellTot  = THIS.nWellTot - m.ninvamt
		
		      m.ctype = 'EXP'
		      m.nworkint = THIS.oInvTmp.nworkint
		
		      * Reset the owner id before saving to the statemnt table
		      m.cownerid = THIS.cownerid
		      m.nRunNo = THIS.nRunNo
		      m.cProgCode = THIS.oInvTmp.cProgCode
		      SELE programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         lcprogname = cProgName
		      ELSE
		         lcprogname = ''
		      ENDIF
		
		      * Only insert a record if the expense line is non-zero
		      IF THIS.oInvTmp.nworkint <> 0
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group D
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		
		      STORE 0 TO m.ninvamt, m.namount, m.ntotal
		      STORE ' ' TO m.cpayee, m.ccategory, m.cdescript, m.cmiscmemo
		
		      *  Restore original interests in case one-man-item logic changed them. pws 3/11/97
		      THIS.oInvTmp.nworkint   = jnworkint
		      THIS.oInvTmp.nintclass5 = jnclass5
		      THIS.oInvTmp.nintclass4 = jnclass4
		      THIS.oInvTmp.nintclass3 = jnclass3
		      THIS.oInvTmp.nintclass2 = jnclass2
		      THIS.oInvTmp.nintclass1 = jnclass1
		   ENDSCAN  && Exptemp
		ENDIF
		
		IF THIS.oInvTmp.ntotale1 <> 0
		   SELECT exptemp
		   IF THIS.oOptions.lexpsum
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = '1' AND cCatCode <> 'MKTG' and cYear+cPeriod = THIS.oInvTmp.hyear+this.oInvTmp.hPeriod"
		   ELSE
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = '1' AND cCatCode <> 'MKTG' and cYear+cPeriod = THIS.oInvTmp.hyear+this.oInvTmp.hPeriod"
		   ENDIF
		   SCAN FOR &lcScan
		      IF THIS.oInvTmp.ljib
		         EXIT
		      ENDIF
		
		      SCATTER MEMVAR
		
		      IF THIS.cownerid <> THIS.lcOldOwnerID  &&  Only mark it as used if the owner has changed - BH 7/11/06
		         REPL lUsed WITH .T.
		      ENDIF
		
		      *  Store original interests so we can change for one-man-items.  pws 3/11/97
		      jnworkint = THIS.oInvTmp.nworkint
		      jnclass1  = THIS.oInvTmp.nintclass1
		      jnclass2  = THIS.oInvTmp.nintclass2
		      jnclass3  = THIS.oInvTmp.nintclass3
		      jnclass4  = THIS.oInvTmp.nintclass4
		      jnclass5  = THIS.oInvTmp.nintclass5
		
		      DO CASE
		         CASE m.cownerid = THIS.cownerid AND NOT m.loneman
		            REPLACE loneman WITH .T.
		            THIS.oInvTmp.nintclass1 = 100
		         CASE EMPTY(m.cownerid) OR m.cownerid = SPACE(10)
		            * Don't do anything if the cOwnerID is blank
		         CASE m.cownerid <> THIS.cownerid
		            m.cownerid = THIS.cownerid
		            LOOP
		         CASE m.cownerid = THIS.cownerid AND loneman
		            LOOP
		      ENDCASE
		
		      IF THIS.oInvTmp.nintclass1 = 0
		         LOOP
		      ENDIF
		
		      SELE exptemp
		      IF THIS.cownerid <> THIS.lcOldOwnerID  &&  Only mark it as used if the owner has changed - BH 7/11/06
		         REPL lUsed WITH .T.
		      ENDIF
		
		      m.ccategory = m.ccateg
		      m.dExpDate = m.dExpDate
		
		      * Report Category Descript instead of category name
		      IF THIS.oOptions.lacctdesc AND NOT EMPTY(m.cdescrip)
		         m.ccategory = m.cdescrip
		      ENDIF
		
		      *  Use the item description from the A/P bill for the category.
		      IF THIS.oOptions.lBillDesc AND NOT EMPTY(m.cmemo) AND m.laptran
		         m.ccategory = m.cmemo
		         m.cmemo = ''
		      ENDIF
		
		      m.cpayee    = cpayee
		      m.namount   = namount
		      THIS.oInvTmp.nworkint  = THIS.oInvTmp.nintclass1
		
		      * Calculate the owner's share of the expense
		      m.ninvamt   = SWROUND((m.namount * (THIS.oInvTmp.nintclass1/100)),2)
		
		      * Keep the running total for this well current
		      THIS.nWellTot  = THIS.nWellTot - m.ninvamt
		      m.crptgroup = 'D'
		      m.ctype = 'EXP'
		      m.nworkint = THIS.oInvTmp.nworkint
		      m.cownerid = THIS.cownerid
		      m.dacctdate = THIS.dacctdate
		      m.nRunNo = THIS.nRunNo
		      m.cProgCode = THIS.oInvTmp.cProgCode
		      SELE programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         lcprogname = cProgName
		      ELSE
		         lcprogname = ''
		      ENDIF
		
		      * Print the vendor name on the expense line
		      IF THIS.oOptions.lShowVendor
		         m.cmiscmemo = m.cpayee
		      ENDIF
		
		      IF THIS.oInvTmp.nintclass1 <> 0
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group D
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      STORE 0 TO m.ninvamt, m.namount, m.ntotal
		      STORE ' ' TO m.cpayee, m.ccategory, m.cdescript, m.cmiscmemo
		      THIS.oInvTmp.nworkint = jnworkint
		      THIS.oInvTmp.nintclass5 = jnclass5
		      THIS.oInvTmp.nintclass4 = jnclass4
		      THIS.oInvTmp.nintclass3 = jnclass3
		      THIS.oInvTmp.nintclass2 = jnclass2
		      THIS.oInvTmp.nintclass1 = jnclass1
		   ENDSCAN  && Exptemp
		ENDIF
		
		IF THIS.oInvTmp.ntotale2 <> 0
		   SELECT exptemp
		   IF THIS.oOptions.lexpsum
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = '2' AND cCatCode <> 'MKTG' and cYear+cPeriod = THIS.oInvTmp.hyear+this.oInvTmp.hPeriod"
		   ELSE
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND (cyear+cperiod = THIS.oInvTmp.hYear+THIS.oInvTmp.hperiod) AND cexpclass = '2' AND cCatCode <> 'MKTG'"
		   ENDIF
		   SCAN FOR &lcScan
		      IF THIS.oInvTmp.ljib
		         EXIT
		      ENDIF
		
		      SCATTER MEMVAR
		
		      REPL lUsed WITH .T.
		
		      *  Store original interests so we can change for one-man-items.  pws 3/11/97
		      jnworkint = THIS.oInvTmp.nworkint
		      jnclass1  = THIS.oInvTmp.nintclass1
		      jnclass2  = THIS.oInvTmp.nintclass2
		      jnclass3  = THIS.oInvTmp.nintclass3
		      jnclass4  = THIS.oInvTmp.nintclass4
		      jnclass5  = THIS.oInvTmp.nintclass5
		
		      DO CASE
		         CASE m.cownerid = THIS.cownerid AND NOT m.loneman
		            REPLACE loneman WITH .T.
		            THIS.oInvTmp.nintclass2 = 100
		         CASE EMPTY(m.cownerid) OR m.cownerid = SPACE(10)
		            * Don't do anything if the cOwnerID is blank
		         CASE m.cownerid <> THIS.cownerid
		            m.cownerid = THIS.cownerid
		            LOOP
		         CASE m.cownerid = THIS.cownerid AND loneman
		            LOOP
		      ENDCASE
		
		      IF THIS.oInvTmp.nintclass2 = 0
		         LOOP
		      ENDIF
		
		      SELE exptemp
		      REPL lUsed WITH .T.
		
		      m.ccategory = m.ccateg
		
		      * Report Category Descript instead of category name
		      IF THIS.oOptions.lacctdesc AND NOT EMPTY(m.cdescrip)
		         m.ccategory = m.cdescrip
		      ENDIF
		
		      *  Use the item description from the A/P bill for the category.
		      IF THIS.oOptions.lBillDesc AND NOT EMPTY(m.cmemo) AND m.laptran
		         m.ccategory = m.cmemo
		         m.cmemo = ''
		      ENDIF
		
		      THIS.oInvTmp.nworkint  = THIS.oInvTmp.nintclass2
		
		      * Calculate the owner's share of the expense
		      m.ninvamt   = SWROUND((m.namount * (THIS.oInvTmp.nintclass2/100)),2)
		
		      * Keep the running total for this well current
		      THIS.nWellTot  = THIS.nWellTot - m.ninvamt
		      m.crptgroup = 'D'
		      m.ctype = 'EXP'
		      m.nworkint = THIS.oInvTmp.nworkint
		      m.cownerid = THIS.cownerid
		      m.dacctdate = THIS.dacctdate
		      m.nRunNo = THIS.nRunNo
		      m.cProgCode = THIS.oInvTmp.cProgCode
		      SELE programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         lcprogname = cProgName
		      ELSE
		         lcprogname = ''
		      ENDIF
		
		      * Print the vendor name on the expense line
		      IF THIS.oOptions.lShowVendor
		         m.cmiscmemo = m.cpayee
		      ENDIF
		
		      IF THIS.oInvTmp.nintclass2 <> 0
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group D
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		
		      STORE 0 TO m.ninvamt, m.namount, m.ntotal
		      STORE ' ' TO m.cpayee, m.ccategory, m.cdescript, m.cmiscmemo
		      THIS.oInvTmp.nworkint = jnworkint
		      THIS.oInvTmp.nintclass5 = jnclass5
		      THIS.oInvTmp.nintclass4 = jnclass4
		      THIS.oInvTmp.nintclass3 = jnclass3
		      THIS.oInvTmp.nintclass2 = jnclass2
		      THIS.oInvTmp.nintclass1 = jnclass1
		   ENDSCAN  && Exptemp
		ENDIF
		
		IF THIS.oInvTmp.ntotale3 <> 0
		   SELECT exptemp
		   IF THIS.oOptions.lexpsum
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = '3' AND cCatCode <> 'MKTG' and cYear+cPeriod = THIS.oInvTmp.hyear+this.oInvTmp.hPeriod"
		   ELSE
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND (cyear+cperiod = THIS.oInvTmp.hYear+THIS.oInvTmp.hperiod) AND cexpclass = '3' AND cCatCode <> 'MKTG'"
		   ENDIF
		   SCAN FOR &lcScan
		      IF THIS.oInvTmp.ljib
		         EXIT
		      ENDIF
		
		      SCATTER MEMVAR
		
		      REPL lUsed WITH .T.
		
		      *  Store original interests so we can change for one-man-items.  pws 3/11/97
		      jnworkint = THIS.oInvTmp.nworkint
		      jnclass1  = THIS.oInvTmp.nintclass1
		      jnclass2  = THIS.oInvTmp.nintclass2
		      jnclass3  = THIS.oInvTmp.nintclass3
		      jnclass4  = THIS.oInvTmp.nintclass4
		      jnclass5  = THIS.oInvTmp.nintclass5
		
		      DO CASE
		         CASE m.cownerid = THIS.cownerid AND NOT m.loneman
		            REPLACE loneman WITH .T.
		            THIS.oInvTmp.nintclass3 = 100
		         CASE EMPTY(m.cownerid) OR m.cownerid = SPACE(10)
		            * Don't do anything if the cOwnerID is blank
		         CASE m.cownerid <> THIS.cownerid
		            m.cownerid = THIS.cownerid
		            LOOP
		         CASE m.cownerid = THIS.cownerid AND loneman
		            LOOP
		      ENDCASE
		
		      IF THIS.oInvTmp.nintclass3 = 0
		         LOOP
		      ENDIF
		
		      SELE exptemp
		      REPL lUsed WITH .T.
		
		      m.ccategory = m.ccateg
		
		      * Report Category Descript instead of category name
		      IF THIS.oOptions.lacctdesc AND NOT EMPTY(m.cdescrip)
		         m.ccategory = m.cdescrip
		      ENDIF
		
		      *  Use the item description from the A/P bill for the category.
		      IF THIS.oOptions.lBillDesc AND NOT EMPTY(m.cmemo) AND m.laptran
		         m.ccategory = m.cmemo
		         m.cmemo = ''
		      ENDIF
		
		      THIS.oInvTmp.nworkint  = THIS.oInvTmp.nintclass3
		
		      * Calculate the owner's share of the expense
		      m.ninvamt   = SWROUND((m.namount * (THIS.oInvTmp.nintclass3/100)),2)
		
		      * Keep the running total for this well current
		      THIS.nWellTot  = THIS.nWellTot - m.ninvamt
		      m.crptgroup = 'D'
		      m.ctype = 'EXP'
		      m.nworkint = THIS.oInvTmp.nworkint
		      m.cownerid = THIS.cownerid
		      m.dacctdate = THIS.dacctdate
		      m.nRunNo = THIS.nRunNo
		      m.cProgCode = THIS.oInvTmp.cProgCode
		      SELE programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         lcprogname = cProgName
		      ELSE
		         lcprogname = ''
		      ENDIF
		
		      * Print the vendor name on the expense line
		      IF THIS.oOptions.lShowVendor
		         m.cmiscmemo = m.cpayee
		      ENDIF
		
		      IF THIS.oInvTmp.nintclass3 <> 0
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group D
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		
		      STORE 0 TO m.ninvamt, m.namount
		      STORE ' ' TO m.cpayee, m.ccategory, m.cdescript, m.cmiscmemo
		      THIS.oInvTmp.nworkint = jnworkint
		      THIS.oInvTmp.nintclass5 = jnclass5
		      THIS.oInvTmp.nintclass4 = jnclass4
		      THIS.oInvTmp.nintclass3 = jnclass3
		      THIS.oInvTmp.nintclass2 = jnclass2
		      THIS.oInvTmp.nintclass1 = jnclass1
		   ENDSCAN  && Exptemp
		ENDIF
		
		IF THIS.oInvTmp.ntotale4 <> 0
		   SELECT exptemp
		   IF THIS.oOptions.lexpsum
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = '4' AND cCatCode <> 'MKTG' and cYear+cPeriod = THIS.oInvTmp.hyear+this.oInvTmp.hPeriod"
		   ELSE
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND (cyear+cperiod = THIS.oInvTmp.hYear+THIS.oInvTmp.hperiod) AND cexpclass = '4' AND cCatCode <> 'MKTG'"
		   ENDIF
		   SCAN FOR &lcScan
		      IF THIS.oInvTmp.ljib
		         EXIT
		      ENDIF
		
		      SCATTER MEMVAR
		
		      REPL lUsed WITH .T.
		
		      *  Store original interests so we can change for one-man-items.  pws 3/11/97
		      jnworkint = THIS.oInvTmp.nworkint
		      jnclass1  = THIS.oInvTmp.nintclass1
		      jnclass2  = THIS.oInvTmp.nintclass2
		      jnclass3  = THIS.oInvTmp.nintclass3
		      jnclass4  = THIS.oInvTmp.nintclass4
		      jnclass5  = THIS.oInvTmp.nintclass5
		
		      DO CASE
		         CASE m.cownerid = THIS.cownerid AND NOT m.loneman
		            REPLACE loneman WITH .T.
		            THIS.oInvTmp.nintclass4 = 100
		         CASE EMPTY(m.cownerid) OR m.cownerid = SPACE(10)
		            * Don't do anything if the cOwnerID is blank
		         CASE m.cownerid <> THIS.cownerid
		            m.cownerid = THIS.cownerid
		            LOOP
		         CASE m.cownerid = THIS.cownerid AND loneman
		            LOOP
		      ENDCASE
		
		      IF THIS.oInvTmp.nintclass4 = 0
		         LOOP
		      ENDIF
		
		      SELE exptemp
		      REPL lUsed WITH .T.
		
		      m.ccategory = m.ccateg
		
		      * Report Category Descript instead of category name
		      IF THIS.oOptions.lacctdesc AND NOT EMPTY(m.cdescrip)
		         m.ccategory = m.cdescrip
		      ENDIF
		
		      *  Use the item description from the A/P bill for the category.
		      IF THIS.oOptions.lBillDesc AND NOT EMPTY(m.cmemo) AND m.laptran
		         m.ccategory = m.cmemo
		         m.cmemo = ''
		      ENDIF
		
		      THIS.oInvTmp.nworkint  = THIS.oInvTmp.nintclass4
		
		      * Calculate the owner's share of the expense
		      m.ninvamt   = SWROUND((m.namount * (THIS.oInvTmp.nintclass4/100)),2)
		
		      * Keep the running total for this well current
		      THIS.nWellTot  = THIS.nWellTot - m.ninvamt
		      m.crptgroup = 'D'
		      m.ctype = 'EXP'
		      m.nworkint = THIS.oInvTmp.nworkint
		      m.cownerid = THIS.cownerid
		      m.dacctdate = THIS.dacctdate
		      m.nRunNo = THIS.nRunNo
		      m.cProgCode = THIS.oInvTmp.cProgCode
		      SELE programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         lcprogname = cProgName
		      ELSE
		         lcprogname = ''
		      ENDIF
		
		      * Print the vendor name on the expense line
		      IF THIS.oOptions.lShowVendor
		         m.cmiscmemo = m.cpayee
		      ENDIF
		
		      IF THIS.oInvTmp.nintclass4 <> 0
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group D
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      STORE 0 TO m.ninvamt, m.namount
		      STORE ' ' TO m.cpayee, m.ccategory, m.cdescript, m.cmiscmemo
		      THIS.oInvTmp.nworkint = jnworkint
		      THIS.oInvTmp.nintclass5 = jnclass5
		      THIS.oInvTmp.nintclass4 = jnclass4
		      THIS.oInvTmp.nintclass3 = jnclass3
		      THIS.oInvTmp.nintclass2 = jnclass2
		      THIS.oInvTmp.nintclass1 = jnclass1
		   ENDSCAN  && Exptemp
		ENDIF
		
		IF THIS.oInvTmp.ntotale5 <> 0
		   SELECT exptemp
		   IF THIS.oOptions.lexpsum
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = '5' AND cCatCode <> 'MKTG' and cYear+cPeriod = THIS.oInvTmp.hyear+this.oInvTmp.hPeriod"
		   ELSE
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND (cyear+cperiod = THIS.oInvTmp.hYear+THIS.oInvTmp.hperiod) AND cexpclass = '5' AND cCatCode <> 'MKTG'"
		   ENDIF
		   SCAN FOR &lcScan
		      IF THIS.oInvTmp.ljib
		         EXIT
		      ENDIF
		
		      SCATTER MEMVAR
		
		      REPL lUsed WITH .T.
		
		      *  Store original interests so we can change for one-man-items.  pws 3/11/97
		      jnworkint = THIS.oInvTmp.nworkint
		      jnclass1  = THIS.oInvTmp.nintclass1
		      jnclass2  = THIS.oInvTmp.nintclass2
		      jnclass3  = THIS.oInvTmp.nintclass3
		      jnclass4  = THIS.oInvTmp.nintclass4
		      jnclass5  = THIS.oInvTmp.nintclass5
		
		      DO CASE
		         CASE m.cownerid = THIS.cownerid AND NOT m.loneman
		            REPLACE loneman WITH .T.
		            THIS.oInvTmp.nintclass5 = 100
		         CASE EMPTY(m.cownerid) OR m.cownerid = SPACE(10)
		            * Don't do anything if the cOwnerID is blank
		         CASE m.cownerid <> THIS.cownerid
		            m.cownerid = THIS.cownerid
		            LOOP
		         CASE m.cownerid = THIS.cownerid AND loneman
		            LOOP
		      ENDCASE
		
		      IF THIS.oInvTmp.nintclass5 = 0
		         LOOP
		      ENDIF
		
		      SELE exptemp
		      REPL lUsed WITH .T.
		
		      m.ccategory = m.ccateg
		
		      * Report Category Descript instead of category name
		      IF THIS.oOptions.lacctdesc AND NOT EMPTY(m.cdescrip)
		         m.ccategory = m.cdescrip
		      ENDIF
		
		      *  Use the item description from the A/P bill for the category.
		      IF THIS.oOptions.lBillDesc AND NOT EMPTY(m.cmemo) AND m.laptran
		         m.ccategory = m.cmemo
		         m.cmemo = ''
		      ENDIF
		
		      THIS.oInvTmp.nworkint  = THIS.oInvTmp.nintclass5
		
		      * Calculate the owner's share of the expense
		      m.ninvamt   = SWROUND((m.namount * (THIS.oInvTmp.nintclass5/100)),2)
		
		      * Keep the running total for this well current
		      THIS.nWellTot  = THIS.nWellTot - m.ninvamt
		      m.crptgroup = 'D'
		      m.ctype = 'EXP'
		      m.nworkint = THIS.oInvTmp.nworkint
		      m.cownerid = THIS.cownerid
		      m.dacctdate = THIS.dacctdate
		      m.nRunNo = THIS.nRunNo
		      m.cProgCode = THIS.oInvTmp.cProgCode
		      SELE programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         lcprogname = cProgName
		      ELSE
		         lcprogname = ''
		      ENDIF
		
		      * Print the vendor name on the expense line
		      IF THIS.oOptions.lShowVendor
		         m.cmiscmemo = m.cpayee
		      ENDIF
		
		      IF THIS.oInvTmp.nintclass5 <> 0
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group D
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      STORE 0 TO m.ninvamt, m.namount
		      STORE ' ' TO m.cpayee, m.ccategory, m.cdescript, m.cmiscmemo
		      THIS.oInvTmp.nworkint = jnworkint
		      THIS.oInvTmp.nintclass5 = jnclass5
		      THIS.oInvTmp.nintclass4 = jnclass4
		      THIS.oInvTmp.nintclass3 = jnclass3
		      THIS.oInvTmp.nintclass2 = jnclass2
		      THIS.oInvTmp.nintclass1 = jnclass1
		   ENDSCAN  && Exptemp
		ENDIF
		
		IF THIS.oInvTmp.ntotalea <> 0
		   SELECT exptemp
		   IF THIS.oOptions.lexpsum
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = 'A' AND cCatCode <> 'MKTG' and cYear+cPeriod = THIS.oInvTmp.hyear+this.oInvTmp.hPeriod"
		   ELSE
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND (cyear+cperiod = THIS.oInvTmp.hYear+THIS.oInvTmp.hperiod) AND cexpclass = 'A' AND cCatCode <> 'MKTG'"
		   ENDIF
		   SCAN FOR &lcScan
		      IF THIS.oInvTmp.ljib
		         EXIT
		      ENDIF
		
		      SCATTER MEMVAR
		
		      REPL lUsed WITH .T.
		
		      *  Store original interests so we can change for one-man-items.  pws 3/11/97
		      jnworkint = THIS.oInvTmp.nworkint
		      jnclass1  = THIS.oInvTmp.nintclass1
		      jnclass2  = THIS.oInvTmp.nintclass2
		      jnclass3  = THIS.oInvTmp.nintclass3
		      jnclass4  = THIS.oInvTmp.nintclass4
		      jnclass5  = THIS.oInvTmp.nintclass5
		      jnclassa  = THIS.oInvTmp.nacpint
		      jnclassb  = THIS.oInvTmp.nbcpint
		
		      DO CASE
		         CASE m.cownerid = THIS.cownerid AND NOT m.loneman
		            REPLACE loneman WITH .T.
		            m.nacpint = 100
		            THIS.oInvTmp.nacpint = 100
		         CASE EMPTY(m.cownerid) OR m.cownerid = SPACE(10)
		            * Don't do anything if the cOwnerID is blank
		         CASE m.cownerid <> THIS.cownerid
		            m.cownerid = THIS.cownerid
		            LOOP
		         CASE m.cownerid = THIS.cownerid AND loneman
		            LOOP
		      ENDCASE
		
		      IF THIS.oInvTmp.nacpint = 0
		         LOOP
		      ENDIF
		
		      SELE exptemp
		      REPL lUsed WITH .T.
		
		      m.ccategory = m.ccateg
		
		      * Report Category Descript instead of category name
		      IF THIS.oOptions.lacctdesc AND NOT EMPTY(m.cdescrip)
		         m.ccategory = m.cdescrip
		      ENDIF
		
		      *  Use the item description from the A/P bill for the category.
		      IF THIS.oOptions.lBillDesc AND NOT EMPTY(m.cmemo) AND m.laptran
		         m.ccategory = m.cmemo
		         m.cmemo = ''
		      ENDIF
		
		      THIS.oInvTmp.nworkint  = THIS.oInvTmp.nacpint
		
		      * Calculate the owner's share of the expense
		      m.ninvamt   = SWROUND((m.namount * (THIS.oInvTmp.nacpint/100)),2)
		
		      * Keep the running total for this well current
		      THIS.nWellTot  = THIS.nWellTot - m.ninvamt
		      m.crptgroup = 'D'
		      m.ctype = 'EXP'
		      m.nworkint = THIS.oInvTmp.nworkint
		      m.cownerid = THIS.cownerid
		      m.dacctdate = THIS.dacctdate
		      m.nRunNo = THIS.nRunNo
		      m.cProgCode = THIS.oInvTmp.cProgCode
		      SELE programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         lcprogname = cProgName
		      ELSE
		         lcprogname = ''
		      ENDIF
		
		      * Print the vendor name on the expense line
		      IF THIS.oOptions.lShowVendor
		         m.cmiscmemo = m.cpayee
		      ENDIF
		
		      IF THIS.oInvTmp.nacpint <> 0
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group D
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      STORE 0 TO m.ninvamt, m.namount
		      STORE ' ' TO m.cpayee, m.ccategory, m.cdescript, m.cmiscmemo
		      THIS.oInvTmp.nworkint = jnworkint
		      THIS.oInvTmp.nintclass5 = jnclass5
		      THIS.oInvTmp.nintclass4 = jnclass4
		      THIS.oInvTmp.nintclass3 = jnclass3
		      THIS.oInvTmp.nintclass2 = jnclass2
		      THIS.oInvTmp.nintclass1 = jnclass1
		      THIS.oInvTmp.nacpint    = jnclassa
		      THIS.oInvTmp.nbcpint    = jnclassb
		   ENDSCAN  && Exptemp
		ENDIF
		
		IF THIS.oInvTmp.ntotaleb <> 0
		   SELECT exptemp
		   IF THIS.oOptions.lexpsum
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND NOT lUsed AND cexpclass = 'B' AND cCatCode <> 'MKTG' and cYear+cPeriod = THIS.oInvTmp.hyear+this.oInvTmp.hPeriod"
		   ELSE
		      lcScan = "cwellid = THIS.oInvTmp.cwellid  AND (cyear+cperiod = THIS.oInvTmp.hYear+THIS.oInvTmp.hperiod) AND cexpclass = 'B' AND cCatCode <> 'MKTG'"
		   ENDIF
		   SCAN FOR &lcScan
		      IF THIS.oInvTmp.ljib
		         EXIT
		      ENDIF
		
		      SCATTER MEMVAR
		
		      REPL lUsed WITH .T.
		
		      *  Store original interests so we can change for one-man-items.  pws 3/11/97
		      jnworkint = THIS.oInvTmp.nworkint
		      jnclass1  = THIS.oInvTmp.nintclass1
		      jnclass2  = THIS.oInvTmp.nintclass2
		      jnclass3  = THIS.oInvTmp.nintclass3
		      jnclass4  = THIS.oInvTmp.nintclass4
		      jnclass5  = THIS.oInvTmp.nintclass5
		      jnclassa  = THIS.oInvTmp.nacpint
		      jnclassb  = THIS.oInvTmp.nbcpint
		
		      DO CASE
		         CASE m.cownerid = THIS.cownerid AND NOT m.loneman
		            REPLACE loneman WITH .T.
		            m.nbcpint = 100
		            THIS.oInvTmp.nbcpint = 100
		         CASE EMPTY(m.cownerid) OR m.cownerid = SPACE(10)
		            * Don't do anything if the cOwnerID is blank
		         CASE m.cownerid <> THIS.cownerid
		            m.cownerid = THIS.cownerid
		            LOOP
		         CASE m.cownerid = THIS.cownerid AND loneman
		            LOOP
		      ENDCASE
		
		      IF THIS.oInvTmp.nbcpint = 0
		         LOOP
		      ENDIF
		
		      SELE exptemp
		      REPL lUsed WITH .T.
		
		      m.ccategory = m.ccateg
		
		      * Report Category Descript instead of category name
		      IF THIS.oOptions.lacctdesc AND NOT EMPTY(m.cdescrip)
		         m.ccategory = m.cdescrip
		      ENDIF
		
		      *  Use the item description from the A/P bill for the category.
		      IF THIS.oOptions.lBillDesc AND NOT EMPTY(m.cmemo) AND m.laptran
		         m.ccategory = m.cmemo
		         m.cmemo = ''
		      ENDIF
		
		      THIS.oInvTmp.nworkint  = THIS.oInvTmp.nbcpint
		
		      * Calculate the owner's share of the expense
		      m.ninvamt   = SWROUND((m.namount * (THIS.oInvTmp.nbcpint/100)),2)
		
		      * Keep the running total for this well current
		      THIS.nWellTot   = THIS.nWellTot - m.ninvamt
		
		      m.crptgroup = 'D'
		      m.ctype = 'EXP'
		      m.nworkint = THIS.oInvTmp.nworkint
		      m.cownerid = THIS.cownerid
		      m.dacctdate = THIS.dacctdate
		      m.nRunNo = THIS.nRunNo
		      m.cProgCode = THIS.oInvTmp.cProgCode
		      SELE programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         lcprogname = cProgName
		      ELSE
		         lcprogname = ''
		      ENDIF
		
		      * Print the vendor name on the expense line
		      IF THIS.oOptions.lShowVendor
		         m.cmiscmemo = m.cpayee
		      ENDIF
		
		      IF THIS.oInvTmp.nbcpint <> 0
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group D
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      STORE 0 TO m.ninvamt, m.namount
		      STORE ' ' TO m.cpayee, m.ccategory, m.cdescript, m.cmiscmemo
		      THIS.oInvTmp.nworkint   = jnworkint
		      THIS.oInvTmp.nintclass5 = jnclass5
		      THIS.oInvTmp.nintclass4 = jnclass4
		      THIS.oInvTmp.nintclass3 = jnclass3
		      THIS.oInvTmp.nintclass2 = jnclass2
		      THIS.oInvTmp.nintclass1 = jnclass1
		      THIS.oInvTmp.nacpint    = jnclassa
		      THIS.oInvTmp.nbcpint    = jnclassb
		   ENDSCAN  && Exptemp
		ENDIF
		
	ENDPROC

	PROCEDURE calcincome		&& Calculates income section
		LPARA m.cWellID, tnRunNo, tcYear, tcPeriod, tdAcctDate
		
		m.cDirect = THIS.oInvTmp.cDirect
		
		create cursor temptax ;
		 (cwellid    c(10), ;
		  noiltax1   n(9,2), ;
		  noiltax2   n(9,2), ;
		  noiltax3   n(9,2), ;
		  noiltax4   n(9,2), ;
		  ngastax1   n(9,2), ;
		  ngastax2   n(9,2), ;
		  ngastax3   n(9,2), ;
		  ngastax4   n(9,2))
		
		SELECT income
		jflatcnt = 0
		STORE 0 TO THIS.nTotalBBL, THIS.nTotalMCF, jnrevoil, jnrevgas, jnworkint, ;
		   THIS.nOilAmount, THIS.nGasAmount, THIS.nOtherAmount, THIS.nTotalOther, ;
		   jnrevoth, THIS.noiltax1, THIS.noiltax2, THIS.noiltax3, THIS.noiltax4, ;
		   THIS.ngastax1, THIS.ngastax2, THIS.ngastax3, THIS.ngastax4, THIS.nothtax1, THIS.nothtax2, THIS.nothtax3, THIS.nothtax4
		STORE 0 TO m.noiltax1, m.ngastax1, m.noiltax2, m.ngastax2, m.noiltax3, m.ngastax3, m.noiltax4, m.ngastax4   
		SCAN FOR cWellID=m.cWellID AND IIF(tnRunNo=0,nRunno=0,nRunno=tnRunNo AND crunyear=this.cRunYear) AND cyear+cperiod = tcYear+tcPeriod AND drevdate <= tdAcctDate
		   m.crptgroup = 'B'
		   m.cdescript = ' '
		   m.namount   = 0
		   m.dexpdate  = drevdate
		   IF NOT EMPTY(ndayson)
		      m.ndayson   = ndayson
		   ENDIF
		
		   m.ntotalinc = ntotalinc
		   jnrevoil  = THIS.oInvTmp.nrevoil
		   jnrevgas  = THIS.oInvTmp.nrevgas
		   jnrevtax1 = THIS.oInvTmp.nrevtax1
		   jnrevtax2 = THIS.oInvTmp.nrevtax2
		   jnrevtax3 = THIS.oInvTmp.nrevtax3
		   jnrevtax4 = THIS.oInvTmp.nrevtax4
		   jnrevtax5 = THIS.oInvTmp.nrevtax5
		   jnrevtax6 = THIS.oInvTmp.nrevtax6
		   jnrevtax7 = THIS.oInvTmp.nrevtax7
		   jnrevtax8 = THIS.oInvTmp.nrevtax8
		   jnrevtax9 = THIS.oInvTmp.nrevtax9
		   jnrevtax10 = THIS.oInvTmp.nrevtax10
		   jnrevtax11 = THIS.oInvTmp.nrevtax11
		   jnrevtax12 = THIS.oInvTmp.nrevtax12
		   jnrevm1   = THIS.oInvTmp.nrevmisc1
		   jnrevm2   = THIS.oInvTmp.nrevmisc2
		   jnrevoth  = THIS.oInvTmp.nrevoth
		   m.cProgCode = THIS.oInvTmp.cProgCode
		
		   IF 'TAX' $ csource AND THIS.lOwnerTaxExempt
		      LOOP
		   ENDIF
		   DO CASE
		      CASE cownerid = THIS.cownerid AND NOT loneman
		         REPLACE loneman WITH .T.
		         DO CASE
		            CASE csource = 'BBL'
		               THIS.oInvTmp.nrevoil = 100
		            CASE csource = 'EXO'
		               THIS.oInvTmp.nrevoil = 100
		            CASE csource = 'MCF'
		               THIS.oInvTmp.nrevgas = 100
		            CASE csource = 'OTH'
		               THIS.oInvTmp.nrevoth = 100
		            CASE csource = 'EXG'
		               THIS.oInvTmp.nrevgas = 100
		            CASE csource = 'OTAX1'
		               THIS.oInvTmp.nrevtax1 = 100
		            CASE csource = 'GTAX1'
		               THIS.oInvTmp.nrevtax2 = 100
		            CASE csource = 'PTAX1'
		               THIS.oInvTmp.nrevtax3 = 100
		            CASE csource = 'OTAX2'
		               THIS.oInvTmp.nrevtax4 = 100
		            CASE csource = 'GTAX2'
		               THIS.oInvTmp.nrevtax5 = 100
		            CASE csource = 'PTAX2'
		               THIS.oInvTmp.nrevtax6 = 100
		            CASE csource = 'OTAX3'
		               THIS.oInvTmp.nrevtax7 = 100
		            CASE csource = 'GTAX3'
		               THIS.oInvTmp.nrevtax8 = 100
		            CASE csource = 'PTAX3'
		               THIS.oInvTmp.nrevtax9 = 100
		            CASE csource = 'OTAX4'
		               THIS.oInvTmp.nrevtax10 = 100
		            CASE csource = 'GTAX4'
		               THIS.oInvTmp.nrevtax11 = 100
		            CASE csource = 'PTAX4'
		               THIS.oInvTmp.nrevtax12 = 100
		            CASE INLIST(csource,'NOT','NTL','NTO','NTR','NTW')
		               THIS.oInvTmp.nrevint = 100
		            CASE csource = 'MISC1'
		               THIS.oInvTmp.nrevmisc1 = 100
		            CASE csource = 'MISC2'
		               THIS.oInvTmp.nrevmisc2 = 100
		         ENDCASE
		      CASE EMPTY(cownerid) OR cownerid = SPACE(10)
		      CASE cownerid = THIS.cownerid AND loneman
		         LOOP
		      CASE cownerid <> THIS.cownerid
		         LOOP
		   ENDCASE
		   DO CASE
		      CASE csource = 'BBL'
		         m.nrevint = THIS.oInvTmp.nrevoil
		         THIS.nTotalBBL  = THIS.nTotalBBL + nunits
		         THIS.nOilAmount  = THIS.nOilAmount + m.ntotalinc
		      CASE csource = 'MCF'
		         m.nrevint = THIS.oInvTmp.nrevgas
		         THIS.nTotalMCF  = THIS.nTotalMCF + nunits
		         THIS.nGasAmount  = THIS.nGasAmount + m.ntotalinc
		      CASE csource = 'OTH'
		         m.nrevint = THIS.oInvTmp.nrevoth
		         THIS.nTotalOther  = THIS.nTotalOther + nunits
		         THIS.nOtherAmount  = THIS.nOtherAmount + m.ntotalinc
		      CASE csource = 'TRANS'
		         m.nrevint = THIS.oInvTmp.nrevtrp
		      CASE csource = 'NOT'
		         m.nrevint = 1
		      CASE csource = 'MISC1'
		         m.nrevint = THIS.oInvTmp.nrevmisc1
		      CASE csource = 'MISC2'
		         m.nrevint = THIS.oInvTmp.nrevmisc2
		      CASE csource = 'OTAX1'
		        m.noiltax1 = m.noiltax1 + m.ntotalinc
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax1
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax1
		            ENDIF
		         ENDIF
		      CASE csource = 'GTAX1'
		         m.ngastax1 = m.ngastax1 + m.ntotalinc
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax2
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax2
		            ENDIF
		         ENDIF
		      CASE csource = 'PTAX1'
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax3
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax3
		            ENDIF
		         ENDIF
		      CASE csource = 'OTAX2'
		         m.noiltax2 = m.noiltax2 + m.ntotalinc
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax4
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax4
		            ENDIF
		         ENDIF
		      CASE csource = 'GTAX2'
		         m.ngastax2 = m.ngastax2 + m.ntotalinc
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax5
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax5
		            ENDIF
		         ENDIF
		      CASE csource = 'PTAX2'
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax6
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax6
		            ENDIF
		         ENDIF
		      CASE csource = 'OTAX3'
		         m.noiltax3 = m.noiltax3 + m.ntotalinc
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax7
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax7
		            ENDIF
		         ENDIF
		      CASE csource = 'GTAX3'
		         m.ngastax3 = m.ngastax3 + m.ntotalinc
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax8
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax8
		            ENDIF
		         ENDIF
		      CASE csource = 'PTAX3'
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax9
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax9
		            ENDIF
		         ENDIF
		      CASE csource = 'OTAX4'
		         m.noiltax4 = m.noiltax4 + m.ntotalinc
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax10
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax10
		            ENDIF
		         ENDIF
		      CASE csource = 'GTAX4'
		         m.ngastax4 = m.ngastax4 + m.ntotalinc
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax11
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax11
		            ENDIF
		         ENDIF
		      CASE csource = 'PTAX4'
		         IF NOT THIS.lRoyaltyOwner
		            IF THIS.lExemptRoyalty
		               m.nrevint = THIS.oInvTmp.nworkint
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax12
		            ENDIF
		         ELSE
		            IF THIS.lExemptRoyalty
		               m.nrevint = 0
		            ELSE
		               m.nrevint = THIS.oInvTmp.nrevtax12
		            ENDIF
		         ENDIF
		      CASE csource = 'EXO'
		         m.nrevint = THIS.oInvTmp.nworkint
		      CASE csource = 'EXG'
		         m.nrevint = THIS.oInvTmp.nworkint
		   ENDCASE
		   IF THIS.oInvTmp.ctypeint = 'O' AND INLIST(csource,'MCF','GTAX1','GTAX2','GTAX3','GTAX4','EXG')
		      m.nrevint = 0
		      THIS.oInvTmp.nrevgas = 0
		   ENDIF
		   IF THIS.oInvTmp.ctypeint = 'G' AND INLIST(csource,'BBL','OTAX1','OTAX2','OTAX3','OTAX4','EXO')
		      m.nrevint = 0
		      THIS.oInvTmp.nrevoil = 0
		   ENDIF
		   IF csource <> 'EXG' AND csource <> 'EXO'
		      SELECT revsrc
		      SET ORDER TO crevkey
		      IF SEEK(income.crevkey)
		         m.csource = revsrc.crevname
		      ELSE
		         m.csource = 'Unknown'
		      ENDIF
		   ELSE
		      m.csource = cmemo
		   ENDIF
		   SELECT income
		   m.ctype   = csource
		   m.nunits  = nunits
		   m.nprice  = nprice
		   m.cperiod = cperiod
		   m.cyear   = cyear
		   m.crefid  = crefid
		   m.crange  = ALLTRIM(cbegrange)+'-'+ALLTRIM(cendrange)
		   IF income.cbegrange = '  /  ' OR income.cendrange = '  /  '
		      m.crange = ''
		   ENDIF
		   
		   * Setup price if it was left blank
		   IF nprice = 0
		      IF nunits <> 0 AND ntotalinc <> 0
		         REPLACE nprice WITH ROUND(ntotalinc/nunits,4)
		      ENDIF 
		   ENDIF 
		      
		   IF (THIS.lRoyaltyOwner AND THIS.oOptions.lchgprice) OR THIS.oOptions.lhidecomp
		      m.nprice = nprice
		      jgross  = m.ntotalinc
		      IF m.lcompress AND m.ctype = 'MCF'
		         m.nprice = m.nprice - THIS.ncompress
		         jgross  = jgross - ROUND(THIS.ncompress * nunits,2)
		      ENDIF
		      IF m.lgather AND m.ctype = 'MCF'
		         m.nprice = m.nprice - THIS.ngather
		         jgross  = jgross - ROUND(THIS.ngather * nunits,2)
		      ENDIF
		   ELSE
		      m.nprice = nprice
		      jgross  = m.ntotalinc
		   ENDIF
		   
		   *
		   *  Check if this investor is a cDirect pay or a flat rate Royalty
		   *
		
		   DO CASE
		      CASE INLIST(THIS.oInvTmp.cDirect,'O','B') AND INLIST(m.ctype,'BBL','OTAX1','OTAX2','OTAX3','OTAX4','EXO') AND NOT THIS.oInvTmp.lflat
		         *
		         *  If the owner is directly paid oil revenue and oil is being processed, zero out his totals on revenue
		         *
		         m.ninvamt = 0
		         m.ntotal  = 0
		         m.nworktot = 0
		         DO CASE
		            CASE m.ctype = 'OTAX1'
		               IF m.lExempt
		                  * Owner is exempt from tax. Zero out taxes
		                  m.nworktot = 0
		                  lnoiltax1 = 0
		               ELSE
		                  IF NOT m.lSev1O
		                     * Purchaser doesn't withhold, so subtract it
		                     m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                  ELSE
		                     * Purchaser pays revenue directly, so mark as directly paid
		                     IF NOT m.lDirOilPurch
		                        * Purchaser doesn't withhold tax on directly paid owners
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser withholds tax on direct paid revenue
		                        m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                     ENDIF
		                  ENDIF
		               ENDIF
		            CASE m.ctype = 'OTAX2'
		               IF m.lExempt
		                  * Owner is exempt from tax. Zero out taxes
		                  m.nworktot = 0
		                  lnoiltax2 = 0
		               ELSE
		                  IF NOT m.lSev2O
		                     * Purchaser doesn't pay, so subtract it
		                     m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                  ELSE
		                     * Purchaser pays directly, so mark as directly paid
		                     IF NOT m.lDirOilPurch
		                        * Purchaser doesn't withhold tax on directly paid owners
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser withholds tax on direct paid revenue
		                        m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                     ENDIF
		                  ENDIF
		               ENDIF
		            CASE m.ctype = 'OTAX3'
		               IF m.lExempt
		                  * Owner is exempt from tax. Zero out taxes
		                  m.nworktot = 0
		                  lnoiltax3 = 0
		               ELSE
		                  IF NOT m.lSev3O
		                     * Purchaser doesn't pay, so subtract it
		                     m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                  ELSE
		                     * Purchaser pay, so mark as directly paid
		                     IF NOT m.lDirOilPurch
		                        * Purchaser doesn't withhold tax on directly paid owners
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser withholds tax on direct paid revenue
		                        m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                     ENDIF
		                  ENDIF
		               ENDIF
		            CASE m.ctype = 'OTAX4'
		               IF m.lExempt
		                  * Owner is exempt from tax. Zero out taxes
		                  m.nworktot = 0
		                  lnoiltax4 = 0
		               ELSE
		                  IF NOT m.lSev4O
		                     * Purchaser doesn't pay directly, so subtract it
		                     m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                  ELSE
		                     * Purchaser pays directly, so mark as directly paid
		                     IF NOT m.lDirOilPurch
		                        * Purchaser doesn't withhold tax on directly paid owners
		                        m.ninvamt  = SWROUND((jgross*(m.nrevint/100)),2)
		                     ELSE
		                        * Purchaser withholds tax on direct paid revenue
		                        m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		                     ENDIF
		                  ENDIF
		               ENDIF
		            OTHERWISE
		               * Oil Revenue, not taxes
		               m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		         ENDCASE
		      CASE INLIST(THIS.oInvTmp.cDirect,'G','B') AND INLIST(m.ctype,'MCF','GTAX1','GTAX2','GTAX3','GTAX4','EXG') AND NOT THIS.oInvTmp.lflat
		         *
		         *  He is, so zero out his totals on nIncome
		         *
		         m.ninvamt = 0
		         m.ntotal  = 0
		         IF INLIST(m.ctype,'GTAX1','GTAX2','GTAX3','GTAX4')
		            IF THIS.lRoyaltyOwner AND NOT THIS.lOwnerTaxExempt
		               m.ninvamt = SWROUND(m.ntotal*(m.nrevint/100),2)
		               m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		            ENDIF
		            IF NOT THIS.lRoyaltyOwner AND NOT THIS.lOwnerTaxExempt
		               m.ninvamt = SWROUND(m.ntotal*(m.nrevint/100),2)
		               m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		            ENDIF
		         ELSE
		            m.nworktot = SWROUND(jgross*(m.nrevint/100),2)
		         ENDIF
		      CASE INLIST(THIS.oInvTmp.cDirect,'G','B') AND m.ctype = 'MCF' AND THIS.oInvTmp.lflat AND THIS.oInvTmp.ctypeint = 'G'
		         IF jflatcnt = 0
		            m.ninvamt = SWROUND(m.nflatrate * (THIS.oInvTmp.nworkint/100),2)
		            m.ntotal  = 0
		            m.nworktot = m.nflatrate
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		            m.cdescript = ' '
		            jflatcnt = 1
		         ELSE
		            m.ninvamt = 0
		         ENDIF
		      CASE INLIST(THIS.oInvTmp.cDirect,'O','B') AND m.ctype = 'BBL' AND THIS.oInvTmp.lflat AND THIS.oInvTmp.ctypeint = 'O'
		         IF jflatcnt = 0
		            m.ninvamt = SWROUND(m.nflatrate * (THIS.oInvTmp.nworkint/100),2)
		            m.ntotal  = 0
		            m.nworktot = m.nflatrate
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		            m.cdescript = ' '
		            jflatcnt = 1
		         ELSE
		            m.ninvamt = 0
		         ENDIF
		      OTHERWISE
		         *
		         *  He isn't, so let the nIncome flow through
		         *
		         IF NOT THIS.oOptions.lhidecomp
		            IF THIS.lRoyaltyOwner AND THIS.oOptions.lchgprice AND m.ctype = 'MCF'
		            
		               m.ntotal = m.nunits * m.nprice
		            ELSE
		               m.ntotal   = jgross             && Re-establish total
		            ENDIF
		         ELSE
		            m.ntotal   = jgross             && Re-establish total
		         ENDIF
		         IF SUBST(m.ctype,2,3) = 'TAX'
		            IF NOT THIS.lOwnerTaxExempt
		               m.ninvamt = SWROUND(m.ntotal*(m.nrevint/100),2)
		            ENDIF
		         ELSE
		            m.ninvamt = SWROUND(m.ntotal*(m.nrevint/100),2)
		         ENDIF
		
		   ENDCASE
		   IF NOT THIS.oOptions.lhidecomp
		      IF THIS.lRoyaltyOwner AND THIS.oOptions.lchgprice
		         m.ntotal = m.nunits * m.nprice
		      ELSE
		         m.ntotal   = jgross             && Re-establish total
		      ENDIF
		   ELSE
		      m.ntotal   = jgross             && Re-establish total
		   ENDIF
		   THIS.nTotInc  = THIS.nTotInc + m.ninvamt
		   THIS.nWellTot = THIS.nWellTot + m.ninvamt
		   *
		   *  Check to see if this investor gets gas or oil interest
		   *  If not, don't show that nIncome on his cStatement
		   *
		   DO CASE
		      CASE m.ctype = 'BBL' AND THIS.oInvTmp.nrevoil > 0
		         IF THIS.oInvTmp.cDirect = 'G'
		            THIS.oInvTmp.cDirect = 'N'
		         ENDIF
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      CASE m.ctype = 'EXO' AND THIS.oInvTmp.nrevoil > 0
		         IF THIS.oInvTmp.cDirect = 'G'
		            THIS.oInvTmp.cDirect = 'N'
		         ENDIF
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      CASE m.ctype = 'MCF' AND THIS.oInvTmp.nrevgas > 0
		         IF THIS.oInvTmp.cDirect = 'O'
		            m.cDirect = 'N'
		         ENDIF
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      CASE m.ctype = 'EXG' AND THIS.oInvTmp.nrevgas > 0
		         IF THIS.oInvTmp.cDirect = 'O'
		            m.cDirect = 'N'
		         ENDIF
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      CASE m.ctype = 'OTH' AND THIS.oInvTmp.nrevoth > 0
		         *         THIS.oInvTmp.cdirect = 'O'
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      CASE m.ctype = 'TRANS' AND THIS.oInvTmp.nrevtrp > 0
		         m.ctype   = 'TRP'
		         m.cDirect = 'N'
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.ctype   = 'TRANS'
		      CASE m.ctype = 'MISC1' AND THIS.oInvTmp.nrevmisc1 > 0
		         m.ctype   = 'MI1'
		         m.cDirect = 'N'
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.ctype   = 'MISC1'
		      CASE m.ctype = 'MISC2' AND THIS.oInvTmp.nrevmisc2 > 0
		         m.ctype   = 'MI2'
		         m.cDirect = 'N'
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.ctype   = 'MISC2'
		      CASE m.ctype = 'OTAX1' AND THIS.oInvTmp.nrevtax1 > 0
		         THIS.noiltax1 = m.ninvamt
		         THIS.noiltax1  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX1'
		         IF m.cDirect = 'O' OR m.cDirect = 'B'
		            DO CASE
		               CASE THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     *                     m.cdirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		               CASE NOT THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     *                     m.cdirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		            ENDCASE
		         ELSE
		            m.cDirect = 'N'
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         m.ctype = 'OTAX1'
		      CASE m.ctype = 'GTAX1' AND THIS.oInvTmp.nrevtax2 > 0
		
		         THIS.ngastax1 = m.ninvamt
		         THIS.ngastax1  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX2'
		         IF m.cDirect = 'G' OR m.cDirect = 'B'
		            DO CASE
		               CASE THIS.lRoyaltyOwner
		                  IF THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		               CASE NOT THIS.lRoyaltyOwner
		                  IF THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		            ENDCASE
		         ELSE
		            m.cDirect = 'N'
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         m.ctype = 'GTAX1'
		      CASE m.ctype = 'OTAX2' AND THIS.oInvTmp.nrevtax4 > 0
		         THIS.noiltax2 = m.ninvamt
		         THIS.noiltax2  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX4'
		         IF m.cDirect = 'O' OR m.cDirect = 'B'
		            DO CASE
		               CASE THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		               CASE NOT THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		            ENDCASE
		         ELSE
		            m.cDirect = 'N'
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         m.ctype = 'OTAX2'
		      CASE m.ctype = 'GTAX2' AND THIS.oInvTmp.nrevtax5 > 0
		         THIS.ngastax2 = m.ninvamt
		         THIS.ngastax2  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX5'
		         IF m.cDirect = 'G' OR m.cDirect = 'B'
		            DO CASE
		               CASE THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		               CASE NOT THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		            ENDCASE
		         ELSE
		            m.cDirect = 'N'
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         m.ctype = 'GTAX2'
		      CASE m.ctype = 'OTAX3' AND THIS.oInvTmp.nrevtax7 > 0
		         THIS.noiltax3 = m.ninvamt
		         THIS.noiltax3  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX7'
		         IF m.cDirect = 'O' OR m.cDirect = 'B'
		            DO CASE
		               CASE THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		               CASE NOT THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		            ENDCASE
		         ELSE
		            m.cDirect = 'N'
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         m.ctype = 'OTAX3'
		      CASE m.ctype = 'GTAX3' AND THIS.oInvTmp.nrevtax8 > 0
		         THIS.ngastax3 = m.ninvamt
		         THIS.ngastax3  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX8'
		         IF m.cDirect = 'G' OR m.cDirect = 'B'
		            DO CASE
		               CASE THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		               CASE NOT THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		            ENDCASE
		         ELSE
		            m.cDirect = 'N'
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         m.ctype = 'GTAX3'
		      CASE m.ctype = 'OTAX4' AND THIS.oInvTmp.nrevtax10 > 0
		         THIS.noiltax4 = m.ninvamt
		         THIS.noiltax4  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX10'
		         IF m.cDirect = 'O' OR m.cDirect = 'B'
		            DO CASE
		               CASE THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		               CASE NOT THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		            ENDCASE
		         ELSE
		            m.cDirect = 'N'
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         m.ctype = 'OTAX4'
		      CASE m.ctype = 'GTAX4' AND THIS.oInvTmp.nrevtax11 > 0
		         THIS.ngastax4 = m.ninvamt
		         THIS.ngastax4  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX11'
		         IF m.cDirect = 'G' OR m.cDirect = 'B'
		            DO CASE
		               CASE THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		               CASE NOT THIS.lRoyaltyOwner
		                  IF NOT THIS.lOwnerTaxExempt
		                     m.cDirect = 'N'
		                     m.cownerid = THIS.cownerid
		                     m.nRunno = THIS.nRunno
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group B
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		            ENDCASE
		         ELSE
		            m.cDirect = 'N'
		            m.cownerid = THIS.cownerid
		            m.nRunno = THIS.nRunno
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         m.ctype = 'GTAX4'
		      CASE m.ctype = 'PTAX1' AND THIS.oInvTmp.nrevtax3 > 0
		         THIS.nothtax1 = m.ninvamt
		         THIS.nothtax1  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX3'
		         m.cDirect = 'N'
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.ctype = 'PTAX1'
		      CASE m.ctype = 'PTAX2' AND THIS.oInvTmp.nrevtax6 > 0
		         THIS.nothtax2 = m.ninvamt
		         THIS.nothtax2  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX6'
		         m.cDirect = 'N'
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.ctype = 'PTAX2'
		      CASE m.ctype = 'PTAX3' AND THIS.oInvTmp.nrevtax9 > 0
		         THIS.nothtax3 = m.ninvamt
		         THIS.nothtax3  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX9'
		         m.cDirect = 'N'
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.ctype = 'PTAX3'
		      CASE m.ctype = 'PTAX4' AND THIS.oInvTmp.nrevtax12 > 0
		         THIS.nothtax4 = m.ninvamt
		         THIS.nothtax4  = m.ntotal
		
		         SELECT revcat  &&  Plug in description from the revcat table, instead of using the purchaser name - BH 06/08/2004
		         LOCATE FOR crevtype = m.ctype
		         IF FOUND()
		            m.csource = revcat.cRevDesc
		         ENDIF
		
		         m.ctype = 'TX12'
		         m.cDirect = 'N'
		         m.cownerid = THIS.cownerid
		         m.nRunno = THIS.nRunno
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.ctype = 'PTAX4'
		   ENDCASE
		
		   * Restore original interests that may have been changed by one-man-item processing.
		   THIS.oInvTmp.nrevoil   = jnrevoil
		   THIS.oInvTmp.nrevgas   = jnrevgas
		   THIS.oInvTmp.nrevoth   = jnrevoth
		   THIS.oInvTmp.nrevtax1  = jnrevtax1
		   THIS.oInvTmp.nrevtax2  = jnrevtax2
		   THIS.oInvTmp.nrevtax3  = jnrevtax3
		   THIS.oInvTmp.nrevtax4  = jnrevtax4
		   THIS.oInvTmp.nrevtax5  = jnrevtax5
		   THIS.oInvTmp.nrevtax6  = jnrevtax6
		   THIS.oInvTmp.nrevtax7  = jnrevtax7
		   THIS.oInvTmp.nrevtax8  = jnrevtax8
		   THIS.oInvTmp.nrevtax9  = jnrevtax9
		   THIS.oInvTmp.nrevtax10 = jnrevtax10
		   THIS.oInvTmp.nrevtax11 = jnrevtax11
		   THIS.oInvTmp.nrevtax12 = jnrevtax12
		   THIS.oInvTmp.nrevmisc1 = jnrevm1
		   THIS.oInvTmp.nrevmisc2 = jnrevm2
		   m.cDirect = THIS.oInvTmp.cDirect
		ENDSCAN && nIncome
		
		insert into temptax from memvar
		
		
	ENDPROC

	PROCEDURE calctaxes		&& Calculates tax section
		SELECT invtmp
		SCATTER MEMVAR
		
		IF invtmp.nsevtaxes <> 0
		   STORE 0 TO lnoiltax1, lnoiltax2, lnoiltax3, lnoiltax4
		   STORE 0 TO lngastax1, lngastax2, lngastax3, lngastax4
		   STORE 0 TO lnothtax1, lnothtax2, lnothtax3, lnothtax4
		
		   SELE wells
		   LOCATE FOR cWellID = THIS.oWellWork.cWellID
		   SCATTER MEMVAR
		
		   * Don't do anything with taxes here if the table
		   * is empty on the well record.
		   IF EMPTY(m.ctable) and not m.luseSev
		      RETURN
		   ENDIF
		
		   * Set the lusesev flag if the wellwork fields ntotmcftxr, ntotmcftxw, ntotbbltxr, ntotbbltxw have a value in them.
		   * The flag could have been set in the well record when the run was closed but not set now when you're trying to
		   * print a previous statement.
		   IF this.owellwork.ntotmcftxr # 0 OR ;
		      this.owellwork.ntotmcftxw # 0 OR ;
		      this.owellwork.ntotbbltxr # 0 OR ;
		      this.owellwork.ntotbbltxw # 0
		      m.lUseSev = .t.
		   ENDIF 
		   
		   lntaxes = 0
		   SELECT sevtax
		   SET ORDER TO ctable
		   IF SEEK(m.ctable)
		      SCATTER MEMVAR
		      * Zero out rates if the purchaser is withholding the tax.
		      IF m.lSev1O
		         m.ntaxbbl1 = 0
		         m.cMethodBBL1 = ' '
		      ENDIF
		      IF m.lSev2O
		         m.ntaxbbl2 = 0
		         m.cMethodBBL2 = ' '
		      ENDIF
		      IF m.lSev3O
		         m.ntaxbbl3 = 0
		         m.cMethodBBL3 = ' '
		      ENDIF
		      IF m.lSev4O
		         m.ntaxbbl4 = 0
		         m.cMethodBBL4 = ' '
		      ENDIF
		      IF m.lSev1G 
		         m.ntaxmcf1 = 0
		         m.cmethodmcf1 = ' '
		      endif
		      IF m.lSev2G 
		         m.ntaxmcf2 = 0
		         m.cmethodmcf2 = ' '
		      endif
		      IF m.lSev3G 
		         m.ntaxmcf3 = 0
		         m.cmethodmcf3 = ' '
		      endif
		      IF m.lSev4G 
		         m.ntaxmcf4 = 0
		         m.cmethodmcf4 = ' '
		      endif
		   ELSE
		      IF NOT m.lUseSev
		         RETURN
		      ENDIF   
		   ENDIF
		
		
		   IF m.lusesev
		      STORE 0 TO m.ntaxbbl1, m.ntaxmcf1, m.ntaxoth1, ;
		         M.ntaxbbl2, m.ntaxmcf2, m.ntaxoth2, ;
		         M.ntaxbbl3, m.ntaxmcf3, m.ntaxoth3, ;
		         M.ntaxbbl4, m.ntaxmcf4, m.ntaxoth4
		      STORE 'Gas Taxes' to m.cnamemcf1, m.cnamemcf2, m.cnamemcf3, m.cnamemcf4
		      STORE 'Oil Taxes' to m.cnamebbl1, m.cnamebbl2, m.cnamebbl3, m.cnamebbl4
		      STORE ' ' TO m.cmethodbbl1, m.cmethodbbl2, m.cmethodbbl3, m.cmethodbbl4
		      STORE ' ' TO m.cmethodmcf1, m.cmethodmcf2, m.cmethodmcf3, m.cmethodmcf4
		      STORE ' ' TO m.cmethodoth1, m.cmethodoth2, m.cmethodoth3, m.cmethodoth4
		      m.cmethod = "W"
		   ENDIF
		   m.crptgroup = 'B'
		   m.ctype     = 'TAX'
		   m.cYear = m.hyear
		   m.cPeriod = m.hPeriod
		   *!*	   m.cyear     = THIS.cYear
		   m.cProgCode = THIS.oInvTmp.cProgCode
		   IF THIS.lOwnerTaxExempt             && Owner is Tax Exempt
		      m.ninvamt = 0
		      STORE 0 TO lnoiltax1, lnoiltax2, lnoiltax3, lnoiltax4
		      STORE 0 TO lngastax1, lngastax2, lngastax3, lngastax4
		      STORE 0 TO lnothtax1, lnothtax2, lnothtax3, lnothtax4
		   ELSE
		      *  If the owner has an oil interest, process oil taxes
		      IF INLIST(THIS.oInvTmp.ctypeint,'B','O')
		         m.nbblinc = THIS.nOilAmount
		         m.nunits  = THIS.nTotalBBL
		         IF m.lusesev  && Override state severance tax table rates
		            IF THIS.nOilTax1 = 0
		               IF THIS.lRoyaltyOwner
		                  lnoiltax1  = SWROUND(((THIS.oWellWork.nGrossOil*(m.nroysevo/100))*(m.nrevoil/100)),2)
		                  STORE 0 TO lnoiltax2, lnoiltax3, lnoiltax4
		               ELSE
		                  lnoiltax1  = SWROUND(((THIS.oWellWork.nGrossOil*(m.nwrksevo/100))*(m.nrevoil/100)),2)
		                  STORE 0 TO lnoiltax2, lnoiltax3, lnoiltax4
		               ENDIF
		            ENDIF
		         ELSE
		            * If royalty owners are exempt, working interest owner takes full
		            * working interest share of severance tax.
		            IF THIS.lExemptRoyalty AND NOT THIS.lRoyaltyOwner
		               STORE m.nworkint TO m.nrevtax1, m.nrevtax4, m.nrevtax7, m.nrevtax10
		            ENDIF
		            IF INLIST(m.cDirect,'B','O') AND m.lsev1o AND m.ldiroilpurch
		               lnoiltax1 = 0
		            ELSE
		               * Save the original tax pct
		               lnPct = m.nrevtax1
		               * If this is a NM well and we're using the alternate calculation,
		               * gross up the tax pct to account for exempt owners. This is only
		               * valid for tax 1.
		               IF m.cstate = 'NM' AND FILE('nm.cfg')
		                  lnPct = THIS.odist.grossuptaxpct(m.cWellID,lnPct,'O')
		               ENDIF
		               if m.lSev1O
		                  lnOilTax1 = 0
		               ELSE
		                  lnoiltax1   = (SWROUND((THIS.oWellWork.ntotbbltx1+temptax.noiltax1)*(lnPct/100),2))
		                  m.nrevtax1  = lnPct
		                  lntaxes = lntaxes + lnoiltax1
		               ENDIF
		            ENDIF
		            IF m.lsev2o AND (m.ldiroilpurch AND INLIST(m.cDirect,'B','O'))
		               lnoiltax2 = 0
		            ELSE
		               if m.lSev2O
		                  lnoiltax2 = 0
		               else   
		                  lnoiltax2   = (SWROUND((THIS.oWellWork.ntotbbltx2+temptax.noiltax2)*(m.nrevtax4/100),2))
		                  lntaxes = lntaxes + lnoiltax2
		               endif   
		            ENDIF
		
		            IF m.lsev3o  AND (m.ldiroilpurch AND INLIST(m.cDirect,'B','O'))
		               lnoiltax3 = 0
		            ELSE
		               if m.lsev3o
		                  lnoiltax3 = 0
		               else   
		                  lnoiltax3   = (SWROUND((THIS.oWellWork.ntotbbltx3+temptax.noiltax3)*(m.nrevtax7/100),2))
		                  lntaxes = lntaxes + lnoiltax3
		               endif    
		            ENDIF
		            IF m.lsev4o AND (m.ldiroilpurch AND INLIST(m.cDirect,'B','O'))
		               lnoiltax4 = 0
		            ELSE
		               if m.lsev4o
		                  lnoiltax4 = 0
		               else   
		                  lnoiltax4   = (SWROUND((THIS.oWellWork.ntotbbltx4+temptax.noiltax4)*(m.nrevtax10/100),2))
		                  lntaxes = lntaxes + lnoiltax4
		               endif   
		            ENDIF
		         ENDIF
		      ENDIF
		
		      IF THIS.lRoyaltyOwner AND THIS.lExemptRoyalty
		         STORE 0 TO lnoiltax1, lnoiltax2, lnoiltax3, lnoiltax4
		      ENDIF
		      IF lnoiltax1 + lnoiltax2 + lnoiltax3 + lnoiltax4 # 0
		         THIS.nWellTot = THIS.nWellTot - lnoiltax1 - lnoiltax2 - lnoiltax3 - lnoiltax4
		         m.cownerid = THIS.cownerid
		         IF lnoiltax1 <> 0
		            m.csource  = m.cnamebbl1
		            IF NOT m.lusesev
		               m.cmethod  = m.cmethodbbl1
		            ENDIF
		            * If the well is a NM well and we're using the alternate tax calculation,
		            * remove the tax exempt owner's portion of the revenue.
		            IF m.cstate = 'NM' AND FILE('nm.cfg')
		               m.ctaxable = THIS.odist.removetaxexempt(m.cWellID,'BBL',THIS.oWellWork.nGrossOil)
		            ELSE
		               m.ctaxable = THIS.oWellWork.nGrossOil
		            ENDIF
		            m.ninvamt  = lnoiltax1 * -1
		            IF m.lusesev
		               IF THIS.lRoyaltyOwner
		                  m.nprice = m.nroysevo/100
		                  m.ntotal = SWROUND((THIS.oWellWork.nGrossOil*(m.nroysevo/100)),2) * -1
		               ELSE
		                  m.nprice = m.nwrksevo/100
		                  m.ntotal = SWROUND((THIS.oWellWork.nGrossOil*(m.nwrksevo/100)),2) *-1
		               ENDIF
		            ELSE
		               m.nprice   = m.ntaxbbl1
		               *  Remove any manually entered taxes from calculated total
		               m.ntotal   = (THIS.oWellWork.ntotbbltx1 + THIS.nOilTax1) * -1
		            ENDIF
		            IF NOT m.lusesev
		               m.nrevint  = m.nrevtax1
		            ELSE
		               m.nrevint  = m.nrevoil
		            ENDIF
		            m.nRunNo = THIS.nRunNo
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         IF lnoiltax2 <> 0
		            m.csource  = m.cnamebbl2
		            m.cmethod  = m.cmethodbbl2
		            *                     m.ctaxable = THIS.oWellWork.nTotBBLtx2/m.nTaxBBL2
		            m.ctaxable = THIS.oWellWork.nGrossOil
		            m.ninvamt  = lnoiltax2 * -1
		            *  Remove any manually entered taxes from calculated total
		            m.ntotal   = (THIS.oWellWork.nTotbbltx2 + THIS.noiltax2) * -1
		            m.nprice   = m.ntaxbbl2
		            m.nrevint  = m.nrevtax4
		            m.nRunNo = THIS.nRunNo
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         IF lnoiltax3 <> 0
		            m.csource  = m.cnamebbl3
		            m.cmethod  = m.cmethodbbl3
		            *                     m.ctaxable = THIS.oWellWork.nTotBBLtx3/m.nTaxBBL3
		            m.ctaxable = THIS.oWellWork.nGrossOil
		            m.ninvamt  = lnoiltax3 * -1
		            *  Remove any manually entered taxes from calculated total
		            m.ntotal   = (THIS.oWellWork.nTotbbltx3 + THIS.noiltax3) * -1
		            m.nprice   = m.ntaxbbl3
		            m.nrevint  = m.nrevtax7
		            m.nRunNo = THIS.nRunNo
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         IF lnoiltax4 <> 0
		            m.csource  = m.cnamebbl4
		            m.cmethod  = m.cmethodbbl4
		            *                     m.ctaxable = THIS.oWellWork.nTotBBLtx4/m.nTaxBBL4
		            m.ctaxable = THIS.oWellWork.nGrossOil
		            m.ninvamt  = lnoiltax4 * -1
		            *  Remove any manually entered taxes from calculated total
		            m.ntotal   = (THIS.oWellWork.nTotbbltx4 + THIS.noiltax4) * -1
		            m.nprice   = m.ntaxbbl4
		            m.nrevint  = m.nrevtax10
		            m.nRunNo = THIS.nRunNo
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDIF
		   IF INLIST(THIS.oInvTmp.ctypeint,'B','G')
		      IF m.lusesev  && Use state severance tax table rates
		         m.cmethod = "W"
		         IF THIS.nGasTax1 = 0
		            IF THIS.lRoyaltyOwner
		               lngastax1  = SWROUND(((THIS.oWellWork.nGrossGas*(m.nroysevg/100))*(m.nrevgas/100)),2)
		               STORE 0 TO lngastax2, lngastax3, lngastax4
		            ELSE
		               lngastax1  = SWROUND(((THIS.oWellWork.nGrossGas*(m.nwrksevg/100))*(m.nrevgas/100)),2)
		               STORE 0 TO lngastax2, lngastax3, lngastax4
		            ENDIF
		         ENDIF
		      ELSE
		         * If royalty owners are exempt, working interest owner takes full
		         * working interest share of severance tax.
		         IF THIS.lExemptRoyalty AND NOT THIS.lRoyaltyOwner
		            STORE m.nworkint TO m.nrevtax2, m.nrevtax5, m.nrevtax8, m.nrevtax11
		         ENDIF
		         IF m.lsev1g AND (m.ldirgaspurch AND INLIST(m.cDirect,'B','G'))
		            lngastax1 = 0
		         ELSE
		            *lngastax1   = m.ngastax1 + THIS.nGasTax1
		            lnPct = m.nrevtax2
		            * If this is a NM well and we're using the alternate calculation,
		            * gross up the tax pct to account for exempt owners. This is only
		            * valid for tax 1.
		            IF m.cstate = 'NM' AND FILE('nm.cfg')
		               lnPct = THIS.odist.grossuptaxpct(m.cWellID,lnPct,'O')
		            ENDIF
		            if m.lsev1g
		               lngastax1 = 0
		            else   
		               lngastax1   = (SWROUND((THIS.oWellWork.ntotmcftx1+temptax.ngastax1)*(lnPct/100),2))
		               m.nrevtax2  = lnPct
		               lntaxes = lntaxes + lngastax1
		            endif   
		         ENDIF
		         IF m.lsev2g AND (m.ldirgaspurch AND INLIST(m.cDirect,'B','G'))
		            lngastax2 = 0
		         ELSE
		            if m.lsev2g
		               lngastax2 = 0
		            else   
		               lngastax2   = (SWROUND((THIS.oWellWork.ntotmcftx2+temptax.ngastax2)*(m.nrevtax5/100),2))
		               lntaxes = lntaxes + lngastax2
		            endif   
		         ENDIF
		         IF m.lsev3g AND (m.ldirgaspurch AND INLIST(m.cDirect,'B','G'))
		            lngastax3 = 0
		         ELSE
		            if m.lsev3g
		               lngastax3 = 0
		            else   
		               lngastax3   = (SWROUND((THIS.oWellWork.ntotmcftx3+temptax.ngastax3)*(m.nrevtax8/100),2))
		               lntaxes = lntaxes + lngastax3
		            endif   
		         ENDIF
		         IF m.lsev4g AND (m.ldirgaspurch AND INLIST(m.cDirect,'B','G'))
		            lngastax4 = 0
		         ELSE
		            if m.lsev4g 
		               lngastax4 = 0
		            else   
		               lngastax4   = (SWROUND((THIS.oWellWork.ntotmcftx4+temptax.ngastax4)*(m.nrevtax11/100),2))
		               lntaxes = lntaxes + lngastax4
		            endif   
		         ENDIF
		      ENDIF
		      *  If royalty owners are exempt from the severance tax, don't
		      *  show a share for them.
		      IF THIS.lExemptRoyalty AND THIS.lRoyaltyOwner
		         STORE 0 TO lngastax1, lngastax2, lngastax3, lngastax4
		      ENDIF
		      IF lngastax1 + lngastax2 + lngastax3 + lngastax4 # 0
		         *!*	                  IF (m.cDirect = 'G' OR m.cDirect = 'B')
		         *!*	                     THIS.nWellTot = THIS.nWellTot
		         *!*	                  ELSE
		         THIS.nWellTot = THIS.nWellTot - lngastax1 - lngastax2 - lngastax3 - lngastax4
		         *!*	                  ENDIF
		         m.cownerid = THIS.cownerid
		         IF lngastax1 <> 0
		            m.csource  = m.cnamemcf1
		            IF NOT m.lusesev
		               m.cmethod  = m.cmethodmcf1
		            ENDIF
		            * If this is a NM well and we're using the alternate tax calculation,
		            * remove the tax exempt owner's share of gas revenue.
		            IF m.cstate = 'NM' AND FILE('nm.cfg')
		               m.ctaxable = THIS.odist.removetaxexempt(m.cWellID,'MCF',THIS.oWellWork.nGrossGas)
		            ELSE
		               m.ctaxable = THIS.oWellWork.nGrossGas
		            ENDIF
		
		            m.ninvamt  = lngastax1 * -1
		            IF m.lusesev
		               IF THIS.lRoyaltyOwner
		                  m.nprice = m.nroysevg/100
		                  m.ntotal = SWROUND((THIS.oWellWork.nGrossGas*(m.nroysevg/100)),2) *-1
		               ELSE
		                  m.nprice = m.nwrksevg/100
		                  m.ntotal = SWROUND((THIS.oWellWork.nGrossGas*(m.nwrksevg/100)),2) *-1
		               ENDIF
		            ELSE
		               *  Remove any manually entered taxes from calculated total
		               m.ntotal   = (THIS.oWellWork.ntotmcftx1 + THIS.nGasTax1) * -1
		               m.nprice   = m.ntaxmcf1
		            ENDIF
		            IF NOT m.lusesev
		               m.nrevint  = m.nrevtax2
		            ELSE
		               m.nrevint  = m.nrevgas
		            ENDIF
		            m.nRunNo = THIS.nRunNo
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         IF lngastax2 <> 0
		            m.csource  = m.cnamemcf2
		            m.cmethod  = m.cmethodmcf2
		            *                     m.ctaxable = THIS.oWellWork.nTotMCFtx2/m.nTaxMCF2
		            m.ctaxable = THIS.oWellWork.nGrossGas
		            m.ninvamt  = lngastax2 * -1
		            *  Remove any manually entered taxes from calculated total
		            m.ntotal   = (THIS.oWellWork.nTotmcftx2 + THIS.ngastax2) * -1
		            m.nprice   = m.ntaxmcf2
		            m.nrevint  = m.nrevtax5
		            m.nRunNo = THIS.nRunNo
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         IF lngastax3 <> 0
		            m.csource  = m.cnamemcf3
		            m.cmethod  = m.cmethodmcf3
		            *                     m.ctaxable = THIS.oWellWork.nTotMCFtx3/m.nTaxMCF3
		            m.ctaxable = THIS.oWellWork.nGrossGas
		            m.ninvamt  = lngastax3 * -1
		            *  Remove any manually entered taxes from calculated total
		            m.ntotal   = (THIS.oWellWork.nTotmcftx3 + THIS.ngastax3) * -1
		            m.nprice   = m.ntaxmcf3
		            m.nrevint  = m.nrevtax8
		            m.nRunNo = THIS.nRunNo
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		         IF lngastax4 <> 0
		            m.csource  = m.cnamemcf4
		            m.cmethod  = m.cmethodmcf4
		            *                     m.ctaxable = THIS.oWellWork.nTotMCFtx4/m.nTaxMCF4
		            m.ctaxable = THIS.oWellWork.nGrossGas
		            m.ninvamt  = lngastax4 * -1
		            *  Remove any manually entered taxes from calculated total
		            m.ntotal   = (THIS.oWellWork.nTotmcftx4 + THIS.ngastax4) * -1
		            m.nprice   = m.ntaxmcf4
		            m.nrevint  = m.nrevtax11
		            m.nRunNo = THIS.nRunNo
		            *********************************************************************************************************
		            *  Insert into the statement file  - Report Group B
		            *********************************************************************************************************
		            INSERT INTO statemnt FROM MEMVAR
		         ENDIF
		      ENDIF
		   ENDIF
		   *
		   *  Calculate other product taxes
		   *
		
		   IF m.lsev1p
		      lnothtax1 = 0
		   ELSE
		      *      lnothtax1 = m.nothtax1
		      lnothtax1 = (SWROUND(THIS.oWellWork.nTotOthtx1*(m.nRevTax3/100),2))
		      lntaxes   = lntaxes + lnothtax1
		   ENDIF
		   IF m.lsev2p
		      lnothtax2 = 0
		   ELSE
		      *      lnothtax2 = m.nothtax2
		      lnothtax2 = (SWROUND(THIS.oWellWork.nTotOthtx2*(m.nRevTax6/100),2))
		      lntaxes   = lntaxes + lnothtax2
		   ENDIF
		   IF m.lsev3p
		      lnothtax3 = 0
		   ELSE
		      *      lnothtax3 = m.nothtax3
		      lnothtax3 = (SWROUND(THIS.oWellWork.nTotOthtx4*(m.nRevTax9/100),2))
		      lntaxes   = lntaxes + lnothtax3
		   ENDIF
		   IF m.lsev4p
		      lnothtax4 = 0
		   ELSE
		      *      lnothtax4 = m.nothtax4
		      lnothtax4 = (SWROUND(THIS.oWellWork.nTotOthtx4*(m.nRevTax12/100),2))
		      lntaxes   = lntaxes + lnothtax4
		   ENDIF
		   IF lnothtax1 + lnothtax2 + lnothtax3 + lnothtax4 # 0
		      THIS.nWellTot = THIS.nWellTot - lnothtax1 - lnothtax2 - lnothtax3 - lnothtax4
		      m.cownerid = THIS.cownerid
		      IF lnothtax1 <> 0
		         m.csource  = m.cnameoth1
		         m.cmethod  = m.cmethodoth1
		         m.ctaxable = THIS.oWellWork.nOthInc
		         m.ninvamt  = lnothtax1 * -1
		         *  Remove any manually entered taxes from calculated total
		         m.ntotal   = (THIS.oWellWork.nTotOthtx1 + THIS.nothtax1) * -1
		         m.nprice   = m.ntaxoth1
		         m.nrevint  = m.nRevTax3
		         m.nRunNo = THIS.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      IF lnothtax2 <> 0
		         m.csource  = m.cnameoth2
		         m.cmethod  = m.cmethodoth2
		         m.ctaxable = THIS.oWellWork.nOthInc
		         m.ninvamt  = lnothtax2 * -1
		         *  Remove any manually entered taxes from calculated total
		         m.ntotal   = (THIS.oWellWork.nTotOthtx2 + THIS.nothtax2) * -1
		         m.nprice   = m.ntaxoth2
		         m.nrevint  = m.nRevTax6
		         m.nRunNo = THIS.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      IF lnothtax3 <> 0
		         m.csource  = m.cnameoth3
		         m.cmethod  = m.cmethodoth3
		         m.ctaxable = THIS.oWellWork.nOthInc
		         m.ninvamt  = lnothtax3 * -1
		         *  Remove any manually entered taxes from calculated total
		         m.ntotal   = (THIS.oWellWork.nTotothtx3 + THIS.nothtax3) * -1
		         m.nprice   = m.ntaxoth3
		         m.nrevint  = m.nRevTax9
		         m.nRunNo = THIS.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      IF lnothtax4 <> 0
		         m.csource  = m.cnameoth4
		         m.cmethod  = m.cmethodoth4
		         m.ctaxable = THIS.oWellWork.nOthInc
		         m.ninvamt  = lnothtax4 * -1
		         *  Remove any manually entered taxes from calculated total
		         m.ntotal   = (THIS.oWellWork.nTotOthtx4 + THIS.nothtax4) * -1
		         m.nprice   = m.ntaxoth4
		         m.nrevint  = m.nRevTax12
		         m.nRunNo = THIS.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group B
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE deficits_own
		if this.lDeficitProcessed = .T.
		   RETURN
		endif
		   
		IF THIS.lNetWells 
		   SELECT invtmp
		   SCAN FOR cownerid = THIS.cownerid  ;
		         AND ctypeinv = 'X' ;
		         AND (EMPTY(ALLT(cprogcode)) OR cprogcode = 'NONE') ;
		         AND nnetcheck <> 0
		      THIS.nOwnerTotal   = THIS.nOwnerTotal + nnetcheck
		      m.crptgroup = 'H'
		      m.ctype     = 'PPD'
		      m.nwellnet  = nnetcheck
		      m.cperiod   = ''
		      m.cyear     = this.cRunyear
		      m.cprogcode = 'ZZZZ'
		      m.cwelltype = '}ZZZZZZZ'
		      m.cwellid   = cwellid
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(m.cWellid)
		         m.cwellname = cwellname
		      ELSE
		         m.cwellname = 'Combined Wells'
		      ENDIF
		      IF m.cwellid = 'ALL'
		         m.cwellid = PADR(ALLTRIM(m.cwellid),10,' ')
		      ENDIF
		      m.cdescript = 'Previous Amount Paid By Revenue This Period For Well: ' + ALLT(m.cWellid) + ' - ' + m.cwellname
		      m.cownerid = THIS.cownerid
		      m.nRunNo = this.nRunNo
		      *********************************************************************************************************
		      *  Insert into the statement file  - Report Group H   (Previous Deficits Being Covered)
		      *********************************************************************************************************
		      INSERT INTO statemnt FROM MEMVAR
		   ENDSCAN     && invtmp
		ENDIF  && IF THIS.lNetWells
		
	ENDPROC

	PROCEDURE deficits_well
		*
		*  Bring any any deficits processed this period for the given well. Deficits
		*  are marked with the cTypeInv field having an "X".  This is for deficits
		*  that are not netted with income from other wells.
		*
		if this.lDeficitProcessed = .T.
		   return
		endif 
		   
		IF NOT THIS.lNetWells
		   USE DBF('invtmp') AGAIN IN 0 ALIAS tmpsusp
		   SELECT tmpsusp
		   SCAN FOR cownerid = THIS.oInvTmp.cOwnerid  ;
		         AND nnetcheck < 0             ;
		         AND cwellid  = THIS.oWellWork.cwellid      ;
		         AND ctypeinv = 'X'
		      THIS.nOwnerTotal   = THIS.nOwnerTotal + nnetcheck
		      this.lDeficitProcessed = .T.
		      m.crptgroup = 'F'
		      m.ctype     = 'WDF'
		      m.nwellnet  = nnetcheck
		      m.cperiod   = ''
		      m.cyear     = THIS.oWellWork.hYear
		      m.cdescript = 'Deficits Brought Forward From Previous Periods'
		      m.cownerid  = THIS.cownerid
		      m.nRunNo    = this.nRunNo
		      *********************************************************************************************************
		      *  Insert into the statement file  - Report Group F
		      *********************************************************************************************************
		      INSERT INTO statemnt FROM MEMVAR
		
		      m.cdescript = ' '
		   ENDSCAN     && tmpsusp
		   SELECT tmpsusp
		   USE
		ENDIF  && IF NOT THIS.lNetWells
		
	ENDPROC

	PROCEDURE flatowner
		
		* Only allocate flat rates once
		IF this.lFlatAlloc = .T.
		   RETURN
		ENDIF
		   
		*
		*  Get flat-rate Royalty nAmounts for current well
		*
		STORE 0 TO jnflatgas, jnflatoil
		*  If the run is closed, get the flat rates from well history
		
		IF this.lclosed
		   SELECT wellhist
		   locate for cwellid == this.cwellid and hyear+hperiod == this.cyear+this.cperiod and nrunno = this.nrunno
		   if found()
		      jnflatgas = nflatgas
		      jnflatoil = nflatoil
		   ENDIF
		ELSE
		   * The run isn't closed so get the flat rates from wellinv
		   jnflatgas = this.odist.getflatamt(THIS.cwellid,'G')
		   jnflatoil = this.odist.getflatamt(THIS.cwellid,'O')
		ENDIF
		
		*************************************************************
		*  Process flat-rate royalties
		*************************************************************
		IF jnflatgas <> 0 AND NOT THIS.lRoyaltyOwner
		   m.ctype = 'FLT'
		   m.csource = 'Flat-Rate Gas Royalties'
		   m.ntotal  = jnflatgas * -1
		   m.nrevint = invtmp.nworkint
		   jwrk = jnflatgas * (invtmp.nworkint/100)
		   IF THIS.oInvTmp.cDirect = 'G' OR THIS.oInvTmp.cDirect = 'B'
		      m.ninvamt = 0
		      m.ntotal  = 0
		      m.nworktot = jwrk * -1
		   ELSE
		      m.ninvamt = jwrk * -1
		   ENDIF
		   m.cdirect = THIS.oInvTmp.cDirect
		   m.crptgroup = 'B'
		   m.cownerid = THIS.oInvTmp.cownerid
		   m.nRunNo = this.nRunNo
		   *********************************************************************************************************
		   *  Insert into the statement file  - Report Group B
		   *********************************************************************************************************
		   INSERT INTO statemnt FROM MEMVAR
		   
		   m.cdescript = ' '
		   THIS.nTotInc  = THIS.nTotInc + m.ninvamt
		   THIS.nWellTot = THIS.nWellTot + m.ninvamt
		ENDIF
		
		IF jnflatoil <> 0 AND NOT THIS.lRoyaltyOwner
		   m.ctype = 'FLT'
		   m.csource = 'Flat-Rate Oil Royalties'
		   m.ntotal  = jnflatoil * -1
		   m.nrevint = invtmp.nworkint
		   jwrk = jnflatoil * (invtmp.nworkint/100)
		   IF THIS.oInvTmp.cDirect = 'O' OR THIS.oInvTmp.cDirect = 'B'
		      m.ninvamt = 0
		      m.ntotal  = 0
		      m.nworktot = jwrk * -1
		   ELSE
		      m.ninvamt = jwrk * -1
		   ENDIF
		   m.cdirect = THIS.oInvTmp.cDirect
		   m.crptgroup = 'B'
		   m.cownerid = THIS.oInvTmp.cownerid
		   m.nRunNo = this.nRunNo
		   *********************************************************************************************************
		   *  Insert into the statement file  - Report Group B
		   *********************************************************************************************************
		   INSERT INTO statemnt FROM MEMVAR
		   m.cdescript = ' '
		   THIS.nTotInc  = THIS.nTotInc + m.ninvamt
		   THIS.nWellTot = THIS.nWellTot + m.ninvamt
		ENDIF
		
		this.lFlatAlloc = .t.
	ENDPROC

	PROCEDURE getprevmins
		LPARA tcOwner, tcYear, tcPeriod, tcGroup, tnAmount
		
		SELECT options
		GO TOP
		llChgPrice = lChgPrice
		llHideComp = lHideComp
		
		CREATE CURSOR disbchks ;
		   (cOwnerID         C(10), ;
		    cOwnname         C(40), ;
		    cwellid          C(10), ;
		    nincome          N(12,2), ;
		    noilrev          N(12,2), ;
		    ngasrev          N(12,2), ;
		    nothrev          N(12,2), ;
		    ctypeinv         C(1), ;
		    ctypeint         C(1), ;
		    nexpense         N(12,2), ;
		    nsevtaxes        N(12,2), ;
		    noiltax          N(12,2), ;
		    ngastax          N(12,2), ;
		    nCOMPRESS        N(12,2), ;
		    nGATHER          N(12,2), ;
		    nnetcheck        N(12,2), ;
		    hyear            C(4), ;
		    hperiod          C(2), ;
		    cprogcode        C(10), ;
		    cprogname        C(40), ;
		    cwellname        C(30), ;
		    ncheck_amt       N(12,2))
		   
		SELECT disbhist.cOwnerID, ;
		       investor.cOwnname, ;
		       disbhist.cwellid, ;
		       disbhist.nincome, ;
		       disbhist.cdirect, ;
		       IIF(cDIRECT<>'O',IIF(cDIRECT<>'B',SUM(noilrev),000000.00),000000.00) AS noilrev, ;
		       IIF(cDIRECT<>'G',IIF(cDIRECT<>'B',SUM(ngasrev),000000.00),000000.00) AS ngasrev, ;
		       SUM(disbhist.ntrprev+disbhist.nmiscrev1+disbhist.nmiscrev2) AS nothrev, ;
		       disbhist.ctypeinv, ;
		       disbhist.ctypeint, ;
		       SUM(disbhist.nexpense+;
		           disbhist.ntotale1+;
		           disbhist.ntotale2+;
		           disbhist.ntotale3+;
		           disbhist.ntotale4+;
		           disbhist.ntotale5) AS nexpense,  ;
		       disbhist.nsevtaxes, ;
		       SUM(disbhist.noiltax1+disbhist.noiltax2+disbhist.noiltax3+disbhist.noiltax4) AS noiltax, ;
		       SUM(disbhist.ngastax1+disbhist.ngastax2+disbhist.ngastax3+disbhist.ngastax4) AS ngastax, ;
		       disbhist.ngather, ;
		       disbhist.ncompress, ;
		       disbhist.nnetcheck, ;
		       disbhist.hyear,    ;
		       disbhist.hperiod, ;
		       disbhist.cprogcode, ;
		       disbhist.ntaxwith, ;
		       disbhist.nbackwith, ;
		       wells.cwellname, ;
		       0.00  AS ncheck_amt ;
		   FROM disbhist, wells, investor ;
		   WHERE hyear   = tcYear    ;
		     AND hperiod = tcPeriod  ;
		     AND disbhist.cgroup = tcGroup ;
		     AND disbhist.cOwnerID = tcOwner ;
		     AND investor.cOwnerID = disbhist.cOwnerID  ;
		     AND wells.cwellid = disbhist.cwellid ;
		   INTO CURSOR disbchk ;
		   ORDER BY disbhist.cOwnerID, disbhist.nnetcheck, disbhist.cwellid, disbhist.ctypeinv, disbhist.ctypeint, disbhist.cprogcode ;
		   GROUP BY disbhist.cOwnerID, disbhist.nnetcheck, disbhist.cwellid, disbhist.ctypeinv, disbhist.ctypeint, disbhist.cprogcode
		
		SELECT disbchks
		APPEND FROM DBF('disbchk')
		
		*
		*   Add suspense items that affected this period.
		*
		SELECT susaudit
		SCAN FOR cyear+cperiod = tcYear+tcPeriod AND namount < 0 AND caction = 'O' AND cOwnerID = tcOwner
		   SCATTER MEMVAR
		   m.nnetcheck = namount
		   STORE 0 TO m.nincome, m.nexpense, m.nsevtaxes
		   IF NOT EMPTY(ALLT(m.cprogcode)) AND m.cprogcode <> 'NONE'
		      SELECT programs
		      SET ORDER TO cprogcode
		      SEEK m.cprogcode
		      IF FOUND() AND lprognet = .T.
		         INSERT INTO disbchks FROM MEMVAR
		      ENDIF
		   ELSE
		     INSERT INTO disbchks FROM MEMVAR
		   ENDIF
		ENDSCAN
		
		SELECT disbchks
		SCAN
		   SCATTER MEMVAR
		   IF nincome = 0 and ;
		      nexpense = 0 and ;
		      nnetcheck = 0
		      DELETE NEXT 1
		      LOOP
		   ENDIF
		   SELECT programs
		   SET ORDER TO cprogcode
		   SEEK m.cprogcode
		   IF FOUND()
		      m.cprogname = cprogname
		   ELSE
		      m.cprogcode = 'None'
		      m.cprogname = 'Non Program Wells'
		   ENDIF
		   DO CASE
		      CASE m.cdirect = 'O'
		         m.ntaxes = m.nsevtaxes - m.noiltax
		      CASE m.cdirect = 'G'
		         m.ntaxes = m.nsevtaxes - m.ngastax
		      CASE m.cdirect = 'B'
		         m.ntaxes = 0
		      OTHERWISE
		         m.ntaxes = m.nsevtaxes   
		   ENDCASE            
		   IF m.nTaxWith <> 0
		      m.nTaxes = m.nTaxes + m.nTaxwith
		      m.nNetCheck = m.nNetCheck - m.nTaxWith
		   ENDIF
		   IF m.nBackWith <> 0
		      m.nTaxes = m.nTaxes + m.nBackwith
		      m.nNetCheck = m.nNetCheck - m.nBackWith
		   ENDIF
		   m.nincome = m.ngasrev+m.noilrev+m.nothrev
		   IF llHideComp
		      m.nincome = m.nincome - m.ngather - m.ncompress
		      m.ngather = 0
		      m.ncompress = 0
		   ELSE
		      IF llChgPrice AND m.ctypeinv <> 'W'
		         m.nincome = m.nincome - m.ngather - m.ncompress
		         m.ngather = 0
		         m.ncompress = 0
		      ENDIF
		   ENDIF        
		   SELECT disbchks
		   REPLACE cprogname WITH m.cprogname, ;
		           cprogcode WITH m.cprogcode, ;
		           nincome   WITH m.nincome,   ;
		           ngather   WITH m.ngather,   ;
		           ncompress WITH m.ncompress, ;
		           nsevtaxes WITH m.ntaxes,    ;
		           nnetcheck WITH m.nnetcheck
		ENDSCAN
		
		SELECT disbchks
		INDEX ON hyear+hperiod DESC TAG yearprd
		SET ORDER TO yearprd
		
		SELECT SUM(nnetcheck) FROM disbchks INTO ARRAY laTotal 
		
		IF _tally > 0
		   IF latotal[1] <> tnAmount
		      SELECT disbchks
		*      delete all
		   ENDIF
		ENDIF      
		
		
		
	ENDPROC

	PROCEDURE getrange
		*========================================================================================
		*  Program....: GETRANGE.PRG
		*  Version....: 2.5
		*  Author.....: Phil W. Sherwood
		*  Date.......: February 13, 1994
		*  Notice.....: Copyright (c) 1996 SherWare, Inc., All Rights Reserved.
		*  Compiler...: FoxPro 2.6a
		*) Description: Retrieves well period range information from prdrange file.
		*  Parameters.:
		*  Changes....:
		*    03/31/96   pws - Changed to update the prdrange file instead of the well file.
		*    02/14/97   pws - Changed the way the range is calculated.  Calculate the range by
		*                     looking at last periods range and adding 1 to the end.
		*    12/08/98   pws - Changed for new wellrng file.
		*========================================================================================
		LPARA tcPeriod, tcYear, tcType, tcWellId
		LOCAL ldDate1, lcDate1, lcDate2, lcYear, lcRange1, lcRange2, llCalcRange
		LOCAL m.cRange1, m.cRange2
		
		ldDate1 = tcperiod+'/01/'+tcyear
		m.cRange1 = LEFT(ldDate1,5)
		ldDate1 = GOMONTH(CTOD(ldDate1),1) - 1
		lcDate1 = DTOC(ldDate1)
		m.cRange2 = LEFT(lcDate1,5)
		
		IF TYPE('tcYear') = 'C'
		   lcYear = tcYear
		ELSE   
		   lcYear = STR(YEAR(DATE()),4)
		ENDIF   
		
		IF tcPeriod = '01'
		   lcPrd = '12'
		   lcYr  = STR(VAL(tcYear)-1,4)
		ELSE
		   lcPrd = PADL(ALLTRIM(STR(VAL(tcPeriod)-1,2)),2,'0')   
		   lcYr  = tcYear
		ENDIF   
		
		SELECT options
		GO TOP
		llCalcRange = lCalcRange
		
		SELECT wellrng
		SET ORDER TO wellprd
		IF SEEK (tcWellId+tcYear+tcPeriod)
		   DO CASE
		      CASE tcType = 'O'
		         m.crange1 = oprng1
		         m.crange2 = oprng2
		      CASE tcType = 'G'
		         m.cRange1 = gprng1
		         m.cRange2 = gprng2
		   ENDCASE
		ELSE     
		   DO CASE
		      CASE tcType = 'O'       
		         IF llCalcRange
		            IF SEEK(tcWellId+lcYr+lcPrd)
		               ldDate1  = CTOD(cRange2+'/'+lcYr)
		               lcDate1  = DTOC(ldDate1+1)
		               lcDate2  = DTOC(ldDate1+31)
		               lcRange1 = LEFT(lcDate1,5)
		               lcRange2 = LEFT(lcDate2,5)
		               m.cRange1 = lcRange1
		               m.cRange2 = lcRange2
		            ENDIF
		         ENDIF   
		      CASE tcType = 'G'       
		         IF llCalcRange
		            IF SEEK(tcWellId+lcYr+lcPrd)
		               ldDate1  = CTOD(cRange2+'/'+lcYr)
		               lcDate1  = DTOC(ldDate1+1)
		               lcDate2  = DTOC(ldDate1+31)
		               lcRange1 = LEFT(lcDate1,5)
		               lcRange2 = LEFT(lcDate2,5)
		               m.cRange1 = lcRange1
		               m.cRange2 = lcRange2
		            ENDIF
		         ENDIF 
		   ENDCASE
		ENDIF                          
		
		RETURN (m.cRange1+m.cRange2)
		
	ENDPROC

	PROCEDURE intonhold
		*
		*  Check for released interest on holds
		*
		SELECT invtmp
		SCAN FOR cownerid = THIS.cownerid AND ctypeinv = 'I'
		   m.crptgroup = 'J'
		   m.ctype     = 'MIN'
		   m.nwellnet  = nnetcheck
		   m.cperiod   = ''
		   m.cyear     = WellWork.hYear
		   m.cprogcode = 'ZZZZ'
		   m.cwelltype = '}ZZZZZZZ'
		   THIS.nOwnerTotal   = THIS.nOwnerTotal + nnetcheck
		   m.cdescript = 'Interest On Hold Released For Well: ' + invtmp.cwellid
		   m.cownerid = THIS.cownerid
		   m.nRunNo = this.nRunNo
		   *********************************************************************************************************
		   *  Insert into the statement file  - Report Group J     (Interest On Hold Released)
		   *********************************************************************************************************
		   INSERT INTO statemnt FROM MEMVAR
		ENDSCAN   && invtmp
		
	ENDPROC

	PROCEDURE main
		LPARAMETERS tlSelected
		LOCAL lcoldprog, lnowncount
		LOCAL lcoldprogname, lcperiod1, lcperiod2, lnperiodbal
		LOCAL llexemptroyalty, m.ljib, tcWellID1, tcWellID2
		
		llCanceled = .F.
		
		ON KEY LABEL esc llCanceled = .T.
		
		THIS.omessage = findglobalobject("cmmessage")
		
		*  For compatibility with new changes
		tlChecksonly = .f.
		
		SELECT wells
		SET ORDER TO cwellid
		GO TOP
		THIS.cWellID1 = cwellid
		GO BOTT
		THIS.cWellID2 = cwellid
		
		m.crunyear = THIS.crunyear
		
		*
		*  Call distproc to create the (invtmp) and (wellwork) cursors
		*
		IF THIS.nRunNo = 0
		   THIS.oDist = CREATEOBJECT('olddistproc',THIS.cOwner1, THIS.cOwner2, ;
		      '01', ;
		      THIS.crunyear, ;
		      THIS.cGroup, 'O', THIS.dAcctDate, .F.,0)
		ELSE
		   THIS.oDist = CREATEOBJECT('olddistproc',THIS.cOwner1, THIS.cOwner2, ;
		      '01', ;
		      THIS.crunyear, ;
		      THIS.cGroup, 'O', THIS.dAcctDate, .F.,THIS.nRunNo)
		ENDIF
		
		THIS.oDist.lFlatRates = THIS.lflatrate
		
		IF THIS.oDist.MAIN()
		   WAIT WIND NOWAIT 'Building Report File....'
		   LOCAL lnWellTot, lnInvTot, lnTotInc, jInvCnt, lnProgTot, lcoldprog, lcOldcProgName
		   LOCAL lnTax, lnInvCnt
		   LOCAL jSavePrd1, jSavePrd2, lcDirect, lnMinAmt
		   LOCAL lcperiod1, lcperiod2, m.cGrpName, llRefId, llChgPrice
		   LOCAL llHideComp, jGross
		
		   STORE 0 TO lnWellTot, lnInvTot, lnTotInc, jInvCnt, lnProgTot,  ;
		      M.nTax, jGross, lnInvCnt
		   STORE '   ' TO lcoldprog, lcOldcProgName, lcperiod1, lcperiod2, m.cPeriod
		
		   IF NOT USED('invtmp')
		      this.oDist = .Null.
		      RETURN .f.
		   ENDIF 
		   **-
		   **-  Get the suspense flag from the group table
		   **-
		   SELECT groups
		   SET ORDER TO cGroup
		   IF SEEK(THIS.cGroup)
		      THIS.lNetWells  = lNetDef
		   ELSE
		      THIS.lNetWells  = .T.
		   ENDIF
		
		   *  Reset used flag in roundtmp
		   IF USED('roundtmp')
		      SELE roundtmp
		      REPL lused WITH .F. FOR cDMBatch = THIS.cDMBatch
		   ENDIF
		
		   ***
		   ***   Get suspense balances
		   ***
		   IF THIS.lNetWells        && We will only report the current balance if netting
		      THIS.oDist.Suspcalc('**')
		   ENDIF
		   *
		   *  Create work cursor for report data
		   *
		   CREATE CURSOR  statemnt ;
		      (cRptGroup   C(1),    ;
		      lClosed     L,       ;
		      cWellType   C(30),    ;
		      cOwnerID    C(10),    ;
		      cOwnname    C(60),   ;
		      cOwnname1   C(60),   ;
		      caddress1   C(30),   ;
		      caddress2   C(30),   ;
		      ccityState  C(30),   ;
		      caddr1      C(30),   ;
		      caddr2      C(30),   ;
		      caddr3      C(30),   ;
		      czip        C(10),   ;
		      dAcctDate   D,       ;
		      cYear       C(4),    ;
		      cPeriod     C(2),    ;
		      ntotalcheck N(12,2), ;
		      nTotalBal   N(12,2), ;
		      cProgCode   C(10),   ;
		      cProgName   C(40),   ;
		      cwellid     C(10),   ;
		      cWellName   C(30),   ;
		      cCounty     C(40),   ;
		      cState      C(2),    ;
		      crange      C(11),   ;
		      ndayson     N(3),    ;
		      cTYPE       C(3),    ;
		      cSource     C(30),   ;
		      crefid      C(20),   ;
		      nUnits      N(12,4), ;
		      nprice      N(12,6), ;
		      nTOTAL      N(12,2), ;
		      ninvamt     N(12,2), ;
		      nRevInt     N(11,7), ;
		      nRoyInt     N(11,7), ;
		      nTotNet     N(12,2), ;
		      nWellNet    N(12,2), ;
		      nWorkTot    N(12,2), ;
		      dexpdate    D,       ;
		      cCategory   C(30),   ;
		      cPayee      C(30),   ;
		      nAmount     N(12,2), ;
		      nWorkInt    N(11,7), ;
		      ctypeinv    C(1),    ;
		      ctypeint    C(1),    ;
		      cDirect     C(1),    ;
		      nFlatRate   N(7,2),  ;
		      lFlat       L,       ;
		      lused       L,       ;
		      lwellpage   L,       ;
		      lusesev     L,       ;
		      cMethod     C(1),    ;
		      cTaxable    N(12,2), ;
		      lHold       L,       ;
		      lOnHold     L,       ;
		      lExpDate    L,       ;
		      ninvmin     N(12,2), ;
		      nIntClass1  N(11,7), ;
		      nIntClass2  N(11,7), ;
		      nIntClass3  N(11,7), ;
		      nIntClass4  N(11,7), ;
		      nIntClass5  N(11,7), ;
		      cMiscMemo   C(30),   ;
		      ljib        L,       ;
		      glStminv    L, ;
		      glExpDate   L, ;
		      cProdPrd    C(7),    ;
		      cDescript   M,       ;
		      crunyear    C(4), ;
		      nRunNo      I, ;
		      lCloseRun   L)
		   INDEX ON cOwnerID+cWellType+cRptGroup TAG invwell
		   IF THIS.lziporder
		      INDEX ON czip+cOwnerID+cProgCode+cWellType+cRptGroup TAG invprog
		   ELSE
		      INDEX ON cOwnerID+cProgCode+cWellType+cRptGroup TAG invprog
		   ENDIF
		
		   * Initialize the fields
		   SELECT statemnt
		   SCATTER MEMVAR BLANK
		
		   *
		   *  Add accounting date to the records if not already there
		   *
		   IF THIS.oDist.CheckhistRun()
		      SELECT sysctl
		      LOCATE FOR crunyear = THIS.crunyear AND nRunNo = THIS.nRunNo AND cTypeClose='R'
		      IF FOUND()
		         m.dAcctDate = dAcctDate
		      ELSE
		         m.dAcctDate = THIS.dAcctDate
		      ENDIF
		   ELSE
		      m.dAcctDate = THIS.dAcctDate
		   ENDIF
		
		   THIS.dAcctDate = m.dAcctDate
		
		   *
		   *  Get the Accounting Month
		   *
		   lcAcctPrd = PADL(ALLTRIM(STR(MONTH(m.dAcctDate),2)),2,'0')
		
		   SELECT invtmp
		   GO TOP
		   REPLACE hdate WITH m.dAcctDate FOR EMPTY(hdate)
		   GO TOP
		   DELETE FOR NOT BETWEEN(cOwnerID, THIS.cOwner1, THIS.cOwner2)
		   IF USED('tmp')
		      USE IN tmp
		   ENDIF
		
		   IF USED('invtmpx')
		      USE IN invtmpx
		   ENDIF
		   IF USED('owntmp')
		      USE IN owntmp
		   ENDIF
		   IF USED('tmpsusp')
		      USE IN tmpsusp
		   ENDIF
		   IF USED('invtotx')
		      USE IN invtotX
		   ENDIF
		
		   IF USED('invsusp')
		      SELECT invsusp
		      REPLACE hdate WITH m.dAcctDate FOR EMPTY(hdate)
		   ENDIF
		
		   *
		   *  Total investor's wells to get check nAmounts
		   *
		   CREATE CURSOR invtotal ;
		      (cOwnerID    C(10), ;
		      hdate       D, ;
		      ntotalcheck     N(12,2))
		   INDEX ON cOwnerID TAG owner
		
		   SELECT cOwnerID, hdate, SUM(ROUND(nNetCheck,2)) AS ntotalcheck  ;
		      FROM invtmp ;
		      WHERE BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) ;
		      INTO CURSOR invtotX ;
		      GROUP BY cOwnerID ;
		      ORDER BY cOwnerID
		
		   SELECT invtotal
		   APPEND FROM DBF('invtotx')
		   SELECT invtotX
		   USE
		
		   *
		   *  Create temporary invtmp to calculate totals
		   *
		   SELECT invtmp.*, .T. AS lFlag FROM invtmp INTO CURSOR invx
		   IF USED('invxxx')
		      USE IN invxxx
		   ENDIF
		   USE DBF('invx') AGAIN IN 0 ALIAS invxxx
		
		   *
		   *   Bring in wells not covered this period but sent to suspense
		   *
		
		   IF USED('invsusp')
		      SELECT invsusp
		      GO TOP
		      SCAN FOR nNetCheck < 0 AND NOT lOnHold
		         SCATTER MEMVAR
		         IF NOT EMPTY(ALLT(m.cProgCode)) AND m.cProgCode <> 'NONE'
		            SELECT invtmp
		            LOCATE FOR cOwnerID+cwellid+ctypeinv+ctypeint+cProgCode+hyear+hperiod = m.cOwnerID+m.cwellid+m.ctypeinv+m.ctypeint+m.cProgCode+m.hyear+m.hperiod AND nWorkInt = m.nWorkInt
		            IF !FOUND()
		               IF THIS.lNetWells
		                  INSERT INTO invtmp FROM MEMVAR
		                  INSERT INTO invxxx FROM MEMVAR
		               ENDIF
		            ELSE
		               IF THIS.lNetWells
		                  REPLACE nNetCheck WITH nNetCheck + m.nNetCheck, ;
		                     nincome   WITH m.nincome, ;
		                     nExpense  WITH m.nExpense, ;
		                     nSevTaxes WITH m.nSevTaxes, ;
		                     lused     WITH .F.
		                  SELECT invxxx
		                  LOCATE FOR cOwnerID+cwellid+ctypeinv+ctypeint+cProgCode+hyear+hperiod = m.cOwnerID+m.cwellid+m.ctypeinv+m.ctypeint+m.cProgCode+m.hyear+m.hperiod AND nWorkInt = m.nWorkInt
		                  IF FOUND()
		                     REPLACE nNetCheck WITH nNetCheck + m.nNetCheck, ;
		                        nincome   WITH m.nincome, ;
		                        nExpense  WITH m.nExpense, ;
		                        nSevTaxes WITH m.nSevTaxes, ;
		                        lused     WITH .F.
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		         SELECT invsusp
		      ENDSCAN
		   ENDIF
		
		   *
		   *  Total investor's wells to get check nAmounts
		   *
		   SELECT cOwnerID, hdate, SUM(ROUND(nNetCheck,2)) AS ntotalcheck  ;
		      FROM invxxx ;
		      WHERE BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) ;
		      INTO CURSOR invtotX ;
		      GROUP BY cOwnerID ;
		      ORDER BY cOwnerID
		   *   SELECT invxxx
		   *   USE
		
		   SELECT invtotX
		   SCAN
		      SCATTER MEMVAR
		      SELECT invtotal
		      SET ORDER TO owner
		      SEEK m.cOwnerID
		      IF FOUND()
		         *
		         *  Only replace those totals of owners whose
		         *  current nAmount is a deficit, otherwise the
		         *  total should equal the check nAmount.
		         *
		         IF ntotalcheck <= 0
		            REPLACE ntotalcheck WITH m.ntotalcheck
		         ENDIF
		      ELSE
		         APPEND BLANK
		         REPLACE cOwnerID WITH m.cOwnerID, ;
		            hdate    WITH m.hdate,    ;
		            ntotalcheck  WITH m.ntotalcheck
		      ENDIF
		   ENDSCAN
		
		   DO CASE
		      CASE THIS.lNetWells
		         *
		         *  Bring in wells that are in programs that were not covered this period.
		         *
		         IF USED('invsusp')
		            SELECT invsusp
		            GO TOP
		            SCAN FOR nNetCheck < 0 AND EMPTY(ALLT(cProgCode)) AND NOT lOnHold
		               SCATTER MEMVAR
		               SELECT invtmp
		               LOCATE FOR cOwnerID+cwellid+ctypeinv+ctypeint+cProgCode+hyear+hperiod = m.cOwnerID+m.cwellid+m.ctypeinv+m.ctypeint+m.cProgCode+m.hyear+m.hperiod
		               IF !FOUND()
		                  INSERT INTO invtmp FROM MEMVAR
		                  INSERT INTO invxxx FROM MEMVAR
		               ELSE
		                  REPLACE nNetCheck WITH nNetCheck + m.nNetCheck, ;
		                     lused     WITH .F., ;
		                     nSevTaxes WITH nSevTaxes + m.nSevTaxes, ;
		                     nincome   WITH nincome   + m.nincome, ;
		                     nExpense  WITH nExpense  + m.nExpense
		                  INSERT INTO invxxx FROM MEMVAR
		               ENDIF
		               SELECT invsusp
		            ENDSCAN
		         ENDIF
		
		         *
		         *  Bring in interests that are on hold.
		         *
		         IF USED('invsusp')
		            SELECT invsusp
		            GO TOP
		            SCAN FOR lOnHold
		               SCATTER MEMVAR
		               INSERT INTO invtmp FROM MEMVAR
		               INSERT INTO invxxx FROM MEMVAR
		            ENDSCAN
		         ENDIF
		
		         *
		         *  Total investor's wells to get check nAmounts
		         *
		         SELECT cOwnerID, hdate, SUM(ROUND(nNetCheck,2)) AS ntotalcheck  ;
		            FROM invxxx ;
		            WHERE BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) ;
		            INTO CURSOR invtotX ;
		            GROUP BY cOwnerID ;
		            ORDER BY cOwnerID
		         SELECT invxxx
		         USE
		
		         SELECT invtotX
		         SCAN
		            SCATTER MEMVAR
		            SELECT invtotal
		            SET ORDER TO owner
		            SEEK m.cOwnerID
		            IF FOUND()
		               *
		               *  Only replace those totals of owners whose
		               *  current nAmount is a deficit, otherwise the
		               *  total should equal the check nAmount.
		               *
		               IF ntotalcheck <= 0
		                  REPLACE ntotalcheck WITH m.ntotalcheck
		               ENDIF
		            ELSE
		               APPEND BLANK
		               REPLACE cOwnerID WITH m.cOwnerID, ;
		                  hdate    WITH m.hdate,    ;
		                  ntotalcheck  WITH m.ntotalcheck
		            ENDIF
		         ENDSCAN
		
		      CASE NOT THIS.lNetWells
		         *
		         *  Bring in interests that are on hold.
		         *
		         IF USED('invsusp')
		            SELECT invsusp
		            GO TOP
		            SCAN FOR lOnHold
		               SCATTER MEMVAR
		               INSERT INTO invtmp FROM MEMVAR
		            ENDSCAN
		         ENDIF
		
		         CREATE CURSOR invtotal ;
		            (cOwnerID    C(10), ;
		            hdate       D, ;
		            ntotalcheck     N(12,2))
		         SELECT cOwnerID, hdate, SUM(ROUND(IIF(lOnHold,0,nNetCheck),2)) AS ntotalcheck  ;
		            FROM invtmp ;
		            WHERE BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) ;
		            INTO CURSOR invtotX ;
		            GROUP BY cOwnerID ;
		            ORDER BY cOwnerID
		         IF _TALLY <> 0
		            SELECT invtotal
		            APPEND FROM DBF('invtotx')
		            SELECT invtotX
		            USE
		         ENDIF
		
		         *
		         *   Bring in wells not covered this period but sent to suspense
		         *
		         IF USED('invsusp')
		            * Add totals for deficit owners with no other activity
		            SELECT cOwnerID, hdate, SUM(ROUND(IIF(lOnHold,0,nNetCheck),2)) AS ntotalcheck  ;
		               FROM invsusp ;
		               WHERE BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) ;
		               AND NOT lOnHold ;
		               INTO CURSOR invtotX ;
		               GROUP BY cOwnerID ;
		               ORDER BY cOwnerID
		            SET SAFETY OFF
		            SELE invtmp
		            INDEX ON cOwnerID+cwellid+ctypeinv+hyear+hperiod TAG invwell
		            SELECT invsusp
		            SCAN FOR NOT lOnHold
		               SCATTER MEMVAR
		               SELECT invtmp
		               SET ORDER TO invwell
		               SEEK (m.cOwnerID+m.cwellid+m.ctypeinv+m.hyear+m.hperiod)
		               IF !FOUND()
		                  INSERT INTO invtmp FROM MEMVAR
		               ENDIF
		               SELECT invsusp
		               DELETE NEXT 1
		            ENDSCAN
		
		            *  Add totals for deficit owners with no other activity
		            IF _TALLY <> 0
		               SELE invtotX
		               SCAN
		                  SCATTER MEMVAR
		                  SELECT invtotal
		                  LOCATE FOR cOwnerID = m.cOwnerID
		                  IF NOT FOUND()
		                     INSERT INTO invtotal FROM MEMVAR
		                  ENDIF
		               ENDSCAN
		            ENDIF
		         ENDIF
		   ENDCASE
		
		   *
		   *  Build the statemnt file
		   *
		   SELECT invtmp
		   COUNT FOR NOT DELETED() TO lnCount
		
		   IF lnCount <= 0
		      IF NOT THIS.lNetWells
		         *
		         *   Bring in wells not covered this period but sent to suspense
		         *
		         IF USED('invsusp')
		            SELECT invsusp
		            GO TOP
		            SCAN FOR nNetCheck < 0 AND NOT lOnHold
		               SCATTER MEMVAR
		               SELECT invtmp
		               SET ORDER TO invtype
		               SEEK (m.cOwnerID+m.cwellid+m.ctypeinv+m.ctypeint+m.cProgCode)
		               IF !FOUND()
		                  INSERT INTO invtmp FROM MEMVAR
		               ENDIF
		               SELECT invsusp
		            ENDSCAN
		         ENDIF
		         CREATE CURSOR invtotal ;
		            (cOwnerID    C(10), ;
		            hdate       D, ;
		            ntotalcheck     N(12,2))
		         SELECT cOwnerID, hdate, SUM(ROUND(IIF(lOnHold,0,nNetCheck),2)) AS ntotalcheck  ;
		            FROM invtmp ;
		            WHERE BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) ;
		            INTO CURSOR invtotX ;
		            GROUP BY cOwnerID ;
		            ORDER BY cOwnerID
		         IF _TALLY <> 0
		            SELECT invtotal
		            APPEND FROM DBF('invtotx')
		            SELECT invtotX
		            USE
		         ENDIF
		      ELSE
		         CREATE CURSOR invtotal ;
		            (cOwnerID    C(10), ;
		            hdate       D, ;
		            ntotalcheck     N(12,2))
		         SELECT cOwnerID, hdate, SUM(ROUND(nNetCheck,2)) AS ntotalcheck  ;
		            FROM invtmp ;
		            WHERE BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) ;
		            AND NOT lOnHold ;
		            INTO CURSOR invtotX ;
		            GROUP BY cOwnerID ;
		            ORDER BY cOwnerID
		         IF _TALLY <> 0
		            SELECT invtotal
		            APPEND FROM DBF('invtotx')
		            SELECT invtotX
		            USE
		         ENDIF
		      ENDIF  && IF NOT THIS.lNetWells
		   ENDIF
		
		
		
		   *
		   *  Get report criteria
		   *
		
		   m.nRunNo    = THIS.nRunNo
		   m.crunyear  = THIS.crunyear
		
		   * Clear up temporary cursors from previous statements
		   IF USED('name')
		      USE IN NAME
		   ENDIF
		
		   * Check to see if we're processing a new or closed run
		
		   THIS.lClosed = (NOT THIS.nRunNo = 0)
		
		   *  Remove owner types not being reported
		   THIS.pulltype()
		
		   *  Build a cursor for storing owner statement notes
		   CREATE CURSOR ownnotes ;
		      (cOwnerID  C(10), ;
		      cwellid   C(10), ;
		      mNotes    M)
		
		   *
		   *  Initialize memory variables
		   *
		   STORE ' ' TO m.crptgoup, m.cOwnerID, m.cOwnname, m.caddr1, m.caddr2, m.ccitycstate, ;
		      M.cYear, m.cPeriod, m.coilprd1, m.coilprd2, m.cgasprd1, m.cgasprd2,  ;
		      M.cwellid, m.cWellName, m.cSource, m.cCategory, m.cPayee, m.ctypeinv, ;
		      M.ctypeint, m.cMiscMemo, m.cDescript, lcoldprog, lcoldprogname, lcperiod1, lcperiod2
		   STORE 0   TO m.ntotalcheck, m.nUnits, m.nprice, m.ninvamt, m.nRevInt,  ;
		      M.nWorkTot, m.nlandpct, m.noverpct, m.nAmount, m.nWorkInt, THIS.nOwnerTotal, ;
		      M.nIntClass1, m.nIntClass2, m.nIntClass3, m.nIntClass4, m.nIntClass5
		   STORE 0 TO lnowncount, THIS.nWellTot, THIS.nTotInc, lnperiodbal
		
		   STORE .F. TO THIS.lExemptRoyalty, m.ldiroilpurch, m.ldirgaspurch, m.ljib
		
		   * Create cursor to hold program totals
		   CREATE CURSOR progtots ;
		      (cOwnerID   C(10), ;
		      cProgCode  C(10), ;
		      nprogtot   N(12,2))
		
		   *
		   *  Get list of owners that are getting checks
		   *
		   IF tlChecksOnly = .T.
		      SELECT cid AS cOwnerID ;
		         FROM checks ;
		         WHERE cbatch = tcDMBatch ;
		         AND BETWEEN(cid, THIS.cOwner1, THIS.cOwner2) ;
		         INTO CURSOR tempchks ORDER BY cid
		      IF _tally > 0
		         SELE invtmp
		         SCAN
		            m.cOwnerID = cOwnerID
		            SELE tempchks
		            LOCATE FOR cOwnerID = m.cOwnerID
		            IF NOT FOUND()
		               SELE invtmp
		               DELE NEXT 1
		            ENDIF
		         ENDSCAN
		         SELE invtotal
		         SCAN
		            m.cOwnerID = cOwnerID
		            SELE tempchks
		            LOCATE FOR cOwnerID = m.cOwnerID
		            IF NOT FOUND()
		               SELE invtotal
		               DELE NEXT 1
		            ENDIF
		         ENDSCAN
		         USE IN tempchks
		         ERASE tempchks.DBF
		      ENDIF
		   ENDIF
		
		   *
		   *  Get the current period total before suspense is brought in.
		   *
		   SELECT cOwnerID, hdate, SUM(ROUND(nNetCheck,2)) AS ntotalcheck  ;
		      FROM invtmp ;
		      WHERE NOT INLIST(ctypeinv,'M','X','I') ;
		      AND NOT lOnHold ;
		      INTO CURSOR presusptot ;
		      GROUP BY cOwnerID ;
		      ORDER BY cOwnerID
		
		   *  Index invtmp on netcheck to gain rushmore
		   SET SAFETY OFF
		   SELECT invtmp
		   INDEX ON nNetCheck TAG nNetCheck
		
		   SELECT options
		   GO TOP
		   SCATTER NAME THIS.oOptions
		
		   glStminv   = lstminv
		   gnmincheck = nmincheck
		   glhidecomp = lhidecomp
		   glshowroy  = lshowroy
		   glacctdesc = lacctdesc
		   glrefid    = lrefid
		   glexpsum   = lexpsum
		   glchgprice = lchgprice
		   gngather   = ngather
		   gncompress = ncompress
		   gldirinv   = ldirinv
		   llroycomp  = lroycomp
		   llbilldesc = lbilldesc
		   llshowvendor = lshowvendor
		   m.lExpDate  = lExpDate
		   m.glExpDate = lExpDate
		
		   **-
		   **-  Get producer's address information
		   **-
		   **- Check on the existence of the application object
		   **- if it doesn't exist, we're running in development
		   **- mode and need to initialize the company address info.
		   IF TYPE('m.goApp') = 'O'
		      m.caddr1 = m.goapp.caddress1
		      m.caddr2 = m.goapp.caddress2
		      m.caddr3 = m.goapp.caddress3
		      m.ctax   = m.goapp.ctaxid
		      IF EMPTY(m.goapp.ccompanyname) OR ALLT(m.goapp.ccompanyname) = "''"
		         m.goapp.ccompanyname = 'Sherwood Energy'
		      ENDIF
		      IF EMPTY(m.caddr1) OR ALLT(m.caddr1) = "''"
		         m.caddr1 = 'PO Box 209'
		      ENDIF
		      IF EMPTY(m.caddr2) OR ALLT(m.caddr2) = "''"
		         m.caddr2 = 'Apple Creek, OH 44606'
		      ENDIF
		      IF EMPTY(m.caddr3) OR ALLT(m.caddr3) = "''"
		         m.caddr3 = ''
		      ENDIF
		   ELSE
		      m.caddr1 = 'PO Box 223'
		      m.caddr2 = 'Wooster, OH  44691'
		      m.caddr3 = ''
		      m.ctax   = '99-9999999'
		   ENDIF
		
		   *  Get the total invtmp records we're going to process so the progress bar updates correctly.
		   SELECT invtmp
		   SET ORDER TO invprog
		   lnCount = 1
		   COUNT FOR BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) TO lnmax
		   IF lnmax = 0
		      RETURN .F.
		   ENDIF
		   GO TOP
		
		   *  Add back exempt owners taxes
		   THIS.oDist.Taxexempt(.T.)
		
		   oprogress = THIS.omessage.progressbar('Building Owner Statements....Press ESC To Cancel')
		   oprogress.setprogressrange(0,lnmax)
		   *
		   *  Prepare expense table
		   *
		   CREATE CURSOR exptemp ;
		      (cwellid    C(10), ;
		      cCatCode   C(4), ;
		      ccateg     C(20), ;
		      cYear      C(4), ;
		      cPeriod    C(2), ;
		      crefid     C(20), ;
		      dexpdate   D, ;
		      nAmount    N(12,2), ;
		      cPayee     C(40), ;
		      cmemo      C(30), ;
		      cvendorid  C(10), ;
		      cpaidbyck  C(8), ;
		      cExpClass  C(1), ;
		      nsaltwater I, ;
		      cprdpaid   C(6), ;
		      lfixed     L, ;
		      laptran    L, ;
		      cbatch     C(8), ;
		      cOwnerID   C(10), ;
		      loneman    L, ;
		      cdescrip   C(30), ;
		      lused      L)
		
		   IF THIS.oOptions.lexpsum         && Summarize expenses
		      SELECT expense
		      SCAN FOR BETWEEN(cwellid,THIS.cWellID1,THIS.cWellID2) ;
		            AND IIF(THIS.nRunNo=0,nrunnorev=0 AND dexpdate <= THIS.dAcctDate,nrunnorev=THIS.nRunNo AND crunyearrev=THIS.crunyear) ;
		            AND cYear <> 'FIXD' AND cCatCode <> 'MKTG'
		         SCATTER MEMVAR
		         SELE expcat
		         SET ORDER TO cCatCode
		         IF SEEK(m.cCatCode)
		            m.cdescrip  = cdescrip
		         ELSE
		            LOOP
		         ENDIF
		         m.loneman = .F.
		         SELE exptemp
		         LOCATE FOR cwellid = m.cwellid AND ;
		            cCatCode == m.cCatCode AND cOwnerID = m.cOwnerID AND cExpClass = m.cExpClass
		         IF FOUND()
		            REPL nAmount WITH nAmount + m.nAmount
		         ELSE
		            INSERT INTO exptemp FROM MEMVAR
		         ENDIF
		      ENDSCAN
		   ELSE
		      SELECT expense
		      SCAN FOR BETWEEN(cwellid,THIS.cWellID1,THIS.cWellID2) ;
		            AND IIF(THIS.nRunNo=0,nrunnorev=0 AND dexpdate <= THIS.dAcctDate,nrunnorev=THIS.nRunNo AND crunyearrev=THIS.crunyear) ;
		            AND cYear <> 'FIXD' AND cCatCode <> 'MKTG'
		         SCATTER MEMVAR
		         m.loneman = .F.
		         SELE expcat
		         SET ORDER TO cCatCode
		         IF SEEK(m.cCatCode)
		            m.cdescrip  = cdescrip
		         ELSE
		            LOOP
		         ENDIF
		         INSERT INTO exptemp FROM MEMVAR
		      ENDSCAN
		   ENDIF
		
		   *
		   *  Reset the one-man-item flag in the Income file.
		   *
		   SELECT income
		   REPLACE loneman WITH .F. FOR loneman = .T.
		
		   *  Build the statement totals if the cursor hasn't been built yet.
		   SELE invtotal
		   IF RECC() = 0
		      SELECT cOwnerID, hdate, SUM(ROUND(nNetCheck,2)) AS ntotalcheck  ;
		         FROM invtmp ;
		         WHERE BETWEEN(cOwnerID,THIS.cOwner1,THIS.cOwner2) ;
		         INTO CURSOR invtotX ;
		         GROUP BY cOwnerID ;
		         ORDER BY cOwnerID
		      SELECT invtotal
		      APPEND FROM DBF('invtotx')
		      SELECT invtotX
		      USE
		   ENDIF
		
		   *  Remove owner history records with no production if we're not reporting non producing wells.
		   IF THIS.lNoProd = .F.
		      SELE invtmp
		      SCAN
		         IF invtmp.nincome = 0 AND ;
		               (invtmp.nExpense+invtmp.ntotale1+invtmp.ntotale2+invtmp.ntotale3+;
		               invtmp.ntotale4+invtmp.ntotale5+invtmp.ntotalea+invtmp.ntotaleb) = 0 ;
		               AND invtmp.nSevTaxes = 0 AND invtmp.nNetCheck = 0
		            SELE stmtnote
		            LOCATE FOR cwellid == invtmp.cwellid AND nRunNo == invtmp.nRunNo AND crunyear == invtmp.crunyear
		            IF FOUND()
		               DO CASE
		                  CASE stmtnote.nnotetype = 1
		                     IF invtmp.ctypeinv = 'L'
		                        LOOP
		                     ENDIF
		                  CASE stmtnote.nnotetype = 2
		                     IF invtmp.ctypeinv = 'O'
		                        LOOP
		                     ENDIF
		                  CASE stmtnote.nnotetype = 3
		                     IF invtmp.ctypeinv = 'O' OR invtmp.ctypeinv = 'L'
		                        LOOP
		                     ENDIF
		                  CASE stmtnote.nnotetype = 4
		                     IF invtmp.ctypeinv = 'W'
		                        LOOP
		                     ENDIF
		                  CASE stmtnote.nnotetype = 5
		                     LOOP
		               ENDCASE
		            ENDIF
		            SELE invtmp
		            DELE NEXT 1
		         ENDIF
		      ENDSCAN
		   ENDIF
		
		   * Get unique owner, well and owner types
		   SELECT cOwnerID, cwellid, ctypeinv FROM invtmp INTO CURSOR owntypes ORDER BY cOwnerID, cwellid, ctypeinv GROUP BY cOwnerID, cwellid, ctypeinv
		
		   *  Calculate the suspense balances
		   THIS.oDist.Suspcalc('**', .F., .T., .T.)
		
		   * Start building a statement for each owner
		   SELECT invtotal
		   SCAN
		      IF llCanceled
		         IF THIS.omessage.CONFIRM('Cancel report generation?')
		            THIS.lCanceled = .T.
		            EXIT
		         ENDIF
		         THIS.lCanceled = .F.
		         llCanceled = .F.
		      ENDIF
		      SCATTER MEMVAR
		
		      SELE exptemp
		      REPL lused WITH .F. ALL
		      * Set a flag that we're working with a different owner than before
		      llnewowner = .T.
		      * Save the current owner since we have to check for one-man items
		      THIS.cOwnerID = m.cOwnerID
		      STORE ' ' TO THIS.OwnerGroup
		      STORE 0 TO THIS.nOwnerTotal
		
		      *  Get the suspense balance before this run.
		      SELECT presusptot
		      LOCATE FOR cOwnerID = THIS.cOwnerID
		      IF FOUND()
		         m.npretotal = ntotalcheck
		      ELSE
		         m.npretotal = 0
		      ENDIF
		
		      **-
		      **- Check to see if deficit nAmount cStatements should be printed
		      **-
		      IF NOT THIS.lprintdef AND m.ntotalcheck < 0
		         LOOP
		      ENDIF
		
		      **-
		      **- Check to see if this owner has an outstanding suspense balance
		      **-
		      jTotal = m.ntotalcheck
		      m.nTotalBal = m.ntotalcheck
		
		      * If wells are netted together and the current month is a negative
		      * show current suspense balance at top of statement for all owners
		      IF THIS.lNetWells AND jTotal <= 0
		         STORE 0 TO lnSuspBbalance, lnCoveredBal, m.nSuspBal
		
		         TRY 
		         SELECT suspbalown
		         LOCATE FOR cOwnerID = m.cOwnerID
		         IF FOUND()
		            lnSuspBalance = nNetOwn    &&  Balance before this month
		         ELSE
		            lnSuspBalance = 0
		         ENDIF
		         CATCH
		            lnSuspBalance = 0
		         ENDTRY 
		
		         *  Look for any suspense brought in this month.
		         *  Added between stmt to fix problem with rounding 6/12/01 pws
		         IF BETWEEN(jTotal,-.03,.03) AND NOT jTotal = 0
		            jTotal = 0
		            m.nTotalBal = 0
		            SELE invtmp
		            SCAN FOR cOwnerID = THIS.cOwnerID AND INLIST(ctypeinv,'M','X','I')
		               lnCoveredBal = lnCoveredBal + nNetCheck     && Subtract current month's suspense activity
		            ENDSCAN
		         ENDIF
		
		         *!*	         IF m.npretotal > 0 AND m.nTotalBal = 0
		         *!*	            m.nTotalBal = m.npretotal + lnSuspBalance - lnCoveredBal + m.nSuspBal
		         *!*	         ELSE
		         *!*	            m.nTotalBal = m.nTotalBal + lnSuspBalance - lnCoveredBal + m.nSuspBal
		         *!*	         ENDIF
		      ENDIF
		
		      SELECT invtotal
		      m.dAcctDate = m.hdate
		      m.cRptGroup = 'A'
		      m.cYear     = THIS.crunyear
		      SELECT investor
		      SET ORDER TO cOwnerID
		      IF SEEK(THIS.cOwnerID)
		         *
		         *  Check to see if this investors deficit cStatement should be printed
		         *
		         SCATTER MEMVAR
		         THIS.lOwnerTaxExempt = lExempt
		         THIS.lOwnerOnHold = lHold
		         WAIT WIND NOWAIT 'Building Statement for ' + ALLT(csortfield)
		         IF investor.lprtdef = .F. AND m.ntotalcheck < 0
		            LOOP
		         ENDIF
		
		         *
		         *  Don't print dummy owner cStatements
		         *
		         IF investor.ldummy
		            LOOP
		         ENDIF
		
		         IF THIS.lClosed
		            IF THIS.oDist.lRelmin
		               THIS.lAllMinsReleased  = .T.
		               m.ninvmin = 0
		            ELSE
		               IF m.ninvmin = 0
		                  m.ninvmin = gnmincheck
		               ENDIF
		            ENDIF
		         ELSE
		            IF m.ninvmin = 0
		               m.ninvmin = THIS.oOptions.nmincheck
		            ENDIF
		         ENDIF
		
		         STORE 0 TO THIS.nBackupWith, THIS.nTaxWith
		
		         **-
		         **-  Setup the minimum check nAmount so that the Statement can
		         **-  notify the owner if the net Amount is below the minimum.
		         **-
		         DO CASE
		            CASE THIS.lOwnerOnHold                  && Owner on hold - set minimum to max so owner stays on hold
		               m.ninvmin = 99999999
		            CASE THIS.lAllMinsReleased    && Releasing minimums - set minimum amount to zero
		               m.ninvmin = 0
		            CASE m.ndisbfreq = 2          && Quarterly owner - set minimum to max if not at the end of qtr
		               IF NOT INLIST(lcAcctPrd,'03','06','09','12')
		                  m.invmin = 99999999
		               ENDIF
		            CASE m.ndisbfreq = 3          && SemiAnnually owner - set minimum to max if not at middle or end of year
		               IF NOT INLIST(lcAcctPrd,'06','12')
		                  m.ninvmin = 99999999
		               ENDIF
		            CASE m.ndisbfreq = 4          && Annual owner - set minimum to max if not at end of year
		               IF lcAcctPrd <> '12'
		                  m.ninvmin = 99999999
		               ENDIF
		         ENDCASE
		
		         * If this statement is under the minimum check amount and we're not printing
		         * minimum statements, skip this statement.
		         IF NOT THIS.lPrintMin AND m.ntotalcheck < m.ninvmin AND m.ntotalcheck > 0
		            LOOP
		         ENDIF
		
		         **-
		         **-  If the statment should be sent to the secondary address
		         **-  pull in the secondary address, otherwise pull in the
		         **-  primary address.
		         **-
		         IF m.lchktosec AND NOT m.lcheckonly
		            m.cOwnname = m.cownname2
		            m.caddress1 = m.caddress2a
		            m.czip = m.czip2
		            IF NOT EMPTY(m.caddress2b)
		               m.caddress2  = m.caddress2b
		               m.ccityState = ALLTRIM(m.ccity2)+' '+m.cstate2+'  '+m.czip2
		            ELSE
		               m.caddress2  = ALLTRIM(m.ccity2)+' '+m.cstate2+'  '+m.czip2
		               m.ccityState = ' '
		            ENDIF
		         ELSE
		            m.czip = m.czip1
		            IF NOT EMPTY(m.caddress1a)
		               m.caddress1 = m.caddress1a
		               IF NOT EMPTY(m.caddress1b)
		                  m.caddress2 = m.caddress1b
		                  m.ccityState = ALLTRIM(m.ccity1)+' '+m.cstate1+'  '+m.czip1
		               ELSE
		                  m.caddress2 = ALLTRIM(m.ccity1)+' '+m.cstate1+'  '+m.czip1
		                  m.ccityState = ''
		               ENDIF
		            ELSE
		               IF NOT EMPTY(m.caddress1b)
		                  m.caddress1  = m.caddress1b
		                  m.caddress2  = ALLTRIM(m.ccity1)+' '+m.cstate1+'  '+m.czip1
		                  m.ccityState = ''
		               ELSE  &&  Blank out address for people with no address, so it doesn't just carry forward the same address from the last owner who had an address filled in
		                  m.caddress1 = ''
		                  m.caddress2 = ''
		                  m.ccityState = ''
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		
		      llWellProd = .F.
		
		      * Build a cursor of totals for the owner and well
		      SELE SUM(ngrossgas+ngrossoil) AS nbal FROM wellwork ;
		         INTO CURSOR tempgross ORDER BY cwellid GROUP BY cwellid
		
		      *  Start scan of owner types.  We need to scan through wellwork for each owner type record so
		      *  that if an owner has more than one interest in the well, we'll process for each interest.
		      SELE owntypes
		      SCAN FOR cOwnerID = THIS.cOwnerID
		         lcTypeOwner = ctypeinv
		         lcWellID    = cwellid
		
		         THIS.lFlatAlloc = .F.
		         THIS.lDeficitProcessed = .F.
		
		         * Scan through wellwork for each well the owner has an interest in.
		         SELE wellwork
		         SET ORDER TO wellprd
		         SCAN FOR cwellid = lcWellID
		            SCATTER NAME THIS.oWellWork
		            THIS.cwellid = wellwork.cwellid
		            m.cwellid = THIS.cwellid
		            m.nroyalty   = nRoyInt
		
		            * Scan through the temp owner history for each record with the given ownerid,
		            * well, owner type and production period
		            SELECT invtmp
		            SET ORDER TO ownertype
		            THIS.lcOldOwnerID = ''  &&  Storing previous owner ID for expense processing
		            SCAN FOR cOwnerID = THIS.cOwnerID ;
		                  AND hyear+hperiod = THIS.oWellWork.hyear+THIS.oWellWork.hperiod    ;
		                  AND cwellid  = lcWellID     ;
		                  AND ctypeinv = lcTypeOwner ;
		                  AND NOT INLIST(ctypeinv,'S','M','X','I')
		
		               IF EMPTY(THIS.lcOldOwnerID)  &&  First time through, replace the blank lcOldOwnerID with the current one
		                  THIS.lcOldOwnerID = THIS.cOwnerID
		               ENDIF
		
		               *  Update the progress bar
		               oprogress.updateprogress(lnCount)
		               lnCount = lnCount + 1
		
		               llnoprod = .F.
		
		               SELECT programs
		               m.cProgCode = invtmp.cProgCode
		               LOCATE FOR cProgCode = m.cProgCode
		               IF FOUND()
		                  m.cProgName = cProgName
		               ELSE
		                  m.cProgName = ''
		               ENDIF
		
		               IF THIS.lNoProd = .T.
		                  SELE tempgross
		                  LOCATE FOR cwellid = THIS.oWellWork.cwellid
		                  IF nbal <> 0
		                     llWellProd = .T.
		                     IF THIS.OwnerGroup <> ' '   && If this isn't the 1st time through for this owner
		                        IF invtmp.nincome = 0 AND (invtmp.nExpense+invtmp.ntotale1+invtmp.ntotale2+invtmp.ntotale3+invtmp.ntotale4+invtmp.ntotale5) = 0 ;
		                              AND invtmp.nSevTaxes = 0 AND invtmp.nNetCheck = 0
		                           *  Don't process invtmp records for periods with no activity if we have
		                           *  invtmp records for the same well with activity.  This prevents multple
		                           *  "A" rptgroup records in statemnt
		                           LOOP     && Loop back to invtmp scan
		                        ENDIF
		                     ENDIF
		                  ELSE
		                     llWellProd = .F.
		                  ENDIF
		               ENDIF
		
		               *  Set the flag that tells whether we have production this period or not.
		               IF invtmp.nincome = 0 AND (invtmp.nExpense+invtmp.ntotale1+invtmp.ntotale2+invtmp.ntotale3+invtmp.ntotale4+invtmp.ntotale5) = 0 ;
		                     AND invtmp.nSevTaxes = 0 AND invtmp.nNetCheck = 0
		                  llnoprod   = .T.
		                  llWellProd = .F.
		               ELSE
		                  llnoprod   = .F.
		                  llWellProd = .T.
		               ENDIF
		
		               SELE invtmp
		               *  Process net well totals when not splitting prod prds into their own section
		
		               THIS.NetWellTotalNoSplit()
		
		               *  Continue scan through invtmp
		               SELE invtmp
		               * Create the oInvTmp object so other methods have access to this record
		               SCATTER NAME THIS.oInvTmp
		
		               THIS.cYear   = THIS.oInvTmp.hyear
		               THIS.cPeriod = THIS.oInvTmp.hperiod
		
		               IF THIS.lsplitperiods
		                  lnowncount = lnowncount + 1
		                  m.cWellType = THIS.oInvTmp.cOwnerID+THIS.oInvTmp.cwellid+ ;
		                     THIS.oInvTmp.ctypeinv+THIS.oInvTmp.ctypeint+STR(lnowncount,1)+THIS.oInvTmp.hyear+THIS.oInvTmp.hperiod
		               ELSE
		                  m.cWellType = THIS.oInvTmp.cOwnerID+THIS.oInvTmp.cwellid+ ;
		                     THIS.oInvTmp.ctypeinv+THIS.oInvTmp.ctypeint+STR(lnowncount,1)
		               ENDIF
		
		               *
		               *  Determine if investor is a Royalty owner
		               *
		               IF THIS.oInvTmp.ctypeinv = 'L' OR THIS.oInvTmp.ctypeinv = 'O'
		                  THIS.lRoyaltyOwner = .T.
		               ELSE
		                  THIS.lRoyaltyOwner = .F.
		               ENDIF
		
		               m.cRptGroup = 'A'
		
		               *  Get the current well's info into memory variables
		               SELECT wells
		               SET ORDER TO cwellid
		               SEEK THIS.oWellWork.cwellid
		               IF FOUND()
		                  SCATTER MEMVAR
		                  m.nRoyInt    = nlandpct + noverpct
		                  IF m.ncompress <> 0
		                     THIS.ncompress = wells.ncompress
		                  ELSE
		                     THIS.ncompress = THIS.oOptions.ncompress
		                  ENDIF
		                  IF m.ngather <> 0
		                     THIS.ngather = wells.ngather
		                  ELSE
		                     THIS.ngather = THIS.oOptions.ngather
		                  ENDIF
		                  THIS.lExemptRoyalty = lroysevtx
		               ELSE
		                  * Not a valid well so loop out...Shouldn't ever get here.
		                  LOOP    && Loop back to invtmp scan
		               ENDIF
		
		               m.cDescript = ' '
		               m.cOwnerID = THIS.cOwnerID
		
		               ************************************************************************************
		               **** PROCESSING FOR COMBINING PRODUCTION PERIOD TOGETHER UNDER ONE WELL HEADER *****
		               ************************************************************************************
		               IF NOT THIS.lsplitperiods    && Keeping production periods together
		                  * If we're including wells with no production and the current well has no production
		                  * insert a header record into the statement file.
		                  IF THIS.lNoProd = .T. AND NOT llWellProd
		                     m.nRunNo = THIS.nRunNo
		                     m.cProgCode = THIS.oInvTmp.cProgCode
		                     SELE programs
		                     LOCATE FOR cProgCode = m.cProgCode
		                     IF FOUND()
		                        lcprogname = cProgName
		                     ELSE
		                        lcprogname = ''
		                     ENDIF
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group A
		                     *********************************************************************************************************
		                     m.crunyear = THIS.crunyear
		                     INSERT INTO statemnt FROM MEMVAR
		                     *********************************************************************************************************
		                  ELSE
		                     *  Only insert a header record if the well has production at this point or if there are statement notes.
		                     IF llWellProd
		                        SELE statemnt
		                        LOCATE FOR cWellType = m.cWellType AND cRptGroup = 'A'
		                        IF NOT FOUND()
		                           m.nRunNo = THIS.nRunNo
		                           m.cProgCode = THIS.oInvTmp.cProgCode
		                           SELE programs
		                           LOCATE FOR cProgCode = m.cProgCode
		                           IF FOUND()
		                              lcprogname = cProgName
		                           ELSE
		                              lcprogname = ''
		                           ENDIF
		                           *********************************************************************************************************
		                           *  Insert into the statement file  - Report Group A
		                           *********************************************************************************************************
		                           INSERT INTO statemnt FROM MEMVAR
		                           *********************************************************************************************************
		                        ENDIF
		                     ELSE
		                        * Check to see if there are statement notes, and if so, insert an A record.
		                        SELE stmtnote
		                        LOCATE FOR cwellid == THIS.oInvTmp.cwellid AND nRunNo == THIS.oInvTmp.nRunNo AND crunyear == THIS.oInvTmp.crunyear
		                        IF FOUND()
		                           DO CASE
		                              CASE stmtnote.nnotetype = 1
		                                 IF THIS.oInvTmp.ctypeinv # 'L'
		                                    LOOP
		                                 ENDIF
		                              CASE stmtnote.nnotetype = 2
		                                 IF THIS.oInvTmp.ctypeinv # 'O'
		                                    LOOP
		                                 ENDIF
		                              CASE stmtnote.nnotetype = 3
		                                 IF (THIS.oInvTmp.ctypeinv # 'O' AND THIS.oInvTmp.ctypeinv # 'L')
		                                    LOOP
		                                 ENDIF
		                              CASE stmtnote.nnotetype = 4
		                                 IF THIS.oInvTmp.ctypeinv # 'W'
		                                    LOOP
		                                 ENDIF
		                           ENDCASE
		                           SELE statemnt
		                           LOCATE FOR cWellType = m.cWellType AND cRptGroup = 'A'
		                           IF NOT FOUND()
		                              m.nRunNo = THIS.nRunNo
		                              m.cProgCode = THIS.oInvTmp.cProgCode
		                              SELE programs
		                              LOCATE FOR cProgCode = m.cProgCode
		                              IF FOUND()
		                                 lcprogname = cProgName
		                              ELSE
		                                 lcprogname = ''
		                              ENDIF
		                              *********************************************************************************************************
		                              *  Insert into the statement file  - Report Group A
		                              *********************************************************************************************************
		                              INSERT INTO statemnt FROM MEMVAR
		                              *********************************************************************************************************
		                           ENDIF
		                        ENDIF
		                     ENDIF
		                  ENDIF
		                  llwellstmt   = .T.
		               ELSE
		                  m.nRunNo = THIS.nRunNo
		                  m.cProgCode = THIS.oInvTmp.cProgCode
		                  SELE programs
		                  LOCATE FOR cProgCode = m.cProgCode
		                  IF FOUND()
		                     lcprogname = cProgName
		                  ELSE
		                     lcprogname = ''
		                  ENDIF
		                  *********************************************************************************************************
		                  *  Insert into the statement file  - Report Group A
		                  *********************************************************************************************************
		                  INSERT INTO statemnt FROM MEMVAR
		                  *********************************************************************************************************
		                  llwellstmt = .T.
		               ENDIF
		               ************************************************************************************
		               **** PROCESSING FOR COMBINING PRODUCTION PERIOD TOGETHER UNDER ONE WELL HEADER *****
		               ************************************************************************************
		
		               *  If this is a flat rate royalty owner, insert the flat rate into the income section
		               IF invtmp.lFlat
		                  m.cRptGroup = 'B'
		                  IF invtmp.nFlatRate = 0
		                     *  Flat rate owner but no flat rate amount - loop back to invtmp
		                     LOOP
		                  ENDIF
		
		                  m.ninvamt = invtmp.nFlatRate
		                  THIS.nOwnerTotal = THIS.nOwnerTotal + invtmp.nFlatRate
		                  m.cDescript = ' '
		                  m.cTYPE = 'FLT'
		                  m.cYear = invtmp.hyear
		                  m.cPeriod = invtmp.hperiod
		                  m.cOwnerID = THIS.cOwnerID
		                  m.nRunNo = THIS.nRunNo
		                  m.cProgCode = THIS.oInvTmp.cProgCode
		                  SELE programs
		                  LOCATE FOR cProgCode = m.cProgCode
		                  IF FOUND()
		                     lcprogname = cProgName
		                  ELSE
		                     lcprogname = ''
		                  ENDIF
		                  THIS.nTotInc  = THIS.nTotInc + m.ninvamt
		                  THIS.nWellTot = THIS.nWellTot + m.ninvamt
		                  *********************************************************************************************************
		                  *  Insert into the statement file  - Report Group B
		                  *********************************************************************************************************
		                  INSERT INTO statemnt FROM MEMVAR
		                  *********************************************************************************************************
		                  *
		                  *  Look for statement notes for flat rate owners
		                  *
		                  THIS.stmtnotes(THIS.nRunNo, THIS.crunyear, THIS.oWellWork.cwellid, THIS.oInvTmp.cOwnerID)
		                  LOOP
		               ENDIF
		
		
		               IF THIS.oInvTmp.nincome = 0 AND ;
		                     (THIS.oInvTmp.nExpense+THIS.oInvTmp.ntotale1+THIS.oInvTmp.ntotale2+THIS.oInvTmp.ntotale3+THIS.oInvTmp.ntotale4+THIS.oInvTmp.ntotale5) = 0 ;
		                     AND THIS.oInvTmp.nSevTaxes = 0 AND THIS.oInvTmp.nNetCheck = 0 AND NOT llWellProd
		                  *  Print any statement notes
		                  IF NOT THIS.stmtnotes(THIS.nRunNo, THIS.crunyear, THIS.oWellWork.cwellid, THIS.oInvTmp.cOwnerID)
		                     * If no notes, print message about no production
		                     m.cDescript = 'No Production This Period'
		                     m.cTYPE = 'NOT'
		                     m.cOwnerID = THIS.cOwnerID
		                     SELE statemnt
		                     LOCATE FOR cwellid = THIS.oWellWork.cwellid AND (cRptGroup = 'B' OR cRptGroup = 'D')
		                     IF NOT FOUND()
		                        GO BOTT
		                        IF cRptGroup <> 'F' AND cDescript <> 'No Production This Period'
		                           m.nRunNo = THIS.nRunNo
		                           *********************************************************************************************************
		                           *  Insert into the statement file  - Report Group F
		                           *********************************************************************************************************
		                           INSERT INTO statemnt FROM MEMVAR
		                           *********************************************************************************************************
		                        ENDIF
		                     ENDIF
		                  ENDIF
		                  LOOP
		               ELSE
		                  THIS.stmtnotes(THIS.nRunNo, THIS.crunyear, THIS.oWellWork.cwellid, THIS.oInvTmp.cOwnerID)
		                  m.cDescript = ' '
		                  m.cOwnerID = THIS.cOwnerID
		               ENDIF
		
		               *  Initialize work properties that need to be passed between methods
		               STORE ' ' TO m.oprng1, m.oprng2, m.gprng1, m.gprng2
		               STORE 0 TO THIS.nOilTax1, THIS.nOilTax2, THIS.nOilTax3, THIS.nOilTax4
		               STORE 0 TO THIS.nGasTax1, THIS.nGasTax2, THIS.nGasTax3, THIS.nGasTax4
		               STORE 0 TO THIS.nOthTax1, THIS.nOthTax2, THIS.nOthTax3, THIS.nOthTax4
		               STORE 0 TO jflatcnt
		               STORE 'N' TO m.cDirect
		
		               *************************************************************
		               *  Process Income
		               *************************************************************
		               THIS.calcincome(THIS.oWellWork.cwellid, THIS.nRunNo, THIS.oWellWork.hyear, THIS.oWellWork.hperiod, THIS.dAcctDate)
		
		               STORE 0 TO m.ninvamt, m.nTOTAL, m.nprice, m.nUnits, m.nRevInt
		               STORE ' ' TO m.cTYPE, m.cSource, m.crange
		
		               *************************************************************
		               *  Process Flat-Rates to deduct them from working interests
		               *************************************************************
		               THIS.flatowner()
		
		               STORE 0 TO jnflatoil, jnflatgas
		               STORE ' ' TO m.cTYPE
		               *************************************************************
		               *  Process taxes
		               *************************************************************
		               THIS.calctaxes()
		
		               STORE 0 TO m.nTOTAL, m.ninvamt, m.nRevInt
		               STORE ' ' TO m.cSource, m.cTYPE, m.cMethod
		               *   ENDIF
		               *************************************************************
		               *  Process Gathering and Compression Charges
		               *************************************************************
		               THIS.CalcCompress()
		               STORE 0 TO m.nTOTAL, m.ninvamt, m.nRevInt
		               STORE ' ' TO m.cSource, m.cTYPE, m.cDescript
		
		               *************************************************************
		               *  Process Royalty Interest Amounts
		               *************************************************************
		               IF NOT THIS.lRoyaltyOwner AND THIS.oOptions.lshowroy
		                  m.cRptGroup = 'C'
		                  m.cTYPE     = 'ROY'
		                  m.cSource   = 'Royalty Interest Totals'
		                  m.ninvamt   = m.nroyalty
		                  m.cPeriod   = ''
		                  m.cYear     = THIS.oWellWork.hyear
		                  m.cDescript = 'Royalty Interest Totals'
		                  m.cOwnerID = THIS.cOwnerID
		                  m.nRunNo = THIS.nRunNo
		                  IF m.ninvamt > 0
		                     *********************************************************************************************************
		                     *  Insert into the statement file  - Report Group C
		                     *********************************************************************************************************
		                     INSERT INTO statemnt FROM MEMVAR
		                  ENDIF
		                  STORE 0 TO m.ninvamt
		                  STORE ' ' TO m.cTYPE, m.cSource, m.cDescript, m.cMiscMemo
		               ENDIF
		
		               *************************************************************
		               *  Process expenses
		               *************************************************************
		               THIS.CalcExpense()
		
		               THIS.lcOldOwnerID = THIS.cOwnerID
		
		               *************************************************************
		               *  Process well net total when splitting prod prds
		               *************************************************************
		               THIS.NetWellTotalSplit()
		
		               **************************************************************
		               *  Bring in well deficits from other periods
		               **************************************************************
		               THIS.Deficits_Well()
		
		               *************************************************************
		               *  Process Well Statement notes
		               *************************************************************
		               THIS.stmtnotes(THIS.nRunNo, THIS.crunyear, THIS.oWellWork.cwellid, THIS.oInvTmp.cOwnerID)
		
		               STORE 0 TO m.nWellNet, m.nTotNet
		               SELECT invtmp
		               THIS.nBackupWith = THIS.nBackupWith + THIS.oInvTmp.nbackwith
		               THIS.nTaxWith    = THIS.nTaxWith  + THIS.oInvTmp.nTaxWith
		               THIS.OwnerGroup = THIS.cOwnerID+THIS.oWellWork.cwellid+THIS.oInvTmp.ctypeinv
		               THIS.cProgCode  = invtmp.cProgCode
		            ENDSCAN  && invtmp
		         ENDSCAN  && wellwork
		      ENDSCAN  && Owntypes
		
		      *
		      *  Process the well net totals for the last well for the owner
		      *
		
		      THIS.NetWellTotalNoSplit()
		
		      *************************************************************
		      *  Process net interest this period.
		      *************************************************************
		      SELECT invtotal
		      m.cRptGroup    = 'K'
		      m.cTYPE        = 'TOT'
		      m.cPeriod      = ''
		      m.cYear        = THIS.cRunYear
		      m.cProgCode    = 'YZZZ'
		      m.cWellType    = '}ZZZZZZZ'
		      m.cwellid      = ''
		      IF THIS.lNetWells
		         m.nTotNet      = m.npretotal
		      ELSE
		         m.nTotNet      = m.nTotalBal
		      ENDIF
		      THIS.nBalance  = m.nTotalBal
		      lldef = .F.
		      DO CASE
		         CASE m.nTotNet > 0 AND m.nTotalBal < m.ninvmin
		            IF THIS.lOwnerOnHold
		               m.cDescript = 'Your Net Interest This Run (Held In Suspense)'
		            ELSE
		               IF m.nTotalBal > 0
		                  m.cDescript = 'Your Net Interest This Run (Below Minimum Check - Placed In Suspense)'
		               ELSE
		                  m.cDescript = 'Your Net Interest This Run (Before Suspense Processing)'
		               ENDIF
		            ENDIF
		            THIS.lBelowMinimum = .T.
		         CASE m.nTotNet >= 0
		            m.cDescript = 'Your Net Interest This Run'
		            THIS.lBelowMinimum = .F.
		         CASE m.npretotal < 0
		            m.cDescript = 'Your Net Deficit This Run (Placed In Suspense)'
		            THIS.lBelowMinimum = .F.
		      ENDCASE
		      m.cOwnerID = THIS.cOwnerID
		      m.nRunNo = THIS.nRunNo
		      *********************************************************************************************************
		      *  Insert into the statement file  - Report Group K      (Net Interest This Period)
		      *********************************************************************************************************
		      INSERT INTO statemnt FROM MEMVAR
		
		      m.cDescript = ' '
		      STORE 0 TO THIS.nWellTot, m.nWellNet, m.nTotNet
		      STORE 0 TO THIS.nWellTot, m.nWellNet, m.nTotNet
		
		
		      *************************************************************
		      *  Process Previous Period Deficits when netting wells together
		      *************************************************************
		      THIS.deficits_own()
		
		      **************************************************************
		      *  Bring in well minimums from other periods
		      **************************************************************
		      THIS.PrevMins()
		
		      *************************************************************
		      *  Process Backup and Tax Withholding
		      *************************************************************
		      THIS.BackTaxWith()
		
		      *************************************************************
		      *  Process released interest on holds
		      *************************************************************
		      THIS.intonhold()
		
		      *************************************************************
		      *  Process net balance amount for this run.
		      *************************************************************
		      THIS.netbalance()
		
		      *************************************************************
		      *  Process suspense balance
		      *************************************************************
		      IF THIS.lNetWells    && We'll only report suspense balance if netting
		         IF USED('suspbal')
		            SELECT suspbal
		            SET ORDER TO cOwnerID
		            SEEK THIS.cOwnerID
		            IF FOUND() OR THIS.nBackupWith <> 0
		               lctypeinv = ctypeinv
		               IF lctypeinv <> 'V'
		                  m.nTotNet   = nAmount
		               ENDIF
		               
		               lnTotNetOld = m.ntotnet
		               
		               m.cRptGroup = 'N'
		               m.cTYPE     = 'BAL'
		               m.cPeriod   = ''
		               m.cYear     = THIS.cRunYear
		               m.cProgCode = 'ZZZZ'
		               m.cWellType = '}ZZZZZZZZZZ'
		               m.cDescript = 'Suspense Balance (Before This Run)'
		               IF m.nTotNet <> 0
		                  m.cOwnerID = THIS.cOwnerID
		                  m.nRunNo = THIS.nRunNo
		                  *********************************************************************************************************
		                  *  Insert into the statement file  - Report Group N     (Suspense Balance Before This Run)
		                  *********************************************************************************************************
		                  INSERT INTO statemnt FROM MEMVAR
		               ENDIF
		               * Process interests on hold being released
		               SELE invtmp
		               SCAN FOR cOwnerID = THIS.cOwnerID AND ctypeinv = 'I'
		                  m.nTotNet = m.nTotNet - nNetCheck
		               ENDSCAN
		
		               lldef = .F.
		               * Process deficits covered this run
		               SELE invtmp
		               SCAN FOR cOwnerID = THIS.cOwnerID AND ctypeinv = 'X'
		                  m.nTotNet = m.nTotNet - nNetCheck
		                  lldef = .T.
		               ENDSCAN
		
		               * Process minimums released this run
		               SELE invtmp
		               SCAN FOR cOwnerID = THIS.cOwnerID AND ctypeinv = 'M'
		                  m.nTotNet = m.nTotNet - nNetCheck
		               ENDSCAN
		
		               * Process deficits and minimums not covered this run
		               SELE invsusp
		               SCAN FOR cOwnerID = THIS.cOwnerID
		                  m.nTotNet = m.nTotNet + nNetCheck
		               ENDSCAN
		
		               * Process this whole run if owner is on hold
		               * Commented out 12/17/04 because it was doubling
		               * suspense after this run.  pws
		               *!*	            IF THIS.lOwnerOnHold
		               *!*	               m.ntotnet = m.ntotnet + m.nTotalBal
		               *!*	            ENDIF
		
		
		                  * Is amount below owner minimum?
		                  IF THIS.lBelowMinimum = .T. AND NOT lldef
		                     m.ntotnet = m.ntotnet + THIS.nBalance
		                  ENDIF
		
		                  * Changed the AND below "m.nTotalBal) AND (m.nTotNet < 0" from an OR - pws 1/25/2007
		                  IF (m.ntotnet - lnTotNetOld = m.nTotalBal) AND (m.ntotnet < 0 AND lnTotNetOld < 0 AND m.ntotalcheck < 0)  &&  Added the part about nTotalCheck being negative, so if they're getting a check, that shows at the top, instead of a suspense balance - BH 01/05/07
		                     * This represents a situation where their total deficit balance is getting added to an existing
		                     * deficit balance, so it should be reporting the total suspense at the top of the statement. - BH 12/20/06
		                     * Or, both the previous suspense balance, and current are deficit, so put the new deficit total at the top as the deficit amount.
		                     SELECT statemnt
		                     SCAN FOR cOwnerID == THIS.cOwnerID
		                        REPLACE nTotalBal WITH m.ntotnet
		                     ENDSCAN
		                  ENDIF
		
		                  IF (m.nPretotal < 0 AND glStmInv AND m.nTotNet > 0) OR  m.ntotnet < 0 AND glStminv
		                     SELE statemnt
		                     * If this owner is in programs, don't mess with the total.
		                     LOCATE FOR cOwnerID == THIS.cOwnerID AND NOT EMPTY(cProgCode) AND NOT 'ZZZ' $ cProgCode
		                     IF NOT FOUND()
		                        SCAN FOR cOwnerID == THIS.cOwnerID
		                           REPL nTotalBal WITH m.ntotnet
		                        ENDSCAN
		                     ENDIF
		                  ENDIF
		
		               m.cRptGroup = 'N'
		               m.cTYPE     = 'BAL'
		               m.cPeriod   = ''
		               m.cYear     = THIS.cRunYear
		               m.cProgCode = 'ZZZZ'
		               m.cWellType = '}ZZZZZZZZZZ'
		               m.cDescript = 'Suspense Balance (After This Run)'
		               IF lctypeinv <> 'V'
		                  m.cOwnerID = THIS.cOwnerID
		                  m.nRunNo = THIS.nRunNo
		                  *********************************************************************************************************
		                  *  Insert into the statement file  - Report Group N     (Suspense Balance After This Run)
		                  *********************************************************************************************************
		                  INSERT INTO statemnt FROM MEMVAR
		               ENDIF
		               m.cDescript = ' '
		            ENDIF   && IF FOUND() suspbal
		         ENDIF
		      ENDIF
		
		      WAIT CLEAR
		
		      THIS.lBelowMinimum = .F.
		   ENDSCAN  && invtotal
		
		   *
		   *  Print Program totals and deficits covered
		   *
		
		   SELE progtots
		   SCAN
		      SCATTER MEMVAR
		      *
		      * Print the program total
		      *
		      m.cRptGroup = 'E'
		      m.nWellNet  = nprogtot
		      m.cTYPE     = 'PRG'
		      m.cProgCode = m.cProgCode
		      SELECT programs
		      LOCATE FOR cProgCode = m.cProgCode
		      IF FOUND()
		         m.cProgName = cProgName
		      ELSE
		         m.cProgName = ''
		      ENDIF
		      m.cWellType = '{YZZZZZZ'
		      STORE '' TO m.cDescript
		      SELE statemnt
		      LOCATE FOR cOwnerID = progtots.cOwnerID AND cRptGroup='A'
		      IF FOUND()
		         m.nTotalBal = nTotalBal
		         m.caddress1 = statemnt.caddress1
		         m.caddress2 = statemnt.caddress2
		         m.ccityState = statemnt.ccityState
		      ELSE
		         m.nTotalBal = 0
		      ENDIF
		      IF m.nWellNet <> 0
		         m.nRunNo = THIS.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group E     (Program Totals)
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		      ENDIF
		      m.nWellNet = 0
		      lnprogamt = 0
		      *
		      *  Look for any program deficits that are being covered.
		      *
		      USE DBF('invtmp') AGAIN IN 0 ALIAS tmpsusp
		      SELECT tmpsusp
		      SET ORDER TO 0
		      SCAN FOR cOwnerID = progtots.cOwnerID  ;
		            AND nNetCheck <> 0          ;
		            AND ctypeinv = 'X'         ;
		            AND cProgCode = m.cProgCode
		         lnprogamt  = lnprogamt + nNetCheck
		      ENDSCAN     && tmpsusp
		      IF lnprogamt <> 0
		         m.cRptGroup = 'E'
		         m.cTYPE     = 'PRS'
		         m.nWellNet  = lnprogamt
		         m.cPeriod   = ''
		         m.cYear     = THIS.cRunYear
		         m.cWellType = '}ZZZZZZZ'
		         SELE programs
		         LOCATE FOR cProgCode = m.cProgCode
		         IF FOUND()
		            lcprogname = cProgName
		         ELSE
		            lcprogname = ''
		         ENDIF
		         m.cProgName = lcprogname
		         m.cDescript = 'Balance Brought Forward From Previous Periods For Program: ' + lcprogname
		         m.cOwnerID = THIS.cOwnerID
		         m.nRunNo = THIS.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group E     (Program Deficits)
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.nWellNet = 0
		         m.cDescript = ' '
		      ENDIF
		      SELECT tmpsusp
		      USE
		      m.nWellNet = 0
		      lnProgTot = 0
		   ENDSCAN
		
		   * Get list of owners and wells from statemnt
		   * Remove any well records there's no "A" records for.
		   SELE cOwnerID, cwellid FROM statemnt INTO CURSOR temp ORDER BY cOwnerID, cwellid GROUP BY cOwnerID, cwellid
		   SELE temp
		   SCAN FOR NOT EMPTY(cwellid)
		      SCATTER MEMVAR
		      SELE statemnt
		      LOCATE FOR cOwnerID == m.cOwnerID AND cwellid == m.cwellid AND cRptGroup = 'A'
		      IF NOT FOUND()
		         DELE FOR cOwnerID == m.cOwnerID AND cwellid == m.cwellid AND cWellType <> '{YZZZZZZ' AND UPPER(cTYPE) <> 'MIN' AND UPPER(cTYPE) <> 'PPD'  &&  Don't delete {YZZZZZZ record, since that's the prog total - BH 06/15/06  &&  Also don't delete MIN records, b/c they represent an amount being released - BH 10/24/07  &&  And not PPD recs, since they contain tax withholding info - BH 05/22/08
		      ENDIF
		   ENDSCAN
		
		   * Get list of owners in statemnt file.
		   SELE cOwnerID FROM statemnt INTO CURSOR temp ORDER BY cOwnerID GROUP BY cOwnerID
		   SELE temp
		   SCAN
		      m.cOwnerID = cOwnerID
		      SELE investor
		      SET ORDER TO cOwnerID
		      IF SEEK(m.cOwnerID)
		         *
		         *  Check to see if this investors deficit cStatement should be printed
		         *
		         SCATTER MEMVAR
		         **-
		         **-  If the statment should be sent to the secondary address
		         **-  pull in the secondary address, otherwise pull in the
		         **-  primary address.
		         **-
		         IF m.lchktosec AND NOT m.lcheckonly
		            m.cOwnname = m.cownname2
		            m.caddress1 = m.caddress2a
		            IF NOT EMPTY(m.caddress2b)
		               m.caddress2  = m.caddress2b
		               m.ccityState = ALLTRIM(m.ccity2)+' '+m.cstate2+'  '+m.czip2
		            ELSE
		               m.caddress2  = ALLTRIM(m.ccity2)+' '+m.cstate2+'  '+m.czip2
		               m.ccityState = ' '
		            ENDIF
		         ELSE
		            IF NOT EMPTY(m.caddress1a)
		               m.caddress1 = m.caddress1a
		               IF NOT EMPTY(m.caddress1b)
		                  m.caddress2 = m.caddress1b
		                  m.ccityState = ALLTRIM(m.ccity1)+' '+m.cstate1+'  '+m.czip1
		               ELSE
		                  m.caddress2 = ALLTRIM(m.ccity1)+' '+m.cstate1+'  '+m.czip1
		                  m.ccityState = ''
		               ENDIF
		            ELSE
		               IF NOT EMPTY(m.caddress1b)
		                  m.caddress1  = m.caddress1b
		                  m.caddress2  = ALLTRIM(m.ccity1)+' '+m.cstate1+'  '+m.czip1
		                  m.ccityState = ''
		               ELSE  &&  Blank out address for people with no address, so it doesn't just carry forward the same address from the last owner who had an address filled in
		                  m.caddress1 = ''
		                  m.caddress2 = ''
		                  m.ccityState = ''
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		      SELE statemnt
		      SCAN FOR cOwnerID == m.cOwnerID
		         REPL cOwnname WITH m.cOwnname, ;
		            cOwnname1 WITH m.cOwnname1, ;
		            caddress1 WITH m.caddress1, ;
		            caddress2 WITH m.caddress2, ;
		            ccityState WITH m.ccityState
		      ENDSCAN
		   ENDSCAN
		
		
		   SELE statemnt
		   GO TOP
		   m.dAcctDate = dAcctDate
		   REPL dAcctDate WITH m.dAcctDate ALL
		   oprogress.closeprogress()
		
		   SELE statemnt
		   SET ORDER TO invprog
		   WAIT CLEAR
		
		   THIS.oDist = .NULL.
		   *
		   *  Send data through report
		   *
		   SELECT statemnt
		   SET ORDER TO invprog
		   COUNT FOR NOT DELETED() TO lnCount
		   GO TOP
		   IF lnCount = 0
		      RETURN .F.
		   ELSE
		      RETURN .T.
		   ENDIF
		ELSE
		   THIS.oDist = .NULL.
		   RETURN .F.
		ENDIF
		
		
		
		
		
	ENDPROC

	PROCEDURE netbalance
		
		SELECT invtotal
		m.crptgroup = 'M'
		m.ctype     = 'TOT'
		m.cperiod   = ''
		m.cyear     = THIS.cRunYear
		m.cprogcode = 'ZZZZ'
		m.cwelltype = '}ZZZZZZZ'
		m.cwellid   = ''
		IF THIS.lBelowMinimum = .T.
		   m.ntotnet   = THIS.nBalance
		ELSE
		   m.ntotnet   = m.ntotalbal
		ENDIF
		
		DO CASE
		   CASE m.ntotnet > 0 AND m.ntotnet < m.ninvmin
		      if this.lOwnerOnHold
		         m.cdescript = 'Your Net Balance After This Run (Held - Placed In Suspense)'
		      else   
		         m.cdescript = 'Your Net Balance After This Run (Below Minimum Amount - Placed In Suspense)'
		      endif   
		   CASE m.ntotnet >= 0
		      m.cdescript = 'Your Net Balance After This Run'
		   CASE m.ntotnet < 0 AND ;
		         NOT (THIS.oOptions.lstminv OR (NOT THIS.oOptions.ldirinv AND INLIST(invtmp.cdirect,'G','O','B')))
		      m.ntotnet = THIS.nOwnerTotal
		      m.cdescript = 'Your Net Balance After This Run (Placed In Suspense)'
		   CASE m.ntotnet < 0 AND ;
		         (THIS.oOptions.lstminv OR (THIS.oOptions.ldirinv AND INLIST(invtmp.cdirect,'G','O','B')))   
		      m.cdescript = 'Your Net Balance After This Run (Please Pay)'   
		   CASE m.ntotnet  < 0 AND ;
		         M.ntotalcheck < 0 AND ;
		         (glstminv OR (gldirinv AND INLIST(invtmp.cdirect,'G','O','B')))
		      m.ntotnet = ABS(m.nTotalBal)
		      m.cdescript = 'Your Net Balance After This Run (Please Pay)'
		ENDCASE
		
		*IF THIS.nBalance <> m.ntotnet
		   m.cownerid = THIS.cownerid
		   m.nRunNo = this.nRunNo
		   *********************************************************************************************************
		   *  Insert into the statement file  - Report Group M     (Net Balance)
		   *********************************************************************************************************
		   INSERT INTO statemnt FROM MEMVAR
		*ENDIF
		
	ENDPROC

	PROCEDURE netwelltotalnosplit
		************************************************************************************
		**** PROCESSING FOR COMBINING PRODUCTION PERIOD TOGETHER UNDER ONE WELL HEADER *****
		************************************************************************************
		
		IF NOT THIS.lsplitperiods
		   IF THIS.OwnerGroup <> invtmp.cownerid+invtmp.cwellid+invtmp.ctypeinv AND THIS.OwnerGroup <> ' ' OR invtmp.lFlat
		      *!*	      IF THIS.oInvTmp.nincome = 0 AND ;
		      *!*	            (THIS.oInvTmp.nexpense+THIS.oInvTmp.ntotale1+THIS.oInvTmp.ntotale2+THIS.oInvTmp.ntotale3+THIS.oInvTmp.ntotale4+THIS.oInvTmp.ntotale5) = 0 ;
		      *!*	            AND THIS.oInvTmp.nsevtaxes = 0 AND THIS.oInvTmp.nnetcheck = 0
		      *!*	         * Nothing
		      *!*	      ELSE
		      IF THIS.nwelltot = 0
		         RETURN
		      ELSE
		
		         m.crptgroup = 'E'
		         m.nwellnet  = THIS.nwelltot
		         lnwelldef   = m.nwellnet
		         m.ctype     = 'NET'
		         llnewowner  = .F.
		         m.cwellid = THIS.oInvTmp.cwellid
		         m.cProgCode = THIS.oInvTmp.cProgCode
		
		         SELE programs
		         LOCATE FOR cProgCode = m.cProgCode
		         IF FOUND()
		            m.cprogname = cprogname
		         ELSE
		            m.cprogname = ''
		         ENDIF
		
		         DO CASE
		            CASE THIS.oInvTmp.ctypeinv <> 'W' AND m.nwellnet >= 0    && Royalty Owner
		               IF NOT THIS.oInvTmp.lOnHold
		                  m.cdescript = 'Your Royalty Interest This Well'
		               ELSE
		                  m.cdescript = 'Your Royalty Interest This Well  (**ON HOLD**)'
		               ENDIF
		            CASE THIS.oInvTmp.ctypeinv <> 'W' AND m.nwellnet < 0 AND THIS.oInvTmp.lused  && Royalty Owner
		               IF NOT THIS.oInvTmp.lOnHold
		                  m.cdescript = 'Your Royalty Interest This Well '
		               ELSE
		                  m.cdescript = 'Your Royalty Interest This Well  (**ON HOLD**)'
		               ENDIF
		            CASE THIS.oInvTmp.ctypeinv <> 'W' AND m.nwellnet < 0 AND NOT THIS.oInvTmp.lused  && Royalty Owner in Deficit
		               IF NOT THIS.oInvTmp.lOnHold
		                  m.cdescript = 'Your Royalty Interest This Well (Deficit Carried Forward)'
		               ELSE
		                  m.cdescript = 'Your Royalty Interest This Well  (**ON HOLD**)'
		               ENDIF
		            CASE THIS.oInvTmp.ctypeinv = 'W' AND ;     && Working interest owner
		               ((m.nwellnet > 0 OR (m.nwellnet < 0 AND THIS.oInvTmp.lused) OR ;
		                  (m.nwellnet < 0 AND NOT THIS.oInvTmp.lused AND THIS.oOptions.lstminv AND THIS.lNetWells)))
		               IF NOT THIS.oInvTmp.lOnHold
		                  IF m.nwellnet < 0 AND NOT THIS.oInvTmp.lused
		                     m.cdescript = 'Your Working Interest This Well (Deficit Carried Forward)'
		                  ELSE
		                     m.cdescript = 'Your Working Interest This Well'
		                  ENDIF
		               ELSE
		                  m.cdescript = 'Your Working Interest This Well (**ON HOLD**)'
		               ENDIF
		               IF m.nwellnet < 0 AND NOT THIS.oInvTmp.lused AND THIS.oOptions.lstminv AND THIS.lNetWells
		               ENDIF
		            CASE THIS.oInvTmp.ctypeinv = 'W' AND ;        && Working Interest Owner in Deficit
		               (m.nwellnet < 0 AND NOT THIS.oInvTmp.lused AND (NOT THIS.oOptions.lstminv OR NOT THIS.lNetWells))
		               IF NOT THIS.oInvTmp.lOnHold
		                  m.cdescript = 'Your Working Interest This Well (Deficit Carried Forward)'
		               ELSE
		                  m.cdescript = 'Your Working Interest This Well (**ON HOLD**)'
		               ENDIF
		            OTHERWISE
		               m.cdescript = ' '
		         ENDCASE
		         STORE 0 TO m.ninvamt, m.namount, m.ntotal, lnwelldef
		         m.cownerid = THIS.cownerid
		         m.nRunNo = THIS.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group E
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         *********************************************************************************************************
		
		         *  At this point, m.cProgCode still has the last program code stored
		         *  Add to that programs totals
		         IF NOT EMPTY(ALLT(THIS.cProgCode))
		            SELE progtots
		            LOCATE FOR cownerid+cProgCode = THIS.cownerid+THIS.oInvTmp.cProgCode
		            IF FOUND()
		               IF THIS.lNetWells
		                  REPL nprogtot WITH nprogtot + m.nwellnet
		               ELSE
		                  IF m.nwellnet > 0
		                     REPL nprogtot WITH nprogtot + m.nwellnet
		                  ENDIF
		               ENDIF
		            ELSE
		               m.nprogtot  = m.nwellnet
		               m.cProgCode = THIS.oInvTmp.cProgCode
		               m.cownerid  = THIS.oInvTmp.cownerid
		               IF THIS.lNetWells
		                  INSERT INTO progtots FROM MEMVAR
		               ELSE
		                  IF m.nwellnet > 0
		                     INSERT INTO progtots FROM MEMVAR
		                  ENDIF
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		      m.cdescript = ' '
		      IF m.nwellnet > 0 OR (m.nwellnet < 0 AND THIS.oInvTmp.lused) OR (m.ntotalcheck < 0)
		         THIS.nOwnerTotal = THIS.nOwnerTotal + ROUND(m.nwellnet,2)
		      ENDIF
		      STORE 0 TO THIS.nwelltot, THIS.nTotInc, m.nwellnet, m.ntotal
		   ENDIF
		
		   **************************************************************
		   *  Report Rounding for this owner
		   **************************************************************
		   THIS.Rounding()
		ENDIF
		
		m.cWellType = invtmp.cownerid+invtmp.cwellid+invtmp.ctypeinv+invtmp.ctypeint  &&  Reset values back to new values from invtmp
		m.cwellid   = invtmp.cwellid
		m.cProgCode = invtmp.cProgCode
		SELE programs
		LOCATE FOR cProgCode = m.cProgCode
		IF FOUND()
		   m.cprogname = cprogname
		ELSE
		   m.cprogname = ''
		ENDIF
		
		************************************************************************************
		**** PROCESSING FOR COMBINING PRODUCTION PERIOD TOGETHER UNDER ONE WELL HEADER *****
		************************************************************************************
		
	ENDPROC

	PROCEDURE netwelltotalsplit
		LOCAL llNetSusp
		
		sele groups
		locate for cgroup = this.cgroup
		if found()
		   llNetSusp = lNetDef
		ELSE
		   llNetSusp = .t.
		ENDIF      
		
		*
		* Determines which message to print for the net total
		*
		
		IF THIS.lsplitperiods
		   m.nworkint = THIS.oInvTmp.nWorkint
		   m.crptgroup = 'E'
		   m.nWellNet = THIS.nWellTot
		   m.ctype     = 'NET'
		   SELE programs
		   LOCATE FOR cProgCode = m.cProgCode
		   IF FOUND()
		      lcprogname = cProgName
		   ELSE
		      lcprogname = ''
		   ENDIF
		   
		   DO CASE
		      * Royalty owner, postive net
		      CASE THIS.oInvTmp.ctypeinv <> 'W' AND m.nwellnet >= 0
		         IF NOT THIS.oInvTmp.lonhold
		            m.cdescript = 'Your Royalty Interest This Well'
		         ELSE
		            m.cdescript = 'Your Royalty Interest This Well  (**ON HOLD**)'
		         ENDIF
		      * Royalty owner, negative net covered by other wells this period
		      CASE THIS.oInvTmp.ctypeinv <> 'W' AND m.nwellnet < 0 AND THIS.oInvTmp.lUsed
		         IF NOT THIS.oInvTmp.lonhold
		            m.cdescript = 'Your Royalty Interest This Well '
		         ELSE
		            m.cdescript = 'Your Royalty Interest This Well  (**ON HOLD**)'
		         ENDIF
		      * Royalty owner, deficit   
		      CASE THIS.oInvTmp.ctypeinv <> 'W' AND m.nwellnet < 0 AND NOT THIS.oInvTmp.lUsed
		         IF NOT THIS.oInvTmp.lonhold
		            m.cdescript = 'Your Royalty Interest This Well (Deficit Carried Forward)'
		         ELSE
		            m.cdescript = 'Your Royalty Interest This Well  (**ON HOLD**)'
		         ENDIF
		      * Working interest owner, positive net or deficit covered by other wells this period   
		      CASE THIS.oInvTmp.ctypeinv = 'W' AND ;
		            ((m.nwellnet > 0 OR (m.nwellnet < 0 AND THIS.oInvTmp.lUsed) OR ;
		            (m.nwellnet < 0 AND NOT THIS.oInvTmp.lUsed AND THIS.oOptions.lStmInv AND llNetSusp)))
		         IF NOT THIS.oInvTmp.lonhold
		            m.cdescript = 'Your Working Interest This Well'
		         ELSE
		            m.cdescript = 'Your Working Interest This Well (**ON HOLD**)'
		         ENDIF
		      * Working interest owner, deficit
		      CASE THIS.oInvTmp.ctypeinv = 'W' AND ;
		            (m.nwellnet < 0 AND NOT THIS.oInvTmp.lUsed AND (NOT THIS.oOptions.lstminv OR NOT THIS.lNetWells))
		         IF NOT THIS.oInvTmp.lonhold
		            m.cdescript = 'Your Working Interest This Well (Deficit Carried Forward)'
		         ELSE
		            m.cdescript = 'Your Working Interest This Well (**ON HOLD**)'
		         ENDIF
		      * Should never get here   
		      OTHERWISE
		         m.cdescript = ' '
		   ENDCASE
		   STORE 0 TO m.ninvamt, m.namount, m.ntotal, lnwelldef
		   m.cownerid = THIS.oInvTmp.cownerid
		   m.nRunNo   = this.nRunNo
		   
		   *********************************************************************************************************
		   *  Insert into the statement file  - Report Group E
		   *********************************************************************************************************
		   INSERT INTO statemnt FROM MEMVAR
		
		   IF NOT EMPTY(ALLT(THIS.oInvTmp.cprogcode))
		      SELE progtots
		         LOCATE FOR cownerid+cprogcode = THIS.oInvTmp.cownerid+THIS.oInvTmp.cprogcode
		         IF FOUND()  
		            if this.lNetWells
		               REPL nprogtot WITH nprogtot + m.nwellnet
		            else
		               if m.nwellnet > 0
		                  REPL nprogtot WITH nprogtot + m.nwellnet
		               endif
		            endif      
		         ELSE
		            m.nprogtot = m.nwellnet
		            if this.lNetWells
		               INSERT INTO progtots FROM MEMVAR
		            else
		               if m.nwellnet > 0
		                  INSERT INTO progtots FROM MEMVAR
		               endif   
		            endif   
		      endif   
		   ENDIF
		   m.cdescript = ' '
		   IF m.nwellnet > 0 OR (m.nwellnet < 0 AND THIS.oInvTmp.lUsed) OR (m.ntotalcheck < 0)
		      THIS.nOwnerTotal = THIS.nOwnerTotal + ROUND(m.nwellnet,2)
		   ENDIF
		   STORE 0 TO THIS.nWellTot, THIS.nTotInc
		
		   **************************************************************
		   *  Report Rounding for this owner
		   **************************************************************
		   THIS.Rounding()
		 
		ENDIF
		
	ENDPROC

	PROCEDURE prevmins
		   *************************************************************
		   *  Process previous minimums
		   *************************************************************
		   llfoundmin = .F.
		   lnminamt = 0
		   SELECT invtmp
		   SCAN FOR cownerid = this.cownerid   ;
		         AND ctypeinv = 'M' ;
		         AND nnetcheck <> 0
		      m.crptgroup = 'K'
		      m.ctype     = 'MIN'
		      m.ntotnet  = nnetcheck
		      m.cperiod   = ''
		      m.cyear     = this.cRunyear
		      m.cprogcode = 'YZZZ'
		      m.cwelltype = '}ZZZZZZZ'
		      m.cwellid   = invtmp.cwellid
		      m.cdescript = 'Balance Released This Period For Well: ' + m.cwellid
		      m.cownerid = this.cownerid
		      INSERT INTO statemnt FROM MEMVAR
		      m.cdescript = ' '
		   ENDSCAN   && invtmp
		
	ENDPROC

	PROCEDURE pulltype
		LOCAL lnRecNo, lcOrder
		
		tcowner1    = THIS.cowner1
		tcowner2    = THIS.cowner2
		tcownertype = THIS.cownertype
		
		* Get list of owners, wells and types from doi
		SELE cownerid, cwellid, ctypeinv ;
		   FROM wellinv ;
		   WHERE BETWEEN(cownerid,tcowner1,tcowner2) ;
		   AND cwellid IN(SELECT cwellid FROM wells WHERE cGroup = THIS.cGroup)  ;
		   INTO CURSOR owntypes ;
		   ORDER BY cownerid, cwellid
		
		DO CASE
		   CASE 'Royalty' $ tcownertype
		*  Scan for non royalty owner records to see if they should stay or go
		*  They stay if the owner has other royalty interests being reported
		      SELE invtmp
		      SET DELETED OFF
		      lcOrder = ORDER()
		      SCAN FOR NOT INLIST(ctypeinv,'L','O')
		         m.cownerid = cownerid
		         m.cwellid  = cwellid
		         m.ctypeinv = ctypeinv
		         SELE owntypes
		         LOCATE FOR cownerid=m.cownerid AND cwellid=m.cwellid
		         IF FOUND()
		            IF NOT INLIST(ctypeinv,'L','O')
		               LOCATE FOR cownerid=m.cownerid AND INLIST(ctypeinv,'L','O')
		               IF NOT FOUND()
		                  SELE invtmp
		                  lnRecNo = RECNO()
		                  DELE FOR cownerid == m.cownerid  &&  Changed to get rid of all INVTMP records for the owner - BH 05/20/08
		                  GOTO lnRecNo                     &&  Would a scan work better?  Absolutely.  Why isn't it in there?
		                  SET ORDER TO                     &&  The scan/delete next 1 didn't work.  No idea why.  Mystery of life, I guess.
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDSCAN
		      SET DELETED ON
		      SET ORDER TO &lcOrder
		   CASE 'Working' $ tcownertype
		* Scan for non working interests to see if they should stay or go
		* They stay if the owner has other working interests that are being reported
		      SELE invtmp
		      SET DELETED OFF
		      lcOrder = ORDER()
		      SCAN FOR ctypeinv # 'W'
		         m.cownerid = cownerid
		         m.cwellid  = cwellid
		         m.ctypeinv = ctypeinv
		         SELE owntypes
		         LOCATE FOR cownerid=m.cownerid AND cwellid=m.cwellid
		         IF FOUND()
		            IF ctypeinv # 'W'
		               LOCATE FOR cownerid=m.cownerid AND ctypeinv = 'W'
		               IF NOT FOUND()
		                  SELE invtmp
		                  lnRecNo = RECNO()
		                  DELE FOR cownerid == m.cownerid  &&  Changed to get rid of all INVTMP records for the owner - BH 05/20/08
		                  GOTO lnRecNo                     &&  Would a scan work better?  Absolutely.  Why isn't it in there?
		                  SET ORDER TO                     &&  The scan/delete next 1 didn't work.  No idea why.  Mystery of life, I guess.
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDSCAN
		      SET DELETED ON
		      SET ORDER TO &lcOrder
		ENDCASE
		
		*  Remove owner total records if there are no detail records
		*  to report on.
		SELE invtotal
		SCAN
		   m.cownerid = cownerid
		   SELE invtmp
		   LOCATE FOR cownerid = m.cownerid
		   IF NOT FOUND()
		      SELE invtotal
		      DELE NEXT 1
		   ENDIF
		ENDSCAN
		
	ENDPROC

	PROCEDURE removetaxexempt
		LPARA tcWellID, tcType, tnAmount
		LOCAL lnShare
		
		*
		* Removes the tax exempt owners share from the gross amount before taxes
		* are calculated on the gross.  - For New Mexico Wells
		*
		
		lnShare = 0
		
		SELECT wellinv
		SCAN FOR cwellid = tcwellid
		   SCATTER MEMVAR
		
		   SELECT investor
		   SET ORDER TO cownerid
		   IF SEEK(m.cownerid) AND lexempt
		     do case
		        case tcType = 'BBL'
		           lnShare = lnShare + swround((tnAmount * m.nrevoil/100),2)
		        case tcType = 'MCF'
		           lnShare = lnShare + swround((tnAmount * m.nrevgas/100),2)   
		     endcase      
		  ENDIF
		ENDSCAN  
		
		lnAmount = tnAmount - lnShare
		
		RETURN (lnAmount)
		        
	ENDPROC

	PROCEDURE rounding
		*
		* Looks in the roundtmp table to see if there are any rounding records for the current owner and well
		* If there are, we report on the rounding
		*
		
		IF USED('roundtmp')
		   SELE roundtmp
		   LOCATE FOR cownerid == invtmp.cownerid AND cwellid == invtmp.cwellid AND lused = .F. AND cDMBatch == THIS.cDMBatch
		   IF FOUND()
		
		      m.nwellnet = (roundtmp.noilrev+roundtmp.ngasrev+roundtmp.ntrprev+roundtmp.nmiscrev1+roundtmp.nmiscrev2+roundtmp.nothrev) - ;
		         (roundtmp.nexpense+roundtmp.ntotale1+roundtmp.ntotale2+roundtmp.ntotale3+roundtmp.ntotale4+roundtmp.ntotale5+roundtmp.ntotalea+roundtmp.ntotaleb) - ;
		         (roundtmp.nothtax1+roundtmp.nothtax2+roundtmp.nothtax3+roundtmp.nothtax4+ ;
		         roundtmp.noiltax1+roundtmp.noiltax2+roundtmp.noiltax3+roundtmp.noiltax4+ ;
		         roundtmp.ngastax1+roundtmp.ngastax2+roundtmp.ngastax3+roundtmp.ngastax4) - ;
		         (roundtmp.ncompress+roundtmp.ngather)
		      THIS.nwelltot = THIS.nwelltot + m.nwellnet
		      IF THIS.nRunno = 0
		         m.nTotalBal = m.nTotalBal + m.nwellnet
		      ENDIF
		      m.crptgroup = 'E'
		      m.ctype     = 'RND'
		      m.cperiod   = ''
		      m.cyear     = WellWork.hYear
		      m.cprogcode = ''
		      m.cwellid   = invtmp.cwellid
		      REPL lused WITH .T.
		
		      SELECT wells
		      SET ORDER TO cwellid
		      IF SEEK(invtmp.cwellid)
		         m.cwellname = cwellname
		      ELSE
		         m.cwellname = 'Combined Wells'
		      ENDIF
		      IF THIS.lsplitperiods
		         m.cwelltype = invtmp.cownerid+invtmp.cwellid+ ;
		            invtmp.ctypeinv+invtmp.ctypeint+STR(0,1)+invtmp.hYear+invtmp.hperiod
		      ELSE
		         m.cwelltype = invtmp.cownerid+invtmp.cwellid+ ;
		            invtmp.ctypeinv+invtmp.ctypeint+STR(0,1)
		      ENDIF
		      m.cprogcode = invtmp.cprogcode
		      m.cdescript = 'Rounding Adjustment For Well: ' + ALLT(invtmp.cwellid) + ' - ' + m.cwellname
		      m.cownerid = invtmp.cownerid
		      m.nRunno = THIS.nRunno
		      *********************************************************************************************************
		      *  Insert into the statement file  - Report Group H   (Previous Deficits Being Covered)
		      *********************************************************************************************************
		      IF m.nwellnet <> 0
		         INSERT INTO statemnt FROM MEMVAR
		         IF THIS.nRunno = 0
		            SELECT statemnt
		            SCAN FOR cownerid = invtmp.cownerid
		               REPLACE nTotalBal WITH m.nTotalBal
		            ENDSCAN
		         ENDIF
		      ENDIF
		   ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE stmtnotes
		LPARA tnRunNo, tcRunYear, m.cWellID, m.cOwnerID
		m.ninvamt = 0
		llReturn  = .F.
		m.ctypeinv = this.oInvTmp.cTypeInv
		SELECT stmtnote
		IF tnRunNo = 0
		   LOCATE FOR cWellID = m.cWellID AND nrunno = tnRunNo        && Look for notes
		ELSE
		   LOCATE FOR cWellID = m.cWellID AND crunyear = tcRunYear AND nrunno = tnRunNo        && Look for notes
		ENDIF
		IF FOUND() AND NOT EMPTY(mNotes)
		   SCATTER MEMVAR MEMO
		   SELE ownnotes
		   LOCATE FOR cOwnerID = m.cOwnerID AND cWellID = m.cWellID
		   IF NOT FOUND()
		      IF m.ctypeinv = 'L' AND INLIST(m.nnotetype,1,3,5)
		         m.cdescript = '**********************************************************************'
		         m.ctype = 'NOT'
		         m.crptgroup = 'F'
		         m.cOwnerID = THIS.oInvTmp.cownerid
		         m.nRunNo = this.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group F
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.cdescript = m.mNotes
		         INSERT INTO statemnt FROM MEMVAR
		         m.cdescript = '**********************************************************************'
		         INSERT INTO statemnt FROM MEMVAR
		         *********************************************************************************************************
		         llReturn = .T.
		      ENDIF
		      IF m.ctypeinv = 'O' AND INLIST(m.nnotetype,2,3,5)
		         m.cdescript = '**********************************************************************'
		         m.ctype = 'NOT'
		         m.crptgroup = 'F'
		         m.cOwnerID = THIS.oInvTmp.cownerid
		         m.nRunNo = this.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group F
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.cdescript = m.mNotes
		         INSERT INTO statemnt FROM MEMVAR
		         m.cdescript = '**********************************************************************'
		         INSERT INTO statemnt FROM MEMVAR
		         *********************************************************************************************************
		         llReturn = .T.
		      ENDIF
		      IF m.ctypeinv = 'W' AND INLIST(m.nnotetype,4,5)
		         m.cdescript = '**********************************************************************'
		         m.ctype = 'NOT'
		         m.crptgroup = 'F'
		         m.cOwnerID = THIS.oInvTmp.cownerid
		         m.nRunNo = this.nRunNo
		         *********************************************************************************************************
		         *  Insert into the statement file  - Report Group F
		         *********************************************************************************************************
		         INSERT INTO statemnt FROM MEMVAR
		         m.cdescript = m.mNotes
		         INSERT INTO statemnt FROM MEMVAR
		         m.cdescript = '**********************************************************************'
		         INSERT INTO statemnt FROM MEMVAR
		         *********************************************************************************************************
		         llReturn = .T.
		      ENDIF
		      INSERT INTO ownnotes FROM MEMVAR 
		   ENDIF
		ENDIF
		
		
	ENDPROC

ENDDEFINE
