*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="foxaudit.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS about AS fa_form OF "foxaudit.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Fa_label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.txtVersion" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.txtDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Label5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Label6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page1.Label7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Fa_label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Fa_label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Fa_label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Fa_label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Fa_label5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Fa_label6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Fa_label7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Fa_label8" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page2.Label7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page3.Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page3.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page3.Fa_label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page3.Fa_label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page3.Fa_label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Pageframe1.Page3.Label7" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Image1" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: copyright		&& Copyright information
		*m: readme		&& Information about working with this class
		*p: ofoxaudit		&& Reference to current FoxAudit object
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "About FoxAudit"
	Closable = .F.
	ControlBox = .F.
	DoCreate = .T.
	Height = 306
	MaxButton = .F.
	MinButton = .F.
	Name = "about"
	Width = 497

	ADD OBJECT 'cmdOK' AS fa_commandbutton WITH ;
		Caption = "\<Ok", ;
		Height = 27, ;
		Left = 396, ;
		Name = "cmdOK", ;
		Top = 12, ;
		Width = 84
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Image1' AS fa_image WITH ;
		Height = 48, ;
		Left = 48, ;
		Name = "Image1", ;
		Picture = foxaudit.bmp, ;
		Stretch = 1, ;
		Top = 228, ;
		Width = 288
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="image" />

	ADD OBJECT 'Pageframe1' AS fa_pageframe WITH ;
		ErasePage = .T., ;
		Height = 276, ;
		Left = 12, ;
		Name = "Pageframe1", ;
		PageCount = 3, ;
		Top = 12, ;
		Width = 360, ;
		Page1.Caption = "Copyright", ;
		Page1.Name = "Page1", ;
		Page2.Caption = "Ordering", ;
		Page2.Name = "Page2", ;
		Page3.Caption = "Support", ;
		Page3.Name = "Page3"
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="pageframe" />

	ADD OBJECT 'Pageframe1.Page1.Fa_label1' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "All rights reserved", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 17, ;
		Name = "Fa_label1", ;
		Top = 50, ;
		Width = 106, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page1.Label1' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Copyright (c) 1998, 1999 TakeNote Computer Consulting", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 17, ;
		Name = "Label1", ;
		Top = 33, ;
		Width = 318, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page1.Label2' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Version:", ;
		Height = 17, ;
		Left = 17, ;
		Name = "Label2", ;
		Top = 86, ;
		Width = 47, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page1.Label3' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Date:", ;
		Height = 17, ;
		Left = 17, ;
		Name = "Label3", ;
		Top = 115, ;
		Width = 31, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page1.Label4' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Warning: This computer program is protected by copyright law and", ;
		FontSize = 7, ;
		Height = 14, ;
		Left = 41, ;
		Name = "Label4", ;
		Top = 139, ;
		Width = 280, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page1.Label5' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "international treaties. Unauthorized reproduction or distribution of this", ;
		FontSize = 7, ;
		Height = 14, ;
		Left = 41, ;
		Name = "Label5", ;
		Top = 150, ;
		Width = 289, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page1.Label6' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "program, or any portion of it, is strictly prohibited.", ;
		FontSize = 7, ;
		Height = 14, ;
		Left = 41, ;
		Name = "Label6", ;
		Top = 161, ;
		Width = 211, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page1.Label7' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "FoxAudit 6.0", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 17, ;
		Name = "Label7", ;
		Top = 16, ;
		Width = 71, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page1.Shape1' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 62, ;
		Left = 8, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 8, ;
		Width = 339, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'Pageframe1.Page1.Shape2' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 113, ;
		Left = 8, ;
		Name = "Shape2", ;
		SpecialEffect = 0, ;
		Top = 68, ;
		Width = 339, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'Pageframe1.Page1.txtDate' AS fa_textbox WITH ;
		Alignment = 1, ;
		BackColor = 192,192,192, ;
		FontBold = .T., ;
		ForeColor = 0,0,255, ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtDate", ;
		Style = 1, ;
		Top = 110, ;
		Value = (THIS.oFoxAudit.dBuildDate), ;
		Width = 120, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />

	ADD OBJECT 'Pageframe1.Page1.txtVersion' AS fa_textbox WITH ;
		Alignment = 1, ;
		BackColor = 192,192,192, ;
		ControlSource = "", ;
		FontBold = .T., ;
		ForeColor = 0,0,255, ;
		Height = 23, ;
		Left = 65, ;
		Name = "txtVersion", ;
		Style = 1, ;
		Top = 79, ;
		Value = , ;
		Width = 120, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />

	ADD OBJECT 'Pageframe1.Page2.Fa_label1' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "back guarantee. For more information about ordering your", ;
		Height = 17, ;
		Left = 22, ;
		Name = "Fa_label1", ;
		Top = 57, ;
		Width = 317, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Fa_label2' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "copy of FoxAudit, contact:", ;
		Height = 17, ;
		Left = 22, ;
		Name = "Fa_label2", ;
		Top = 73, ;
		Width = 137, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Fa_label3' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "TakeNote Computer Consulting", ;
		Height = 17, ;
		Left = 88, ;
		Name = "Fa_label3", ;
		Top = 90, ;
		Width = 176, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Fa_label4' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "P.O. Box 99271", ;
		Height = 17, ;
		Left = 88, ;
		Name = "Fa_label4", ;
		Top = 104, ;
		Width = 86, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Fa_label5' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Raleigh, NC  USA   27624", ;
		Height = 17, ;
		Left = 88, ;
		Name = "Fa_label5", ;
		Top = 118, ;
		Width = 143, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Fa_label6' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "www.takenote.com", ;
		Height = 17, ;
		Left = 88, ;
		Name = "Fa_label6", ;
		Top = 146, ;
		Width = 106, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Fa_label7' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "foxaudit@takenote.com", ;
		Height = 17, ;
		Left = 88, ;
		Name = "Fa_label7", ;
		Top = 160, ;
		Width = 130, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Fa_label8' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "(919) 870-9000", ;
		Height = 17, ;
		Left = 88, ;
		Name = "Fa_label8", ;
		Top = 133, ;
		Width = 87, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Label1' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "FoxAudit retails for $259 and comes with a 30-day money ", ;
		Height = 17, ;
		Left = 22, ;
		Name = "Label1", ;
		Top = 41, ;
		Width = 316, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Label7' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Ordering Information", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 23, ;
		Name = "Label7", ;
		Top = 21, ;
		Width = 120, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page2.Shape1' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 173, ;
		Left = 8, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 8, ;
		Width = 339, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'Pageframe1.Page3.Fa_label1' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "foxaudit@takenote.com or by fax to (919) 845-7666.", ;
		Height = 17, ;
		Left = 22, ;
		Name = "Fa_label1", ;
		Top = 57, ;
		Width = 281, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page3.Fa_label2' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Additional support is available on the Universal Thread", ;
		Height = 17, ;
		Left = 22, ;
		Name = "Fa_label2", ;
		Top = 80, ;
		Width = 300, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page3.Fa_label3' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "(www.universalthread.com).", ;
		Height = 17, ;
		Left = 22, ;
		Name = "Fa_label3", ;
		Top = 95, ;
		Width = 155, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page3.Label1' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Primary support for FoxAudit is provided via email to", ;
		Height = 17, ;
		Left = 22, ;
		Name = "Label1", ;
		Top = 41, ;
		Width = 283, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page3.Label7' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Technical Support", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 23, ;
		Name = "Label7", ;
		Top = 21, ;
		Width = 105, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Pageframe1.Page3.Shape1' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 173, ;
		Left = 8, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 8, ;
		Width = 339, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />
	
	PROCEDURE copyright		&& Copyright information
		******************************************************************
		* Class: About                          
		******************************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************************
		
		* This software and documentation is protected by U.S. copyright 
		* laws and International treaty provisions.
		
		* Copyright © 1998, 1999 Management Smarts, Inc. 
		*  dba TakeNote Computer Consulting
		* All rights reserved
		
		* TakeNote Computer Consulting
		* P.O. Box 99271
		* Raleigh, NC 27624
		* USA
		* (919) 870-9000
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toFoxAudit
		THIS.oFoxAudit = toFoxAudit
		RELEASE toFoxAudit
		
		THIS.PageFrame1.Page1.txtVersion.Value = THIS.oFoxAudit.cVersion
		THIS.PageFrame1.Page1.txtDate.Value = THIS.oFoxAudit.dBuildDate
		
		
	ENDPROC

	PROCEDURE readme		&& Information about working with this class
		***************************************************
		* Method:		ReadMe
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* The About form displays information about FoxAudit.
		* It is called from the FoxAudit object by calling the
		* About method.
		*
		* Example: oFoxAudit.About()
		
	ENDPROC

	PROCEDURE cmdOK.Click
		RELEASE THISFORM
	ENDPROC

ENDDEFINE

DEFINE CLASS archive AS fa_form OF "foxaudit.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtLogName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkConfirm" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtArchiveToDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblLogname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblParameters" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Fa_label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkPack" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFileName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Fa_label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdLocate" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: ofoxaudit
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	BorderStyle = 3
	Caption = "Archive Transaction Log"
	DoCreate = .T.
	Height = 243
	Name = "archive"
	Width = 559

	ADD OBJECT 'chkConfirm' AS fa_checkbox WITH ;
		Alignment = 1, ;
		AutoSize = .T., ;
		Caption = "\<Display confirmation prompt", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 15, ;
		Name = "chkConfirm", ;
		TabIndex = 6, ;
		Top = 146, ;
		Value = .T., ;
		Width = 151
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkPack' AS fa_checkbox WITH ;
		Alignment = 1, ;
		AutoSize = .T., ;
		Caption = "\<Remove records from log     ", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 15, ;
		Name = "chkPack", ;
		TabIndex = 7, ;
		Top = 166, ;
		Value = .T., ;
		Width = 155
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS fa_commandbutton WITH ;
		Cancel = .T., ;
		Caption = "\<Close", ;
		FontSize = 8, ;
		Height = 27, ;
		Left = 285, ;
		Name = "cmdCancel", ;
		TabIndex = 9, ;
		Top = 208, ;
		Width = 101
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdGo' AS fa_commandbutton WITH ;
		Caption = "\<Archive", ;
		FontSize = 8, ;
		Height = 27, ;
		Left = 155, ;
		Name = "cmdGo", ;
		TabIndex = 8, ;
		Top = 208, ;
		Width = 101
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdLocate' AS fa_commandbutton WITH ;
		Caption = "\<Locate", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 499, ;
		Name = "cmdLocate", ;
		TabIndex = 5, ;
		Top = 108, ;
		Width = 51
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Fa_label1' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = "Transaction Log Information", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 9, ;
		Name = "Fa_label1", ;
		TabIndex = 13, ;
		Top = 0, ;
		Width = 158
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Fa_label2' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Archive File Name", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 15, ;
		Name = "Fa_label2", ;
		TabIndex = 3, ;
		Top = 113, ;
		Width = 89
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblDate' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Date/Time to Roll Back To", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 15, ;
		Name = "lblDate", ;
		TabIndex = 1, ;
		Top = 86, ;
		Width = 123
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblLogname' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Log Name", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 7, ;
		Name = "lblLogname", ;
		TabIndex = 10, ;
		Top = 28, ;
		Width = 50
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblParameters' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = "Parameters", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 9, ;
		Name = "lblParameters", ;
		TabIndex = 12, ;
		Top = 61, ;
		Width = 67
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Shape1' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 48, ;
		Left = 1, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 7, ;
		Width = 555
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'Shape2' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 124, ;
		Left = 1, ;
		Name = "Shape2", ;
		SpecialEffect = 0, ;
		Top = 68, ;
		Width = 556
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'txtArchiveToDate' AS fa_textbox WITH ;
		Alignment = 3, ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 174, ;
		Name = "txtArchiveToDate", ;
		SelectOnEntry = .T., ;
		TabIndex = 2, ;
		Top = 80, ;
		Width = 156
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtFileName' AS fa_textbox WITH ;
		Alignment = 3, ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 174, ;
		Name = "txtFileName", ;
		SelectOnEntry = .T., ;
		TabIndex = 4, ;
		Top = 107, ;
		Width = 322
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtLogName' AS fa_textbox WITH ;
		BackColor = 192,192,192, ;
		FontBold = .T., ;
		FontSize = 8, ;
		ForeColor = 0,0,255, ;
		Height = 23, ;
		Left = 73, ;
		Name = "txtLogName", ;
		SelectOnEntry = .T., ;
		Style = 1, ;
		TabIndex = 11, ;
		Top = 22, ;
		Width = 477
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		******************************************************
		* Method:		Init
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/12/1999
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Pass in the FoxAudit object to work with
		******************************************************
		LPARAMETERS toFoxAudit
		THIS.oFoxAudit = toFoxAudit
		toFoxAudit = .NULL.
		RELEASE toFoxAudit
		
		* Declare LOCAL vars
		LOCAL ;
			lcTableName, ;
			lcTableStem, ;
			llAlreadyOpen
		
		THIS.txtLogName.Value = THIS.oFoxAudit.LogLocation()
		lcTableName = ALLTRIM(THIS.oFoxAudit.LogLocation())
		lcTableStem = THIS.oFoxAudit.JustStem(lcTableName)
		lcTableAlias = THIS.oFoxAudit.cLogAlias
		lcTableAlias = THIS.oFoxAudit.cLogAlias
		
		THISFORM.oFoxAudit.CloseLogTables()
		THISFORM.oFoxAudit.OpenLogTables()
		SET DATASESSION TO (THIS.oFoxAudit.iLogDataSession)
		SELECT (lcTableAlias)
		LOCATE
		
		THIS.txtArchiveToDate.Value = tUpd_When
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		RELEASE THISFORM
	ENDPROC

	PROCEDURE cmdGo.Click
		WITH THISFORM
		
			*****************************************************
			* Declare LOCAL vars
			*****************************************************
			LOCAL ;
				lcLog, ;
				ltWhen, ;
				llLogUpdates, ;
				llDisregardWarnings
		
			llDisregardWarnings = .F.
		
			IF EMPTY(.txtFileName.VALUE)
				MESSAGEBOX("You must specify a file name.",16,THISFORM.oFoxAudit.cMsgBoxTitle)
				.txtFileName.SETFOCUS()
				RETURN
			ENDIF
		
			IF EMPTY(.txtArchiveToDate.VALUE)
				MESSAGEBOX("You must specify a processing date/time.",16,THISFORM.oFoxAudit.cMsgBoxTitle)
				.txtArchiveToDate.SETFOCUS()
				RETURN
			ENDIF
		
			lcLog			= .txtLogName.VALUE
			lcFileName 		= .txtFileName.Value
			ltWhen			= .txtArchiveToDate.VALUE
			llByPassPrompt	= NOT (.chkConfirm.Value)
			llByPassPack	= NOT (.chkPack.Value)
		
			*****************************************************
			* Call the ProcessLog method to begin processing the
			* transaction log
			*****************************************************
			.oFoxAudit.Archive(ltWhen,lcFileName,llByPassPrompt,llByPassPack)
		
			*****************************************************
			* If an error occured in the FoxAudit object, cancel
			* this form
			*****************************************************
			IF .oFoxAudit.ErrorState()
				.cmdCancel.CLICK()
			ENDIF
		
			.cmdCancel.SETFOCUS()
		
		ENDWITH
		
		
	ENDPROC

	PROCEDURE cmdLocate.Click
		THISFORM.txtFileName.Value = GETFILE('DBF', 'Select Archive File', 'Select', 0,"Locate Archive File")
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fa_checkbox AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "Check1"
	Height = 17
	Name = "fa_checkbox"
	Width = 60

ENDDEFINE

DEFINE CLASS fa_commandbutton AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	Caption = "Command1"
	Height = 27
	Name = "fa_commandbutton"
	Width = 84

ENDDEFINE

DEFINE CLASS fa_dropdown AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 24
	Name = "fa_dropdown"
	Style = 2
	Width = 100

ENDDEFINE

DEFINE CLASS fa_editbox AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 53
	Name = "fa_editbox"
	Width = 100

ENDDEFINE

DEFINE CLASS fa_form AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	BorderStyle = 2
	Caption = "Form2"
	DoCreate = .T.
	Height = 250
	Left = 0
	Name = "fa_form"
	Top = 0
	Width = 375

ENDDEFINE

DEFINE CLASS fa_grid AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: highlightactiverow
		*p: chighlightrowbackcolor
		*p: chighlightrowforecolor
		*p: lhighlightactiverow
		*p: nbackcolor_blue
		*p: nbackcolor_green
		*p: nbackcolor_red
		*p: ncurrentrec
		*p: nforecolor_blue
		*p: nforecolor_green
		*p: nforecolor_red
	*</DefinedPropArrayMethod>

	chighlightrowbackcolor = 0,0,128
	chighlightrowforecolor = 255,255,255
	Height = 200
	lhighlightactiverow = .T.
	Name = "fa_grid"
	nbackcolor_blue = 0
	nbackcolor_green = 0
	nbackcolor_red = 0
	ncurrentrec = 0
	nforecolor_blue = 0
	nforecolor_green = 0
	nforecolor_red = 0
	Width = 320
	
	PROCEDURE AfterRowColChange
		LPARAMETERS nColIndex
		
		THISFORM.LockScreen = .T.
		
		IF This.lHighlightActiveRow
			*-- Update nCurrentRec property with RECNO()
			THIS.nCurrentRec = RECNO()
			This.Refresh()
		ENDIF
		
		THISFORM.LockScreen = .F.
		
	ENDPROC

	PROCEDURE BeforeRowColChange
		LPARAMETERS nColIndex
		
		*-- Prevent LEFT ARROW scrolling from Column1 when horisontal scrollbar is disabled
		IF This.ActiveColumn = 1 
			IF This.ScrollBars = 0 OR This.ScrollBars = 2
				IF LASTKEY() = 19
					NODEFAULT
				ELSE
					DODEFAULT()
				ENDIF
			ELSE
				DODEFAULT()
			ENDIF
		ENDIF
		
		
	ENDPROC

	PROCEDURE highlightactiverow
		LOCAL ;
			lnFirstComma, ;
			lnSecondComma
			
		this.nCurrentRec = 0
		
		*-- Determine comma locations in backcolor values
		lnFirstComma = AT(",",This.cHighlightRowBackcolor)
		lnSecondComma = RAT(",",This.cHighlightRowBackcolor)
		
		* Determine RED backcolor value to be used
		THIS.nBackColor_Red		= INT(VAL(LEFT(This.cHighlightRowBackcolor,lnFirstComma-1)))
		
		* Determine Green backcolor value to be used
		THIS.nBackColor_Green	= INT(VAL(SUBSTR(This.cHighlightRowBackcolor,lnFirstComma+1,lnSecondComma - (lnFirstComma+1))))
		
		* Determine Blue backcolor value to be used
		THIS.nBackColor_Blue	= INT(VAL(LTRIM(SUBSTR(This.cHighlightRowBackcolor,lnSecondComma+1,3))))
		
		*-- Determine comma locations in forecolor values
		lnFirstComma = AT(",",This.cHighlightRowForecolor)
		lnSecondComma = RAT(",",This.cHighlightRowForecolor)
		
		* Determine Red forecolor value to be used
		THIS.nForeColor_Red = INT(VAL(LEFT(This.cHighlightRowForecolor,lnFirstComma-1)))
		
		* Determine Green forcolor value to be used
		THIS.nForeColor_Green = INT(VAL(SUBSTR(This.cHighlightRowForecolor,lnFirstComma+1,lnSecondComma - (lnFirstComma+1))))
		
		* Determine Blue forecolor value to be used
		THIS.nForeColor_Blue = INT(VAL(LTRIM(SUBSTR(This.cHighlightRowForecolor,lnSecondComma+1,3))))
		
		WITH This
			.SetAll("DynamicBackColor",;
					"IIF(RECNO() = THIS.nCurrentRec,RGB(THIS.nBackColor_Red,THIS.nBackColor_Green,THIS.nBackColor_Blue),This.BackColor)","Column")
			.SetAll("DynamicForeColor",;
					"IIF(RECNO() = THIS.nCurrentRec,RGB(THIS.nForeColor_Red,THIS.nForeColor_Green,THIS.nForeColor_Blue),This.ForeColor)","Column")
		ENDWITH
		
	ENDPROC

	PROCEDURE Init
		* Should Grid highlighting be displayed?
		IF This.lHighlightActiveRow
			This.HighlightActiveRow()
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fa_image AS image 
 	*< CLASSDATA: Baseclass="image" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 68
	Name = "fa_image"
	Width = 68

ENDDEFINE

DEFINE CLASS fa_label AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	AutoSize = .T.
	BackStyle = 0
	Caption = "Label1"
	Height = 17
	Name = "fa_label"
	Width = 40

ENDDEFINE

DEFINE CLASS fa_optiongroup AS optiongroup 
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	ButtonCount = 2
	Height = 46
	Name = "fa_optiongroup"
	Value = 1
	Width = 71
	Option1.Caption = "Option1"
	Option1.Height = 17
	Option1.Left = 5
	Option1.Name = "Option1"
	Option1.Top = 5
	Option1.Value = 1
	Option1.Width = 61
	Option2.Caption = "Option2"
	Option2.Height = 17
	Option2.Left = 5
	Option2.Name = "Option2"
	Option2.Top = 24
	Option2.Width = 61

ENDDEFINE

DEFINE CLASS fa_pageframe AS pageframe 
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	ErasePage = .T.
	Height = 169
	Name = "fa_pageframe"
	PageCount = 2
	Width = 241
	Page1.Caption = "Page1"
	Page1.Name = "Page1"
	Page2.Caption = "Page2"
	Page2.Name = "Page2"

ENDDEFINE

DEFINE CLASS fa_shape AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackStyle = 0
	Height = 68
	Name = "fa_shape"
	SpecialEffect = 0
	Width = 68

ENDDEFINE

DEFINE CLASS fa_textbox AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 23
	Name = "fa_textbox"
	Width = 100

ENDDEFINE

DEFINE CLASS fieldhistory AS fa_form OF "foxaudit.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Fa_shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Fa_shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Fa_label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtTable" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory.Column3.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory.Column3.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory.Column4.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdHistory.Column4.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Fa_label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtField" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdViewFields" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: printhistoryreport
		*p: ofoxaudit
		*p: oviewfield
		*p: xkey
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "FoxAudit Field History"
	Closable = .F.
	ControlBox = .F.
	DataSession = 2
	DoCreate = .T.
	Height = 372
	MaxButton = .F.
	MinButton = .F.
	Name = "fieldhistory"
	ofoxaudit = 
	ShowTips = .T.
	Width = 559
	WindowType = 1

	ADD OBJECT 'cmdClose' AS fa_commandbutton WITH ;
		Cancel = .T., ;
		Caption = "", ;
		Height = 24, ;
		Left = 36, ;
		Name = "cmdClose", ;
		Picture = fa_close.bmp, ;
		TabIndex = 9, ;
		ToolTipText = "Close", ;
		Top = 3, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdViewFields' AS fa_commandbutton WITH ;
		Caption = "", ;
		Height = 24, ;
		Left = 9, ;
		Name = "cmdViewFields", ;
		Picture = fa_viewm.bmp, ;
		TabIndex = 8, ;
		ToolTipText = "Display field contents", ;
		Top = 3, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Fa_label1' AS fa_label WITH ;
		Caption = "Table", ;
		FontSize = 8, ;
		Left = 19, ;
		Name = "Fa_label1", ;
		Top = 51, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Fa_label2' AS fa_label WITH ;
		Caption = "Field", ;
		FontSize = 8, ;
		Left = 20, ;
		Name = "Fa_label2", ;
		Top = 71, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Fa_shape1' AS fa_shape WITH ;
		Height = 49, ;
		Left = 4, ;
		Name = "Fa_shape1", ;
		Top = 43, ;
		Width = 548, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'Fa_shape2' AS fa_shape WITH ;
		Height = 275, ;
		Left = 4, ;
		Name = "Fa_shape2", ;
		Top = 90, ;
		Width = 548, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'grdHistory' AS fa_grid WITH ;
		ColumnCount = 4, ;
		DeleteMark = .F., ;
		FontSize = 8, ;
		Height = 253, ;
		Left = 15, ;
		lhighlightactiverow = .F., ;
		Name = "grdHistory", ;
		Panel = 1, ;
		ReadOnly = .T., ;
		RowHeight = 17, ;
		Top = 103, ;
		Width = 528, ;
		ZOrderSet = 4, ;
		Column1.FontSize = 8, ;
		Column1.Name = "Column1", ;
		Column1.ReadOnly = .T., ;
		Column1.Width = 136, ;
		Column2.FontSize = 8, ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 90, ;
		Column3.FontSize = 8, ;
		Column3.Name = "Column3", ;
		Column3.ReadOnly = .T., ;
		Column3.Width = 134, ;
		Column4.FontSize = 8, ;
		Column4.Name = "Column4", ;
		Column4.ReadOnly = .T., ;
		Column4.Width = 134
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="grid" />

	ADD OBJECT 'grdHistory.Column1.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "When", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdHistory.Column1.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdHistory.Column2.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Who", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdHistory.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdHistory.Column3.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Original", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdHistory.Column3.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdHistory.Column4.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Updated", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdHistory.Column4.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'Shape4' AS fa_shape WITH ;
		BackStyle = 1, ;
		BorderStyle = 0, ;
		BorderWidth = 0, ;
		FillColor = 64,128,128, ;
		FillStyle = 0, ;
		Height = 32, ;
		Left = 0, ;
		Name = "Shape4", ;
		SpecialEffect = 0, ;
		Top = -1, ;
		Width = 607
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'txtField' AS fa_textbox WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		FontBold = .T., ;
		FontSize = 8, ;
		ForeColor = 0,0,160, ;
		Height = 23, ;
		Left = 63, ;
		Name = "txtField", ;
		Style = 1, ;
		Top = 68, ;
		Width = 273, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtTable' AS fa_textbox WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		FontBold = .T., ;
		FontSize = 8, ;
		ForeColor = 0,0,160, ;
		Height = 23, ;
		Left = 63, ;
		Name = "txtTable", ;
		Style = 1, ;
		Top = 48, ;
		Width = 273, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />
	
	PROCEDURE Init
		***************************************************************
		* Accept the current FoxAudit object and transaction record key
		***************************************************************
		LPARAMETER toFoxAudit, txKey
		
		SET TALK OFF
		SET DELETED OFF
		SET CONFIRM ON
		SET BELL OFF
		
		THISFORM.oFoxAudit = toFoxAudit
		THISFORM.xKey = txKey
		
		SET DATASESSION TO
		
		SELECT (THISFORM.oFoxAudit.cHistoryCursor)
		
		IF RECCOUNT() = 0
			ThisForm.cmdViewFields.Enabled = .F.
			ThisForm.grdHistory.Enabled = .F.
		ELSE
			LOCATE
		ENDIF
		
		THIS.grdHistory.RecordSource = THISFORM.oFoxAudit.cHistoryCursor
		ThisForm.txtTable.Value = EVAL(THISFORM.oFoxAudit.cHistoryCursor+".cTable") 
		ThisForm.txtField.Value = EVAL(THISFORM.oFoxAudit.cHistoryCursor+".cField") 
	ENDPROC

	PROCEDURE printhistoryreport
	ENDPROC

	PROCEDURE cmdClose.Click
		RELEASE THISFORM
	ENDPROC

	PROCEDURE cmdViewFields.Click
		LOCAL liKey, lcCursor
		
		***************************************************************
		* Transaction Log Key
		liKey = EVAL(THISFORM.oFoxAudit.cHistoryCursor+".iLog_Key")
		***************************************************************
		
		***************************************************************
		* Cursor with field's transactions
		***************************************************************
		lcCursor = THISFORM.oFoxAudit.cHistoryCursor
		
		THISFORM.oViewField = .NULL.
		THISFORM.oViewField = CREATEOBJECT("ViewField",lcCursor,liKey,THISFORM.oFoxAudit.cMemoAlias)
		THISFORM.oViewField.SHOW(1)
		
		THISFORM.oViewField = .NULL.
	ENDPROC

	PROCEDURE Shape4.Init
		THIS.Width = THISFORM.Width
	ENDPROC

ENDDEFINE

DEFINE CLASS foxaudit AS line 
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: about		&& Displays the About form
		*m: archive
		*m: buildhistorycursor
		*m: buildrestorecursor		&& Build the cursor that will be processed to rollforward or rollback updates
		*m: buildthermometer
		*m: closelogtables		&& Scans data sessions for open log tables and closes them
		*m: closetables		&& Close all the tables used in the process
		*m: committ		&& Committs changes to the original table with TABLEUPDATE
		*m: convertrestorekey
		*m: copyright		&& Copyright 1998 TakeNote Computer Consulting
		*m: createarchivefile
		*m: createlogfile
		*m: creatememofile
		*m: createpkeyfile
		*m: displaywarning
		*m: errorstate		&& Returns the value in lError
		*m: flocktables		&& Attempt to get a FLOCK on all tables to be processed.  If successful, continue processing
		*m: genkey		&& Generates next log key value
		*m: getdbcname		&& Returns the name of the DBC the current cursor is contained in
		*m: getfoxversion		&& Returns the current VFP version
		*m: guiarchivelog
		*m: guiprocesslog		&& Run the ProcessLog form
		*m: justdrive
		*m: justpath		&& Returns just the path for a file
		*m: juststem		&& Retuns just the file name, no extension, no path
		*m: keytochar		&& Convert Key value to character
		*m: loadclasslib		&& Loads the FoxAudit class libary if necessary
		*m: loglocation		&& Returns the full path of the location of the log from the cLogLocation property
		*m: logupdates		&& Method called from triggers to update log table
		*m: memolocation		&& Returns the name and location of the memo file
		*m: oktoinstance		&& If this method returns .T., the class can be instanced.
		*m: openlogtables		&& Opens the log and memo tables
		*m: pkeylocation
		*m: postlogupdatehook		&& Automatically run after update is logged
		*m: prelogupdatehook		&& Automatically run before record is logged.
		*m: processdelete
		*m: processinsert
		*m: processlog		&& Method used to rollback or rollforward transactions
		*m: processlufields
		*m: processlumemos
		*m: processrestorecursor
		*m: processupdate
		*m: readme		&& FoxAudit usage information
		*m: realctot
		*m: restoreenv		&& Restore to environment
		*m: restorefields		&& Works through each field in the mActions field and rollbacks the data to it's preupdated state.
		*m: restorememos
		*m: rollbackwarning
		*m: rollforwardwarning
		*m: storeluenv		&& Store the environment settings before a logged update occurs
		*m: validateloglocation
		*m: validateluparms		&& Validate the LogUpdate Parms
		*m: validaterestoreparms
		*m: viewlog
		*m: writetolog		&& Inserts a log record
		*p: cchanges		&& Contains all the changes that occured.  This data is written to the mActions memo field in the log table
		*p: ccurrentprocess		&& Set in RollbackUpdates and RollForwardUpdates with RB and RF respectively
		*p: cdbc		&& Contains the name up the DBC that the updated table whose triggers were called is in
		*p: cdbcdrive		&& Drive letter of current DBC
		*p: cdbcfullpath
		*p: cdbcname		&& Name of current DBC
		*p: cdbcpath		&& Path of current DBC
		*p: cdefaultlogname		&& Used if no log name is passed when FoxAudit object is created.
		*p: chistorycursor
		*p: cindextag
		*p: ckey		&& Contains the key value for the record being logged
		*p: ckeytype		&& Contains the data type of the key value passed in
		*p: clogalias		&& Alias of the currently open transaction log
		*p: clogarchivelocation		&& Contains the path and table information for the ARCHIVE audit table.  Specify the full path, C:\MYDRIVE\MYLOGARCHIVE.DBF, for example
		*p: cloglocation		&& Contains the path and table information for the audit table.  Specify the full path, C:\MYDRIVE\MYLOG.DBF, for example
		*p: clogpath		&& Contains the path information for the log table
		*p: clogtable		&& Contains just the name of the log table
		*p: cmemoalias		&& Alias of the open log memo table
		*p: cmemolocation
		*p: cmemopath
		*p: cmemotable
		*p: cmsgboxtext		&& Application name text to appear in the text portion of all messageboxes called
		*p: cmsgboxtitle		&& Title text to appear in all Messagebox calls
		*p: cpkeyalias		&& Alias of the log primary key table
		*p: cpkeylocation
		*p: cpkeypath
		*p: cpkeytable
		*p: crestoretablename		&& Name of the current table with records being rolled back
		*p: crestoretrgtype		&& The type of transaction being restored (I,U,D)
		*p: cseparator		&& Contains the character used to separate fields and values in the audit table
		*p: csetfullpath		&& Environmental setting for SET FULL PATH
		*p: ctable		&& Contains the name up the updated table whose triggers were called
		*p: ctabledrive		&& Drive letter of table being updated
		*p: ctablefullpath
		*p: ctablename		&& Name of table being updated
		*p: ctablepath		&& Path of table being updated
		*p: ctempfilelocation
		*p: ctemplog		&& Contains the name of the temporary cursor used to process the log records
		*p: ctranscursor
		*p: ctranstype		&& Contains the transaction type (I, U or D) that caused an update to be audited.
		*p: cuserid		&& Contains the developer assigned user ID of the person currently logged on, goApp.cUserID, for example
		*p: cusermsg1		&& Developer assigned message that is stored in the cUserMsg1 field whos width determined by iDefUserMsg1 property
		*p: cusermsg2		&& Developer assigned message that is stored in the cUserMsg2 field whos width determined by iDefUserMsg2 property
		*p: cversion
		*p: dbuilddate		&& Last build date
		*p: idatasession		&& Data Session ID of the current update
		*p: idefdbcnamelength		&& Default length for how long the cDBC_Name field should be
		*p: idefdbcpathlength		&& Default length for how long the cDBC_Path field should be
		*p: ideffieldlength		&& Default length for how long the cField name should be in the memo table
		*p: idefkeylength		&& Default length for how long the cRec_Key field should be
		*p: ideftaglength		&& Default length for how long the cTag_Name field should be
		*p: ideftblnamelength		&& Default length for how long the cTbl_Name field should be
		*p: ideftblpathlength		&& Default length for how long the cTbl_Path field should be
		*p: idefuseridlength		&& Default length for how long the cUserID field should be
		*p: idefusermsg1length		&& Determine length of cUserMsg1 field when created
		*p: idefusermsg2length		&& Determine length of cUserMsg2 field when created
		*p: ilogdatasession		&& The data session id where the log tables are opened
		*p: lerror		&& Contains .T. if an error occurred.
		*p: llocklogsopen		&& Determines if log files should stay open after logging a transaction.  Default  = .T.
		*p: llogupdates		&& Contains the audit trail toggle.  When set to .T.,  updates are logged to the cLogLocation table
		*p: llumemos		&& .T. if updated record contains memo changes
		*p: lrestoreok
		*p: lvalidatepassedparms		&& Logical value which determines if parms passed to LogUpdates need to be verified.
		*p: narea		&& Contains the work area before log update begins
		*p: nfoxversion		&& Contains the current VFP version 3,5,6 and so on
		*p: oaboutform		&& Contains a reference to the About form
		*p: oarchiveform		&& Object reference to the Archive form
		*p: oprocesslogform		&& Object reference for the Processlog form
		*p: oviewlogform		&& View log form object reference
		*p: trestoretodatetime		&& DateTime passed into RollBackUpdates or RollForwardUpdates
		*p: xrestorekey		&& Contains the record key of the currently restored record
		*a: aalreadyopentables[1,1]		&& Contains the names of the tables about to be processed that were already open
		*a: atablesprocessed[1,1]		&& Array containing the names of all the tables effected by log processing
	*</DefinedPropArrayMethod>

	PROTECTED aalreadyopentables,atablesprocessed,cchanges,ccurrentprocess,cdefaultlogname,cindextag,ckey,ckeytype,crestoretablename,crestoretrgtype,csetfullpath,ctable,ctemplog,ctranstype,idatasession,lerror,llumemos,lrestoreok,narea,trestoretodatetime,xrestorekey
	cchanges = 		&& Contains all the changes that occured.  This data is written to the mActions memo field in the log table
	ccurrentprocess = 		&& Set in RollbackUpdates and RollForwardUpdates with RB and RF respectively
	cdbc = 		&& Contains the name up the DBC that the updated table whose triggers were called is in
	cdbcdrive = 		&& Drive letter of current DBC
	cdbcfullpath = 
	cdbcname = 		&& Name of current DBC
	cdbcpath = 		&& Path of current DBC
	cdefaultlogname = FA_LOG		&& Used if no log name is passed when FoxAudit object is created.
	chistorycursor = 
	cindextag = 
	ckey = 		&& Contains the key value for the record being logged
	ckeytype = 		&& Contains the data type of the key value passed in
	clogalias = 		&& Alias of the currently open transaction log
	clogarchivelocation = 		&& Contains the path and table information for the ARCHIVE audit table.  Specify the full path, C:\MYDRIVE\MYLOGARCHIVE.DBF, for example
	cloglocation = 		&& Contains the path and table information for the audit table.  Specify the full path, C:\MYDRIVE\MYLOG.DBF, for example
	clogpath = 		&& Contains the path information for the log table
	clogtable = 		&& Contains just the name of the log table
	cmemoalias = 		&& Alias of the open log memo table
	cmemolocation = 
	cmemopath = 
	cmemotable = 
	cmsgboxtext = SherWare		&& Application name text to appear in the text portion of all messageboxes called
	cmsgboxtitle = SherWare		&& Title text to appear in all Messagebox calls
	Comment = "FoxAudit"
	cpkeylocation = 
	cpkeypath = 
	cpkeytable = 
	crestoretablename = 		&& Name of the current table with records being rolled back
	crestoretrgtype = 		&& The type of transaction being restored (I,U,D)
	cseparator = ~		&& Contains the character used to separate fields and values in the audit table
	csetfullpath = 		&& Environmental setting for SET FULL PATH
	ctable = 		&& Contains the name up the updated table whose triggers were called
	ctabledrive = 		&& Drive letter of table being updated
	ctablefullpath = 
	ctablename = 		&& Name of table being updated
	ctablepath = 		&& Path of table being updated
	ctempfilelocation = .F.
	ctemplog = 		&& Contains the name of the temporary cursor used to process the log records
	ctranscursor = 
	ctranstype = 		&& Contains the transaction type (I, U or D) that caused an update to be audited.
	cuserid = 		&& Contains the developer assigned user ID of the person currently logged on, goApp.cUserID, for example
	cusermsg1 = 		&& Developer assigned message that is stored in the cUserMsg1 field whos width determined by iDefUserMsg1 property
	cusermsg2 = 		&& Developer assigned message that is stored in the cUserMsg2 field whos width determined by iDefUserMsg2 property
	cversion = 6.005.003
	dbuilddate = {^1999/05/10}		&& Last build date
	Height = 132
	idatasession = 0		&& Data Session ID of the current update
	idefdbcnamelength = 20		&& Default length for how long the cDBC_Name field should be
	idefdbcpathlength = 20		&& Default length for how long the cDBC_Path field should be
	ideffieldlength = 20		&& Default length for how long the cField name should be in the memo table
	idefkeylength = 20		&& Default length for how long the cRec_Key field should be
	ideftaglength = 20		&& Default length for how long the cTag_Name field should be
	ideftblnamelength = 20		&& Default length for how long the cTbl_Name field should be
	ideftblpathlength = 20		&& Default length for how long the cTbl_Path field should be
	idefuseridlength = 10		&& Default length for how long the cUserID field should be
	idefusermsg1length = 50		&& Determine length of cUserMsg1 field when created
	idefusermsg2length = 50		&& Determine length of cUserMsg2 field when created
	ilogdatasession = 0		&& The data session id where the log tables are opened
	lerror = .F.		&& Contains .T. if an error occurred.
	llocklogsopen = .T.		&& Determines if log files should stay open after logging a transaction.  Default  = .T.
	llogupdates = .T.		&& Contains the audit trail toggle.  When set to .T.,  updates are logged to the cLogLocation table
	llumemos = .F.		&& .T. if updated record contains memo changes
	lrestoreok = .T.
	lvalidatepassedparms = .F.		&& Logical value which determines if parms passed to LogUpdates need to be verified.
	Name = "foxaudit"
	narea = 		&& Contains the work area before log update begins
	nfoxversion = 		&& Contains the current VFP version 3,5,6 and so on
	oaboutform = .NULL.		&& Contains a reference to the About form
	oprocesslogform = .NULL.		&& Object reference for the Processlog form
	oviewlogform = .NULL.		&& View log form object reference
	trestoretodatetime = 		&& DateTime passed into RollBackUpdates or RollForwardUpdates
	Width = 192
	xrestorekey = 		&& Contains the record key of the currently restored record
	
	PROCEDURE about		&& Displays the About form
		******************************************************
		* Method:		About	
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Load the FoxAudit class library if necessary
		******************************************************
		THIS.LoadClassLib()
		
		THIS.oAboutForm = CREATEOBJECT("About",THIS)
		
		IF TYPE("THIS.oAboutForm") == "O" AND !ISNULL(THIS.oAboutForm)
			THIS.oAboutForm.SHOW()
		ELSE
			MESSAGEBOX("The About form could not be displayed.",0,THIS.cMsgBoxTitle)
		ENDIF
		
	ENDPROC

	PROCEDURE archive
		***************************************************
		* Method:		Archive
		******************************************************
		* Author:		Jim Duffy
		* Date:			2/16/1999
		* Copyright:	1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Archives transaction log records
		******************************************************
		LPARAMETERS ;
			tdArchiveBackTo, ;
			tcFileName, ;
			tlByPassPrompt, ;
			tlByPassRemoveFromLog
			
		#DEFINE MB_ICONQUESTION         32      && Warning query
		#DEFINE MB_ICONEXCLAMATION      48      && Warning message
		
		#DEFINE MB_APPLMODAL            0       && Application modal message box
		#DEFINE MB_DEFBUTTON1           0       && First button is default
		
		*-- MsgBox return values
		#DEFINE IDNO            7       && No button pressed
		
		LOCAL ;
			lcMsgText, ;
			lnDialogType, ;
			lcMsgTitle, ;
			lcArchiveFile, ;
			llReturnValue, ;
			loThermometer, ;
			lnPctComplete, ;
			lcLogAlias, ;
			lcMemoAlias, ;
			liLoopCounter, ;
			llNewArchive
		
		IF NOT tlByPassPrompt
			lcMsgText = THIS.cMsgBoxText+" Transaction Log Archive Confirmation"+CRLF+CRLF
			lcMsgText = lcMsgText+"Do you want to archive the transaction log?"+CRLF+CRLF
			lnDialogType = MB_YESNO+MB_DEFBUTTON2+MB_ICONQUESTION
			IF MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle) = IDNO
				RETURN
			ENDIF
		ENDIF
		
		lnDataSession	= SET("DATASESSION")
		llReturnValue	= .T.
		lnDialogType	= MB_ICONSTOP
		lcLogAlias		= THIS.cLogAlias
		lcMemoAlias		= THIS.cMemoAlias
		llNewArchive	= .T.
		
		IF EMPTY(tdArchiveBackTo) OR (TYPE("tdArchiveBackTo") # "D" AND TYPE("tdArchiveBackTo") # "T")
			lcMsgText = THIS.cMsgBoxText+" Error"+CHR(13)+CHR(13)
			lcMsgText = lcMsgText + 'A valid archive date was not passed to the Archive method.'+CHR(13)
			MESSAGEBOX(lcMsgText, lnDialogType,THIS.cMsgBoxTitle)
			llReturnValue = .F.
			RETURN(llReturnValue)
		ENDIF
		
		IF TYPE("tdArchiveBackTo") = "D"
			tdArchiveBackTo = DTOT(tdArchiveBackTo)
		ENDIF
		
		* If no file name is passed in ask for one
		IF EMPTY(tcFileName)
			lcMsgText = THIS.cMsgBoxText+" Error"+CHR(13)+CHR(13)
			lcMsgText = lcMsgText + 'A archive file name was not passed to the Archive method.'+CHR(13)
			MESSAGEBOX(lcMsgText, lnDialogType,THIS.cMsgBoxTitle)
			llReturnValue = .F.
			RETURN(llReturnValue)
		ELSE
			lcArchiveFile = ALLTRIM(tcFileName)
		ENDIF
		
		* If no file name is passed in ask for one
		IF NOT ".DBF" $ UPPER(lcArchiveFile)
			lcArchiveFile = lcArchiveFile+".DBF"
		ENDIF
		
		* Does selected archive file exist?
		IF FILE(lcArchiveFile)
			llNewArchive = .F.
		ENDIF
		
		* Create Memo archive table
		lnDotLoc			= ATC(".",lcArchiveFile)
		lcArchiveMemoFile	= LEFT(lcArchiveFile,(lnDotLoc-1))+"_M.DBF"
		
		* Set up thermometer
		loThermometer = THIS.BuildThermometer()
		
		llLogOpenedHere					= .F.
		llMemoOpenedHere				= .F.
		llLogAlreadyOpenedExclusive		= .NULL.
		llMemoAlreadyOpenedExclusive	= .NULL.
		
		THIS.CloseLogTables()
		llExclusive = .T.
		
		THIS.OpenLogTables(llExclusive)
		
		* Build archive tables if necessary otherwise open them
		IF llNewArchive
			SELECT (lcLogAlias)
			COPY STRUCTURE TO (lcArchiveFile) WITH PRODUCTION
			SELECT (lcMemoAlias)
			COPY STRUCTURE TO (lcArchiveMemoFile) WITH PRODUCTION
		ELSE
			USE (lcArchiveFile) IN 0 EXCLUSIVE
			USE (lcArchiveMemoFile) IN 0 EXCLUSIVE
		ENDIF
		
		SELECT (lcLogAlias)
		SET ORDER TO TUPD_WHEN
		COUNT FOR TUPD_WHEN >= tdArchiveBackTo TO liRecordCount
		
		LOCATE FOR TUPD_WHEN >= tdArchiveBackTo
		
		lcMsg = "Archiving "+ALLTRIM(TRANSFORM(liRecordCount,"99,999,999"))+" records back to: "+TTOC(tdArchiveBackTo)
		loThermometer.UpdateBar(0,lcMsg)
		loThermometer.SHOW()
		liLoopCounter = 1
		
		lcArchiveTable = JUSTSTEM(lcArchiveFile)
		lcArchiveMemoTable = JUSTSTEM(lcArchiveMemoFile)
		
		SCAN REST
			SCATTER TO laLogFields MEMO
		
			IF NOT tlByPassRemoveFromLog
				DELETE
			ENDIF
		
			INSERT INTO (lcArchiveTable) FROM ARRAY laLogFields
		
			* Determine record key
			liKey = iLog_Key
		
			SELECT (lcMemoAlias)
			IF SEEK(liKey, lcMemoAlias,"iLog_Key")
				SCATTER TO laMemoFields MEMO
				IF NOT tlByPassRemoveFromLog
					DELETE
				ENDIF
				INSERT INTO (lcArchiveMemoTable) FROM ARRAY laMemoFields
			ENDIF
			SELECT (lcLogAlias)
			
			liLoopCounter	= liLoopCounter + 1
			lnPcntComplete	 = ((liLoopCounter/liRecordCount)*100)
			loThermometer.UpdateBar(lnPcntComplete)
		
		ENDSCAN
		
		IF NOT tlByPassRemoveFromLog
			SELECT (lcLogAlias)
			PACK
			
			SELECT (lcMemoAlias)
			PACK
		ENDIF
		
		* Close log tables
		IF llLogOpenedHere
			IF USED(lcLogAlias)
				USE in (lcLogAlias)
			ENDIF
		ENDIF
		
		IF llMemoOpenedHere
			IF USED(lcMemoAlias)
				USE IN (lcMemoAlias)
			ENDIF
		ENDIF
		
		IF NOT llLogAlreadyOpenedExclusive AND NOT llLogOpenedHere
			SELECT (lcLogAlias)
			USE
			USE (THIS.cLogLocation) SHARED ALIAS (THIS.cLogAlias)
		ENDIF
		
		IF NOT llMemoAlreadyOpenedExclusive AND NOT llMemoOpenedHere
			SELECT (lcMemoAlias)
			USE
			USE (THIS.cMemoLocation) SHARED ALIAS (THIS.cMemoAlias)
		ENDIF
		
		lcFile = JustStem(lcArchiveFile)
		IF USED(lcFile)
			USE IN (lcFile)
		ENDIF
		
		lcFile = JustStem(lcArchiveMemoFile)
		IF USED(lcFile)
			USE IN (lcFile)
		ENDIF
		
		loThermometer = .NULL.
		RELEASE loThermometer
		
		lcMsgText = THIS.cMsgBoxText+" archive process complete."+CRLF+CRLF
		lnDialogType = MB_ICONINFORMATION
		MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
		
		THIS.CloseLogTables()
		llExclusive = .F.
		THIS.OpenLogTables(llExclusive)
		
		
		SET DATASESSION TO (lnDataSession)
	ENDPROC

	PROCEDURE buildhistorycursor
		******************************************************
		* Method:		BuildTransactionsCursor
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/13/1999
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Builds and populates a cursor containing transaction
		* log records
		******************************************************
		LPARAMETERS tcTableDotField, tcKey, ttBegin, ttEnd, tnSort, tnDataSession
		
		IF EMPTY(tcTableDotField)
			MESSAGEBOX("Table can not be empty")
			RETURN
		ELSE
			lcTableDotField = UPPER(ALLTRIM(tcTableDotField))
		ENDIF
		
		IF EMPTY(tcKey)
			MESSAGEBOX("Record Key can not be empty")
			RETURN
		ELSE
			lcKey = ALLTRIM(STR(tcKey))
		ENDIF
		
		lcFieldPassed = ""
		llNoBeginDate = .F.
		llNoEndDate = .F.
		
		DO CASE
			CASE EMPTY(ttBegin)
				llNoBeginDate = .T.
			CASE TYPE("ttBegin") = "D"
				ltBegin = DTOT(ttBegin)
			OTHERWISE
				ltBegin = ttBegin
		ENDCASE
			
		DO CASE
			CASE EMPTY(ttEnd)
				llNoEndDate = .T.
			CASE TYPE("ttEnd") = "D"
				ltEnd = DTOT(ttEnd)
			OTHERWISE
				ltEnd = ttEnd
		ENDCASE
		
		lnLoc  = AT(".",lcTableDotField)
		IF lnLoc <> 0
			lcFieldPassed = SUBSTR(lcTableDotField,(lnLoc+1))
			lcTable = LEFT(lcTableDotField,(lnLoc-1))
		ENDIF
		
		llMemoField = IIF(TYPE("lcFieldPassed") = "M",.T.,.F.)
			
		LOCAL i, ;
			lcSeparator, ;
			lnSepLoc1, ;
			lnSepLoc2, ;
			lnSepLoc3, ;
			lnSepLoc4, ;
			lcDataType, ;
			lcField, ;
			lcOrg, ;
			lcUpdated, ;
			lnOldMemoWidth, ;
			lmActions, ;
			lnLines, ;
			lcSafety, ;
			liLog_Key, ;
			lcLine
		
		lnOldMemoWidth = SET("MEMOWIDTH")
		SET MEMOWIDTH TO 500
		
		*******************************************************
		* Character used as the field/value separator
		*******************************************************
		lcSeparator = THIS.cSeparator
		
		*******************************************************
		* Location of the first separator
		*******************************************************
		lnSepLoc1 = 2
		lcCursor = "TC_"+RIGHT(SYS(3),5)
		
		DO CASE
			CASE llNoBeginDate AND llNoEndDate
				SELECT * FROM (THIS.cLogAlias) ;
					WHERE 	cTbl_Name = lcTable AND ;
							cRec_Key = lcKey ;
					INTO CURSOR (lcCursor)
			
			CASE NOT llNoBeginDate AND llNoEndDate
				SELECT * FROM (THIS.cLogAlias) ;
					WHERE	cTbl_Name = lcTable AND ;
							tUpd_When >= ltBegin AND ;
							cRec_Key = lcKey ;
					INTO CURSOR (lcCursor)
		
			CASE NOT llNoBeginDate AND NOT llNoEndDate
				SELECT * FROM (THIS.cLogAlias) ;
					WHERE	cTbl_Name = lcTable AND ;
							tUpd_When >= ltBegin AND ;
							tUpd_When <= ltEnd AND ;
							cRec_Key = lcKey ;
					INTO CURSOR (lcCursor)
		
			OTHERWISE
				MESSAGEBOX("Invalid Dates passed")
				RETURN
		ENDCASE
		
		*******************************************************
		* Create the HistoryCursor
		*******************************************************
		lcSafety = SET("SAFETY")
		SET SAFETY OFF
		
		SET SAFETY &lcSafety
		
		THIS.cHistoryCursor = "HC_"+RIGHT(SYS(3),5)
		
		CREATE CURSOR (THIS.cHistoryCursor) (;
					tUpd_When t , ;
					cUpd_Who c(20) , ;
					cOrig c(100) , ;
					cUpdated c(100) ,;
					cTable c(30) , ;
					cDataType c(1) , ;
					cField c(50), ; 
					iLog_Key i)
		
		SELECT (lcCursor)
		
		lnRecCount = RECCOUNT(lcCursor)
		
		IF lnRecCount > 100
			loThermometer = THIS.BuildThermometer()
		
			lcMsg = "Creating List of Transactions..."
			loThermometer.UpdateBar(0,lcMsg)
			loThermometer.SHOW()
		ENDIF
		
		
		SCAN
		
			*******************************************************
			* Capture the contents of the mAction memo field to
			* the lmActions variable
			*******************************************************
			lmActions = EVAL(lcCursor+".mActions")
		
			*******************************************************
			* Determine how many lines there are in the mActions
			* memo field (ie how many fields need to be updated)
			*******************************************************
			lnLines = MEMLINES(lmActions)
		
			*******************************************************
			* Loop through each line
			*******************************************************
			FOR i = 1 TO lnLines
		
				****************************************************
				* Grab the line i and store it in lcLine
				****************************************************
				lcLine = MLINE(lmActions, i)
		
				****************************************************
				* Date type of field being rolledback
				****************************************************
				lcDataType = LEFT(lcLine,1)
		
				****************************************************
				* Determine location of the field value separators
				****************************************************
				lnSepLoc2 = ATC(lcSeparator,SUBSTR(lcLine,(lnSepLoc1+1))) + lnSepLoc1
				lnSepLoc3 = ATC(lcSeparator,SUBSTR(lcLine,(lnSepLoc2+1))) + lnSepLoc2
				lnSepLoc4 = LEN(lcLine)
		
				****************************************************
				* Field name of field being rolledback
				****************************************************
				lcField = SUBSTR(lcLine,(lnSepLoc1+1),(lnSepLoc2-(lnSepLoc1+1)))
				IF !EMPTY(lcFieldPassed)
					IF UPPER(ALLTRIM(lcField)) <> lcFieldPassed
						LOOP
					ENDIF
				ENDIF
		
				****************************************************
				* Original field value (pre-updated value)
				****************************************************
				lcOrig = SUBSTR(lcLine,(lnSepLoc2+1),(lnSepLoc3-(lnSepLoc2+1)))
		
				****************************************************
				* Updated field value (post updated value)
				****************************************************
				lcUpdated = SUBSTR(lcLine,(lnSepLoc3+1),(lnSepLoc4-(lnSepLoc3+1)))
		
				ltUpd_When = EVAL(lcCursor+".tUpd_When")
				lcUpd_Who = EVAL(lcCursor+".cUpd_Who")
				liLog_Key = EVAL(lcCursor+".iLog_Key")
		
				SELECT (THIS.cHistoryCursor)
				APPEND BLANK
				REPLACE cDataType 	WITH lcDataType, ;
						cField		WITH lcField, ;
						cOrig		WITH lcOrig, ;
						cUpDated	WITH lcUpdated, ;
						cTable		WITH lcTable, ;
						cUpd_Who	WITH lcUpd_Who, ;
						tUpd_When	WITH ltUpd_When, ;
						iLog_Key	WITH liLog_Key
		
			ENDFOR
		
			SELECT (lcCursor)
		
			IF lnRecCount > 100
				lnPcntComplete = ((RECNO()/lnRecCount)*100)
				loThermometer.UpdateBar(lnPcntComplete)
			ENDIF
		ENDSCAN
		
		IF USED(lcCursor)
			USE IN (lcCursor)
		ENDIF
		
		SET MEMOWIDTH TO (lnOldMemoWidth)
		
	ENDPROC

	PROTECTED PROCEDURE buildrestorecursor		&& Build the cursor that will be processed to rollforward or rollback updates
		******************************************************
		* Method:		BuildRestoreCursor
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Based on the datetime parameter passed to the
		* ProcessLog method, a temporary cursor is created
		* containing the audit records that were added after
		* the datetime value passed.
		******************************************************
		* Declare LOCAL vars
		LOCAL ;
			lcLogLocation, ;
			lcTempLog, ;
			llReturnValue, ;
			lcAction
		
		lcLogLocation	= THIS.cLogTable
		*lcLogLocation	= THIS.cLogALIAS	&& Per Joel Baines 7/7/99
		
		* Assign temporary table name
		this.ctempfilelocation = ADDBS(SYS(2023))
		lcTempLog		= this.ctempfilelocation+"_FATL"+RIGHT(SYS(3),3)
		
		llReturnValue	= .T.
		
		******************************************************
		* Build a temporary cursor containing all the log
		* records to be processed
		******************************************************
		
		WAIT WINDOW "Building Temporary Work File..." NOWAIT
		
		* Per Joel Baines 7/7/99
		*THIS.CloseLogTables()
		*THIS.OpenLogTables()
		
		SELECT * FROM (lcLogLocation) ;
			WHERE tUpd_When >= THIS.tRestoreToDateTime;
			INTO TABLE (lcTempLog)
		
		WAIT CLEAR
		
		******************************************************
		* If no records are selected to be processed,
		* inform the user.
		******************************************************
		IF RECCOUNT() = 0
			#DEFINE CRLF CHR(13)
			#DEFINE MB_ICONINFORMATION 64
			LOCAL lcMsgText, lnDialogType, lcMsgTitle
			lcMsgText = THIS.cMsgBoxText+" Information"+CRLF+CRLF
			lcMsgText = lcMsgText+"There are no records in the log table that meet "
			lcMsgText = lcMsgText+"your date criteria. No records were processed."
			lcMsgText = lcMsgText+CRLF
			lnDialogType = MB_ICONINFORMATION
			MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
			llReturnValue = .F.
		ELSE
		
		******************************************************
		* Assign the name of the temporary cursor to
		* THIS.cTempLog
		******************************************************
			THIS.cTempLog = lcTempLog
		ENDIF
		
		RETURN(llReturnValue)
		
	ENDPROC

	PROTECTED PROCEDURE buildthermometer
		******************************************************
		* Method:		BuildThermometer
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		LOCAL loThermometer
		
		THIS.LoadClassLib()
		
		loThermometer = CREATEOBJECT("FoxAuditThermo")
		loThermometer.TOP = 30
		loThermometer.LEFT = ((_SCREEN.WIDTH - loThermometer.WIDTH) / 2)
		
		RETURN(loThermometer)
		
	ENDPROC

	PROCEDURE closelogtables		&& Scans data sessions for open log tables and closes them
		******************************************************
		* Method:		CloseLogTables
		******************************************************
		* Author:		Jim Duffy
		* Date:			4/12/1999
		* Copyright:	1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Closes all occurances of the transaction log tables
		* across data sessions
		******************************************************
		* Save the original error handler
		lcOldOnError = ON("ERROR")
		
		lnDataSession = SET("DATASESSION")
		
		ON ERROR *
		
		FOR i = 1 TO 40
		
			SET DATASESSION TO (i)
		
			IF THIS.lError
				THIS.lError = .F.
				EXIT
			ENDIF
		
			IF USED(JUSTSTEM(THIS.cLogTable))
				USE IN (JUSTSTEM(THIS.cLogTable))
			ENDIF
			
			IF USED(THIS.cLogALias)
				USE IN (THIS.cLogAlias)
			ENDIF
		
			IF USED(JUSTSTEM(THIS.cMemoTable))
				USE IN (JUSTSTEM(THIS.cMemoTable))
			ENDIF
			
			IF USED(THIS.cMemoAlias)
				USE IN (THIS.cMemoAlias)
			ENDIF
		
		ENDFOR
		
		IF !EMPTY(lcOldOnError)
			ON ERROR &lcOldOnError
		endif
		
		SET DATASESSION TO (lnDataSession)
	ENDPROC

	PROTECTED PROCEDURE closetables		&& Close all the tables used in the process
		******************************************************
		* Method:		CloseTables
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	1998 TakeNote Computer Consulting
		*					http://www.takenote.com
		*					All rights reserved
		******************************************************
		* Declare LOCAL vars
		LOCAL ;
			lcTable, ;
			liCount, ;
			i, ;
			j, ;
			lcOrder, ;
			liRecNo
		
		
		*******************************************************
		* Close and erase the temporary cursor
		*******************************************************
		IF USED(THIS.cTempLog)
			USE IN (THIS.cTempLog)
		 	ERASE (this.ctempfilelocation+"_FATL*.*")
		ENDIF
		
		*******************************************************
		* Close the tables processed
		*******************************************************
		IF !EMPTY(THIS.aTablesProcessed[1])
			liCount = ALEN(THIS.aTablesProcessed)
			FOR i = 1 TO liCount
				lcTable = ALLTRIM(JustStem(THIS.aTablesProcessed[i]))
				USE IN (lcTable)
			ENDFOR
		ENDIF
		
		*******************************************************
		* Reopen the tables that were processed if they were open
		* when the process started
		*******************************************************
		IF !EMPTY(THIS.aAlreadyOpenTables[1,1])
			FOR j = 1 TO ALEN(THIS.aAlreadyOpenTables,1)
				lcTable			= THIS.aAlreadyOpenTables[j,1]
				lcOrder			= THIS.aAlreadyOpenTables[j,2]
				liRecNo			= THIS.aAlreadyOpenTables[j,3]
				SELECT 0
				USE (lcTable) ORDER (lcOrder)
				GO (liRecNo)
			ENDFOR
		ENDIF
		
		*******************************************************
		* Reset the arrays back to empty
		*******************************************************
		DIMENSION THIS.aTablesProcessed[1]
		THIS.aTablesProcessed = ""
		
		DIMENSION THIS.aAlreadyOpenTables[1,3]
		THIS.aAlreadyOpenTables = ""
		
		*******************************************************
		* Ease Temp files
		*******************************************************
		
		
	ENDPROC

	PROTECTED PROCEDURE committ		&& Committs changes to the original table with TABLEUPDATE
		******************************************************
		* Method:		Committ
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Committ changes to the transaction log table
		******************************************************
		IF !TABLEUPDATE(0)
			=AERROR(laError)
		
			LOCAL ;
				lcAlias, ;
				lcIndexTag, ;
				lcIndexExp, ;
				lcMsgText, ;
				lnDialogType, ;
				lcRecNo, ;
				i, ;
				j, ;
				lnFields, ;
				lxIndexValue, ;
				lcIndexValue, ;
				lxFieldValue, ;
				lcFieldValue
				
			lcAlias = ALIAS()
			lcRecNo = ALLTRIM(STR(RECNO()))
			lnFields = IIF(FCOUNT() <= 10, FCOUNT(), 10)
		
			* Determine Primary key and expression
			For j = 1 To TagCount()
		       If Primary(j)
		         lcIndexTag = (Tag(j))
		         lcIndexExp = SYS(14,j)
		         EXIT
		       Endif
		    EndFor
			
			
			lxIndexValue = EVAL(lcIndexExp)
			DO CASE
				CASE TYPE('lxIndexValue') = "C"
					lcIndexValue = lxIndexValue
				CASE TYPE('lxIndexValue') = "D"
					lcIndexValue = DTOC(lxIndexValue)
				CASE TYPE('lxIndexValue') = "T"
					lcIndexValue = TTOC(lxIndexValue)
				CASE INLIST(TYPE('lxIndexValue'),"I","N","Y","B")
					lcIndexValue = STR(lxIndexValue)
				CASE TYPE('lxIndexValue') = "L"
					lcIndexValue = IIF(lxIndexValue=.T.,".T.",".F.")
			ENDCASE		
		
			lcMsgText = THIS.cMsgBoxText+" Error"+CRLF+CRLF
			lcMsgText = lcMsgText+THIS.cMsgBoxText+" had trouble processing the following "
			lcMsgText = lcMsgText+"record. "+CHR(13)+CHR(13)
			lcMsgText = lcMsgText+"Table: "+lcAlias+CHR(13)
			lcMsgText = lcMsgText+"Record #: "+lcRecNo+CHR(13)
			lcMsgText = lcMsgText+"Index Tag: "+lcIndexTag+CHR(13)
			lcMsgText = lcMsgText+"Index Exp: "+lcIndexExp+CHR(13)
			lcMsgText = lcMsgText+"Index Value: "+lcIndexValue+CHR(13)+CHR(13)
			lcMsgText = lcMsgText+"The first "+ALLTRIM(STR(lnFields)) +" fields are:"+CHR(13)
		
			FOR i = 1 TO lnFields
				lxFieldValue = EVAL(FIELD[i])
				DO CASE
					CASE TYPE('lxFieldValue') = "C"
						lcFieldValue = lxFieldValue
					CASE TYPE('lxFieldValue') = "D"
						lcFieldValue = DTOC(lxFieldValue)
					CASE TYPE('lxFieldValue') = "T"
						lcFieldValue = TTOC(lxFieldValue)
					CASE INLIST(TYPE('lxFieldValue'),"I","N","Y","B")
						lcFieldValue = STR(lxFieldValue)
					CASE TYPE('lxFieldValue') = "L"
						lcFieldValue = IIF(lxFieldValue=.T.,".T.",".F.")
				ENDCASE		
		
				lcMsgText = lcMsgText + "    Field: "+FIELD[i]+"   Value: "+lcFieldValue +CHR(13)
			ENDFOR
		
			lcMsgText = lcMsgText+CHR(13)+CHR(13)
			DO CASE
				* Primary Key problem
				CASE laError[1] = 1884
					
					lcMsgText = lcMsgText + "Problem: An attempt was made to write a record with a "
					lcMsgText = lcMsgText + "duplicate key."+CHR(13)
			ENDCASE
				
			lnDialogType = MB_ICONSTOP
		
			MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxText)
		ENDIF
		
		
	ENDPROC

	PROTECTED PROCEDURE convertrestorekey
		******************************************************
		* Method:		ConvertRestoreKey
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	1998 TakeNote Computer Consulting
		*					http://www.takenote.com
		*					All rights reserved
		******************************************************
		* Convert the key value stored in the log table back
		* to its original data type
		******************************************************
		* Declare LOCAL vars
		LOCAL ;
			lxKey, ;
			lcKeyType, ;
			lcTran_Type
		
		* pws - 5/7/21 Make sure the temp log table is selected
		
		lcLogTable = JUSTFNAME(this.ctemplog)
		SELECT (lcLogTable)
		* Assign vars value from transaction log fields
		lcKeyType  	= cKey_Type
		lcTran_Type = cTran_Type
		
		DO CASE
		***********************************************
		* Process Integer, Numerics, Currency, Double and
		* Float fields
		***********************************************
			CASE INLIST(lcKeyType,"I","N","Y","B","F")
				lxKey = VAL(cRec_Key)
		
		***********************************************
		* Process Character fields
		***********************************************
			CASE lcKeyType = "C"
				lxKey = RTRIM(cRec_Key)
		
		***********************************************
		* Process Date fields
		***********************************************
			CASE lcKeyType = "D"
		
				DO CASE
		
		* This section of code included for backward compatibility
		* with VFP 3 & 5.  It WILL cause a STRICTDATE warning to appear
		* when compiled in VFP 6.0.  Comment out the
		*
		* lxKey=CTOD(cRec_Key)
		*
		* line to avoid the STRICTDATE warnings
					CASE INLIST(THIS.nFoxVersion,3,5)
						lcCmd = "lxKey=CTOD(cRec_Key)"
						&lcCmd.
				
		* Support for SET STRICTDATE TO 2 in VFP 6.0 and later versions
					OTHERWISE
						LOCAL ;
							lnYear, ;
							lnMonth, ;
							lnDay
						lnYear	= Val(right(cRec_Key,4))
						lnMonth	= val(left(cRec_Key,2))
						lnDay	= val(substr(cRec_Key,4,2))
						lxKey	= DATE(lnYear,lnMonth,lnDay)
				
				ENDCASE
				
		***********************************************
		* Process DateTime fields
		***********************************************
			CASE lcKeyType = "T"
				lxKey=THIS.RealCTOT(cRec_Key)
		
		***********************************************
		* Process Logical fields
		***********************************************
			CASE lcKeyType = "L"
				lxKey = IIF(cRec_Key="True",.T.,.F.)
		
		ENDCASE
		
		THIS.xRestoreKey = lxKey
		
		RETURN
		
	ENDPROC

	PROCEDURE copyright		&& Copyright 1998 TakeNote Computer Consulting
		******************************************************************
		* Class: FoxAudit 6.0
		******************************************************************
		* Author:		Jim Duffy
		* Date:			5/10/1999
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************************
		
		* This software and documentation is protected by U.S. copyright 
		* laws and International treaty provisions.
		
		* Copyright © 1998, 1999 Management Smarts, Inc. 
		*  dba TakeNote Computer Consulting
		* All rights reserved
		
		* TakeNote Computer Consulting
		* P.O. Box 99271
		* Raleigh, NC 27624
		* USA
		* (919) 870-9000
		* foxaudit@takenote.com
	ENDPROC

	PROCEDURE createarchivefile
		******************************************************
		* Method:		CreateArchiveFile
		******************************************************
		* Author:		Jim Duffy
		* Date:			2/18/1999
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Called by the Archive method.  If the archive file
		* does not exist when the Archive() method is run it 
		* is created here.
		******************************************************
		#DEFINE CRLF	CHR(13)
		THIS.lError = .F.
		
			LOCAL ;
				lcDBC, ;
				lcOldDBC, ;
				llDBCOpen
		
			llDBCOpen = .T.
		
			DO CASE
				CASE EMPTY(DBC()) AND !EMPTY(DBF())
					llDBCOpen = .F.
					lcOldDBC = SET("DATABASE")
					lcDBC = JustStem(THIS.GetDBCName())
					SET DATABASE TO (lcDBC)
		
				CASE EMPTY(DBC()) AND EMPTY(DBF())
					lcMsgText = THIS.cMsgBoxText+" Error Information"+CRLF+CRLF
					lcMsgText = lcMsgText + "A database must first be open before "
					lcMsgText = lcMsgText + "a transaction log archive file can be created."+CRLF+CRLF
					THIS.lError = .T.
					MESSAGEBOX(lcMsgText,0,THIS.cMsgBoxTitle)
					RETURN
			ENDCASE
		
		******************************************************
		* Build transaction log archive table
		******************************************************
			CREATE TABLE (THIS.cLogLocation) ;
				(iLog_Key i PRIMARY KEY , ;
				cTran_Type c(1), ;
				cDBC_Drive c(1), ;
				cDBC_Path c(THIS.iDefDBCPathLength), ;
				cDBC_Name c(THIS.iDefDBCNameLength), ;
				cTbl_Drive c(1), ;
				cTbl_Path c(THIS.iDefTblPathLength), ;
				cTbl_Name c(THIS.iDefTblNameLength), ;
				cTag_Name c(THIS.iDefTagLength), ;
				cKey_Type c(1), ;
				cRec_Key c(THIS.iDefKeyLength), ;
				mActions m, ;
				lMemos l DEFAULT .F., ;
				cUserMsg1 c(THIS.iDefUserMsg1Length), ;
				cUserMsg2 c(THIS.iDefUserMsg2Length), ;
				cUpd_Who c(THIS.iDefUserIDLength), ;
				tUpd_When T DEFAULT DATETIME())
		
		******************************************************
		* Build transaction log archive table indexes
		******************************************************
			IF FILE(THIS.cLogLocation) AND !THIS.lError
		
				lcCollate = SET("COLLATE")
				SET COLLATE TO "MACHINE"
		
				INDEX ON cTbl_Name	TAG cTbl_Name
				INDEX ON cTran_Type	TAG cTran_Type
				INDEX ON cUpd_Who	TAG cUpd_Who
				INDEX ON tUpd_When	TAG tUpd_When
				INDEX ON iLog_Key	TAG PKEY
				INDEX ON DELETED()	TAG DELETED
		
				SET COLLATE TO (lcCollate)
		
				THIS.cLogTable	= JustStem(THIS.cLogLocation)
				THIS.cLogPath	= JustPath(THIS.cLogLocation)
			ENDIF
		
		******************************************************
		* Build table containing memo updates
		******************************************************
			IF !THIS.lError
				THIS.CreateArchiveMemoFile()
			ENDIF
		
		******************************************************
		* If the files were created sucessfully and an error has
		* not occured then all is well
		******************************************************
			IF !llDBCOpen
				SET DATABASE TO
			ENDIF
		
		
		RETURN
		
	ENDPROC

	PROTECTED PROCEDURE createlogfile
		******************************************************
		* Method:		CreateLogFile
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Called by the OKToInstance method.  If the log file
		* specified when the FoxAudit object was created does
		* not exist, then it is created here.
		* _TRIGGERLEVEL is checked because doing a CREATE
		* TABLE inside a trigger causes VFP to crash
		******************************************************
		#DEFINE CRLF	CHR(13)
		THIS.lError = .F.
		
		IF _TRIGGERLEVEL = 0
		
			LOCAL ;
				lcDBC, ;
				lcOldDBC, ;
				llDBCOpen
		
			llDBCOpen = .T.
		
			DO CASE
				CASE EMPTY(DBC()) AND !EMPTY(DBF())
					llDBCOpen = .F.
					lcOldDBC = SET("DATABASE")
					lcDBC =JustStem(THIS.GetDBCName())
					SET DATABASE TO (lcDBC)
		
				CASE EMPTY(DBC()) AND EMPTY(DBF())
					lcMsgText = THIS.cMsgBoxText+" Error Information"+CRLF+CRLF
					lcMsgText = lcMsgText + "A database must first be open before "
					lcMsgText = lcMsgText + "a transaction log can be created."+CRLF+CRLF
					THIS.lError = .T.
					MESSAGEBOX(lcMsgText,0,THIS.cMsgBoxTitle)
					RETURN
			ENDCASE
		
		******************************************************
		* Build Primary transaction logging table
		******************************************************
			CREATE TABLE (THIS.cLogLocation) ;
				(iLog_Key i PRIMARY KEY, ;
				cTran_Type c(1), ;
				cDBC_Drive c(1), ;
				cDBC_Path c(THIS.iDefDBCPathLength), ;
				cDBC_Name c(THIS.iDefDBCNameLength), ;
				cTbl_Drive c(1), ;
				cTbl_Path c(THIS.iDefTblPathLength), ;
				cTbl_Name c(THIS.iDefTblNameLength), ;
				cTag_Name c(THIS.iDefTagLength), ;
				cKey_Type c(1), ;
				cRec_Key c(THIS.iDefKeyLength), ;
				mActions m, ;
				lMemos l DEFAULT .F., ;
				cUserMsg1 c(THIS.iDefUserMsg1Length), ;
				cUserMsg2 c(THIS.iDefUserMsg2Length), ;
				cUpd_Who c(THIS.iDefUserIDLength), ;
				tUpd_When T DEFAULT DATETIME())
		
		*!* old log structure
		*!*		CREATE TABLE (THIS.cLogLocation) ;
		*!*			(iLog_Key i PRIMARY KEY DEFAULT FA_GenKy(DBF()), ;
		*!*			cTran_Type c(1), ;
		*!*			cDBC_Name c(THIS.iDefDBCLength), ;
		*!*			cTbl_Name c(THIS.iDefTblLength), ;
		*!*			cTag_Name c(THIS.iDefTagLength), ;
		*!*			cKey_Type c(1), ;
		*!*			cRec_Key c(THIS.iDefKeyLength), ;
		*!*			mActions m, ;
		*!*			lMemos l DEFAULT .F., ;
		*!*			cUserMsg1 c(THIS.iDefUserMsg1Length), ;
		*!*			cUserMsg2 c(THIS.iDefUserMsg2Length), ;
		*!*			cUpd_Who c(THIS.iDefUserIDLength), ;
		*!*			tUpd_When T DEFAULT DATETIME())
		
		******************************************************
		* Build Primary transaction logging table indexes
		******************************************************
			IF FILE(THIS.cLogLocation) AND !THIS.lError
		
				lcCollate = SET("COLLATE")
				SET COLLATE TO "MACHINE"
		
				INDEX ON cTbl_Name	TAG cTbl_Name
				INDEX ON cTran_Type	TAG cTran_Type
				INDEX ON cUpd_Who	TAG cUpd_Who
				INDEX ON tUpd_When	TAG tUpd_When
				INDEX ON iLog_Key	TAG iLog_Key2
				SET COLLATE TO (lcCollate)
		
				THIS.cLogTable	= JustStem(THIS.cLogLocation)
				THIS.cLogPath	= JustPath(THIS.cLogLocation)
			ENDIF
		
		******************************************************
		* Build table containing memo updates
		******************************************************
			IF !THIS.lError
				THIS.CreateMemoFile()
			ENDIF
		
		******************************************************
		* Build table containing primary key values
		******************************************************
			IF !THIS.lError
				THIS.CreatePKeyFile()
			ENDIF
		
		******************************************************
		* If the files were created sucessfully and an error has
		* not occured then all is well
		******************************************************
			IF !llDBCOpen
				SET DATABASE TO
			ENDIF
		
		ELSE
			THIS.lError = .T.
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE creatememofile
		******************************************************
		* Method:		CreateMemoFile
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Creates the table that contains all of the updates to
		* memo fields
		******************************************************
		* Declare LOCAL vars
		LOCAL ;
			lnDotLoc, ;
			lcLoglocation, ;
			lcMemoLocation, ;
			lcCollate
		
		lcLoglocation	= THIS.LogLocation()
		lnDotLoc		= ATC(".",lcLoglocation)
		lcMemoLocation	= LEFT(lcLoglocation,(lnDotLoc-1))+"_M.DBF"
		
		* Create transaction memo table
		CREATE TABLE (lcMemoLocation) ;
			(iLog_Key i, ;
			cField c(THIS.iDefFieldLength), ;
			mOrig m, ;
			mUpdated m)
		
		* If transaction memo table was created OK build indexes
		IF FILE(lcMemoLocation) AND !THIS.lError
		
			lcCollate = SET("COLLATE")
			SET COLLATE TO "MACHINE"
			INDEX ON BINTOC(iLog_Key)+cField 	TAG PKEY
			INDEX ON iLog_Key					TAG iLog_Key
		*	INDEX ON DELETED()					TAG DELETED
			SET COLLATE TO (lcCollate)
		
			THIS.cMemoLocation	= lcMemoLocation
			THIS.cMemoTable		= JustStem(THIS.cMemoLocation)
			THIS.cMemoPath		= JustPath(THIS.cMemoLocation)
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE createpkeyfile
		******************************************************
		* Method:		CreatePKeyFile
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Creates the table responsible for supply record keys to
		* the transaction table
		******************************************************
		* Declare LOCAL vars
		LOCAL ;
			lcLogLocation, ;
			lnDotLoc, ;
			lcPkLocation
		
		lcLogLocation	= THIS.LogLocation()
		lnDotLoc		= ATC(".",lcLogLocation)
		lcPKLocation	= LEFT(lcLogLocation,(lnDotLoc-1))+"_K.DBF"
		
		* Create transaction primary key table
		CREATE TABLE (lcPKLocation) ;
			(iNextKey i DEFAULT 1)
		
		******************************************************
		* If table built OK add first record
		******************************************************
		IF FILE(lcPKLocation) AND !THIS.lError
			APPEND BLANK
			USE IN (lcPKLocation)
		
			THIS.cPKeyLocation	= lcPKLocation
			THIS.cPKeyTable		= JustStem(THIS.cPKeyLocation)
			THIS.cPKeyPath		= JustPath(THIS.cPKeyLocation)
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE Destroy
		******************************************************
		* Method:		Destroy
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	1998,1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Release the object references
		******************************************************
		THIS.oViewLogForm		= .NULL.
		THIS.oArchiveForm		= .NULL.
		THIS.oProcessLogForm	= .NULL.
		
		******************************************************
		* Close the transaction log and associated tables
		******************************************************
		TRY 
		IF USED(THIS.cLogAlias)
			USE IN (THIS.cLogAlias)
		ENDIF
		
		IF USED(THIS.cMemoAlias)
			USE IN (THIS.cMemoAlias)
		ENDIF
		
		IF USED(THIS.cPKeyAlias)
			USE IN (THIS.cPKeyAlias)
		ENDIF
		CATCH TO loErr
		ENDTRY 
	ENDPROC

	PROTECTED PROCEDURE displaywarning
		******************************************************
		* Method:		DisplayWarning
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		#DEFINE CRLF CHR(13)
		#DEFINE MB_ICONSTOP 32
		#DEFINE MB_YESNO		4
		#DEFINE IDYES			6
		#DEFINE MB_DEFBUTTON2	256
		#DEFINE MB_ICONINFORMATION 64
		
		* Declare LOCAL vars
		LOCAL ;
			lcMsgText, ;
			lnDialogType, ;
			lcTiming, ;
			lcProcess, ;
			llReturnValue
		
		llReturnValue = .T.
		lcTiming = "1ST"
		lcProcess = THIS.cCurrentProcess
		
		DO CASE
			CASE lcProcess = "RB"
				lcMsgText = THIS.RollBackWarning(lcTiming)
			CASE lcProcess = "RF"
				lcMsgText = THIS.RollForwardWarning(lcTiming)
		ENDCASE
		
		lnDialogType = MB_ICONSTOP+MB_YESNO+MB_DEFBUTTON2
		
		IF MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle) <> IDYES
			lcMsgText = THIS.cMsgBoxText+" Information"+CRLF+CRLF
			lcMsgText = lcMsgText+"The transaction log was not processed. No data "
			lcMsgText = lcMsgText+"updates occured."+CRLF
			lnDialogType = MB_ICONINFORMATION
			MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
			llReturnValue = .F.
		ELSE
			lcTiming = "2ND"
			DO CASE
				CASE lcProcess = "RB"
					lcMsgText = THIS.RollBackWarning(lcTiming)
				CASE lcProcess = "RF"
					lcMsgText = THIS.RollForwardWarning(lcTiming)
			ENDCASE
		
			lnDialogType = MB_ICONSTOP+MB_YESNO+MB_DEFBUTTON2
			IF MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle) <> IDYES
				lcMsgText = THIS.cMsgBoxText+" Information"+CRLF+CRLF
				lcMsgText = lcMsgText + "The transaction log was not processed. No data "
				lcMsgText = lcMsgText + "updates occured."+CRLF
				lnDialogType = MB_ICONINFORMATION
				MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
				llReturnValue = .F.
			ELSE
				llReturnValue = .T.
			ENDIF
		ENDIF
		
		RETURN(llReturnValue)
		
	ENDPROC

	PROCEDURE Error
		******************************************************
		* Method:		Error
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		LPARAMETERS nError, cMethod, nLine
		
		#DEFINE MB_OKCANCEL             1       && OK and Cancel buttons
		#DEFINE MB_ABORTRETRYIGNORE     2       && Abort, Retry, and Ignore buttons
		#DEFINE MB_RETRYCANCEL          5       && Retry and Cancel buttons
		
		#DEFINE MB_ICONQUESTION         32      && Warning query
		#DEFINE MB_ICONEXCLAMATION      48      && Warning message
		
		*-- MsgBox return values
		#DEFINE IDCANCEL        2       && Cancel button pressed
		#DEFINE IDABORT         3       && Abort button pressed
		#DEFINE IDRETRY         4       && Retry button pressed
		#DEFINE IDIGNORE        5       && Ignore button pressed
		
		LOCAL lcMsgText
		AERROR(laError)
		
		DO CASE
			CASE laError[1] = 1540 AND UPPER(cMethod) = "CLOSELOGTABLES"
				THIS.lError = .T.
				RETURN
		
			CASE laError[1] = 1 AND UPPER(cMethod) = "ARCHIVE"
				RETURN
		
			CASE laError[1] = 3 AND UPPER(cMethod) = "FLOCKTABLES"
				THIS.lError = .T.
				RETURN
		
			CASE laError[1] = 5		&& Record out of range
				THIS.lError = .T.
				RETURN
		
			CASE laError[1] = 202	&& Invalid path or file name
				THIS.lError = .T.
				RETURN
		
			CASE laError[1] = 1539	&& Trigger failed
				THIS.lError = .T.
		
			CASE laError[1] = 1705	&& File access denied
				THIS.lError = .T.
				RETURN
		
			CASE laError[1] = 1884	&& File access denied
				THIS.lError = .T.
				RETURN
		
		ENDCASE
		
		lcMsgText = THIS.cMsgBoxText+" Error Information"+CRLF+CRLF
		lcMsgText = lcMsgText+"A problem has occured that "+THIS.cMsgBoxText+" was unable handle. The "
		lcMsgText = lcMsgText+"following information was available at the time of the problem."
		lcMsgText = lcMsgText+CHR(13)+CHR(13)
		lcMsgText = lcMsgText+"Error: "+ALLTR(STR(nError))+CHR(13)
		lcMsgText = lcMsgText+"Message: "+laError[2]+CHR(13)
		lcMsgText = lcMsgText+"Method: "+cMethod+CHR(13)
		lcMsgText = lcMsgText+"Line #: "+ALLT(STR(nLine))+CHR(13)
		lcMsgText = lcMsgText+"Code: "+laerror[3]+CHR(13)
		
		lnDialogType = MB_RETRYCANCEL+MB_DEFBUTTON2+MB_ICONSTOP
		lnSelected = MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
		
		THIS.lError = .T.
		
		DO CASE
			CASE lnSelected = IDCANCEL
				CANCEL
		
			CASE lnSelected = IDRETRY
				RETRY
		
		ENDCASE
		
		RETURN
		
	ENDPROC

	PROCEDURE errorstate		&& Returns the value in lError
		******************************************************
		* Method:		ErrorState
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Makes the lError value available outside the 
		* FoxAudit object
		******************************************************
		RETURN(THIS.lError)
		
		
	ENDPROC

	PROTECTED PROCEDURE flocktables		&& Attempt to get a FLOCK on all tables to be processed.  If successful, continue processing
		******************************************************
		* Method:		FlockTables
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Open and FLOCK() the tables to be processed
		* Before any transaction log records are processed (RB
		* or RF) FoxAudit insures that all affected tables
		* an be FLOCKed. If they can be then processing
		* continues.
		******************************************************
		* Declare LOCAL vars
		******************************************************
		LOCAL ;
			lcTempLog, ;
			llReturnValue, ;
			lcBadTables, ;
			lcTablesToProcess, ;
			lcTable, ;
			lcTag, ;
			lcTableStem, ;
			liNewLen
		
		llReturnValue		= .T.
		lcTempLog			= ALLTRIM(THIS.cTempLog)
		lcTablesToProcess	= "T2P"+LEFT(SYS(3),4)
		lcBadTables			= ""
		THIS.lError			= .F.
		
		SELECT (lcTempLog)
		
		******************************************************
		* Build a cursor containing the names of the tables to be
		* processed
		******************************************************
		SELECT ;
			cTbl_Drive AS cTableDrive, ;
			cTbl_Path AS cTablePath, ;
			cTbl_Name AS cTableName, ;
			cTag_Name AS cTagName ;
			FROM (lcTempLog) ;
			GROUP BY 3 ;
			INTO CURSOR Tables2Process
		
		*	GROUP BY 1 ; 6/3
		
		SELECT Tables2Process
		GO TOP
		
		******************************************************
		* Loop through cursor and attempt to open and FLOCK()
		* each table. If any problems occur, the Error method
		* sets the lError property to .T.
		******************************************************
		DIMENSION THIS.aTablesProcessed[1]
		DIMENSION THIS.aAlreadyOpenTables[1,3]
		
		SCAN
			lcDrive	= ALLTRIM(Tables2Process.cTableDrive)
			lcPath	= ALLTRIM(Tables2Process.cTablePath)
			lcTable	= ALLTRIM(Tables2Process.cTableName)
			lcFullTable = lcDrive+":"+lcPath+"\"+lcTable
			lcTag	= ALLTRIM(Tables2Process.cTagName)
			lcTableStem = JustStem(lcTable)
		
		*--5/22	IF USED(lcTableStem)
		*--5/22		SELECT (lcTableStem)
			IF USED(lcTable)
				SELECT (lcTable)
				IF EMPTY(THIS.aAlreadyOpenTables[1,1])
					liNewLen = 1
				ELSE
					liNewLen = ALEN(THIS.aAlreadyOpenTables,1) + 1
					DIMENSION THIS.aAlreadyOpenTables[liNewLen,4]
				ENDIF
		
				THIS.aAlreadyOpenTables[liNewLen,1] = lcDrive+":"+lcPath+'\'+lcTable
				THIS.aAlreadyOpenTables[liNewLen,2] = ORDER()
				THIS.aAlreadyOpenTables[liNewLen,3] = RECNO()
		
				USE IN (lcTable)
			ENDIF
		
			SELECT 0
			USE (lcFullTable) ORDER (lcTag) && EXCLUSIVE
			IF !THIS.lError
				IF ! FLOCK()
					lcBadTables = lcBadTables + lcTable + CHR(13)
					llReturnValue = .F.
					EXIT
				ENDIF
				IF EMPTY(THIS.aTablesProcessed[1])
					THIS.aTablesProcessed[1] = lcTable
				ELSE
					liNewLen = ALEN(THIS.aTablesProcessed) + 1
					DIMENSION THIS.aTablesProcessed[liNewLen]
					THIS.aTablesProcessed[liNewLen] = lcTable
				ENDIF
						
				CURSORSETPROP("BUFFERING",3)
			ELSE
				lcBadTables = lcBadTables + lcTable + CHR(13)
				llReturnValue = .F.
				THIS.lError = .F.
			ENDIF
			
			SELECT Tables2Process
		ENDSCAN
		
		
		******************************************************
		* Get rid of temporary table containing tables to process
		******************************************************
		USE IN Tables2Process
		
		SELECT (lcTempLog)
		
		IF !llReturnValue
			lcMsgText = THIS.cMsgBoxText+" Error"+CRLF+CRLF
			lcMsgText = lcMsgText+THIS.cMsgBoxText+" had trouble obtaining the "
			lcMsgText = lcMsgText+"necessary file locks required to process the "
			lcMsgText = lcMsgText+"transaction log. Here are the table(s) causing "
			lcMsgText = lcMsgText+"the problems: "+CRLF+CRLF
			lcMsgText = lcMsgText+lcBadTables+CRLF+CRLF
			lcMsgText = lcMsgText+"Make sure that the above tables are closed "
			lcMsgText = lcMsgText+"prior to attempting to process the log again."
			lcMsgText = lcMsgText+CRLF+CRLF
			lnDialogType = MB_ICONSTOP
			MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
			llReturnValue = .F.
		ENDIF
		
		******************************************************
		* Return .T. if all tables are opened and FLOCKed Ok
		******************************************************
		RETURN(llReturnValue)
		
	ENDPROC

	PROCEDURE genkey		&& Generates next log key value
		******************************************************
		* Method:		GenKey
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Generates the next primary key value for the
		* transaction log.
		*
		* Called from Default Value property in the transaction
		* log table.
		******************************************************
		* Declare LOCAL variables
		LOCAL ;
			lnOldArea, ;
			lnOldDataSession, ;
			liPKey, ;
			lnDotLoc, ;
			lcPKeyTable, ;
			lcPKeyTable
		
		* Grab current work area
		lnOldArea = SELECT()
		lnOldDataSession = SET("DATASESSION")
		
		lcLogTable = THIS.cLogTable
		lcPKeyTable = lcLogTable+"_K.DBF"
		lcPKeyTableStem = JUSTSTEM(lcPKeyTable)
		lcPKeyAlias = THIS.cPKeyAlias
		
		SET DATASESSION TO (THIS.iLogDataSession)
		
		IF USED(lcPKeyAlias)
			SELECT (lcPKeyAlias)
		ELSE
			SELECT 0
			USE (THIS.cPKeyLocation) SHARED
		ENDIF
		
		* Attempt to lock Primary Key record
		IF RECCOUNT() = 0
			APPEND BLANK
			REPLACE iNextKey WITH 0
		ENDIF
		
		DO WHILE !RLOCK()
		ENDDO
		
		* Increment and replace next ID
		liPKey = iNextKey
		REPLACE iNextKey WITH iNextKey + 1
		UNLOCK
		
		* Restore original work area
		SET DATASESSION TO (lnOldDataSession)
		SELECT (lnOldArea)
		
		RETURN (liPKey)
		
	ENDPROC

	PROTECTED PROCEDURE getdbcname		&& Returns the name of the DBC the current cursor is contained in
		******************************************************
		* Method:		GetDBCName
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Returns the full path of the name of the DBC the
		* current table is located in
		******************************************************
		LOCAL ;
			lcDBCName
		
		lcDBCName	= CURSORGETPROP("DATABASE")
		
		RETURN(lcDBCName)
		
	ENDPROC

	PROCEDURE getfoxversion		&& Returns the current VFP version
		******************************************************
		* Method:		GetFoxVersion
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Determines what version of VFP is running
		******************************************************
		LOCAL ;
			lcVersion,;
			lnReturnValue
			
		lcVersion = UPPER(VERSION(1))
		
		DO CASE
			CASE "VISUAL FOXPRO 03" $ lcVersion
				lnReturnValue = 3
		
			CASE "VISUAL FOXPRO 05" $ lcVersion
				lnReturnValue = 5
				
			CASE "VISUAL FOXPRO 06" $ lcVersion
				lnReturnValue = 6
		ENDCASE
		
		RETURN(lnReturnValue)
		
	ENDPROC

	PROCEDURE guiarchivelog
		******************************************************
		* Method:		ArchiveLog
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/26/1999
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Instantiates and displays the Archive form.  In the
		* Destroy of FoxAudit, THIS.oArchiveForm is set to .NULL.
		******************************************************
		THIS.LoadClassLib()
		
		THIS.oArchiveForm = CREATEOBJECT("Archive",THIS)
		
		IF TYPE("THIS.oArchiveForm") == "O" AND !ISNULL(THIS.oArchiveForm)
			THIS.oArchiveForm.SHOW()
		ELSE
			MESSAGEBOX("The Archive form could not be displayed.",0,THIS.cMsgBoxTitle)
		ENDIF
		
		
	ENDPROC

	PROCEDURE guiprocesslog		&& Run the ProcessLog form
		******************************************************
		* Method:		GUIProcessLog
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Load the FoxAudit class library if necessary
		******************************************************
		THIS.LoadClassLib()
		
		THIS.oProcessLogForm = CREATEOBJECT("ProcessLog",THIS)
		
		IF TYPE("THIS.oProcessLogForm") == "O" AND !ISNULL(THIS.oProcessLogForm)
			THIS.oProcessLogForm.SHOW()
		ELSE
			MESSAGEBOX("The Process Log form could not be displayed.",0,THIS.cMsgBoxTitle)
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		******************************************************
		* Method:		Init
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Pass in the name of the audit trail table that updates,
		* inserts and deletes will be logged to. Omit tcLogName
		* and the cDefaultLogLocation property will be used.
		******************************************************
		LPARAMETERS tcLogName
		
		* Declare LOCAL vars
		LOCAL ;
			llReturnValue, ;
			lcLogName, ;
			lnDotLoc, ;
			lcDBCName
		
		THIS.lError = .F.
		llReturnValue = .T.
		
		DO CASE
			CASE NOT EMPTY(tcLogName) AND ATC("\",tcLogName) <> 0
		* If a log name is passed and the path information is included, then
		* just ALLTRIM() any spaces passed and continue
				lcLogName = ALLTRIM(tcLogName)
		
			CASE NOT EMPTY(tcLogName) AND ATC("\",tcLogName) = 0
		* If a log name is passed and the path information is NOT included, then
		* if a table is open in the current work area, use it's path 
				DO CASE
					CASE NOT EMPTY(DBF())
						lcLogName = JustPath(DBF())+"\"+ALLTRIM(tcLogName)
		
		* If a log name is passed and the path information is NOT included then
		* if a table is NOT open in the current work area, use the current drive
		* SYS(3) and the current default directory SYS(2003)
					CASE EMPTY(DBF())
						lcLogName = SYS(5)+SYS(2003)+"\"+ALLTRIM(tcLogName)
		
					OTHERWISE
						llReturnValue = .F.
				ENDCASE
		
			CASE EMPTY(tcLogName) AND NOT EMPTY(THIS.cDefaultLogName)
		* If a log name is NOT passed then use the log specified in the 
		* cDefaultLogLocation property.
				DO CASE
					CASE ATC("\",THIS.cDefaultLogName) = 0
		* Place the transaction log in the default drive & directory
						lcLogName = SYS(5)+SYS(2003)+"\"+ALLTRIM(THIS.cDefaultLogName)
					CASE ATC("\",THIS.cDefaultLogName) <> 0
		* Place the transaction log in the specified location
						lcLogName = ALLTRIM(THIS.cDefaultLogName)
				ENDCASE
		
			OTHERWISE
				llReturnValue = .F.
		ENDCASE
		
		IF ! llReturnValue
			#DEFINE CRLF CHR(13)
			#DEFINE MB_ICONSTOP 32
			LOCAL lcMsgText, lnDialogType, lcMsgTitle
			lcMsgText = THIS.cMsgBoxText+" Error"+CRLF+CRLF
			lcMsgText = lcMsgText + "Unable to determine the log table to use."+CRLF
			lnDialogType = MB_ICONSTOP
			MESSAGEBOX(lcMsgText, lnDialogType,THIS.cMsgBoxTitle)
			RETURN(llReturnValue)
		ENDIF
		
		* Add .DBF to the log name if necessary
		IF ATC(".DBF",lcLogName) = 0
			lcLogName = ALLTRIM(lcLogName)+".DBF"
		ENDIF
		
		* Assign log location to the cLogLocation property
		THIS.cLogLocation = lcLogName
		
		* Determine the Version of VFP running
		THIS.nFoxVersion = THIS.GetFoxVersion()
		
		* Store current data session
		THIS.iLogDataSession = SET("DATASESSION")
		
		DODEFAULT()
		
		******************************************************
		* If the FoxAudit object instantiates without
		* a problem then THIS.OKToInstance will return
		* .T.
		******************************************************
		llReturnValue = THIS.OKToInstance()
		
		******************************************************
		* If llReturnValue = .T. then the FoxAudit object
		* is created.
		******************************************************
		RETURN(llReturnValue)
		
	ENDPROC

	PROCEDURE justdrive
		******************************************************
		* Method:		JustDrive
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Returns the drive for a table - Same as JustPath in
		* Foxtools
		******************************************************
		LPARAMETER ;
			tcTable
		
		LOCAL ;
			lcDrive, ;
			lnLocation
		
		lnLocation = AT(":",tcTable)
		lcDrive = IIF(lnLocation=2,LEFT(tcTable,1),"")
		
		RETURN(lcDrive)
		
	ENDPROC

	PROCEDURE justpath		&& Returns just the path for a file
		******************************************************
		* Method:		JustPath
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Returns the path for a table - Same as JustPath in
		* Foxtools
		******************************************************
		LPARAMETER ;
			tcTable
		LOCAL ;
			lcPath, ;
			lnLength, ;
			i
		
		lnLength = LEN(tcTable)
		
		FOR i = lnLength TO 1 STEP -1
			IF SUBSTR(tcTable,i,1) = "\"
				lcPath = SUBSTR(tcTable,1,(i-1))
				EXIT
			ENDIF
		ENDFOR
		
		RETURN(lcPath)
		
	ENDPROC

	PROCEDURE juststem		&& Retuns just the file name, no extension, no path
		******************************************************
		* Method:		JustStem
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Returns just the name for a table - Same as JustStem
		* in Foxtools
		******************************************************
		LPARAMETER ;
			tcTable
		
		LOCAL ;
			lcTable
		
		IF ":" $ tcTable
			lcTable = SUBSTR(tcTable,ATC(":",tcTable)+1)
		ELSE
			lcTable = ALLTRIM(tcTable)
		ENDIF
		
		DO WHILE ATC("\",lcTable) <> 0
			lcTable = SUBSTR(lcTable,ATC("\",lcTable)+1)
		ENDDO
		
		IF "." $ lcTable
			lcTable = LEFT(lcTable,ATC(".",lcTable)-1)
		ENDIF
		
		RETURN(lcTable)
		
	ENDPROC

	PROTECTED PROCEDURE keytochar		&& Convert Key value to character
		******************************************************
		* Method:		KeyToChar
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Convert the value of the record key to character
		******************************************************
		* Declare LOCAL vars
		******************************************************
		LOCAL ;
			lcKeyType, ;
			llReturnValue
		
		lcKeyType = TYPE("THIS.cKey")
		THIS.cKeyType = lcKeyType
		llReturnValue = .T.
		
		DO CASE
			CASE INLIST(lcKeyType,"N","I","B","Y","F")
				THIS.cKey = ALLTR(STR(THIS.cKey))
			CASE INLIST(lcKeyType,"C","M")
				THIS.cKey = THIS.cKey
			CASE lcKeyType = "D"
				THIS.cKey = DTOC(THIS.cKey)
			CASE lcKeyType = "T"
				THIS.cKey = TTOC(THIS.cKey)
			CASE lcKeyType = "L"
				THIS.cKey = IIF(THIS.cKey,"T","F")
			OTHERWISE
				lcMsgText = THIS.cMsgBoxText+" Transaction Logging Error"+CRLF+CRLF
				lcMsgText = lcMsgText + "FoxAudit does not support keys of type "+lcKeyType+CRLF
				lnDialogType = MB_ICONSTOP
				MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
				llReturnValue = .F.
		ENDCASE
		
		RETURN llReturnValue
		
	ENDPROC

	PROTECTED PROCEDURE loadclasslib		&& Loads the FoxAudit class libary if necessary
		******************************************************
		* Method:		LoadClassLib
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Loads the FoxAudit class library if necessary
		******************************************************
		IF NOT ("FOXAUDIT" $ SET("ClassLib"))
			SET CLASSLIB TO FOXAUDIT ADDITIVE
		ENDIF
	ENDPROC

	PROCEDURE loglocation		&& Returns the full path of the location of the log from the cLogLocation property
		******************************************************
		* Method:	LogLocation
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Returns information about where the transaction log
		* table is located. Calling LogLocation without a 
		* parameter defaults to the LOCATION of the log
		******************************************************
		LPARAMETER tcWhat
		LOCAL ;
			lcWhat, ;
			lcReturnValue
		
		IF EMPTY(tcWhat) OR !INLIST(UPPER(tcWhat),"LOCATION","TABLE","PATH")
			lcWhat = "LOCATION"
		ENDIF
		
		DO CASE
			CASE lcWhat = "LOCATION"
				lcReturnValue = THIS.cLogLocation
		
			CASE lcWhat = "TABLE"
				lcReturnValue = JustStem(THIS.cLogLocation)
		
			CASE lcWhat = "PATH"
				lcReturnValue = JustPath(THIS.cLogLocation)
		ENDCASE
		
		RETURN(lcReturnValue)
		
	ENDPROC

	PROCEDURE logupdates		&& Method called from triggers to update log table
		******************************************************
		* Method:		LogUpdates
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Called in INSERT, DELETE AND UPDATE triggers to log all
		* and any changes made to data
		******************************************************
		* Pass it the record key, the type of transaction, and
		* optionally the Data Session ID and Primary key for
		* the table being logged.
		*
		* Omitting the Primary key will cause FoxAudit to
		* determine the primary key.
		* Transaction Types: I - Insert, U - Update, D - Delete
		******************************************************
		LPARAMETERS ;
			tcKey, ;
			tcTransType, ;
			tiDataSession, ;
			tcIndexTag
		
		LOCAL llReturnValue
		llReturnValue = .T.
		
		******************************************************
		* If a transaction type is not passed in, assume an
		* update.
		******************************************************
		IF EMPTY(tcTransType)
			tcTransType = "U"
		ENDIF
		
		******************************************************
		* Setting the lLogUpdates property to .F. allows the
		* developer to turn off logging at runtime.
		******************************************************
		IF !THIS.lLogUpdates
			RETURN
		ENDIF
		
		******************************************************
		* Store the values passed in
		******************************************************
		THIS.cKey			= tcKey
		THIS.cTransType		= UPPER(tcTransType)
		THIS.iDataSession	= tiDataSession
		THIS.cIndexTag		= IIF(EMPTY(tcIndexTag),"",UPPER(tcIndexTag))
		
		******************************************************
		* Validate parameters passed
		******************************************************
		IF THIS.lValidatePassedParms
			llReturnValue = THIS.ValidateLUParms()
			IF ! llReturnValue
				RETURN(llReturnValue)
			ENDIF
		ENDIF
		
		******************************************************
		* Grab the current work are so it can be reset when
		* processing is complete
		******************************************************
		SET DATASESSION TO (THIS.iDataSession)
		
		THIS.StoreLUEnv()
		THIS.lLUMemos = .F.
		
		******************************************************
		* Hook to place application specific code to run
		* before the log record is generated.  For example,
		* you could set the lLogThem property to .F. in the
		* PreLogUpdateHook method and the insert/update/delete
		* would not be logged.
		* If PreLogUpdateHook RETURNs .F., update is not
		* logged and will cause the trigger to fail.
		******************************************************
		llReturnValue = THIS.PreLogUpdateHook()
		IF ! llReturnValue
			RETURN(llReturnValue)
		ENDIF
		
		******************************************************
		* Assign the Character representation of the key
		* to THIS.cKey for storage in the log table
		******************************************************
		IF !THIS.KeyToChar()
			RETURN(.F.)
		ENDIF
		
		******************************************************
		* Loop through all fields in the updated record
		******************************************************
		THIS.ProcessLUFields()
		
		******************************************************
		* Write the log record for this update
		******************************************************
		THIS.WriteToLog()
		
		******************************************************
		* The PostLogUpdateHook is called just after the
		* update/insert/delete is logged.  A use of this hook
		* may be to determine if a sensitive file has been
		* updated and generating an e-mail message
		******************************************************
		THIS.PostLogUpdateHook()
		
		******************************************************
		* Reset the workarea back to the one that was active
		* when LogUpdates started
		******************************************************
		THIS.RestoreEnv()
		
		RETURN
		
	ENDPROC

	PROCEDURE memolocation		&& Returns the name and location of the memo file
		******************************************************
		* Method:	MemoLocation
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Returns information about where the transaction file
		* that manages memo updates is located
		******************************************************
		LPARAMETER tcWhat
		LOCAL lcWhat, lcReturnValue
		
		IF EMPTY(tcWhat) OR !INLIST(UPPER(tcWhat),"LOCATION","TABLE","PATH")
			lcWhat = "LOCATION"
		ENDIF
		
		DO CASE
			CASE lcWhat = "LOCATION"
				lcReturnValue = THIS.cMemoLocation
		
			CASE lcWhat = "TABLE"
				lcReturnValue = THIS.cMemoTable
		
			CASE lcWhat = "PATH"
				lcReturnValue = THIS.cMemoPath
		ENDCASE
		
		RETURN(lcReturnValue)
		
	ENDPROC

	PROTECTED PROCEDURE oktoinstance		&& If this method returns .T., the class can be instanced.
		******************************************************
		* Method:		OKToInstance
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* If OKToInstance returns .F. to the Init method, the
		* FoxAudit object does not get created
		******************************************************
		******************************************************
		* Does the log file specified in the cLogLocation
		* property exist?
		******************************************************
		LOCAL ;
			lcLogLocation, ;
			lnDotLoc
		
		IF !THIS.lError AND !FILE(THIS.cLogLocation)
		******************************************************
		* Log file doesn't exist...go try to create it.  If it isn't
		* created, THIS.lError will be set to .T.
		******************************************************
			THIS.CreateLogFile()
		ELSE
			lcLogLocation		= THIS.cLogLocation
			lnDotLoc			= ATC(".",lcLogLocation)
			THIS.cLogTable		= JustStem(lcLogLocation)
			THIS.cLogPath		= JustPath(lcLogLocation)
			THIS.cLogAlias		= "FoxAuditLog_"+SYS(2015)
			THIS.cMemoLocation	= LEFT(lcLogLocation,(lnDotLoc-1))+"_M.DBF"
			THIS.cMemoTable		= JustStem(THIS.cMemoLocation)
			THIS.cMemoPath		= JustPath(THIS.cMemoLocation)
			THIS.cMemoAlias		= "FoxAuditMemo_"+SYS(2015)
			THIS.cPKeyLocation	= LEFT(lcLogLocation,(lnDotLoc-1))+"_K.DBF"
			THIS.cPKeyTable		= JustStem(THIS.cPKeyLocation)
			THIS.cPKeyPath		= JustPath(THIS.cPKeyLocation)
			THIS.cPKeyAlias		= JustStem(THIS.cPKeyLocation)
			
			
			THIS.CloseLogTables()
			THIS.OpenLogTables()
			
		ENDIF
		
		******************************************************************
		* If an error occured while trying to create the log file then
		* THIS.lError would be set to .T. in the Error method
		******************************************************************
		RETURN(!THIS.lError)
		
	ENDPROC

	PROCEDURE openlogtables		&& Opens the log and memo tables
		******************************************************
		* Method:		OpenLogTables
		******************************************************
		* Author:		Jim Duffy
		* Date:			8/22/1999
		* Copyright:	1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Opens the transaction log tables
		******************************************************
		LPARAMETER tlExclusive
		
		LOCAL lnDataSession
		lcLogAlias = THIS.cLogAlias
		lcLogTable = THIS.cLogTable
		lcLogLocation = THIS.cLogLocation
		lcMemoAlias = THIS.cMemoAlias
		lcMemoTable = THIS.cMemoTable
		lcMemoLocation = THIS.cMemoLocation
		lcPKeyAlias = THIS.cPKeyAlias
		lcPKeyLocation = THIS.cPKeyLocation
		
		lnDataSession = SET("DATASESSION")
		lcAccessMethod = IIF(tlExclusive,"EXCLUSIVE","SHARED")
		
		liLogDataSession = THIS.iLogDataSession
		IF liLogDataSession <> 0
			SET DATASESSION TO (THIS.iLogDataSession)
		ELSE
			SET DATASESSION TO 1
		ENDIF
		
		IF USED('appdata_log')
		   USE IN appdata_log
		ENDIF
		IF USED('appdata_log_m')
		   USE IN appdata_log_m
		ENDIF
		IF USED('appdata_log_k')
		   USE IN appdata_log_k
		ENDIF 
		
		IF NOT FILE(lcLogLocation)
		   this.createlogfile()
		ENDIF
		IF NOT FILE(lcMemoLocation)
		   this.createlogfile()
		ENDIF
		
		llNeedToOpenLog = .F.
		IF USED(lcLogAlias)
			SELECT (lcLogAlias)
			IF tlExclusive and NOT ISEXCLUSIVE()
				USE
				llNeedToOpenLog = .T.
			ENDIF
		
			IF NOT tlExclusive AND ISEXCLUSIVE()
				USE
				llNeedToOpenLog = .T.
			ENDIF
		ELSE
			llNeedToOpenLog = .T.
		ENDIF
		
		llNeedToOpenMemo = .F.
		IF USED(lcMemoAlias)
			SELECT (lcMemoAlias)
			IF tlExclusive and NOT ISEXCLUSIVE()
				USE
				llNeedToOpenMemo = .F.
			ENDIF
		
			IF NOT tlExclusive AND ISEXCLUSIVE()
				USE
				llNeedToOpenMemo = .F.
			ENDIF
		ELSE
			llNeedToOpenMemo = .T.
		ENDIF
		
		llNeedToOpenPKey = .F.
		IF USED(lcPKeyAlias)
			llNeedToOpenPKey = .F.
		ELSE
			llNeedToOpenPKey = .T.
		ENDIF
		
		
		IF llNeedToOpenLog 
			lcCmd = "USE (lcLogLocation) ALIAS (lcLogAlias) IN 0 "+lcAccessMethod
			&lcCmd.
		ENDIF
		
		IF llNeedToOpenMemo
			lcCmd = "USE (lcMemoLocation) ALIAS (lcMemoAlias) IN 0 "+lcAccessMethod
			&lcCmd.
		ENDIF
		
		IF llNeedToOpenPKey
			lcCmd = "USE (lcPKeyLocation) ALIAS (lcPKeyAlias) IN 0 SHARED"
			&lcCmd.
		ENDIF
		
	ENDPROC

	PROCEDURE pkeylocation
		******************************************************
		* Method:	PKeyLocation
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Returns information about where the primary key file
		* is located
		******************************************************
		LPARAMETER tcWhat
		LOCAL lcWhat, lcReturnValue
		
		IF EMPTY(tcWhat) OR !INLIST(UPPER(tcWhat),"LOCATION","TABLE","PATH")
			lcWhat = "LOCATION"
		ENDIF
		
		DO CASE
			CASE lcWhat = "LOCATION"
				lcReturnValue = THIS.cPKeyLocation
		
			CASE lcWhat = "TABLE"
				lcReturnValue = THIS.cPKeyTable
		
			CASE lcWhat = "PATH"
				lcReturnValue = THIS.cPKeyPath
		ENDCASE
		
		RETURN(lcReturnValue)
		
	ENDPROC

	PROTECTED PROCEDURE postlogupdatehook		&& Automatically run after update is logged
		******************************************************
		* Method:		PostLogUpdateHook
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Place code here to be run AFTER the update is logged. 
		******************************************************
		
	ENDPROC

	PROTECTED PROCEDURE prelogupdatehook		&& Automatically run before record is logged.
		******************************************************
		* Method:		PreLogUpdateHook
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Place code here to be run BEFORE the updates are 
		* logged.  Returning .F. from this method will cause
		* the logupdates method to RETURN .F. as well.  That
		* would cause the trigger to fail, thus the entire update
		* to fail.
		******************************************************
		
	ENDPROC

	PROTECTED PROCEDURE processdelete
		******************************************************
		* Method: ProcessDelete
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Process a logged Delete by seeking the record and
		* RECALLing it.  If the record doesn't exist anymore
		* in the original table (maybe it was PACKed), since
		* every logged Delete captures each field and the value
		* stored in them, we'll just add a new record and
		* restore the logged values.
		******************************************************
		LOCAL lcRestoreTable
		
		lcRestoreTable = THIS.cRestoreTableName
		
		SELECT (lcRestoreTable)
		IF SEEK(THIS.xRestoreKey,lcRestoreTable,THIS.cIndexTag)
			RECALL
		ELSE
			INSERT INTO (lcRestoreTable) FROM MEMVAR	&& Blanks
			THIS.RestoreFields()
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE processinsert
		******************************************************
		* Method:		ProcessInsert
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Since an insert is being reversed, find the record
		* that was inserted and mark it deleted.
		******************************************************
		LOCAL lcRestoreTable
		
		lcRestoreTable = THIS.cRestoreTableName
		
		SELECT (lcRestoreTable)
		IF SEEK(THIS.xRestoreKey,lcRestoreTable,THIS.cIndexTag)
			DELETE
		ENDIF
		
	ENDPROC

	PROCEDURE processlog		&& Method used to rollback or rollforward transactions
		******************************************************
		* Method:		ProcessLog
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		******************************************************
		* Since this method is updating/inserting/deleteing records
		* in the database, keep in mind that any changes will be
		* logged.  Luckliy, the lLogUpdates property is evaluated
		* in the LogUpdates method just before a audit record is
		* generated.  If lLogUpdates = .F. then the rollback update
		* is not logged.
		******************************************************
		LPARAMETERS ;
			tcProcess, ;
			tcLogTable, ;
			ttRestoreToDate, ;
			tlDisregardWarning, ;
			tlLogChanges
		
		* Declare LOCAL vars
		LOCAL ;
			lOldLogUpdates, ;
			llReturnValue, ;
			llContinue, ;
			lcMsgText, ;
			lnDialogType, ;
			lcPrevMultiLocks
		
		THIS.cCurrentProcess 	= UPPER(tcProcess)
		THIS.cLogTable			= JUSTSTEM(tcLogTable)
		THIS.tRestoreToDateTime	= ttRestoreToDate
		
		*********************************************************
		* Grab the lLogUpdates property value so we can restore
		* it when we leave
		*********************************************************
		lOldLogUpdates				= THIS.lLogUpdates
		THIS.lLogUpdates			= tlLogChanges
		
		*********************************************************
		* Grab the MultiLocks setting so we can restore
		* it when we finish processing the log
		*********************************************************
		lcPrevMultiLocks		= SET("MULTILOCKS")
		SET MULTILOCKS ON
		
		*********************************************************
		* Validate the paramaters being passed in
		*********************************************************
		llReturnValue = THIS.ValidateRestoreParms()
		IF ! llReturnValue
			RETURN
		ENDIF
		
		*********************************************************
		* Display the Warning messages?
		*********************************************************
		llContinue = .T.
		IF !tlDisregardWarning
			llContinue = THIS.DisplayWarning()
		ENDIF
		
		IF ! llContinue
			RETURN
		ENDIF
		
		*******************************************************
		* Build temporary cursor of all records to be processed
		* based on the datetime passed
		*******************************************************
		IF llReturnValue
			llReturnValue = THIS.BuildRestoreCursor()
		ENDIF
		
		*******************************************************
		* Open and try to FLOCK() each table to be processed
		*******************************************************
		IF llReturnValue
			llReturnValue = THIS.FlockTables()
		ENDIF
		
		*******************************************************
		* Process each record in the temporary cursor
		*******************************************************
		IF llReturnValue
			THIS.ProcessRestoreCursor()
		
			IF THIS.lError
				#DEFINE MB_ICONSTOP 32
				lcMsgText = THIS.cMsgBoxText+" Information"+CRLF+CRLF
				lcMsgText = lcMsgText+"WARNING! An error occured during transaction log processing "
				lcMsgText = lcMsgText+"that left the transaction log partially processed. The application data "
				lcMsgText = lcMsgText+"is in an incomplete state. Restore your latest backup immediately!"
				lcMsgText = lcMsgText+CRLF+CRLF
				lnDialogType = MB_ICONSTOP
				MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
			ENDIF
		ENDIF
		
		*******************************************************
		* Close processing tables
		*******************************************************
		THIS.CloseTables()
		
		*******************************************************
		* Restore the lLogUpdates property
		*******************************************************
		THIS.lLogUpdates = lOldLogUpdates
		
		*******************************************************
		* Reset the cCurrentProcess and cTempLog properties
		*******************************************************
		THIS.cCurrentProcess	= ""
		THIS.cTempLog			= ""
		
		*******************************************************
		* Display status message
		*******************************************************
		IF llReturnValue AND !THIS.lError
			lcMsgText = "Log processing complete."
			lnDialogType = MB_ICONINFORMATION
		ELSE
			lcMsgText = "Log processing terminated. The log WAS NOT processed."
			lnDialogType = MB_ICONSTOP
		ENDIF
		
		MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
		
		*********************************************************
		* Restore the MultiLocks setting
		*********************************************************
		SET MULTILOCKS &lcPrevMultiLocks.
		
		RETURN
		
	ENDPROC

	PROTECTED PROCEDURE processlufields
		******************************************************
		* Method:		ProcessLUFields
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Process LogUpdates Fields
		******************************************************
		LOCAL ;
			lcSeparator, ;
			lcTransType, ;
			lcChanges, ;
			lcField, ;
			lxCurFieldValue, ;
			lxOldFieldValue, ;
			lcDataType, ;
			lcOldFieldValue, ;
			lcCurFieldValue, ;
			liWidth, ;
			liDecimal, ;
			lcChanges, ;
			liElement, ;
			liRow, ;
			lnLength, ;
			i, ;
			j
		
		lcSeparator = THIS.cSeparator
		lcTransType = THIS.cTransType
		lcChanges = ""
		lcOldFieldValue = ""
		
		FOR i = 1 TO FCOUNT()
			lcField = ALLTRIM(FIELD(i))
			* With Deletes and Inserts we'll process and store the value
			* in all fields.  The are two reasons for doing that with Inserts
			* 	1.	Capture the DefaultValues first stored to the new record
			*	2.	RECALLing a record fires the Insert trigger and we want to
			* 		grab all the data RECALLed.
			*
			* Updates are much more straight forward.  In the updated record each
			* field is checked to see if it has been updated with GETFLDSTATE().
			* If it has, a line is added to the mUpd_Action memo field and the
			* field name, pre-updated value and updated values, separated by a
			* character separator (cSeparator property), are stored there.
			IF TYPE("EVAL(lcField)") = "G" && Skip General Fields
				LOOP
			ENDIF
		
			IF (lcTransType = "D" OR ;
				lcTransType = "I" OR ;
				(GETFLDSTATE(lcField) <> 1 AND lcTransType = "U"))
		
				* If field is a memo field process differently
				IF TYPE("EVAL(lcField)") = "M"
					THIS.ProcessLUMemos(i,lcTransType)
		
					lcChanges	=	lcChanges+"M"+lcSeparator+;
						lcField+lcSeparator+;
						"Memo"+lcSeparator+;
						"Memo"+lcSeparator+CHR(13)
		
				ELSE
					* Process non-memo fields
					lxCurFieldValue=EVAL(lcField)
					lxOldFieldValue=OLDVAL(lcField)
		
					* JMD - 10/30/1998 - Per Doug Hennig
					* If they edit a field and change it to what it was before 
					* they changed it, a log record should not be generated
					IF lcTransType = "U" AND lxCurFieldValue = lxOldFieldValue
						LOOP
					ENDIF
		
					* Build array
					* JMD - 10/19/1998
					* Added 2nd array and copy first two columns code due to
					* the fact that the long table name shows up in a column in row 1.
					* What if a colunm and the long name are the same? It would
					* ASCAN and find the table name first.
					RELEASE laFields
					
					AFIELDS(laTempFields)
					lnLength=ALEN(laTempFields,1)
		
					DIMENSION laFields[lnLength,2]
					FOR j = 1 TO lnLength
						laFields[j,1] = laTempFields[j,1]	&& Field Name
						laFields[j,2] = laTempFields[j,2]	&& Data Type
					ENDFOR
		
					RELEASE j, laTempFields
		
					* Find current field in array
					* JMD 10/16/1998
					* Added EXACT ON because searching for a field
					* named CREATEDBY would return the element for
					* a field named CREATED
					lcExact = SET("EXACT")
					SET EXACT ON
					liElement = ASCAN(laFields,lcField)
					SET EXACT &lcExact.
		
					* Get row subscript
					liRow = ASUBSCRIPT(laFields,liElement,1)
		
					* 2nd column is data type
					lcDataType = laFields[liRow,2]
		
					DO CASE
						*************************************************
						* Process Character fields
						*************************************************
						CASE INLIST(lcDataType,"C","V")
							lcOldFieldValue = IIF(ISNULL(lxOldFieldValue),"",;
								lxOldFieldValue)
		
							lcCurFieldValue = IIF(;
								lcTransType="D","",;
								IIF(ISNULL(lxCurFieldValue),".NULL.",;
									lxCurFieldValue))
		
						*************************************************
						* Process Date fields
						*************************************************
						CASE lcDataType = "D"
							lcOldFieldValue = IIF(ISNULL(lxOldFieldValue),"",;
								ALLTRIM(DTOS(lxOldFieldValue)))
		
							lcCurFieldValue = IIF(;
								lcTransType="D","",;
								IIF(ISNULL(lxCurFieldValue),".NULL.",;
									ALLTRIM(DTOS(lxCurFieldValue))))
		
						*************************************************
						* Process DateTime fields
						*************************************************
						CASE lcDataType = "T"
							lcOldFieldValue = IIF(ISNULL(lxOldFieldValue),"",;
								ALLTRIM(TTOC(lxOldFieldValue,1)))
		
							lcCurFieldValue = IIF(;
								lcTransType="D","",;
								IIF(ISNULL(lxCurFieldValue),".NULL.",;
									ALLTRIM(TTOC(lxCurFieldValue,1))))
		
						*************************************************
						* 5/24/ Process Integer fields
						*************************************************
						CASE lcDataType = "I"
		
							lcOldFieldValue = IIF(ISNULL(lxOldFieldValue),"",;
								ALLTRIM(PADR(lxOldFieldValue,10)))
		
							lcCurFieldValue = IIF(;
								lcTransType="D","",;
								IIF(ISNULL(lxCurFieldValue),".NULL.",;
									ALLTRIM(PADR(lxCurFieldValue,10))))
		
						*************************************************
						* Process Numeric,Currency fields
						* Use AFIELDS() to determine the width and decimal places
						*************************************************
						CASE INLIST(lcDataType,"N","Y","B","F" )
		
							=AFIELDS(laFields)
							liWidth	= laFields(i,3)
							liDecimal	= laFields(i,4)
		
							lcOldFieldValue = IIF(ISNULL(lxOldFieldValue),"",;
								ALLTRIM(STR(lxOldFieldValue,liWidth,liDecimal)))
		
		*						ALLTRIM(PADR(lxOldFieldValue,15)))
		
							lcCurFieldValue = IIF(;
								lcTransType="D","",;
								IIF(ISNULL(lxCurFieldValue),".NULL.",;
									ALLTRIM(STR(lxCurFieldValue,liWidth,liDecimal))))
		
						*************************************************
						* Process Logical fields
						*************************************************
						CASE lcDataType = "L"
							lcOldFieldValue = IIF(ISNULL(lxOldFieldValue),"",;
								IIF(lxOldFieldValue,'True','False'))
		
							lcCurFieldValue = IIF(;
								lcTransType="D","",;
								IIF(ISNULL(lxCurFieldValue),".NULL.",;
									IIF(lxCurFieldValue,'True','False')))
		
		
					ENDCASE
		
					*************************************************************
					* Create character field to store in the mUpd_Action field
					* in the specified log table
					*************************************************************
					lcChanges =	lcChanges+lcDataType+lcSeparator+;
						lcField+lcSeparator+;
						lcOldFieldValue+lcSeparator+;
						lcCurFieldValue+lcSeparator+CHR(13)
				ENDIF
			ENDIF
		ENDFOR
		
		* Store changes to property to be used on INSERT into
		* transaction log in the WriteLog method
		THIS.cChanges = lcChanges
		
	ENDPROC

	PROCEDURE processlumemos
		******************************************************
		* Method:		ProcessLUMemos
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Process LogUpdate Memos
		* Parameters passed in are the field number and the 
		* transaction type taking place 
		******************************************************
		LPARAMETERS ;
			tnI, ;
			tcTransType
		
		* Declare LOCAL vars
		LOCAL ;
			lcField, ;
			lnOldArea, ;
			lcOldFieldValue, ;
			lcCurFieldValue
		
		* Grab current work area
		lnOldArea = SELECT()
		
		* If temporary memo cursor doesn't exist create it
		IF !USED("FA_TempMemos")
			CREATE CURSOR FA_TempMemos ;
				(cField c(THIS.iDefFieldLength), ;
				mOrig m, ;
				mUpdated m)
		ENDIF
		
		SELECT (lnOldArea)
		
		* Get current field name
		lcField = FIELD(tnI)
		
		* Grab OLDVAL() and current value
		lcOldFieldValue = IIF(ISNULL(OLDVAL(lcField)),"",OLDVAL(lcField))
		lcCurFieldValue = IIF(tcTransType="D","",IIF(ISNULL(EVAL(lcField)),".NULL.",EVAL(lcField)))
		
		SELECT FA_TempMemos
		
		* Write to transaction memo table
		INSERT INTO FA_TempMemos ( ;
			cField, ;
			mOrig, ;
			mUpdated) ;
			VALUES (;
				lcField, ;
				lcOldFieldValue, ;
				lcCurFieldValue)
		
		THIS.lLUMemos = .T.
		
		SELECT (lnOldArea)
		RETURN
		
	ENDPROC

	PROTECTED PROCEDURE processrestorecursor
		******************************************************
		* Method:		ProcessRestoreCursor
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* This method cycles through the records in the
		* temporary cursor that contains all the logged
		* transactions to be processed
		******************************************************
		LOCAL ;
			lcDeleted, ;
			lnRecCount, ;
			loThermometer, ;
			lcMsg, ;
			lcAction, ;
			lnPosition, ;
			lnPctComplete
		
		lcAction = THIS.cCurrentProcess	&& grab process flag
		lcDeleted = SET("DELETED")
		SET DELETED OFF
		
		loThermometer = THIS.BuildThermometer()
		
		lcMsg = IIF(UPPER(lcAction) = "RB",;
			"Rolling Back Updates To: "+TTOC(THIS.tRestoreToDateTime), ;
			"Rolling Forward Updates From: "+TTOC(THIS.tRestoreToDateTime))
		loThermometer.UpdateBar(0,lcMsg)
		loThermometer.SHOW()
		
		lnRecCount = RECCOUNT()
		
		DO CASE
			CASE UPPER(lcAction) = "RB"
				GO BOTTOM
			CASE UPPER(lcAction) = "RF"
				GO TOP
		ENDCASE
		
		THIS.lRestoreOK = .T.
		
		DO WHILE !BOF() AND !EOF() AND ;
			THIS.lRestoreOK AND !THIS.lError
		******************************************************
		* Determine the record key
		******************************************************
			THIS.ConvertRestoreKey()
		
			THIS.cRestoreTrgType	= cTran_Type
		
			THIS.cRestoreTableName	= ALLTRIM(cTbl_Name)
			THIS.cIndexTag			= ALLTRIM(cTag_Name)
		
		******************************************************
		* Open or SELECT the table that contains the record
		* to be reversed
		******************************************************
			SELECT (THIS.cRestoreTableName)
		
			DO CASE
		******************************************************
		* If Rolling the log back, process a logged Insert 
		* by seeking the record and DELETEing it.  That's what
		* the ProcessInsert method does.
		*
		* If Rolling the log forward, process a logged Insert 
		* by APPENDing the record. That's what the ProcessDelete
		* method does.
		******************************************************
				CASE THIS.cRestoreTrgType = "I"
		
					DO CASE
						CASE UPPER(lcAction) = "RB"
							THIS.ProcessInsert()
						CASE UPPER(lcAction) = "RF"
							THIS.ProcessDelete()
					ENDCASE
		
		******************************************************
		* If Rolling the log back, process a logged Delete 
		* by seeking the record and RECALLing it.  That's what
		* the ProcessDelete method does. If the record doesn't 
		* exist anymore in the original table (maybe it was 
		* PACKed), since every logged Delete captures each 
		* field and the value stored in them, FoxAudit will 
		* add a new record and restore the logged values.
		*
		* If Rolling the log forward, process a logged Delete 
		* by DELETINGing the record. That's what the ProcessInsert
		* method does.
		******************************************************
				CASE THIS.cRestoreTrgType = "D"
					DO CASE
						CASE UPPER(lcAction) = "RB"
							THIS.ProcessDelete()
						CASE UPPER(lcAction) = "RF"
							THIS.ProcessInsert()
					ENDCASE
		
		******************************************************
		* If Rolling the log back, process a logged Update 
		* by seeking the record and modifying it.  That's what
		* the ProcessUpdate method does.
		*
		* If Rolling the log forward, process a logged Update 
		* by seeking the record and modifying it.  That's what
		* the ProcessUpdate method does.
		*
		* Although the CASE statement will always evaluate
		* to running the ProcessUpdate method, breaking out 
		* the 'RB' and 'RF' decision strucutre makes it
		* look consistent with Inserts and Deletes.
		******************************************************
				CASE THIS.cRestoreTrgType = "U"
					DO CASE
						CASE UPPER(lcAction) = "RB"
							THIS.ProcessUpdate()
						CASE UPPER(lcAction) = "RF"
							THIS.ProcessUpdate()
					ENDCASE
		
			ENDCASE
		
			IF !THIS.lError
				THIS.lRestoreOK = THIS.Committ()
			ENDIF
		
		******************************************************
		* Update the thermometer and based on the type of
		* process, skip forward or backward through the log
		******************************************************
			SELECT (THIS.cTempLog)
		
			lnPosition = IIF(UPPER(lcAction)="RB", ;
				(lnRecCount - RECNO()), ;
				RECNO())
			lnPcntComplete = ((lnPosition/lnRecCount)*100)
			loThermometer.UpdateBar(lnPcntComplete)
		
		******************************************************
		* If the log is being rolled back (RB), FoxAudit will
		* traverse the log in reverse (SKIP -1).  If the log
		* is being rolled forward (RF), FoxAudit will traverse
		* the log normally (SKIP).
		******************************************************
			DO CASE
				CASE UPPER(lcAction) = "RB"
					SKIP -1
				CASE UPPER(lcAction) = "RF"
					SKIP
			ENDCASE
		
		ENDDO
		
		******************************************************
		* Reset the Record pointer to get last update to 
		* committ. Without the GO BOTTOM, the last record does 
		* not committ.
		******************************************************
		GO BOTTOM
		
		SET DELETED &lcDeleted.
		RELEASE loThermometer
		
	ENDPROC

	PROTECTED PROCEDURE processupdate
		*******************************************************
		* Method:		ProcessUpdate
		*******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Process a logged Update by seeking the record and
		* restoring the logged values.
		*******************************************************
		LOCAL lcRestoreTable
		
		lcRestoreTable = THIS.cRestoreTableName
		
		SELECT (lcRestoreTable)
		IF SEEK(THIS.xRestoreKey,lcRestoreTable,THIS.cIndexTag)
			THIS.RestoreFields()
		ELSE
			THIS.ProcessDelete()
		ENDIF
		
		
	ENDPROC

	PROCEDURE readme		&& FoxAudit usage information
		***************************************************
		* Method:		ReadMe
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Information about setting up and calling FoxAudit
		
		***************************************************
		* Preparing to Call FoxAudit
		***************************************************
		* Before your application can begin to log or reverse transactions,
		* a FoxAudit object needs to be instantiated first. This
		* is done by issuing CREATEOBJECT() and specifying
		* FoxAudit as the class of object to be created. When 
		* the FoxAudit object is created the location of the log
		* file is also passed to the CREATEOBJECT() function. If the
		* location of the log table is omitted, then the table name
		* specified in the cDefaultLogLocation property is used. 
		* The default value for cDefaultLogLocation is FA_LOG. 
		
		* The following code segment builds the oFoxAudit object.
		
		* SET CLASSLIB TO FoxAudit
		* PUBLIC oFoxAudit
		* lcLogLocation = "C:\FOXAUDIT6\MYLOG.DBF"
		* oFoxAudit = CREATEOBJECT("FOXAUDIT",lcLogLocation)
		
		* The following lines could be used to insure the oFoxAudit was
		* created correctly.
		
		* IF TYPE("oFoxAudit")=="O" AND !ISNULL("oFoxAudit")
		* 	WAIT WINDOW "Created!"
		*   oFoxAudit.cUserID = oApp.cUserID	&& Assign current user
		* ELSE
		* 	WAIT WINDOW "Not Created!"
		* ENDIF
		
		* Why check to see if it was created correctly? Why wouldn't it be?  
		* Maybe Visual FoxPro couldn't find the FoxAudit class library specified 
		* in the SET CLASSLIB TO command. Also, when an attempt is made 
		* to create a FoxAudit object, a method called OKToInstance is run to 
		* to determine if the specified log table exists.  If the table doesn't exist 
		* FoxAudit will attempt to create it.  If all goes well OkToInstance returns
		* .T. and the object is created.
		
		***************************************************
		* Logging Transactions With FoxAudit
		***************************************************
		* Logging transactions is accomplished by running the FoxAudit stored
		* procedure. FoxAudit is called in the triggers of each of the
		* tables you want to log transactions for.  
		
		***************************************************
		* The Transaction Log Structure
		***************************************************
		* cTran_Type	Trans Type:		Insert (I), Update (U), Delete (D)
		* cDBC_Drive	DBC Drive:		Drive DBC is located on
		* cDBC_Path		DBC Path:		DBC Path
		* cDBC_Name		DBC Name:		DBC name
		* cTbl_Drive	Table Drive:	Drive Table is located on
		* cTbl_Path		Table Path:		Table path
		* cTbl_Name		Table Name:		Table name 
		* cTag_Name		Tag Name:		Tag to use when seeking the key record
		* cKey_Type		DataType:		Datatype of the key field
		* cRec_key		Record Key:		Unique value for this record
		* mActions		Actions:		The changes made to the record
		* cUserMsg1		Message:		Assigned at runtime to document transaction
		* cUserMsg2		Message:		Assigned at runtime to document transaction
		* tUpd_Who		Who:			User ID who made changes
		* tUpd_When		When:			Update timestamp
		******************************************************************
		
		***************************************************
		* Processing Transactions With ProcessLog
		***************************************************
		* Before we get into the semantics of rolling back or rolling forward
		* a transaction log, let's take a look at why you would want to do
		* either of these things.
		
		* Rolling back the transaction log allows you to work with your data 
		* as it appeared on a specific date and time in history.  Running reports
		* would be a common reason to rollback logged transactions.
		
		* A common reason for rolling forward the transaction log would be if
		* you had to restore a backup tape due to table corruption or something.
		* You could roll forward all the log entries from the date and time the
		* backup was done to avoid having to rekey all do the data entry that
		* was lost.
		
		* Rolling back or rolling forward logged transactions is accomplished 
		* by running the ProcessLog method of the oFoxAudit object. 
		* The changes made by ProcessLog can be minor or they can be quite 
		* extensive. It is HIGHLY RECOMMENDED that a backup is done 
		* BEFORE the ProcessLog method is run.
		
		* ProcessLog Syntax
		
		* ProcessLog(cProcess,cLogName,tRestoreToDate,[lDisplayWarning],[lLogChanges])
		
		* The cProcess parameter specifies what action should be taken. "RB" for
		* roll back and "RF" for roll forward.
		
		* The tRestoreToDate parameter specifies the date or datetime value that 
		* the log table is reversed to. If a Date data type is passed, it is converted
		* to a DateTime format with 12:00:00am as the time.
		
		* The lDisregardWarning parameter specifies if a warning dialog should be displayed
		* before the reversing entries are made. If omitted, lDisregardWarning defaults to .F.
		
		* The lLogChanges parameter specifies if the reversing entries should be logged. If .T.
		* all reversing entries will generate a record in the log table.  If omitted, lLogChanges 
		* defaults to .F.
		
		* Samples
		
		* The following sample will roll back all entries in the FALOG table back to 12/31/97
		* at 8:00am without logging the reversing entires. A warning dialog will be displayed.
		
		* oFoxAudit.ProcessLog("RB","FALOG",{12/31/97 8:00:00am},.F.,.F.)
		
		* The following sample will rollback all entries in the FALOG table back to 12/31/97
		* at 8:00am. All reversing entries will be logged but no warning message will be 
		* displayed.
		
		* oFoxAudit.ProcessLog("RB","FALOG",{12/31/97 8:00:00am},.T.,.T.)
		
		* Remarks
		
		* The time it takes to process entries depends on how far back in time entires
		* are being processed and how many records are being processed.  In an intensive
		* data entry application the log file could grow quite large fairly quickly.  Processing
		* entires in that situation could take some time. 
		
		* Due to the extensive changes made by ProcessLog, EXCLUSIVE use of all
		* tables is required.  Processing entries is not something you want to do in the
		* middle of the day while extensive date entry is being done.
		
		* Also, for obvious reasons, you cannot roll back entries back to before FoxAudit was
		* implemented. Those entries would not be in the log table.
		
		
	ENDPROC

	PROTECTED PROCEDURE realctot
		******************************************************
		* Method:		RealCTOT
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Converts a TTOC(x,1) string 19980328045002 into a
		* DateTime format.  CTOT() doesn't convert a string
		* in that format. CTOT only works with specific char
		* formats. YYYYMMDDHHMMSS isn't one of them.
		******************************************************
		LPARAMETERS ;
			tcDateTime
		
		LOCAL ;
			lcDate, ;
			lcTime, ;
			lnDay, ;
			lnMonth, ;
			lnYear, ;
			lnHour, ;
			lnMinute, ;
			lnSecond, ;
			ltDateTime
		
		DO CASE
		
		* This section of code included for backward compatibility
		* with VFP 3 & 5.  It WILL cause a STRICTDATE warning to appear
		* when compiled in VFP 6.0.  Comment out the
		*
		* ltDateTime = CTOT(lcDate+" "+lcTime)
		*
		* line to avoid the STRICTDATE warnings
			CASE INLIST(THIS.nFoxVersion,3,5)
				lcDate	=	SUBSTR(tcDateTime,5,2)+"/"+;
							SUBSTR(tcDateTime,7,2)+;
							"/"+LEFT(tcDateTime,4)
				lcTime	=	SUBSTR(tcDateTime,9,2)+":"+;
							SUBSTR(tcDateTime,11,2)+;
							":"+SUBSTR(tcDateTime,13,2)
		
				lcCmd	=	"ltDateTime = CTOT(lcDate+[ ]+lcTime)"
				&lcCmd.
			
		* Support for SET STRICTDATE TO 2 in VFP 6.0 for Y2K compatibility
			OTHERWISE
				lnDay		= VAL(SUBSTR(tcDateTime,7,2))
				lnMonth		= VAL(SUBSTR(tcDateTime,5,2))
				lnYear		= VAL(LEFT(tcDateTime,4))
				lnHour		= VAL(SUBSTR(tcDateTime,9,2))
				lnMinute	= VAL(SUBSTR(tcDateTime,11,2))
				lnSecond	= VAL(SUBSTR(tcDateTime,13,2))
		
				ltDateTime = DATETIME(lnYear, lnMonth, lnDay, lnHour, lnMinute, lnSecond)
				
		ENDCASE
		
		RETURN(ltDateTime)
		
	ENDPROC

	PROTECTED PROCEDURE restoreenv		&& Restore to environment
		******************************************************
		* Method:		RestoreEnv
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Restore the work area back to that way it was
		* when the LogUpdates method was run
		******************************************************
		LOCAL lcFullPath
		lcFullPath = THIS.cSetFullPath
		SET FULLPATH &lcFullPath.
		
		IF NOT THIS.lLockLogsOpen
			* Close the transaction log table
			IF USED(THIS.cLogAlias)
				USE IN (THIS.cLogAlias)
			ENDIF
		
			* Close the transaction memo table
			IF USED(THIS.cMemoAlias)
				USE IN (THIS.cMemoAlias)
			ENDIF
		
			* Close the transaction primary key table
			IF USED(THIS.cPKeyAlias)
				USE IN (THIS.cPKeyAlias)
			ENDIF
		
			* Close the temporary memo table
			IF USED("FA_TempMemos")
				USE IN FA_TempMemos
			ENDIF
		ENDIF
		
		
		SELECT (THIS.nArea)
		
		* Added for Mere Mortals
		SET DATASESSION TO
	ENDPROC

	PROTECTED PROCEDURE restorefields		&& Works through each field in the mActions field and rollbacks the data to it's preupdated state.
		******************************************************
		* Method:		RestoreFields
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		LOCAL ;
			i, ;
			lcSeparator, ;
			lnSepLoc1, ;
			lnSepLoc2, ;
			lnSepLoc3, ;
			lcAction, ;
			lcField, ;
			lcDataType, ;
			lcUpdated, ;
			lxUpdated, ;
			lcOrig, ;
			lxOrig, ;
			liLog_Key, ;
			lmActions, ;
			lnLines, ;
			lcLine, ;
			lcCurrentProcess, ;
			lcPrevMemoWidth
		
		lcPrevMemoWidth = SET("MEMOWIDTH")
		SET MEMOWIDTH TO 500
		*******************************************************
		* Grab current process - RB or RF
		*******************************************************
		lcCurrentProcess = THIS.cCurrentProcess
		
		*******************************************************
		* Character used as the field/value separator
		*******************************************************
		lcSeparator = THIS.cSeparator
		
		*******************************************************
		* Location of the first separator
		*******************************************************
		lnSepLoc1 = 2
		
		*******************************************************
		* Capture the contents of the mAction memo field to
		* the lmActions variable
		*******************************************************
		lmActions	= EVAL(THIS.cTempLog+".mActions")
		
		*******************************************************
		* Grab the Key value for the current log record
		*******************************************************
		liLog_Key	= EVAL(THIS.cTempLog+".iLog_Key")
		
		*******************************************************
		* Determine how many lines there are in the mActions
		* memo field (ie how many fields need to be updated)
		*******************************************************
		lnLines = MEMLINES(lmActions)
		
		*******************************************************
		* Loop through each line
		*******************************************************
		FOR i = 1 TO lnLines
		
		****************************************************
		* Grab the line i and store it in lcLine
		****************************************************
			lcLine = MLINE(lmActions, i)
			IF EMPTY(lcLine)
				RETURN
			ENDIF
		
		****************************************************
		* Determine location of the field value separators
		****************************************************
			lnSepLoc2 = ATC(lcSeparator,SUBSTR(lcLine,(lnSepLoc1+1))) + lnSepLoc1
			lnSepLoc3 = ATC(lcSeparator,SUBSTR(lcLine,(lnSepLoc2+1))) + lnSepLoc2
			lnSepLoc4 = LEN(lcLine)
		
		****************************************************
		* Date type of field being rolledback
		****************************************************
			lcDataType = LEFT(lcLine,1)
		
		****************************************************
		* Field name of field being rolledback
		****************************************************
			lcField = SUBSTR(lcLine,(lnSepLoc1+1),(lnSepLoc2-(lnSepLoc1+1)))
		
		
			IF lcDataType <> "M"
		
		****************************************************
		* Original field value (pre-updated value)
		****************************************************
				lcOrig = SUBSTR(lcLine,(lnSepLoc2+1),(lnSepLoc3-(lnSepLoc2+1)))
		
		****************************************************
		* Updated field value (post updated value)
		****************************************************
				lcUpdated = SUBSTR(lcLine,(lnSepLoc3+1),(lnSepLoc4-(lnSepLoc3+1)))
		
				DO CASE
		
		**************************************************************
		* Process Character Fields
		**************************************************************
					CASE lcDataType = "C"
						lxOrig		= IIF(lcOrig # ".NULL.",lcOrig,.NULL.)
						lxUpdated	= IIF(lcUpdated # ".NULL.",lcUpdated,.NULL.)
		
		**************************************************************
		* Process Integer, Numeric, Currency, Double and Float fields
		**************************************************************
					CASE INLIST(lcDataType,"I","N","Y","B","F")
		
						lxOrig		= IIF(lcOrig # ".NULL.",VAL(lcOrig),.NULL.)
						lxUpdated	= IIF(lcUpdated # ".NULL.",VAL(lcUpdated),.NULL.)
		
		**************************************************************
		* Process Date fields
		**************************************************************
					CASE lcDataType = "D"
		
						DO CASE
		
		* This section of code included for backward compatibility
		* with VFP 3 & 5.  It WILL cause a STRICTDATE warning to appear
		* when compiled in VFP 6.0.  Comment out the
		*
		* lxKey=CTOD(cRec_Key)
		*
		* line to avoid the STRICTDATE warnings .
							CASE INLIST(THIS.nFoxVersion,3,5)
								lcDay	=	SUBSTR(lcOrig,7,2)
								lcMonth	=	SUBSTR(lcOrig,5,2)
								lcYear	=	LEFT(lcOrig,4)
								
								lcCmd = 	"lxOrig	= IIF(EMPTY(lcOrig),{},CTOD(lcMonth+'/'+lcDay+'/'+lcYear))"
								&lcCmd.
								
								lcDay	=	SUBSTR(lcUpdated,7,2)
								lcMonth	=	SUBSTR(lcUpdated,5,2)
								lcYear	=	LEFT(lcUpdated,4)
		
								lcCmd = 	"lxUpdated	= IIF(EMPTY(lcUpdated),{},CTOD(lcMonth+'/'+lcDay+'/'+lcYear))"
								&lcCmd.
			
		* Support for SET STRICTDATE TO 2 in VFP 6.0 for Y2K compatibility
							OTHERWISE
								lxOrig = IIF(EMPTY(lcOrig),{}, ;
									DATE(;
										VAL(LEFT(lcOrig,4)),;
										VAL(SUBSTR(lcOrig,5,2)),;
										VAL(SUBSTR(lcOrig,7,2))))
		
								lxUpdated	= IIF(EMPTY(lcUpdated),{}, ;
									DATE(;
										VAL(LEFT(lcUpdated,4)),;
										VAL(SUBSTR(lcUpdated,5,2)),;
										VAL(SUBSTR(lcUpdated,7,2))))
		
						ENDCASE
		
		**************************************************************
		* Process DateTime fields
		**************************************************************
					CASE lcDataType = "T"
						lxOrig = IIF(LEFT(lcOrig,6)="000000" OR EMPTY(lcOrig), ;
							{},THIS.RealCTOT(lcOrig))
						lxUpdated = IIF(LEFT(lcUpdated,6)="000000" OR EMPTY(lcUpdated), ;
							{},THIS.RealCTOT(lcUpdated))
		
		**************************************************************
		* Process Logical fields
		**************************************************************
					CASE lcDataType = "L"
						lxOrig		= IIF(lcOrig # ".NULL.",IIF(lcOrig="True",.T.,.F.),.NULL.)
						lxUpdated	= IIF(lcUpdated # ".NULL.",IIF(lcUpdated="True",.T.,.F.),.NULL.)
		
				ENDCASE
			ELSE
				THIS.RestoreMemos(liLog_Key, lcField)
				lxOrig		= EVAL(THIS.cMemoAlias+".mOrig")
				lxUpdated	= EVAL(THIS.cMemoAlias+".mUpdated")
		
				* JMD 10/31/98
				* Added to provide better NULL support
				lxOrig		= IIF(lxOrig = ".NULL.",.NULL.,lxOrig)
				lxUpdated	= IIF(lxUpdated=".NULL.",.NULL.,lxUpdated)
			ENDIF
		
		**************************************************************
		* Restore the field
		**************************************************************
			DO CASE
				CASE lcCurrentProcess = "RB"
					REPLACE (lcField) WITH lxOrig
				CASE lcCurrentProcess = "RF"
					REPLACE (lcField) WITH lxUpdated
			ENDCASE
		
		ENDFOR
		
		RETURN
		
	ENDPROC

	PROCEDURE restorememos
		******************************************************
		* Method:		RestoreMemos
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998,1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Positions the record pointer in the associated memos
		* table to the related record in the transaction log table
		******************************************************
		* Parameters passed are the primary key of the log table
		* and the memo field being restored
		******************************************************
		LPARAMETER ;
			tiLog_Key, ;
			tcField
		
		* Declare LOCAL vars
		LOCAL ;
			lnOldArea, ;
			lcMemoLocation, ;
			lcMemoTable, ;
			lcMemoAlias, ;
			lcSeekKey
		
		lcMemoLocation 	= THIS.cMemoLocation
		lcMemoTable		= JustStem(lcMemoLocation)
		lcMemoAlias		= THIS.cMemoAlias
		lcTransTable	= EVAL(THIS.cTempLog+".cTBL_Name")
		lcTransType		= EVAL(THIS.cTempLog+".cTran_Type")
		lcTransKey		= EVAL(THIS.cTempLog+".cRec_Key")
		lcTransMsg1		= ALLTRIM(LEFT(EVAL(THIS.cTempLog+".cUserMsg1"),70))
		lcTransMsg2		= ALLTRIM(LEFT(EVAL(THIS.cTempLog+".cUserMsg2"),70))
		lcTransWho		= EVAL(THIS.cTempLog+".cUpd_Who")
		lcTransWhen		= EVAL(THIS.cTempLog+".tUpd_When")
		liLogKey		= EVAL(THIS.cTempLog+".iLog_Key")
		
		lnOldArea=SELECT()
		
		* Open the transaction memo table if necessary
		IF USED(lcMemoAlias)
			SELECT (lcMemoAlias)
		ELSE
			SELECT 0
			USE (lcMemoLocation) SHARED ALIAS (lcMemoAlias)
		ENDIF
		
		* Determine record key
		lcSeekKey = BINTOC(tiLog_Key)+tcField
		
		* Locate the record
		IF !SEEK(lcSeekKey, lcMemoAlias,"PKEY")
			lcMsgText = THIS.cMsgBoxText+" Alert"+CHR(13)+CHR(13)
			lcMsgText = lcMsgText + "Could NOT find a transaction memo for the following record."+CHR(13)+CHR(13)
			lcMsgText = lcMsgText + "Log Key: "+TRANSFORM(liLogKey)+CHR(13)
			lcMsgText = lcMsgText + "Table: "+lcTransTable+CHR(13)
			lcMsgText = lcMsgText + "Record Key: "+lcTransKey+CHR(13)
			lcMsgText = lcMsgText + "Trans Type: "+lcTransType+CHR(13)
			lcMsgText = lcMsgText + "Message 1: "+lcTransMsg1+CHR(13)
			lcMsgText = lcMsgText + "Message 2: "+lcTransMsg2+CHR(13)
			lcMsgText = lcMsgText + "Updated By: "+lcTransWho+CHR(13)
			lcMsgText = lcMsgText + "Updated On: "+TTOC(lcTransWhen)+CHR(13)
			MESSAGEBOX(lcMsgText,MB_ICONINFORMATION,THIS.cMsgBoxTitle)
		ENDIF
		
		SELECT (lnOldArea)
		RETURN
	ENDPROC

	PROTECTED PROCEDURE rollbackwarning
		******************************************************
		* Method:		RollBackWarning
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998,1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Parameter passed is which occurance of the warning
		* is occuring, the first or second
		******************************************************
		LPARAMETERS tcTiming
		LOCAL lcText
		
		DO CASE
			CASE tcTiming = "1ST"
		
				lcText = UPPER(THIS.cMsgBoxText)+" ROLLBACK WARNING"+CRLF+CRLF
				lcText = lcText+"Rolling the transaction log back will result "
				lcText = lcText+"in the data in the tables being permanently "
				lcText = lcText+"modified. Backing up your data is HIGHLY "
				lcText = lcText+"RECOMMENDED."+CRLF+CRLF
				lcText = lcText+"Do you want to continue??" +CRLF
		
			CASE tcTiming = "2ND"
		
				lcText = UPPER(THIS.cMsgBoxText)+" ROLLBACK CONFIRMATION"+CRLF+CRLF
				lcText = lcText+"This is your LAST chance to confirm your rollback "
				lcText = lcText+"selection.  PLEASE keep in mind that rolling back "
				lcText = lcText+"the transaction log will cause the data in the "
				lcText = lcText+"tables to be PERMANENTLY modified.  As stated on "
				lcText = lcText+"the prior warning, backing up your data is HIGHLY "
				lcText = lcText+"RECOMMENDED. If you haven't already done so, BACK "
				lcText = lcText+"UP YOUR DATA NOW!"+CRLF+CRLF
				lcText = lcText+"This is your last chance! Do you want to continue??"
				lcText = lcText+CRLF
		
		ENDCASE
		
		RETURN(lcText)
		
	ENDPROC

	PROTECTED PROCEDURE rollforwardwarning
		******************************************************
		* Method:		RollForwardWarning
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998,1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Parameter passed is which occurance of the warning
		* is occuring, the first or second
		******************************************************
		LPARAMETER tcTiming
		LOCAL lcText
		
		DO CASE
			CASE tcTiming = "1ST"
		
				lcText = UPPER(THIS.cMsgBoxText)+" ROLLFORWARD WARNING"+CRLF+CRLF
				lcText = lcText+"Rolling the transaction log forward will result "
				lcText = lcText+"in the data in your tables being permanently "
				lcText = lcText+"modified. Backing up your data is HIGHLY "
				lcText = lcText+"RECOMMENDED."+CRLF+CRLF
				lcText = lcText+"Do you want to continue??" +CRLF
		
			CASE tcTiming = "2ND"
		
				lcText = UPPER(THIS.cMsgBoxText)+" ROLLFORWARD CONFIRMATION"+CRLF+CRLF
				lcText = lcText+"This is your LAST chance to confirm your rollforward "
				lcText = lcText+"selection. PLEASE keep in mind that rolling the "
				lcText = lcText+"transaction log forward causes the data in the tables "
				lcText = lcText+"to be PERMANENTLY modified.  As stated on the prior "
				lcText = lcText+"warning, backing up your data is HIGHLY RECOMMENDED. "
				lcText = lcText+"If you haven't already done so, BACK UP YOUR DATA NOW!"
				lcText = lcText+CRLF+CRLF
				lcText = lcText+"This is your last chance! Do you want to continue?"+CRLF
		ENDCASE
		
		RETURN(lcText)
		
	ENDPROC

	PROTECTED PROCEDURE storeluenv		&& Store the environment settings before a logged update occurs
		******************************************************
		* Method:		StoreLUEnv
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998,1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Store LogUpdates Environment
		* Grab the enviromental settings on the way in
		******************************************************
		THIS.nArea			= SELECT()
		THIS.cSetFullPath	= SET("FULLPATH")
		SET FULLPATH ON
		
		******************************************************************
		* Grab the name of the currently opened table
		******************************************************************
		THIS.cTableDrive		= JustDrive(DBF())
		THIS.cTablePath			= SUBSTR(JustPath(DBF()),3)
		THIS.cTableName			= JustStem(DBF())
		
		******************************************************************
		* Grab the name of the currently opened database
		******************************************************************
		lcDBC					= THIS.GetDBCName()
		
		THIS.cDBCDrive			= JustDrive(lcDBC)
		THIS.cDBCPath			= SUBSTR(JustPath(lcDBC),3)
		THIS.cDBCName			= JustStem(lcDBC)
		
		RETURN
	ENDPROC

	PROTECTED PROCEDURE validateloglocation
		******************************************************
		* Method:		ValidateLogLocation
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Called when FoxAudit object is created.  This method
		* returns .T. is the log table specified when the
		* FoxAudit object was created exists
		******************************************************
		* Declare LOCAL vars
		LOCAL ;
			lcLogLocation, ;
			lcMemoLocation, ;
			llReturnValue
			
		lcLogLocation = THIS.cLogLocation
		lcMemoLocation = THIS.cMemoLocation
		llReturnValue = .T.
		
		IF !EMPTY(lcLogLocation)
		   THIS.cLogTable		= JustStem(lcLogLocation)
		   THIS.cLogPath		= JustPath(lcLogLocation)
		   THIS.cMemoTable	= JustStem(lcMemoLocation)
		   THIS.cMemoPath	= JustPath(lcMemoLocation)
		ELSE
			lcMsgText = THIS.cMsgBoxText+" Transaction Logging Error"+CRLF+CRLF
			lcMsgText = lcMsgtext + "The cLogLocation property can not be empty."+CRLF
			lnDialogType = MB_ICONSTOP
			MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
		   llReturnValue = .F.
		ENDIF
		
		RETURN(llReturnValue)
	ENDPROC

	PROTECTED PROCEDURE validateluparms		&& Validate the LogUpdate Parms
		********************************************************
		* Method:		ValidateLUParms
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Validate LogUpdate parameters
		* Determines if parameters passed to LogUpdates are valid
		********************************************************
		#DEFINE CRLF CHR(13)
		#DEFINE HR2  CHR(13)+CHR(13)
		#DEFINE MB_ICONSTOP 32
		
		* Declare LOCAL vars
		LOCAL ;
			lcMsgText, ;
			lnDialogType, ;
			lcMsgTitle, ;
			llReturnValue
		
		llReturnValue = .T.
		
		SET DATASESSION TO (THIS.iDataSession)
		
		IF !INLIST(THIS.cTransType,"I","D","U")
			lcMsgText = THIS.cMsgBoxText+" Transaction Logging Error"+CRLF+CRLF
			lcMsgText = lcMsgText + "An invalid Transaction Type was specified in the calling "+CRLF
			lcMsgText = lcMsgText + "trigger.  An 'I', 'D', or 'U' are required."+CRLF
			lnDialogType = MB_ICONSTOP
			MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
			llReturnValue = .F.
		ENDIF
		
		IF EMPTY(THIS.cIndexTag)
			lcMsgText = THIS.cMsgBoxText+" Transaction Logging Error"+HR2
			lcMsgText = lcMsgText + "A Primary Key index could not be located and an alternate "+CRLF
			lcMsgText = lcMsgText + "index has not been supplied.  If there is not a Primary Key index "+CRLF
			lcMsgText = lcMsgText + "in the table then a alternate index tag must be supplied. Refer "+CRLF
			lcMsgText = lcMsgText + "to the LogUpdates syntax to determine how to send an alternate index."+HR2
			lnDialogType = MB_ICONSTOP
			MESSAGEBOX(lcMsgText, lnDialogType, THIS.cMsgBoxTitle)
			llReturnValue = .F.
		ENDIF
		
		RETURN(llReturnValue)
		
	ENDPROC

	PROTECTED PROCEDURE validaterestoreparms
		******************************************************
		* Method:		ValidateRestoreParms
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Declare LOCAL vars
		LOCAL llReturnValue, lcMsgText
		
		llReturnValue = .T.
		lcMsgText = THIS.cMsgBoxText+" Information"+CHR(13)+CHR(13)
		
		DO CASE
		* Validate process
			CASE EMPTY(THIS.cCurrentProcess) OR !INLIST(THIS.cCurrentProcess,"RB","RF")
				llReturnValue = .F.
				lcMsgText = lcMsgText + "You must specify either 'RB' or 'RF' as the process."
		
		* Validate transactio log table
			CASE EMPTY(THIS.cLogTable) OR TYPE("THIS.cLogTable") <> "C"
				llReturnValue = .F.
				lcMsgText = lcMsgText + "You must specify a log to restore."
				
		* Validate datetime parameter		
			CASE EMPTY("THIS.tRestoreToDateTime")
				llReturnValue = .F.
				lcMsgText = lcMsgText + "You must specify a date parameter!"
				
		* Validate datetime data type		
			CASE TYPE("THIS.tRestoreToDateTime")#"D" AND ;
					TYPE("THIS.tRestoreToDateTime")#"T"
				llReturnValue = .F.
				lcMsgText = lcMsgText + "You must specify a date or a datetime parameter!"
		
		* If only a date type is passed, convert it to datetime
			CASE TYPE("THIS.tRestoreToDateTime") = "D"
				THIS.tRestoreToDateTime = DTOT(THIS.tRestoreToDate)
		ENDCASE
		
		IF !llReturnValue
			MESSAGEBOX(lcMsgText,0,THIS.cMsgBoxTitle)
		ENDIF
		
		RETURN(llReturnValue)
		
	ENDPROC

	PROCEDURE viewlog
		******************************************************
		* Method:		ViewLog
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Instantiates and displays the ViewLog form.  In the
		* Destroy of FoxAudit, THIS.oViewLogForm is set to .NULL.
		******************************************************
		THIS.LoadClassLib()
		
		THIS.oViewLogForm = CREATEOBJECT("ViewLog",THIS)
		
		IF TYPE("THIS.oViewLogForm") == "O" AND !ISNULL(THIS.oViewLogForm)
			THIS.oViewLogForm.SHOW()
		ELSE
			MESSAGEBOX("The View Log form could not be displayed.",0,THIS.cMsgBoxTitle)
		ENDIF
		
		
	ENDPROC

	PROTECTED PROCEDURE writetolog		&& Inserts a log record
		******************************************************
		* Method:		WriteToLog
		******************************************************
		* Author:		Jim Duffy
		* Date:			10/16/1998
		* Copyright:	1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* This method writes the log record to the log table
		******************************************************
		
		******************************************************
		* If no actual changes have been made to the record 
		* do NOT create a log record.
		* How could this happen?
		* 1. Edit a record and replace a field's contents with
		*    its current value
		* 2. Do a REPLACE on a field and replace it with its
		*    current contents.  REPLACE NAME WITH UPPER(NAME)
		*    where the name is already upper case.
		*
		* THIS.cChanges contains all of the updated fields and
		* their corresponding original and current values.
		******************************************************
		IF EMPTY(THIS.cChanges)
			RETURN
		ENDIF
		
		LOCAL ;
			lcLogAlias, ;
			lcMemoAlias, ;
			lnDataSession, ;
			lcLogTable, ;
			lcMemoTable
		
		lcLogAlias = THIS.cLogAlias
		lcLogTable = THIS.cLogTable
		lcLogLocation = THIS.cLogLocation
		lcMemoAlias = THIS.cMemoAlias
		lcMemoTable = THIS.cMemoTable
		lcMemoLocation = THIS.cMemoLocation
		lnDataSession = SET("DATASESSION")
		
		IF USED(lcLogAlias)
			lcTheLog = ALLTRIM(lcLogAlias)
			lcTheMemoLog = ALLTRIM(lcMemoAlias)
		ELSE
			lcTheLog = lcLogLocation
			lcTheMemoLog = lcMemoLocation
		ENDIF
		
		liTheKey = THIS.GenKey()
		
		INSERT INTO (lcTheLog) ( ;
			iLog_Key, ;
			cTran_Type, ;
			cDBC_Drive, ;
			cDBC_Path, ;
			cDBC_Name, ;
			cTbl_Drive, ;
			cTbl_Path, ;
			cTbl_Name, ;
			cTag_Name, ;
			cKey_Type, ;
			cRec_Key, ;
			mActions, ;
			lMemos, ;
			cUserMsg1, ;
			cUserMsg2, ;
			cUpd_Who, ;
			tUpd_When) ;
		VALUES (;
			liTheKey, ;
			THIS.cTransType, ;
			THIS.cDBCDrive, ;
			THIS.cDBCPath, ;
			THIS.cDBCName, ;
			THIS.cTableDrive, ;
			THIS.cTablePath, ;
			THIS.cTableName, ;
			THIS.cIndexTag, ;
			THIS.cKeyType, ;
			THIS.cKey, ;
			THIS.cChanges, ;
			THIS.lLUMemos, ;
			THIS.cUserMsg1, ;
			THIS.cUserMsg2, ;
			THIS.cUserID, ;
			DATETIME())
		
		IF THIS.lLUMemos
			LOCAL ;
				liLog_Key, ;
				lnDotLoc, ;
				lcOldSafety
		
			liLog_Key = liTheKey
		
			SET DATASESSION TO (lnDataSession)
			SELECT FA_TempMemos
			lcField		= FA_TempMemos.cField
			lmOrig		= FA_TempMemos.mOrig
			lmUpdated	= FA_TempMemos.mUpdated
			
			LOCATE
			SCAN
				SET DATASESSION TO (THIS.iLogDataSession)
				INSERT INTO (lcTheMemoLog) ( ;
					iLog_Key, ;
					cField, ;
					mOrig, ;
					mUpdated) ;
				VALUES (;
					liLog_Key, ;
					lcField, ;
					lmOrig, ;
					lmUpdated)
		
				SET DATASESSION TO (lnDataSession)
			ENDSCAN
			
			SET DATASESSION TO (lnDataSession)
			SELECT FA_TempMemos
			lcOldSafety = SET("SAFETY")
			SET SAFETY OFF
			ZAP
			SET SAFETY &lcOldSafety.
		ENDIF
		
		
		SET DATASESSION TO (lnDataSession)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS foxauditthermo AS fa_form OF "foxaudit.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtThermOutline" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblPct" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="shpTherm" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMsg" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTitle" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: copyright		&& Copyright information
		*m: readme		&& Information about working with this class
		*m: updatebar		&& Updates the thermometer bar based on percentage passed in
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	BackColor = 192,192,192
	Caption = ""
	Closable = .F.
	ControlBox = .F.
	DoCreate = .T.
	HalfHeightCaption = .F.
	Height = 101
	MaxButton = .F.
	MinButton = .F.
	Movable = .F.
	Name = "foxauditthermo"
	Width = 326
	WindowType = 0

	ADD OBJECT 'lblMsg' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "lblMsg", ;
		Height = 17, ;
		Left = 6, ;
		Name = "lblMsg", ;
		Top = 40, ;
		Width = 38
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblPct' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "0%", ;
		ColorScheme = 1, ;
		ColorSource = 0, ;
		ForeColor = 0,0,255, ;
		Height = 17, ;
		Left = 153, ;
		Name = "lblPct", ;
		Top = 77, ;
		Width = 20
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblTitle' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "L O G    P R O C E S S I N G    P R O G R E S S    M E T E R", ;
		FontBold = .T., ;
		Height = 17, ;
		Left = 10, ;
		Name = "lblTitle", ;
		Top = 12, ;
		Width = 306
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'shpTherm' AS fa_shape WITH ;
		BackColor = 0,0,255, ;
		BackStyle = 1, ;
		BorderColor = 0,0,255, ;
		BorderWidth = 0, ;
		DrawMode = 10, ;
		Height = 19, ;
		Left = 7, ;
		Name = "shpTherm", ;
		Top = 76, ;
		Width = 0
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'txtThermOutline' AS fa_textbox WITH ;
		Enabled = .F., ;
		Height = 22, ;
		Left = 5, ;
		Name = "txtThermOutline", ;
		Top = 74, ;
		Width = 316
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />
	
	PROCEDURE copyright		&& Copyright information
		******************************************************************
		* Class: FoxAuditThermo                          
		******************************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************************
		
		* This software and documentation is protected by U.S. copyright 
		* laws and International treaty provisions.
		
		* Copyright © 1998 Management Smarts, Inc. 
		*  dba TakeNote Computer Consulting
		* All rights reserved
		
		* TakeNote Computer Consulting
		* P.O. Box 99271
		* Raleigh, NC 27624
		* USA
		* (919) 870-9000
		
	ENDPROC

	PROCEDURE readme		&& Information about working with this class
		***************************************************
		* Method:		ReadMe
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	1998 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* The FoxAuditThermo form displays a thermometer
		* indicating the progress of a roll back or roll forward
		* operation.
		*
		* Example: oFoxAudit.ViewLog()
		
	ENDPROC

	PROCEDURE updatebar		&& Updates the thermometer bar based on percentage passed in
		***************************************************
		* Method: UpdateBar
		***************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	1998 TakeNote Computer Consulting
		*					http://www.takenote.com
		*					All rights reserved
		******************************************************
		* Parameters passed are the percentage complete and
		* the message to display
		LPARAMETERS tnPct, tcMsg
		
		THIS.LOCKSCREEN = .T.
		
		tnPct = IIF(tnPct<0,0,IIF(tnPct>100,100,tnPct))
		
		IF !EMPTY(tcMsg)
			THIS.lblMsg.CAPTION = tcMsg
		ENDIF
		
		THIS.lblPct.CAPTION = LTRIM(STR(tnPct) + '%')
		THIS.shpTherm.WIDTH = 3.15 * tnPct
		
		THIS.LOCKSCREEN = .F.
		
		IF !THIS.VISIBLE = .F.
			THIS.SHOW()
		ENDIF
		
		IF tnPct = 100
			THIS.HIDE()
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS processlog AS fa_form OF "foxaudit.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtLogName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkLogUpdates" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtRestoreToDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblLogname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblProcess" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblParameters" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: copyright		&& Copyright information
		*m: readme		&& Information about working with this class
		*p: cdateformat		&& Date format to use on this form - AMERICAN, BRITISH, etc.
		*p: ofoxaudit		&& Contains a reference to the FoxAudit object that called this form
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "Process Transaction Log"
	cdateformat = AMERICAN		&& Date format to use on this form - AMERICAN, BRITISH, etc.
	Closable = .F.
	ControlBox = .F.
	DoCreate = .T.
	Height = 193
	MaxButton = .F.
	MinButton = .F.
	Name = "processlog"
	ofoxaudit = 		&& Contains a reference to the FoxAudit object that called this form
	Width = 494
	WindowType = 1

	ADD OBJECT 'chkLogUpdates' AS fa_checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "\<Log Processing Updates", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 127, ;
		Name = "chkLogUpdates", ;
		TabIndex = 6, ;
		Top = 75, ;
		Value = .F., ;
		Width = 136
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS fa_commandbutton WITH ;
		Cancel = .T., ;
		Caption = "\<Close", ;
		FontSize = 8, ;
		Height = 27, ;
		Left = 261, ;
		Name = "cmdCancel", ;
		TabIndex = 10, ;
		Top = 156, ;
		Width = 101
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdGo' AS fa_commandbutton WITH ;
		Caption = "Roll Back", ;
		FontSize = 8, ;
		Height = 27, ;
		Left = 131, ;
		Name = "cmdGo", ;
		TabIndex = 9, ;
		Top = 156, ;
		Width = 101
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblDate' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Date/Time to Roll Back To", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 127, ;
		Name = "lblDate", ;
		TabIndex = 8, ;
		Top = 102, ;
		Width = 123
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblLogname' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Log Name", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 13, ;
		Name = "lblLogname", ;
		TabIndex = 1, ;
		Top = 24, ;
		Width = 50
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblParameters' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = "Parameters", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 115, ;
		Name = "lblParameters", ;
		TabIndex = 5, ;
		Top = 56, ;
		Width = 57
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblProcess' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = "Process", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 14, ;
		Name = "lblProcess", ;
		TabIndex = 3, ;
		Top = 56, ;
		Width = 42
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'opgProcess' AS fa_optiongroup WITH ;
		ButtonCount = 2, ;
		Height = 69, ;
		Left = 7, ;
		Name = "opgProcess", ;
		TabIndex = 4, ;
		Top = 63, ;
		Value = 1, ;
		Width = 98, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Roll \<Back", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Top = 12, ;
		Option1.Value = 1, ;
		Option1.Width = 62, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Roll \<Forward", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 5, ;
		Option2.Name = "Option2", ;
		Option2.Top = 39, ;
		Option2.Width = 80
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'Shape1' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 42, ;
		Left = 7, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 9, ;
		Width = 476
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'Shape2' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 69, ;
		Left = 107, ;
		Name = "Shape2", ;
		SpecialEffect = 0, ;
		Top = 63, ;
		Width = 376
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'txtLogName' AS fa_textbox WITH ;
		BackColor = 192,192,192, ;
		FontBold = .T., ;
		FontSize = 8, ;
		ForeColor = 0,0,255, ;
		Height = 23, ;
		Left = 79, ;
		Name = "txtLogName", ;
		SelectOnEntry = .T., ;
		Style = 1, ;
		TabIndex = 2, ;
		Top = 18, ;
		Width = 396
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtRestoreToDate' AS fa_textbox WITH ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 319, ;
		Name = "txtRestoreToDate", ;
		SelectOnEntry = .T., ;
		TabIndex = 7, ;
		Top = 96, ;
		Width = 156
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />
	
	PROCEDURE copyright		&& Copyright information
		******************************************************************
		* Class: 		ProcessLog                          
		******************************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************************
		
		* This software and documentation is protected by U.S. copyright 
		* laws and International treaty provisions.
		
		* Copyright © 1998, 1999 Management Smarts, Inc. 
		*  dba TakeNote Computer Consulting
		* All rights reserved
		
		* TakeNote Computer Consulting
		* P.O. Box 99271
		* Raleigh, NC 27624
		* USA
		* (919) 870-9000
		
	ENDPROC

	PROCEDURE Destroy
		******************************************************
		* Method:		Destroy
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Release the reference to the current FoxAudit object
		******************************************************
		THIS.oFoxAudit = .NULL.
	ENDPROC

	PROCEDURE Init
		******************************************************
		* Method:		Init
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Pass in the FoxAudit object to work with
		LPARAMETERS toFoxAudit
		THIS.oFoxAudit = toFoxAudit
		RELEASE toFoxAudit
		
		SET TALK OFF
		SET DELETED OFF
		SET CONFIRM ON
		SET BELL OFF
		SET CENTURY ON
		
		* Declare LOCAL vars
		LOCAL ;
			lcTableName, ;
			lcTableStem, ;
			lcTableAlias, ;
			llAlreadyOpen
		
		THIS.txtLogName.Value = THIS.oFoxAudit.LogLocation()
		lcTableName = ALLTRIM(THIS.oFoxAudit.LogLocation())
		lcTableStem = THIS.oFoxAudit.JustStem(lcTableName)
		lcTableAlias = THIS.oFoxAudit.cLogAlias
		
		THISFORM.oFoxAudit.CloseLogTables()
		THISFORM.oFoxAudit.OpenLogTables()
		
		SET DATASESSION TO (THIS.oFoxAudit.iLogDataSession)
		SELECT (lcTableAlias)
		LOCATE
		
		THIS.txtRestoreToDate.Value = tUpd_When
		
		
	ENDPROC

	PROCEDURE readme		&& Information about working with this class
		***************************************************
		* Method:		ReadMe
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* The ProcessLog form is used to place a GUI interface
		* on the ProcessLog method.
		* It is called from the FoxAudit object by calling the
		* GUIProcessLog method.
		*
		* Example: oFoxAudit.GUIProcessLog()
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		RELEASE THISFORM
	ENDPROC

	PROCEDURE cmdGo.Click
		WITH THISFORM
		
			* Declare LOCAL vars
			LOCAL ;
				lcProcess, ;
				lcLog, ;
				ltWhen, ;
				llLogUpdates, ;
				llDisregardWarnings
			llDisregardWarnings = .F.
		
			IF EMPTY(.txtRestoreToDate.VALUE)
				MESSAGEBOX("You must specify a processing date/time",16,THISFORM.oFoxAudit.cMsgBoxTitle)
				.txtRestoreToDate.SETFOCUS()
				RETURN
			ENDIF
		
		* Determine Process
			DO CASE
				CASE .opgProcess.VALUE = 1
					lcProcess = "RB"
				CASE .opgProcess.VALUE = 2
					lcProcess = "RF"
			ENDCASE
		
			lcLog			= .txtLogName.VALUE
			ltWhen			= .txtRestoreToDate.VALUE
			llLogUpdates	= .chkLogUpdates.VALUE
		
			*****************************************************
			* Call the ProcessLog method to begin processing the
			* transaction log
			*****************************************************
			.oFoxAudit.ProcessLog(lcProcess,lcLog,ltWhen,;
				llDisregardWarnings,llLogUpdates)
		
			* If an error occured in the FoxAudit object, cancel
			* this form
			IF .oFoxAudit.ErrorState()
				.cmdCancel.CLICK()
			ENDIF
		
			.cmdCancel.SETFOCUS()
		
		ENDWITH
		
		
		
	ENDPROC

	PROCEDURE opgProcess.Option1.Click
		THISFORM.lblDate.Caption = "Date/Time to Roll Back To"
		THISFORM.cmdGo.Caption = "Roll Back"
		
	ENDPROC

	PROCEDURE opgProcess.Option2.Click
		THISFORM.lblDate.Caption = "Date/Time to Roll Forward From"
		THISFORM.cmdGo.Caption = "Roll Forward"
		
	ENDPROC

ENDDEFINE

DEFINE CLASS viewfield AS fa_form OF "foxaudit.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtFieldValue" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgFields" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtField" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: copyright		&& Copyright information
		*m: readme		&& Information about this class
		*p: cactions
		*p: cmemolog
		*p: ikey
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "Field Contents Viewer"
	DoCreate = .T.
	Height = 364
	Name = "viewfield"
	Width = 496
	WindowType = 1

	ADD OBJECT 'cmdOK' AS fa_commandbutton WITH ;
		Cancel = .T., ;
		Caption = "OK", ;
		Default = .T., ;
		Height = 27, ;
		Left = 206, ;
		Name = "cmdOK", ;
		Top = 332, ;
		Width = 84
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtFieldValue' AS fa_editbox WITH ;
		FontSize = 8, ;
		Height = 228, ;
		Left = 16, ;
		Name = "edtFieldValue", ;
		Top = 89, ;
		Width = 462
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="editbox" />

	ADD OBJECT 'Label1' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Selected value to view", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 14, ;
		Name = "Label1", ;
		Top = 44, ;
		Width = 112
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Label2' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Field", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 14, ;
		Name = "Label2", ;
		Top = 19, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Label3' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = " Field Value ", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 17, ;
		Name = "Label3", ;
		Top = 69, ;
		Width = 61
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'opgFields' AS fa_optiongroup WITH ;
		BackStyle = 0, ;
		ButtonCount = 2, ;
		Height = 27, ;
		Left = 142, ;
		Name = "opgFields", ;
		Top = 36, ;
		Value = 2, ;
		Width = 242, ;
		Option1.AutoSize = .T., ;
		Option1.Caption = "Original Value", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.ToolTipText = "Display the pre-updated value", ;
		Option1.Top = 5, ;
		Option1.Value = 0, ;
		Option1.Width = 85, ;
		Option2.AutoSize = .T., ;
		Option2.Caption = "Updated Value", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 126, ;
		Option2.Name = "Option2", ;
		Option2.ToolTipText = "Display the updated value", ;
		Option2.Top = 5, ;
		Option2.Value = 1, ;
		Option2.Width = 89
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'Shape1' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 65, ;
		Left = 5, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 4, ;
		Width = 484
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'Shape2' AS fa_shape WITH ;
		BackStyle = 0, ;
		Height = 248, ;
		Left = 5, ;
		Name = "Shape2", ;
		SpecialEffect = 0, ;
		Top = 77, ;
		Width = 484
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'txtField' AS fa_textbox WITH ;
		Comment = "FA_Actions.cField", ;
		ControlSource = "", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 142, ;
		Name = "txtField", ;
		Style = 1, ;
		Top = 11, ;
		Width = 242
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="textbox" />
	
	PROCEDURE copyright		&& Copyright information
		******************************************************************
		* Class: ViewField                          
		******************************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************************
		
		* This software and documentation is protected by U.S. copyright 
		* laws and International treaty provisions.
		
		* Copyright © 1998, 1999 Management Smarts, Inc. 
		*  dba TakeNote Computer Consulting
		* All rights reserved
		
		* TakeNote Computer Consulting
		* P.O. Box 99271
		* Raleigh, NC 27624
		* USA
		* (919) 870-9000
		
	ENDPROC

	PROCEDURE Init
		***************************************************
		* Method:		INIT
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1999
		* Copyright:	© 1998,1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Parameters accepted are the name of the cursor containing
		* transaction, the key value of the current table record, and
		* the name of the transaction log memo table.
		******************************************************
		LPARAMETERS tcActionsCursor, tiKey, tcMemoLog
		
		THISFORM.cActions = tcActionsCursor
		THISFORM.iKey = tiKey
		THISFORM.cMemoLog = tcMemoLog
		
		THISFORM.txtField.Value = EVAL(THISFORM.cActions+".cField")
		
		THISFORM.opgFields.InteractiveChange()
		
	ENDPROC

	PROCEDURE readme		&& Information about this class
		***************************************************
		* Method:		ReadMe
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/26/1999
		* Copyright:	© 1998,1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* The ViewField form displays information about a specific
		* transaction log field. It displays the original and
		* updated field values.  It is most commonly used to view
		* memo field data.
		*
		* It is called from the ViewLog form by creating a ViewField 
		* object and running its SHOW method
		*
		* Example:
		* THISFORM.oViewField = .NULL.
		* THISFORM.oViewField = CREATEOBJECT("ViewField",lcCursor,liRecordKey,xLog Memo Table)
		* THISFORM.oViewField.SHOW(1)  && Modal
		* THISFORM.oViewField = .NULL.
		******************************************************
		* Comments
		* The Field Contents Viewer form is pretty straight forward. By
		* default, the updated field contents appear when the form is 
		* loaded. To change this behavior and have the original value
		* displayed first, change the Value property of the opgFields
		* option group from 2 to 1.
	ENDPROC

	PROCEDURE cmdOK.Click
		RELEASE THISFORM
	ENDPROC

	PROCEDURE edtFieldValue.When
		RETURN(.F.)
	ENDPROC

	PROCEDURE opgFields.InteractiveChange
		* Declare LOCAL vars
		LOCAL ;
			lcOrig, ;
			lcUpdated, ;
			liLog_Key, ;
			liKey
			
		**********************************************
		* If the current field is a memo field, grab
		* original and updated values from the associated
		* memo file
		**********************************************
		
		IF EVAL(THISFORM.cActions+".cDataType") = "M"
			
			liLog_Key = BINTOC(THISFORM.iKey)+ALLTRIM(EVAL(THISFORM.cActions+".cField"))
		
			IF SEEK(liLog_Key,THISFORM.cMemoLog,"PKEY")
				lcOrig 		= EVAL(THISFORM.cMemoLog+".mOrig")
				lcUpdated	= EVAL(THISFORM.cMemoLog+".mUpdated")
			ELSE
				lcOrig 		= "Error: Unable to locate original value"
				lcUpdated	= "Error: Unable to locate updated value"
			ENDIF
		
		ELSE
			lcOrig 		= EVAL(THISFORM.cActions+".cOrig")
			lcUpdated	= EVAL(THISFORM.cActions+".cUpdated")
		ENDIF
		
		DO CASE
			CASE THIS.VALUE = 1
				THISFORM.edtFieldValue.VALUE = lcOrig
			CASE THIS.VALUE = 2
				THISFORM.edtFieldValue.VALUE = lcUpdated
		ENDCASE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS viewlog AS fa_form OF "foxaudit.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shape4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBeginning" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblEnding" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSearchLog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column3.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column3.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column4.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column4.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column5.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column5.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column6.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column6.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column7.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdLog.Column7.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPreview" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblRecords" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions.Column3.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions.Column3.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions.Column4.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdActions.Column4.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTransactionDates" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ddlCriteria" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFilterCriteria" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ddlTable" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ddlUser" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ddlTransactionType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdViewFields" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblUpdateActions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtBeginDate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtEndDate" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: buildactionscursor
		*m: buildtemplog
		*m: buildthermometer
		*m: callhelp
		*m: copyright		&& Copyright information
		*m: filtertemplog
		*m: getgridwidths
		*m: managebuttons		&& Handles enabling and disabling command buttons
		*m: populateactionscursor
		*m: populateactionsmemos
		*m: printlogreport
		*m: readme		&& Information about working with this class
		*m: setupactionsgrid
		*m: setupgrid
		*m: updatecaption
		*p: ccentury		&& SET CENTURY setting on the way in
		*p: ctemplocation
		*p: ctemplog
		*p: ctemplogalias
		*p: lopenedlogs		&& Did this form open the log tables? If .T. they will be closed in Destroy
		*p: lsetcolwidths
		*p: lsetcolwidthsactions
		*p: ncolumn10width
		*p: ncolumn11width
		*p: ncolumn12width
		*p: ncolumn13width
		*p: ncolumn1width		&& Run time width of Column 1 in the log records grid
		*p: ncolumn1widthaction
		*p: ncolumn2width		&& Run time width of Column 2 in the log records grid
		*p: ncolumn2widthaction
		*p: ncolumn3width		&& Run time width of Column 3 in the log records grid
		*p: ncolumn3widthaction
		*p: ncolumn4width		&& Run time width of Column 4 in the log records grid
		*p: ncolumn4widthaction
		*p: ncolumn5width		&& Run time width of Column 5 in the log records grid
		*p: ncolumn6width		&& Run time width of Column 6 in the log records grid
		*p: ncolumn7width		&& Run time width of Column 7 in the log records grid
		*p: ncolumn8width		&& Run time width of Column 8 in the log records grid
		*p: ncolumn9width		&& Run time width of Column 9 in the log records grid
		*p: ncontrolflags
		*p: ofoxaudit		&& Stores a reference to the FoxAudit object that called the View Log form
		*p: oviewfield		&& Contains a reference to the view field form
		*p: tbegindate
		*p: tenddate
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED ccentury,lsetcolwidths,lsetcolwidthsactions,ncolumn1width,ncolumn1widthaction,ncolumn2width,ncolumn2widthaction,ncolumn3width,ncolumn3widthaction,ncolumn4width,ncolumn4widthaction,ncolumn5width,ncolumn6width,ncolumn7width
	AutoCenter = .T.
	BorderStyle = 3
	Caption = "View Audit Log"
	ccentury = 		&& SET CENTURY setting on the way in
	ctemplocation = .F.
	ctemplog = .F.
	ctemplogalias = .F.
	DoCreate = .T.
	Height = 669
	HelpContextID = 567
	Icon = ..\
	lsetcolwidths = .F.
	lsetcolwidthsactions = .F.
	MaxButton = .T.
	Name = "viewlog"
	ncolumn10width = 0
	ncolumn11width = 0
	ncolumn12width = 0
	ncolumn13width = 0
	ncolumn1width = 0		&& Run time width of Column 1 in the log records grid
	ncolumn1widthaction = 0
	ncolumn2width = 0		&& Run time width of Column 2 in the log records grid
	ncolumn2widthaction = 0
	ncolumn3width = 0		&& Run time width of Column 3 in the log records grid
	ncolumn3widthaction = 0
	ncolumn4width = 0		&& Run time width of Column 4 in the log records grid
	ncolumn4widthaction = 0
	ncolumn5width = 0		&& Run time width of Column 5 in the log records grid
	ncolumn6width = 0		&& Run time width of Column 6 in the log records grid
	ncolumn7width = 0		&& Run time width of Column 7 in the log records grid
	ncolumn8width = 0		&& Run time width of Column 8 in the log records grid
	ncolumn9width = 0		&& Run time width of Column 9 in the log records grid
	ncontrolflags = 0
	ofoxaudit = 		&& Stores a reference to the FoxAudit object that called the View Log form
	oviewfield = 		&& Contains a reference to the view field form
	ShowTips = .T.
	tbegindate = 
	tenddate = 
	Width = 720
	WindowType = 0
	_memberdata = <VFPData>
		<memberdata name="ncontrolflags" display="nControlFlags"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'cmdClose' AS fa_commandbutton WITH ;
		Cancel = .T., ;
		Caption = "", ;
		Height = 24, ;
		Left = 108, ;
		Name = "cmdClose", ;
		Picture = ..\..\..\3rdparty\foxaudit6\fa_close.bmp, ;
		TabIndex = 10, ;
		ToolTipText = "Close", ;
		Top = 4, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPreview' AS fa_commandbutton WITH ;
		Caption = "", ;
		Default = .F., ;
		Enabled = .F., ;
		Height = 24, ;
		Left = 30, ;
		Name = "cmdPreview", ;
		Picture = ..\..\..\3rdparty\foxaudit6\fa_prevw.bmp, ;
		TabIndex = 7, ;
		ToolTipText = "Preview Log Report", ;
		Top = 4, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrint' AS fa_commandbutton WITH ;
		Caption = "", ;
		Enabled = .F., ;
		Height = 24, ;
		Left = 56, ;
		Name = "cmdPrint", ;
		Picture = ..\..\..\3rdparty\foxaudit6\fa_print.bmp, ;
		TabIndex = 8, ;
		ToolTipText = "Print Log Report", ;
		Top = 4, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSearch' AS fa_commandbutton WITH ;
		Caption = "", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 528, ;
		Name = "cmdSearch", ;
		Picture = ..\..\..\3rdparty\foxaudit6\fa_find.bmp, ;
		TabIndex = 5, ;
		ToolTipText = "Search Log using Transaction Dates ", ;
		Top = 49, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSearchLog' AS fa_commandbutton WITH ;
		Caption = "", ;
		Height = 24, ;
		Left = 4, ;
		Name = "cmdSearchLog", ;
		Picture = ..\..\..\3rdparty\foxaudit6\fa_find.bmp, ;
		TabIndex = 6, ;
		ToolTipText = "Search Log using Transaction Dates below", ;
		Top = 4, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdViewFields' AS fa_commandbutton WITH ;
		Caption = "", ;
		Enabled = .F., ;
		Height = 24, ;
		Left = 82, ;
		Name = "cmdViewFields", ;
		Picture = ..\..\..\3rdparty\foxaudit6\fa_viewm.bmp, ;
		TabIndex = 9, ;
		ToolTipText = "Display field contents", ;
		Top = 4, ;
		Width = 24
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'ddlCriteria' AS fa_dropdown WITH ;
		Height = 24, ;
		Left = 269, ;
		Name = "ddlCriteria", ;
		RowSource = "None,By Transaction Type,By Table Name,By User", ;
		RowSourceType = 1, ;
		Style = 2, ;
		TabIndex = 18, ;
		ToolTipText = "", ;
		Top = 4, ;
		Value = None, ;
		Width = 142
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="combobox" />

	ADD OBJECT 'ddlTable' AS fa_dropdown WITH ;
		ColumnCount = 1, ;
		ColumnWidths = "300", ;
		Height = 24, ;
		Left = 458, ;
		Name = "ddlTable", ;
		Style = 2, ;
		TabIndex = 19, ;
		ToolTipText = "Select the table to display log records for", ;
		Top = 4, ;
		Value = , ;
		Visible = .F., ;
		Width = 135
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="combobox" />

	ADD OBJECT 'ddlTransactionType' AS fa_dropdown WITH ;
		Height = 24, ;
		Left = 518, ;
		Name = "ddlTransactionType", ;
		RowSource = "Inserts,Updates,Deletes", ;
		RowSourceType = 1, ;
		Style = 2, ;
		TabIndex = 21, ;
		ToolTipText = "Select type of transactions to display log records for", ;
		Top = 4, ;
		Value = All, ;
		Visible = .F., ;
		Width = 76
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="combobox" />

	ADD OBJECT 'ddlUser' AS fa_dropdown WITH ;
		ColumnCount = 1, ;
		ColumnWidths = "200", ;
		Height = 24, ;
		Left = 470, ;
		Name = "ddlUser", ;
		Style = 2, ;
		TabIndex = 20, ;
		ToolTipText = "Select the user to display log records for", ;
		Top = 4, ;
		Value = , ;
		Visible = .F., ;
		Width = 124
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="combobox" />

	ADD OBJECT 'grdActions' AS fa_grid WITH ;
		ColumnCount = 4, ;
		DeleteMark = .F., ;
		FontSize = 8, ;
		Height = 284, ;
		Left = 8, ;
		Name = "grdActions", ;
		Panel = 1, ;
		ReadOnly = .T., ;
		RecordMark = .F., ;
		RowHeight = 17, ;
		SplitBar = .F., ;
		TabIndex = 16, ;
		Top = 364, ;
		Width = 700, ;
		Column1.ControlSource = "", ;
		Column1.FontSize = 8, ;
		Column1.Name = "Column1", ;
		Column1.ReadOnly = .T., ;
		Column1.Width = 59, ;
		Column2.ControlSource = "", ;
		Column2.FontSize = 8, ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 250, ;
		Column3.ControlSource = "", ;
		Column3.FontSize = 8, ;
		Column3.Name = "Column3", ;
		Column3.ReadOnly = .T., ;
		Column3.Width = 183, ;
		Column4.ControlSource = "", ;
		Column4.FontSize = 8, ;
		Column4.Name = "Column4", ;
		Column4.ReadOnly = .T., ;
		Column4.Width = 183
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="grid" />

	ADD OBJECT 'grdActions.Column1.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Data Type", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdActions.Column1.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdActions.Column2.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Field", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdActions.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdActions.Column3.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Original", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdActions.Column3.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdActions.Column4.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Updated", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdActions.Column4.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdLog' AS fa_grid WITH ;
		ColumnCount = 7, ;
		DeleteMark = .F., ;
		FontSize = 8, ;
		Height = 246, ;
		Left = 9, ;
		Name = "grdLog", ;
		Panel = 1, ;
		ReadOnly = .T., ;
		RecordMark = .F., ;
		RowHeight = 17, ;
		SplitBar = .F., ;
		TabIndex = 15, ;
		Top = 90, ;
		Width = 699, ;
		Column1.FontSize = 8, ;
		Column1.Name = "Column1", ;
		Column1.ReadOnly = .T., ;
		Column1.Width = 138, ;
		Column2.FontSize = 8, ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 27, ;
		Column3.FontSize = 8, ;
		Column3.Name = "Column3", ;
		Column3.ReadOnly = .T., ;
		Column3.Width = 83, ;
		Column4.FontSize = 8, ;
		Column4.Name = "Column4", ;
		Column4.ReadOnly = .T., ;
		Column4.Width = 51, ;
		Column5.FontSize = 8, ;
		Column5.Name = "Column5", ;
		Column5.ReadOnly = .T., ;
		Column5.Width = 148, ;
		Column6.FontSize = 8, ;
		Column6.Name = "Column6", ;
		Column6.ReadOnly = .T., ;
		Column6.Width = 149, ;
		Column7.FontSize = 8, ;
		Column7.Name = "Column7", ;
		Column7.ReadOnly = .T.
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="grid" />

	ADD OBJECT 'grdLog.Column1.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "When", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdLog.Column1.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdLog.Column2.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Type", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdLog.Column2.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdLog.Column3.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Table", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdLog.Column3.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdLog.Column4.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Key", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdLog.Column4.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdLog.Column5.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "User Message 1", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdLog.Column5.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdLog.Column6.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "User Message 2", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdLog.Column6.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'grdLog.Column7.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Who", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdLog.Column7.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'lblBeginning' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "\<Begin", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 26, ;
		Name = "lblBeginning", ;
		TabIndex = 1, ;
		Top = 53, ;
		Width = 29
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblEnding' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "\<End", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 302, ;
		Name = "lblEnding", ;
		TabIndex = 3, ;
		Top = 53, ;
		Width = 20
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblFilter' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "Filter", ;
		FontBold = .T., ;
		ForeColor = 255,255,255, ;
		Height = 17, ;
		Left = 416, ;
		Name = "lblFilter", ;
		TabIndex = 14, ;
		Top = 11, ;
		Visible = .F., ;
		Width = 30
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblFilterCriteria' AS fa_label WITH ;
		AutoSize = .T., ;
		Caption = "\<Select Filtering Criteria", ;
		FontBold = .T., ;
		ForeColor = 255,255,255, ;
		Height = 17, ;
		Left = 138, ;
		Name = "lblFilterCriteria", ;
		TabIndex = 17, ;
		Top = 11, ;
		Width = 131
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblRecords' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = "Selected Transaction Log Records ", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 9, ;
		Name = "lblRecords", ;
		TabIndex = 11, ;
		Top = 72, ;
		Width = 194
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblTransactionDates' AS fa_label WITH ;
		BackStyle = 1, ;
		Caption = "Transaction Date Search Range", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 9, ;
		Name = "lblTransactionDates", ;
		TabIndex = 12, ;
		Top = 34, ;
		Width = 172
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'lblUpdateActions' AS fa_label WITH ;
		AutoSize = .T., ;
		BackStyle = 1, ;
		Caption = "Update Actions ", ;
		FontBold = .T., ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 9, ;
		Name = "lblUpdateActions", ;
		TabIndex = 13, ;
		Top = 346, ;
		Width = 88
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="label" />

	ADD OBJECT 'Shape4' AS fa_shape WITH ;
		BackStyle = 1, ;
		BorderStyle = 0, ;
		BorderWidth = 0, ;
		FillColor = 64,128,128, ;
		FillStyle = 0, ;
		Height = 32, ;
		Left = -1, ;
		Name = "Shape4", ;
		SpecialEffect = 0, ;
		Top = 0, ;
		Width = 918
		*< END OBJECT: ClassLib="foxaudit.vcx" BaseClass="shape" />

	ADD OBJECT 'txtBeginDate' AS tpk WITH ;
		ControlSource = "thisform.tbegindate", ;
		Height = 22, ;
		Left = 63, ;
		Name = "txtBeginDate", ;
		Top = 50, ;
		Width = 165
		*< END OBJECT: ClassLib="swdate.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtEndDate' AS tpk WITH ;
		ControlSource = "thisform.tenddate", ;
		Height = 22, ;
		Left = 326, ;
		Name = "txtEndDate", ;
		Top = 50, ;
		Width = 165
		*< END OBJECT: ClassLib="swdate.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		DODEFAULT()
		ON KEY LABEL F1 _screen.ActiveForm.callhelp(_screen.ActiveForm.name)
	ENDPROC

	PROCEDURE buildactionscursor
		******************************************************
		* Method:		BuildActionsCursor
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		LOCAL lnFieldLength
		
		ThisForm.grdActions.RecordSource = "PLACEHOLDER"
		
		IF USED("FA_Actions")
			USE IN FA_Actions
		ENDIF
		
		******************************************************
		* Get the default field length specified in the current
		* FoxAudit object
		******************************************************
		lnFieldLength = THIS.oFoxAudit.iDefFieldLength
		
		******************************************************
		* Create the table which stores the field, original
		* and updated values
		******************************************************
		CREATE CURSOR FA_Actions ;
			(cDataType c(1), ;
			cField c(lnFieldLength), ;
			cOrig c(254), ;
			cUpdated c(254))
			
		ThisForm.grdActions.RecordSource = "FA_ACTIONS"
			
	ENDPROC

	PROCEDURE buildtemplog
		******************************************************
		* Method:		BuildTempLog
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Builds the FA_TempLog cursor which is the Recordsource
		* for the upper grid.
		******************************************************
		LOCAL lcTempLog, ltBegin, ltEnd, lcLogAlias
		lcTempLog= thisform.ctemplog
		ltBegin	= THISFORM.tBeginDate
		ltEnd	= THISFORM.tEndDate
		lcLogAlias = THIS.oFoxAudit.cLogAlias
		
		ThisForm.grdLog.RecordSource = "PLACEHOLDER"
		
		This.LockScreen = .T.
		
		IF USED("FA_TempLog")
			USE IN FA_TempLog
		*	ERASE (thisform.cTempLocation+'_FA*.*')
		ENDIF
		
		SELECT (lcLogAlias)
		
		SELECT ;
			tUpd_When, ;
			cTran_Type, ;
			cTBL_Name, ;
			cRec_Key, ;
			cUserMsg1, ;
			cUserMsg2, ;
			cUpd_Who, ;
			cDBC_Drive, ;
			cDBC_Path, ;
			cDBC_Name, ;
			cTBL_Drive, ;
			cTBL_Path, ;
			mActions, ;
			cKey_Type, ;
			iLog_Key ;
			FROM (lcLogAlias) ;
			WHERE	BETWEEN(tUpd_When,ltBegin,ltEnd) ;
			ORDER BY tUpd_When ;
			INTO CURSOR fa_templog READWRITE 
		
		*!*	IF USED('fa_templog')
		*!*		USE IN fa_templog
		*!*	ENDIF
		
		*!*	USE (lcTempLog) again ALIAS fa_templog IN 0
		
		THISFORM.UpdateCaption()
		
		ThisForm.grdLog.RecordSource = "FA_TEMPLOG"
		
		THISFORM.BuildActionsCursor()
		THISFORM.PopulateActionsCursor()
		THISFORM.ManageButtons()
		
		This.LockScreen = .F.
	ENDPROC

	PROCEDURE buildthermometer
		******************************************************
		* Method:		BuildThermometer
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		LOCAL loThermometer
		
		loThermometer = CREATEOBJECT("FoxAuditThermo")
		loThermometer.TOP = 20
		loThermometer.LEFT = ((_SCREEN.WIDTH - loThermometer.WIDTH) / 2)
		
		RETURN(loThermometer)
		
	ENDPROC

	PROCEDURE callhelp
		LPARAMETERS tcName
		
		IF FILE('helptopic.txt')
		    WAIT WINDOW 'Showing Help Topic for Form: ' + ALLTRIM(tcName)+': ' + TRANSFORM(THIS.HELPCONTEXTID)
		ENDIF
		IF NOT EMPTY(THIS.HELPCONTEXTID)
		    HELP ID THISFORM.HELPCONTEXTID
		ELSE
		    HELP
		ENDIF
		
	ENDPROC

	PROCEDURE copyright		&& Copyright information
		******************************************************************
		* Class: 		ViewLog                          
		******************************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************************
		
		* This software and documentation is protected by U.S. copyright 
		* laws and International treaty provisions.
		
		* Copyright © 1998,1999 Management Smarts, Inc. 
		*  dba TakeNote Computer Consulting
		* All rights reserved
		
		* TakeNote Computer Consulting
		* P.O. Box 99271
		* Raleigh, NC 27624
		* USA
		* (919) 870-9000
		
	ENDPROC

	PROCEDURE Destroy
		******************************************************
		* Method:		Destroy
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Close all temporary tables built while viewing the
		* transaction log
		******************************************************
		LOCAL lcLogAlias, lcMemoAlias
		
		lcLogAlias = THIS.oFoxAudit.cLogAlias
		lcMemoAlias = THIS.oFoxAudit.cMemoAlias
		
		IF USED("FA_TempLog")
		   USE IN FA_TempLog
		ENDIF
		
		IF USED("FA_Actions")
		   USE IN FA_Actions
		ENDIF
		
		IF USED("FA_PrintLog")
		   USE IN FA_PrintLog
		ENDIF
		
		IF USED("PLACEHOLDER")
		   USE IN PLACEHOLDER
		ENDIF
		
		******************************************************
		* Erase all temporary tables built while viewing the
		* transaction log
		******************************************************
		TRY 
		   * PL - PrintLog
		   ERASE (THISFORM.cTempLocation+'_FAPL*.*')		
		   * TL - TempLog
		   ERASE (THISFORM.cTempLocation+'_FATL*.*')		
		CATCH
		ENDTRY 
		
		lcPrevCentury	= THIS.cCentury
		SET CENTURY &lcPrevCentury
		
		THISFORM.oViewField = .NULL.
		
	ENDPROC

	PROCEDURE Error
		******************************************************
		* Method:		Error
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		LPARAMETERS nError, cMethod, nLine
		#DEFINE MB_ICONSTOP	32
		
		LOCAL lcMsgText
		AERROR(laError)
		
		lcMsgText = "An error occured while viewing the transaction log."+CHR(13)+CHR(13)
		lcMsgText = lcMsgText + "Error:   "+ALLTR(STR(nError))+CHR(13)
		lcMsgText = lcMsgText + "Message: "+laError[2]+CHR(13)
		lcMsgText = lcMsgText + "Method:  "+cmethod + CHR(13)
		lcMsgText = lcMsgText + "Line:    "+TRANSFORM(nline)
		
		=MESSAGEBOX(lcMsgText,MB_ICONSTOP,"Error")
		
		THIS.LockScreen = .F.
		
		IF USED("FA_PrintLog")
			USE IN FA_PrintLog
		ENDIF
		ERASE (thisform.cTempLocation+'_FAPL*.*')
		
		RETURN TO MASTER
		
	ENDPROC

	PROCEDURE filtertemplog
		******************************************************
		* Method:		FilterTempLog
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Filters the FA_TempLog cursor based on the selection
		* criteria selected
		******************************************************
		LPARAMETERS tcFilterType, tcFilterValue
		
		LOCAL	lcTempLogLOCAL, ;
			lcLogAlias, ;
			lcMemoAlias
		
		PUBLIC lcFilterValue
		IF EMPTY(tcFilterValue)
			lcFilterValue = " "
		ELSE
			lcFilterValue = ALLTRIM(tcFilterValue)
		ENDIF
		
		lcLogAlias = THIS.oFoxAudit.cLogAlias
		lcMemoAlias = THIS.oFoxAudit.cMemoAlias
		lcTempLog = thisform.ctemplog
		
		WAIT WINDOW "Filtering Transaction Log..." NOWAIT
		
		THIS.LOCKSCREEN = .T.
		ThisForm.grdLog.RecordSource = "PLACEHOLDER"
		
		IF USED("FA_TempLog")
			USE IN FA_TempLog
		*	ERASE (thisform.cTempLocation+'_FA*.*')
		ENDIF
		
		******************************************************
		* Build the table containing the specified log
		* records
		******************************************************
		DO CASE
			CASE UPPER(tcFilterType) = "TRANSTYPE"
				SELECT ;
					tUpd_When, ;
					cTran_Type, ;
					cTBL_Name, ;
					cRec_Key, ;
					cUserMsg1, ;
					cUserMsg2, ;
					cUpd_Who, ;
					cDBC_Drive, ;
					cDBC_Path, ;
					cDBC_Name, ;
					cTBL_Drive, ;
					cTBL_Path, ;
					mActions, ;
					cKey_Type, ;
					iLog_Key ;
					FROM (lcLogAlias) ;
					WHERE	tUpd_When >= THISFORM.txtBeginDate.VALUE AND ;
							tUpd_When <= THISFORM.txtEndDate.VALUE  AND ;
							cTran_Type = lcFilterValue ;
					INTO CURSOR FA_TempLog READWRITE 			
		*			FROM FA_LogTable ;
		
			CASE UPPER(tcFilterType) = "TABLE"
				SELECT ;
					tUpd_When, ;
					cTran_Type, ;
					cTBL_Name, ;
					cRec_Key, ;
					cUserMsg1, ;
					cUserMsg2, ;
					cUpd_Who, ;
					cDBC_Drive, ;
					cDBC_Path, ;
					cDBC_Name, ;
					cTBL_Drive, ;
					cTBL_Path, ;
					mActions, ;
					cKey_Type, ;
					iLog_Key ;
					FROM (lcLogAlias) ;
					WHERE	tUpd_When >= THISFORM.txtBeginDate.VALUE AND ;
							tUpd_When <= THISFORM.txtEndDate.VALUE  AND ;
							cTbl_Name = lcFilterValue ;
					INTO CURSOR FA_TempLog READWRITE 
		
		
		
			CASE UPPER(tcFilterType) = "USER"
				SELECT ;
					tUpd_When, ;
					cTran_Type, ;
					cTBL_Name, ;
					cRec_Key, ;
					cUserMsg1, ;
					cUserMsg2, ;
					cUpd_Who, ;
					cDBC_Drive, ;
					cDBC_Path, ;
					cDBC_Name, ;
					cTBL_Drive, ;
					cTBL_Path, ;
					mActions, ;
					cKey_Type, ;
					iLog_Key ;
					FROM (lcLogAlias) ;
					WHERE	tUpd_When >= THISFORM.txtBeginDate.VALUE AND ;
							tUpd_When <= THISFORM.txtEndDate.VALUE AND ;
							cUpd_Who = lcFilterValue ;
					INTO CURSOR FA_TempLog READWRITE 
		
		
		ENDCASE
		
		THISFORM.UpdateCaption()
		
		ThisForm.grdLog.RecordSource = "FA_TempLog"
		
		THISFORM.BuildActionsCursor()
		THISFORM.PopulateActionsCursor()
		THISFORM.ManageButtons()
		
		THIS.LOCKSCREEN = .F.
		
		WAIT CLEAR
		
	ENDPROC

	PROTECTED PROCEDURE getgridwidths
		******************************************************
		* Method:		GetGridWidths
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Grab the grid widths for the two grids so that they
		* can be set back to the user specified size after
		* filtering the grids
		******************************************************
		IF TYPE("THISFORM.grdLog.Column1") = "O" AND !ISNULL("THISFORM.grdLog.Column1")
			WITH THISFORM
				.nColumn1Width = .grdLog.Column1.Width
				.nColumn2Width = .grdLog.Column2.Width
				.nColumn3Width = .grdLog.Column3.Width
				.nColumn4Width = .grdLog.Column4.Width
				.nColumn5Width = .grdLog.Column5.Width
				.nColumn6Width = .grdLog.Column6.Width
				.nColumn7Width = .grdLog.Column7.Width
			ENDWITH
		
		ENDIF
		
		IF TYPE("THISFORM.grdActions.Column1") = "O" AND !ISNULL("THISFORM.grdActions.Column1")
			WITH THISFORM
				.nColumn1WidthAction = .grdActions.Column1.Width
				.nColumn2WidthAction = .grdActions.Column2.Width
				.nColumn3WidthAction = .grdActions.Column3.Width
				.nColumn4WidthAction = .grdActions.Column4.Width
			ENDWITH
		
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		******************************************************
		* Method:		Init
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		LPARAMETERS toFoxAudit
		
		THIS.oFoxAudit = toFoxAudit
		toFoxAudit = .NULL.
		RELEASE toFoxAudit
		
		* Set up environmental settings
		THIS.cCentury = SET("CENTURY")
		SET CENTURY ON
		SET DELETED ON
		SET TALK OFF
		SET CONFIRM ON
		SET BELL OFF
		SET SAFETY OFF
		
		* Declare LOCAL vars
		LOCAL ;
			lcLogLocation, ;
			lcLogtable, ;
			lnDotLoc, ;
			lcMemoTable, ;
			lcLogAlias, ;
			lcMemoAlias
		
		* Assign LOCAL vars
		lcLogLocation 	= THIS.oFoxAudit.LogLocation()
		lcLogTable		= THIS.oFoxAudit.JustStem(lcLogLocation)
		lcLogAlias		= THIS.oFoxAudit.cLogAlias
		lnDotLoc		= ATC(".",lcLogLocation)
		lcMemoTable		= LEFT(lcLoglocation,(lnDotLoc-1))+"_M.DBF"
		lcMemoAlias		= THIS.oFoxAudit.cMemoAlias
		
		thisform.ctemplogalias = 'fa_templog'
		
		SET DATASESSION TO 1
		* 5/24 added
		lcMemoTable		= THIS.oFoxAudit.JustStem(lcMemoTable)
		
		THISFORM.oFoxAudit.OpenLogTables()
		
		*********************************************************
		* Subtract 1 second from the tUpd_When field in the first
		* record to ensure a unique begining datetime value
		*********************************************************
		SELECT (lcLogAlias)
		LOCATE
		THISFORM.tBeginDate	= EVAL(lcLogAlias+".tUpd_When") - 1
		
		*********************************************************
		* Add 1 second to the tUpd_When field in the last
		* record to ensure a unique ending datetime value
		*********************************************************
		GO BOTTOM
		THISFORM.tEndDate	= EVAL(lcLogAlias+".tUpd_When") + 1
		
		this.ctemplocation = ADDBS(SYS(2023))
		lcTempLog= this.ctemplocation+"_FATL"+RIGHT(SYS(3),3)
		thisform.ctemplog = lctemplog
		SELECT * FROM (lcLogAlias) INTO CURSOR fa_templog READWRITE 
		*!*	COPY STRU TO (lcTempLog)
		*!*	USE (lcTempLog) ALIAS fa_templog IN 0
		
		THISFORM.UpdateCaption()
		THISFORM.SetUpGrid()
		THISFORM.BuildActionsCursor()
		THISFORM.PopulateActionsCursor()
		
	ENDPROC

	PROCEDURE Load
		CREATE CURSOR PLACEHOLDER (MyField c(1))
		
		
	ENDPROC

	PROTECTED PROCEDURE managebuttons		&& Handles enabling and disabling command buttons
		******************************************************
		* Method:		ManageButtons
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Enables/Disables the command buttons on the top of
		* the form
		******************************************************
		IF RECCOUNT("FA_TempLog") = 0
			THISFORM.cmdViewFields.Enabled	= .F.
			THISFORM.cmdPreview.Enabled		= .F.
			THISFORM.cmdPrint.Enabled		= .F.
		ELSE
			THISFORM.cmdViewFields.Enabled	= .T.
			THISFORM.cmdPreview.Enabled		= .T.
			THISFORM.cmdPrint.Enabled		= .T.
		ENDIF
		
	ENDPROC

	PROCEDURE populateactionscursor
		******************************************************
		* Method:		PopulateActionsCursor
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Populates the FA_Actions cursor which is the recordsource
		* for the lower grid
		******************************************************
		LOCAL i, ;
			lcSeparator, ;
			lnSepLoc1, ;
			lnSepLoc2, ;
			lnSepLoc3, ;
			lnSepLoc4, ;
			lcDataType, ;
			lcField, ;
			lcOrg, ;
			lcUpdated, ;
			lnOldMemoWidth, ;
			lmActions, ;
			lnLines, ;
			lcSafety, ;
			lcLine
		
		lnOldMemoWidth = SET("MEMOWIDTH")
		SET MEMOWIDTH TO 500
		
		*******************************************************
		* Character used as the field/value separator
		*******************************************************
		lcSeparator = THIS.oFoxAudit.cSeparator
		
		*******************************************************
		* Location of the first separator
		*******************************************************
		lnSepLoc1 = 2
		
		*******************************************************
		* Capture the contents of the mAction memo field to
		* the lmActions variable
		*******************************************************
		lmActions = EVAL("FA_TempLog.mActions")
		
		*******************************************************
		* Determine how many lines there are in the mActions
		* memo field (ie how many fields need to be updated)
		*******************************************************
		lnLines = MEMLINES(lmActions)
		
		*******************************************************
		* Clear the FA_Actions cursor
		*******************************************************
		lcSafety = SET("SAFETY")
		SET SAFETY OFF
		
		SELECT FA_Actions
		ZAP
		
		SET SAFETY &lcSafety
		
		*******************************************************
		* Loop through each line
		*******************************************************
		FOR i = 1 TO lnLines
		
			****************************************************
			* Grab the line i and store it in lcLine
			****************************************************
			lcLine = MLINE(lmActions, i)
		
			****************************************************
			* Date type of field being rolledback
			****************************************************
			lcDataType = LEFT(lcLine,1)
		
			****************************************************
			* Determine location of the field value separators
			****************************************************
			lnSepLoc2 = ATC(lcSeparator,SUBSTR(lcLine,(lnSepLoc1+1))) + lnSepLoc1
			lnSepLoc3 = ATC(lcSeparator,SUBSTR(lcLine,(lnSepLoc2+1))) + lnSepLoc2
			lnSepLoc4 = LEN(lcLine)
		
			****************************************************
			* Field name of field being rolledback
			****************************************************
			lcField = SUBSTR(lcLine,(lnSepLoc1+1),(lnSepLoc2-(lnSepLoc1+1)))
		
			****************************************************
			* Original field value (pre-updated value)
			****************************************************
			lcOrig = SUBSTR(lcLine,(lnSepLoc2+1),(lnSepLoc3-(lnSepLoc2+1)))
		
			****************************************************
			* Updated field value (post updated value)
			****************************************************
			lcUpdated = SUBSTR(lcLine,(lnSepLoc3+1),(lnSepLoc4-(lnSepLoc3+1)))
		
			INSERT INTO FA_Actions ( ;
					cDataType, ;
					cField, ;
					cOrig, ;
					cUpdated);
					VALUES ( ;
						lcDataType, ;
						lcField, ;
						lcOrig, ;
						lcUpdated)
		
		ENDFOR
		
		THIS.SetUpActionsGrid()
		
		SET MEMOWIDTH TO (lnOldMemoWidth)
		
		SELECT FA_Actions
		LOCATE
		
		ThisForm.grdActions.Refresh()
	ENDPROC

	PROCEDURE populateactionsmemos
		LPARAMETERS tnI
		LOCAL ;
		   lcLine, ;
		   lcOrig, ;
		   lcUpdated, ;
		   lcSeparator, ;
		   lnLines, ;
		   llOrigDone, ;
		   llComplete, ;
		   j, ;
		   lnMemoSep, ;
		   lcField, ;
		   llRecAdded, ;
		   lnSepLoc1, ;
		   lnSepLoc2, ;
		   lnSepLoc3, ;
		   lnSepLoc4, ;
		   lmOrig, ;
		   lmUpdated, ;
		   lnMemoSepLoc
		
		lcSeparator = oFoxAudit.cSeparator
		STORE .F. TO llOrigDone, llComplete, llRecAdded
		STORE "Memo" TO lcOrig, lcUpdated
		
		*******************************************************
		* Determine how many lines there are in the mActions
		* memo field (ie how many fields need to be updated)
		*******************************************************
		lnLines = MEMLINES(FA_TempLog.mActions)
		
		*******************************************************
		* Loop through each line
		*******************************************************
		FOR j = tnI TO lnLines
		   IF llComplete
		      EXIT
		   ENDIF
		
		   ****************************************************
		   * Grab the line i and store it in lcLine
		   ****************************************************
		   lcLine = MLINE(FA_TempLog.mActions, j)
		
		   DO CASE
		      CASE LEN(lcLine) = 0
		         lmOrig = ""
		         lmUpdated = ""
		
		      CASE SUBSTR(lcLine,2,1)  = lcSeparator
		         ****************************************************
		         * Determine location of the field value separators
		         ****************************************************
		         lnSepLoc1 = 2
		         lnSepLoc2 = ATC(lcSeparator,lcLine,2)	&& end of field
		         lnSepLoc3 = ATC(lcSeparator,lcLine,3)	&& orig ~ updated
		         lnSepLoc4 = ATC(lcSeparator,lcLine,4)	&& end
		
		         lcField = SUBSTR(lcLine,(lnSepLoc1+1),(lnSepLoc2-(lnSepLoc1+1)))
		
		         DO CASE
		               * Entire Memo record on one line
		            CASE lnSepLoc3 <> 0 AND lnSepLoc4 <> 0
		               lmOrig		= SUBSTR(lcLine,(lnSepLoc2+1),(lnSepLoc3-(lnSepLoc2+1)))
		               lmUpdated = SUBSTR(lcLine,(lnSepLoc3+1),(lnSepLoc4-(lnSepLoc3+1)))
		               llComplete = .T.
		
		            CASE lnSepLoc3 = 0
		               lmOrig		= SUBSTR(lcLine,(lnSepLoc2+1))
		               lmUpdated = ""
		
		         ENDCASE
		
		      CASE SUBSTR(lcLine,2,1) <> lcSeparator
		
		         lnMemoSepLoc = ATC(lcSeparator,lcLine,1)
		         DO CASE
		            CASE lnMemoSepLoc = 0 AND ! llOrigDone
		               lmOrig = lcLine
		
		            CASE lnMemoSepLoc <> 0 AND ! llOrigDone
		               lmOrig = LEFT(lcLine,(lnMemoSepLoc-1))
		               llOrigDone = .T.
		
		               lnMemoSepLoc2 = ATC(lcSeparator,lcLine,2)
		               IF lnMemoSepLoc2 = 0
		                  lmUpdated = RIGHT(lcLine, (lnMemoSepLoc+1))
		               ELSE
		                  lmUpdated = SUBSTR(lcLine, (lnMemoSepLoc+1),(lnMemoSepLoc2-1))
		                  llComplete = .T.
		               ENDIF
		
		            CASE lnMemoSepLoc = 0 AND llOrigDone
		               lmUpdated = lcLine
		
		            CASE lnMemoSepLoc <> 0 AND llOrigDone
		               lmUpdated = LEFT(lcLine,(lnMemoSepLoc-1))
		               llComplete = .T.
		
		         ENDCASE
		   ENDCASE
		
		   IF tnI = 1 AND ! llRecAdded
		      llRecAdded = .T.
		      APPEND BLANK
		   ENDIF
		
		   REPLACE ;
		      FA_Actions.cDataType	WITH "M", ;
		      FA_Actions.cField		WITH lcField, ;
		      FA_Actions.cOrig		WITH lcOrig, ;
		      FA_Actions.cUpdated	WITH lcUpdated, ;
		      FA_Actions.mOrig		WITH mOrig + lmOrig, ;
		      FA_Actions.mUpdated	WITH mUpdated + lmUpdated
		
		ENDFOR
		
		RETURN(j)
		
	ENDPROC

	PROCEDURE printlogreport
		******************************************************
		* Method:		PrintLogReport
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* The parameter passed specifies if the log report
		* should go to PREVIEW or TO PRINT
		LPARAMETER tcWhere
		
		LOCAL ;
			lnRecNo,;
			lnOldRecNo, ;
			lcMsg, ;
			lcPrintLog, ;
			lcMemoAlias, ;
			lnDTSize, ;
			lnRecKeySize, ;
			lcMsgText, ;
			lnDialogType, ;
			lnIDSize, ;
			lnTranTypeSize, ;
			lnDBCNameSize, ;
			lnTBLNameSize, ;
			lnKeyTypeSize, ;
			lnUpdWhoSize, ;
			loThermometer, ;
			lcRecKey, ;
			lcUpd_When, ;
			lcID, ;
			liLog_Key, ; 
			lnPosition, ;
			lnPcntComplete
		
		AFIELDS(laActions,"FA_Actions")
		lnFieldSize		= laActions(2,3)
		lnOrigSize		= laActions(3,3)
		lnUpdatedSize	= laActions(4,3)
		
		lcMemoAlias = THIS.oFoxAudit.cMemoAlias
		
		******************************************************
		* Define constants
		******************************************************
		#DEFINE MB_YESNO                4       && Yes and No buttons
		#DEFINE MB_ICONQUESTION         32      && Warning query
		#DEFINE IDYES 6
		
		******************************************************
		* Confirm report selection
		******************************************************
		lcMsgText = IIF(tcWhere = "SCREEN","Preview","Print")
		lcMsgText = lcMsgText+" the Transaction Log Report?"
		lnDialogType = MB_ICONQUESTION + MB_YESNO
		
		IF lcMsgText = "Print"
			IF MESSAGEBOX(lcMsgtext, lnDialogType, THIS.oFoxAudit.cMsgBoxTitle) <> IDYES
				RETURN
			ENDIF
		ENDIF
		
		******************************************************
		* The following variables are used on the log report
		******************************************************
		PRIVATE ptBeginDate, ptEndDate, pcTitle
		ptBeginDate	= THISFORM.txtBeginDate.Value
		ptEndDate	= THISFORM.txtEndDate.Value
		pcTitle		= THIS.oFoxAudit.cMsgBoxText
		
		THISFORM.LockScreen = .T.
		
		IF USED("FA_PrintLog")
			USE IN FA_PrintLog
			ERASE (thisform.cTempLocation+'_FAPL*.*')
		ENDIF
		
		******************************************************
		* laTempLog(7,3) will contain the defined size of the
		* cRec_Key field in the log table
		******************************************************
		AFIELDS(laTempLog,"FA_TempLog")
		lnDTSize			= LEN(ALLTRIM(TTOC(DATETIME(),1)))
		lnIDSize			= lnDTSize + laTempLog(4,3)	&& 11 was 7
		lnTranTypeSize	= 1		
		lnDBCDriveSize	= 1		
		lnDBCPathSize	= laTempLog(9,3)
		lnDBCNameSize	= laTempLog(10,3)
		lnTBLDriveSize	= 1		
		lnTBLPathSize	= laTempLog(12,3)
		lnTBLNameSize	= laTempLog(3,3)
		lnKeyTypeSize	= 1		
		lnRecKeySize	= laTempLog(4,3)
		lnUpdWhoSize	= laTempLog(7,3)
		
		AFIELDS(laActions,"FA_Actions")
		lnFieldSize		= laActions(2,3)
		lnOrigSize		= laActions(3,3)
		lnUpdatedSize	= laActions(4,3)
		
		SELECT 0
		lcPrintLog		= thisform.cTempLocation+"_FAPL"+RIGHT(SYS(3),3)
		
		CREATE TABLE (lcPrintLog) FREE;
			(cID c(lnIDSize), ;
			iLog_Key i, ;
			cTran_Type c(lnTranTypeSize), ;
			cDBC_Drive c(lnDBCDriveSize), ;
			cDBC_Path c(lnDBCPathSize), ;
			cDBC_Name c(lnDBCNameSize), ;
			cTBL_Drive c(lnTBLDriveSize), ;
			cTBL_Path c(lnTBLPathSize), ;
			cTBL_Name c(lnTBLNameSize), ;
			cKey_Type c(lnKeyTypeSize), ;	
			cRec_Key c(lnRecKeySize), ;	
			cUpd_Who c(lnUpdWhoSize), ;	
			tUpd_When t, ;
			cDataType c(1), ;
			cField c(lnFieldSize), ;
			cOrig c(lnOrigSize), ;
			cUpdated c(lnUpdatedSize))
		
		IF USED(lcPrintLog)
			SELECT (lcPrintLog)
			USE
		ENDIF
		
		USE (lcPrintLog) EXCLUSIVE ALIAS FA_PrintLog
		INDEX ON	STR(iLog_Key)+ ALLTRIM(cField) TAG Primary
		INDEX ON	cID TAG cID
		
		
		loThermometer = THISFORM.BuildThermometer()
		lcMsg = "Formatting and preparing to print log entries..."
		loThermometer.UpdateBar(0,lcMsg)
		loThermometer.Show()
		
		SELECT FA_TempLog
		lnOldRecNo = RECNO()
		lnRecCount = RECCOUNT()
		
		GO TOP
		SCAN
			lcRecKey		= ALLTRIM(FA_TempLog.cRec_Key)
			lcUpd_When		= ALLTRIM(TTOC(FA_TempLog.tUpd_When,1))
			lcID			= lcRecKey+lcUpd_When
			liLog_Key		= FA_TempLog.iLog_Key
			lnPosition		= RECNO()
			lnPcntComplete	= ((lnPosition/lnRecCount)*100)
			loThermometer.UpdateBar(lnPcntComplete)
		
			SELECT FA_PrintLog
			THISFORM.PopulateActionsCursor()
			SELECT FA_Actions
			GO TOP
		
			SCAN
				SELECT FA_PrintLog
		
				INSERT INTO FA_PrintLog ( ;
					cID, ;
					iLog_Key, ;
					cTran_Type, ;
					cDBC_Drive, ;
					cDBC_Path, ;
					cDBC_Name, ;
					cTBL_Drive, ;
					cTBL_Path, ;
					cTBL_Name, ;
					cKey_Type, ;
					cRec_Key, ;
					cUpd_Who, ;
					tUpd_When, ;
					cDataType, ;
					cField,	;
					cOrig, ;
					cUpdated) ;
					VALUES ( ;
						lcID, ;
						liLog_Key, ;
						FA_TempLog.cTran_Type, ;
						FA_TempLog.cDBC_Drive, ;
						FA_TempLog.cDBC_Path, ;
						FA_TempLog.cDBC_Name, ;
						FA_TempLog.cTBL_Drive, ;
						FA_TempLog.cTBL_Path, ;
						FA_TempLog.cTBL_Name, ;
						FA_TempLog.cKey_Type, ;
						FA_TempLog.cRec_Key, ;
						FA_TempLog.cUpd_Who, ;
						FA_TempLog.tUpd_When, ;
						FA_Actions.cDataType, ;
						FA_Actions.cField, ;
						FA_Actions.cOrig, ;
						FA_Actions.cUpdated)
		
				SELECT FA_Actions
			ENDSCAN
		
			SELECT FA_TempLog
		ENDSCAN
		
		STORE "" TO lcSQL_1, lcSQL_2, lcSQL_3, lcSQL_4, lcSQL_5
		
		lcPrintLog = thisform.cTempLocation+"_FAPL"+RIGHT(SYS(3),3)
		lcSQL_1 = "SELECT FA_PrintLog.cID,FA_PrintLog.iLog_Key,FA_PrintLog.cTran_Type,"
		lcSQL_1 = lcSQL_1 + "FA_PrintLog.cDBC_Drive,FA_PrintLog.cDBC_Path,FA_PrintLog.cDBC_Name,"
		lcSQL_1 = lcSQL_1 + "FA_PrintLog.cTBL_Drive,FA_PrintLog.cTBL_Path, FA_PrintLog.cTBL_Name,"
		lcSQL_2 = lcSQL_2 + "FA_PrintLog.cKey_Type,FA_PrintLog.cRec_Key,FA_PrintLog.cUpd_Who,"
		lcSQL_2 = lcSQL_2 + "FA_PrintLog.tUpd_When,FA_PrintLog.cDataType,FA_PrintLog.cField,"
		lcSQL_2 = lcSQL_2 + "FA_PrintLog.cOrig,FA_PrintLog.cUpdated,"
		lcSQL_3 = lcSQL_3 + ALLTRIM(lcMemoAlias)+".mOrig,"
		lcSQL_3 = lcSQL_3 + ALLTRIM(lcMemoAlias)+".mUpdated "
		lcSQL_3 = lcSQL_3 + "FROM FA_PrintLog LEFT OUTER JOIN "+ALLTRIM(lcMemoAlias)+" "
		lcSQL_4 = lcSQL_4 + "ON STR(FA_PrintLog.iLog_Key)+ ALLTRIM(FA_PrintLog.cField) = "
		lcSQL_5 = lcSQL_5 + "STR("+ALLTRIM(lcMemoAlias)+".iLog_Key)+ALLTRIM("+ALLTRIM(lcMemoAlias)+".cField) "
		lcSQL_5 = lcSQL_5 + "ORDER BY 9, 2, 11 INTO cursor tempPrintLog"
		
		lcSQLCmd = lcSQL_1 + lcSQL_2 + lcSQL_3 + lcSQL_4+lcSQL_5
		&lcSQLCmd.
		
		USE IN FA_PrintLog
		SELECT tempprintlog
		
		DO CASE
			CASE UPPER(tcWhere) = "SCREEN"
		
				REPORT FORM FA_LogRp PREVIEW NOCONSOLE
		
			CASE UPPER(tcWhere) = "PRINTER"
			
				REPORT FORM FA_LogRp TO PRINT PROMPT NOCONSOLE
				
		ENDCASE
		
		IF USED(lcPrintLog)
			USE IN (lcPrintLog)
			ERASE (thisform.cTempLocation+'_FAPL*.*')
		ENDIF
		
		RELEASE ptBeginDate, ptEndDate, pcTitle
		
		SELECT FA_TempLog
		GO (lnOldRecNo)
		THISFORM.PopulateActionsCursor()
		
		THISFORM.LockScreen = .F.
	ENDPROC

	PROCEDURE readme		&& Information about working with this class
		***************************************************
		* Method:		ReadMe
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* The ViewLog form displays transaction log records.
		* It is called from the FoxAudit object by calling the
		* ViewLog method.
		*
		* Example: oFoxAudit.ViewLog()
		
	ENDPROC

	PROCEDURE setupactionsgrid
		******************************************************
		* Method:		SetUpActionsGrid
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Sets the ControlSOurce properties for the lower grid
		******************************************************
		WITH THISFORM.grdActions
			IF NOT .Column3.ControlSource = "SPACE(1)"
				.Refresh()
				RETURN
			ENDIF
		
			.RecordSource = "FA_Actions"
				
			.Column1.ControlSource = "FA_Actions.cDataType"
			.Column1.Header1.Caption = "Type"
			
			.Column2.ControlSource = "FA_Actions.cField"
			.Column2.Header1.Caption = "Field"
		
			.Column3.ControlSource = "FA_Actions.cOrig"
			.Column3.Header1.Caption = "Original Value"
		
			.Column4.ControlSource = "FA_Actions.cUpdated"
			.Column4.Header1.Caption = "Updated Value"
		
		ENDWITH
		
		SELECT FA_Actions
		LOCATE
	ENDPROC

	PROTECTED PROCEDURE setupgrid
		******************************************************
		* Method:		SetUpGrid
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Sets a number of properties for the upper grid
		******************************************************
		WITH THISFORM.grdLog
			IF NOT .Column4.ControlSource = "SPACE(1)"
				RETURN
			ENDIF
			
			.RecordSource = "FA_TempLog"
			.ReadOnly = .T.
			.Column1.ControlSource = "FA_TempLog.tUpd_When"
			.Column2.ControlSource = "FA_TempLog.cTran_Type"
			.Column3.ControlSource = "FA_TempLog.cTbl_Name"
			.Column4.ControlSource = "FA_TempLog.cRec_Key"
			.Column5.ControlSource = "FA_TempLog.cUserMsg1"
			.Column6.ControlSource = "FA_TempLog.cUserMsg2"
			.Column7.ControlSource = "FA_TempLog.cUpd_Who"
		ENDWITH
		
		RETURN
		
		IF !THISFORM.lSetColWidths
			WITH THISFORM.grdLog
				.Column1.Width = 30
				.Column2.Width = 30
				.Column3.Width = 70
				.Column4.Width = 70
				.Column5.Width = 30
				.Column6.Width = 70
				.Column7.Width = 70
			ENDWITH
			WITH THISFORM
				.nColumn1Width = .grdLog.Column1.Width
				.nColumn2Width = .grdLog.Column2.Width
				.nColumn3Width = .grdLog.Column3.Width
				.nColumn4Width = .grdLog.Column4.Width
				.nColumn5Width = .grdLog.Column5.Width
				.nColumn6Width = .grdLog.Column6.Width
				.nColumn7Width = .grdLog.Column7.Width
			ENDWITH
		
			THISFORM.lSetColWidths = .T.
		ENDI
		
		WITH THISFORM
			.grdLog.Column1.Width = .nColumn1Width
			.grdLog.Column2.Width = .nColumn2Width
			.grdLog.Column3.Width = .nColumn3Width
			.grdLog.Column4.Width = .nColumn4Width
			.grdLog.Column5.Width = .nColumn5Width
			.grdLog.Column6.Width = .nColumn6Width
			.grdLog.Column7.Width = .nColumn7Width
		ENDWITH
		
		
	ENDPROC

	PROCEDURE updatecaption
		******************************************************
		* Method:		UpdateCaption
		******************************************************
		* Author:		Jim Duffy
		* Date:			5/22/1998
		* Copyright:	© 1998, 1999 TakeNote Computer Consulting
		*				http://www.takenote.com
		*				All rights reserved
		******************************************************
		* Based on the number of records selected by the
		* filtering process, displays a xxx of xxx total log
		* records message in the form's caption
		******************************************************
		LOCAL lcLogRecs, lcTempRecs
		
		IF NOT USED(this.ofoxaudit.clogalias) OR NOT USED('fa_templog')
		   RETURN
		ENDIF 
		lcLogRecs = ALLTRIM(TRANSFORM(RECCOUNT(THIS.oFoxAudit.cLogAlias),"9,999,999"))
		
		lcTempRecs = ALLTRIM(TRANSFORM(RECCOUNT('fa_templog'),"9,999,999"))
		
		THISFORM.CAPTION = "View Transaction Log - " + lcTempRecs +" of " + ;
		   lcLogRecs + " log records currently displayed"
		
	ENDPROC

	PROCEDURE cmdClose.Click
		RELEASE THISFORM
	ENDPROC

	PROCEDURE cmdPreview.Click
		#DEFINE MB_ICONINFORMATION 16
		LOCAL lcMsgText, lnDialogType
		lcMsgText = "Beginning date must be equal to or before end date"
		lnDialogType = MB_ICONINFORMATION
		lcMsgTitle = THISFORM.oFoxAudit.cMsgBoxTitle
		
		IF THISFORM.txtBeginDate.VALUE > THISFORM.txtEndDate.VALUE
			MESSAGEBOX(lcMsgText, lnDialogType, lcMsgTitle)
			RETURN
		ENDIF
		
		THISFORM.PrintLogReport("SCREEN")
		
		#UNDEFINE MB_ICONINFORMATION
		
	ENDPROC

	PROCEDURE cmdPrint.Click
		#DEFINE MB_ICONINFORMATION 16
		LOCAL lcMsgText, lnDialogType
		lcMsgText = "Beginning date must be equal to or before end date"
		lnDialogType = MB_ICONINFORMATION
		lcMsgTitle = THISFORM.oFoxAudit.cMsgBoxTitle
		
		IF THISFORM.txtBeginDate.VALUE > THISFORM.txtEndDate.VALUE
			=MESSAGEBOX(lcMsgText, lnDialogType, lcMsgTitle)
			RETURN
		ENDIF
		
		THISFORM.PrintLogReport("PRINTER")
		
		#UNDEFINE MB_ICONINFORMATION
		
		
	ENDPROC

	PROCEDURE cmdSearch.Click
		#DEFINE MB_ICONINFORMATION 16
		LOCAL lcMsgText, lnDialogType
		lcMsgText = "Beginning date must be equal to or before end date"
		lnDialogType = MB_ICONINFORMATION
		lcMsgTitle = THISFORM.oFoxAudit.cMsgBoxTitle
		
		WITH THISFORM
		
		   IF .txtBeginDate.VALUE > .txtEndDate.VALUE
		      MESSAGEBOX(lcMsgText, lnDialogType, lcMsgTitle)
		      RETURN
		   ENDIF
		   .ddlCriteria.VALUE			= "None"
		   .ddlTable.VISIBLE			= .F.
		   .ddlUser.VISIBLE				= .F.
		   .ddlTransactionType.VISIBLE	= .F.
		   .lblFilter.VISIBLE			= .F.
		
		   .BuildTempLog()
		
		ENDWITH
		
		#UNDEFINE MB_ICONINFORMATION
		
	ENDPROC

	PROCEDURE cmdSearchLog.Click
		#DEFINE MB_ICONINFORMATION 16
		LOCAL lcMsgText, lnDialogType
		lcMsgText = "Beginning date must be equal to or before end date"
		lnDialogType = MB_ICONINFORMATION
		lcMsgTitle = THISFORM.oFoxAudit.cMsgBoxTitle
		
		WITH THISFORM
		
		   IF .txtBeginDate.VALUE > .txtEndDate.VALUE
		      MESSAGEBOX(lcMsgText, lnDialogType, lcMsgTitle)
		      RETURN
		   ENDIF
		   .ddlCriteria.VALUE				= "None"
		   .ddlTable.VISIBLE					= .F.
		   .ddlUser.VISIBLE					= .F.
		   .ddlTransactionType.VISIBLE	= .F.
		   .lblFilter.VISIBLE				= .F.
		
		   .BuildTempLog()
		
		ENDWITH
		
		#UNDEFINE MB_ICONINFORMATION
		
	ENDPROC

	PROCEDURE cmdViewFields.Click
		LOCAL liKey
		liKey = FA_TempLog.iLog_Key
		
		THISFORM.oViewField = .NULL.
		THISFORM.oViewField = CREATEOBJECT("ViewField","FA_Actions",liKey,THISFORM.oFoxAudit.cMemoAlias)
		THISFORM.oViewField.SHOW(1)
		
		THISFORM.oViewField = .NULL.
	ENDPROC

	PROCEDURE ddlCriteria.InteractiveChange
		LOCAL lcSelection, lcLogAlias, lcMemoAlias
		
		lcSelection = UPPER(ALLTRIM(THIS.VALUE))
		lcLogAlias = THISFORM.oFoxAudit.cLogAlias
		lcMemoAlias = THISFORM.oFoxAudit.cMemoAlias
		
		DO CASE
			CASE lcSelection = "NONE"
				WITH THISFORM
					.lblFilter.Caption = ""
					.lblFilter.Visible = .F.
					.ddlTransactionType.Visible = .F.
					.ddlUser.Visible = .F.
					.ddlTable.Visible = .F.
				ENDWITH
		
				THISFORM.BuildTempLog()
			
			CASE lcSelection = "BY TRANSACTION TYPE"
				WITH THISFORM
					.lblFilter.Caption = "Transaction Type"
					.lblFilter.Visible = .T.
					.ddlTransactionType.Value = ""
		*			.ddlTransactionType.Value = "All"
					.ddlTransactionType.Visible = .T.
					.ddlTransactionType.SetFocus()
					.ddlUser.Visible = .F.
					.ddlTable.Visible = .F.
				ENDWITH
		
			CASE lcSelection = "BY TABLE"
				WITH THISFORM
					.lblFilter.Caption = "Table"
					.lblFilter.Visible = .T.
					.ddlTable.Visible = .T.
					.ddlTable.SetFocus()
					.ddlTransactionType.Visible = .F.
					.ddlUser.Visible = .F.
		
					IF ! USED("csrTables")
						SELECT (ALLTRIM(cTbl_Name)) ;
							FROM (lcLogAlias) ;
							ORDER BY 1 ;
							GROUP BY 1 ;
							INTO CURSOR csrTables
						.ddlTable.RowSourceType = 2
						.ddlTable.RowSource = "csrTables"
					ENDIF
		
				ENDWITH
		
			CASE lcSelection = "BY USER"
				WITH THISFORM
					.lblFilter.Caption = "User"
					.lblFilter.Visible = .T.
					.ddlUser.Visible = .T.
					.ddlUser.SetFocus()
					.ddlTransactionType.Visible = .F.
					.ddlTable.Visible = .F.
				
					IF ! USED("csrUsers")
						SELECT cUpd_Who ;
							FROM (lcLogAlias) ;
							ORDER BY 1 ;
							GROUP BY 1 ;
							INTO CURSOR csrUsers
						.ddlUser.RowSourceType = 2
						.ddlUser.RowSource = "csrUsers"
					ENDIF
					
				ENDWITH
		ENDCASE
	ENDPROC

	PROCEDURE ddlTable.Destroy
		IF USED("csrTables")
			USE IN csrTables
		ENDIF
	ENDPROC

	PROCEDURE ddlTable.Valid
		LOCAL lcSend
		lcSend = THIS.VALUE
		THISFORM.FilterTempLog("TABLE",lcSend)
		
	ENDPROC

	PROCEDURE ddlTransactionType.Valid
		LOCAL lcSend
		
		lcSend = IIF(THIS.VALUE = "All","A",LEFT(THIS.Value,1))
		THISFORM.FilterTempLog("TransType",lcSend)
		
	ENDPROC

	PROCEDURE ddlUser.Destroy
		IF USED("csrUsers")
			USE IN csrUsers
		ENDIF
	ENDPROC

	PROCEDURE ddlUser.Valid
		LOCAL lcSend
		lcSend = THIS.VALUE
		THISFORM.FilterTempLog("USER",lcSend)
		
	ENDPROC

	PROCEDURE grdActions.DblClick
		ThisForm.cmdViewFields.Click()
	ENDPROC

	PROCEDURE grdLog.AfterRowColChange
		LPARAMETERS nColIndex
		
		DODEFAULT()
		
		THISFORM.PopulateActionsCursor()
		
		
	ENDPROC

	PROCEDURE txtEndDate.LostFocus
		thisform.cmdsearch.Click()
	ENDPROC

ENDDEFINE
