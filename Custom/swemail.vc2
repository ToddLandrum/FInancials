*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="swemail.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS swcdo AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: createsession		&& Create configuration and mail objects and if Outlook express is not installed, try and get info from the registry
		*m: getsmtpinfo		&& If Outlook express or IIS is not installed, configuration info cannot be loaded automatically. Must try to do it using the registry
		*m: sendmail		&& Create and send a message
		*m: str2exp		&& Given a string expression and a data type, returns the converted value
		*p: oconfig		&& The CDO Configuration object
		*p: omsg		&& Hold the CDO message object
	*</DefinedPropArrayMethod>

	Height = 33
	Name = "cuscdo"
	oconfig = .NULL.		&& The CDO Configuration object
	omsg = .NULL.		&& Hold the CDO message object
	Width = 43
	
	PROCEDURE createsession		&& Create configuration and mail objects and if Outlook express is not installed, try and get info from the registry
		LOCAL loInfo, llRetVal
		
		WITH This
			*** create configuration and message objects
			.oConfig = CREATEOBJECT( 'CDO.Configuration' )
			IF TYPE( 'This.oConfig' ) = 'O'
				*** Check to see if we have configuration infomation
				IF NOT EMPTY( NVL( .oConfig.Fields( "http://schemas.microsoft.com/cdo/configuration/smtpserver").value, "" ) )            
					llRetVal = .T.
				ELSE
		      *** Manually set Configuration properties
		      *** using the CdoConfig table
					llRetVal = This.GetSmtpInfo()
				ENDIF
			ENDIF
			IF llretVal
				.oMsg = CREATEOBJECT( 'CDO.Message' )
		    llretVal = IIF( TYPE( 'This.oMsg' ) = 'O', .T., .F. )	
		  ENDIF
		ENDWITH
		
		RETURN llRetVal
		
	ENDPROC

	PROCEDURE Destroy
		*** Clean up
		WITH THIS
			.oMsg = .NULL.
			.oConfig = .NULL.
		ENDWITH
	ENDPROC

	PROCEDURE getsmtpinfo		&& If Outlook express or IIS is not installed, configuration info cannot be loaded automatically. Must try to do it using the registry
		LOCAL lcFieldName
		*** This is a template method
		*** If you do not have outlook express installed
		*** and configured as an e-mail client or IIS installed and configured
		*** You will have to load the seetings for your remote SMTP server here
		*** and manually configure the CDO.Configuration object
		*** You can read the required values from CdoConfig.dbf, supplied with this example
		IF NOT FILE( 'CdoConfig.dbf' )
		    RETURN .F.
		ENDIF
		
		IF NOT USED( 'CdoConfig' )
		  USE CdoConfig AGAIN IN 0
		ENDIF
		SELECT CdoConfig
		SCAN
		  IF NOT EMPTY( CdoConfig.cVal )
		    lcFieldName = ALLTRIM( cdoConfig.cFld )
		    This.oConfig.Fields( lcFieldName ).Value = This.Str2Exp( ALLTRIM( CdoConfig.cVal ), cType )
		  ENDIF
		ENDSCAN
		This.oConfig.Fields.Update
		USE IN CdoConfig
		
		
	ENDPROC

	PROCEDURE Init
		LOCAL llretVal
		
		llRetVal = DODEFAULT()
		IF llretVal
			llRetVal = This.CreateSession()
		ENDIF
		RETURN llretVal
		
		
	ENDPROC

	PROCEDURE sendmail		&& Create and send a message
		LPARAMETERS toParms
		#DEFINE cdoSendEmailAddress    "http://schemas.microsoft.com/cdo/configuration/sendemailaddress"    
		
		LOCAL lnCnt, lnLen
		
		*** Make sure We have enough info to send the message
		WITH toParms
			IF EMPTY( .cTo ) AND EMPTY( .cCC ) AND EMPTY(.cBcc )
				*** Must have at least one recipient
				ASSERT .F. MESSAGE 'You must specify at least one recipient'
				RETURN .F.
			ENDIF
			IF EMPTY( .cSubject )
				*** Must have a subject line
				ASSERT .F. MESSAGE 'You must specify a subject for the message'
				RETURN .F.
			ENDIF
		ENDWITH
		
		WITH This
			WITH .oMsg
				.Configuration = This.oConfig
				*** See if we have a sender address. 
				*** If we manually loaded the config, we may not
				IF EMPTY( NVL( .From, "" ) )
					.From = .Configuration.Fields( cdoSendEmailAddress ).value
				ENDIF
				.To = ALLTRIM( toParms.cTo )
				.CC = ALLTRIM( toParms.cCC )
				.Bcc = ALLTRIM(toParms.cBcc )
		    .Subject = ALLTRIM( toParms.cSubject )
		    *** See if we are sending a web page in the body of the message
		    IF NOT EMPTY( toParms.cURL )
		    		.CreateMHTMLBody( ALLTRIM( toParms.cURL ) )
		    	ENDIF
		  		*** Add any message text to the beginning of the body
				.HTMLBody = toParms.cHTMLBody + .HTMLBody 
				*** Add any attachments
				IF NOT EMPTY( toParms.aAttachments[ 1 ] )
					lnLen = ALEN( toParms.aAttachments, 1 )
					FOR lnCnt = 1 TO lnLen
						.AddAttachment( ALLTRIM( toParms.aAttachments[ lnCnt ] ) )
					ENDFOR
				ENDIF
		    .Send()
			ENDWITH
		ENDWITH
		
		
	ENDPROC

	PROCEDURE str2exp		&& Given a string expression and a data type, returns the converted value
		LPARAMETERS tcExp, tcType
		LOCAL lcExp, luRetVal, lcType, lcStr
		
		*** Verify parameters
		IF VARTYPE( tcExp ) # 'C'
		    ASSERT .F. MESSAGE TRANSFORM( tcExp ) + ' is NOT a character expression and you MUST pass a character expression to Str2Exp!'
		    RETURN tcExp
		ENDIF
		IF EMPTY( tcType )
		    ASSERT .F. MESSAGE 'You MUST pass a data type to Str2Exp!'
		    RETURN tcExp
		ENDIF
		
		*** If no type passed -- map to expression type
		lcType = UPPER( ALLTRIM( tcType ) )
		*** Remove any NULL characters, and leading/trailing spaces
		lcExp = CHRTRAN( ALLTRIM( tcExp ), CHR( 0 ), '' )
		*** Convert from Character to the correct type
		DO CASE
		  *** Integers
		  CASE INLIST( lcType, 'I', 'N' ) AND INT( VAL( lcExp ) ) == VAL( lcExp ) 
		    luRetVal = INT( VAL( lcExp ) )
		  *** Other Numeric 
		  CASE INLIST( lcType, 'N', 'B' )
		    luRetVal = VAL( lcExp )
		  *** Currency
		  CASE lcType = "Y"
		    luRetVal = NTOM( VAL( lcExp ))
		  *** Character or memo
		  CASE INLIST( lcType, 'C', 'M' ) 
		    *** Remove delimiting marks if present.
		    IF INLIST( LEFT(lcExp,1), CHR(91), CHR(34), CHR(39))
		      *** We begin with a delimiter
		      lcExp = SUBSTR( lcExp, 2 )
		      *** So we should end with a delimiter
		      IF INLIST( RIGHT(lcExp,1), CHR(93), CHR(34), CHR(39))
		        lcExp = LEFT( lcExp, LEN( lcExp )- 1 )
		      ENDIF
		    ENDIF
		    luRetVal = lcExp
		  *** Logical
		  CASE lcType = 'L'
		    luRetVal = IIF( !EMPTY( CHRTRAN( lcExp, 'Ff0.', "" ) ), .T., .F.)
		  *** Date
		  CASE lcType = 'D' && Date
		    *** Check for separators in the string
		    IF CHRTRAN( lcExp, "/.-", "" ) == lcExp
		      *** We are in yyyymmdd format
		      lcStr = LEFT( lcExp, 4) + "," + SUBSTR( lcExp, 5, 2 ) + "," + RIGHT( lcExp, 2)
		      luRetVal = DATE( &lcStr )
		    ELSE
		      *** We are in DTOC() format
		      luRetVal = CTOD( lcExp )
		    ENDIF
		  *** DateTime
		  CASE lcType = 'T' && DateTime 
		    *** Check for date separators in the string
		    IF CHRTRAN( lcExp, "/.-", "" ) == lcExp
		      *** No separators so we have something other than TTOC() format
		      IF LEN( lcExp ) > 8
		        *** This one must be in yyyymmddhhmmss format
		        *** So get the date part first
		        lcStr = LEFT( lcExp, 4) + "," + SUBSTR( lcExp, 5, 2 ) + "," + SUBSTR( lcExp, 7, 2)
		        *** and convert to the correct date string format
		        lcStr = DTOC( DATE( &lcStr ))
		        *** Now tack on the hours part
		        lcStr = lcStr + " " + SUBSTR( lcExp, 9, 2 )
		        *** Minutes
		        IF LEN( lcExp ) > 10
		          lcStr = lcStr + ":" + SUBSTR( lcExp, 11, 2 )
		        ELSE
		          lcStr = lcStr + ":00"
		        ENDIF
		        *** Seconds
		        IF LEN( lcExp ) > 12
		          lcStr = lcStr + ":" + SUBSTR( lcExp, 13, 2 )
		        ELSE
		          lcStr = lcStr + ":00"
		        ENDIF
		        luRetVal = CTOT( lcStr )
		      ELSE  
		        *** This must be a date in yyyymmdd format which we want to force to DateTime format
		        lcStr = LEFT( lcExp, 4) + "," + SUBSTR( lcExp, 5, 2 ) + "," + RIGHT( lcExp, 2)
		        luRetVal = DTOT( DATE( &lcStr )) 
		      ENDIF
		    ELSE
		      *** We are already in TTOC() format
		      luRetVal = CTOT( lcExp )
		    ENDIF
		
		  OTHERWISE
		    *** We have an invalid combination of value and data type
		    MESSAGEBOX( "Cannot convert " + lcExp + " to Data Type " + tcType, 16, "Conversion Failed " )
		    luRetVal = lcExp
		ENDCASE
		*** Return value as Data Type
		RETURN luRetVal
		
	ENDPROC

ENDDEFINE

DEFINE CLASS swcdoparms AS line 		&& Parameter object to send to the cusCDOMail object. It's properties are used to creat and send the message
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cbcc		&& The RFC 822 Bcc header field for the message. Identifies blind carbon copy recipients for the message.
		*p: ccc		&& The RFC 822 CC header field for the message. Identifies secondary or carbon copy recipients for the message.
		*p: cfrom		&& The RFC 822 From: header field for the message. Identifies the sender of the message.
		*p: chtmlbody		&& The Hypertext Markup Language (HTML) representation of the message.
		*p: csender		&& The RFC 822 Sender header field for the message. Identifies the person or entity that actually submitted the message if this person or entity is not the sole identity in the From header.
		*p: csubject		&& The RFC 822 Subject: header field for the message. Identifies the subject of the message
		*p: cto		&& The RFC 822 To: header field for the message. Identifies the primary recipients of the message.
		*p: curl		&& Used by the CDO,message object's CreateMHTMLBody method to convert the contents of an entire Web page into a MIME Encapsulation of Aggregate HTML Documents (MHTML) formatted message body.
		*a: aattachments[1,0]		&& An array of file names to attch to the message
	*</DefinedPropArrayMethod>

	cbcc = 		&& The RFC 822 Bcc header field for the message. Identifies blind carbon copy recipients for the message.
	ccc = 		&& The RFC 822 CC header field for the message. Identifies secondary or carbon copy recipients for the message.
	cfrom = 		&& The RFC 822 From: header field for the message. Identifies the sender of the message.
	chtmlbody = 		&& The Hypertext Markup Language (HTML) representation of the message.
	csender = 		&& The RFC 822 Sender header field for the message. Identifies the person or entity that actually submitted the message if this person or entity is not the sole identity in the From header.
	csubject = 		&& The RFC 822 Subject: header field for the message. Identifies the subject of the message
	cto = 		&& The RFC 822 To: header field for the message. Identifies the primary recipients of the message.
	curl = 		&& Used by the CDO,message object's CreateMHTMLBody method to convert the contents of an entire Web page into a MIME Encapsulation of Aggregate HTML Documents (MHTML) formatted message body.
	Height = 17
	Name = "cdoparms"
	Visible = .F.
	Width = 100

ENDDEFINE

DEFINE CLASS swoutlook AS custom 		&& A custom class for automating outlook 2000. Includes functionality to read and send e-mail
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "msoutl9.h"
	*<DefinedPropArrayMethod>
		*m: addcontact		&& Adds the SherWare contact to the Outlook address book
		*m: buildfilter		&& Based on the properties of the Read Parameter object, builds the filter condition for retrieveing messages from the inbox
		*m: createsession		&& Instantiate outlook and logon
		*m: deletemessage		&& Deletes aMsgs[ This.nCurrentMsg ] from the array as well as from the outlok inbox
		*m: getattachmentcount		&& Returns the number of attachments that the current message has
		*m: getattachmentfile		&& Passed the index into a message's attachments collection, returns the fully qualified file name of that attachment (if it exists)
		*m: getbodytext		&& Returns the text of the current message
		*m: getcontacts		&& Gets the names and e-mail addresses from contacts into an array
		*m: getdatereceived		&& Returns the date the message was received
		*m: getfirstmsg		&& Sets the class's nCurrentMsg property to 1
		*m: getlastmsg		&& Sets the class's nCurrentMsg property to the length of the aMsgs array
		*m: getmsg		&& Given an Index into the aMsgs array, sets the internal nCurrentMsg property so we know which message we are operating on
		*m: getnextmsg		&& Increments the class's nCurrentMsg by 1
		*m: getpriormsg		&& Decrements the class's nCurrentMsg by 1
		*m: getsender		&& Returns the message sender
		*m: getsubject		&& Returns the subject line for the current message
		*m: readmail		&& Vased on the parameters passed, accesses the Outlook Inbox and retrieves the messages that satisfy the filter requirements
		*m: saveattachment		&& Saves the spcified attachment in the current message to the specified file name
		*m: sendmail		&& Passed a parameter object that contains the message info, creates it, adds the attachments Iif any) and send it
		*p: ncurrentmsg		&& Points to the current message in the internal aMsgs array
		*p: onamespace		&& Object reference to the MAPI namespace object in Outlook from which you reference all the other objects (like the inbox)
		*p: ooutlook		&& Object reference to the outlook application object
		*a: acontacts[1,3]		&& array to hold contact names and e-mail address
		*a: amsgs[1,0]		&& Holds all the messages that fit the search criteria (an array of message objects)
	*</DefinedPropArrayMethod>

	Height = 25
	Name = "swoutlook"
	ncurrentmsg = 0		&& Points to the current message in the internal aMsgs array
	onamespace = .NULL.		&& Object reference to the MAPI namespace object in Outlook from which you reference all the other objects (like the inbox)
	ooutlook = .NULL.		&& Object reference to the outlook application object
	Width = 50
	
	PROCEDURE addcontact		&& Adds the SherWare contact to the Outlook address book
		LOCAL oContact
		
		oContact = this.oOutlook.CreateItem( 2 )
		
		IF VARTYPE(oContact) = 'O' AND NOT ISNULL(oContact)
		   WITH oContact
		       .FullName = 'SherWare Support'
		       .CompanyName = 'SherWare, Inc.'
		       .BusinessAddressStreet = 'PO Box 209'
		       .BusinessAddressCity   = 'Apple Creek'
		       .BusinessAddressState  = 'OH'
		       .BusinessAddressPostalCode = '44606'
		       .BusinessAddressCountry = 'USA'
		       .SelectedMailingAddress = 2
		       .BusinessTelephoneNumber = '(330) 682-0137'
		       .Email1Address = 'support@sherware.com'
		       .Save()
		    ENDWITH
		ENDIF 
	ENDPROC

	PROCEDURE buildfilter		&& Based on the properties of the Read Parameter object, builds the filter condition for retrieveing messages from the inbox
		LPARAMETERS toReadParms
		LOCAL lcFilter, lcDateExp
		
		lcFilter = ""
		*** Start building the filter condition
		WITH toReadParms
			*** First see if we want unread items only
			IF .lUnreadOnly
				lcFilter = "[Unread] = True "
			ENDIF
			*** Now Check for the sender
			IF NOT EMPTY( .cSender )
				lcFilter = lcFilter + IIF( NOT EMPTY( lcFilter ), "AND ", "" ) + "[From] = '" + ALLTRIM( .cSender ) + "' "
			ENDIF
			*** Finally a date range
			lcDateExp = ""
			IF NOT EMPTY( .dFromDate ) AND NOT EMPTY( .dToDate )
				lcDateExp = "[ReceivedTime] > '" + DTOC( .dFromDate - 1 ) + "' AND [ReceivedTime] < '" + DTOC( .dToDate + 1 ) + "'"
			ELSE
				IF NOT EMPTY( .dFromDate ) 
					lcDateExp = "[ReceivedTime] > '" + DTOC( .dFromDate - 1 ) + "'"
				ELSE
					IF NOT EMPTY( .dToDate ) 
						lcDateExp = "[ReceivedTime] < '" + DTOC( .dToDate + 1 ) + "'"
					ENDIF
				ENDIF
			ENDIF
			IF NOT EMPTY( lcDateExp )
				lcFilter = lcFilter + IIF( NOT EMPTY( lcFilter ), "AND ", "" ) + lcDateExp
			ENDIF
		ENDWITH
		RETURN lcFilter
	ENDPROC

	PROCEDURE createsession		&& Instantiate outlook and logon
		LOCAL llRetVal, llReturn
		
		*** See we we already have an instance of Outlook Running
		IF TYPE( 'This.oOutlook' ) = 'O' AND NOT ISNULL( THIS.oOutlook )
		   *** No need to create a new instance
		ELSE
		   WITH THIS
		      llReturn = .T.
		      TRY
		         .oOutlook = CREATEOBJECT( 'Outlook.Application' )
		      CATCH
		         llReturn = .F.
		      ENDTRY
		
		      IF llReturn
		         IF TYPE( 'This.oOutLook' ) = 'O' AND NOT ISNULL( .oOutlook )
		            .oNameSpace = .oOutlook.GetNameSpace( 'MAPI' )
		            IF TYPE( 'This.oNameSpace' ) = 'O' AND NOT ISNULL( .oNameSpace )
		               llRetVal = .T.
		            ENDIF
		         ENDIF
		      ELSE
		         llRetVal = llReturn
		      ENDIF
		   ENDWITH
		ENDIF
		
		RETURN llRetVal
		
	ENDPROC

	PROCEDURE deletemessage		&& Deletes aMsgs[ This.nCurrentMsg ] from the array as well as from the outlok inbox
		LOCAL loMsg, lnArrayLen
		*** This method expects to have nCurrentMsg pointing to the message
		*** that we want to delete upon entry. 
		*** One of the positional methods ( i.e., GetFirstMsg, GetNextMsg, GetMsg, etc. )
		*** must be called before calling this one to delete the specified message
		WITH This
			*** Get a reference.to the current message
			loMsg = .aMsgs[ .nCurrentMsg ]
			*** And delete it in the internal aMsgs array
			lnArrayLen = ALEN( .aMsgs, 1 ) - 1
			ADEL( .aMsgs, .nCurrentMsg )
			DIMENSION .aMsgs[ lnArrayLen ]
			*** Deletes the entire email - attachments and all
			loMsg.Delete()
		
			*** Now, reset the nCurrentMsg property if we deleted the last message
			IF .nCurrentMsg > lnArrayLen
				.nCurrentMsg = lnArrayLen	
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE Destroy
		WITH This
			.aMsgs = .NULL.
			.oNameSpace = .NULL.
			.oOutLook = .NULL.
		ENDWITH
	ENDPROC

	PROCEDURE getattachmentcount		&& Returns the number of attachments that the current message has
		RETURN This.aMsgs[ This.nCurrentMsg ].Attachments.Count
	ENDPROC

	PROCEDURE getattachmentfile		&& Passed the index into a message's attachments collection, returns the fully qualified file name of that attachment (if it exists)
		LPARAMETERS tnAttachment
		LOCAL lcFileName
		
		lcFileName = ''
		
		IF TYPE( 'This.aMsgs[ This.nCurrentMsg ]' ) = 'O' AND NOT ISNULL( This.aMsgs[ This.nCurrentMsg ] )
			*** Make sure we have a valid attachment number
			IF NOT EMPTY( tnAttachment ) AND tnAttachment <= THIS.aMsgs[ This.nCurrentMsg ].Attachments.Count 
				*** Get the specified attachment ( base 0 )
				lcFileName = THIS.aMsgs[ This.nCurrentMsg ].Attachments[ tnAttachment ].FileName
			ENDIF
		ENDIF
		RETURN lcFileName
		
	ENDPROC

	PROCEDURE getbodytext		&& Returns the text of the current message
		RETURN This.aMsgs[ This.nCurrentMsg ].Body
	ENDPROC

	PROCEDURE getcontacts		&& Gets the names and e-mail addresses from contacts into an array
		LOCAL loAddressBook AS Outlook.MAPIFolder, loContact AS OBJECT, lnContactCount
		LOCAL llReturn
		
		llReturn = .T.
		
		TRY 
		*** Get a reference to the contacts folder
		loAddressBook = THIS.oNameSpace.GetDefaultFolder( 10 )
		IF VARTYPE( loAddressBook ) = 'O'
		   lnContactCount = 0
		   *** Get info about each contact into the array
		   FOR EACH loContact IN loAddressBook.Items
		      WITH loContact
		         *** Make sure we only get individual contacts
		         *** and skip any distribution lists
		         IF .CLASS = 40
		            lnContactCount = lnContactCount + 1
		            DIMENSION THIS.aContacts[ lnContactCount, 4 ]
		            THIS.aContacts[ lnContactCount, 1 ] = .LastName
		            THIS.aContacts[ lnContactCount, 2 ] = .FirstName
		            THIS.aContacts[ lnContactCount, 3 ] = .Email1Address
		            THIS.aContacts[ lnContactCount, 4 ] = .FULLNAME
		         ENDIF
		      ENDWITH
		   ENDFOR
		   ASORT( THIS.aContacts )
		   IF lnContactCount = 0
		      THIS.addcontact()
		   ENDIF
		ELSE
		   THIS.addcontact()
		ENDIF
		CATCH TO loError
		    IF 'abort' $ LOWER(loError.message)
		       MESSAGEBOX("Unable to send email since permission wasn't granted.",16,'Email Permission Denied')
		    ENDIF 
		    llReturn = .F.
		ENDTRY 
		
		RETURN (llReturn)
	ENDPROC

	PROCEDURE getdatereceived		&& Returns the date the message was received
		RETURN This.aMsgs[ This.nCurrentMsg ].ReceivedTime
	ENDPROC

	PROCEDURE getfirstmsg		&& Sets the class's nCurrentMsg property to 1
		This.nCurrentMsg = 1
	ENDPROC

	PROCEDURE getlastmsg		&& Sets the class's nCurrentMsg property to the length of the aMsgs array
		This.nCurrentMsg = ALEN( This.aMsgs, 1 )
	ENDPROC

	PROCEDURE getmsg		&& Given an Index into the aMsgs array, sets the internal nCurrentMsg property so we know which message we are operating on
		LPARAMETERS tnMsgIndex
		LOCAL lcBDPE
		
		*** Check parameter
		WITH This
			IF VARTYPE( tnMsgIndex ) = 'N' AND BETWEEN( tnMsgIndex, 1, ALEN( .aMsgs, 1 ) )
				.nCurrentMsg = tnMsgIndex
			ELSE
				lcBDPE = 'This is another brain dead programmer error' + CHR( 13 ) 
				lcBDPE = lcBDPE + 'You must send a message index to the cusMapi GetMsg method' + CHR( 13 )
				lcBDPE = lcBDPE + 'Have a nice day now...'
				ASSERT .F. MESSAGE lcBDPE
				RETURN .F.
			ENDIF
		ENDWITH
		
		
	ENDPROC

	PROCEDURE getnextmsg		&& Increments the class's nCurrentMsg by 1
		WITH This
			*** We can only get a next message if we are not currently on the last one
			IF .nCurrentMsg < ALEN( .aMsgs, 1 )
				*** Increment index into the message numbers array
				.nCurrentMsg = .nCurrentMsg + 1
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE getpriormsg		&& Decrements the class's nCurrentMsg by 1
		WITH This
			*** We can only get a prior message if we are not currently on the first one
			IF .nCurrentMsg > 1
				*** Increment index into the message numbers array
				.nCurrentMsg = .nCurrentMsg - 1
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE getsender		&& Returns the message sender
		RETURN This.aMsgs[ This.nCurrentMsg ].SenderName
	ENDPROC

	PROCEDURE getsubject		&& Returns the subject line for the current message
		RETURN This.aMsgs[ This.nCurrentMsg ].Subject
	ENDPROC

	PROCEDURE Init
		
		llRetVal = DODEFAULT()
		IF llRetVal
			llRetVal = This.CreateSession( )
			*** Now populate the internal array of contacts
			*** so we have it available when we need it
			IF llRetVal
		*    	llRetVal = This.GetContacts()
			ENDIF
		ENDIF
		
		RETURN llRetVal
			
	ENDPROC

	PROCEDURE readmail		&& Vased on the parameters passed, accesses the Outlook Inbox and retrieves the messages that satisfy the filter requirements
		*******************************************************************************************************
		*** The ReadMail Method expects a parameter object with the following properties
		***		lUnreadOnly: When true, only unread messages are loaded
		*** 	cSender: When not empty, only loads messages sent by name specified
		*** 	cSubject: When not empty, only loads messages with specified subject line
		*** 	dFromDate: When not empty, only loads messages received after specified date
		*** 	dToDate: When not empty, only loads messages received before specified date
		*** This parameter object can easily be instantiated using loReadParms = CREATEOBJECT( 'swOutlookReadParms' )
		********************************************************************************************************
		LPARAMETERS toReadParms
		LOCAL	loInbox AS Outlook.MAPIFolder, loMessages AS Outlook.Items
		LOCAL lcFilter, lnMsgCount, lcSubject, lcBDPE
		
		IF VARTYPE( toReadParms ) = 'O' AND LOWER( toReadParms.Class ) == 'swoutlookreadparms'
			*** Peachy keen...everything is fine
		ELSE
			lcBDPE = 'This is another brain dead programmer error' + CHR( 13 ) 
			lcBDPE = lcBDPE + 'You must send a parameter object to the cusOutlook ReadMail method' + CHR( 13 )
			lcBDPE = lcBDPE + "Please create one using CREATEOBJECT( 'swOutlookReadParms' ) and populate it" + CHR( 13 )
			lcBDPE = lcBDPE + 'Have a nice day now...'
			ASSERT .F. MESSAGE lcBDPE
			RETURN -1
		ENDIF
		
		*** Build the filter condition
		lcFilter = This.BuildFilter( toReadParms )
		
		*** Get an object reference to the inbox
		*** The constant 'olFolderInbox' is in the msoutl9.h include file
		*** along with all the other outlook constants
		loInbox = This.oNameSpace.GetDefaultFolder( 6 )
		IF NOT EMPTY( lcFilter )
			loMessages = loInbox.Items.Restrict( lcFilter )
		ELSE
			loMessages = loInbox.Items
		ENDIF
		*** Go through the collection of messages retrieved
		*** and save only the ones we are interested in to the aMsgs array
		*** the Restrict method doesn't work consistently with restricting
		*** messages by subject
		IF VARTYPE( loMessages ) = 'O'
			lnMsgCount = 0
			lcSubject = UPPER( ALLTRIM( toReadParms.cSubject ) )
			FOR lnMsg = 1 TO loMessages.Count
				IF NOT EMPTY( lcSubject )
					IF UPPER( ALLTRIM( loMessages.Item[ lnMsg ].Subject ) ) = lcSubject
						lnMsgCount = lnMsgCount + 1
						DIMENSION This.aMsgs[ lnMsgCount ]
						This.aMsgs[ lnMsgCount ] = loMessages.Item[ lnMsg ]
					ENDIF
				ELSE
					lnMsgCount = lnMsgCount + 1
					DIMENSION This.aMsgs[ lnMsgCount ]
					This.aMsgs[ lnMsgCount ] = loMessages.Item[ lnMsg ]
				ENDIF		
			ENDFOR
		ELSE
			lnMsgCount = -1
		ENDIF
		RETURN lnMsgCount
		
	ENDPROC

	PROCEDURE saveattachment		&& Saves the spcified attachment in the current message to the specified file name
		LPARAMETERS tnAttachment, tcPathName
		
		IF TYPE( 'This.aMsgs[ This.nCurrentMsg ]' ) = 'O' AND NOT ISNULL( This.aMsgs[ This.nCurrentMsg ] )
			*** Make sure we have a valid attachment number
			IF NOT EMPTY( tnAttachment ) AND tnAttachment <= THIS.aMsgs[ This.nCurrentMsg ].Attachments.Count 
				*** Get the specified attachment ( base 0 )
				THIS.aMsgs[ This.nCurrentMsg ].Attachments[ tnAttachment ].SaveAsFile( tcPathName )
			ENDIF
		ENDIF
		
		
	ENDPROC

	PROCEDURE sendmail		&& Passed a parameter object that contains the message info, creates it, adds the attachments Iif any) and send it
		*******************************************************************************************************
		*** The SendMail Method expects a parameter object with the following properties
		*** 	cSubject: Content to be placed on the subject line of the message
		*** 	cBodyText: Content to be placed in the body of the message
		*** 	aAttachments: an array of file names to attach to the message
		*** 	aRecipients: an array of message recipients
		*** 	aCC: an array of people to be cc's
		***		aBcc an array of people to be blind copied
		*** This parameter object can easily be instantiated using loReadParms = CREATEOBJECT( 'swOutlookSendParms' )
		********************************************************************************************************
		LPARAMETERS toSendParms
		LOCAL lcBDPE, loMsg AS Outlook.MailItem, lnLen, lnCnt, llResult
		
		llResult = .f.
		
		IF VARTYPE( toSendParms ) = 'O' AND LOWER( toSendParms.Class ) == 'swoutlooksendparms'
			*** Peachy keen...everything is fine
		ELSE
			lcBDPE = 'This is another brain dead programmer error' + CHR( 13 ) 
			lcBDPE = lcBDPE + 'You must send a parameter object to the cusOutlook SendMail method' + CHR( 13 )
			lcBDPE = lcBDPE + "Please create one using CREATEOBJECT( 'swOutlookSendParms' ) and populate it" + CHR( 13 )
			lcBDPE = lcBDPE + 'Have a nice day now...'
			ASSERT .F. MESSAGE lcBDPE
			RETURN .F.
		ENDIF
		*** Check for sufficient info to send message
		IF EMPTY( toSendParms.aRecipients[ 1, 2 ] ) 
			MESSAGEBOX( 'You MUST specify at least 1 Recipient', 16, 'Missing Recipient!' )
			RETURN .F.
		ENDIF
		IF EMPTY( toSendParms.cSubject )
			MESSAGEBOX( 'You MUST specify a subject', 16, 'Missing Subject!' )
			RETURN .F.
		ENDIF
		
		*** Verify that all attachment files exist
		IF NOT EMPTY( toSendParms.aAttachments[ 1 ] )
			FOR lnFile = 1 TO ALEN( toSendParms.aAttachments, 1 )
				IF NOT FILE( toSendParms.aAttachments[ lnFile ] )
					MESSAGEBOX( 'Attachment File is Missing or Invalid:' + CHR( 13 ) + ;
						toSendParms.aAttachments[ lnFile ], 16, 'Invalid Attachment!' )
					RETURN .F.	
				ENDIF
			ENDFOR
		ENDIF
		
		*** Create a new mail item
		TRY 
		loMsg = This.oOutlook.CreateItem( 0 )
		IF VARTYPE( loMsg ) = 'O' AND NOT ISNULL(loMsg)
			WITH loMsg
				*** Set the required message properties
				.Subject = ALLTRIM( toSendParms.cSubject )
				.Body = ALLTRIM( toSendParms.cBodyText )
				*** Add the recipients
				IF VARTYPE(loMsg.Recipients) = 'O'
				lnLen = ALEN( toSendParms.aRecipients, 1 )
				FOR lnCnt = 1 TO lnLen
					.Recipients.Add( ALLTRIM( toSendParms.aRecipients[ lnCnt, 1 ] ) )
					.Recipients[ lnCnt ].Type = toSendParms.aRecipients[ lnCnt, 2 ]
				ENDFOR
				ENDIF 
				*** And finally, add the attachment if there are any
				IF NOT EMPTY( toSendParms.aAttachments[ 1 ] )
					lnLen = ALEN( toSendParms.aAttachments, 1 )
					FOR lnCnt = 1 TO lnLen
						.Attachments.Add( ALLTRIM( toSendParms.aAttachments[ lnCnt, 1 ] ) )
					ENDFOR
				ENDIF
				*** And send it off
				llResult = .t.
				llOutlookResolve = .t.
				TRY 
		   			.Send()
		   		CATCH TO loError
		   		    IF "Outlook does not recognize one or more names" $ loError.message
		   		        llOutlookResolve = .f.
		   		    ENDIF 
		   		    llResult = .f.	
		   		ENDTRY    
		   		
		   		IF NOT llOutlookResolve
		   		   MESSAGEBOX('Recipient: ' + ALLTRIM(toSendParms.aRecipients[1,1]) + ' is not in your Outlook Contact list. You cannot use ' + ;
		   		              'the outlook settings to email them reports. Go to Edit, Preferences, Email to specify the email server and password.',16,'Outlook Email Problem')
		   		ENDIF 
			ENDWITH
		ELSE 
		    MESSAGEBOX('Unable to create email message in Outlook.',16,'Email Problem')	
		    llResult = .f.
		ENDIF
		CATCH TO loError
		    llResult = .f.
		ENDTRY 
		
		IF NOT llResult
		   MESSAGEBOX('Unable to send email. Error: ' + CHR(13) + loerror.message,48,'Unable to send email')
		ENDIF 
		RETURN llResult 
					
	ENDPROC

ENDDEFINE

DEFINE CLASS swoutlookreadparms AS line 		&& MAPI readMail method parameter
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: csender		&& Sender name (used when reading messages to apply a filter: retrieve only messages sent by this person)
		*p: csubject		&& Subject (used when reading messages to apply a filter: retrieve only messages with the specified subject line)
		*p: dfromdate		&& Used when reading messages to apply a filter: retrieve only messages after the specifed date
		*p: dtodate		&& Used when reading messages to apply a filter: retrieve only messages before the specifed date
		*p: lunreadonly		&& When true, retrieves only unread messages
	*</DefinedPropArrayMethod>

	csender = 		&& Sender name (used when reading messages to apply a filter: retrieve only messages sent by this person)
	csubject = 		&& Subject (used when reading messages to apply a filter: retrieve only messages with the specified subject line)
	dfromdate = {}		&& Used when reading messages to apply a filter: retrieve only messages after the specifed date
	dtodate = {}		&& Used when reading messages to apply a filter: retrieve only messages before the specifed date
	Height = 17
	Name = "outlookireadparms"
	Visible = .F.
	Width = 100

ENDDEFINE

DEFINE CLASS swoutlooksendparms AS line 		&& MAPI SendMail parameters
 	*< CLASSDATA: Baseclass="line" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cbodytext		&& Body text of the e-mail
		*p: csubject		&& Subject line for the e-mail
		*a: aattachments[1,0]		&& array of file names to be sent as attachments
		*a: arecipients[1,2]		&& Reciepients (main, cc, and bcc) to be sent the mail; Columns are: 1-Email Address 2-Recipient Type; Types are 1-Main 2-CC 3-BCC
	*</DefinedPropArrayMethod>

	cbodytext = 		&& Body text of the e-mail
	csubject = 		&& Subject line for the e-mail
	Height = 17
	Name = "swoutlooksendparms"
	Visible = .F.
	Width = 100

ENDDEFINE

DEFINE CLASS swsendmail AS relation 
 	*< CLASSDATA: Baseclass="relation" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "source\appdefs.h"
	*<DefinedPropArrayMethod>
		*m: isemailsetup		&& Are the email parameters set in Email Preferences.  Returns .T. if they are and .F. if they aren't
		*m: sendmail		&& Send the email
		*p: cattachment		&& Name of attachment
		*p: cbcc		&& Blind carbon copy list
		*p: cbody		&& Body of Email
		*p: ccc		&& Carbon Copy list
		*p: cemailaddress		&& Email message
		*p: cemailpass		&& Email login password
		*p: cemailserver		&& Email server domain
		*p: cemailuser		&& User login for email server
		*p: cerrormsg
		*p: creplyto
		*p: csender		&& Name of person sending email
		*p: csubject		&& Subject of email
		*p: cto		&& Address to send email to
		*p: loutlook		&& Send using outlook parameters (CDO)
		*p: lresult		&& Return result
		*p: lusessl
		*p: nsmtpport
		*p: ocdo
		*p: ocdoparms
		*p: ooutlook
		*p: osendparms
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	cattachment = 		&& Name of attachment
	cbcc = 		&& Blind carbon copy list
	cbody = 		&& Body of Email
	ccc = 		&& Carbon Copy list
	cemailaddress = 		&& Email message
	cemailpass = 		&& Email login password
	cemailserver = 		&& Email server domain
	cemailuser = 		&& User login for email server
	cerrormsg = **
	creplyto = 
	csender = 		&& Name of person sending email
	csubject = 		&& Subject of email
	cto = 		&& Address to send email to
	Height = 23
	loutlook = .F.		&& Send using outlook parameters (CDO)
	Name = "swsendmail"
	nsmtpport = 25
	ocdo = .NULL.
	ocdoparms = .NULL.
	ooutlook = .NULL.
	osendparms = .NULL.
	Width = 23
	_memberdata = <VFPData>
		<memberdata name="cemailaddress" type="property" display="cEmailAddress"/>
		<memberdata name="cbody" type="property" display="cBody"/>
		<memberdata name="cemailserver" type="property" display="cEmailServer"/>
		<memberdata name="cemailuser" type="property" display="cEmailUser"/>
		<memberdata name="cemailpass" type="property" display="cEmailPass"/>
		<memberdata name="csubject" type="property" display="cSubject"/>
		<memberdata name="cto" type="property" display="cTo"/>
		<memberdata name="ccc" type="property" display="cCC"/>
		<memberdata name="cbcc" type="property" display="cBCC"/>
		<memberdata name="loutlook" type="property" display="lOutlook"/>
		<memberdata name="sendmail" type="method" display="SendMail"/>
		<memberdata name="ocdoparms" type="property" display="oCDOParms"/>
		<memberdata name="ocdo" type="property" display="oCDO"/>
		<memberdata name="csender" type="property" display="cSender"/>
		<memberdata name="cattachment" type="property" display="cAttachment"/>
		<memberdata name="cerrormsg" type="property" display="cErrorMsg"/>
		<memberdata name="ooutlook" type="property" display="oOutlook"/>
		<memberdata name="osendparms" type="property" display="oSendParms"/>
		<memberdata name="lresult" display="lResult"/>
		<memberdata name="lusessl" display="lUseSSL"/>
		<memberdata name="creplyto" display="cReplyTo"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE isemailsetup		&& Are the email parameters set in Email Preferences.  Returns .T. if they are and .F. if they aren't
		RETURN .f.
	ENDPROC

	PROCEDURE sendmail		&& Send the email
		LPARAMETERS tlAsync, tlSendingError
		LOCAL llResult, lcErr, lnAdds, lcAddress, llEmailSetup, llUseSherWareServer
		LOCAL loConfig AS "CDO.Configuration"
		LOCAL o AS "wwSMTP"
		LOCAL lcSchema, loError
		
		llResult = .T.
		
		TRY
		   STORE '' TO lcErr, lcAddress
		   STORE 0  TO lnAdds
		   
		   TRY 
		      lcPath = SET('path')
		      IF NOT '\bin\' $ lcPath
		         SET PATH to (m.goapp.cCommonFolder + 'bin\,' + lcPath)
		      ENDIF    
		   CATCH
		   ENDTRY 
		   
		   llEmailSetup = swIsEmailSetup()
		   IF NOT llEmailSetup AND NOT tlSendingError
		      MESSAGEBOX('The email preferences have not been setup. Email cannot be sent.', 16, 'Email Preferences Missing')
		      llResult =  .F.
		      EXIT
		   ENDIF
		
		* Tell it to use SherWare's email server
		   IF NOT llEmailSetup AND tlSendingError
		      llUseSherWareServer = .T.
		   ELSE
		      llUseSherWareServer = .F.
		   ENDIF
		
		   IF NOT THIS.lOutlook OR llUseSherWareServer
		      DO wwsmtp
		      o = CREATEOBJECT("wwSMTP")
		      SET MEMOWIDTH TO 200
		
		*** Sending SMTP Mail
		      IF NOT llUseSherWareServer
		         o.cMailServer  = ALLT(THIS.cEmailServer)
		         o.cSenderEmail = ALLT(THIS.cEmailAddress)
		         o.cSenderName  = THIS.cSender
		         o.cUserName    = ALLT(THIS.cEmailUser)
		         o.cPassword    = ALLT(THIS.cEmailPass)
		         o.nServerPort  = 25
		         IF THIS.nSMTPPort <> 0
		            o.nServerPort  = THIS.nSMTPPort
		         ENDIF
		         o.lUseSSL      = THIS.lUseSSL
		         IF NOT EMPTY(THIS.cReplyTo)
		            o.cReplyTo     = THIS.cReplyTo
		         ENDIF
		* Remove trailing ';'
		         IF RIGHT(ALLTRIM(THIS.cTo), 1) = ';'
		            THIS.cTo = SUBSTR(THIS.cTo, 1, LEN(ALLTRIM(THIS.cTo)) - 1)
		         ENDIF
		* Remove trailing ','
		         IF RIGHT(ALLTRIM(THIS.cTo), 1) = ','
		            THIS.cTo = SUBSTR(THIS.cTo, 1, LEN(ALLTRIM(THIS.cTo)) - 1)
		         ENDIF
		
		         o.cRecipient  = ALLTRIM(THIS.cTo)
		         o.cCCList     = ALLTRIM(THIS.cCC)
		         o.cBCCList    = ALLTRIM(THIS.cBCC)
		         o.cSubject    = THIS.cSubject
		         o.cMessage    = THIS.cBody
		         o.cAttachment = ALLTRIM(THIS.cAttachment)
		         IF THIS.lUseSSL
		            o.nMailMode = 0
		         ELSE
		            o.nMailMode = 2
		         ENDIF
		
		      ELSE
		         o.cMailServer  = "smtp.gmail.com"
		         o.cSenderEmail = "support@sherware.com"
		         o.cSenderName  = m.goApp.cCompanyName
		         o.cUserName    = "support@sherware.com"
		         IF NOT EMPTY(THIS.cReplyTo)
		            o.cReplyTo     = THIS.cReplyTo
		         ENDIF
		         o.cPassword    = "$herW@re1994"
		         o.nServerPort  = 587
		         o.lUseSSL      = .T.
		         o.cRecipient   = ALLTRIM(THIS.cTo)
		         o.cCCList      = ''
		         o.cBCCList     = ''
		         o.cSubject     = THIS.cSubject
		         o.cMessage     = THIS.cBody
		         o.cAttachment  = ALLTRIM(THIS.cAttachment)
		         o.nMailMode    = 0
		      ENDIF
		
		      IF NOT tlAsync
		         llResult = o.SendMail()       && Send and wait for completion
		      ELSE
		         llResult = o.SendMailAsync()       && Send and don't wait for completion
		      ENDIF
		
		      IF NOT llResult
		         THIS.cErrorMsg = o.cErrorMsg
		      ENDIF
		      RELEASE o
		
		   ELSE
		      LOCAL lcSender, lcMailServer, lcSenderName, llDirectDepOnly
		      LOCAL lcName, llCDO, lnAdds, lnPlace, lnPos, lnX, lnY
		      LOCAL oOutlook, oSendParms
		
		      STORE 0 TO lnAdds, lnPlace, lnPos, lnX, lnY
		      STORE '' TO lcSender, lcMailServer, lcSenderName, lcName
		      STORE .F. TO llDirectDepOnly
		      STORE .T. TO llCDO
		
		      IF VARTYPE(THIS.oOutlook) <> 'O'
		         THIS.oOutlook = CREATEOBJECT('swOutlook')
		      ENDIF
		      IF VARTYPE(THIS.oOutlook) = 'O' AND NOT ISNULL(THIS.oOutlook)
		         THIS.oSendParms = CREATEOBJECT('swOutlookSendParms')
		         IF VARTYPE(THIS.oSendParms) = 'O' AND NOT ISNULL(THIS.oSendParms)
		            lnPlace = 1
		            IF NOT ',' $ THIS.cTo AND NOT ';' $ THIS.cTo
		               THIS.oSendParms.aRecipients[lnPlace, 1] = THIS.cTo
		               THIS.oSendParms.aRecipients[lnPlace, 2] = 1
		            ELSE
		* There are multiple recipients specified in the To field.
		* Strip them out and add them to the aRecipients array
		               lnAdds = 0
		               lnAdds = OCCURS(',', THIS.cTo)
		               lnAdds = lnAdds + OCCURS(';', THIS.cTo)
		               IF lnAdds = 0
		                  THIS.oSendParms.aRecipients[lnPlace, 1] = ALLTRIM(THIS.cTo)
		                  THIS.oSendParms.aRecipients[lnPlace, 2] = 1
		               ELSE
		                  lnX = 1
		* Remove trailing ';'
		                  IF RIGHT(ALLTRIM(THIS.cTo), 1) = ';'
		                     THIS.cTo = SUBSTR(THIS.cTo, 1, LEN(ALLTRIM(THIS.cTo)) - 1)
		                  ENDIF
		* Remove trailing ','
		                  IF RIGHT(ALLTRIM(THIS.cTo), 1) = ','
		                     THIS.cTo = SUBSTR(THIS.cTo, 1, LEN(ALLTRIM(THIS.cTo)) - 1)
		                  ENDIF
		                  FOR lnPlace = 1 TO lnAdds
		                     DIMENSION THIS.oSendParms.aRecipients[lnPlace, 2]
		                     IF ',' $ THIS.cTo
		                        lnPos                                   = AT(',', THIS.cTo, lnPlace)
		                        lnY                                     = lnPos - lnX
		                        THIS.oSendParms.aRecipients[lnPlace, 1] = ALLTRIM(SUBSTR(THIS.cTo, lnX, lnY))
		                        THIS.oSendParms.aRecipients[lnPlace, 2] = 1
		                        lnX                                     = lnPos + 1
		                     ELSE
		                        lnPos                                   = AT(';', THIS.cTo, lnPlace)
		                        lnY                                     = lnPos - lnX
		                        THIS.oSendParms.aRecipients[lnPlace, 1] = ALLTRIM(SUBSTR(THIS.cTo, lnX, lnY))
		                        THIS.oSendParms.aRecipients[lnPlace, 2] = 1
		                        lnX                                     = lnPos + 1
		                     ENDIF
		                  ENDFOR
		                  DIMENSION THIS.oSendParms.aRecipients[lnPlace, 2]
		                  THIS.oSendParms.aRecipients[lnPlace, 1] = ALLTRIM(SUBSTR(THIS.cTo, lnX))
		                  THIS.oSendParms.aRecipients[lnPlace, 2] = 1
		               ENDIF
		            ENDIF
		            IF NOT EMPTY(THIS.cCC)
		               lnPlace = lnPlace + 1
		               DIMENSION THIS.oSendParms.aRecipients[lnPlace, 2]
		               THIS.oSendParms.aRecipients[2, 1] = THIS.cCC
		               THIS.oSendParms.aRecipients[2, 2] = 2
		            ENDIF
		            IF NOT EMPTY(THIS.cBCC)
		               lnPlace = lnPlace + 1
		               DIMENSION THIS.oSendParms.aRecipients[lnPlace, 2]
		               THIS.oSendParms.aRecipients[3, 1] = THIS.cBCC
		               THIS.oSendParms.aRecipients[3, 2] = 3
		            ENDIF
		            THIS.oSendParms.cBodyText          = THIS.cBody
		            THIS.oSendParms.cSubject           = THIS.cSubject
		            THIS.oSendParms.aAttachments[1, 1] = THIS.cAttachment
		
		
		            llResult = THIS.oOutlook.SendMail(THIS.oSendParms)
		            llCDO    = NOT llResult
		         ELSE
		            llCDO = .T.
		         ENDIF
		      ELSE
		         llCDO = .T.
		      ENDIF
		
		      IF llCDO
		         TRY
		** Setup the config smtp parameters
		            lcSchema = "http://schemas.microsoft.com/cdo/configuration/"
		            loConfig = CREATEOBJECT("CDO.Configuration")
		            WITH loConfig.FIELDS
		               .ITEM(lcSchema + "smtpserver")       = "smtp.gmail.com"
		               .ITEM(lcSchema + "smtpserverport")   = 587
		               .ITEM(lcSchema + "sendusing")        = 2
		               .ITEM(lcSchema + "smtpauthenticate") = 1
		               .ITEM(lcSchema + "sendusername")     = 'info@sherware.com'
		               .ITEM(lcSchema + "sendpassword")     = "ts060962"
		               .UPDATE
		            ENDWITH
		
		** Setup the CDO Message Object
		            LOCAL swCDO AS "CDO.Message"
		            swCDO = THIS.oCDO
		            IF VARTYPE(swCDO) <> 'O'
		               THIS.oCDO = CREATEOBJECT("CDO.Message")
		               swCDO     = THIS.oCDO
		            ENDIF
		** Tie the configuration to the message
		            swCDO.Configuration = loConfig
		
		** Set the email parameters
		            swCDO.CC       = THIS.cCC
		            swCDO.BCC      = THIS.cBCC
		            swCDO.HTMLBody = STRTRAN(THIS.cBody, CHR(10), "<br>")
		            swCDO.Subject  = THIS.cSubject
		            swCDO.TO       = THIS.cTo
		            swCDO.FROM     = '"' + ALLTRIM(THIS.cSender) + '"' + '<swapp@sherware.com>'
		            swCDO.Sender   = swCDO.FROM
		            swCDO.AddAttachment(THIS.cAttachment)
		            swCDO.SEND()
		         CATCH TO loError
		            lcErr = [Error: ] + STR(loError.ERRORNO) + CHR(13) + ;
		               [Line: ] + STR(loError.LINENO) + CHR(13) + ;
		               [Message: ] + loError.MESSAGE
		            THIS.cErrorMsg = loError.MESSAGE
		         FINALLY
		            RELEASE swCDO, loConfig
		            STORE .NULL. TO loConfig, swCDO
		            IF EMPTY(lcErr)
		               llResult = .T.
		            ELSE
		               llResult = .F.
		            ENDIF
		         ENDTRY
		         IF llResult = .F. AND NOT tlSendingError
		            IF '1429' $ lcErr
		               MESSAGEBOX("The email preferences are set to use Outlook but I'm unable to do so. " + ;
		                          "Try entering your email preferences explicitly.",16,'Outlook Email Problem')
		            ELSE 
		               DO errorlog WITH 'swemail.sendmail', 100, 'None', 99, lcErr, 'None'
		            ENDIF    
		         ENDIF
		      ENDIF
		   ENDIF
		
		   THIS.lResult = llResult
		CATCH TO loError
		   llResult = .F.
		   IF NOT tlSendingError
		      DO errorlog WITH 'SendMail', loError.LINENO, 'SWEmail', loError.ERRORNO, loError.MESSAGE, '', loError
		      MESSAGEBOX('Unable to send email at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		           'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		   ENDIF
		ENDTRY
		
		RETURN llResult
		
		
		
		
	ENDPROC

ENDDEFINE
