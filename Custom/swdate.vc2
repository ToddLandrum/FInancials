*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="swdate.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS calendar_form AS form 		&& the "always on top" form with calendar
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oleMonthView" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: gettoplevelform		&& get top level form reference (or _screen if doesn't exist)
		*p: oldvalue		&& old value, for Escape/Deactivate
		*p: textboxref		&& reference to textbox
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 1
	Caption = "ComboForm"
	Closable = .F.
	Desktop = .F.
	DoCreate = .T.
	Height = 144
	KeyPreview = .T.
	Left = 0
	Name = "calendar_form"
	ShowInTaskBar = .F.
	ShowWindow = 1
	textboxref = .NULL.		&& reference to textbox
	TitleBar = 0
	Top = 0
	Width = 164

	ADD OBJECT 'oleMonthView' AS olecontrol WITH ;
		Left = 0, ;
		Name = "oleMonthView", ;
		Top = 0
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\system32\mscomct2.ocx" Value="yKQR0+1fGt8AAAAAAAAAAAAAAAAAAAAAPgADAF+gCQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAABfoKCgAAAAAAAAAACgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKD+oKCgX6CgoF+goKAEAAAAX6CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCg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" />
	
	PROCEDURE Deactivate
		THIS.Release
	ENDPROC

	PROCEDURE gettoplevelform		&& get top level form reference (or _screen if doesn't exist)
		*from Foundation Classes "_ui.vcx"
		
		ASSERT TYPE("_SCREEN.ActiveForm") # "O"  OR ;
		       INLIST(_SCREEN.ActiveForm.ShowWindow, 0,1,2)
		
		DO CASE
		CASE _SCREEN.FormCount = 0 OR ;
		     (TYPE("_SCREEN.ActiveForm") = "O" AND ;
		     _SCREEN.ActiveForm.ShowWindow = 0 )     && ShowWindow In Screen
				     
		     loTopForm = _SCREEN
		
		CASE (TYPE("_SCREEN.ActiveForm") = "O" AND ;
		      _SCREEN.ActiveForm.ShowWindow = 2 )    && ShowWindow As Top Form
		
		     loTopForm = _SCREEN.ActiveForm
				     
		OTHERWISE 
				                                       
		     FOR EACH loForm IN _SCREEN.Forms  && note: these may be toolbars
		                                       && if undocked, but that's okay --
		                                       && they are only ShowWIndow 0 or 1.
		
		        IF loForm.ShowWindow = 2 && the first one in the collection will
		                                && be "active top form"
		           loTopForm = loForm
		           EXIT
		        ENDIF
		     ENDFOR
				     
		     IF VARTYPE(loTopForm) # "O"
		        loTopForm = _SCREEN
		     ENDIF
				          
		ENDCASE
		
		RETURN loTopForm     
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS toTextboxRef, toformRef
		
		oMessage = findglobalobject('cmMessage')
		
		IF ISNULL(toTextboxRef) OR VARTYPE(toTextboxRef) <> 'O'
			RETURN
		ENDIF 
		LOCAL oTopLevelForm
		oTopLevelForm = this.gettoplevelform() &&get host form reference for setting position
		WITH this
			.textboxRef = toTextboxRef
			.oldValue = .textboxRef.Value 	&&just in case for Esc or Deactivate
			
			IF YEAR(.oldValue) < 1850 AND .OldValue <> {  /  /    }  &&  Added blank date checking for this message, since the 5/2/08 update seemed to break something - BH 05/21/08
		         omessage.warning('This is an invalid date. The date must be greater than Jan 1, 1850. Defaulting to current date.')
		         .OldValue = DATE()
		         .textBoxRef.value = DATE()
		    ENDIF
		
			IF NOT EMPTY(.textboxRef.value)
				this.oleMonthView.Year = YEAR(.textboxRef.Value)		
				this.oleMonthView.month = MONTH(.textboxRef.Value)
				this.oleMonthView.day = DAY(.textboxRef.Value)
			ENDIF 
			
			.Top = .textboxRef.Height + OBJTOCLIENT(.textboxRef ,1)  ;
				+ SYSMETRIC(4) + SYSMETRIC(9) + toFormRef.top
			.Left = OBJTOCLIENT(.textboxRef ,2) + SYSMETRIC(3) + toFormRef.left 
		
		*check to see id "drop up" os horizontal position shifting needed	
			DO CASE 
			CASE toFormRef.ShowWindow = 0 OR toFormRef.ShowWindow = 1
				IF .Left + .Width > oTopLevelForm.Width 	
					.Left = oTopLevelForm.Width - .Width - 4
				ENDIF
			
				IF .Top + .Height  > oTopLevelForm.Height
					.Top = .Top - .textboxRef.Height - .Height - 2
				ENDIF 
			CASE  toFormRef.ShowWindow = 2
				IF .Left + .Width > SYSMETRIC(1)
					.Left = SYSMETRIC(1) - .Width - 4
				ENDIF
			
				IF .Top + .Height  > SYSMETRIC(2)
					.Top = .Top - .textboxRef.Height - .Height - 2
				ENDIF 
			ENDC
		ENDWITH 
	ENDPROC

	PROCEDURE Show
		LPARAMETERS nStyle
		THIS.OLEMonthView.Width = this.Width 
		this.olemonthView.Height = this.Height 
		this.oleMonthView.SetFocus()
		
	ENDPROC

	PROCEDURE oleMonthView.DateClick
		*** ActiveX Control Event ***
		LPARAMETERS dateClicked
		DO CASE
		   CASE VARTYPE(THISFORM.oldvalue) = 'D'
		      THIS.PARENT.textboxref.SET('value',DATE(THIS.YEAR,THIS.MONTH,THIS.DAY))
		   CASE VARTYPE(THISFORM.oldvalue) = 'T'
		      THIS.PARENT.textboxref.VALUE = DATETIME(THIS.YEAR,THIS.MONTH,THIS.DAY ;
		         ,HOUR(THISFORM.oldvalue), MINUTE(THISFORM.oldvalue))
		ENDCASE
		THIS.PARENT.RELEASE
		
		
		
	ENDPROC

	PROCEDURE oleMonthView.DateDblClick
		*** ActiveX Control Event ***
		LPARAMETERS datedblclicked
		DO CASE
		   CASE VARTYPE(THISFORM.oldvalue) = 'D'
		      THIS.PARENT.textboxref.VALUE = DATE(THIS.YEAR,THIS.MONTH,THIS.DAY)
		   CASE VARTYPE(THISFORM.oldvalue) = 'T'
		      THIS.PARENT.textboxref.VALUE = DATETIME(THIS.YEAR,THIS.MONTH,THIS.DAY ;
		         ,HOUR(THISFORM.oldvalue), MINUTE(THISFORM.oldvalue))
		ENDCASE
		THIS.PARENT.RELEASE
		
	ENDPROC

	PROCEDURE oleMonthView.KeyPress
		*** ActiveX Control Event ***
		LPARAMETERS nKeyCode
		
		DO CASE
		   CASE nKeyCode = 13
		      DO CASE
		         CASE VARTYPE(THISFORM.oldvalue) = 'D'
		            THIS.PARENT.textboxref.VALUE = DATE(THIS.YEAR,THIS.MONTH,THIS.DAY)
		         CASE VARTYPE(THISFORM.oldvalue) = 'T'
		            THIS.PARENT.textboxref.VALUE = DATETIME(THIS.YEAR,THIS.MONTH,THIS.DAY ;
		               ,HOUR(THISFORM.oldvalue), MINUTE(THISFORM.oldvalue))
		      ENDCASE
		      THISFORM.RELEASE
		   CASE nKeyCode = 27
		      THISFORM.textboxref.VALUE = THISFORM.oldvalue
		      THISFORM.RELEASE
		ENDCASE
		
	ENDPROC

	PROCEDURE oleMonthView.SelChange
		*** ActiveX Control Event ***
		LPARAMETERS startdate, enddate, CANCEL
		DO CASE
		   CASE VARTYPE(THISFORM.oldvalue) = 'D'
		      THIS.PARENT.textboxref.VALUE = DATE(THIS.YEAR,THIS.MONTH,THIS.DAY)
		   CASE VARTYPE(THISFORM.oldvalue) = 'T'
		      THIS.PARENT.textboxref.VALUE = DATETIME(THIS.YEAR,THIS.MONTH,THIS.DAY ;
		         ,HOUR(THISFORM.oldvalue), MINUTE(THISFORM.oldvalue))
		ENDCASE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS calendar_form_desktop AS calendar_form OF "swdate.vcx" 		&& calendar form with Desktop = .T., instantiated when parent is top level form.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	AlwaysOnTop = .F.
	Desktop = .T.
	DoCreate = .T.
	Name = "calendar_form_desktop"
	oleMonthView.Height = 144
	oleMonthView.Left = 0
	oleMonthView.Name = "oleMonthView"
	oleMonthView.Top = 0
	oleMonthView.Width = 148

ENDDEFINE

DEFINE CLASS cbbutton AS combobox 		&& small combo-button only, I only needed the button
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: setpositionandsize
		*p: odatetextbox
		*p: otextbox
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Height = 22
	Name = "cbbutton"
	odatetextbox = null
	otextbox = .NULL.
	Width = 21
	_memberdata = <VFPData>
		<memberdata name="odatetextbox" type="property" display="oDateTextbox"/>
		<memberdata name="setpositionandsize" type="method" display="setPositionAndSize"/>
		<memberdata name="otextbox" type="property" display="oTextBox"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Destroy
		this.oTextBox = .Null.
		DODEFAULT()
	ENDPROC

	PROCEDURE DropDown
		oTextBox = EVALUATE('this.parent.' + this.oDateTextbox)
		oTextbox.DropDown()
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		MESSAGEBOX('Error: ' + TRANSFORM(nerror),0,'Error')
		DODEFAULT(nerror, cmethod, nline)
	ENDPROC

	PROCEDURE Init
		LPARAMETERS oTextBox
		
		this.oDateTextbox = oTextbox.Name
		this.oTextBox = oTextBox
		
	ENDPROC

	PROCEDURE setpositionandsize
		LPARAMETERS toTextbox
		WITH this
			.Top = toTextbox.Top
			.Left = toTextbox.Left + toTextbox.Width - 1
			.Height = toTextbox.Height
		ENDWITH 
		
	ENDPROC

	PROCEDURE When
		RETURN MDOWN()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS dpk AS txttextboxcustom OF "ccontrol.vcx" 		&& Textbox only from DatePicX classlib, modified
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: checkdate		&& Checks the date to see if it is in a closed period or year. Returns .T. if it is.
		*m: datepartinitfocus_assign
		*m: dropdown		&& afiseaza form calendr
		*m: height_assign
		*m: left_assign
		*m: lexitontabonly_assign
		*m: lupdowndisabled_assign
		*m: setstartendpositions		&& Sets the Day, Month and Year Start and End positions
		*m: setyearsellength		&& Sets the year selected length
		*m: top_assign
		*m: visible_assign
		*m: width_assign
		*p: blankdatestring
		*p: calendar_form_ref		&& referinta la formul cu calendar
		*p: cbbutton_name
		*p: csavedvalue
		*p: currentdate		&& Date on field entry
		*p: datepartinitfocus		&& Date part highlighted when control receives focus: 1- Month (default), 2-Day, 3-Year
		*p: datetype		&& Date Type 1-{mm/dd/yy},{mm-dd-yy},{mm.dd.yy}, 2-{dd/mm/yy},{dd-mm-yy},{dd.mm.yy}, 3-(yy/mm/dd),(yy-mm-dd),(yy.mm.dd)
		*p: dayend		&& Day end position
		*p: daystart		&& Day Start position
		*p: lallowblankdate		&& Allow blank dates
		*p: lcheckdate		&& When enabled, tells the class to check the date to see if it is valid. A valid date is one that doesn't exist in a closed fiscal year or period.
		*p: ldateclosed		&& .T. if the date has been checked and the period or year is closed.
		*p: lexitontabonly		&& Exit the control only on (Shift+)Tab
		*p: lmorethan90		&& Whether to check if the date is more than 90 days before/after the current date, and bring up a warning.
		*p: lnocheck		&& If .T. - don't check for closed fiscal prd or years.
		*p: lnocurrentdate		&& Set to .t. to keep it from defaulting to the current date.
		*p: lupdowndisabled		&& Flag indicating whether the Up / Down arrow keys are disabled ( +/- functionality only )
		*p: monthend		&& Month end position
		*p: monthstart		&& Month start position
		*p: oglmaint
		*p: yearend		&& Year end position
		*p: yearsellength		&& Selected length of the year ( 2 or 4 )
		*p: yearstart		&& Year start position
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	HIDDEN ldateclosed,oglmaint
	PROTECTED currentdate,dayend,daystart,monthend,monthstart,yearend,yearstart
	Alignment = 3
	blankdatestring = 99999999
	calendar_form_ref = .NULL.		&& referinta la formul cu calendar
	cbbutton_name = 
	csavedvalue = {}
	currentdate = 		&& Date on field entry
	datepartinitfocus = 2		&& Date part highlighted when control receives focus: 1- Month (default), 2-Day, 3-Year
	datetype = 1		&& Date Type 1-{mm/dd/yy},{mm-dd-yy},{mm.dd.yy}, 2-{dd/mm/yy},{dd-mm-yy},{dd.mm.yy}, 3-(yy/mm/dd),(yy-mm-dd),(yy.mm.dd)
	dayend = 1		&& Day end position
	daystart = 0		&& Day Start position
	FontName = "Tahoma"
	FontSize = 8
	Height = 22
	lallowblankdate = .T.		&& Allow blank dates
	lcheckdate = .F.		&& When enabled, tells the class to check the date to see if it is valid. A valid date is one that doesn't exist in a closed fiscal year or period.
	ldateclosed = .F.		&& .T. if the date has been checked and the period or year is closed.
	lexitontabonly = .T.		&& Exit the control only on (Shift+)Tab
	lmorethan90 = .F.		&& Whether to check if the date is more than 90 days before/after the current date, and bring up a warning.
	lnocheck = .F.		&& If .T. - don't check for closed fiscal prd or years.
	lnocurrentdate = .F.		&& Set to .t. to keep it from defaulting to the current date.
	monthend = 2		&& Month end position
	monthstart = 1		&& Month start position
	Name = "dpk"
	oglmaint = .NULL.
	Value = (DATE())
	Width = 75
	yearend = 9		&& Year end position
	yearsellength = 4		&& Selected length of the year ( 2 or 4 )
	yearstart = 6		&& Year start position
	_memberdata = <VFPData>
		<memberdata name="cbbutton_name" type="property" display="cbButton_name" favorites="True"/>
		<memberdata name="comboformref" type="property" display="comboFormRef"/>
		<memberdata name="oglmaint" type="property" display="oGLMaint"/>
		<memberdata name="lnocheck" type="property" display="lNoCheck"/>
		<memberdata name="checkdate" type="method" display="CheckDate"/>
		<memberdata name="ldateclosed" type="property" display="lDateClosed"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE checkdate		&& Checks the date to see if it is in a closed period or year. Returns .T. if it is.
		LPARAMETERS tdDate
		
		this.lDateClosed = .F.
		*  If we're supposed to check for closed periods, do it.
		IF THIS.lCheckDate
		   * Ignore blank values - pws 5/13/08
		   IF EMPTY(tdDate)
		      RETURN .F.
		   ENDIF 
		   
		   SWSELECT('sysctl')
		   *  Get the fiscal period and year the date is in
		   lcPeriod = THIS.oglmaint.getperiod(tdDate,.F.)
		   lcYear   = THIS.oglmaint.getperiod(tdDate,.T.)
		
		   SWSELECT('sysctl')
		   SET ORDER TO yrprdkey
		   IF SEEK(lcYear+lcPeriod+'NA')
		      this.lDateClosed = .T.
		   ELSE
		      SET ORDER TO yearclose
		      IF SEEK(lcYear+'YA')
		         this.lDateClosed = .T.
		      ENDIF
		   ENDIF
		ENDIF
		
		RETURN (this.lDateClosed)
	ENDPROC

	PROCEDURE Click
		THIS.SetFocus()
	ENDPROC

	PROCEDURE datepartinitfocus_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		
		IF INLIST( m.vNewVal, 1, 2, 3 )	&& Month, Day, Year
			THIS.DatePartInitFocus = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE dropdown		&& afiseaza form calendr
		IF EMPTY(this.Value)
		   this.Value = DATE()
		ENDIF 
		IF thisform.ShowWindow = 2
			this.calendar_form_ref = CREATEOBJECT('calendar_Form_desktop',this,thisform)
		ELSE 
			this.calendar_form_ref = CREATEOBJECT('calendar_Form',this,thisform)
		ENDIF 
		this.calendar_form_ref.AlwaysOnTop = .T.
		this.calendar_form_ref.Show()
		
		*!*	IF PEMSTATUS(thisform,'cworkarea',5)
		*!*	   thisform.setchanged(.T.,thisform.cworkarea)
		*!*	   this.Valid()
		*!*	ELSE 
		*!*	   this.Valid()
		*!*	ENDIF 
		thisform.setnextcontrol(this)
		
		
	ENDPROC

	PROCEDURE GotFocus
		LOCAL lnStart, lnLength
		
		WITH THIS
			.SetYearSelLength()		&& Set these property values each time we enter
			.SetStartEndPositions()	&& the control in case of programmatic changes
			.CurrentDate = .VALUE
		
			DO CASE
				CASE .DatePartInitFocus = 2	&& Day
					lnLength = 2
					lnStart = .DayStart
		
				CASE .DatePartInitFocus = 3	&& Year
					lnLength = .YearSelLength
					lnStart = .YearStart
		
				OTHERWISE					&& Month
					lnLength = 2
					lnStart = .MonthStart
			ENDCASE
		
			.SelStart = lnStart
			.SelLength = lnLength
		ENDWITH
		
	ENDPROC

	PROCEDURE height_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF vNewVal <> this.Height 
			this.Height = vNewVal
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.setPositionAndSize(this)
		ENDIF 
		
	ENDPROC

	PROCEDURE Init
		this.oGLMaint = CREATEOBJECT('glmaint')
		
		IF DODEFAULT()
		   SET CENTURY TO 
		   WITH THIS
		      .SetYearSelLength()
		      .SetStartEndPositions()
		      .cbButton_name = SYS(2015)
		      IF NOT INLIST( .PARENT.BASECLASS, 'Toolbar','Column')
		         .PARENT.NEWOBJECT( 	.cbButton_name ,'cbButton', '','',THIS)
		         loBtn = EVALUATE( '.parent.'+.cbButton_name)
		         loBtn.SetPositionAndSize(THIS)
		         loBtn.VISIBLE = THIS.VISIBLE
		      ENDIF
		   ENDWITH
		ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		IF DODEFAULT()
		   WITH THIS
		      IF INLIST( .DateType, 1, 2 )	&& MDY, DMY
		         DO CASE
		            CASE .SELSTART = 3
		               .SELLENGTH = 2
		
		            CASE .SELSTART = 6
		               .SELLENGTH = .YearSelLength
		         ENDCASE
		      ELSE							&& YMD
		         IF INLIST( .SELSTART, .MonthStart, .DayStart )	&& 5, 8
		            .SELLENGTH = 2
		         ENDIF
		      ENDIF
		      IF VARTYPE(THIS.VALUE) = 'D'
		         IF VAL(DTOC(THIS.VALUE,1)) = THIS.blankDateString
		            THIS.FORECOLOR = THIS.BACKCOLOR
		         ELSE
		            THIS.FORECOLOR = THIS.PARENT.FORECOLOR
		         ENDIF
		      ENDIF
		   ENDWITH
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		WITH THIS
			DO CASE
				CASE INLIST( nKeyCode, 32, 84, 116 )					&& Space Bar ( DATE() )
					NODEFAULT
					IF .ReadOnly
						RETURN
					ENDIF
					.VALUE = DATE()
					.REFRESH
					.SETFOCUS()
					RETURN 
				
				CASE nKeyCode = 1					&& Home ( Last Date entered )
					NODEFAULT
					IF .ReadOnly
						RETURN
					ENDIF
					.VALUE = .CurrentDate
					.REFRESH
					.SETFOCUS()
				    RETURN 
				    
				CASE nKeyCode = 4		&& Right Arrow
					IF .ReadOnly
						NODEFAULT
						RETURN
					ENDIF
					IF .DateType = 3	&& YMD 0123/56/89, 01/34/67
						DO CASE
							CASE .SelStart < .MonthStart	&& 5
								NODEFAULT
								.SelStart = .MonthStart		&& Moving to second date part ( Month )
								.SelLength = 2
		
							CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& 3, 8
								NODEFAULT
								.SelStart = .DayStart		&& Moving to third date part ( Day )
								.SelLength = 2
		
							CASE .SelStart >= .DayStart
								NODEFAULT
								IF NOT .lExitOnTabOnly
									KEYBOARD '{TAB}'		&& Exiting the control
								ENDIF
							
							OTHERWISE
								NODEFAULT
						ENDCASE
					ELSE				&& MDY/DMY 01/34/6789, 01/34/67
						DO CASE			&& Month and Day SelLengths are the same so we use
							CASE .SelStart < 3	&& Literals for performance here
								NODEFAULT
								.SelStart = 3	&& Moving to second date part ( Day or Month )
								.SelLength = 2
		
							CASE .SelStart > 1 AND .SelStart < 6
								NODEFAULT
								.SelStart = 6	&& Moving to third date part ( Year )
								.SelLength = .YearSelLength
							
							CASE .SelStart >= .YearStart
								NODEFAULT
								IF NOT .lExitOnTabOnly
									KEYBOARD '{TAB}'		&& Exiting the control
								ENDIF
		
							OTHERWISE
								NODEFAULT
						ENDCASE
					ENDIF
		
				CASE nKeyCode = 19					&& Left Arrow
					IF .ReadOnly
						NODEFAULT
						RETURN
					ENDIF
					IF .DateType = 3	&& YMD 0123/56/89, 01/34/67
						DO CASE
							CASE .SelStart > .MonthEnd	&& 7
								NODEFAULT
								.SelStart = .MonthStart	&& Moving to second date part ( Month )
								.SelLength = 2
		
							CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& 3, 8
								NODEFAULT
								.SelStart = 0	&& Moving to first date part ( Year )
								.SelLength = .YearSelLength
		
							CASE .SelStart < .MonthStart
								NODEFAULT
								IF NOT .lExitOnTabOnly
									KEYBOARD '{BACKTAB}'	&& Exiting the control
								ENDIF
							
							OTHERWISE
								NODEFAULT
						ENDCASE
					ELSE				&& MDY/DMY 01/34/6789, 01/34/67
						DO CASE			&& Month and Day SelLengths are the same so we use
							CASE .SelStart > 5	&& Literals for performance here
								NODEFAULT
								.SelStart = 3	&& Moving to second date part ( Day or Month )
								.SelLength = 2
		
							CASE .SelStart > 1 AND .SelStart < 6
								NODEFAULT
								.SelStart = 0	&& Moving to first date part ( Month or Day )
								.SelLength = 2
		
							CASE .SelStart < 3
								NODEFAULT
								IF NOT .lExitOnTabOnly
									KEYBOARD '{BACKTAB}'	&& Exiting the control
								ENDIF
							
							OTHERWISE
								NODEFAULT
						ENDCASE
					ENDIF
		        
				CASE INLIST( nKeyCode, 5, 43, 61 )	&& Up Arrow, '+'('=') ( Increment )
					NODEFAULT
					IF ( ( .lUpDownDisabled AND nKeyCode = 5 ) OR .ReadOnly )	&& Up Arrow disabled
						RETURN
					ENDIF
		
					DO CASE
						CASE .DateType = 1	&& MDY 01/34/6789, 01/34/67
							DO CASE			&& Use literals whenever possible for performance
								CASE .SelStart < 3						&& Month
									.VALUE = GOMONTH( .VALUE, 1 )
									.REFRESH
									.SelStart = 0
									.SelLength = 2
		
								CASE .SelStart > 1 AND .SelStart < 6	&& Day
									.VALUE = .VALUE + 1
									.REFRESH
									.SelStart = 3
									.SelLength = 2
		
								OTHERWISE								&& Year
									.VALUE = GOMONTH( .VALUE, 12 )
									.REFRESH
									.SelStart = 6
									.SelLength = .YearSelLength	&& 4
							ENDCASE
		
						CASE .DateType = 2	&& DMY 01/34/6789, 01/34/67
							DO CASE
								CASE .SelStart < 3						&& Day
									.VALUE = .VALUE + 1
									.REFRESH
									.SelStart = 0
									.SelLength = 2
		
								CASE .SelStart > 1 AND .SelStart < 6	&& Month
									.VALUE = GOMONTH( .VALUE, 1 )
									.REFRESH
									.SelStart = 3
									.SelLength = 2
		
								OTHERWISE								&& Year
									.VALUE = GOMONTH( .VALUE, 12 )
									.REFRESH
									.SelStart = 6
									.SelLength = .YearSelLength	&& 4
							ENDCASE
		
						OTHERWISE			&& YMD 0123/56/89, 01/34/67
							DO CASE
								CASE .SelStart < .MonthStart	&& 5	&& Year
									.VALUE = GOMONTH( .VALUE, 12 )
									.REFRESH
									.SelStart = 0
									.SelLength = .YearSelLength	&& 4
		
								CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& Month ( 3, 8 )
									.VALUE = GOMONTH( .VALUE, 1 )
									.REFRESH
									.SelStart = .MonthStart	&& 5
									.SelLength = 2
		
								OTHERWISE								&& Day
									.VALUE = .VALUE + 1
									.REFRESH
									.SelStart = .DayStart	&& 8
									.SelLength = 2
							ENDCASE
						ENDCASE
		                RETURN 
				CASE INLIST( nKeyCode, 24, 45 )	&& Down Arrow, '-' ( Decrement )
					NODEFAULT
					IF ( ( .lUpDownDisabled AND nKeyCode = 24 ) OR .ReadOnly )	&& Down Arrow disabled
						RETURN
					ENDIF
		
					DO CASE
						CASE .DateType = 1	&& MDY 01/34/6789, 01/34/67
							DO CASE			&& Use literals whenever possible for performance
								CASE .SelStart < 3						&& Month
									.VALUE = GOMONTH( .VALUE, -1 )
									.REFRESH
									.SelStart = 0
									.SelLength = 2
		
								CASE .SelStart > 1 AND .SelStart < 6	&& Day
									.VALUE = .VALUE - 1
									.REFRESH
									.SelStart = 3
									.SelLength = 2
		
								OTHERWISE								&& Year
									.VALUE = GOMONTH( .VALUE, -12 )
									.REFRESH
									.SelStart = 6
									.SelLength = .YearSelLength
							ENDCASE
		
						CASE .DateType = 2	&& DMY 01/34/6789, 01/34/67
							DO CASE
								CASE .SelStart < 3						&& Day
									.VALUE = .VALUE - 1
									.REFRESH
									.SelStart = 0
									.SelLength = 2
		
								CASE .SelStart > 1 AND .SelStart < 6	&& Month
									.VALUE = GOMONTH( .VALUE, -1 )
									.REFRESH
									.SelStart = 3
									.SelLength = 2
		
								OTHERWISE								&& Year
									.VALUE = GOMONTH( .VALUE, -12 )
									.REFRESH
									.SelStart = 6
									.SelLength = .YearSelLength
							ENDCASE
		
						OTHERWISE			&& YMD 0123/56/89, 01/34/67
							DO CASE
								CASE .SelStart < .MonthStart	&& 5	&& Year
									.VALUE = GOMONTH( .VALUE, -12 )
									.REFRESH
									.SelStart = 0
									.SelLength = .YearSelLength	&& 4
		
								CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& Month ( 3, 8 )
									.VALUE = GOMONTH( .VALUE, -1 )
									.REFRESH
									.SelStart = .MonthStart	&& 5
									.SelLength = 2
		
								OTHERWISE								&& Day
									.VALUE = .VALUE - 1
									.REFRESH
									.SelStart = .DayStart	&& 8
									.SelLength = 2
							ENDCASE
					ENDCASE
		            RETURN 
				CASE nKeyCode = 7								&& Del
					IF ( .ReadOnly OR NOT .lAllowBlankDate )
						NODEFAULT
						RETURN
					ENDIF
					.VALUE = {  /  /  }
		
				CASE ( nKeyCode > 47 AND nKeyCode < 60 )		&& Pass Digits
					IF .ReadOnly
						NODEFAULT
						RETURN
					ENDIF
		        CASE nKeyCode = 47                              && /
					   nodefault
					   RETURN
		
				CASE INLIST( nKeyCode, 9, 15 )					&& Pass TAB, Shift+TAB
		
				CASE ( nKeyCode = 13 )							&& Pass the Enter key
		
				CASE ( nKeyCode = 127 )							&& Pass the Backspace key
		
				CASE ( nKeyCode = 27 )							&& Pass the Escape key
				
				CASE nKeyCode = 145 OR nKeycode = -3 OR nKeyCode = 160
					this.DropDown()
				OTHERWISE										&& Inhibit all other key strokes
					NODEFAULT
			ENDCASE
		ENDWITH
		
		* DODEFAULT(nKeyCode, nShiftAltCtrl)
	ENDPROC

	PROCEDURE left_assign
		LPARAMETERS vNewVal
		IF vNewVal <> this.left
			this.left = vNewVal
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.setPositionAndSize(this)
		ENDIF 
		
	ENDPROC

	PROCEDURE lexitontabonly_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF VARTYPE( m.vNewVal ) = 'L'
			THIS.lExitOnTabOnly = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE lupdowndisabled_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF VARTYPE( vNewVal ) = 'L'
			THIS.lUpDownDisabled = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE Refresh
		IF DODEFAULT()
		   IF VARTYPE(THIS.VALUE) = 'D'
		      IF VAL(DTOC(THIS.VALUE,1)) = THIS.blankDateString
		         THIS.FORECOLOR = THIS.BACKCOLOR
		      ELSE
		         THIS.FORECOLOR = THIS.PARENT.FORECOLOR
		      ENDIF
		      IF THIS.lcheckdate
		         loBtn = EVALUATE( 'this.parent.'+THIS.cbButton_name)
		         THIS.ENABLED  = .T.
		         loBtn.ENABLED = .T.
		      ENDIF
		   ENDIF
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE setstartendpositions		&& Sets the Day, Month and Year Start and End positions
		*	We set the positions for testing when moving
		*	between date parts, etc.
		WITH THIS
			DO CASE
				CASE .DateType = 1			&& MDY 01/34/6789
					.DayStart = 3
					.DayEnd = 4
					.MonthStart = 0
					.MonthEnd = 1
					.YearStart = 6
					.YearEnd = 7			&& Century Off	(01/34/67)
		
					IF .YearSelLength = 4	&& Century On	(01/34/6789)
						.YearEnd = .YearEnd + 2
					ENDIF
		
				CASE .DateType = 2			&& DMY 01/34/6789
					.DayStart = 0
					.DayEnd = 1
					.MonthStart = 3
					.MonthEnd = 4
					.YearStart = 6
					.YearEnd = 7			&& Century Off	(01/34/67)
		
					IF .YearSelLength = 4	&& Century On	(01/34/6789)
						.YearEnd = .YearEnd + 2
					ENDIF
		
				OTHERWISE					&& YMD 0123/56/89
					.YearStart = 0
		
					.YearEnd = 1			&& Century Off	(01/34/67)
					.MonthStart = 3
					.MonthEnd = 4
					.DayStart = 6
					.DayEnd = 7
		
					IF .YearSelLength = 4	&& Century On	(0123/56/89)
						.YearEnd = .YearEnd + 2
						.MonthStart = .MonthStart + 2
						.MonthEnd = .MonthEnd + 2
						.DayStart = .DayStart + 2
						.DayEnd = .DayEnd + 2
					ENDIF
			ENDCASE
		ENDWITH
		
	ENDPROC

	PROTECTED PROCEDURE setyearsellength		&& Sets the year selected length
		WITH THIS
			DO CASE
				CASE .Century = 0	&& Off
					.YearSelLength = 2
		
				CASE .Century = 1	&& On
					.YearSelLength = 4
		
				CASE .Century = 2	&& Default
					IF SET( "CENTURY" ) = "ON"
						.YearSelLength = 4
					ELSE
						.YearSelLength = 2
					ENDIF
			ENDCASE
		ENDWITH
		
	ENDPROC

	PROCEDURE top_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF vNewVal <> this.Top
			this.top = vNewVal
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.setPositionAndSize(this)
		ENDIF 
		
	ENDPROC

	PROCEDURE Valid
		LOCAL llReturn, loError
		llReturn = .T.
		
		TRY
		   IF EMPTY( THIS.VALUE ) AND EMPTY(THIS.cSavedValue)
		      IF NOT THIS.lAllowBlankDate
		         MESSAGEBOX('The date cannot be left blank. Please correct by entering a valid date.', 16, 'Invalid Date')
		         llReturn = .F.
		      ELSE
		         IF NOT THIS.lNoCurrentDate
		            THIS.SET('VALUE', DATE())
		         ENDIF
		      ENDIF
		      IF THIS.lCheckdate
		         IF THIS.CheckDate(THIS.VALUE)
		            THISFORM.omessage.warning('This date is invalid. Either the fiscal year or period represented by this date has been closed.')
		            llReturn = .F.
		            EXIT
		         ENDIF
		      ENDIF
		   ELSE
		
		      IF THIS.VALUE # THIS.cSavedValue
		         IF THIS.lCheckdate
		            IF THIS.CheckDate(THIS.cSavedValue)
		* Checking to see if the current date on the entry is in a closed period or year
		               THISFORM.omessage.warning('This date cannot be changed. The fiscal period or year associated with this date has been closed.')
		               THIS.SET('value', THIS.cSavedValue)
		               THIS.REFRESH()
		               llReturn = .F.
		               EXIT
		            ELSE
		* Checking to see if the new date entered is in a closed period or year
		               IF THIS.CheckDate(THIS.VALUE)
		                  THISFORM.omessage.warning('This date is invalid. Either the fiscal year or period represented by this date has been closed.')
		                  THIS.SET('value', THIS.cSavedValue)
		                  llReturn = .F.
		                  EXIT
		               ENDIF
		            ENDIF
		         ENDIF
		
		         IF YEAR( THIS.VALUE ) < 1850 AND THIS.VALUE <> {  /  /    }  &&  Added blank date checking for this message, since the 5/2/08 update seemed to break something - BH 05/21/08
		            THISFORM.omessage.warning('This is an invalid date. The date must be greater than Jan 1, 1850')
		            llReturn = .F.
		            EXIT
		         ENDIF
		
		         IF THIS.lmorethan90 AND THISFORM.lChanged AND NOT MDOWN()  &&  Check to see if the date entered is more than 90 days before/after the current date
		            IF THIS.VALUE - DATE() < -90
		               IF NOT THISFORM.omessage.CONFIRM('This date is more than 90 days in the past.  Do you want to keep it and continue?')
		                  llReturn = .F.
		                  EXIT
		               ENDIF
		            ENDIF
		            IF THIS.VALUE - DATE() > 90
		               IF NOT THISFORM.omessage.CONFIRM('This date is more than 90 days in the future.  Do you want to keep it and continue?')
		                  llReturn = .F.
		                  EXIT
		               ENDIF
		            ENDIF
		         ENDIF
		      ENDIF
		   ENDIF
		CATCH TO loError
		   llReturn = .F.
		   DO errorlog WITH 'Valid', loError.LINENO, THISFORM.NAME, loError.ERRORNO, loError.MESSAGE, '', loError
		   MESSAGEBOX('Unable to process the date at this time. Check the System Log found under Other Reports for more information.' + CHR(10) + CHR(10) + ;
		        'Contact SherWare Support for help at support@sherware.com', 16, 'Problem Encountered')
		ENDTRY
		
		IF llReturn
		   RETURN (DODEFAULT())
		ELSE
		   RETURN .F.
		   EXIT
		ENDIF    
		
	ENDPROC

	PROCEDURE visible_assign
		LPARAMETERS vNewVal
		IF vNewVal <> this.Visible
			this.Visible = vNewVal
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.Visible = vNewVal
			
		ENDIF 
		
	ENDPROC

	PROCEDURE When
		this.csavedvalue = this.Value
		
		RETURN DODEFAULT()
		
		
	ENDPROC

	PROCEDURE width_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF vNewVal <> this.Width
			this.Width = vNewVal 
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.setPositionAndSize(this)
		ENDIF 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tpk AS txttextboxcustom OF "ccontrol.vcx" 		&& Textbox only from DatePicX classlib, modified
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: datepartinitfocus_assign
		*m: dropdown		&& Show the calendar form
		*m: height_assign
		*m: left_assign
		*m: lexitontabonly_assign
		*m: lupdowndisabled_assign
		*m: setstartendpositions		&& Sets the Day, Month and Year Start and End positions
		*m: setyearsellength		&& Sets the year selected length
		*m: top_assign
		*m: visible_assign
		*m: width_assign
		*p: ampmstart
		*p: blankdatetimestring
		*p: calendar_form_ref		&& referinta la formul cu calendar
		*p: cbbutton_name
		*p: currentdatetime		&& DateTime on field entry
		*p: datepartinitfocus		&& Date part highlighted when control receives focus: 1- Month (default), 2-Day, 3-Year
		*p: datetype		&& Date Type 1-{mm/dd/yy},{mm-dd-yy},{mm.dd.yy}, 2-{dd/mm/yy},{dd-mm-yy},{dd.mm.yy}, 3-(yy/mm/dd),(yy-mm-dd),(yy.mm.dd)
		*p: dayend		&& Day end position
		*p: daystart		&& Day Start position
		*p: hourend
		*p: hours24format
		*p: hourstart
		*p: lallowblankdate		&& Allow blank dates
		*p: lexitontabonly		&& Exit the control only on (Shift+)Tab
		*p: lupdowndisabled		&& Flag indicating whether the Up / Down arrow keys are disabled ( +/- functionality only )
		*p: minuteend
		*p: minutestart
		*p: monthend		&& Month end position
		*p: monthstart		&& Month start position
		*p: secondend
		*p: secondstart
		*p: yearend		&& Year end position
		*p: yearsellength		&& Selected length of the year ( 2 or 4 )
		*p: yearstart		&& Year start position
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED currentdatetime,dayend,daystart,hourend,hours24format,hourstart,minuteend,minutestart,monthend,monthstart,secondend,secondstart,yearend,yearstart
	Alignment = 3
	ampmstart = 20
	blankdatetimestring = 19000101000000
	calendar_form_ref = .NULL.		&& referinta la formul cu calendar
	cbbutton_name = 
	currentdatetime = 		&& DateTime on field entry
	datepartinitfocus = 2		&& Date part highlighted when control receives focus: 1- Month (default), 2-Day, 3-Year
	datetype = 2		&& Date Type 1-{mm/dd/yy},{mm-dd-yy},{mm.dd.yy}, 2-{dd/mm/yy},{dd-mm-yy},{dd.mm.yy}, 3-(yy/mm/dd),(yy-mm-dd),(yy.mm.dd)
	dayend = 1		&& Day end position
	daystart = 0		&& Day Start position
	FontName = "Tahoma"
	FontSize = 8
	Height = 22
	hourend = 12
	hourstart = 11
	lallowblankdate = .T.		&& Allow blank dates
	lexitontabonly = .T.		&& Exit the control only on (Shift+)Tab
	minuteend = 15
	minutestart = 14
	monthend = 4		&& Month end position
	monthstart = 3		&& Month start position
	Name = "tpk"
	secondend = 18
	secondstart = 17
	Value = (DATETIME())
	Width = 115
	yearend = 9		&& Year end position
	yearsellength = 4		&& Selected length of the year ( 2 or 4 )
	yearstart = 6		&& Year start position
	_memberdata = <VFPData>
		<memberdata name="cbbutton_name" type="property" display="cbButton_name" favorites="True"/>
		<memberdata name="comboformref" type="property" display="comboFormRef"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Click
		THIS.SetFocus()
	ENDPROC

	PROCEDURE datepartinitfocus_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		
		IF INLIST( m.vNewVal, 1, 2, 3 )	&& Month, Day, Year
			THIS.DatePartInitFocus = m.vNewVal
		ENDIF
	ENDPROC

	PROCEDURE dropdown		&& Show the calendar form
		IF thisform.ShowWindow = 2
			this.calendar_form_ref = CREATEOBJECT('calendar_Form_desktop',this,thisform)
		ELSE 
			this.calendar_form_ref = CREATEOBJECT('calendar_Form',this,thisform)
		ENDIF 
		this.calendar_form_ref.AlwaysOnTop = .T.
		this.calendar_form_ref.Show()
		
	ENDPROC

	PROCEDURE GotFocus
		LOCAL lnStart, lnLength
		
		WITH THIS
			.SetYearSelLength()		&& Set these property values each time we enter
			.SetStartEndPositions()	&& the control in case of programmatic changes
			.CurrentDateTime = .Value
		
			DO CASE
				CASE .DatePartInitFocus = 2	&& Day
					lnLength = 2
					lnStart = .DayStart
		
				CASE .DatePartInitFocus = 3	&& Year
					lnLength = .YearSelLength
					lnStart = .YearStart
		
				OTHERWISE					&& Month
					lnLength = 2
					lnStart = .MonthStart
			ENDCASE
		
			.SelStart = lnStart
			.SelLength = lnLength
		ENDWITH
		
	ENDPROC

	PROCEDURE height_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF vNewVal <> this.Height 
			this.Height = vNewVal
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.setPositionAndSize(this)
		ENDIF 
		
	ENDPROC

	PROCEDURE Init
		WITH THIS
			.SetYearSelLength()
			.SetStartEndPositions()
			.cbButton_name = SYS(2015)
			IF NOT INLIST( .Parent.BaseClass, 'Toolbar','Column')
				.Parent.NewObject( 	.cbButton_name ,'cbButton', '','',this)
				loBtn = EVALUATE( '.parent.'+.cbButton_name)
				loBtn.SetPositionAndSize(this)
				loBtn.Visible = this.Visible 
			ENDIF 
		ENDWITH
		
	ENDPROC

	PROCEDURE InteractiveChange
		WITH THIS
			IF INLIST( .DateType, 1, 2 )	&& MDY, DMY
				DO CASE
					CASE .SelStart = 3
						.SelLength = 2
		
					CASE .SelStart = 6
						.SelLength = .YearSelLength
		
					CASE INLIST( .SelStart, .HourStart, .MinuteStart, .SecondStart )
						.SelLength = 2
				ENDCASE
			ELSE							&& YMD
				IF INLIST( .SelStart, .MonthStart, .DayStart .HourStart, .MinuteStart, .SecondStart )	&& 5, 8
					.SelLength = 2
				ENDIF
			ENDIF
			IF VARTYPE(this.Value) = 'D'
				IF VAL(TTOC(this.value,1)) = this.blankDateTimeString 
					.ForeColor = .BackColor 
				ELSE
					.ForeColor = .Parent.ForeColor
				ENDIF 
			ENDIF	
		ENDWITH
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		#DEFINE	SECONDS_PER_MINUTE	60
		#DEFINE	SECONDS_PER_HOUR	3600
		#DEFINE	SECONDS_PER_DAY		86400
		
		WITH THIS
			DO CASE
				CASE nKeyCode = 32					&& Space Bar ( DATE() )
					NODEFAULT
					IF .ReadOnly
						RETURN
					ENDIF
					.Value = DATE()
					.REFRESH
					.SETFOCUS()
				
				CASE nKeyCode = 1					&& Home ( Last Date entered )
					NODEFAULT
					IF .ReadOnly
						RETURN
					ENDIF
					.Value = .CurrentDateTime
					.REFRESH
					.SETFOCUS()
				
				CASE nKeyCode = 4		&& Right Arrow
					IF .ReadOnly
						NODEFAULT
						RETURN
					ENDIF
					IF .DateType = 3	&& YMD 0123/56/89 12:45:78 01, 01/34/67 12:45:78 01
										&&	   YYYY/MM/DD HH:MM:SS PM, YY/MM/DD HH:MM:SS PM
						DO CASE
							CASE .SelStart < .MonthStart	&& 5
								NODEFAULT
								.SelStart = .MonthStart		&& Moving to second date part ( Month )
								.SelLength = 2
		
							CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& 3, 8
								NODEFAULT
								.SelStart = .DayStart		&& Moving to third date part ( Day )
								.SelLength = 2
							
							CASE .SelStart > .MonthEnd AND .SelStart < .HourStart
								NODEFAULT
								.SelStart = .HourStart		&& Moving to Hour time part
								.SelLength = 2
		
							CASE .SelStart > .DayEnd AND .SelStart < .MinuteStart
								NODEFAULT
								.SelStart = .MinuteStart	&& Moving to Minute time part
								.SelLength = 2
		
							CASE .SelStart > .HourEnd AND .SelStart < .SecondStart
								NODEFAULT
								.SelStart = .SecondStart	&& Moving to Second time part
								.SelLength = 2
		
							CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart
								NODEFAULT
								.SelStart = .AMPMStart		&& Moving to AMPM time part
								.SelLength = 2
		
							CASE .SelStart >= .AMPMStart
								NODEFAULT
								IF NOT .lExitOnTabOnly
									KEYBOARD '{TAB}'		&& Exiting the control
								ENDIF
							
							OTHERWISE
								NODEFAULT
						ENDCASE
					ELSE				&& MDY/DMY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
										&&	   	   MM/DD/YYYY HH:MM:SS PM, MM/DD/YY HH:MM:SS PM
						DO CASE			&& Month and Day SelLengths are the same so we use
							CASE .SelStart < 3	&& Literals for performance here when we can
								NODEFAULT
								.SelStart = 3	&& Moving to second date part ( Day or Month )
								.SelLength = 2
		
							CASE .SelStart > 1 AND .SelStart < 6
								NODEFAULT
								.SelStart = 6	&& Moving to third date part ( Year )
								.SelLength = .YearSelLength
		
							CASE .SelStart >= .YearStart AND .SelStart < .HourStart
								NODEFAULT
								.SelStart = .HourStart		&& Moving to Hour time part
								.SelLength = 2
		
							CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart
								NODEFAULT
								.SelStart = .MinuteStart	&& Moving to Minute time part
								.SelLength = 2
		
							CASE .SelStart > .HourEnd AND .SelStart < .SecondStart
								NODEFAULT
								.SelStart = .SecondStart	&& Moving to Second time part
								.SelLength = 2
		
							CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart
								NODEFAULT
								.SelStart = .AMPMStart		&& Moving to AMPM time part
								.SelLength = 2
						
							CASE .SelStart >= .AMPMStart
								NODEFAULT
								IF NOT .lExitOnTabOnly
									KEYBOARD '{TAB}'		&& Exiting the control
								ENDIF
							
							OTHERWISE
								NODEFAULT
						ENDCASE
					ENDIF
		
				CASE nKeyCode = 19					&& Left Arrow
					IF .ReadOnly
						NODEFAULT
						RETURN
					ENDIF
					IF .DateType = 3	&& YMD 0123/56/89 12:45:78 01, 01/34/67 12:45:78 01
										&&	   YYYY/MM/DD HH:MM:SS PM, YY/MM/DD HH:MM:SS PM
						DO CASE
							CASE .Hours24Format AND .SelStart >= .SecondStart	&& Moving to Minute time part
								NODEFAULT
								.SelStart = .MinuteStart	&& Moving to Minute time part
								.SelLength = 2
		
							CASE .SelStart > .SecondEnd
								NODEFAULT
								.SelStart = .SecondStart	&& Moving to Seconds time part
								.SelLength = 2
		
							CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart
								NODEFAULT
								.SelStart = .MinuteStart	&& Moving to Minute time part
								.SelLength = 2
		
							CASE .SelStart > .HourEnd AND .SelStart < .SecondStart
								NODEFAULT
								.SelStart = .HourStart	&& Moving to Hour time part
								.SelLength = 2
		
							CASE .SelStart > .DayEnd AND .SelStart < .MinuteStart
								NODEFAULT
								.SelStart = .DayStart	&& Moving to third date part ( Day )
								.SelLength = 2
		
							CASE .SelStart > .MonthEnd AND .SelStart < .HourStart	&& 7
								NODEFAULT
								.SelStart = .MonthStart	&& Moving to second date part ( Month )
								.SelLength = 2
		
							CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& 3, 8
								NODEFAULT
								.SelStart = 0	&& Moving to first date part ( Year )
								.SelLength = .YearSelLength
							
							CASE .SelStart < .MonthStart
								NODEFAULT
								IF NOT .lExitOnTabOnly
									KEYBOARD '{BACKTAB}'	&& Exiting the control
								ENDIF
							
							OTHERWISE
								NODEFAULT
						ENDCASE
					ELSE				&& MDY/DMY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
										&&	   	   MM/DD/YYYY HH:MM:SS PM, MM/DD/YY HH:MM:SS PM
						DO CASE			&& Month and Day SelLengths are the same so we use literal when we can
							CASE .Hours24Format AND .SelStart >= .SecondStart	&& Moving to Minute time part
								NODEFAULT
								.SelStart = .MinuteStart	&& Moving to Minute time part
								.SelLength = 2
		
							CASE .SelStart > .SecondEnd
								NODEFAULT
								.SelStart = .SecondStart	&& Moving to Seconds time part
								.SelLength = 2
		
							CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart
								NODEFAULT
								.SelStart = .MinuteStart	&& Moving to Minute time part
								.SelLength = 2
		
							CASE .SelStart > .HourEnd AND .SelStart < .SecondStart
								NODEFAULT
								.SelStart = .HourStart	&& Moving to Hour time part
								.SelLength = 2
		
							CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart
								NODEFAULT
								.SelStart = .YearStart	&& Moving to third date part ( Year )
								.SelLength = .YearSelLength
		
							CASE .SelStart > 4 AND .SelStart < .HourStart
								NODEFAULT
								.SelStart = 3	&& Moving to second date part ( Day or Month )
								.SelLength = 2
		
							CASE .SelStart > 1 AND .SelStart < 6
								NODEFAULT
								.SelStart = 0	&& Moving to first date part ( Month or Day )
								.SelLength = 2
							
							CASE .SelStart < 3
								NODEFAULT
								IF NOT .lExitOnTabOnly
									KEYBOARD '{BACKTAB}'	&& Exiting the control
								ENDIF
							
							OTHERWISE
								NODEFAULT
						ENDCASE
					ENDIF
		
				CASE INLIST( nKeyCode, 5, 43, 61 )	&& Up Arrow, '+'('=') ( Increment )
					NODEFAULT
					IF ( ( .lUpDownDisabled AND nKeyCode = 5 ) OR .ReadOnly )	&& Up Arrow disabled
						RETURN
					ENDIF
		
					DO CASE
						CASE .DateType = 1	&& MDY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
											&&	   MM/DD/YYYY HH:MM:SS PM, MM/DD/YY HH:MM:SS PM
							DO CASE			&& Use literals whenever possible for performance
								CASE .SelStart < 3						&& Month
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, 1 ) )
									.REFRESH
									.SelStart = 0
									.SelLength = 2
		
								CASE .SelStart > 1 AND .SelStart < 6	&& Day
									.Value = .Value + SECONDS_PER_DAY
									.REFRESH
									.SelStart = 3
									.SelLength = 2
		
								CASE .SelStart > 4 AND .SelStart < .HourStart	&& Year
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, 12 ) )
									.REFRESH
									.SelStart = 6
									.SelLength = .YearSelLength	&& 4
		
								CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart	&& Hour
									.Value = .Value + SECONDS_PER_HOUR
									.REFRESH
									.SelStart = .HourStart
									.SelLength = 2
		
								CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
									.Value = .Value + SECONDS_PER_MINUTE
									.REFRESH
									.SelStart = .MinuteStart
									.SelLength = 2
		
								CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
									.Value = .Value + 1
									.REFRESH
									.SelStart = .SecondStart
									.SelLength = 2
		
								CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
									.Value = .Value + IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
									.REFRESH
									.SelStart = .AMPMStart
									.SelLength = 2
		
								OTHERWISE
									NODEFAULT
							ENDCASE
		
						CASE .DateType = 2	&& DMY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
											&&	   DD/MM/YYYY HH:MM:SS PM, DD/MM/YY HH:MM:SS PM
							DO CASE
								CASE .SelStart < 3						&& Day
									.Value = .Value + SECONDS_PER_DAY
									.REFRESH
									.SelStart = 0
									.SelLength = 2
		
								CASE .SelStart > 1 AND .SelStart < 6	&& Month
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, 1 ) )
									.REFRESH
									.SelStart = 3
									.SelLength = 2
		
								CASE .SelStart > 4 AND .SelStart < .HourStart	&& Year
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, 12 ) )
									.REFRESH
									.SelStart = 6
									.SelLength = .YearSelLength	&& 4
		
								CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart	&& Hour
									.Value = .Value + SECONDS_PER_HOUR
									.REFRESH
									.SelStart = .HourStart
									.SelLength = 2
		
								CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
									.Value = .Value + SECONDS_PER_MINUTE
									.REFRESH
									.SelStart = .MinuteStart
									.SelLength = 2
		
								CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
									.Value = .Value + 1
									.REFRESH
									.SelStart = .SecondStart
									.SelLength = 2
		
								CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
									.Value = .Value + IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
									.REFRESH
									.SelStart = .AMPMStart
									.SelLength = 2
		
								OTHERWISE
									NODEFAULT
							ENDCASE
		
						OTHERWISE			&& YMD 0123/56/89 12:45:78 01, 01/34/67 12:45:78 01
											&&	   YYYY/MM/DD HH:MM:SS PM, YY/MM/DD HH:MM:SS PM
							DO CASE
								CASE .SelStart < .MonthStart	&& 5	&& Year
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, 12 ) )
									.REFRESH
									.SelStart = 0
									.SelLength = .YearSelLength	&& 4
		
								CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& Month ( 3, 8 )
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, 1 ) )
									.REFRESH
									.SelStart = .MonthStart	&& 5
									.SelLength = 2
		
								CASE .SelStart >= .MonthEnd AND .SelStart < .HourStart	&& Day
									.Value = .Value + SECONDS_PER_DAY
									.REFRESH
									.SelStart = .DayStart	&& 8
									.SelLength = 2
		
								CASE .SelStart > .DayEnd AND .SelStart < .MinuteStart	&& Hour
									.Value = .Value + SECONDS_PER_HOUR
									.REFRESH
									.SelStart = .HourStart
									.SelLength = 2
		
								CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
									.Value = .Value + SECONDS_PER_MINUTE
									.REFRESH
									.SelStart = .MinuteStart
									.SelLength = 2
		
								CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
									.Value = .Value + 1
									.REFRESH
									.SelStart = .SecondStart
									.SelLength = 2
		
								CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
									.Value = .Value + IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
									.REFRESH
									.SelStart = .AMPMStart
									.SelLength = 2
		
								OTHERWISE
									NODEFAULT
							ENDCASE
						ENDCASE
		
				CASE INLIST( nKeyCode, 24, 45 )	&& Down Arrow, '-' ( Decrement )
					NODEFAULT
					IF ( ( .lUpDownDisabled AND nKeyCode = 24 ) OR .ReadOnly )	&& Down Arrow disabled
						RETURN
					ENDIF
		
					DO CASE
						CASE .DateType = 1	&& MDY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
											&&	   MM/DD/YYYY HH:MM:SS PM, MM/DD/YY HH:MM:SS PM
							DO CASE			&& Use literals whenever possible for performance
								CASE .SelStart < 3						&& Month
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, -1 ) )
									.REFRESH
									.SelStart = 0
									.SelLength = 2
		
								CASE .SelStart > 1 AND .SelStart < 6	&& Day
									.Value = .Value - SECONDS_PER_DAY
									.REFRESH
									.SelStart = 3
									.SelLength = 2
		
								CASE .SelStart > .DayEnd AND .SelStart < .HourStart	&& Year
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, -12 ) )
									.REFRESH
									.SelStart = 6
									.SelLength = .YearSelLength
		
								CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart	&& Hour
									.Value = .Value - SECONDS_PER_HOUR
									.REFRESH
									.SelStart = .HourStart
									.SelLength = 2
		
								CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
									.Value = .Value - SECONDS_PER_MINUTE
									.REFRESH
									.SelStart = .MinuteStart
									.SelLength = 2
		
								CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
									.Value = .Value - 1
									.REFRESH
									.SelStart = .SecondStart
									.SelLength = 2
		
								CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
									.Value = .Value - IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
									.REFRESH
									.SelStart = .AMPMStart
									.SelLength = 2
		
								OTHERWISE
									NODEFAULT
							ENDCASE
		
						CASE .DateType = 2	&& DMY 01/34/6789 12:45:78 01, 01/34/67 12:45:78 01
											&&	   DD/MM/YYYY HH:MM:SS PM, DD/MM/YY HH:MM:SS PM
							DO CASE
								CASE .SelStart < 3						&& Day
									.Value = .Value - SECONDS_PER_DAY
									.REFRESH
									.SelStart = 0
									.SelLength = 2
		
								CASE .SelStart > 1 AND .SelStart < 6	&& Month
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, -1 ) )
									.REFRESH
									.SelStart = 3
									.SelLength = 2
		
								CASE .SelStart > .MonthEnd AND .SelStart < .HourStart	&& Year
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, -12 ) )
									.REFRESH
									.SelStart = 6
									.SelLength = .YearSelLength
		
								CASE .SelStart > .YearEnd AND .SelStart < .MinuteStart	&& Hour
									.Value = .Value - SECONDS_PER_HOUR
									.REFRESH
									.SelStart = .HourStart
									.SelLength = 2
		
								CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
									.Value = .Value - SECONDS_PER_MINUTE
									.REFRESH
									.SelStart = .MinuteStart
									.SelLength = 2
		
								CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
									.Value = .Value - 1
									.REFRESH
									.SelStart = .SecondStart
									.SelLength = 2
		
								CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
									.Value = .Value - IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
									.REFRESH
									.SelStart = .AMPMStart
									.SelLength = 2
		
								OTHERWISE
									NODEFAULT
							ENDCASE
		
						OTHERWISE			&& YMD 0123/56/89 12:45:78 01, 01/34/67 12:45:78 01
											&&	   YYYY/MM/DD HH:MM:SS PM, YY/MM/DD HH:MM:SS PM
							DO CASE
								CASE .SelStart < .MonthStart	&& 5	&& Year
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, -12 ) )
									.REFRESH
									.SelStart = 0
									.SelLength = .YearSelLength	&& 4
		
								CASE .SelStart > .YearEnd AND .SelStart < .DayStart	&& Month ( 3, 8 )
									.Value = ( .Value - DTOT( TTOD( .Value ) ) ) + ;
												DTOT( GOMONTH( .Value, -1 ) )
									.REFRESH
									.SelStart = .MonthStart	&& 5
									.SelLength = 2
		
								CASE .SelStart > .MonthEnd AND .SelStart < .HourStart	&& Day
									.Value = .Value - SECONDS_PER_DAY
									.REFRESH
									.SelStart = .DayStart	&& 8
									.SelLength = 2
		
								CASE .SelStart > .DayEnd AND .SelStart < .MinuteStart	&& Hour
									.Value = .Value + SECONDS_PER_HOUR
									.REFRESH
									.SelStart = .HourStart
									.SelLength = 2
		
								CASE .SelStart > .HourEnd AND .SelStart < .SecondStart	&& Minute
									.Value = .Value + SECONDS_PER_MINUTE
									.REFRESH
									.SelStart = .MinuteStart
									.SelLength = 2
		
								CASE .SelStart > .MinuteEnd AND .SelStart < .AMPMStart	&& Second
									.Value = .Value + 1
									.REFRESH
									.SelStart = .SecondStart
									.SelLength = 2
		
								CASE .SelStart >= .AMPMStart			&& AM/PM or Seconds
									.Value = .Value - IIF( .Hours24Format, 1, SECONDS_PER_DAY / 2 )
									.REFRESH
									.SelStart = .AMPMStart
									.SelLength = 2
		
								OTHERWISE		&& AM/PM
									NODEFAULT
							ENDCASE
					ENDCASE
		
				CASE nKeyCode = 7								&& Del
					IF ( .ReadOnly OR NOT .lAllowBlankDate )
						NODEFAULT
						RETURN
					ENDIF
					.Value = {  /  /  }
		
				CASE ( ( nKeyCode > 47 AND nKeyCode < 60 ) OR INLIST( nKeyCode, 65, 97, 80, 112 ) )
					IF .ReadOnly	&& Pass Digits, 'A', 'a', 'P' and 'p' if editable
						NODEFAULT
						RETURN
					ENDIF
		
				CASE INLIST( nKeyCode, 9, 15 )					&& Pass TAB, Shift+TAB
		
				CASE ( nKeyCode = 13 )							&& Pass the Enter key
		
				CASE ( nKeyCode = 127 )							&& Pass the Backspace key
		
				CASE ( nKeyCode = 27 )							&& Pass the Escape key
		
				CASE nKeyCode = 145 OR nKeycode = -3 OR nKeyCode = 160
					this.DropDown()
				OTHERWISE										&& Inhibit all other key strokes
					NODEFAULT
			ENDCASE
		ENDWITH
		
	ENDPROC

	PROCEDURE left_assign
		LPARAMETERS vNewVal
		IF vNewVal <> this.left
			this.left = vNewVal
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.setPositionAndSize(this)
		ENDIF 
		
	ENDPROC

	PROCEDURE lexitontabonly_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF VARTYPE( m.vNewVal ) = 'L'
			THIS.lExitOnTabOnly = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE lupdowndisabled_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF VARTYPE( vNewVal ) = 'L'
			THIS.lUpDownDisabled = m.vNewVal
		ENDIF
		
	ENDPROC

	PROCEDURE Refresh
		IF VARTYPE(this.Value) = 'D'
			IF VAL(TTOC(this.value,1)) = this.blankDateTimeString 
				this.ForeColor = this.BackColor 
			ELSE
				this.ForeColor = this.Parent.ForeColor
			ENDIF 
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE setstartendpositions		&& Sets the Day, Month and Year Start and End positions
		*	We set the positions for testing when moving
		*	between date parts, etc.
		WITH THIS
			DO CASE
				CASE .DateType = 1			&& MDY 01/34/6789
					.DayStart = 3
					.DayEnd = 4
					.MonthStart = 0
					.MonthEnd = 1
					.YearStart = 6
					.YearEnd = 7			&& Century Off	(01/34/67)
		
					IF .YearSelLength = 4	&& Century On	(01/34/6789)
						.YearEnd = .YearEnd + 2
					ENDIF
		
				CASE .DateType = 2			&& DMY 01/34/6789
					.DayStart = 0
					.DayEnd = 1
					.MonthStart = 3
					.MonthEnd = 4
					.YearStart = 6
					.YearEnd = 7			&& Century Off	(01/34/67)
		
					IF .YearSelLength = 4	&& Century On	(01/34/6789)
						.YearEnd = .YearEnd + 2
					ENDIF
		
				OTHERWISE					&& YMD 0123/56/89
					.YearStart = 0
		
					.YearEnd = 1			&& Century Off	(01/34/67)
					.MonthStart = 3
					.MonthEnd = 4
					.DayStart = 6
					.DayEnd = 7
		
					IF .YearSelLength = 4	&& Century On	(0123/56/89)
						.YearEnd = .YearEnd + 2
						.MonthStart = .MonthStart + 2
						.MonthEnd = .MonthEnd + 2
						.DayStart = .DayStart + 2
						.DayEnd = .DayEnd + 2
					ENDIF
			ENDCASE
		
		*	Time data
			.HourStart = 9		&& Century Off
			.MinuteStart = 12
			.SecondStart = 15
			.AMPMStart = 18
			.Hours24Format = .F.
		
			IF .YearSelLength = 4	&& Century On (01/34/6789)
				.HourStart = .HourStart + 2
				.MinuteStart = .MinuteStart + 2
				.SecondStart = .SecondStart + 2
				.AMPMStart = .AMPMStart + 2
			ENDIF
		
			.HourEnd = .HourStart + 1
			.MinuteEnd = .MinuteStart + 1
			.SecondEnd = .SecondStart + 1
		
			IF ( .Hours = 24 OR ( .Hours = 0 AND SET( "HOURS" ) = 24 ) )
				.AMPMStart = .SecondStart	&& 24 hour Military time
				.Hours24Format = .T.
			ENDIF
		
		ENDWITH
		
	ENDPROC

	PROTECTED PROCEDURE setyearsellength		&& Sets the year selected length
		WITH THIS
			DO CASE
				CASE .Century = 0	&& Off
					.YearSelLength = 2
		
				CASE .Century = 1	&& On
					.YearSelLength = 4
		
				CASE .Century = 2	&& Default
					IF SET( "CENTURY" ) = "ON"
						.YearSelLength = 4
					ELSE
						.YearSelLength = 2
					ENDIF
			ENDCASE
		ENDWITH
		
	ENDPROC

	PROCEDURE top_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF vNewVal <> this.Top
			this.top = vNewVal
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.setPositionAndSize(this)
		ENDIF 
		
	ENDPROC

	PROCEDURE Valid
		IF EMPTY( THIS.VALUE )
			IF NOT THIS.lAllowBlankDate
				RETURN 0
			ENDIF
		ELSE
			IF YEAR( THIS.VALUE ) = 0
				RETURN 0
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE visible_assign
		LPARAMETERS vNewVal
		IF vNewVal <> this.Visible
			this.Visible = vNewVal
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.Visible = vNewVal
			
		ENDIF 
		
	ENDPROC

	PROCEDURE width_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		IF vNewVal <> this.Width
			this.Width = vNewVal 
			oButtonRef = EVALUATE('this.parent.' + this.cbButton_name)
			oButtonRef.setPositionAndSize(this)
		ENDIF 
		
	ENDPROC

ENDDEFINE
