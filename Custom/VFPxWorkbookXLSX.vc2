*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="vfpxworkbookxlsx.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS vfpxworkbookxlsx AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "vfpxworkbookxlsx.h"
	*<DefinedPropArrayMethod>
		*m: addclassdefinednumericformats		&& Adds pre-defined numeric cell formats
		*m: addcustomnumericformat		&& Adds a new custom defined numeric format
		*m: addinlinefontobject		&& Adds an object for setting the inline formatting of cell text
		*m: addnamedrange		&& Adds a name range to the workbook
		*m: addnumericformat		&& Adds a numeric format expression to be used
		*m: addsheet		&& Adds a new sheet to the workbook
		*m: addstringvalue		&& Adds a string value to the internal cursor
		*m: cellformatpainter		&& Copies the formatting of a source cell to other cells
		*m: clearcellvalidation		&& Clears/deletes the named range from the workbook
		*m: clearcellvalue		&& Clears the cell value
		*m: columnasciitoindex		&& Converts Excel Ascii column value to index value
		*m: columnindextoascii		&& Gets the column ASCII code for the column index
		*m: convertcolortohex		&& Converts a color value (integer) to Hex representation
		*m: converthexstringtonumeric		&& ConvertHexStringToNumeric
		*m: convertpixelstoexcelunits		&& Converts Pixel measurement to Excel measurement
		*m: createexcelfile		&& Creates the Excel file from the components
		*m: createinlineformattext		&& Creates an in-line text formatted definition
		*m: createworkbook		&& Creates a new workbook object
		*m: createworkbookex		&& Internal method for creating a workbook
		*m: createworkingcursors		&& Creates the working cursors for worksheet definitions
		*m: createworkingdirectories		&& Creates the working directories for the XML files
		*m: debugcursorstofile		&& Debugging use for saving the internal cursors to a text file
		*m: debugoutput		&& Limited functions for debugging
		*m: debug_assign
		*m: declaredll		&& Declares the required support Win32 API
		*m: deleteallworkbooks		&& Deletes all workbooks
		*m: deletesheet		&& Deletes the sheet from the Workbook
		*m: deleteworkbook		&& Deletes the selected workbook
		*m: demo		&& Demo for the features of this class
		*m: derivesheetname		&& Derives the sheet name
		*m: destroyworkingcursors		&& Destroys the working cursors
		*m: documentation		&& Documentation of the methods and properties for this class
		*m: freezepanes		&& Freezes the panes of the sheet
		*m: getbordersrecord		&& Gets the border record; returns True if found, or False in not found
		*m: getcellalignment		&& Returns the cell alignment
		*m: getcellborders		&& Returns the cell border info
		*m: getcelldatatype		&& Returns the data type for the selected cell
		*m: getcellfill		&& Returns the fill info for the cell
		*m: getcellfont		&& Returns the cell font settings
		*m: getcellformula		&& Returns the cell formula expression
		*m: getcellformulafromxml		&& Gets the cell formula from the XML node
		*m: getcellindent		&& Returns the cell indentation
		*m: getcellnumberformat		&& Returns the format code for the selected cell
		*m: getcellrecord		&& Positions to the xl_cells record; returns true if found, or false if not found
		*m: getcelltextrotation		&& Gets the cell text rotation value
		*m: getcellvalidation		&& Returns the cell validation settings
		*m: getcellvalue		&& Returns the value of the cell
		*m: getcellwordwrap		&& Returns the cell word wrap setting
		*m: getcellxfsid		&& Returns the Cell XfsId value
		*m: getcellxfsrecord		&& Positions the record pointer to xl_cellxfs record; returns true if found, or false if not found
		*m: getchildnodecount		&& Returns the number of child nodes
		*m: getchildnodeelement		&& Returns the selected child node
		*m: getcolumnincolrowpair		&& Returns the column (Ascii value) in a ColRow pair; i.e., returns A from A6 reference
		*m: getcolumnwidth		&& Returns the column width
		*m: getcolwidthkeyexpr		&& Gets the key expression for c_colwidths
		*m: getcursorrecord		&& Gets the specified xl_cursor record; returns true if found, false if not found
		*m: getcustomnumericformat		&& Returns the format code for the specified custom numeric format
		*m: getcustompapersize		&& Gets the values for the custom paper size
		*m: getformatkeyexpr		&& Gets the key expression for t_format
		*m: getheaderfooterkeyexpr		&& Gets the key expression for the header footer table record
		*m: getinlinefontdefinition		&& Returns the inline formatting definition of cell text for each character group
		*m: getlastcolumninrow		&& Returns the last column index in the row
		*m: getlastrownumber		&& Returns the last row number in the sheet
		*m: getmaxcolumnnumber		&& Returns the max column number for a sheet
		*m: getnextid		&& Gets the next sequential Id value
		*m: getnodeattributevalue		&& Returns the attribute value
		*m: getnodeelement		&& Gets the string content for the node element
		*m: getnodeelementvalue		&& Gets the value assigned to the node element
		*m: getpapersize		&& Gets the paper size for the selected sheet
		*m: getprintorientation		&& Gets the print orientation for the sheet output
		*m: getrgbvalues		&& Gets the specified RGB color value
		*m: getrowheightkeyexpr		&& Gets the key expression for the c_rowheights
		*m: getrowincolrowpair		&& REturns the row (integer value) in a ColRow pair; i.e., return 6 from A6 reference
		*m: getsharedstringid		&& Gets the Shared Strings Id value for the cell text
		*m: getsheetname		&& Gets the sheet name
		*m: getsheetnamexml		&& Gets the sheet file name for the R:Id value in the XML
		*m: getsheetrecord		&& Positions the record in xl_sheets; returns true if record found, or false if not found
		*m: getsheetrowvalues		&& Returns the cell values for the given row
		*m: getsheetscale		&& Gets the sheet printing scale
		*m: getvalidation		&& Returns the validation definition
		*m: getvalidationlist		&& Returns a list of validations for the workbook/sheet
		*m: getworkbook		&& Gets the workbook Id from the name
		*m: getworkbookfilename		&& Gets the file name for the workbook index
		*m: getworkbooksheets		&& Returns the workbook sheets
		*m: getxmlheaderfootertext		&& Returns a XML formatted string for the header and footer text
		*m: getxmlstring		&& Gets the string as an XML formatted string
		*m: iscellformula		&& Returns True if cell contains a formula
		*m: isvalidborderstyle		&& Validates the border style value
		*m: mergecells		&& Merges cells together
		*m: ondestroy		&& Called by the Destroy() event - user implementation
		*m: oninit		&& User code for Init() Event
		*m: opencreatedxlsxfile		&& Opens the XLSX file via Win32 API default program
		*m: openxlsxworkbook		&& Opens the passed Xlsx workbook and loads the internal cursors with the content
		*m: parsestring		&& Parses a string based on a specified delimiter
		*m: readcellvalueformat		&& Reads the cell value and format for a sheet
		*m: readsharedstringsxml		&& Reads the sharedstrings.xml for opening workbooks
		*m: readsheetxml		&& Reads the sheet.xml for opening a workbook
		*m: readstylesxml		&& Reads the styles.xml file for opening a workbook
		*m: removeworkingdirectories		&& Removes the working directories
		*m: renamesheet		&& Renames the selected sheet
		*m: resetcolumnwidth		&& Resets the column width to default
		*m: savegridtoworkbook		&& Saves the selected grid to a workbook
		*m: savetabletoworkbook		&& Saves the table passed (alias) as a workbook sheet
		*m: saveworkbook		&& Saves the selected workbook as an XLSX file
		*m: saveworkbookas		&& Saves the selected workbook with the new name
		*m: setcellalignment		&& Sets the cell horizontal and vertical alignments
		*m: setcellalignmentrange		&& Sets the cell alignment for a range of cells
		*m: setcellborder
		*m: setcellborderex
		*m: setcellborderrange		&& Sets the cell border for a range of cells
		*m: setcellfill		&& Sets the fill color for the cell
		*m: setcellfillrange		&& Sets the fill for a range of cells
		*m: setcellfont		&& Sets the selected cell font format
		*m: setcellfontrange		&& Sets the cell font format for a range of cells
		*m: setcellformula		&& Sets the cell formula expression
		*m: setcellindent		&& Sets the cell indentation value
		*m: setcellinlineformattext		&& Saves the in-line format definition to a cell value
		*m: setcellnumberdecimals		&& Sets the number of decimals to display
		*m: setcellnumberformat		&& Sets the cell number format
		*m: setcellnumberformatrange		&& Sets the number format for a range of cells
		*m: setcelltextrotation		&& Sets the cell text rotation value
		*m: setcellvalidation		&& Adds a cell validation
		*m: setcellvalue		&& Sets the cell value
		*m: setcellwordwrap		&& Sets the cell word-wrapping value
		*m: setcellwordwraprange		&& Sets the word wrap for a range of cells
		*m: setcolumnbestfit		&& Set the column to best fit
		*m: setcolumnwidth		&& Sets the column width
		*m: setcolumnwidthrange		&& Sets the column width for a range of columns
		*m: setcustompapersize		&& Sets the paper size based on custom dimensions
		*m: setdefaultborder		&& Sets the default border style for the workbook
		*m: setdefaultfill		&& Sets the default fill for the workbook
		*m: setdefaultfont		&& Sets the default font for the workbook
		*m: setheaderfootersetup		&& Sets the header and footer setup for the sheet
		*m: setheaderfootertext		&& Sets the header/footer text for the sheet
		*m: setpapersize		&& Sets the paper size for the selected sheet
		*m: setprintfittoheight		&& Number of vertical pages to fit on for printing
		*m: setprintfittowidth		&& Number of horizontal pages to fit on for printing
		*m: setprintorientation		&& Sets the printer orientation for sheet output
		*m: setrowheight		&& Sets the row height
		*m: setrowheightrange		&& Sets the row height for a range of rows
		*m: setsheetmargins		&& Sets the sheet margin values
		*m: setsheetscale		&& Sets the print scale; must be between 10 and 400; i.e. 10=10%, 100=100%, etc.
		*m: setsheetvisibility		&& Sets the sheet visibility
		*m: ttoc3		&& Equlivalent of TTOC() function for pre VFP9 support
		*m: unfreezepanes		&& Removes the pane freeze from the sheet
		*m: unmergedcells		&& Unmerges merged cells
		*m: writesheetxmls		&& Writes the Sheet XML files
		*m: writestylesxml		&& Writes the styles.xml support file
		*m: writesupportxmls		&& Writes the [Content_Types].xml, .rels, core.xml, workbook.xml.rels and app.xml files
		*m: writeworkbookxml		&& Writes the workbook XML
		*p: codepage		&& CodePage to use for the Strings cursor
		*p: companyname		&& Company Name
		*p: creatorname		&& Creator Name
		*p: debug		&& Sets debugging mode ***Boolean
		*p: declarewinapi		&& Flag to execute the DeclareDLL method in the Init() ***Boolean
		*p: defaultfont		&& Workbook Default Font
		*p: defaultsheetname		&& Default sheet name (language specific)
		*p: excelxlsxrelease		&& Release version of Class ***Integer
		*p: subject		&& Subject of Workbook (stored in properties)
		*p: title		&& Title of workbook (stored in properties)
		*p: truefalsevalue		&& The boolean value as displayed in Excel delimited by a pipe symbol
		*p: username		&& User Name
		*a: stringndx[1,0]		&& Returns the next string index value by workbook ***Integer
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED destroy,init
	AutoSize = .T.
	Caption = "clsVFPxWorkbookXLSX"
	codepage = 0		&& CodePage to use for the Strings cursor
	companyname = VFPxWorkbookXLSX		&& Company Name
	creatorname = VFPxWorkbookXLSX		&& Creator Name
	debug = .F.		&& Sets debugging mode ***Boolean
	declarewinapi = .T.		&& Flag to execute the DeclareDLL method in the Init() ***Boolean
	defaultfont = Calibri		&& Workbook Default Font
	defaultsheetname = Sheet		&& Default sheet name (language specific)
	excelxlsxrelease = 17		&& Release version of Class ***Integer
	Height = 17
	Name = "vfpxworkbookxlsx"
	subject = 		&& Subject of Workbook (stored in properties)
	title = 		&& Title of workbook (stored in properties)
	truefalsevalue = Yes|No		&& The boolean value as displayed in Excel delimited by a pipe symbol
	username = VFPxWorkbookXLSX		&& User Name
	Visible = .F.
	Width = 129
	_memberdata = <VFPData>
		<memberdata name="defaultfont" type="property" display="DefaultFont"/>
		<memberdata name="truefalsevalue" type="property" display="TrueFalseValue"/>
		<memberdata name="addclassdefinednumericformats" type="method" display="AddClassDefinedNumericFormats"/>
		<memberdata name="addcustomnumericformat" type="method" display="AddCustomNumericFormat"/>
		<memberdata name="addinlinefontobject" type="method" display="AddInLineFontObject"/>
		<memberdata name="addnamedrange" type="method" display="AddNamedRange"/>
		<memberdata name="cellformatpainter" type="method" display="CellFormatPainter"/>
		<memberdata name="clearcellvalidation" type="method" display="ClearCellValidation"/>
		<memberdata name="convertcolortohex" type="method" display="ConvertColorToHex"/>
		<memberdata name="createinlineformattext" type="method" display="CreateInLineFormatText"/>
		<memberdata name="createworkbookex" type="method" display="CreateWorkbookEx"/>
		<memberdata name="debugcursorstofile" type="method" display="DebugCursorsToFile"/>
		<memberdata name="derivesheetname" type="method" display="DeriveSheetName"/>
		<memberdata name="destroyworkingcursors" type="method" display="DestroyWorkingCursors"/>
		<memberdata name="getbordersrecord" type="method" display="GetBordersRecord"/>
		<memberdata name="getcellindent" type="method" display="GetCellIndent"/>
		<memberdata name="getcellrecord" type="method" display="GetCellRecord"/>
		<memberdata name="getcelltextrotation" type="method" display="GetCellTextRotation"/>
		<memberdata name="getcellvalidation" type="method" display="GetCellValidation"/>
		<memberdata name="getcellxfsid" type="method" display="GetCellXfsId"/>
		<memberdata name="getcellxfsrecord" type="method" display="GetCellXfsRecord"/>
		<memberdata name="getchildnodecount" type="method" display="GetChildNodeCount"/>
		<memberdata name="getchildnodeelement" type="method" display="GetChildNodeElement"/>
		<memberdata name="getcursorrecord" type="method" display="GetCursorRecord"/>
		<memberdata name="getcustomnumericformat" type="method" display="GetCustomNumericFormat"/>
		<memberdata name="getheaderfooterkeyexpr" type="method" display="GetHeaderFooterKeyExpr"/>
		<memberdata name="getinlinefontdefinition" type="method" display="GetInLineFontDefinition"/>
		<memberdata name="getlastcolumninrow" type="method" display="GetLastColumnInRow"/>
		<memberdata name="getnextid" type="method" display="GetNextId"/>
		<memberdata name="getnodeattributevalue" type="method" display="GetNodeAttributeValue"/>
		<memberdata name="getnodeelement" type="method" display="GetNodeElement"/>
		<memberdata name="getnodeelementvalue" type="method" display="GetNodeElementValue"/>
		<memberdata name="getrgbvalues" type="method" display="GetRGBValues"/>
		<memberdata name="getsharedstringid" type="method" display="GetSharedStringId"/>
		<memberdata name="getsheetname" type="method" display="GetSheetName"/>
		<memberdata name="getsheetnamexml" type="method" display="GetSheetNameXML"/>
		<memberdata name="getsheetrecord" type="method" display="GetSheetRecord"/>
		<memberdata name="getvalidation" type="method" display="GetValidation"/>
		<memberdata name="getvalidationlist" type="method" display="GetValidationList"/>
		<memberdata name="getworkbookfilename" type="method" display="GetWorkbookFileName"/>
		<memberdata name="getxmlheaderfootertext" type="method" display="GetXMLHeaderFooterText"/>
		<memberdata name="iscellformula" type="method" display="IsCellFormula"/>
		<memberdata name="opencreatedxlsxfile" type="method" display="OpenCreatedXlsxFile"/>
		<memberdata name="parsestring" type="method" display="ParseString"/>
		<memberdata name="readcellvalueformat" type="method" display="ReadCellValueFormat"/>
		<memberdata name="readsharedstringsxml" type="method" display="ReadSharedStringsXML"/>
		<memberdata name="readsheetxml" type="method" display="ReadSheetXML"/>
		<memberdata name="readstylesxml" type="method" display="ReadStylesXML"/>
		<memberdata name="saveworkbookas" type="method" display="SaveWorkbookAs"/>
		<memberdata name="setcellinlineformattext" type="method" display="SetCellInLineFormatText"/>
		<memberdata name="setcellindent" type="method" display="SetCellIndent"/>
		<memberdata name="setcelltextrotation" type="method" display="SetCellTextRotation"/>
		<memberdata name="setcellvalidation" type="method" display="SetCellValidation"/>
		<memberdata name="setdefaultborder" type="method" display="SetDefaultBorder"/>
		<memberdata name="setdefaultfill" type="method" display="SetDefaultFill"/>
		<memberdata name="setdefaultfont" type="method" display="SetDefaultFont"/>
		<memberdata name="setheaderfootersetup" type="method" display="SetHeaderFooterSetup"/>
		<memberdata name="setheaderfootertext" type="method" display="SetHeaderFooterText"/>
		<memberdata name="setprintfittoheight" type="method" display="SetPrintFitToHeight"/>
		<memberdata name="setprintfittowidth" type="method" display="SetPrintFitToWidth"/>
		<memberdata name="setsheetvisibility" type="method" display="SetSheetVisibility"/>
		<memberdata name="writeworkbookxml" type="method" display="WriteWorkbookXML"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROTECTED PROCEDURE AddClassDefinedNumericFormats		&& Adds pre-defined numeric cell formats
		LPARAMETERS tnWB, tnFormatId
		LOCAL llAdded
		DO CASE
			CASE tnFormatId = CELL_FORMAT_CURRENCY_RED
				INSERT INTO xl_numFmts (workbook, id, posformat, negformat, zeroformat, textformat, code, applydec) ;
					VALUES (tnWB, CELL_FORMAT_CURRENCY_RED, "&quot;$&quot;#,##0.", "[Red]&quot;$&quot;#,##0.", "",  "", '"$"#,##0.00;[Red]"$"#,##0.00', True)
				llAdded = True
		
			CASE tnFormatId = CELL_FORMAT_CURRENCY_POUNDS
				INSERT INTO xl_numFmts (workbook, id, posformat, negformat, zeroformat, textformat, code, applydec) ;
					VALUES (tnWB, CELL_FORMAT_CURRENCY_POUNDS, "_-[$&#163;-809]* #,##0.00_-", "-[$&#163;-809]* #,##0.00_-", "",  "", ;
							'_-[$&#163;-809]* #,##0.00_-;-[$&#163;-809]* #,##0.00_-;_-[$&#163;-809]* &quot;-&quot;??_-;_-@_-', False)
				llAdded = True
		
			CASE tnFormatId = CELL_FORMAT_CURRENCY_EURO
				INSERT INTO xl_numFmts (workbook, id, posformat, negformat, zeroformat, textformat, code, applydec) ;
					VALUES (tnWB, CELL_FORMAT_CURRENCY_EURO, "_-[$&#8364;-2]* .00_-", "-[$&#8364;-2]* .00_-", "",  "", ;
							'"_-[$&#8364;-2]* .00_-;-[$&#8364;-2]* .00_-;_-[$&#8364;-2]* &quot;-&quot;??_-;_-@_-', False)
				llAdded = True
			
			OTHERWISE
				llAdded = False
		ENDCASE
		RETURN llAdded
	ENDPROC

	PROCEDURE AddCustomNumericFormat		&& Adds a new custom defined numeric format
		LPARAMETERS tnWB, tcPosFormat, tcNegFormat, tcZeroFormat, tcTextFormat, tlApplyDec
		LOCAL lnId, lcFormatCode, lnNdx, lcSetPoint, lcSeparator
		IF VARTYPE(tcPosFormat) != "C"
			RETURN 0
		ENDIF
		DO CASE
			CASE PCOUNT() = 1
				tcNegFormat  = ""
				tcZeroFormat = ""
				tcTextFormat = ""
				tlApplyDec   = False
		
			CASE PCOUNT() = 2
				tcZeroFormat = ""
				tcTextFormat = ""
				tlApplyDec   = False
		
			CASE PCOUNT() = 3
				tcTextFormat = ""
				tlApplyDec   = False
		
			CASE PCOUNT() = 4
				tlApplyDec = False
		ENDCASE
		IF VARTYPE(tcNegFormat) != "C"
			tcNegFormat = ""
		ENDIF
		IF VARTYPE(tcZeroFormat) != "C"
			tcZeroFormat = ""
		ENDIF
		IF VARTYPE(tcTextFormat) != "C"
			tcTextFormat = ""
		ENDIF
		IF OCCURS(";", tcPosFormat) > 0
			RETURN 0
		ENDIF
		IF OCCURS(";", tcNegFormat) > 0
			RETURN 0
		ENDIF
		IF OCCURS(";", tcZeroFormat) > 0
			RETURN 0
		ENDIF
		IF OCCURS(";", tcTextFormat) > 0
			RETURN 0
		ENDIF
		*-*	If not US standard for separator and decimal point, then change to US standard
		lcSetPoint  = SET("POINT")
		lcSeparator = SET("SEPARATOR")
		IF lcSetPoint != "." .OR. lcSeparator != ","
			tcPosFormat = CHRTRAN(tcPosFormat, lcSetPoint, TAB)
			tcPosFormat = CHRTRAN(tcPosFormat, lcSeparator, CR)
			tcPosFormat = CHRTRAN(tcPosFormat, TAB, ".")
			tcPosFormat = CHRTRAN(tcPosFormat, CR,  ",")
		
			tcNegFormat = CHRTRAN(tcNegFormat, lcSetPoint, TAB)
			tcNegFormat = CHRTRAN(tcNegFormat, lcSeparator, CR)
			tcNegFormat = CHRTRAN(tcNegFormat, TAB, ".")
			tcNegFormat = CHRTRAN(tcNegFormat, CR,  ",")
		
			tcZeroFormat = CHRTRAN(tcZeroFormat, lcSetPoint, TAB)
			tcZeroFormat = CHRTRAN(tcZeroFormat, lcSeparator, CR)
			tcZeroFormat = CHRTRAN(tcZeroFormat, TAB, ".")
			tcZeroFormat = CHRTRAN(tcZeroFormat, CR,  ",")
		
			tcTextFormat = CHRTRAN(tcTextFormat, lcSetPoint, TAB)
			tcTextFormat = CHRTRAN(tcTextFormat, lcSeparator, CR)
			tcTextFormat = CHRTRAN(tcTextFormat, TAB, ".")
			tcTextFormat = CHRTRAN(tcTextFormat, CR,  ",")
		ENDIF
		*-*	Build expression from parts
		lcFormatCode = tcPosFormat
		IF !EMPTY(tcNegFormat)
			lcFormatCode = lcFormatCode + ";" + tcNegFormat
		ENDIF
		IF !EMPTY(tcZeroFormat)
			lcFormatCode = lcFormatCode + ";" + tcZeroFormat
		ENDIF
		IF !EMPTY(tcTextFormat)
			lcFormatCode = lcFormatCode + ";" + tcTextFormat
		ENDIF
		*-*	Apply decimal size if specified
		IF tlApplyDec
			lnNdx = RATC(".", tcPosFormat)
			IF RIGHT(tcPosFormat, 1) = "0" .AND. lnNdx > 0
				tcPosFormat = LEFT(tcPosFormat, lnNdx)
			ENDIF
			lnNdx = RATC(".", tcNegFormat)
			IF RIGHT(tcNegFormat, 1) = "0" .AND. lnNdx > 0
				tcNegFormat = LEFT(tcNegFormat, lnNdx)
			ENDIF
			lnNdx = RATC(".", tcZeroFormat)
			IF RIGHT(tcZeroFormat, 1) = "0" .AND. lnNdx > 0
				tcZeroFormat = LEFT(tcZeroFormat, lnNdx)
			ENDIF
		ENDIF
		SELECT MAX(fmt.id) AS maxid FROM xl_numfmts AS fmt INTO CURSOR c_temp
		IF _TALLY > 0 .AND. !ISNULL(c_temp.maxid)
			lnId = c_temp.maxid + 1
		ELSE
			lnId = 165
		ENDIF
		INSERT INTO xl_numfmts (workbook, id, posformat, negformat, zeroformat, textformat, code, applydec) ;
			VALUES (tnWB, lnId, this.GetXMLString(tcPosFormat), this.GetXMLString(tcNegFormat), this.GetXMLString(tcZeroFormat), this.GetXMLString(tcTextFormat), lcFormatCode, tlApplyDec)
		USE IN c_temp
		RETURN lnId
	ENDPROC

	PROCEDURE AddInLineFontObject		&& Adds an object for setting the inline formatting of cell text
		LPARAMETERS toInline, tnBeg, tnLen, tcFontName, tnFontSize, tnFontColor, tlFontBold, tlFontItalic, tcULine, tlStrkThru, tlSubscript, tlSuperscript
		LOCAL loCharacter
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		IF VARTYPE(toInline) != "O"
			RETURN .NULL.
		ENDIF
		DO CASE
			CASE PCOUNT() = 4
				tnFontSize    = 10
				tnFontColor   = RGB(0,0,0)
				tlFontBold    = False
				tlFontItalic  = False
				tcULine       = UNDERLINE_NONE
				tlStrkThru    = False
				tlSubscript   = False
				tlSuperscript = False
		
			CASE PCOUNT() = 5
				tnFontColor   = RGB(0,0,0)
				tlFontBold    = False
				tlFontItalic  = False
				tcULine       = UNDERLINE_NONE
				tlStrkThru    = False
				tlSubscript   = False
				tlSuperscript = False
		
			CASE PCOUNT() = 6
				tlFontBold    = False
				tlFontItalic  = False
				tcULine       = UNDERLINE_NONE
				tlStrkThru    = False
				tlSubscript   = False
				tlSuperscript = False
		
			CASE PCOUNT() = 7
				tlFontItalic  = False
				tcULine       = UNDERLINE_NONE
				tlStrkThru    = False
				tlSubscript   = False
				tlSuperscript = False
		
			CASE PCOUNT() = 8
				tcULine       = UNDERLINE_NONE
				tlStrkThru    = False
				tlSubscript   = False
				tlSuperscript = False
		
			CASE PCOUNT() = 9
				tlStrkThru    = False
				tlSubscript   = False
				tlSuperscript = False
		
			CASE PCOUNT() = 10
				tlSubscript   = False
				tlSuperscript = False
		
			CASE PCOUNT() = 11
				tlSuperscript = False
		ENDCASE
		loCharacter = CREATEOBJECT("Empty")
		ADDPROPERTY(loCharacter, "BegPos", tnBeg)
		ADDPROPERTY(loCharacter, "Length", tnLen)
		ADDPROPERTY(loCharacter, "FontName", tcFontName)
		ADDPROPERTY(loCharacter, "FontSize", tnFontSize)
		ADDPROPERTY(loCharacter, "FontBold", tlFontBold)
		ADDPROPERTY(loCharacter, "FontItalic", tlFontItalic)
		ADDPROPERTY(loCharacter, "FontColor", tnFontColor)
		ADDPROPERTY(loCharacter, "Underline", tcULine)
		ADDPROPERTY(loCharacter, "StrikeThru", tlStrkThru)
		ADDPROPERTY(loCharacter, "SubScript", tlSubscript)
		ADDPROPERTY(loCharacter, "SuperScript", tlSuperscript)
		
		toInline.Count = toInline.Count + 1
		DIMENSION toInline.Characters[toInline.Count]
		toInline.Characters[toInline.Count] = loCharacter
		
		RETURN toInline
	ENDPROC

	PROCEDURE AddNamedRange		&& Adds a name range to the workbook
		LPARAMETERS tnWB, tnSheet, tcName, tnScope, tcComment, tnBegRow, tnBegCol, tnEndRow, tnEndCol
		LOCAL lcRangeName
		IF PCOUNT() < 8
			RETURN ""
		ENDIF
		IF VARTYPE(tcName) != "C" .OR. LEN(tcName) > 50
			RETURN ""
		ENDIF
		IF VARTYPE(tnScope) != "N"
			tnScope = 0
		ENDIF
		IF VARTYPE(tcComment) != "C"
			tcComment = ""
		ENDIF
		IF LEN(tcComment) > 254
			RETURN ""
		ENDIF
		IF tnBegRow > tnEndRow .OR. tnBegCol > tnEndCol
			RETURN ""
		ENDIF
		lcRangeName = CHRTRAN(ALLTRIM(tcName), " !@#$%^&*()+={}[]|<>,.'?/" + CHR(34), REPLICATE("_", 25))
		IF !ISALPHA(lcRangeName) .AND. !INLIST(LEFT(lcRangeName, 1), "_", "\")
			lcRangeName = "_" + lcRangeName
		ENDIF
		IF SEEK(BINTOC(tnWB), "xl_workbooks", "workbook") .AND. !SEEK(BINTOC(tnWB)+PADL(lcRangeName, 254, " "), "xl_namerange", "wbrname")
			INSERT INTO xl_namerange (workbook, sheet, rname, scope, comment, begrow, begcol, endrow, endcol) ;
				VALUES (tnWB, tnSheet, lcRangeName, tnScope, tcComment, tnBegRow, tnBegCol, tnEndRow, tnEndCol)
		ELSE
			lcRangeName = ""
		ENDIF
		RETURN lcRangeName
	ENDPROC

	PROCEDURE AddNumericFormat		&& Adds a numeric format expression to be used
		LPARAMETERS tnWB, tcFormatCode
		LOCAL lcPosCode, lcNegCode, lcZerCode
		IF PCOUNT() < 2
			RETURN 0
		ENDIF
		IF VARTYPE(tnWB) != "N" .AND. tnWB > 0
			RETURN 0
		ENDIF
		IF VARTYPE(tcFormatCode) != "C"
			RETURN 0
		ENDIF
		lcPosCode = this.ParseString(tcFormatCode, 1, ";")
		lcNegCode = this.ParseString(tcFormatCode, 2, ";")
		lcZerCode = this.ParseString(tcFormatCode, 3, ";")
		RETURN this.AddCustomNumericFormat(tnWB, lcPosCode, lcNegCode, lcZerCode)
	ENDPROC

	PROCEDURE AddSheet		&& Adds a new sheet to the workbook
		LPARAMETERS tnWB, tcSheetName, tnState
		LOCAL lnSheetIndex
		lnSheetIndex = 0
		IF PCOUNT() > 0 .AND. SEEK(BINTOC(tnWB), "xl_workbooks", "workbook")
			DO CASE
				CASE PCOUNT() = 0
				
				CASE PCOUNT() = 1
					tcSheetName = "Sheet" + TRANSFORM(xl_workbooks.sheetcnt) + 1
					tnState = VISIBLE_SHEET_STATE
				
				CASE PCOUNT() = 2
					IF VARTYPE(tcSheetName) != "C"
						tcSheetName = "Sheet" + TRANSFORM(xl_workbooks.sheetcnt) + 1
					ENDIF
					tnState = VISIBLE_SHEET_STATE
		
				OTHERWISE
					IF VARTYPE(tcSheetName) != "C"
						tcSheetName = "Sheet" + TRANSFORM(xl_workbooks.sheetcnt) + 1
					ENDIF
					IF VARTYPE(tnState) != "N"
						tnState = VISIBLE_SHEET_STATE
					ENDIF
			ENDCASE
			IF EMPTY(tcSheetName)
				tcSheetName = "Sheet" + TRANSFORM(xl_workbooks.sheetcnt) + 1
			ENDIF
			tcSheetName = CHRTRAN(tcSheetName, ":\/?*", "_____")
			IF !SEEK(BINTOC(tnWB)+UPPER(PADR(tcSheetName, LEN(xl_sheets.shname))), "xl_sheets", "shname")    && Change recommendation by Doug Hennig
				REPLACE xl_workbooks.sheetcnt WITH xl_workbooks.sheetcnt + 1 IN xl_workbooks
				lnSheetIndex = xl_workbooks.sheetcnt
				INSERT INTO xl_sheets (workbook, sheet, shname, state, mleft, mright, mtop, mbot, mheader, mfooter, shdeleted, xsplit, ysplit, prnorient, ;
									  papersize, paperwidth, paperheight, scale, fittowidth, fittoheight) ;
					VALUES (tnWB, lnSheetIndex, tcSheetName, tnState, 0.75, 0.75, 0.75, 0.75, 0.3, 0.3, False, 0, 0, PORTRAIT_PRINT_ORIENTATION, 0, 0, 0, 100, 0, 0)
			ENDIF
		ENDIF
		RETURN lnSheetIndex
	ENDPROC

	PROTECTED PROCEDURE AddStringValue		&& Adds a string value to the internal cursor
		LPARAMETERS tnWB, tcString, tlInLine
		LOCAL lcStringValue, lnStringId, llPreserveSpace
		IF tlInLine
			llPreserveSpace = IIF(LEFT(tcString, 1) = " ", True, False)
			lcStringValue   = this.GetXMLString(tcString)
			lnStringId      = this.GetNextId(tnWB, "xl_strings")
			INSERT INTO xl_strings (id, workbook, stringvalue, string, presvspace, formatted) VALUES (lnStringId, tnWB, lcStringValue, tcString, llPreserveSpace, True)
		ELSE
			IF SEEK(BINTOC(tnWB)+PADR(UPPER(LEFT(tcString, 180)), 180, " "), "xl_strings", "stringndx") .AND. xl_strings.formatted = False
				lnStringId = xl_strings.id
			ELSE
				llPreserveSpace = IIF(LEFT(tcString, 1) = " ", True, False)
				lcStringValue   = this.GetXMLString(tcString)
				lnStringId      = this.GetNextId(tnWB, "xl_strings")
				INSERT INTO xl_strings (id, workbook, stringvalue, string, presvspace, formatted) VALUES (lnStringId, tnWB, lcStringValue, tcString, llPreserveSpace, False)
			ENDIF
		ENDIF
		RETURN lnStringId
	ENDPROC

	PROCEDURE CellFormatPainter		&& Copies the formatting of a source cell to other cells
		LPARAMETERS tnWB, tnSheet, tnSrcRow, tnSrcCol, tnBegRow, tnBegCol, tnEndRow, tnEndCol
		LOCAL lnCellXfs, lnNumDec, llReturn, lnRow, lnCol
		DO CASE
			CASE PCOUNT() < 6
				RETURN False
		
			CASE PCOUNT() = 6
				tnEndRow = tnBegRow
				tnEndCol = tnBegCol
			
			CASE PCOUNT() = 7
				tnEndCol = tnBegCol
		ENDCASE
		IF this.GetCellRecord(tnWB, tnSheet, tnSrcRow, tnSrcCol)
			lnCellXfs = xl_cells.cellxfs
			lnNumDec  = xl_cells.numdec
			FOR lnRow=tnBegRow TO tnEndRow
				FOR lnCol=tnBegCol TO tnEndCol
					IF this.GetCellRecord(tnWB, tnSheet, lnRow, lnCol)
						REPLACE xl_cells.cellxfs WITH lnCellXfs, ;
								xl_cells.numdec  WITH lnNumDec IN xl_cells
					ELSE
						INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
							VALUES (tnWB, tnSheet, lnRow, lnCol, DATA_TYPE_NONE, lnCellXfs, False, lnNumDec, 0)
					ENDIF
				ENDFOR
			ENDFOR
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE ClearCellValidation		&& Clears/deletes the named range from the workbook
		LPARAMETERS tnWB, tcName
		IF PCOUNT() < 2
			RETURN False
		ENDIF
		IF VARTYPE(tcName) != "C"
			RETURN False
		ENDIF
		IF SEEK(BINTOC(tnWB)+PADL(tcName, 254, " "), "xl_namerange", "wbrname")
			DELETE IN xl_namerange
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE ClearCellValue		&& Clears the cell value
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL llReturn
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			REPLACE xl_cells.celldeleted WITH True IN xl_cells
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE ColumnAsciiToIndex		&& Converts Excel Ascii column value to index value
		LPARAMETERS tcColIndex
		LOCAL lnLen, lnIndex, lnNdx, lnChr
		lnLen = LEN(tcColIndex)
		lnIndex = 0
		FOR lnNdx=1 TO lnLen
			lnChr = ASC(UPPER(SUBSTR(tcColIndex, lnNdx, 1)))
			IF BETWEEN(lnChr, 65, 90)
				lnIndex = (lnChr - 64) + (lnIndex * 26)
			ELSE
				EXIT
			ENDIF
		ENDFOR
		RETURN lnIndex
	ENDPROC

	PROCEDURE ColumnIndexToAscii		&& Gets the column ASCII code for the column index
		LPARAMETERS tnCol
		LOCAL lcCol
		lcCol = IIF(tnCol > 26, CHR(64 + FLOOR((tnCol - 1) / 26)), '') + CHR(65 + MOD(tnCol - 1, 26))
		RETURN lcCol
	ENDPROC

	PROTECTED PROCEDURE ConvertColorToHex		&& Converts a color value (integer) to Hex representation
		LPARAMETERS tnColor
		LOCAL lnRed, lnGreen, lnBlue, lcHexRed, lcHexGreen, lcHexBlue
		lnRed   = this.GetRGBValues(tnColor, 'R')
		lnGreen = this.GetRGBValues(tnColor, 'G')
		lnBlue  = this.GetRGBValues(tnColor, 'B')
		lcHexRed   = RIGHT(TRANSFORM(lnRed, '@0'), 2)
		lcHexGreen = RIGHT(TRANSFORM(lnGreen, '@0'), 2)
		lcHexBlue  = RIGHT(TRANSFORM(lnBlue, '@0'), 2)
		RETURN "FF" + UPPER(lcHexRed + lcHexGreen + lcHexBlue)
	ENDPROC

	PROTECTED PROCEDURE ConvertHexStringToNumeric		&& ConvertHexStringToNumeric
		LPARAMETERS tcHexNum
		LOCAL lcValue
		IF EMPTY(tcHexNum)
			RETURN 0
		ENDIF
		IF LEN(tcHexNum) > 6
			tcHexNum = SUBSTR(tcHexNum, 3)
		ENDIF
		tcHexNum = UPPER(ALLTRIM(tcHexNum))
		tcHexNum = RIGHT(tcHexNum, 2) + SUBSTR(tcHexNum, 3, 2) + LEFT(tcHexNum, 2)
		lcValue  = "0x" + tcHexNum
		RETURN EVAL(lcValue)
	ENDPROC

	PROCEDURE ConvertPixelsToExcelUnits		&& Converts Pixel measurement to Excel measurement
		LPARAMETERS tnPixels
		RETURN tnPixels * 0.152542
	ENDPROC

	PROTECTED PROCEDURE CreateExcelFile		&& Creates the Excel file from the components
		LPARAMETERS tnWB, tcTempPath
		LOCAL loShell, loFolder, lcZipFile, loException, loFile, lnCountBefore, lcFile, lcZipPath, lnCount, lhFile
		IF SEEK(BINTOC(tnWB), "xl_workbooks", "workbook")
			lcZipPath = ALLTRIM(xl_workbooks.filepath)
			IF EMPTY(lcZipPath)
				lcZipPath = SYS(5) + SYS(2003)
			ENDIF
			lcZipFile = ADDBS(lcZipPath) + FORCEEXT(ALLTRIM(xl_workbooks.wbname), "zip")
		*-*	Delete any prior file with same Excel name
			IF FILE(FORCEEXT(lcZipFile, "xlsx"))
				TRY
					ERASE (FORCEEXT(lcZipFile, "xlsx"))
					llError = False
				CATCH TO loException
					MESSAGEBOX("Error - unable to delete existing file" + CR + loException.Message)
					llError = True
				ENDTRY
				IF llError
					RETURN False
				ENDIF
			ENDIF
		*-*	Validate that the file name and path are valid
			TRY
				lhFile = FCREATE(lcZipFile, 0)
				FCLOSE(lhFile)
		
			CATCH TO loException
				MESSAGEBOX("CreateExcelFile - Failed to create Zip file"+ CR + loException.Message)
				RETURN
			ENDTRY
		
		*-*	Create base zip file
			STRTOFILE(CHR(80)+CHR(75)+CHR(5)+CHR(6)+REPLICATE(CHR(0), 18), lcZipFile, 0)
			loShell  = CREATEOBJECT("shell.application")
			loFolder = loShell.NameSpace(tcTempPath).Items
		
		*-*	Add the files to the zip
			IF OS(3)<'6' .OR. OS(3)='6' .AND. OS(4)<'1'
				TRY
					FOR EACH loFile IN loFolder
						loShell.NameSpace(lcZipFile).MoveHere(loFile, FOF_SILENT)
						apiSleep(100)
					ENDFOR
		
				CATCH TO loException
					SET STEP ON
				ENDTRY
			
				llErr = True
				DO WHILE llErr
					TRY
						apiMoveFile(lcZipFile, FORCEEXT(lcZipFile, "xlsx"))
						llErr = False
					CATCH
						apiSleep(100)
					ENDTRY
				ENDDO
			ELSE
				TRY
					FOR EACH loFile IN loFolder
						lnCountBefore = loShell.NameSpace(tcTempPath).Items.Count
						loShell.NameSpace(lcZipFile).MoveHere(loFile, FOF_SILENT)
						DO WHILE lnCountBefore = loShell.NameSpace(tcTempPath).Items.Count
							apiSleep(50)
						ENDDO
					ENDFOR
		
				CATCH TO loException
					MESSAGEBOX("CreateExcelFile - Failed to add contents to Zip file"+ CR + loException.Message)
					SET STEP ON
					ERASE (lcZipFile)
					DO CASE
						CASE loException.ErrorNo = 1943
						
						OTHERWISE
							SET STEP ON
					ENDCASE
				ENDTRY
				TRY
					apiMoveFile(lcZipFile, FORCEEXT(lcZipFile, "xlsx"))
				CATCH TO loException
					MESSAGEBOX("CreateExcelFile - Rename failed"+ CR + loException.Message)
					SET STEP ON
				ENDTRY
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE CreateInLineFormatText		&& Creates an in-line text formatted definition
		LPARAMETERS tnWB, tcCellText
		LOCAL loInline
		loInline = CREATEOBJECT("Empty")
		ADDPROPERTY(loInline, "Workbook", tnWB)
		ADDPROPERTY(loInline, "StringId", .NULL.)
		ADDPROPERTY(loInline, "StringValue", tcCellText)
		ADDPROPERTY(loInline, "Count", 0)
		ADDPROPERTY(loInline, "Characters[1]")
		loInline.Characters[1] = .NULL.
		RETURN loInline
	ENDPROC

	PROCEDURE CreateWorkbook		&& Creates a new workbook object
		LPARAMETERS tcName
		LOCAL lcWBName, lcPath, lnWB
		IF PCOUNT() = 1
			tlLoadDefaults = True
		ENDIF
		lcWBName = JUSTSTEM(tcName)
		lcPath   = JUSTPATH(tcName)
		IF EMPTY(lcPath)
			lcPath = SYS(5) + SYS(2003)
		ENDIF
		IF SEEK(PADL(UPPER(lcWBName), 200, " "), "xl_workbooks", "wbname")
			lnWB = 0
		ELSE
			INSERT INTO xl_workbooks (wbname, filepath, sheetcnt) VALUES (lcWBName, lcPath, 0)
			lnWB = xl_workbooks.workbook
			this.SetDefaultFont(lnWB, this.DefaultFont, 11)
			this.SetDefaultBorder(lnWB, BORDER_STYLE_NONE)
			INSERT INTO xl_cellxfs (workbook, id, numFmtId, fontId, fillId, borderId, halign, valign, indent, wraptext) ;
				VALUES (lnWB, 0, 0, 0, 0, 0, "", "", 0, 0)
			INSERT INTO xl_fills (workbook, id, fgcolor, bgcolor, patttype, theme, tint, fgindexed, bgindexed) ;
				VALUES (lnWB, 0, 0, 0, FILL_STYLE_NONE, 0, 0, 0, 0)
			INSERT INTO xl_fills (workbook, id, fgcolor, bgcolor, patttype, theme, tint, fgindexed, bgindexed) ;
				VALUES (lnWB, 1, 0, 0, FILL_STYLE_GRAY125, 0, 0, 0, 0)
		ENDIF
		RETURN lnWB
	ENDPROC

	PROTECTED PROCEDURE CreateWorkbookEx		&& Internal method for creating a workbook
		LPARAMETERS tcName
		LOCAL lcWBName, lcPath, lnWB
		lcWBName = JUSTSTEM(tcName)
		lcPath   = JUSTPATH(tcName)
		IF EMPTY(lcPath)
			lcPath = SYS(5) + SYS(2003)
		ENDIF
		IF SEEK(PADL(UPPER(lcWBName), 200, " "), "xl_workbooks", "wbname")
			lnWB = 0
		ELSE
			INSERT INTO xl_workbooks (wbname, filepath, sheetcnt) VALUES (lcWBName, lcPath, 0)
			lnWB = xl_workbooks.workbook
		ENDIF
		RETURN lnWB
	ENDPROC

	PROTECTED PROCEDURE CreateWorkingCursors		&& Creates the working cursors for worksheet definitions
		IF USED('xl_strings')
			RETURN
		ENDIF
		DO CASE
			CASE this.CodePage = 620            && Mazovia (Polish) MS-DOS
				CREATE CURSOR xl_strings CODEPAGE = 620 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 737            && Greek MS-DOS
				CREATE CURSOR xl_strings CODEPAGE = 737 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 852            && Eastern European MS-DOS
				CREATE CURSOR xl_strings CODEPAGE = 852 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 857            && Turkish MS-DOS
				CREATE CURSOR xl_strings CODEPAGE = 857 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 861            && Icelandic MS-DOS
				CREATE CURSOR xl_strings CODEPAGE = 861 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 865            && Nordic MS-DOS
				CREATE CURSOR xl_strings CODEPAGE = 865 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 866            && Russian MS-DOS
				CREATE CURSOR xl_strings CODEPAGE = 866 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 874            && Thai Windows
				CREATE CURSOR xl_strings CODEPAGE = 874 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 895            && Kamenicky (Czech) MS-DOS
				CREATE CURSOR xl_strings CODEPAGE = 895 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 932            && Japanese Windows
				CREATE CURSOR xl_strings CODEPAGE = 932 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 936            && Chinese Simplified (PRC, Singapore) Windows
				CREATE CURSOR xl_strings CODEPAGE = 936 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 949            &&Korean Windows
				CREATE CURSOR xl_strings CODEPAGE = 949 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 950            && Traditional Chinese (Hong Kong SAR, Taiwan) Windows
				CREATE CURSOR xl_strings CODEPAGE = 950 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 1250           && Eastern European Windows
				CREATE CURSOR xl_strings CODEPAGE = 1250 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 1251           && Russian Windows
				CREATE CURSOR xl_strings CODEPAGE = 1251 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 1252           && Windows ANSI
				CREATE CURSOR xl_strings CODEPAGE = 1252 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 1253           && Greek Windows
				CREATE CURSOR xl_strings CODEPAGE = 1253 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 1254           && Turkish Windows
				CREATE CURSOR xl_strings CODEPAGE = 1254 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 1255           && Hebrew Windows
				CREATE CURSOR xl_strings CODEPAGE = 1255 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			CASE this.CodePage = 1256           && Arabic Windows
				CREATE CURSOR xl_strings CODEPAGE = 1256 (id I, workbook I, stringvalue M, string M, presvspace L, formatted L)
		
			OTHERWISE
				CREATE CURSOR xl_strings (id I, workbook I, stringvalue M, STRING M, presvspace L, formatted L)
		ENDCASE
		INDEX ON BINTOC(workbook)+BINTOC(id) TAG id FOR !DELETED()
		INDEX ON BINTOC(workbook)+PADL(id, 10, '0') TAG sortorder FOR !DELETED()
		INDEX ON BINTOC(workbook)+PADR(LEFT(UPPER(ALLTRIM(string)), 180), 180, " ") TAG stringndx
		INDEX ON workbook TAG workbook
		
		CREATE CURSOR xl_strformat (workbook I, id I, index I, stringvalue M, string M, fbold L, fitalic L, fcolor I, fname C(100), fsize N(5,1), uline C(16), strkthr L, ;
									fvpos C(11), theme I, tint F(20,15), indexed I)
		INDEX ON BINTOC(workbook)+BINTOC(id)+PADL(index, 10, '0') TAG sortorder FOR !DELETED()
		INDEX ON BINTOC(workbook)+BINTOC(id)+BINTOC(index) TAG id FOR !DELETED()
		
		CREATE CURSOR xl_workbooks (workbook I AUTOINC NEXTVALUE 1, wbname C(200), filepath C(200), sheetcnt I)
		INDEX ON BINTOC(workbook) TAG workbook
		INDEX ON UPPER(ALLTRIM(wbname)) TAG wbname
		
		CREATE CURSOR xl_sheets (workbook I, sheet I, shname C(30), state I, mleft N(6,3), mright N(6,3), mtop N(6,3), mbot N(6,3), mheader N(6,3), ;
								mfooter N(6,3), shdeleted L, xsplit I, ysplit I, prnorient I, papersize I, paperwidth I, paperheight I, ;
								paperdimen C(2), scale I, fittowidth I, fittoheight I)
		INDEX ON sheet TAG sheet
		INDEX ON workbook TAG workbook
		INDEX ON BINTOC(workbook)+UPPER(ALLTRIM(shname)) TAG shname
		INDEX ON BINTOC(workbook)+BINTOC(sheet) TAG sheetndx FOR !DELETED()
		
		CREATE CURSOR xl_cells (workbook I, sheet I, cellrow I, cellcol I, cellvalue C(25), datatype C(1), cellformula M, stringid I, cellxfs I, numdec I, celldeleted L, validndx I)
		INDEX ON sheet TAG sheet
		INDEX ON cellrow TAG cellrow
		INDEX ON cellcol TAG cellcol
		INDEX ON workbook TAG workbook
		INDEX ON BINTOC(workbook)+BINTOC(sheet)+BINTOC(cellrow)+BINTOC(cellcol) TAG cellindex CANDIDATE
		
		CREATE CURSOR xl_cellxfs (workbook I, id I, numFmtId I, fontId I, fillId I, borderId I, halign C(8), valign C(8), indent I, wraptext I, rotation I)
		INDEX ON BINTOC(workbook)+BINTOC(id) TAG id FOR !DELETED()
		INDEX ON BINTOC(workbook)+PADL(id, 10, '0') TAG sortorder FOR !DELETED()
		INDEX ON BINTOC(workbook)+BINTOC(numFmtId)+BINTOC(fontId)+BINTOC(fillId)+BINTOC(borderId)+BINTOC(indent)+BINTOC(wraptext)+BINTOC(rotation)+ALLTRIM(halign)+ALLTRIM(valign) TAG cellxfs FOR !DELETED()
		
		CREATE CURSOR xl_fonts (workbook I, id I, fname C(100), fsize N(5,1), fbold L, fitalic L, fcolor I, uline C(16), strkthr L, ;
							   fvpos C(11), theme I, tint F(20,15), indexed I)
		INDEX ON BINTOC(workbook)+fname + STR(fsize, 5, 1) + TRANSFORM(fbold) + TRANSFORM(fitalic) + PADL(fcolor, 15) + uline + TRANSFORM(strkthr) + fvpos TAG cellformat
		INDEX ON BINTOC(workbook)+PADL(id, 10, '0') TAG sortorder FOR !DELETED()
		INDEX ON BINTOC(workbook)+BINTOC(id) TAG id FOR !DELETED()
		
		CREATE CURSOR xl_fills (workbook I, id I, fgcolor I, bgcolor I, patttype C(25), theme I, tint F(20,15), fgindexed I, bgindexed I)
		INDEX ON BINTOC(workbook)+BINTOC(fgcolor)+BINTOC(bgcolor)+patttype TAG fillcolor
		INDEX ON BINTOC(workbook)+PADL(id, 10, '0') TAG sortorder FOR !DELETED()
		INDEX ON BINTOC(workbook)+BINTOC(id) TAG id FOR !DELETED()
		
		CREATE CURSOR xl_borders (workbook I, id I, lstyle C(20), lcolor I, ltheme I, ltint I, lindexed I, rstyle C(20), rcolor I, rtheme I, rtint I, rindexed I, ;
								 tstyle C(20), tcolor I, ttheme I, ttint I, tindexed I, bstyle C(20), bcolor I, btheme I, btint I, bindexed I, ;
								 dstyle C(20), dcolor I, dtheme I, dtint I, dindexed I, diagdn I, diagup I, theme I, tint F(20,15))
		INDEX ON BINTOC(workbook) + ALLTRIM(lstyle) + BINTOC(lcolor) + ALLTRIM(rstyle) + BINTOC(rcolor) + ALLTRIM(tstyle) + BINTOC(tcolor) + ALLTRIM(bstyle) + BINTOC(bcolor) + ;
				 ALLTRIM(dstyle) + BINTOC(dcolor) + BINTOC(diagdn) + BINTOC(diagup) TAG cellborder
		INDEX ON BINTOC(workbook)+PADL(id, 10, '0') TAG sortorder FOR !DELETED()
		INDEX ON BINTOC(workbook)+BINTOC(id) TAG id FOR !DELETED()
		
		CREATE CURSOR xl_mergecells (workbook I, sheet I, begrow I, begcol I, endrow I, endcol I)
		INDEX ON workbook TAG workbook
		INDEX ON sheet TAG sheet
		INDEX ON BINTOC(workbook)+BINTOC(sheet)+BINTOC(begrow)+BINTOC(begcol) TAG mergecell FOR !DELETED()
		
		CREATE CURSOR xl_colwidths (workbook I, sheet I, column I, width N(16,9), bestfit L)
		INDEX ON sheet TAG sheet
		INDEX ON column TAG column
		INDEX ON workbook TAG workbook
		INDEX ON BINTOC(workbook)+BINTOC(sheet)+BINTOC(column) TAG shcolumn FOR !DELETED()
		
		CREATE CURSOR xl_hdrfooterdefn (workbook I, sheet I, alignmargin L, difffirstpg L, diffoddeven L, scalewdoc L)
		INDEX ON workbook TAG workbook
		INDEX ON sheet TAG sheet
		INDEX ON BINTOC(workbook)+BINTOC(sheet) TAG wbsheet FOR !DELETED()
		
		CREATE CURSOR xl_hdrfootertext (workbook I, sheet I, page I, section I, text C(200), fontname C(50), fontsize I, fontstyle I, fontcolor I)
		INDEX ON workbook TAG workbook
		INDEX ON sheet TAG sheet
		INDEX ON BINTOC(workbook)+BINTOC(sheet)+BINTOC(page)+BINTOC(section) TAG hdrfootr FOR !DELETED()
		
		CREATE CURSOR xl_rowheights (workbook I, sheet I, row I, height N(14,7))
		INDEX ON workbook TAG workbook
		INDEX ON sheet TAG sheet
		INDEX ON row TAG row
		INDEX ON BINTOC(workbook)+BINTOC(sheet)+BINTOC(row) TAG shrow FOR !DELETED()
		
		CREATE CURSOR xl_validation (workbook I, sheet I, validndx I AUTOINC NEXTVALUE 1, vtype I, vstyle I, voperator I, errmsg C(100), errtitle C(100), ;
									 allowblank L, showinpmsg L, showerrmsg L, vprompt C(100), formula L, formula1 C(254), formula2 C(254))
		INDEX ON BINTOC(validndx) TAG validndx FOR !DELETED()
		INDEX ON BINTOC(workbook)+BINTOC(sheet) TAG wbshindex FOR !DELETED()
		INDEX ON BINTOC(workbook)+BINTOC(sheet)+BINTOC(validndx) TAG validindex FOR !DELETED()
		INDEX ON LEFT(formula1, 240) TAG formula1 FOR !DELETED()
		INDEX ON LEFT(formula2, 240) TAG formula2 FOR !DELETED()
		
		CREATE CURSOR xl_namerange (workbook I, rname C(50), scope I, comment C(254), sheet I, begrow I, begcol I, endrow I, endcol I)
		INDEX ON BINTOC(workbook)+rname TAG wbrname FOR !DELETED()
		
		CREATE CURSOR xl_numfmts (workbook I, id I, tempid I, posformat C(200), negformat C(200), zeroformat C(200), textformat C(200), code C(200), applydec L)
		INDEX ON BINTOC(workbook)+PADL(id, 10, '0') TAG sortorder FOR !DELETED()
		INDEX ON BINTOC(workbook)+BINTOC(id) TAG id FOR !DELETED()		
	ENDPROC

	PROTECTED PROCEDURE CreateWorkingDirectories		&& Creates the working directories for the XML files
		LOCAL lcDir, loException
		lcDir = ADDBS(SYS(2023)) + SYS(2015)
		TRY
			MKDIR (lcDir)
			MKDIR (lcDir + "\_rels")
			MKDIR (lcDir + "\docProps")
			MKDIR (lcDir + "\xl")
			MKDIR (lcDir + "\xl\_rels")
			MKDIR (lcDir + "\xl\worksheets")
		
		CATCH TO loException
			lcDir = .NULL.
		ENDTRY
		RETURN ADDBS(lcDir)
	ENDPROC

	PROCEDURE DebugCursorsToFile		&& Debugging use for saving the internal cursors to a text file
		LPARAMETERS tcStemName
		LOCAL lnNumFlds, lcField, lcLineText, lnFld, lcFileName
		LOCAL ARRAY laFields[1, 18]
		SELECT xl_workbooks
		SET ORDER TO TAG workbook
		lnNumFlds = AFIELDS(laFields, "xl_workbooks")
		lcFileText = "Cursor: xl_workbooks" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_workbooks.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_workbooks.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_sheets
		SET ORDER TO TAG sheetndx
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_sheets")
		lcFileText = lcFileText + "Cursor: xl_sheets" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_sheets.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_sheets.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_cells
		SET ORDER TO TAG cellindex
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_cells")
		lcFileText = lcFileText + "Cursor: xl_cells" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_cells.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_cells.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_strings
		SET ORDER TO TAG stringid
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_strings")
		lcFileText = lcFileText + "Cursor: xl_strings" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_strings.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_strings.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_mergecells
		SET ORDER TO TAG mergecell
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_mergecells")
		lcFileText = lcFileText + "Cursor: xl_mergecells" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_mergecells.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_mergecells.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_colwidths
		SET ORDER TO TAG shcolumn
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_colwidths")
		lcFileText = lcFileText + "Cursor: xl_colwidths" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_colwidths.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_colwidths.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_fonts
		SET ORDER TO TAG id
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_fonts")
		lcFileText = lcFileText + "Cursor: xl_fonts" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_fonts.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_fonts.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_fills
		SET ORDER TO TAG id
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_fills")
		lcFileText = lcFileText + "Cursor: xl_fills" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_fills.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_fills.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_numfmts
		SET ORDER TO TAG id
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_numfmts")
		lcFileText = lcFileText + "Cursor: xl_numfmts" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_numfmts.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_numfmts.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_borders
		SET ORDER TO TAG id
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_borders")
		lcFileText = lcFileText + "Cursor: xl_borders" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_borders.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_borders.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_rowheights
		SET ORDER TO TAG shrow
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_rowheights")
		lcFileText = lcFileText + "Cursor: xl_rowheights" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_rowheights.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_rowheights.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_hdrfooterdefn
		SET ORDER TO TAG wbsheet
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_hdrfooterdefn")
		lcFileText = lcFileText + "Cursor: xl_hdrfooterdefn" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_hdrfooterdefn.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_hdrfooterdefn.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		SELECT xl_hdrfootertext
		SET ORDER TO TAG hdrfootr
		lcFileName = tcStemName + " " + ALIAS() + ".txt"
		LIST TO FILE (lcFileName) NOCONSOLE
		lnNumFlds = AFIELDS(laFields, "xl_hdrfootertext")
		lcFileText = lcFileText + "Cursor: xl_hdrfootertext" + CRLF
		SCAN
			lcField = LOWER(laFields[1, 1])
			lcLineText = lcField + ": " + TRANSFORM(xl_hdrfootertext.&lcField)
			FOR lnFld=2 TO lnNumFlds
				lcField = LOWER(laFields[lnFld, 1])
				lcLineText = lcLineText + ";  " + lcField + ": " + TRANSFORM(xl_hdrfootertext.&lcField)
			ENDFOR
			lcFileText = lcFileText + lcLineText + CRLF
		ENDSCAN
		lcFileText = lcFileText + CRLF + CRLF + CRLF
		SET ORDER TO
		
		lcFileName = tcStemName + " Cursors.txt"
		STRTOFILE(lcFileText, lcFileName)
	ENDPROC

	PROCEDURE DebugOutput		&& Limited functions for debugging
		LOCAL lnWb, lnSh
		lnWb = this.CreateWorkbook("ExcelDebug.xlsx")
		
		lnSh = this.AddSheet(lnWb, "Debug Output")
		
		this.SetCellValue(lnWb, lnSh, 1, 1, "Test string 1")
		this.SetCellValue(lnWb, lnSh, 2, 1, "Test string 2")
		this.SetCellValue(lnWb, lnSh, 3, 1, "Test string 3")
		this.SetCellValue(lnWb, lnSh, 4, 1, "Test string 4")
		this.SetCellValue(lnWb, lnSh, 5, 1, "Test string 5")
		
		this.SetCellValue(lnWb, lnSh, 8, 1, "This is a long Test string for word-wrapping to occur This is a long Test string for word-wrapping to occur")
		this.SetCellWordWrap(lnWb, lnSh, 8, 1, True)
		this.SetRowHeight(lnWb, lnSh, 8, 75)
		this.SetColumnWidth(lnWb, lnSh, 1, 25)
		
		this.SetCellValue(lnWb, lnSh, 10, 1, DATE(2015, 5, 6))
		this.SetCellValue(lnWb, lnSh, 11, 1, DATETIME(2015, 5, 6, 6, 30, 30))
		
		this.SetCellFont(lnWb, lnSh, 1, 1, "Arial",                14,   True,         , RGB(0,0,255))
		this.SetCellFont(lnWb, lnSh, 2, 1, "Times New Roman",        ,       ,         , RGB(0,0,255))
		this.SetCellFont(lnWb, lnSh, 3, 1, "Consolas"       ,      14,   True)
		this.SetCellFont(lnWb, lnSh, 4, 1, "Arial",                24,   True,     True, RGB(0,0,255))
		this.SetCellFont(lnWb, lnSh, 5, 1, "Cooper Black"   ,      12,       ,         ,             )
		
		this.SetCellBorder(lnWb, lnSh, 2, 1, BORDER_TOP+BORDER_BOTTOM, BORDER_STYLE_THICK,  RGB(100,150,200))
		this.SetCellBorder(lnWb, lnSh, 5, 1, BORDER_LEFT+BORDER_RIGHT, BORDER_STYLE_DOUBLE, RGB(255,0,0))
		
		this.SetCellFill(lnWb, lnSh, 1, 1, RGB(255,204,153))
		this.SetCellFill(lnWb, lnSh, 3, 1, RGB(204,255,255))
		
		this.SaveWorkbook(lnWb)
	ENDPROC

	PROCEDURE Debug_Assign
		LPARAMETERS tlDebug
		IF tlDebug
			SET DEBUGOUT TO "VFPXWorkbookXLSXDebug.txt"
		ENDIF
		this.Debug = tlDebug
	ENDPROC

	PROTECTED PROCEDURE DeclareDLL		&& Declares the required support Win32 API
		DECLARE Sleep IN kernel32 AS apiSleep INTEGER tnTime
		DECLARE LONG MoveFile IN Win32API AS apiMoveFile STRING SourceFileName, STRING DestFileName
		DECLARE INTEGER ShellExecute IN Shell32 AS apiShellExecute LONG nhWnd, STRING lpAction, STRING lpFile, STRING lpParams, STRING lpDirectory, INTEGER nShowCmd
	ENDPROC

	PROCEDURE DeleteAllWorkbooks		&& Deletes all workbooks
		LOCAL loException
		TRY
			this.DestroyWorkingCursors()
			this.CreateWorkingCursors()
		
		CATCH TO loException
			SET STEP ON
		ENDTRY
	ENDPROC

	PROCEDURE DeleteSheet		&& Deletes the sheet from the Workbook
		LPARAMETERS tnWB, txSheet
		LOCAL lnSheet, lxReturn
		lxReturn = False
		DO CASE
			CASE VARTYPE(txSheet) = "C"
				IF SEEK(BINTOC(tnWB)+UPPER(txSheet), "xl_sheets", "shname")
					lnSheet = xl_sheets.sheet
					REPLACE xl_sheets.shdeleted WITH True IN xl_sheets
					DELETE IN xl_sheets
					lxReturn = True
				ENDIF
		
			CASE VARTYPE(txSheet) = "N"
				IF SEEK(BINTOC(tnWB)+BINTOC(txSheet), "xl_sheets", "sheetndx")
					lnSheet = txSheet
					REPLACE xl_sheets.shdeleted WITH True IN xl_sheets
					DELETE IN xl_sheets
					lxReturn = True
				ENDIF
		ENDCASE
		IF lxReturn
			REPLACE xl_cells.celldeleted WITH True FOR workbook = tnWB .AND. sheet = lnSheet IN xl_cells
			DELETE FOR workbook = tnWB .AND. sheet = lnSheet IN xl_cells
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROCEDURE DeleteWorkbook		&& Deletes the selected workbook
		LPARAMETERS tnWB
		LOCAL llSuccess
		TRY
			REPLACE xl_sheets.shdeleted  WITH True FOR workbook = tnWB IN xl_sheets
			REPLACE xl_cells.celldeleted WITH True FOR workbook = tnWB IN xl_cells
			DELETE FOR workbook = tnWB IN xl_workbooks
			DELETE FOR workbook = tnWB IN xl_sheets
			DELETE FOR workbook = tnWB IN xl_cells
			DELETE FOR workbook = tnWB IN xl_mergecells
			DELETE FOR workbook = tnWB IN xl_colwidths
			llSuccess = True
		
		CATCH TO loException
			SET STEP ON
			llSuccess = False
		ENDTRY
		RETURN llSuccess
	ENDPROC

	PROCEDURE Demo		&& Demo for the features of this class
		LOCAL lnWb, lnSh1, lnRow, lnCol, lnSh2, lnSh3, lnSh4, lnOffset, lnCnt, lnFormat, llBoolean, lcNamedRange
		LOCAL lnSh6, lnSh5, loInline
		lnWb = this.CreateWorkbook("ExcelTest.xlsx")
		
		lnSh1 = this.AddSheet(lnWb, "Test Sheet 1")
		this.FreezePanes(lnWb, lnSh1, 1, 2)
		
		llBoolean = True
		FOR lnRow=1 TO 10
			FOR lnCol=1 TO 9
				this.SetCellValue(lnWb, lnSh1, lnRow, lnCol, SYS(2015))
			ENDFOR
			llBoolean = !llBoolean
			this.SetCellValue(lnWb, lnSh1, lnRow, 10, llBoolean)
		ENDFOR
		this.SetRowHeight(lnWb, lnSh1, 6, 25)
		
		* Indentation examples
		this.SetCellIndent(lnWb, lnSh1, 2, 6, 3)
		this.SetCellIndent(lnWb, lnSh1, 4, 6, 3)
		this.SetCellIndent(lnWb, lnSh1, 6, 6, 3)
		this.SetCellIndent(lnWb, lnSh1, 8, 6, 3)
		this.SetCellIndent(lnWb, lnSh1, 10, 6, 3)
		
		*                tnWB, tnSheet, tnCellRow, tnCellCol,           tcFName, tnFSize, tlBold, tlItalic,     tnFColor,  tcULine, tlStrikThr, tcVPos
		this.SetCellFont(lnWb, lnSh1,           1,         1, "Arial",                14,   True,     True, RGB(0,0,255))
		this.SetCellFont(lnWb, lnSh1,           2,         1, "Times New Roman",        ,       ,         , RGB(0,0,255))
		this.SetCellFont(lnWb, lnSh1,           3,         1,                  ,      14,   True)
		this.SetCellFont(lnWb, lnSh1,           4,         1, "Arial",                14,   True,     True, RGB(0,0,255))
		this.SetCellFont(lnWb, lnSh1,           6,         1,                  ,        ,       ,         ,             , 'single')
		this.SetCellFont(lnWb, lnSh1,           7,         1,                  ,        ,       ,         ,             , 'double')
		this.SetCellFont(lnWb, lnSh1,           8,         1,                  ,        ,       ,         ,             ,         , True)
		this.SetCellFont(lnWb, lnSh1,           9,         1,                  ,        ,       ,         ,             ,         ,            , "superscript")
		
		* New procedure each line is drawed with the same style and color
		this.SetCellBorder(lnWb, lnSh1, 3, 4, 63, BORDER_STYLE_THIN,   RGB(16,100,200))
		this.SetCellBorder(lnWb, lnSh1, 3, 6, 31, BORDER_STYLE_THICK,  RGB(100,150,200))
		this.SetCellBorder(lnWb, lnSh1, 3, 8, 47, BORDER_STYLE_DOUBLE, RGB(200,150,100))
		this.SetCellBorder(lnWb, lnSh1, 3, 4,  8, BORDER_STYLE_THIN,   RGB(16,100,200))
		
		this.SetCellWordWrapRange(lnWb, lnSh1, 1, 1, 10, 9, True)
		
		* Old procedure - each line can have a different style or color
		this.SetCellBorderEx(lnWb, lnSh1, 5, 2, 'thin',,'thin',,'thick',,'thick')
		this.SetCellBorderEx(lnWb, lnSh1, 9, 2, ,,,,'double',255,'thick',RGB(255,0,255))
		
		* Example of setting inline text formatting
		loInline = this.CreateInLineFormatText(lnWb, "This is an in-line formatted text string")
		loInline = this.AddInLineFontObject(loInline, 1, 4, "Arial Black", 16)
		loInline = this.AddInLineFontObject(loInline, 5, 15, "Times New Roman", 14, RGB(255,0,0), .T.)
		loInline = this.AddInLineFontObject(loInline, 20, 21, "Arial", 12)
		this.SetCellInLineFormatText(lnWb, lnSh1, 16, 1, loInline)
		
		* Rotated text
		this.SetCellValue(lnWb, lnSh1, 17, 1, "This text is rotated 45 degrees")
		this.SetCellTextRotation(lnWb, lnSh1, 17, 1, 45)
		this.SetCellValue(lnWb, lnSh1, 18, 1, "This text is rotated -45 degrees")
		this.SetCellTextRotation(lnWb, lnSh1, 18, 1, -45)
		
		* Column Width examples
		this.SetColumnWidth(lnWb, lnSh1, 1, 25)
		this.SetColumnWidth(lnWb, lnSh1, 2, 15)
		this.SetColumnWidth(lnWb, lnSh1, 3, 15)
		this.SetColumnWidth(lnWb, lnSh1, 4, 20)
		this.SetColumnWidth(lnWb, lnSh1, 5, 15)
		this.SetColumnWidth(lnWb, lnSh1, 6, 25)
		this.SetColumnWidth(lnWb, lnSh1, 9, 15)
		
		* Sheet setup examples
		this.SetPrintOrientation(lnWb, lnSh1, PORTRAIT_PRINT_ORIENTATION)
		this.SetPaperSize(lnWb, lnSh1, PAPERSIZE_LEGAL)
		this.SetSheetScale(lnWb, lnSh1, 50)
		
		*******************************************************************************
		
		lnSh2 = this.AddSheet(lnWb, "Test Sheet 2")
		this.FreezePanes(lnWb, lnSh2, 1)
		
		this.SetCellValue(lnWb, lnSh2, 1, 1, "Column Header 1")
		this.SetCellValue(lnWb, lnSh2, 1, 2, "Column Header 2")
		this.SetCellValue(lnWb, lnSh2, 1, 3, "Column Header 3")
		this.SetCellValue(lnWb, lnSh2, 1, 4, "Column Header 4")
		this.SetCellValue(lnWb, lnSh2, 1, 5, "Column Header 5")
		
		this.SetCellFont(lnWb, lnSh2, 1, 1, "Arial", 14, True, False, RGB(255,255,255))
		this.SetCellFill(lnWb, lnSh2, 1, 1, RGB(51,102,255))
		this.CellFormatPainter(lnWb, lnSh2, 1, 1, 1, 2, 1, 5)
		
		this.SetColumnWidthRange(lnWb, lnSh2, 1, 5, 24)
		
		* Add integer values to cells
		FOR lnRow=2 TO 6
			FOR lnCol=1 TO 5
				this.SetCellValue(lnWb, lnSh2, lnRow, lnCol, lnRow*lnCol)
			ENDFOR
		ENDFOR
		
		* Add SUM() formula to columns
		FOR lnCol=1 TO 5
			lcColumn = this.ColumnIndexToAscii(lnCol)
			this.SetCellFormula(lnWb, lnSh2, 7, lnCol, "=SUM(" + lcColumn + "2:" + lcColumn + "6)")
		ENDFOR
		
		* Add floating point values to cells
		FOR lnRow=10 TO 15
			FOR lnCol=3 TO 5
				this.SetCellValue(lnWb, lnSh2, lnRow, lnCol, lnRow*1.25)
			ENDFOR
		ENDFOR
		
		* Add AVERAGE(), MAX(), & MIN() formula to columns
		this.SetCellFormula(lnWb, lnSh2, 16, 3, "=AVERAGE(C10:C15)")
		this.SetCellFormula(lnWb, lnSh2, 16, 4, "=MAX(D10:D15)")
		this.SetCellFormula(lnWb, lnSh2, 16, 5, "=MIN(E10:E15)")
		
		this.SetCellValue(lnWb, lnSh2, 16, 1, "This row contains calculated formulas -->")
		
		* Merge some cells
		this.MergeCells(lnWb, lnSh2, 2, 8, 2, 10)
		this.MergeCells(lnWb, lnSh2, 3, 8, 3, 10)
		this.MergeCells(lnWb, lnSh2, 5, 8, 10, 10)
		this.SetCellValue(lnWb, lnSh2, 2, 8, "Merged H2:J2")
		this.SetCellValue(lnWb, lnSh2, 3, 8, "Merged H3:J3")
		this.SetCellValue(lnWb, lnSh2, 5, 8, "Merged H5:J10")
		this.SetCustomPaperSize(lnWb, lnSh2, 841, 1189, "mm")
		this.SetHeaderFooterSetup(lnWb, lnSh2, False, True, False, False)
		this.SetHeaderFooterText(lnWb, lnSh2, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_HDR_CENTER, "This is First Page", "Arial", 16, HEADERFOOTER_FONT_STYLE_BOLD, RGB(255,0,0))
		this.SetHeaderFooterText(lnWb, lnSh2, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_HDR_CENTER, "These are Additional Pages", "Arial", 10, HEADERFOOTER_FONT_STYLE_BOLD, RGB(0,128,0))
		this.SetHeaderFooterText(lnWb, lnSh2, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_FTR_CENTER, "Page &amp;P of &amp;N", "Arial", 16, HEADERFOOTER_FONT_STYLE_BOLD)
		
		*******************************************************************************
		
		lnSh3 = this.AddSheet(lnWb, "Number Formats")
		
		lnFormat = this.AddNumericFormat(lnWb, '[Green]"$"#,##0.00;[Red]"$"#,##0.00')
		*lnFormat = this.AddCustomNumericFormat(lnWb, '[Green]"$"#,##0.00', '[Red]"$"#,##0.00')
		this.SetCellValue(lnWb, lnSh3, 1, 1, 56.558)
		this.SetCellValue(lnWb, lnSh3, 1, 2, "Custom defined format: " + this.GetCustomNumericFormat(lnWb, lnFormat))
		this.SetCellNumberFormat(lnWb, lnSh3, 1, 1, lnFormat)
		
		this.SetColumnWidth(lnWb, lnSh3, 1, 18)
		this.SetColumnWidth(lnWb, lnSh3, 2, 60)
		
		lnOffset = 2
		this.SetCellValue(lnWb, lnSh3, lnOffset+1, 1, 14)
		this.SetCellValue(lnWb, lnSh3, lnOffset+1, 2, "Integer format")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+1, 1, CELL_FORMAT_INTEGER)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+2, 1, 13355.2)
		this.SetCellValue(lnWb, lnSh3, lnOffset+2, 2, "Float format")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+2, 1, CELL_FORMAT_FLOAT)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+3, 1, 16898)
		this.SetCellValue(lnWb, lnSh3, lnOffset+3, 2, "Integer format, comma separated")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+3, 1, CELL_FORMAT_COMMA_INTEGER)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+4, 1, 13355.20)
		this.SetCellValue(lnWb, lnSh3, lnOffset+4, 2, "Float format, comma separated")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+4 , 1, CELL_FORMAT_COMMA_FLOAT)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+5, 1, -13355.20)
		this.SetCellValue(lnWb, lnSh3, lnOffset+5, 2, "Currency format, negative in parenthesis")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+5, 1, CELL_FORMAT_CURRENCY_PAREN)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+6, 1, -13355.20)
		this.SetCellValue(lnWb, lnSh3, lnOffset+6, 2, "Currency format, negative red in parenthesis")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+6, 1, CELL_FORMAT_CURRENCY_RED_PAREN)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+7, 1, 0.55)
		this.SetCellValue(lnWb, lnSh3, lnOffset+7, 2, "Percent format, integer")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+7, 1, CELL_FORMAT_PERCENT_INTEGER)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+8, 1, 0.5534)
		this.SetCellValue(lnWb, lnSh3, lnOffset+8, 2, "Percent format, float")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+8, 1, CELL_FORMAT_PERCENT_FLOAT)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+9, 1, 456800000.00)
		this.SetCellValue(lnWb, lnSh3, lnOffset+9, 2, "Exponential format")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+9, 1, CELL_FORMAT_EXPONENT)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+10, 1, 0.25)
		this.SetCellValue(lnWb, lnSh3, lnOffset+10, 2, "Fraction format, single place")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+10, 1, CELL_FORMAT_FRACTION_1)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+11, 1, 0.3125)
		this.SetCellValue(lnWb, lnSh3, lnOffset+11, 2, "Fraction format, 2 places")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+11, 1, CELL_FORMAT_FRACTION_2)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+12, 1, DATE())
		this.SetCellValue(lnWb, lnSh3, lnOffset+12, 2, "Default date format")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+12, 1, CELL_FORMAT_DATE_DMMMYY)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+13, 1, DATE())
		this.SetCellValue(lnWb, lnSh3, lnOffset+13, 2, "Date format, d-mmm-yy")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+13, 1, CELL_FORMAT_DATE_DMMMYY)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+14, 1, DATE())
		this.SetCellValue(lnWb, lnSh3, lnOffset+14, 2, "Date format, d-mmm")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+14, 1, CELL_FORMAT_DATE_DMMM)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+15, 1, DATE())
		this.SetCellValue(lnWb, lnSh3, lnOffset+15, 2, "Date format, mmm-yy")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+15, 1, CELL_FORMAT_DATE_MMMYY)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+16, 1, 0.35733796296296294)
		this.SetCellValue(lnWb, lnSh3, lnOffset+16, 2, "Time format, h:mm AM/PM")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+16, 1, CELL_FORMAT_TIME_HMMAMPM)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+17, 1, 0.35733796296296294)
		this.SetCellValue(lnWb, lnSh3, lnOffset+17, 2, "Time format, h:mm:ss AM/PM")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+17, 1, CELL_FORMAT_TIME_HMMSSAMPM)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+18, 1, 0.35733796296296294)
		this.SetCellValue(lnWb, lnSh3, lnOffset+18, 2, "Time format, h:mm")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+18, 1, CELL_FORMAT_TIME_HMM)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+19, 1, 0.35733796296296294)
		this.SetCellValue(lnWb, lnSh3, lnOffset+19, 2, "Time format, h:mm:ss")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+19, 1, CELL_FORMAT_TIME_HMMSS)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+20, 1, DATETIME())
		this.SetCellValue(lnWb, lnSh3, lnOffset+20, 2, "Date-Time format, m/d/yy h:mm")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+20, 1, CELL_FORMAT_DATETIME_MDYYHMM)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+21, 1, DATETIME())
		this.SetCellValue(lnWb, lnSh3, lnOffset+21, 2, "Date-Time format, [$-409]dd/mmm/yyyy\ h:mm\ AM/PM;@")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+21, 1, CELL_FORMAT_DATETIME_DDMMMYYYY_TTAM)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+22, 1, DATETIME())
		this.SetCellValue(lnWb, lnSh3, lnOffset+22, 2, "Date-Time format, dd/mmm/yyyy\ h:mm;@")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+22, 1, CELL_FORMAT_DATETIME_DDMMMYYYY_TT24)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+23, 1, DATETIME())
		this.SetCellValue(lnWb, lnSh3, lnOffset+23, 2, "Date-Time format, [$-409]mmm\ d\,\ yyyy\ h:mm\ AM/PM;@")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+23, 1, CELL_FORMAT_DATETIME_MMMDDYYYY_TTAM)
		
		this.SetCellValue(lnWb, lnSh3, 24, 1, DATETIME())
		this.SetCellValue(lnWb, lnSh3, 24, 2, "Date-Time format, [$-409]mmm\ d\,\ yyyy\ h:mm;@")
		this.SetCellNumberFormat(lnWb, lnSh3, 24, 1, CELL_FORMAT_DATETIME_MMMDDYYYY_TT24)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+25, 1, DATETIME())
		this.SetCellValue(lnWb, lnSh3, lnOffset+25, 2, "Date-Time format, m/d/yy\ h:mm\ AM/PM;@")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+25, 1, CELL_FORMAT_DATETIME_MDYY_TTAM)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+26, 1, DATETIME())
		this.SetCellValue(lnWb, lnSh3, lnOffset+26, 2, "Date-Time format, m/d/yy\ h:mm;@")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+26, 1, CELL_FORMAT_DATETIME_MDYY_TT24)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+27, 1, -89235)
		this.SetCellValue(lnWb, lnSh3, lnOffset+27, 2, "Numeric format, #,##0;(#,##0)")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+27, 1, CELL_FORMAT_COMMA_INTEGER_PAREN)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+28, 1, -12457)
		this.SetCellValue(lnWb, lnSh3, lnOffset+28, 2, "Numeric format, #,##0;[Red](#,##0)")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+28, 1, CELL_FORMAT_COMMA_INTEGER_RED_PAREN)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+29, 1, -1245789.22)
		this.SetCellValue(lnWb, lnSh3, lnOffset+29, 2, "Numeric format, #,##0.00;(#,##0.00)")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+29, 1, CELL_FORMAT_COMMA_FLOAT_PAREN)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+30, 1, -125896.33)
		this.SetCellValue(lnWb, lnSh3, lnOffset+30, 2, "Numeric format, #,##0.00;[Red](#,##0.00)")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+30, 1, CELL_FORMAT_COMMA_FLOAT_RED_PAREN)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+31, 1, 6.25E-2)
		this.SetCellValue(lnWb, lnSh3, lnOffset+31, 2, "Time format")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+31, 1, CELL_FORMAT_TIME_MMSS)
		
		this.SetCellValue(lnWb, lnSh3, lnOffset+32, 1, 0.35733796296296294)
		this.SetCellValue(lnWb, lnSh3, lnOffset+32, 2, "Time format, [h]:mm:ss")
		this.SetCellNumberFormat(lnWb, lnSh3, lnOffset+32, 1, CELL_FORMAT_TIME_H_MMSS)
		
		this.SetPrintOrientation(lnWb, lnSh3, LANDSCAPE_PRINT_ORIENTATION)
		*-*	this.SetPrintFitToHeight(lnWb, lnSh3, 2)
		
		*******************************************************************************
		
		lnSh4 = this.AddSheet(lnWb, "Color Sheet")
		this.SetCellValue(lnWb, lnSh4, 1, 1, "RGB(51,102,255)")
		this.SetCellFill(lnWb, lnSh4, 1, 1, RGB(51,102,255))
		
		this.SetCellValue(lnWb, lnSh4, 1, 2, "RGB(255,0,0)")
		this.SetCellFill(lnWb, lnSh4, 1, 2, RGB(255,0,0))
		
		this.SetCellAlignmentRange(lnWb, lnSh4, 1, 1, 1, 2, CELL_HORIZ_ALIGN_CENTER, CELL_VERT_ALIGN_CENTER)
		
		this.SetColumnWidthRange(lnWb, lnSh4, 1, 2, 18)
		this.SetRowHeight(lnWb, lnSh4, 1, 60)
		
		*******************************************************************************
		
		lnSh5 = this.AddSheet(lnWb, "Blank Sheet")
		
		*******************************************************************************
		
		lnSh6 = this.AddSheet(lnWb, "List Values", HIDDEN_SHEET_STATE)
		
		this.SetCellValidation(lnWb, lnSh1, 12, 1, LIST_VALID_TYPE, , , , , , , , , "Yes,No,Maybe")
		this.SetCellValue(lnWb, lnSh1, 12, 2, "The cell to the left has a droplist validation")
		
		this.SetCellValue(lnWb, lnSh6, 1, 1, "Named Value List")
		this.SetCellValue(lnWb, lnSh6, 2, 1, "Named Value 1")
		this.SetCellValue(lnWb, lnSh6, 3, 1, "Named Value 2")
		this.SetCellValue(lnWb, lnSh6, 4, 1, "Named Value 3")
		this.SetCellValue(lnWb, lnSh6, 5, 1, "Named Value 4")
		this.SetCellValue(lnWb, lnSh6, 6, 1, "Named Value 5")
		this.SetCellValue(lnWb, lnSh6, 7, 1, "Named Value 6")
		
		lcNamedRange = this.AddNamedRange(lnWb, lnSh6, "Named Range", SCOPE_WB_NAMED_RANGE, "This is a comment", 2, 1, 7, 1)
		
		this.SetCellValidation(lnWb, lnSh1, 13, 1, LIST_VALID_TYPE, , , , , , , , , "=" + lcNamedRange)
		this.SetCellValue(lnWb, lnSh1, 13, 2, "The cell to the left has a droplist validation based on a Named Range (stored in Hidden Sheet6)")
		
		this.SaveWorkbook(lnWb)
		IF this.Debug
			this.DebugCursorsToFile("ExcelTest")
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE DeriveSheetName		&& Derives the sheet name
		LPARAMETERS txWB
		DO CASE
			CASE VARTYPE(txWB) = "C"
				lcSheetName = JUSTSTEM(txWB)
		
			CASE VARTYPE(txWB) = "N"
				lcSheetName = JUSTSTEM(this.GetWorkbookFileName(txWB))
		
			OTHERWISE
				RETURN ""
		ENDCASE
		RETURN lcSheetName
	ENDPROC

	PROTECTED PROCEDURE Destroy
		SET DEBUGOUT TO
		this.DestroyWorkingCursors()
		this.OnDestroy()
	ENDPROC

	PROTECTED PROCEDURE DestroyWorkingCursors		&& Destroys the working cursors
		TRY
			USE IN SELECT('xl_strings')
			USE IN SELECT('xl_workbooks')
			USE IN SELECT('xl_sheets')
			USE IN SELECT('xl_cells')
			USE IN SELECT('xl_fonts')
			USE IN SELECT('xl_fills')
			USE IN SELECT('xl_borders')
			USE IN SELECT('xl_mergecells')
			USE IN SELECT('xl_colwidths')
			USE IN SELECT('xl_hdrfooterdefn')
			USE IN SELECT('xl_hdrfootertext')
			USE IN SELECT('xl_rowheights')
			USE IN SELECT('xl_numfmts')
			USE IN SELECT('xl_namerange')
			USE IN SELECT('xl_validation')
			USE IN SELECT('xl_strformat')
			USE IN SELECT('xl_cellxfs')
		
		CATCH TO loException
		ENDTRY
	ENDPROC

	PROTECTED PROCEDURE Documentation		&& Documentation of the methods and properties for this class
		*-*
		*-* Written by:  Vilhelm Praisach
		*-*              Gregory Green
		*-*
		*-* Release History:
		*-*
		*-*  May 11, 2015     Initial release.
		*-*  May 12, 2015     Added new methods: SetCellFormatRange, SetCellBorderRange, SaveGridToWorkbook
		*-*                   Added new properties: Title, Subject, CompanyName
		*-*                   Added check in SetCellValue that if a value is being set in a merged cell range then the value is set in the upper
		*-*                       left cell of the merged range
		*-*                   Corrected sheet references when writing the sheet XML
		*-*  May 27, 2015     Added new methods: ConvertPixelsToExcelUnits, GetWorkbook, GetWorkbookSheets, DeleteWorkbook, DeleteAllWorkbooks,
		*-*                                      SetCellAlignment, SetCellNumberDecimals, SetCellNumberFormat, SetCellNumberFormatRange,
		*-*                                      SetColumnWidthRange, SetRowHeight, SetRowHeightRange, SetCellWordWrap
		*-*                   Renamed method RemoveSheet to DeleteSheet
		*-*                   Corrected string to XML conversion (was performing a double conversion of the string)
		*-*                   Corrected issue of generated XLSX file being deleted; increase of Sleep() time for file rename
		*-* June 1, 2015      Corrected bug in merge cell and cell value assignment (after a merge cell was performed any subsequent sheets
		*-*                        added that had cells in the same merge range with value assignments was not having the values set correctly)
		*-*                   Changed property name ExcelXlsxVersion to ExcelXlsxRelease; this property will give the Release number (integer)
		*-*                        of this class
		*-* June 5, 2015      Added to set the default selected table/cursor (value retuned by ALIAS() function) when the default table/cursor
		*-*                        is changed in a method
		*-*                   Added new method: SaveTableToWorkbook
		*-* June 8, 2015      No new features.  Code was optimized for better performance.
		*-*
		*-*                   The first optimization I changed the SetCellValue() code to now always attempt to INSERT first. I added the CANDIDATE
		*-*                   clause to the primary INDEX so that if a cell is already entered, the INSERT command will fail in a TRY-CATCH block
		*-*                   (duplicate KEY); in the CATCH portion I do an update to the cell value. This reduced the time to assign the values
		*-*                   significantly. I had been doing a SEEK() for the cell and updating if found otherwise doing an INSERT
		*-*
		*-*                   The second optimization was how I was assigning a string index value. The original code did a SELECT-SQL WITH a MAX()
		*-*                   for the last used index value IN the workbook (strings are universal TO a workbook); I changed to a property value
		*-*                   (array indexed by the workbook number) and then just increment this value as it is used. Great amount of savings here too.
		*-*
		*-*                   The LAST optimization was in how the Sheet.xml were being written. I now just do a SCAN across the cells and add to the
		*-*                   XML. I was doing several SQL calls to first get the rows and then SQL calls TO the columns for each row. Again not as
		*-*                   efficient as just SCAN-ENDSCAN on the cells cursor table. Had to build in logic to populate rows that did not have a
		*-*                   cell value assigned but had row height assigned. The SQL coding was easier for this but at a great cost in time.
		*-* June 9, 2015      No new features.  Bug fix for a nasty crash of Excel when the print or print-preview is selected.  Congratulations to
		*-*                   Vilhelm for finding this bug.
		*-* July 1, 2015      Corrected return value for AddNumericFormat.
		*-*                   Changed the parameters on AddNumericFormat(); now just pass the numeric format
		*-*
		*-* Oct 29, 2015      Added new functions for opening an existing workbook (xlsx).  Added sheet print formatting methods.
		*-*
		*-************************************************************************************************************************************
	ENDPROC

	PROCEDURE FreezePanes		&& Freezes the panes of the sheet
		LPARAMETERS tnWB, tnSheet, tnTopRowCount, tnSideColCount
		LOCAL lxReturn
		DO CASE
			CASE PCOUNT() < 3
				RETURN False
			
			CASE PCOUNT() = 3
				tnSideColCount = 0
		ENDCASE
		IF VARTYPE(tnTopRowCount) != 'N'
			tnTopRowCount = 0
		ENDIF
		IF VARTYPE(tnSideColCount) != 'N'
			tnSideColCount = 0
		ENDIF
		IF this.GetSheetRecord(tnWB, tnSheet)
			REPLACE xl_sheets.xsplit WITH tnSideColCount, ;
					xl_sheets.ysplit WITH tnTopRowCount IN xl_sheets
			lxReturn = True
		ELSE
			lxReturn = False
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROTECTED PROCEDURE GetBordersRecord		&& Gets the border record; returns True if found, or False in not found
		LPARAMETERS tnWB, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp
		RETURN SEEK(BINTOC(tnWB) + tcLStyle + BINTOC(tnLColor) + tcRStyle + BINTOC(tnRColor) + tcTStyle + BINTOC(tnTColor) + tcBStyle + BINTOC(tnBColor) + ;
			   		tcDStyle + BINTOC(tnDColor) + BINTOC(tnDiagDn) + BINTOC(tnDiagUp), "xl_borders", "cellborder")
	ENDPROC

	PROCEDURE GetCellAlignment		&& Returns the cell alignment
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL loAlignInfo
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
			loAlignInfo = CREATEOBJECT("Empty")
			ADDPROPERTY(loAlignInfo, "HorzAlign", xl_cellxfs.halign)
			ADDPROPERTY(loAlignInfo, "VertAlign", xl_cellxfs.valign)
		ELSE
			loAlignInfo = .NULL.
		ENDIF
		RETURN loAlignInfo
	ENDPROC

	PROCEDURE GetCellBorders		&& Returns the cell border info
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL loBdrInfo
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs) .AND. this.GetCursorRecord("xl_borders", tnWB, xl_cellxfs.borderId)
			loBdrInfo = CREATEOBJECT("Empty")
			ADDPROPERTY(loBdrInfo, "LeftStyle",  xl_borders.lstyle)
			ADDPROPERTY(loBdrInfo, "LeftColor",  xl_borders.lcolor)
			ADDPROPERTY(loBdrInfo, "LeftTheme",  xl_borders.ltheme)
			ADDPROPERTY(loBdrInfo, "LeftTint",   xl_borders.ltint)
			ADDPROPERTY(loBdrInfo, "LeftIndex",  xl_borders.lindexed)
		
			ADDPROPERTY(loBdrInfo, "RightStyle", xl_borders.rstyle)
			ADDPROPERTY(loBdrInfo, "RightColor", xl_borders.rcolor)
			ADDPROPERTY(loBdrInfo, "RightTheme", xl_borders.rtheme)
			ADDPROPERTY(loBdrInfo, "RightTint",  xl_borders.rtint)
			ADDPROPERTY(loBdrInfo, "RightIndex", xl_borders.rindexed)
		
			ADDPROPERTY(loBdrInfo, "TopStyle",   xl_borders.tstyle)
			ADDPROPERTY(loBdrInfo, "TopColor",   xl_borders.tcolor)
			ADDPROPERTY(loBdrInfo, "TopTheme",   xl_borders.ttheme)
			ADDPROPERTY(loBdrInfo, "TopTint",    xl_borders.ttint)
			ADDPROPERTY(loBdrInfo, "TopIndex",   xl_borders.tindexed)
		
			ADDPROPERTY(loBdrInfo, "BotStyle",   xl_borders.bstyle)
			ADDPROPERTY(loBdrInfo, "BotColor",   xl_borders.bcolor)
			ADDPROPERTY(loBdrInfo, "BotTheme",   xl_borders.btheme)
			ADDPROPERTY(loBdrInfo, "BotTint",    xl_borders.btint)
			ADDPROPERTY(loBdrInfo, "BotIndex",   xl_borders.bindexed)
		
			ADDPROPERTY(loBdrInfo, "DiagStyle",  xl_borders.dstyle)
			ADDPROPERTY(loBdrInfo, "DiagColor",  xl_borders.dcolor)
			ADDPROPERTY(loBdrInfo, "DiagTheme",  xl_borders.dtheme)
			ADDPROPERTY(loBdrInfo, "DiagTint",   xl_borders.dtint)
			ADDPROPERTY(loBdrInfo, "DiagIndex",  xl_borders.dindexed)
		
			ADDPROPERTY(loBdrInfo, "DiagDn",     xl_borders.diagdn)
			ADDPROPERTY(loBdrInfo, "DiagUp",     xl_borders.diagup)
		ELSE
			loBdrInfo = .NULL.
		ENDIF
		RETURN loBdrInfo
	ENDPROC

	PROCEDURE GetCellDataType		&& Returns the data type for the selected cell
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL lxReturn
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			lxReturn = xl_cells.datatype
		ELSE
			lxReturn = .NULL.
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROCEDURE GetCellFill		&& Returns the fill info for the cell
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL loFillInfo
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs) .AND. this.GetCursorRecord("xl_fills", tnWB, xl_cellxfs.fillid)
			loFillInfo = CREATEOBJECT("Empty")
			ADDPROPERTY(loFillInfo, "FgColor",   xl_fills.fgcolor)
			ADDPROPERTY(loFillInfo, "BgColor",   xl_fills.bgcolor)
			ADDPROPERTY(loFillInfo, "PatType",   xl_fills.patttype)
			ADDPROPERTY(loFillInfo, "Theme",     xl_fills.theme)
			ADDPROPERTY(loFillInfo, "Tint",      xl_fills.tint)
			ADDPROPERTY(loFillInfo, "FgIndexed", xl_fills.fgindexed)
			ADDPROPERTY(loFillInfo, "BgIndexed", xl_fills.bgindexed)
		ELSE
			loFillInfo = .NULL.
		ENDIF
		RETURN loFillInfo
	ENDPROC

	PROCEDURE GetCellFont		&& Returns the cell font settings
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL loFontInfo
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs) .AND. this.GetCursorRecord("xl_fonts", tnWB, xl_cellxfs.fontid)
			loFontInfo = CREATEOBJECT("Empty")
			ADDPROPERTY(loFontInfo, "FontName",        ALLTRIM(xl_fonts.fname))
			ADDPROPERTY(loFontInfo, "FontSize",        xl_fonts.fsize)
			ADDPROPERTY(loFontInfo, "FontBold",        xl_fonts.fbold)
			ADDPROPERTY(loFontInfo, "FontItalic",      xl_fonts.fitalic)
			ADDPROPERTY(loFontInfo, "ForeColor",       xl_fonts.fcolor)
			ADDPROPERTY(loFontInfo, "FontUnderline",   ALLTRIM(xl_fonts.uline))
			ADDPROPERTY(loFontInfo, "FontStrikeThr",   xl_fonts.strkthr)
			ADDPROPERTY(loFontInfo, "FontVerticalPos", ALLTRIM(xl_fonts.fvpos))
		ELSE
			loFontInfo = .NULL.
		ENDIF
		RETURN loFontInfo
	ENDPROC

	PROCEDURE GetCellFormula		&& Returns the cell formula expression
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL lcFormula
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		lcFormula = .NULL.
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			lcFormula = ALLTRIM(xl_cells.cellformula)
		ENDIF
		RETURN lcFormula
	ENDPROC

	PROTECTED PROCEDURE GetCellFormulaFromXML		&& Gets the cell formula from the XML node
		LPARAMETERS tcFormula, tnCellCol
		LOCAL lcFormula, lcShared, lnId, lcTemp, lnNdx, lcChr, lcAddExpr, lnCol, lcRef, lcRefBeg, lcRefEnd, llColRelative
		LOCAL lnColBase, llRowRelative, lnRowBase
		lcFormula = this.GetNodeElementValue(tcFormula)
		lcShared  = this.GetNodeAttributeValue(tcFormula, "t")
		IF !EMPTY(lcShared)
		*-*	The formula is a shared formula
			lnId = this.GetNodeAttributeValue(tcFormula, "si")
			IF EMPTY(lcFormula)
				IF SEEK(lnId, "t_shared", "id")
		*-*			Shared formula already added; update the column:row relative references
					lcFormula = ""
					lcTemp = ALLTRIM(t_shared.cellformula)
					DO CASE
						CASE t_shared.colrelative                && Forumla column is relative
							lnNdx = 1
							DO WHILE lnNdx <= LEN(lcTemp)
								lcChr = SUBSTR(lcTemp, lnNdx, 1)
								IF ISALPHA(lcChr)
									lcAddExpr = lcChr
									DO WHILE lnNdx <= LEN(lcTemp)
										lnNdx = lnNdx + 1
										lcChr = SUBSTR(lcTemp, lnNdx, 1)
										DO CASE
											CASE ISALPHA(lcChr)
												lcAddExpr = lcAddExpr + lcChr
											
											CASE ISDIGIT(lcChr)
												lnCol = this.ColumnAsciiToIndex(lcAddExpr)
												lnCol = lnCol + (tnCellCol - t_shared.colbase)
												lcAddExpr = this.ColumnIndexToAscii(lnCol) + lcChr
												EXIT
		
											OTHERWISE
												lcAddExpr = lcAddExpr + lcChr
												EXIT
										ENDCASE
									ENDDO
								ELSE
									lcAddExpr = lcChr
								ENDIF
								lcFormula = lcFormula + lcAddExpr
								lnNdx = lnNdx + 1
							ENDDO
						
						CASE t_shared.rowrelative                && Forumla row is relative
							lnNdx = 1
							DO WHILE lnNdx <= LEN(lcTemp)
								lcChr = SUBSTR(lcTemp, lnNdx, 1)
								IF ISDIGIT(lcChr)
									lcAddExpr = lcChr
									DO WHILE lnNdx <= LEN(lcTemp)
										lnNdx = lnNdx + 1
										lcChr = SUBSTR(lcTemp, lnNdx, 1)
										IF ISDIGIT(lcChr)
											lcAddExpr = lcAddExpr + lcChr
										ELSE
											IF ISALPHA(lcChr)
												lcAddExpr = lcAddExpr + lcChr
											ELSE
												lnRow = INT(VAL(lcAddExpr))
												lnRow = lnRow + (lnCellRow - t_shared.rowbase)
												lcAddExpr = TRANSFORM(lnRow) + lcChr
											ENDIF
											EXIT
										ENDIF
									ENDDO
								ELSE
									lcAddExpr = lcChr
								ENDIF
								lcFormula = lcFormula + lcAddExpr
								lnNdx = lnNdx + 1
							ENDDO
					ENDCASE
				ELSE
					lcFormula = ""
				ENDIF
			ELSE
				lcRef = this.GetNodeAttributeValue(tcFormula, "ref")
				IF !SEEK(lnId, "t_shared", "id") .AND. OCCURS(":", lcRef) > 0
					lcRefBeg = this.GetColumnInColRowPair(GETWORDNUM(lcRef, 1, ":"))
					lcRefEnd = this.GetColumnInColRowPair(GETWORDNUM(lcRef, 2, ":"))
					IF lcRefBeg == lcRefEnd
						llColRelative = False
						lnColBase     = 0
						llRowRelative = True
						lnRowBase     = this.GetRowInColRowPair(GETWORDNUM(lcRef, 1, ":"))
					ELSE
						llColRelative = True
						lnColBase     = this.ColumnAsciiToIndex(lcRefBeg)
						llRowRelative = False
						lnRowBase     = 0
					ENDIF
					INSERT INTO t_shared (id, colrelative, colbase, rowrelative, rowbase, cellformula) ;
						VALUES (lnId, llColRelative, lnColBase, llRowRelative, lnRowBase, lcFormula)
				ENDIF
			ENDIF
		ENDIF
		RETURN lcFormula
	ENDPROC

	PROCEDURE GetCellIndent		&& Returns the cell indentation
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL lnIndent
		IF PCOUNT() != 4
			RETURN -1
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
			lnIndent = xl_cellxfs.indent
		ELSE
			lnIndent = 0
		ENDIF
		RETURN lnIndent
	ENDPROC

	PROCEDURE GetCellNumberFormat		&& Returns the format code for the selected cell
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL lnNumFmtId
		IF PCOUNT() != 4
			RETURN -1
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
			lnNumFmtId = xl_cellxfs.numFmtId
		ELSE
			lnNumFmtId = 0
		ENDIF
		RETURN lnNumFmtId
	ENDPROC

	PROTECTED PROCEDURE GetCellRecord		&& Positions to the xl_cells record; returns true if found, or false if not found
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		RETURN SEEK(BINTOC(tnWB)+BINTOC(tnSheet)+BINTOC(tnCellRow)+BINTOC(tnCellCol), "xl_cells", "cellindex")
	ENDPROC

	PROCEDURE GetCellTextRotation		&& Gets the cell text rotation value
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL lnRotation
		IF PCOUNT() != 4
			RETURN 99
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
			lnRotation = xl_cellxfs.rotation
			IF lnRotation > 90
				lnRotation = 90 - lnRotation
			ENDIF
		ELSE
			lnRotation = 0
		ENDIF
		RETURN lnRotation
	ENDPROC

	PROCEDURE GetCellValidation		&& Returns the cell validation settings
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL loValiation
		loValiation = CREATEOBJECT("Empty")
		ADDPROPERTY(loValiation, "Type", 0)
		ADDPROPERTY(loValiation, "Style", 0)
		ADDPROPERTY(loValiation, "Operator", 0)
		ADDPROPERTY(loValiation, "AllowBlank", False)
		ADDPROPERTY(loValiation, "ShowInputMsg", False)
		ADDPROPERTY(loValiation, "ShowErrMsg", False)
		ADDPROPERTY(loValiation, "ErrMsg", "")
		ADDPROPERTY(loValiation, "ErrTitle", "")
		ADDPROPERTY(loValiation, "Prompt", "")
		ADDPROPERTY(loValiation, "Formula1", "")
		ADDPROPERTY(loValiation, "Formula2", "")
		IF PCOUNT() < 4
			RETURN loValiation
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. SEEK(BINTOC(xl_cells.validndx), "xl_validation", "validndx")
			loValiation.Type         = xl_validation.vtype
			loValiation.Style        = xl_validation.vstyle
			loValiation.Operator     = xl_validation.voperator
			loValiation.AllowBlank   = xl_validation.allowblank
			loValiation.ShowInputMsg = xl_validation.showinpmsg
			loValiation.ShowErrMsg   = xl_validation.showerrmsg
			loValiation.ErrMsg       = xl_validation.errmsg
			loValiation.ErrTitle     = xl_validation.errtitle
			loValiation.Prompt       = xl_validation.vprompt
			loValiation.Formula1     = xl_validation.formula1
			loValiation.Formula2     = xl_validation.formula2
		ENDIF
		RETURN loValiation
	ENDPROC

	PROCEDURE GetCellValue		&& Returns the value of the cell
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL lxValue, lnDays, lnDecimals, lnMSec, lnTime
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		lxValue = .NULL.
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			DO CASE
				CASE xl_cells.datatype = DATA_TYPE_DATE
					lnDays  = CAST(xl_cells.cellvalue AS I)
					lxValue = DATE(1900, 1, 1) + lnDays - 2
		
				CASE xl_cells.datatype = DATA_TYPE_TIME
					lnDecimals  = SET("DECIMALS")
					SET DECIMALS TO 12
					lnMSec  = CAST(xl_cells.cellvalue AS N(20,12))
					lnTime  = lnMSec * 24 * 60 * 60
					lxValue = DTOT(DATE()) + lnTime
					lxValue = TRANSFORM(HOUR(lxValue)) + ":" + TRANSFORM(MINUTE(lxValue)) + ":" + TRANSFORM(SEC(lxValue))
					SET DECIMALS TO &lnDecimals
		
				CASE xl_cells.datatype = DATA_TYPE_DATETIME
					lnDecimals  = SET("DECIMALS")
					SET DECIMALS TO 12
					lnDays  = CAST(xl_cells.cellvalue AS I)
					lxValue = DATE(1900, 1, 1) + lnDays - 2
					lnMSec  = CAST(xl_cells.cellvalue AS N(20,12)) - lnDays
					lnTime  = lnMSec * 24 * 60 * 60
					lxValue = DTOT(lxValue) + lnTime
					SET DECIMALS TO &lnDecimals
		
				CASE xl_cells.datatype = DATA_TYPE_CHAR
					IF this.GetCursorRecord("xl_strings", tnWB, xl_cells.stringid)
						lxValue = RTRIM(xl_strings.string)
					ELSE
						lxValue = ""
					ENDIF
		
				CASE xl_cells.datatype = DATA_TYPE_INT
					lxValue = CAST(xl_cells.cellvalue AS I)
		
				CASE xl_cells.datatype = DATA_TYPE_FLOAT
					lxValue = CAST(xl_cells.cellvalue AS F)
		
				CASE xl_cells.datatype = DATA_TYPE_CURRENCY
					lxValue = CAST(xl_cells.cellvalue AS Y)
		
				CASE xl_cells.datatype = DATA_TYPE_PERCENT
					lxValue = CAST(xl_cells.cellvalue AS F)
					lxValue = TRANSFORM(lxValue * 100) + "%"
		
				CASE xl_cells.datatype = DATA_TYPE_GENERAL
					lxValue = ALLTRIM(xl_cells.cellvalue)
		
				CASE xl_cells.datatype = DATA_TYPE_FORMULA
		
				CASE xl_cells.datatype = DATA_TYPE_NONE
					lxValue = ALLTRIM(xl_cells.cellvalue)
				
				OTHERWISE
					lxValue = ALLTRIM(xl_cells.cellvalue)
			ENDCASE
		ENDIF
		RETURN lxValue
	ENDPROC

	PROCEDURE GetCellWordWrap		&& Returns the cell word wrap setting
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL lxReturn
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
			lxReturn = xl_cellxfs.wraptext
		ELSE
			lxReturn = .NULL.
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROTECTED PROCEDURE GetCellXfsId		&& Returns the Cell XfsId value
		LPARAMETERS tnWB, tnNumFmtId, tnFontId, tnFillId, tnBorderId, tcHAlign, tcVAlign, tnIndex, tnWrapText, tnRotation
		LOCAL lnCellXfsId
		IF SEEK(BINTOC(tnWB)+BINTOC(tnNumFmtId)+BINTOC(tnFontId)+BINTOC(tnFillId)+BINTOC(tnBorderId)+BINTOC(tnIndex)+BINTOC(tnWrapText)+BINTOC(tnRotation)+ALLTRIM(tcHAlign)+ALLTRIM(tcVAlign), "xl_cellxfs", "cellxfs")
			lnCellXfsId = xl_cellxfs.id
		ELSE
			lnCellXfsId = this.GetNextId(tnWB, 'xl_cellxfs')
			INSERT INTO xl_cellxfs (workbook, id, numFmtId, fontId, fillId, borderId, halign, valign, indent, wraptext, rotation) ;
				VALUES (tnWB, lnCellXfsId, tnNumFmtId, tnFontId, tnFillId, tnBorderId, tcHAlign, tcVAlign, tnIndex, tnWrapText, tnRotation)
		ENDIF
		RETURN lnCellXfsId
	ENDPROC

	PROTECTED PROCEDURE GetCellXfsRecord		&& Positions the record pointer to xl_cellxfs record; returns true if found, or false if not found
		LPARAMETERS tnWB, tnId
		RETURN SEEK(BINTOC(tnWB)+BINTOC(tnId), "xl_cellxfs", "id")
	ENDPROC

	PROTECTED PROCEDURE GetChildNodeCount		&& Returns the number of child nodes
		LPARAMETERS tcNode
		RETURN OCCURS("<", tcNode) - 2
	ENDPROC

	PROTECTED PROCEDURE GetChildNodeElement		&& Returns the selected child node
		LPARAMETERS tcNode, tnChild
		LOCAL lcElement
		lcElement = STREXTRACT(tcNode, '<', '>', tnChild+1, 1)
		RETURN STREXTRACT(tcNode, '<'+lcElement+'>', '</'+lcElement+'>', 1, 5)
	ENDPROC

	PROTECTED PROCEDURE GetColumnInColRowPair		&& Returns the column (Ascii value) in a ColRow pair; i.e., returns A from A6 reference
		LPARAMETERS tcColRow
		LOCAL lnNdx, lcCol, lcChr
		lcCol = ""
		FOR lnNdx=1 TO LEN(tcColRow)
			lcChr = SUBSTR(tcColRow, lnNdx, 1)
			IF ISDIGIT(lcChr)
				EXIT
			ENDIF
			lcCol = lcCol + lcChr
		ENDFOR
		RETURN lcCol
	ENDPROC

	PROCEDURE GetColumnWidth		&& Returns the column width
		LPARAMETERS tnWB, tnSheet, tnColumn
		LOCAL lxReturn
		IF PCOUNT() < 3
			RETURN .NULL.
		ENDIF
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF SEEK(this.GetColWidthKeyExpr(tnWB, tnSheet, tnColumn), "xl_colwidths", "shcolumn")
				lxReturn = xl_colwidths.width
			ELSE
				lxReturn = -1
			ENDIF
		ELSE
			lxReturn = .NULL.
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROTECTED PROCEDURE GetColWidthKeyExpr		&& Gets the key expression for c_colwidths
		LPARAMETERS tnWB, tnSheet, tnColumn
		RETURN BINTOC(tnWB)+BINTOC(tnSheet)+BINTOC(tnColumn)
	ENDPROC

	PROTECTED PROCEDURE GetCursorRecord		&& Gets the specified xl_cursor record; returns true if found, false if not found
		LPARAMETERS tcCursor, tnWB, tnId
		RETURN SEEK(BINTOC(tnWB)+BINTOC(tnId), tcCursor, "id")
	ENDPROC

	PROCEDURE GetCustomNumericFormat		&& Returns the format code for the specified custom numeric format
		LPARAMETERS tnWB, tnNumFormat
		LOCAL lxReturn
		IF SEEK(BINTOC(tnWB)+BINTOC(tnNumFormat), "xl_numfmts", "id")
			lxReturn = ALLTRIM(xl_numfmts.code)
		ELSE
			lxReturn = ""
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROCEDURE GetCustomPaperSize		&& Gets the values for the custom paper size
		LPARAMETERS tnWB, tnSheet
		LOCAL loReturn
		IF PCOUNT() = 2 .AND. this.GetSheetRecord(tnWB, tnSheet)
			loReturn = CREATEOBJECT("Empty")
			ADDPROPERTY(loReturn, "PaperWidth",  xl_sheets.paperwidth)
			ADDPROPERTY(loReturn, "PaperHeight", xl_sheets.paperheight)
			ADDPROPERTY(loReturn, "PaperDimen",  xl_sheets.paperdimen)
		ELSE
			loReturn = .NULL.
		ENDIF
		RETURN loReturn
	ENDPROC

	PROTECTED PROCEDURE GetFormatKeyExpr		&& Gets the key expression for t_format
		LPARAMETERS tnNbrFmtId, tnNumDec, tnFontId, tnFillId, tnBorderId, tcHAlign, tcVAlign, tlWordWrap
		RETURN BINTOC(tnNbrFmtId)+BINTOC(tnNumDec)+BINTOC(tnFontId)+BINTOC(tnFillId)+BINTOC(tnBorderId)+tcHAlign+tcVAlign+TRANSFORM(tlWordWrap)
	ENDPROC

	PROTECTED PROCEDURE GetHeaderFooterKeyExpr		&& Gets the key expression for the header footer table record
		LPARAMETERS tnWB, tnSheet, tnPage, tnSection
		RETURN BINTOC(tnWB)+BINTOC(tnSheet)+BINTOC(tnPage)+BINTOC(tnSection)
	ENDPROC

	PROCEDURE GetInLineFontDefinition		&& Returns the inline formatting definition of cell text for each character group
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL loSharedString, loInline, lcAlias, lnBegPos, lnLen, loCharacter
		IF PCOUNT() != 4
			RETURN .NULL.
		ENDIF
		loSharedString = this.GetSharedStringId(tnWB, tnSheet, tnCellRow, tnCellCol)
		IF ISNULL(loSharedString)
			RETURN .NULL.
		ENDIF
		lnBegPos = 1
		lcAlias  = ALIAS()
		loInline = CREATEOBJECT("Empty")
		ADDPROPERTY(loInline, "Workbook", tnWB)
		ADDPROPERTY(loInline, "StringId", loSharedString.StringId)
		ADDPROPERTY(loInline, "StringValue", loSharedString.StringValue)
		ADDPROPERTY(loInline, "Count", 0)
		ADDPROPERTY(loInline, "Characters[1]")
		SELECT xl_strformat
		SET ORDER TO TAG sortorder
		SCAN FOR workbook = tnWB .AND. id = loSharedString.StringId .AND. !DELETED()
			lnLen = LEN(RTRIM(xl_strformat.stringvalue))
			loCharacter = CREATEOBJECT("Empty")
			ADDPROPERTY(loCharacter, "BegPos", lnBegPos)
			ADDPROPERTY(loCharacter, "Length", lnLen)
			ADDPROPERTY(loCharacter, "FontName", xl_strformat.fname)
			ADDPROPERTY(loCharacter, "FontSize", xl_strformat.fsize)
			ADDPROPERTY(loCharacter, "FontBold", xl_strformat.fbold)
			ADDPROPERTY(loCharacter, "FontItalic", xl_strformat.fitalic)
			ADDPROPERTY(loCharacter, "FontColor", xl_strformat.fcolor)
			ADDPROPERTY(loCharacter, "Underline", xl_strformat.uline)
			ADDPROPERTY(loCharacter, "StrikeThru", xl_strformat.strkthr)
			ADDPROPERTY(loCharacter, "SubScript", IIF(xl_strformat.fvpos=FONT_VERTICAL_SUBSCRIPT, True, False))
			ADDPROPERTY(loCharacter, "SuperScript", IIF(xl_strformat.fvpos=FONT_VERTICAL_SUPERSCRIPT, True, False))
			loInline.Count = loInline.Count + 1
			DIMENSION loInline.Characters[loInline.Count]
			loInline.Characters[loInline.Count] = loCharacter
			lnBegPos = lnBegPos + lnLen
		ENDSCAN
		SET ORDER TO
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		IF loInline.Count = 0
			loInline = .NULL.
		ENDIF
		RETURN loInline
	ENDPROC

	PROCEDURE GetLastColumnInRow		&& Returns the last column index in the row
		LPARAMETERS tnWB, tnSheet, tnCellRow
		LOCAL lnMaxCol
		IF PCOUNT() < 3
			RETURN .NULL.
		ENDIF
		lnMaxCol = 0
		SELECT MAX(tmp.cellcol) AS maxcol FROM xl_cells AS tmp ;
			WHERE workbook = tnWB ;
				AND tmp.sheet = tnSheet ;
				AND tmp.cellrow = tnCellRow ;
				AND tmp.celldeleted = False ;
			INTO CURSOR t_temp
		
		IF _TALLY > 0
			lnMaxCol = t_temp.maxcol
		ENDIF
		IF USED('t_temp')
			USE IN t_temp
		ENDIF
		RETURN lnMaxCol
	ENDPROC

	PROCEDURE GetLastRowNumber		&& Returns the last row number in the sheet
		LPARAMETERS tnWB, tnSheet
		LOCAL lnLastRow
		IF PCOUNT() < 2
			RETURN .NULL.
		ENDIF
		lnLastRow = 0
		SELECT MAX(tmp.cellrow) AS maxrow FROM xl_cells AS tmp ;
			WHERE workbook = tnWB ;
				AND tmp.sheet = tnSheet ;
				AND tmp.celldeleted = False ;
			INTO CURSOR t_temp
		
		IF _TALLY > 0
			lnLastRow = t_temp.maxrow
		ENDIF
		IF USED('t_temp')
			USE IN t_temp
		ENDIF
		RETURN lnLastRow
	ENDPROC

	PROCEDURE GetMaxColumnNumber		&& Returns the max column number for a sheet
		LPARAMETERS tnWB, tnSheet
		LOCAL lnMaxCol
		IF PCOUNT() < 2
			RETURN .NULL.
		ENDIF
		lnMaxCol = 0
		SELECT MAX(tmp.cellcol) AS maxcol FROM xl_cells AS tmp ;
			WHERE workbook = tnWB ;
				AND tmp.sheet = tnSheet ;
				AND tmp.celldeleted = False ;
			INTO CURSOR t_temp
		
		IF _TALLY > 0
			lnMaxCol = t_temp.maxcol
		ENDIF
		IF USED('t_temp')
			USE IN t_temp
		ENDIF
		RETURN NVL(lnMaxCol, 0)
	ENDPROC

	PROTECTED PROCEDURE GetNextId		&& Gets the next sequential Id value
		LPARAMETERS tnWB, tcCursor
		LOCAL lcSetDeleted
		lcSetDeleted = SET("DELETED")
		SET DELETED ON
		SELECT tmp.workbook, MAX(tmp.id) AS lastid FROM &tcCursor AS tmp WHERE tmp.workbook = tnWB GROUP BY tmp.workbook INTO CURSOR c_temp
		IF _TALLY > 0
			GOTO TOP IN c_temp
			lnNextId = c_temp.lastid + 1
		ELSE
			lnNextId = 0
		ENDIF
		SET DELETED &lcSetDeleted
		USE IN SELECT('c_temp')
		RETURN lnNextId
	ENDPROC

	PROTECTED PROCEDURE GetNodeAttributeValue		&& Returns the attribute value
		LPARAMETERS tcXf, tcAttrName
		RETURN STREXTRACT(tcXf, tcAttrName+'="', '"', 1)
	ENDPROC

	PROTECTED PROCEDURE GetNodeElement		&& Gets the string content for the node element
		LPARAMETERS tcNode, tcElement, tnNode, tlStrict
		LOCAL lcContent
		IF PCOUNT() = 3
			tlStrict = False
		ENDIF
		IF tlStrict
			lcContent = STREXTRACT(tcNode, '<'+tcElement+'>', '</'+tcElement+'>', tnNode, 5)
		ELSE
			lcContent = STREXTRACT(tcNode, '<'+tcElement+' ', '>', tnNode, 5)
			IF RIGHT(lcContent, 2) != "/>"
				lcContent = STREXTRACT(tcNode, '<'+tcElement+' ', '</'+tcElement+'>', tnNode, 5)
				IF EMPTY(lcContent)
					lcContent = STREXTRACT(tcNode, '<'+tcElement+'>', '</'+tcElement+'>', tnNode, 5)
				ENDIF
				IF EMPTY(lcContent)
					lcContent = STREXTRACT(tcNode, '<'+tcElement, '/>', tnNode, 5)
				ENDIF
			ENDIF
		ENDIF
		RETURN lcContent
	ENDPROC

	PROTECTED PROCEDURE GetNodeElementValue		&& Gets the value assigned to the node element
		LPARAMETERS tcElement
		RETURN STREXTRACT(tcElement, '>', '<', 1, 1)
	ENDPROC

	PROCEDURE GetPaperSize		&& Gets the paper size for the selected sheet
		LPARAMETERS tnWB, tnSheet
		LOCAL lxReturn
		IF PCOUNT() = 2 .AND. this.GetSheetRecord(tnWB, tnSheet)
			lxReturn = xl_sheets.papersize
		ELSE
			lxReturn = -1
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROCEDURE GetPrintOrientation		&& Gets the print orientation for the sheet output
		LPARAMETERS tnWB, tnSheet
		LOCAL lxReturn
		IF PCOUNT() = 2 .AND. this.GetSheetRecord(tnWB, tnSheet)
			lxReturn = xl_sheets.prnorient
		ELSE
			lxReturn = 0
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROCEDURE GetRGBValues		&& Gets the specified RGB color value
		LPARAMETERS tnColorValue, tcRGB
		LOCAL lnValue, lnNdx
		IF PCOUNT() < 2
			RETURN -1
		ENDIF
		DO CASE
			CASE tcRGB = "R"
				lnValue = tnColorValue
				FOR lnNdx=8 TO 31
					lnValue = BITCLEAR(lnValue, lnNdx)
				ENDFOR
		
			CASE tcRGB = "G"
				lnValue = BITRSHIFT(tnColorValue, 8)
				FOR lnNdx=8 TO 31
					lnValue = BITCLEAR(lnValue, lnNdx)
				ENDFOR
		
			CASE tcRGB = "B"
				lnValue = BITRSHIFT(tnColorValue, 16)
				FOR lnNdx=8 TO 31
					lnValue = BITCLEAR(lnValue, lnNdx)
				ENDFOR
		
			OTHERWISE
				RETURN -1
		ENDCASE
		RETURN INT(lnValue)
	ENDPROC

	PROTECTED PROCEDURE GetRowHeightKeyExpr		&& Gets the key expression for the c_rowheights
		LPARAMETERS tnWB, tnSheet, tnRow
		RETURN BINTOC(tnWB)+BINTOC(tnSheet)+BINTOC(tnRow)
	ENDPROC

	PROTECTED PROCEDURE GetRowInColRowPair		&& REturns the row (integer value) in a ColRow pair; i.e., return 6 from A6 reference
		LPARAMETERS tcColRow
		LOCAL lcRow, lnNdx, lcChr
		lcRow = ""
		FOR lnNdx=1 TO LEN(tcColRow)
			lcChr = SUBSTR(tcColRow, lnNdx, 1)
			IF ISDIGIT(lcChr)
				lcRow = lcRow + lcChr
			ENDIF
		ENDFOR
		RETURN INT(VAL(lcRow))
	ENDPROC

	PROTECTED PROCEDURE GetSharedStringId		&& Gets the Shared Strings Id value for the cell text
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL loSharedString
		loSharedString = .NULL.
		IF PCOUNT() < 4
			RETURN loSharedString
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol) .AND. this.GetCursorRecord("xl_strings", tnWB, xl_cells.stringid)
			loSharedString = CREATEOBJECT("Empty")
			ADDPROPERTY(loSharedString, "StringId", xl_cells.stringid)
			ADDPROPERTY(loSharedString, "StringValue", xl_strings.string)
		ENDIF
		RETURN loSharedString
	ENDPROC

	PROCEDURE GetSheetName		&& Gets the sheet name
		LPARAMETERS tnWB, tnSheet
		LOCAL lcSheetName
		IF PCOUNT() = 2 .AND. this.GetSheetRecord(tnWB, tnSheet)
			lcSheetName = ALLTRIM(xl_sheets.shname)
		ELSE
			lcSheetName = ""
		ENDIF
		RETURN lcSheetName
	ENDPROC

	PROTECTED PROCEDURE GetSheetNameXML		&& Gets the sheet file name for the R:Id value in the XML
		LPARAMETERS toXDOM, tcFilePath, tcShRId
		LOCAL lcFileName, loNodes, lnNode, loNode, lcId, lcShFile
		LOCAL ARRAY laTemp[1]
		lcShFile = ""
		lcFileName = ADDBS(tcFilePath) + "xl\_rels\workbook.xml.rels"
		IF ADIR(laTemp, lcFileName) > 0
			toXDOM.Load(lcFileName)
			TRY
				loNodes = toXDOM.getElementsByTagName("Relationship")
				FOR lnNode=0 TO loNodes.Length-1
					loNode = loNodes.Item(lnNode)
					lcId   = NVL(loNode.getAttribute("Id"), "")
					IF lcId == tcShRId
						lcShFile = NVL(loNode.getAttribute("Target"), "")
						EXIT
					ENDIF
				ENDFOR
		
			CATCH TO loException
				SET STEP ON
			ENDTRY
			RETURN lcShFile
		ELSE
			RETURN lcShFile
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE GetSheetRecord		&& Positions the record in xl_sheets; returns true if record found, or false if not found
		LPARAMETERS tnWB, tnSheet
		RETURN SEEK(BINTOC(tnWB)+BINTOC(tnSheet), "xl_sheets", "sheetndx")
	ENDPROC

	PROCEDURE GetSheetRowValues		&& Returns the cell values for the given row
		LPARAMETERS tnWB, tnSheet, tnCellRow
		LOCAL lnMaxCol, loRow
		IF PCOUNT() < 3
			RETURN .NULL.
		ENDIF
		lnMaxCol = this.GetMaxColumnNumber(tnWB, tnSheet)
		IF !ISNULL(lnMaxCol) .AND. lnMaxCol > 0
			loRow = CREATEOBJECT("Empty")
			ADDPROPERTY(loRow, "Values[lnMaxCol, 2]", "")
			ADDPROPERTY(loRow, "Count", lnMaxCol)
			loRow.Values = .NULL.
			SELECT tmp.cellcol FROM xl_cells AS tmp ;
				WHERE workbook = tnWB ;
					AND tmp.sheet = tnSheet ;
					AND tmp.cellrow = tnCellRow ;
					AND tmp.celldeleted = False ;
				INTO CURSOR t_temp
		
			SELECT t_temp
			SCAN
				loRow.Values[t_temp.cellcol, 1] = this.GetCellValue(tnWB, tnSheet, tnCellRow, t_temp.cellcol)
				loRow.Values[t_temp.cellcol, 2] = this.GetCellDataType(tnWB, tnSheet, tnCellRow, t_temp.cellcol)
			ENDSCAN
			USE IN t_temp
		ELSE
			loRow = .NULL.
		ENDIF
		RETURN loRow
	ENDPROC

	PROCEDURE GetSheetScale		&& Gets the sheet printing scale
		LPARAMETERS tnWB, tnSheet
		LOCAL lxReturn
		IF PCOUNT() = 2 .AND. this.GetSheetRecord(tnWB, tnSheet)
			lxReturn = xl_sheets.scale
		ELSE
			lxReturn = -1
		ENDIF
		RETURN lxReturn
	ENDPROC

	PROCEDURE GetValidation		&& Returns the validation definition
		LPARAMETERS tnValidNdx
		LOCAL loValiation
		loValiation = CREATEOBJECT("Empty")
		ADDPROPERTY(loValiation, "Type", 0)
		ADDPROPERTY(loValiation, "Style", 0)
		ADDPROPERTY(loValiation, "Operator", 0)
		ADDPROPERTY(loValiation, "AllowBlank", False)
		ADDPROPERTY(loValiation, "ShowInputMsg", False)
		ADDPROPERTY(loValiation, "ShowErrMsg", False)
		ADDPROPERTY(loValiation, "ErrMsg", "")
		ADDPROPERTY(loValiation, "ErrTitle", "")
		ADDPROPERTY(loValiation, "Prompt", "")
		ADDPROPERTY(loValiation, "Formula1", "")
		ADDPROPERTY(loValiation, "Formula2", "")
		IF PCOUNT() < 1
			RETURN loValiation
		ENDIF
		IF SEEK(BINTOC(tnValidNdx), "xl_validation", "validndx")
			loValiation.Type         = xl_validation.vtype
			loValiation.Style        = xl_validation.vstyle
			loValiation.Operator     = xl_validation.voperator
			loValiation.AllowBlank   = xl_validation.allowblank
			loValiation.ShowInputMsg = xl_validation.showinpmsg
			loValiation.ShowErrMsg   = xl_validation.showerrmsg
			loValiation.ErrMsg       = xl_validation.errmsg
			loValiation.ErrTitle     = xl_validation.errtitle
			loValiation.Prompt       = xl_validation.vprompt
			loValiation.Formula1     = IIF(xl_validation.formula, "=", "") + ALLTRIM(xl_validation.formula1)
			loValiation.Formula2     = IIF(EMPTY(xl_validation.formula2), "", IIF(xl_validation.formula, "=", "") + ALLTRIM(xl_validation.formula2))
		ENDIF
		RETURN loValiation
	ENDPROC

	PROCEDURE GetValidationList		&& Returns a list of validations for the workbook/sheet
		LPARAMETERS tnWB, tnSheet
		LOCAL loValiation, lcAlias
		lcAlias = ALIAS()
		loValiation = CREATEOBJECT("Empty")
		ADDPROPERTY(loValiation, "List[1]")
		ADDPROPERTY(loValiation, "Count", 0)
		SELECT xl_validation
		SCAN FOR BINTOC(workbook)+BINTOC(sheet)
			loValiation.Count = loValiation.Count + 1
			DIMENSION loValiation.List[loValiation.Count, 2]
			loValiation.List[loValiation.Count, 1] = xl_validation.vtype
			loValiation.List[loValiation.Count, 2] = xl_validation.validndx
		ENDSCAN
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN loValiation
	ENDPROC

	PROCEDURE GetWorkbook		&& Gets the workbook Id from the name
		LPARAMETERS tcName
		LOCAL lcWBName, lnWBIndex
		lcWBName = JUSTSTEM(tcName)
		IF SEEK(PADL(UPPER(lcWBName), 200, " "), "xl_workbooks", "wbname")
			lnWBIndex = xl_workbooks.workbook
		ELSE
			lnWBIndex = 0
		ENDIF
		RETURN lnWBIndex
	ENDPROC

	PROCEDURE GetWorkbookFileName		&& Gets the file name for the workbook index
		LPARAMETERS tnWB
		LOCAL lcFileName
		IF SEEK(BINTOC(tnWB), "xl_workbooks", "workbook")
			lcFileName = ADDBS(ALLTRIM(xl_workbooks.filepath)) + ALLTRIM(xl_workbooks.wbname)
			lcFileName = FORCEEXT(lcFileName, "xlsx")
		ELSE
			lcFileName = ""
		ENDIF
	ENDPROC

	PROCEDURE GetWorkbookSheets		&& Returns the workbook sheets
		LPARAMETERS tnWB
		LOCAL loSheets
		loSheets = CREATEOBJECT("Empty")
		ADDPROPERTY(loSheets, "List[1, 2]")
		ADDPROPERTY(loSheets, "Count", 0)
		SELECT xl_sheets
		SET ORDER TO TAG sheet
		SCAN FOR workbook = tnWB .AND. !shdeleted
			loSheets.Count = loSheets.Count + 1
			DIMENSION loSheets.List[loSheets.Count, 2]
			loSheets.List[loSheets.Count, 1] = xl_sheets.sheet
			loSheets.List[loSheets.Count, 2] = ALLTRIM(xl_sheets.shname)
		ENDSCAN
		SET ORDER TO
		RETURN loSheets
	ENDPROC

	PROTECTED PROCEDURE GetXMLHeaderFooterText		&& Returns a XML formatted string for the header and footer text
		LOCAL lcText
		IF EMPTY(xl_hdrfootertext.fontname)
			lcText = '"-,'
		ELSE
			lcText = '"' + ALLTRIM(xl_hdrfootertext.fontname) + ','
		ENDIF
		DO CASE
			CASE xl_hdrfootertext.fontstyle = HEADERFOOTER_FONT_STYLE_BOLD
				lcText = lcText + 'Bold"'
		
			CASE xl_hdrfootertext.fontstyle = HEADERFOOTER_FONT_STYLE_ITALIC
				lcText = lcText + 'Italic"'
		
			CASE xl_hdrfootertext.fontstyle = HEADERFOOTER_FONT_STYLE_BOLDITALIC
				lcText = lcText + 'Bold Italic"'
		
			OTHERWISE
				lcText = lcText + 'Regular"'
		ENDCASE
		IF xl_hdrfootertext.fontsize > 0
			lcText = lcText + '&amp;' + TRANSFORM(xl_hdrfootertext.fontsize)
		ENDIF
		IF xl_hdrfootertext.fontcolor > 0
			lcText = lcText + '&amp;K' + this.ConvertColorToHex(xl_hdrfootertext.fontcolor)
		ENDIF
		lcText = lcText + ALLTRIM(xl_hdrfootertext.text)
		RETURN lcText
	ENDPROC

	PROTECTED PROCEDURE GetXMLString		&& Gets the string as an XML formatted string
		LPARAMETERS tcString
		LOCAL lcString, lcXMLString, lnNdx, lcChar
		IF LEFT(tcString, 1) != " " .AND. EMPTY(tcString)
			RETURN ""
		ENDIF
		lcString = STRTRAN(tcString, CHR(38), '&amp;')
		lcString = STRTRAN(lcString, '>', '&gt;')
		lcString = STRTRAN(lcString, '<', '&lt;')
		lcString = STRTRAN(lcString, '"', '&quot;')
		
		IF this.CodePage = 0
			lcXMLString = ""
			FOR lnNdx=1 TO LEN(lcString)
				lcChar = SUBSTR(lcString, lnNdx, 1)
				lnChar = ASC(lcChar)
				lcXMLString = lcXMLString + IIF(lnChar < 128, lcChar, "&#" + TRANSFORM(lnChar) + ";")
			ENDFOR
		ELSE
			lcXMLString = lcString
		ENDIF
		RETURN lcXMLString
	ENDPROC

	PROTECTED PROCEDURE Init
		LPARAMETERS tnCodePage
		IF PCOUNT() > 0 .AND. VARTYPE(tnCodePage) = "N"
			this.CodePage = tnCodePage
		ENDIF
		this.CreateWorkingCursors()
		IF this.DeclareWinAPI
			this.DeclareDLL()
		ENDIF
		this.OnInit()
	ENDPROC

	PROCEDURE IsCellFormula		&& Returns True if cell contains a formula
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol
		LOCAL llFormula
		IF PCOUNT() < 4
			RETURN .NULL.
		ENDIF
		llFormula = False
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			llFormula = !EMPTY(xl_cells.cellformula)
		ENDIF
		RETURN llFormula
	ENDPROC

	PROTECTED PROCEDURE IsValidBorderStyle		&& Validates the border style value
		LPARAMETERS tcStyle
		IF VARTYPE(tcStyle) != 'C' .OR. EMPTY(tcStyle) .OR. !INLIST(tcStyle, BORDER_STYLE_THIN, BORDER_STYLE_HAIR, BORDER_STYLE_DOTTED, BORDER_STYLE_DASHDOTDOT, ;
																			 BORDER_STYLE_DASHDOT, BORDER_STYLE_DASHED, BORDER_STYLE_THIN, BORDER_STYLE_MEDIUMDASHDOTDOT, ;
																			 BORDER_STYLE_SLANTDASHDOT, BORDER_STYLE_MEDIUMDASHDOT, BORDER_STYLE_MEDIUMDASHED, ;
																			 BORDER_STYLE_MEDIUM, BORDER_STYLE_THICK, BORDER_STYLE_DOUBLE)
			RETURN False
		ENDIF
		RETURN True
	ENDPROC

	PROCEDURE MergeCells		&& Merges cells together
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol
		LOCAL lnRow, lnCol, lcCellValue, lnStringIndex, lcDataType, lcCellFormula, llReturn
		IF PCOUNT() < 6
			RETURN False
		ENDIF
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF SEEK(BINTOC(tnWB)+BINTOC(tnSheet)+BINTOC(tnBegRow)+BINTOC(tnBegCol), "xl_mergecells", "mergecell")
				REPLACE xl_mergecells.endrow WITH tnEndRow, ;
						xl_mergecells.endcol WITH tnEndCol IN xl_mergecells
			ELSE
		*-*		Check if a cell being merged is already in a merge group
				SELECT xl_mergecells
				LOCATE FOR workbook = tnWB .AND. sheet = tnSheet .AND. BETWEEN(tnBegRow, begrow, endrow) .AND. BETWEEN(tnBegCol, begcol, endcol) .AND. !DELETED()
				IF FOUND()
					llReturn = False
				ELSE
					LOCATE FOR workbook = tnWB .AND. sheet = tnSheet .AND. BETWEEN(tnEndRow, begrow, endrow) .AND. BETWEEN(tnEndCol, begcol, endcol) .AND. !DELETED()
					IF FOUND()
						llReturn = False
					ELSE
		*-*				Add merged cells
						INSERT INTO xl_mergecells (workbook, sheet, begrow, begcol, endrow, endcol) ;
							VALUES (tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol)
		*-*				Get upper left most cell value -> will be value of the merged cells (clear all other cell values)
						SELECT xl_cells
						lcCellValue = .NULL.
						FOR lnRow=tnBegRow TO tnEndRow
							FOR lnCol=tnBegCol TO tnEndCol
								IF this.GetCellRecord(tnWB, tnSheet, lnRow, lnCol) .AND. !EMPTY(xl_cells.cellvalue)
									IF ISNULL(lcCellValue) .AND. !xl_cells.celldeleted
										lcDataType    = xl_cells.datatype
										lcCellValue   = xl_cells.cellvalue
										lcCellFormula = xl_cells.cellformula
										lnStringIndex = xl_cells.stringid
									ENDIF
									REPLACE xl_cells.cellvalue   WITH "", ;
											xl_cells.cellformula WITH "", ;
											xl_cells.stringid    WITH 0, ;
											xl_cells.datatype    WITH "" IN xl_cells
								ENDIF
							ENDFOR
						ENDFOR
						IF !ISNULL(lcCellValue)
							IF this.GetCellRecord(tnWB, tnSheet, tnBegRow, tnBegCol)
								REPLACE xl_cells.cellvalue   WITH lcCellValue, ;
										xl_cells.cellformula WITH lcCellFormula, ;
										xl_cells.stringid    WITH lnStringIndex, ;
										xl_cells.datatype    WITH lcDataType, ;
										xl_cells.celldeleted WITH False IN xl_cells
							ENDIF
						ENDIF
		*-*				If the tnEndCol cell is not a cell already in the row then add the cell to the cursor for the max cells by row determination
						SELECT xl_cells
						FOR lnRow=tnBegRow TO tnEndRow
							LOCATE FOR workbook = tnWB .AND. sheet = tnSheet .AND. cellrow = lnRow .AND. cellcol >= tnEndCol .AND. !DELETED()
							IF !FOUND()
								INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, numdec, celldeleted) ;
									VALUES (tnWB, tnSheet, lnRow, tnEndCol, DATA_TYPE_NONE, 0, -1, False)
							ENDIF
						ENDFOR
						llReturn = True
					ENDIF
				ENDIF
			ENDIF
		ELSE
			llReturn = False
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE OnDestroy		&& Called by the Destroy() event - user implementation
		*-*
		*-*	TODO: Add your code here
		*-*
	ENDPROC

	PROCEDURE OnInit		&& User code for Init() Event
		*-*
		*-*	TODO: Add your code here
		*-*
	ENDPROC

	PROCEDURE OpenCreatedXlsxFile		&& Opens the XLSX file via Win32 API default program
		LPARAMETERS txWB
		LOCAL lcFileName
		DO CASE
			CASE PCOUNT() = 0
				RETURN False
			
			CASE VARTYPE(txWB) = "N"
				lcFileName = this.GetWorkbookFileName(txWB)
				IF EMPTY(lcFileName) .OR. !FILE(lcFileName)
					RETURN False
				ENDIF
		
			CASE VARTYPE(txWB) = "C"
				IF FILE(txWB)
					lcFileName = txWB
				ELSE
					RETURN False
				ENDIF
		
			OTHERWISE
				RETURN False
		ENDCASE
		TRY
			apiShellExecute(0, "Open", lcFileName, "", "", 5)
		
		CATCH TO loException
			MESSAGEBOX("Failure to open file: " + loException.Message)
		ENDTRY
	ENDPROC

	PROCEDURE OpenXlsxWorkbook		&& Opens the passed Xlsx workbook and loads the internal cursors with the content
		LPARAMETERS tcFileName, tlForceTextFormat
		LOCAL lnWB, lcBaseName, lcTempPath, lcZipName, loShell, lnCnt, lnCntTot, loException, loXDOM, lcFileName
		LOCAL loShNodes, lnShNode, loSheet, lcShName, loFS, loDir, lcShRId, lcShFile
		LOCAL ARRAY laTemp[1]
		DO CASE
			CASE PCOUNT() = 0
				MESSAGEBOX("Invalid call to OpenXlsxWorkbook() method; must include file name to open")
		
			CASE PCOUNT() = 1
				tlForceTextFormat = False
		ENDCASE
		lnWB = 0
		IF ADIR(laTemp, tcFileName) > 0
		*-*	Open the Workbook as an archive (zip) file and extract contents
			TRY
				lcBaseName = SYS(2015)
				lcTempPath = ADDBS(SYS(2023)) + lcBaseName
				lcZipName  = lcTempPath + ".zip"
				COPY FILE (tcFileName) TO (lcZipName)
				loShell = CREATEOBJECT("shell.application")
				MKDIR (lcTempPath)
				loShell.NameSpace(lcTempPath).CopyHere(loShell.NameSpace(lcZipName).Items, FOF_SILENT)
				lnCnt = 0
				lnCntTot = loShell.NameSpace(lcZipName).Items.Count
				DO WHILE loShell.NameSpace(lcTempPath).Items.Count != lnCntTot
					lnCnt = lnCnt + 1
					apiSleep(100)
					IF lnCnt > lnCntTot
						SET STEP ON
					ENDIF
				ENDDO
				ERASE (lcZipName)
		
			CATCH TO loException
				SET STEP ON
				MESSAGEBOX(loException.Message)
				lnWB = .NULL.
			ENDTRY
			IF ISNULL(lnWB)
				RETURN 0
			ENDIF
		*-*	Add to the workbook table
			lnWB = this.CreateWorkbookEx(tcFileName)
			IF lnWB > 0
				TRY
		*-*			Read the shared strings XML
					this.ReadSharedStringsXML(lcTempPath, lnWB)
		*-*			Read the styles XML
					this.ReadStylesXML(lcTempPath, lnWB)
		*-*			Open the workbook XML and then each of the worksheets
					lcFileName = ADDBS(lcTempPath) + "xl\workbook.xml"
					IF ADIR(laTemp, lcFileName) > 0
						loXDOM = CREATEOBJECT('MSXML2.DOMDocument')
						loXDOM.Load(lcFileName)
						loShNodes = loXDOM.getElementsByTagName("sheet")
						FOR lnShNode=0 TO loShNodes.Length-1
							loSheet  = loShNodes.Item(lnShNode)
							lcShName = NVL(loSheet.getAttribute("name"), "")
							lcShRId  = NVL(loSheet.getAttribute("r:id"), "")
							lcShFile = this.GetSheetNameXML(loXDOM, lcTempPath, lcShRId)
		*-*					Read the worksheet
							IF !this.ReadSheetXML(lcTempPath, lcShFile, lnWB, lnShNode+1, lcShName, tlForceTextFormat)
								MESSAGEBOX("Invalid XLSX file - missing sheet or invalid sheet: " + lcShFile)
								this.DeleteWorkbook(lnWB)
								lnWB = 0
								EXIT
							ENDIF
						ENDFOR
					ELSE
						MESSAGEBOX("Invalid XLSX file - missing workbook.xml")
						this.DeleteWorkbook(lnWB)
						lnWB = 0
					ENDIF
		
				CATCH TO loException
					SET STEP ON
					MESSAGEBOX("Invalid XLSX file - error reading data; " + loException.Message)
					this.DeleteWorkbook(lnWB)
					lnWB = 0
		
				FINALLY
					TRY
						loFS = CREATEOBJECT("Scripting.FileSystemObject")
						loDir = loFS.GetFolder(lcTempPath)
						loDir.Delete()
		
					CATCH TO loException
						SET STEP ON
					ENDTRY
				ENDTRY
				IF this.Debug
					this.DebugCursorsToFile("Extract")
				ENDIF
			ENDIF
		ENDIF
		RETURN lnWB
	ENDPROC

	PROCEDURE ParseString		&& Parses a string based on a specified delimiter
		LPARAMETERS tcText, tnPos, tcDelimiter
		LOCAL lcWord, lnCnt, lnBeg, lnEnd
		lnCnt = OCCURS(tcDelimiter, tcText) + 1
		IF tnPos <= lnCnt
			DO CASE
				CASE lnCnt = 0
					lcWord = tcText
		
				CASE tnPos = 1
					lcWord = LEFT(tcText, ATC(tcDelimiter, tcText)-1)
		
				CASE tnPos = lnCnt
					lcWord = SUBSTR(tcText, RATC(tcDelimiter, tcText)+1)
		
				OTHERWISE
					lnBeg = ATC(tcDelimiter, tcText, tnPos-1) + 1
					lnEnd = ATC(tcDelimiter, tcText, tnPos)
					lcWord = SUBSTR(tcText, lnBeg, lnEnd-lnBeg)
			ENDCASE
			RETURN lcWord
		ELSE
			RETURN ""
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE ReadCellValueFormat		&& Reads the cell value and format for a sheet
		LPARAMETERS tnWB, tcColumn, tnCellCol
		LOCAL lcCellType, lnNode, lcBaseName, lcFormatCode, lnNdx, loCellFormat, lcWholeNbr, lcDecNbr
		LOCAL lcPosFormat, lcNegFormat, lcZerFormat
		loCellFormat = CREATEOBJECT("Empty")
		ADDPROPERTY(loCellFormat, "CellVal", "")
		ADDPROPERTY(loCellFormat, "DataType", DATA_TYPE_NONE)
		ADDPROPERTY(loCellFormat, "Formula", "")
		ADDPROPERTY(loCellFormat, "StringNdx", 0)
		ADDPROPERTY(loCellFormat, "CellXfsId", 0)
		
		lcCellType = this.GetNodeAttributeValue(tcColumn, "t")
		FOR lnChild=1 TO this.GetChildNodeCount(tcColumn)
			lcChild = this.GetChildNodeElement(tcColumn, lnChild)
			DO CASE
				CASE lcChild = "<f"                                   && Formula attribute - cell contains a formula
					lcCellType = "f"
					loCellFormat.Formula = this.GetCellFormulaFromXML(lcChild, tnCellCol)
		
				CASE lcChild = "<v"                                   && Value assigned to cell
					loCellFormat.CellVal = this.GetNodeElementValue(lcChild)
			ENDCASE
		ENDFOR
		
		loCellFormat.CellXfsId = CAST(this.GetNodeAttributeValue(tcColumn, "s") AS I)
		DO CASE
			CASE lcCellType == "f"
				loCellFormat.DataType = DATA_TYPE_FORMULA
		
			CASE lcCellType == "s" .OR. lcCellType == "str"
				loCellFormat.StringNdx = CAST(loCellFormat.CellVal AS I)
				loCellFormat.CellVal   = "StringValue"
				loCellFormat.DataType  = DATA_TYPE_CHAR
		
			OTHERWISE
		*-*		Determine the data type of the value based on assigned format
				IF SEEK(BINTOC(tnWB)+BINTOC(loCellFormat.CellXfsId), "xl_cellxfs", "id")
					DO CASE
						CASE INLIST(xl_cellxfs.numFmtId, 1, 3, 37, 38)                           && Integer format
							loCellFormat.DataType = DATA_TYPE_INT
							
						CASE INLIST(xl_cellxfs.numFmtId, 2, 4, 7, 8, 11, 12, 13, 39, 40)         && Float format
							loCellFormat.DataType = DATA_TYPE_FLOAT
					
						CASE INLIST(xl_cellxfs.numFmtId, 9, 10)                                  && Numeric percent format
							loCellFormat.DataType = DATA_TYPE_FLOAT
			
						CASE INLIST(xl_cellxfs.numFmtId, 14, 15, 16, 17)                         && Date format
							DO CASE
								CASE ATC(".", loCellFormat.CellVal) = 0 .OR. RIGHT(loCellFormat.CellVal, 1) = "."
									loCellFormat.DataType = DATA_TYPE_DATE
								
								CASE ATC(".", loCellFormat.CellVal) > 0
									lnNdx = ATC(".", loCellFormat.CellVal)
									lcWholeNbr = LEFT(loCellFormat.CellVal, lnNdx-1)
									lcDecNbr   = SUBSTR(loCellFormat.CellVal, lnNdx+1)
									IF LEN(lcDecNbr) > 0
										loCellFormat.CellVal  = lcWholeNbr + "." + PADR(lcDecNbr, 17, "0")
										loCellFormat.DataType = DATA_TYPE_DATETIME
									ELSE	
										loCellFormat.CellVal  = lcWholeNbr
										loCellFormat.DataType = DATA_TYPE_DATE
									ENDIF
							ENDCASE
		
						CASE INLIST(xl_cellxfs.numFmtId, 18, 19, 20, 21, 45, 46)                 && Time format
							DO CASE
								CASE ATC("E-", loCellFormat.CellVal) > 0
									loCellFormat.CellVal  = PADR(TRANSFORM(EVAL(loCellFormat.CellVal)), 19, "0")
									loCellFormat.DataType = DATA_TYPE_TIME
		
								CASE ATC("E", loCellFormat.CellVal) > 0
									loCellFormat.CellVal = TRANSFORM(EVAL(loCellFormat.CellVal))
									lnNdx = ATC(".", loCellFormat.CellVal)
									lcWholeNbr = LEFT(loCellFormat.CellVal, lnNdx-1)
									lcDecNbr   = SUBSTR(loCellFormat.CellVal, lnNdx+1)
									loCellFormat.CellVal  = lcWholeNbr + "." + PADR(lcDecNbr, 17, "0")
									loCellFormat.DataType = DATA_TYPE_DATETIME
		
								CASE LEFT(loCellFormat.CellVal, 2) = "0."
									lcDecNbr = SUBSTR(loCellFormat.CellVal, 3)
									loCellFormat.CellVal  = "0." + PADR(lcDecNbr, 17, "0")
									loCellFormat.DataType = DATA_TYPE_TIME
		
								OTHERWISE
									lnNdx = ATC(".", loCellFormat.CellVal)
									lcWholeNbr = LEFT(loCellFormat.CellVal, lnNdx-1)
									lcDecNbr   = SUBSTR(loCellFormat.CellVal, lnNdx+1)
									loCellFormat.CellVal  = lcWholeNbr + "." + PADR(lcDecNbr, 17, "0")
									loCellFormat.DataType = DATA_TYPE_DATETIME
							ENDCASE
		
						CASE INLIST(xl_cellxfs.numFmtId, 22, 29, 30, 31, 32, 33, 34)             && Date-time format
							lnNdx = ATC(".", loCellFormat.CellVal)
							lcWholeNbr = LEFT(loCellFormat.CellVal, lnNdx-1)
							lcDecNbr   = SUBSTR(loCellFormat.CellVal, lnNdx+1)
							loCellFormat.CellVal  = lcWholeNbr + "." + PADR(lcDecNbr, 17, "0")
							loCellFormat.DataType = DATA_TYPE_DATETIME
		
						CASE SEEK(BINTOC(tnWB)+BINTOC(xl_cellxfs.numFmtId), "xl_numfmts", "id")  && Determine based on custom format
							lcFormatCode = ALLTRIM(xl_numfmts.code)
							DO CASE
								CASE ATC("h:m", lcFormatCode) > 0 .OR. ATC("m:s", lcFormatCode) > 0 .OR. ATC("AM/PM", lcFormatCode) > 0 .OR. ATC("A/P", lcFormatCode) > 0
									loCellFormat.DataType = DATA_TYPE_DATETIME
			
								CASE ATC("yy", lcFormatCode) > 0 .OR. ATC("d\-m", lcFormatCode) > 0
									loCellFormat.DataType = DATA_TYPE_DATE
			
								OTHERWISE
									lnNdx = ATC(".", lcFormatCode)
									IF lnNdx > 0
										loCellFormat.DataType = DATA_TYPE_FLOAT
										lnNdx = lnNdx + 1
										DO WHILE lnNdx < LEN(lcFormatCode)
											IF SUBSTR(lcFormatCode, lnNdx, 1) != "0"
												EXIT
											ENDIF
											lnNdx = lnNdx + 1
										ENDDO
									ELSE
										loCellFormat.DataType = DATA_TYPE_INT
									ENDIF
							ENDCASE
		
						
						OTHERWISE
							DO CASE
								CASE ISNULL(loCellFormat.CellVal) .OR. EMPTY(loCellFormat.CellVal)
									loCellFormat.DataType = DATA_TYPE_NONE
			
								CASE ATC(".", loCellFormat.CellVal) > 0
									loCellFormat.DataType = DATA_TYPE_FLOAT
			
								OTHERWISE
									loCellFormat.DataType = DATA_TYPE_INT
							ENDCASE
					ENDCASE
				ELSE
					DO CASE
						CASE ISNULL(loCellFormat.CellVal) .OR. EMPTY(loCellFormat.CellVal)
							loCellFormat.CellVal  = ""
							loCellFormat.DataType = DATA_TYPE_NONE
				
						CASE ATC(".", loCellFormat.CellVal) > 0
							loCellFormat.DataType = DATA_TYPE_FLOAT
				
						OTHERWISE
							loCellFormat.DataType = DATA_TYPE_INT
					ENDCASE
				ENDIF
		ENDCASE
		RETURN loCellFormat
	ENDPROC

	PROTECTED PROCEDURE ReadSharedStringsXML		&& Reads the sharedstrings.xml for opening workbooks
		LPARAMETERS tcFilePath, tnWB
		LOCAL lcStrings, lcString, lcFileName, lnNode, lcRichTextRun, lcText, lnIndex, llPrsvSpace, llFBold, llFItalic
		LOCAL lnFColor, lcFName, lnFSize, lcULine, llStrkThr, lcFVPos, lnTheme, lnTint, lnIndexed, lcRunPrp
		LOCAL lnR, lcRText, lcRunProp, lcColor, llPreserveSpace, llFormatted, loException
		LOCAL ARRAY laTemp[1]
		lcFileName = ADDBS(tcFilePath) + "xl\sharedStrings.xml"
		IF ADIR(laTemp, lcFileName) > 0
			TRY
				lnNode    = 1
				lcStrings = FILETOSTR(lcFileName)
				lcString  = this.GetNodeElement(lcStrings, 'si', lnNode)
				DO WHILE !EMPTY(lcString)
					lnR = 1
					lcRichTextRun = this.GetNodeElement(lcString, 'r', lnR, True)
					IF EMPTY(lcRichTextRun)
						lcText  = this.GetNodeElementValue(this.GetNodeElement(lcString, 't', 1))
						llFormatted = False
					ELSE
						llFormatted = True
						lcText  = ""
						lnIndex = 0
						DO WHILE !EMPTY(lcRichTextRun)
							lnIndex   = lnIndex + 1
							lcRText   = this.GetNodeElementValue(this.GetNodeElement(lcRichTextRun, 't', 1))
							lcText    = lcText + lcRText
			
							lcRunProp = this.GetNodeElement(lcRichTextRun, 'rPr', 1, True)
							llFBold   = IIF(ATC("<b/>", lcRunProp)>0, True, False)
							llFItalic = IIF(ATC("<i/>", lcRunProp)>0, True, False)
							llStrkthr = IIF(ATC("<strike/>", lcRunProp)>0, True, False)
							IF ATC("<u/>", lcRunProp) > 0
								lcULine = UNDERLINE_SINGLE
							ELSE
								lcULine = this.GetNodeAttributeValue(this.GetNodeElement(lcRunProp, 'u', 1), "val")
								lcULine = IIF(EMPTY(lcULine), UNDERLINE_NONE, lcULine)
							ENDIF
			
							lnFSize   = CAST(this.GetNodeAttributeValue(this.GetNodeElement(lcRunProp, 'sz', 1), "val") AS I)
							lcFName   = this.GetNodeAttributeValue(this.GetNodeElement(lcRunProp, 'rFont', 1), "val")
							lcFVPos   = this.GetNodeAttributeValue(this.GetNodeElement(lcRunProp, 'vertAlign', 1), "val")
			
							lcColor   = this.GetNodeElement(lcRunProp, 'color', 1)
							lnFColor  = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
							lnTheme   = CAST(this.GetNodeAttributeValue(lcColor, "theme") AS I)
							lnTint    = CAST(this.GetNodeAttributeValue(lcColor, "tint") AS I)
							lnIndexed = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
			
							INSERT INTO xl_strformat (workbook, id, index, stringvalue, string, fbold, fitalic, fcolor, fname, fsize, uline, strkthr, fvpos, theme, tint, indexed) ;
								VALUES (tnWB, lnNode-1, lnIndex, this.GetXMLString(lcRText), lcRText, llFBold, llFItalic, lnFColor, lcFName, lnFSize, lcULine, llStrkThr, ;
										lcFVPos, lnTheme, lnTint, lnIndexed)
			
							lnR = lnR + 1
							lcRichTextRun = this.GetNodeElement(lcString, 'r', lnR, True)
						ENDDO
					ENDIF
					llPreserveSpace = IIF(LEFT(lcText, 1) = " ", True, False)
					INSERT INTO xl_strings (id, workbook, stringvalue, string, presvspace, formatted) VALUES (lnNode-1, tnWB, this.GetXMLString(lcText), lcText, llPreserveSpace, llFormatted)
			
					lnNode = lnNode + 1
					lcString  = this.GetNodeElement(lcStrings, 'si', lnNode)
				ENDDO
		
			CATCH TO loException
				SET STEP ON
			ENDTRY
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE ReadSheetXML		&& Reads the sheet.xml for opening a workbook
		LPARAMETERS tcFilePath, tcShFile, tnWB, tnSheet, tcShName, tlForceTextFormat
		LOCAL lcFileName, lcSheet, lcSheetViews, lcSheetView, lcPane, lcMargin, lnXSplit, lnYSplit, lnLeft, lcDimen, lnScale, lnFitToWidth, lnFitToHeight
		LOCAL lnRight, lnTop, lnBottom, lnHeader, lnFooter, lcPageSetup, lnOrientation, lnPaperSize, lnWidth, lnHeight, lnNode, lcMergeCells
		LOCAL lnCnt, lcMergeCell, lcCellRef, lnBegCol, lnBegRow, lnEndCol, lnEndRow, lcTemp, lnNdx, lcSheetData
		LOCAL lcRow, lnRowHt, lnCellRow, lnCellCol, lnCol, loCell
		LOCAL ARRAY laTemp[1]
		lcFileName = ADDBS(tcFilePath) + "xl\" + tcShFile
		IF ADIR(laTemp, lcFileName) > 0
			lcSheet = FILETOSTR(lcFileName)
		
		*-*	Get the freeze rows/columns settings
			lcSheetViews = this.GetNodeElement(lcSheet, 'sheetViews', 1, True)
			lcSheetView  = this.GetNodeElement(lcSheetViews, 'sheetView', 1)
			lcPane       = this.GetNodeElement(lcSheetView, 'pane', 1)
			lnXSplit     = CAST(this.GetNodeAttributeValue(lcPane, "xSplit") AS I)
			lnYSplit     = CAST(this.GetNodeAttributeValue(lcPane, "ySplit") AS I)
		
		*-*	Get the worksheet margins
			lcMargin = this.GetNodeElement(lcSheet, 'pageMargins', 1)
			lnLeft   = CAST(this.GetNodeAttributeValue(lcMargin, "left") AS N(6,3))
			lnLeft   = IIF(lnLeft = 0.000, 0.75, lnLeft)
			lnRight  = CAST(this.GetNodeAttributeValue(lcMargin, "right") AS N(6,3))
			lnRight  = IIF(lnRight = 0.000, 0.75, lnRight)
			lnTop    = CAST(this.GetNodeAttributeValue(lcMargin, "top") AS N(6,3))
			lnTop    = IIF(lnTop = 0.000, 0.75, lnTop)
			lnBottom = CAST(this.GetNodeAttributeValue(lcMargin, "bottom") AS N(6,3))
			lnBottom = IIF(lnBottom = 0.000, 0.75, lnBottom)
			lnFooter = CAST(this.GetNodeAttributeValue(lcMargin, "footer") AS N(6,3))
			lnFooter = IIF(lnFooter = 0.000, 0.30, lnFooter)
			lnHeader = CAST(this.GetNodeAttributeValue(lcMargin, "header") AS N(6,3))
			lnHeader = IIF(lnHeader = 0.000, 0.30, lnHeader)
		
		*-*	Get the page setup
			lcPageSetup   = this.GetNodeElement(lcSheet, 'pageMargins', 1)
			lnOrientation = IIF(this.GetNodeAttributeValue(lcPageSetup, "orientation")='portrait', PORTRAIT_PRINT_ORIENTATION, LANDSCAPE_PRINT_ORIENTATION)
			lnPaperSize   = CAST(this.GetNodeAttributeValue(lcPageSetup, "paperSize") AS I)
			lnPaperSize   = IIF(lnPaperSize=0, PAPERSIZE_LTR, lnPaperSize)
			lnWidth       = CAST(this.GetNodeAttributeValue(lcPageSetup, "paperWidth") AS I)
			lnHeight      = CAST(this.GetNodeAttributeValue(lcPageSetup, "paperHeight") AS I)
			lcDimen       = RIGHT(this.GetNodeAttributeValue(lcPageSetup, "paperHeight"), 2)
			lnScale       = CAST(this.GetNodeAttributeValue(lcPageSetup, "scale") AS I)
			lnScale       = IIF(lnScale=0, 100, lnScale)
			lnFitToWidth  = CAST(this.GetNodeAttributeValue(lcPageSetup, "fitToWidth") AS I)
			lnFitToHeight = CAST(this.GetNodeAttributeValue(lcPageSetup, "fitToHeight") AS I)
		
		*-*	Save the worksheet to the cursor
			INSERT INTO xl_sheets (workbook, sheet, shname, mleft, mright, mtop, mbot, mheader, mfooter, shdeleted, xsplit, ysplit, prnorient, ;
								   papersize, paperwidth, paperheight, paperdimen, scale, fittowidth, fittoheight) ;
				VALUES (tnWB, tnSheet, tcShName, lnLeft, lnRight, lnTop, lnBottom, lnHeader, lnFooter, False, lnXSplit, lnYSplit, lnOrientation, ;
						lnPaperSize, lnWidth, lnHeight, lcDimen, lnScale, lnFitToWidth, lnFitToHeight)
			REPLACE xl_workbooks.sheetcnt WITH xl_workbooks.sheetcnt + 1 FOR workbook = tnWB IN xl_workbooks
		
		*-*	Get the defined column widths
			lcCols = this.GetNodeElement(lcSheet, 'cols', 1, True)
			lnNode = 1
			lcCol  = this.GetNodeElement(lcCols, 'col', lnNode)
			DO WHILE !EMPTY(lcCol)
				lnMinCol = CAST(this.GetNodeAttributeValue(lcCol, "min") AS I)
				lnMaxCol = CAST(this.GetNodeAttributeValue(lcCol, "max") AS I)
				lnWidth  = CAST(this.GetNodeAttributeValue(lcCol, "width") AS N(16,9)) - 0.71093750
				FOR lnCol=lnMinCol TO lnMaxCol
					INSERT INTO xl_colwidths (workbook, sheet, column, width) VALUES (tnWB, tnSheet, lnCol, lnWidth)
				ENDFOR
				lnNode = lnNode + 1
				lcCol  = this.GetNodeElement(lcCols, 'col', lnNode)
			ENDDO
		
		*-*	Get the defined merged cells
			lcMergeCells = this.GetNodeElement(lcSheet, 'mergeCells', 1)
			lnCnt = CAST(this.GetNodeAttributeValue(lcMergeCells, "count") AS I)
			FOR lnNode=1 TO lnCnt
				lcMergeCell = this.GetNodeElement(lcMergeCells, 'mergeCell', lnNode)
				IF EMPTY(lcMergeCell)
					SET STEP ON
					LOOP
				ENDIF
				lcCellRef = this.GetNodeAttributeValue(lcMergeCell, "ref")
				lnBegCol = 0
				lnBegRow = 0
				lnEndCol = 0
				lnEndRow = 0
				lcTemp = GETWORDNUM(lcCellRef, 1, ":")
				lnNdx = 0
				DO WHILE lnNdx < LEN(lcTemp)
					lnNdx = lnNdx + 1
					IF ISDIGIT(SUBSTR(lcTemp, lnNdx, 1))
						lnBegCol = this.ColumnAsciiToIndex(LEFT(lcTemp, lnNdx-1))
						lnBegRow = INT(VAL(SUBSTR(lcTemp, lnNdx)))
						EXIT
					ENDIF
				ENDDO
				IF lnBegCol > 0
					lcTemp = GETWORDNUM(lcCellRef, 2, ":")
					lnNdx = 0
					DO WHILE lnNdx < LEN(lcTemp)
						lnNdx = lnNdx + 1
						IF ISDIGIT(SUBSTR(lcTemp, lnNdx, 1))
							lnEndCol = this.ColumnAsciiToIndex(LEFT(lcTemp, lnNdx-1))
							lnEndRow = INT(VAL(SUBSTR(lcTemp, lnNdx)))
							EXIT
						ENDIF
					ENDDO
					IF lnEndCol > 0
						INSERT INTO xl_mergecells (workbook, sheet, begrow, begcol, endrow, endcol) ;
							VALUES (tnWB, tnSheet, lnBegRow, lnBegCol, lnEndRow, lnEndCol)
					ENDIF
				ENDIF
			ENDFOR
		
		*-*	Get the sheet cell values and formatting
			lcSheetData = this.GetNodeElement(lcSheet, 'sheetData', 1, True)
			lnNode = 1
			lcRow = this.GetNodeElement(lcSheetData, 'row', lnNode)
			DO WHILE !EMPTY(lcRow)                                                   && Process each row in the sheet
				lnCellRow = CAST(this.GetNodeAttributeValue(lcRow, "r") AS I)
				lnRowHt = CAST(this.GetNodeAttributeValue(lcRow, "ht") AS N(14,7))
				IF lnRowHt > 0.00 &&.AND. this.GetNodeAttributeValue(lcRow, "customHeight") = "1"
					INSERT INTO xl_rowheights (workbook, sheet, row, height) VALUES (tnWB, tnSheet, lnCellRow, lnRowHt)
				ENDIF
		
				lnCol = 1
				lcColumn = this.GetNodeElement(lcRow, 'c', lnCol)
				DO WHILE !EMPTY(lcColumn)                                            && Process each column in a row
					lnCellCol = this.ColumnAsciiToIndex(this.GetNodeAttributeValue(lcColumn, "r"))
					loCell    = this.ReadCellValueFormat(tnWB, lcColumn, lnCellCol)
					IF tlForceTextFormat .AND. loCell.DataType != DATA_TYPE_CHAR
						loCell.DataType  = DATA_TYPE_CHAR
						loCell.StringNdx = this.AddStringValue(tnWB, TRANSFORM(loCell.CellVal), False)
						loCell.CellVal   = "StringValue"
						loCell.Formula   = ""
					ENDIF
					INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, cellvalue, datatype, cellformula, stringid, cellxfs, celldeleted) ;
						VALUES (tnWB, tnSheet, lnCellRow, lnCellCol, loCell.CellVal, loCell.DataType, loCell.Formula, loCell.StringNdx, loCell.CellXfsId, False)
		
					lnCol = lnCol + 1
					lcColumn = this.GetNodeElement(lcRow, 'c', lnCol)
				ENDDO
				lnNode = lnNode + 1
				lcRow = this.GetNodeElement(lcSheet, 'row', lnNode)
			ENDDO
			RETURN True
		ELSE
			RETURN False
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE ReadStylesXML		&& Reads the styles.xml file for opening a workbook
		LPARAMETERS tcFilePath, tnWB
		LOCAL lcCellXfs, lnCnt, lcXf, lnIndent, lnWrapTx, lcAlign, lcStyleSheet, lcFileName, lnNode, lnNumFmtId, lnFontId, lnFillId, lnBorderId
		LOCAL lcHAlign, lcVAlign, lcNumFmts, lcFonts, lcNumFmt, lcFormatCode, lcFont, lnIndexed, lnFSize, lcFName, llFBold, llFItalic, llStrkthr
		LOCAL lcFVPos, lcULine, lnFColor, lnTheme, lnTint, lcColor, lcFills, lcFill, lcPatternFill, lcPatternType, lnFgColor, lnFgIndexed, lcBorder
		LOCAL lnBgColor, lnBgIndexed, lcBorders, lcBLeft, lcLStyle, lnLColor, lnLTheme, lnLTint, lnLIndex, lcBRight, lcRStyle, lnRColor, lnRTheme
		LOCAL lnRTint, lnRIndex, lcBTop, lcTStyle, lnTColor, lnTTheme, lnTTint, lnTIndex, lcBBottm, lcBStyle, lnBColor, lnBTheme, lnBTint, lnBIndex
		LOCAL lnDTint, lnDIndex, lcBDiag, lcDStyle, lnDColor, lnDTheme, lcPosFormat, lcNegFormat, lcZerFormat
		LOCAL lcTxtFormat
		LOCAL ARRAY laTemp[1]
		lcFileName = ADDBS(tcFilePath) + "xl\styles.xml"
		IF ADIR(laTemp, lcFileName) > 0
			lcStyleSheet = FILETOSTR(lcFileName)
		*-*	Retreive the cell format mapping information
			lcCellXfs = this.GetNodeElement(lcStyleSheet, 'cellXfs', 1)
			lnCnt = CAST(this.GetNodeAttributeValue(lcCellXfs, "count") AS I)
			FOR lnNode=1 TO lnCnt
				lcXf = this.GetNodeElement(lcCellXfs, 'xf', lnNode)
				IF EMPTY(lcXf)
					SET STEP ON
					LOOP
				ENDIF
				lnNumFmtId = CAST(this.GetNodeAttributeValue(lcXf, "numFmtId") AS I)
				lnFontId   = CAST(this.GetNodeAttributeValue(lcXf, "fontId") AS I)
				lnFillId   = CAST(this.GetNodeAttributeValue(lcXf, "fillId") AS I)
				lnBorderId = CAST(this.GetNodeAttributeValue(lcXf, "borderId") AS I)
				lcAlign    = this.GetNodeElement(lcXf, 'alignment', 1)
				lcHAlign   = this.GetNodeAttributeValue(lcAlign, "horizontal")
				lcVAlign   = this.GetNodeAttributeValue(lcAlign, "vertical")
				lnIndent   = CAST(this.GetNodeAttributeValue(lcAlign, "indent") AS I)
				lnWrapTx   = CAST(this.GetNodeAttributeValue(lcAlign, "wrapText") AS I)
				lnRotation = CAST(this.GetNodeAttributeValue(lcAlign, "textRotation") AS I)
		
				INSERT INTO xl_cellxfs (workbook, id, numFmtId, fontId, fillId, borderId, halign, valign, indent, wraptext, rotation) ;
					VALUES (tnWB, lnNode-1, lnNumFmtId, lnFontId, lnFillId, lnBorderId, lcHAlign, lcVAlign, lnIndent, lnWrapTx, lnRotation)
			ENDFOR
		
		*-*	Retreive the number format information
			lcNumFmts = this.GetNodeElement(lcStyleSheet, 'numFmts', 1)
			lnCnt = CAST(this.GetNodeAttributeValue(lcNumFmts, "count") AS I)
			FOR lnNode=1 TO lnCnt
				lcNumFmt = this.GetNodeElement(lcNumFmts, 'numFmt', lnNode)
				IF EMPTY(lcNumFmt)
					SET STEP ON
					LOOP
				ENDIF
				lnNumFmtId   = CAST(this.GetNodeAttributeValue(lcNumFmt, "numFmtId") AS I)
				lcFormatCode = this.GetNodeAttributeValue(lcNumFmt, "formatCode")
		
				lcPosFormat = this.ParseString(lcFormatCode, 1, ";")
				lcNegFormat = this.ParseString(lcFormatCode, 2, ";")
				lcZerFormat = this.ParseString(lcFormatCode, 3, ";")
				lcTxtFormat = this.ParseString(lcFormatCode, 4, ";")
				INSERT INTO xl_numfmts (workbook, id, posformat, negformat, zeroformat, textformat, code, applydec) ;
					VALUES (tnWB, lnNumFmtId, this.GetXMLString(lcPosFormat), this.GetXMLString(lcNegFormat), this.GetXMLString(lcZerFormat), this.GetXMLString(lcTxtFormat), lcFormatCode, False)
			ENDFOR
		
		*-*	Retreive the font informaton
			lcFonts = this.GetNodeElement(lcStyleSheet, 'fonts', 1)
			lnCnt = CAST(this.GetNodeAttributeValue(lcFonts, "count") AS I)
			FOR lnNode=1 TO lnCnt
				lcFont = this.GetNodeElement(lcFonts, 'font', lnNode)
				IF EMPTY(lcFont)
					SET STEP ON
					LOOP
				ENDIF
				lnFSize   = CAST(this.GetNodeAttributeValue(this.GetNodeElement(lcFont, 'sz', 1), "val") AS I)
				lnFSize   = IIF(lnFSize>0, lnFSize, 10)
				lcFName   = this.GetNodeAttributeValue(this.GetNodeElement(lcFont, 'name', 1), "val")
				llFBold   = IIF(ATC("<b/>", lcFont)>0, True, False)
				llFItalic = IIF(ATC("<i/>", lcFont)>0, True, False)
				llStrkthr = IIF(ATC("<strike/>", lcFont)>0, True, False)
				lcFVPos   = this.GetNodeAttributeValue(this.GetNodeElement(lcFont, 'vertAlign', 1), "val")
		
				IF ATC("<u/>", lcFont) > 0
					lcULine = UNDERLINE_SINGLE
				ELSE
					lcULine = this.GetNodeAttributeValue(this.GetNodeElement(lcFont, 'u', 1), "val")
					lcULine = IIF(EMPTY(lcULine), UNDERLINE_NONE, lcULine)
				ENDIF
		
				lcColor   = this.GetNodeElement(lcFont, 'color', 1)
				lnFColor  = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
				lnTheme   = CAST(this.GetNodeAttributeValue(lcColor, "theme") AS I)
				lnTint    = CAST(this.GetNodeAttributeValue(lcColor, "tint") AS I)
				lnIndexed = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
		
				INSERT INTO xl_fonts (workbook, id, fname, fsize, fcolor, fbold, fitalic, uline, strkthr, fvpos, theme, tint, indexed) ;
					VALUES (tnWB, lnNode-1, lcFName, lnFSize, lnFColor, llFBold, llFItalic, lcULine, llStrkthr, lcFVPos, lnTheme, lnTint, lnIndexed)
			ENDFOR
		
		*-*	Retreive the cell fill information
			lcFills = this.GetNodeElement(lcStyleSheet, 'fills', 1)
			lnCnt = CAST(this.GetNodeAttributeValue(lcFills, "count") AS I)
			FOR lnNode=1 TO lnCnt
				lcFill = this.GetNodeElement(lcFills, 'fill', lnNode)
				IF EMPTY(lcFill)
					SET STEP ON
					LOOP
				ENDIF
				lcPatternFill = this.GetNodeElement(lcFill, 'patternFill', 1)
				lcPatternType = this.GetNodeAttributeValue(lcPatternFill, "patternType")
				lcPatternType = IIF(EMPTY(lcPatternType), "none", lcPatternType)
				lnTheme       = CAST(this.GetNodeAttributeValue(lcPatternFill, "theme") AS I)
				
				lcColor = this.GetNodeElement(lcPatternFill, 'fgColor', 1)
				IF EMPTY(lcColor)
					lnFgColor   = 0
					lnFgIndexed = 0
				ELSE
					lnFgColor   = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
					lnFgIndexed = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
				ENDIF
				lcColor = this.GetNodeElement(lcPatternFill, 'bgColor', 1)
				IF EMPTY(lcColor)
					lnBgColor   = 0
					lnBgIndexed = 0
				ELSE
					lnBgColor   = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
					lnBgIndexed = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
				ENDIF
				INSERT INTO xl_fills (workbook, id, patttype, theme, tint, fgcolor, bgcolor, fgindexed, bgindexed) ;
					VALUES (tnWB, lnNode-1, lcPatternType, lnTheme, lnTint, lnFgColor, lnBgColor, lnFgIndexed, lnBgIndexed)
			ENDFOR
		
		*-*	Retreive the cell border information
			lcBorders = this.GetNodeElement(lcStyleSheet, 'borders', 1)
			lnCnt = CAST(this.GetNodeAttributeValue(lcBorders, "count") AS I)
			FOR lnNode=1 TO lnCnt
				lcBorder = this.GetNodeElement(lcBorders, 'border', lnNode)
				IF EMPTY(lcBorder)
					SET STEP ON
					LOOP
				ENDIF
				lcBLeft  = this.GetNodeElement(lcBorder, 'left', 1)
				lcLStyle = this.GetNodeAttributeValue(lcBLeft, "style")
				lcColor  = this.GetNodeElement(lcBLeft, 'color', 1)
				IF EMPTY(lcColor)
					lnLColor = RGB(0, 0, 0)
					lnLTheme = 0
					lnLTint  = 0
					lnLIndex = 0
				ELSE
					lnLColor = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
					lnLTheme = CAST(this.GetNodeAttributeValue(lcColor, "theme") AS I)
					lnLTint  = CAST(this.GetNodeAttributeValue(lcColor, "tint") AS I)
					lnLIndex = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
				ENDIF
		
				lcBRight = this.GetNodeElement(lcBorder, 'right', 1)
				lcRStyle = this.GetNodeAttributeValue(lcBRight, "style")
				lcColor  = this.GetNodeElement(lcBRight, 'color', 1)
				IF EMPTY(lcColor)
					lnRColor = RGB(0, 0, 0)
					lnRTheme = 0
					lnRTint  = 0
					lnRIndex = 0
				ELSE
					lnRColor = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
					lnRTheme = CAST(this.GetNodeAttributeValue(lcColor, "theme") AS I)
					lnRTint  = CAST(this.GetNodeAttributeValue(lcColor, "tint") AS I)
					lnRIndex = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
				ENDIF
		
				lcBTop   = this.GetNodeElement(lcBorder, 'top', 1)
				lcTStyle = this.GetNodeAttributeValue(lcBTop, "style")
				lcColor  = this.GetNodeElement(lcBTop, 'color', 1)
				IF EMPTY(lcColor)
					lnTColor = RGB(0, 0, 0)
					lnTTheme = 0
					lnTTint  = 0
					lnTIndex = 0
				ELSE
					lnTColor = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
					lnTTheme = CAST(this.GetNodeAttributeValue(lcColor, "theme") AS I)
					lnTTint  = CAST(this.GetNodeAttributeValue(lcColor, "tint") AS I)
					lnTIndex = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
				ENDIF
		
				lcBBottm = this.GetNodeElement(lcBorder, 'bottom', 1)
				lcBStyle = this.GetNodeAttributeValue(lcBBottm, "style")
				lcColor  = this.GetNodeElement(lcBBottm, 'color', 1)
				IF EMPTY(lcColor)
					lnBColor = RGB(0, 0, 0)
					lnBTheme = 0
					lnBTint  = 0
					lnBIndex = 0
				ELSE
					lnBColor = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
					lnBTheme = CAST(this.GetNodeAttributeValue(lcColor, "theme") AS I)
					lnBTint  = CAST(this.GetNodeAttributeValue(lcColor, "tint") AS I)
					lnBIndex = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
				ENDIF
		
				lcBDiag  = this.GetNodeElement(lcBorder, 'diagonal', 1)
				lcDStyle = this.GetNodeAttributeValue(lcBDiag, "style")
				lnDiagDn = CAST(this.GetNodeAttributeValue(lcBDiag, "diagonalDown") AS I)
				lnDiagUp = CAST(this.GetNodeAttributeValue(lcBDiag, "diagonalUp") AS I)
				lcColor  = CAST(this.GetNodeElement(lcBDiag, 'color', 1) AS I)
				IF EMPTY(lcColor)
					lnDColor = RGB(0, 0, 0)
					lnDTheme = 0
					lnDTint  = 0
					lnDIndex = 0
				ELSE
					lnDColor = this.ConvertHexStringToNumeric(this.GetNodeAttributeValue(lcColor, "rgb"))
					lnDTheme = CAST(this.GetNodeAttributeValue(lcColor, "theme") AS I)
					lnDTint  = CAST(this.GetNodeAttributeValue(lcColor, "tint") AS I)
					lnDIndex = CAST(this.GetNodeAttributeValue(lcColor, "indexed") AS I)
				ENDIF
		
				INSERT INTO xl_borders (workbook, id, lstyle, lcolor, ltheme, ltint, lindexed, rstyle, rcolor, rtheme, rtint, rindexed, tstyle, tcolor, ttheme, ttint, tindexed, ;
									    bstyle, bcolor, btheme, btint, bindexed, dstyle, dcolor, dtheme, dtint, dindexed, diagdn, diagup) ;
					VALUES (tnWB, lnNode-1, lcLStyle, lnLColor, lnLTheme, lnLTint, lnLIndex, lcRStyle, lnRColor, lnRTheme, lnRTint, lnRIndex, lcTStyle, lnTColor, lnTTheme, ;
							lnTTint, lnTIndex, lcBStyle, lnBColor, lnBTheme, lnBTint, lnBIndex, lcDStyle, lnDColor, lnDTheme, lnDTint, lnDIndex, lnDiagDn, lnDiagUp)
			ENDFOR
		ENDIF
	ENDPROC

	PROTECTED PROCEDURE RemoveWorkingDirectories		&& Removes the working directories
		LPARAMETERS tcDir
		LOCAL llReturn, loException
		TRY
			RMDIR (tcDir)
			llReturn = True
		
		CATCH TO loException
			SET STEP ON
			llReturn = False
		ENDTRY
		RETURN llReturn
	ENDPROC

	PROCEDURE RenameSheet		&& Renames the selected sheet
		LPARAMETERS tnWB, txSheet, tcSheetName
		LOCAL llReturn
		llReturn = False
		DO CASE
			CASE VARTYPE(txSheet) = "C"
				IF SEEK(BINTOC(tnWB)+UPPER(txSheet), "xl_sheets", "shname")
					REPLACE xl_sheets.shname WITH tcSheetName IN xl_sheets
					llReturn = True
				ENDIF
		
			CASE VARTYPE(txSheet) = "N"
				IF SEEK(BINTOC(tnWB)+BINTOC(txSheet), "xl_sheets", "sheetndx")
					REPLACE xl_sheets.shname WITH tcSheetName IN xl_sheets
					llReturn = True
				ENDIF
		ENDCASE
		RETURN llReturn
	ENDPROC

	PROCEDURE ResetColumnWidth		&& Resets the column width to default
		LPARAMETERS tnWB, tnSheet, tnColumn
		IF SEEK(this.GetColWidthKeyExpr(tnWB, tnSheet, tnColumn), "xl_colwidths", "shcolumn")
			DELETE IN xl_colwidths
		ENDIF
	ENDPROC

	PROCEDURE SaveGridToWorkbook		&& Saves the selected grid to a workbook
		LPARAMETERS toGrid, txWB, tlFreeze, tlSaveWB, tcSheetName
		LOCAL lcAlias, lnCol, lnWB, lnSh, lnRow, lcField, loReturn
		loReturn = CREATEOBJECT("Empty")
		ADDPROPERTY(loReturn, "Workbook",  0)
		ADDPROPERTY(loReturn, "Sheet", 0)
		DO CASE
			CASE PCOUNT() = 0
				RETURN loReturn
		
			CASE PCOUNT() = 1
				RETURN loReturn
		
			CASE PCOUNT() = 2
				tlFreeze = True
				tlSaveWB = True
				tcSheetName = this.DeriveSheetName(txWB)
		
			CASE PCOUNT() = 3
				tlSaveWB = True
				tcSheetName = this.DeriveSheetName(txWB)
		
			CASE PCOUNT() = 4
				tcSheetName = this.DeriveSheetName(txWB)
			
			OTHERWISE
				IF VARTYPE(tcSheetName) != 'C' .OR. EMPTY(tcSheetName)
					tcSheetName = this.DeriveSheetName(txWB)
				ENDIF
		ENDCASE
		IF VARTYPE(toGrid) != "O" .AND. PEMSTATUS(toGrid, "BaseClass", 5) .AND. LOWER(toGrid.BaseClass) != "grid"
			RETURN loReturn
		ENDIF
		DO CASE
			CASE VARTYPE(txWB) = "C"
				lnWB = this.CreateWorkbook(txWB)
				IF lnWB = 0
					lnWB = this.GetWorkbook(txWB)
				ENDIF
		
			CASE VARTYPE(txWB) = "N"
				IF SEEK(BINTOC(tnWB), "xl_workbooks", "workbook")
					lnWB = txWB
				ELSE
					RETURN loReturn
				ENDIF
		
			OTHERWISE
				RETURN loReturn
		ENDCASE
		IF lnWB > 0
			lnSh = this.AddSheet(lnWB, tcSheetName)
			IF lnSh > 0
				lcAlias = JUSTSTEM(toGrid.RecordSource)
				FOR lnCol=1 TO toGrid.ColumnCount
					IF toGrid.HeaderHeight > 0                               && Change recommendation by Doug Hennig (if no headers, then no output)
						this.SetCellValue(lnWB, lnSh, 1, lnCol, toGrid.Columns(lnCol).Header1.Caption)
					ENDIF
					this.SetColumnWidth(lnWB, lnSh, lnCol, this.ConvertPixelsToExcelUnits(toGrid.Columns(lnCol).Width))
				ENDFOR
				SELECT &lcAlias
				IF toGrid.HeaderHeight > 0                                   && Change recommendation by Doug Hennig (if no headers, start in first row)
					lnRow = 1
				ELSE
					lnRow = 0
				ENDIF
				SCAN
					lnRow = lnRow + 1
					FOR lnCol=1 TO toGrid.ColumnCount
						lcField = toGrid.Columns(lnCol).ControlSource
						this.SetCellValue(lnWB, lnSh, lnRow, lnCol, &lcField)
					ENDFOR
				ENDSCAN
				IF tlFreeze
					this.FreezePanes(lnWB, lnSh, 1, 0)
				ENDIF
				IF tlSaveWB
					this.SaveWorkbook(lnWB)
				ENDIF
				loReturn.Sheet    = lnSh
				loReturn.Workbook = lnWB
			ENDIF
		ENDIF
		RETURN loReturn
	ENDPROC

	PROCEDURE SaveTableToWorkbook		&& Saves the table passed (alias) as a workbook sheet
		LPARAMETERS tcAlias, tnWB, tlFreeze, tlSaveWB, tcSheetName
		LOCAL lcAlias, lnCol, lnWB, lnSh, lnRow, lcField, lnFldCnt, llError, llOpenedTbl, loException, lcCurAlias, loReturn
		LOCAL ARRAY laFields[1]
		loReturn = CREATEOBJECT("Empty")
		ADDPROPERTY(loReturn, "Workbook",  0)
		ADDPROPERTY(loReturn, "Sheet", 0)
		DO CASE
			CASE PCOUNT() < 2
				RETURN loReturn
		
			CASE PCOUNT() = 2
				tlFreeze = True
				tlSaveWB = False
				tcSheetName = JUSTSTEM(tcAlias)
		
			CASE PCOUNT() = 3
				tlSaveWB = False
				tcSheetName = JUSTSTEM(tcAlias)
		
			CASE PCOUNT() = 4
				tcSheetName = JUSTSTEM(tcAlias)
		ENDCASE
		IF VARTYPE(tcSheetName) != 'C' .OR. EMPTY(tcSheetName)
			tcSheetName = this.DeriveSheetName(tnWB)
		ENDIF
		DO CASE
			CASE USED(tcAlias)
				lcCurAlias  = ALIAS()
				llOpenedTbl = False
				lcAlias = tcAlias
		
			CASE OCCURS("\", tcAlias) > 0
				TRY
					lcAlias = JUSTSTEM(tcAlias)
					USE (tcAlias) IN 0 ALIAS (lcAlias) SHARED
					llOpenedTbl = True
		
				CATCH TO loException
					llError = True
				ENDTRY
				IF llError
					RETURN loReturn
				ENDIF
		
			OTHERWISE
				RETURN loReturn
		ENDCASE
		DO CASE
			CASE VARTYPE(tnWB) = "C"
				lnWB = this.CreateWorkbook(tnWB)
				IF lnWB = 0
					lnWB = this.GetWorkbook(tnWB)
				ENDIF
		
			CASE VARTYPE(tnWB) = "N"
				IF SEEK(BINTOC(tnWB), "xl_workbooks", "workbook")
					lnWB = tnWB
				ELSE
					RETURN loReturn
				ENDIF
		
			OTHERWISE
				RETURN loReturn
		ENDCASE
		IF lnWB > 0
			lnSh = this.AddSheet(lnWB, tcSheetName)
			IF lnSh > 0
				SELECT &lcAlias
				lnFldCnt = AFIELDS(laFields, lcAlias)
		*-*		Place field names in the first row
				FOR lnCol=1 TO lnFldCnt
					this.SetCellValue(lnWb, lnSh, 1, lnCol, laFields[lnCol, 1])
				ENDFOR
		*-*		Populate next rows with data
				SCAN
					FOR lnCol=1 TO lnFldCnt
						IF laFields[lnCol, 2] = "G"
							this.SetCellValue(lnWb, lnSh, 1 + RECNO(lcAlias), lnCol, "General")
						ELSE
							this.SetCellValue(lnWb, lnSh, 1 + RECNO(lcAlias), lnCol, EVALUATE(lcAlias + '.' + laFields[lnCol, 1]))
						ENDIF
					ENDFOR
				ENDSCAN
				IF tlFreeze
					this.FreezePanes(lnWB, lnSh, 1, 0)
				ENDIF
				IF tlSaveWB
					this.SaveWorkbook(lnWB)
				ENDIF
			ELSE
				lnWB = 0
				lnSh = 0
			ENDIF
		ELSE
			lnSh = 0
			lnWB = 0
		ENDIF
		IF llOpenedTbl
			USE IN &lcAlias
		ELSE
			lnSh = 0
			lnWB = 0
			IF !EMPTY(lcCurAlias)
				SELECT &lcCurAlias
			ENDIF
		ENDIF
		loReturn.Sheet    = lnSh
		loReturn.Workbook = lnWB
		RETURN loReturn
	ENDPROC

	PROCEDURE SaveWorkbook		&& Saves the selected workbook as an XLSX file
		LPARAMETERS tnWB
		LOCAL lcTempPath, lnSheet, loSheets, lcDeleted, lcSetPoint, lcSeparator, lcSetDeleted, llReturn, lcAlias
		IF SEEK(BINTOC(tnWB), "xl_workbooks", "workbook")
			lcAlias = ALIAS()
			lcSetDeleted = SET("DELETED")
			lcSetPoint   = SET("POINT")
			lcSeparator  = SET("SEPARATOR")
			SET POINT TO "."
			SET SEPARATOR TO ","
			SET DELETED ON
		*-*	Get the list of actual sheets to be saved
			loSheets = CREATEOBJECT("Empty")
			ADDPROPERTY(loSheets, "List[1, 4]")
			ADDPROPERTY(loSheets, "Count", 0)
			loSheets.Count = 0
			SELECT xl_sheets
			SET ORDER TO TAG sheet
			SCAN FOR workbook = tnWB .AND. !shdeleted
				loSheets.Count = loSheets.Count + 1
				DIMENSION loSheets.List[loSheets.Count, 4]
				loSheets.List[loSheets.Count, 1] = xl_sheets.sheet
				loSheets.List[loSheets.Count, 2] = ALLTRIM(xl_sheets.shname)
				loSheets.List[loSheets.Count, 3] = "rId" + TRANSFORM(loSheets.Count)
				loSheets.List[loSheets.Count, 4] = xl_sheets.state
			ENDSCAN
			SET ORDER TO
		*-*	Write the XLSX Workbook to XML structures
			IF loSheets.Count > 0
				lcTempPath = this.CreateWorkingDirectories()
				IF ISNULL(lcTempPath)
					llReturn = False
				ELSE
					IF this.WriteSupportXMLs(tnWB, lcTempPath, loSheets) .AND. this.WriteStylesXML(tnWB, lcTempPath) .AND. this.WriteWorkbookXML(tnWB, lcTempPath, loSheets)
						FOR lnSheet=1 TO loSheets.Count
							this.WriteSheetXMLs(tnWB, lnSheet, loSheets.List[lnSheet, 1], lcTempPath)
						ENDFOR
						this.CreateExcelFile(tnWB, lcTempPath)
						llReturn = True
					ELSE
						llReturn = False
					ENDIF
					USE IN SELECT('c_temp')
					USE IN SELECT('t_format')
					this.RemoveWorkingDirectories(lcTempPath)
				ENDIF
			ENDIF
			SET DELETED &lcSetDeleted
			SET POINT TO (lcSetPoint)
			SET SEPARATOR TO (lcSeparator)
			IF !EMPTY(lcAlias)
				SELECT &lcAlias
			ENDIF
		ELSE
			llReturn = False
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SaveWorkbookAs		&& Saves the selected workbook with the new name
		LPARAMETERS tnWB, tcWBName
		LOCAL lcName, lcPath
		IF SEEK(BINTOC(tnWB), "xl_workbooks", "workbook") .AND. !EMPTY(tcWBName)
			lcName = JUSTSTEM(tcWBName)
			lcPath = JUSTPATH(tcWBName)
			IF EMPTY(lcPath)
				lcPath = SYS(5) + SYS(2003)
			ENDIF
			REPLACE xl_workbooks.wbname   WITH lcName, ;
					xl_workbooks.filepath WITH lcPath IN xl_workbooks
			this.SaveWorkbook(tnWB)
		ENDIF
	ENDPROC

	PROCEDURE SetCellAlignment		&& Sets the cell horizontal and vertical alignments
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tcHorizAlign, tcVertAlign
		LOCAL llReturn, lnCellXfsId, lcAlias
		IF PCOUNT() < 4
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			DO CASE
				CASE VARTYPE(tcHorizAlign) = 'C' .AND. VARTYPE(tcVertAlign) = 'C'
					IF INLIST(tcHorizAlign, CELL_HORIZ_ALIGN_LEFT, CELL_HORIZ_ALIGN_RIGHT, CELL_HORIZ_ALIGN_CENTER) .AND. ;
					   INLIST(tcVertAlign, CELL_VERT_ALIGN_TOP, CELL_VERT_ALIGN_BOTTOM, CELL_VERT_ALIGN_CENTER)
		
						IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
							IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
								lnCellXfsId = xl_cellxfs.id
								SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
								IF _TALLY > 1
									lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillId, xl_cellxfs.borderId, tcHorizAlign, tcVertAlign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
								ELSE
									REPLACE xl_cellxfs.halign WITH tcHorizAlign, ;
											xl_cellxfs.valign WITH tcVertAlign IN xl_cellxfs
								ENDIF
								USE IN SELECT('c_temp')
							ELSE
								lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, tcHorizAlign, tcVertAlign, 0, 0, 0)
							ENDIF
							REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
						ELSE
							lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, tcHorizAlign, tcVertAlign, 0, 0, 0)
							INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted) ;
								VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False)
						ENDIF
						llReturn = True
					ELSE
						llReturn = False
					ENDIF
				
				CASE VARTYPE(tcHorizAlign) = 'C' .AND. VARTYPE(tcVertAlign) != 'C'
					IF INLIST(tcHorizAlign, CELL_HORIZ_ALIGN_LEFT, CELL_HORIZ_ALIGN_RIGHT, CELL_HORIZ_ALIGN_CENTER)
						IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
							IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
								lnCellXfsId = xl_cellxfs.id
								SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
								IF _TALLY > 1
									lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillId, xl_cellxfs.borderId, tcHorizAlign, "", xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
								ELSE
									REPLACE xl_cellxfs.halign WITH tcHorizAlign, ;
											xl_cellxfs.valign WITH "" IN xl_cellxfs
								ENDIF
								USE IN SELECT('c_temp')
							ELSE
								lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, tcHorizAlign, "", 0, 0, 0)
							ENDIF
							REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
						ELSE
							lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, tcHorizAlign, "", 0, 0, 0)
							INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted) ;
								VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False)
						ENDIF
						llReturn = True
					ELSE
						llReturn = False
					ENDIF
		
				CASE VARTYPE(tcHorizAlign) != 'C' .AND. VARTYPE(tcVertAlign) = 'C'
					IF INLIST(tcVertAlign, CELL_VERT_ALIGN_TOP, CELL_VERT_ALIGN_BOTTOM, CELL_VERT_ALIGN_CENTER)
						IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
							IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
								lnCellXfsId = xl_cellxfs.id
								SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
								IF _TALLY > 1
									lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillId, xl_cellxfs.borderId, "", tcVertAlign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
								ELSE
									REPLACE xl_cellxfs.halign WITH "", ;
											xl_cellxfs.valign WITH tcVertAlign IN xl_cellxfs
								ENDIF
								USE IN SELECT('c_temp')
							ELSE
								lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, "", tcVertAlign, 0, 0, 0)
							ENDIF
							REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
						ELSE
							lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, "", tcVertAlign, 0, 0, 0)
							INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted) ;
								VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False)
						ENDIF
						llReturn = True
					ELSE
						llReturn = False
					ENDIF
		
				OTHERWISE
					IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
						REPLACE xl_cells.halign WITH "", ;
								xl_cells.valign WITH "" IN xl_cells
					ENDIF
					llReturn = True
			ENDCASE
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellAlignmentRange		&& Sets the cell alignment for a range of cells
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tcHorizAlign, tcVertAlign
		LOCAL lnRow, lnCol, llReturn
		IF PCOUNT() < 7
			RETURN False
		ENDIF
		IF tnBegRow > tnEndRow .OR. tnBegCol > tnEndCol
			RETURN False
		ENDIF
		llReturn = True
		FOR lnRow=tnBegRow TO tnEndRow
			FOR lnCol=tnBegCol TO tnEndCol
				IF !this.SetCellAlignment(tnWB, tnSheet, lnRow, lnCol, tcHorizAlign, tcVertAlign)
					llReturn = False
					EXIT
				ENDIF
			ENDFOR
		ENDFOR
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellBorder
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tnBorders, tcStyle, tnColor
		LOCAL lcLStyle, lnLColor, lcRStyle, lcTStyle, lnTColor, lcBStyle, lnBColor, lcDStyle, lnDColor, lnDiagDn, lnDiagUp
		LOCAL lnRColor, llReturn, lcAlias
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF VARTYPE(tnBorders) != 'N' .OR. EMPTY(tnBorders) .OR. !BETWEEN(tnBorders, 0, 63)
				tnBorders = 0
			ENDIF
			IF !this.IsValidBorderStyle(tcStyle)
				tcStyle = BORDER_STYLE_NONE
			ENDIF
			IF VARTYPE(tnColor) != 'N' .OR. !BETWEEN(tnColor, 0, RGB(255,255,255)) .OR. EMPTY(tnColor)
				tnColor = RGB(0, 0, 0)
			ENDIF
			lnDiagDn = 0
			lnDiagUp = 0
			IF BITTEST(tnBorders, 0)
				lcLStyle = tcStyle
				lnLColor = tnColor
			ENDIF
			IF BITTEST(tnBorders, 1)
				lcRStyle = tcStyle
				lnRColor = tnColor
			ENDIF
			IF BITTEST(tnBorders, 2)
				lcTStyle = tcStyle
				lnTColor = tnColor
			ENDIF
			IF BITTEST(tnBorders, 3)
				lcBStyle = tcStyle
				lnBColor = tnColor
			ENDIF
			IF BITTEST(tnBorders, 4)
				lcDStyle = tcStyle
				lnDColor = tnColor
				lnDiagDn = 1
			ENDIF
			IF BITTEST(tnBorders, 5)
				lcDStyle = tcStyle
				lnDColor = tnColor
				lnDiagUp = 1
			ENDIF
			this.SetCellBorderEx(tnWB, tnSheet, tnCellRow, tnCellCol, lcLStyle, lnLColor, lcRStyle, lnRColor, ;
								 lcTStyle, lnTColor, lcBStyle, lnBColor, lcDStyle, lnDColor, lnDiagDn, lnDiagUp)
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellBorderEx
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp
		LOCAL lnCellXfsId, lnBorderId
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF !this.IsValidBorderStyle(tcLStyle)
				tcLStyle = BORDER_STYLE_NONE
			ENDIF
			IF VARTYPE(tnLColor) != 'N' .OR. EMPTY(tnLColor) .OR. !BETWEEN(tnLColor, 0, RGB(255,255,255))
				tnLColor = RGB(0, 0, 0)
			ENDIF
		
			IF !this.IsValidBorderStyle(tcRStyle)
				tcRStyle = BORDER_STYLE_NONE
			ENDIF
			IF VARTYPE(tnRColor) != 'N' .OR. EMPTY(tnRColor) .OR. !BETWEEN(tnRColor, 0, RGB(255,255,255))
				tnRColor = RGB(0, 0, 0)
			ENDIF
		
			IF !this.IsValidBorderStyle(tcTStyle)
				tcTStyle = BORDER_STYLE_NONE
			ENDIF
			IF VARTYPE(tnTColor) != 'N' .OR. EMPTY(tnTColor) .OR. !BETWEEN(tnTColor, 0, RGB(255,255,255))
				tnTColor = RGB(0, 0, 0)
			ENDIF
		
			IF !this.IsValidBorderStyle(tcBStyle)
				tcBStyle = BORDER_STYLE_NONE
			ENDIF
			IF VARTYPE(tnBColor) != 'N' .OR. EMPTY(tnBColor) .OR. !BETWEEN(tnBColor, 0, RGB(255,255,255))
				tnBColor = RGB(0, 0, 0)
			ENDIF
		
			IF !this.IsValidBorderStyle(tcDStyle)
				tcDStyle = BORDER_STYLE_NONE
			ENDIF
			IF VARTYPE(tnDColor) != 'N' .OR. EMPTY(tnDColor) .OR. !BETWEEN(tnDColor, 0, RGB(255,255,255))
				tnDColor = RGB(0, 0, 0)
			ENDIF
			IF VARTYPE(tnDiagDn) != 'N' .OR. !BETWEEN(tnDiagDn, 0, 3)
				tnDiagDn = 0
			ENDIF
			IF VARTYPE(tnDiagUp) != 'N' .OR. !BETWEEN(tnDiagUp, 0, 3)
				tnDiagUp = 0
			ENDIF
		
		*-*	Get the border record Id
			IF this.GetBordersRecord(tnWB, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp)
				lnBorderId = xl_borders.id
			ELSE
				lnBorderId = this.GetNextId(tnWB, 'xl_borders')
				INSERT INTO xl_borders (workbook, id, lstyle, lcolor, rstyle, rcolor, tstyle, tcolor, bstyle, bcolor, dstyle, dcolor, diagdn, diagup) ;
					VALUES (tnWB, lnBorderId, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp)
			ENDIF
		*-*	Set the XfsId to the cell record
			IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
				IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
					lnCellXfsId = xl_cellxfs.id
					SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
					IF _TALLY > 1
						lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillId, lnBorderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
					ELSE
						REPLACE xl_cellxfs.borderId WITH lnBorderId IN xl_cellxfs
					ENDIF
					USE IN SELECT('c_temp')
				ELSE
					lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, lnBorderId, "", "", 0, 0, 0)
				ENDIF
				REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
			ELSE
				lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, lnBorderId, "", "", 0, 0, 0)
				INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
					VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellBorderRange		&& Sets the cell border for a range of cells
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tnBorder, tcStyle, tnColor
		LOCAL llReturn, lnRow, lnCol
		IF PCOUNT() < 7
			RETURN False
		ENDIF
		IF tnBegRow > tnEndRow .OR. tnBegCol > tnEndCol
			RETURN False
		ENDIF
		llReturn = True
		FOR lnRow=tnBegRow TO tnEndRow
			FOR lnCol=tnBegCol TO tnEndCol
				IF !this.SetCellBorder(tnWB, tnSheet, lnRow, lnCol, tnBorder, tcStyle, tnColor)
					llReturn = False
					EXIT
				ENDIF
			ENDFOR
		ENDFOR
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellFill		&& Sets the fill color for the cell
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tnFColor, tnBColor, tcPatternType
		LOCAL llReturn, lnFillId, lnCellXfsId, lnFIndex, lnBIndex, lcAlias
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF PCOUNT() = 5 .OR. PCOUNT() = 6 .OR. VARTYPE(tcPatternType) != "C" .OR. EMPTY(tcPatternType)
			tcPatternType = FILL_STYLE_SOLID
		ENDIF
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF VARTYPE(tnFColor) = 'N' .AND. BETWEEN(tnFColor, 0, RGB(255, 255, 255))
				tnFColor = FLOOR(tnFColor)
				lnFIndex = 0
			ELSE
				tnFColor = 0
				lnFIndex = 64
			ENDIF
			IF VARTYPE(tnBColor) = 'N' .AND. BETWEEN(tnBColor, 0, RGB(255, 255, 255))
				tnBColor = FLOOR(tnBColor)
				lnBIndex = 0
			ELSE
				tnBColor = RGB(0, 0, 0)
				lnBIndex = 64
			ENDIF
		*-*	Get the fill record id
			IF SEEK(BINTOC(tnWB)+BINTOC(tnFColor)+BINTOC(tnBColor)+tcPatternType, "xl_fills", "fillcolor")
				lnFillId = xl_fills.id
				REPLACE xl_fills.theme     WITH 0, ;
						xl_fills.tint      WITH 0, ;
						xl_fills.fgindexed WITH lnFIndex, ;
						xl_fills.bgindexed WITH lnBIndex IN xl_fills
			ELSE
				lnFillId = this.GetNextId(tnWB, 'xl_fills')
				INSERT INTO xl_fills (workbook, id, fgcolor, bgcolor, patttype, theme, tint, fgindexed, bgindexed) ;
					VALUES (tnWB, lnFillId, tnFColor, tnBColor, tcPatternType, 0, 0, lnFIndex, lnBIndex)
			ENDIF
		*-*	Set the XfsId to the cell record
			IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
				IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
					lnCellXfsId = xl_cellxfs.id
					SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
					IF _TALLY > 1
						lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, lnFillId, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
					ELSE
						REPLACE xl_cellxfs.fillId WITH lnFillId IN xl_cellxfs
					ENDIF
					USE IN SELECT('c_temp')
				ELSE
					lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, lnFillId, 0, "", "", 0, 0, 0)
				ENDIF
				REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
			ELSE
				lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, lnFillId, 0, "", "", 0, 0, 0)
				INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
					VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellFillRange		&& Sets the fill for a range of cells
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tnFColor, tnBColor, tcPatternType
		LOCAL lnRow, lnCol, llReturn
		IF PCOUNT() < 8
			RETURN False
		ENDIF
		IF tnBegRow > tnEndRow .OR. tnBegCol > tnEndCol
			RETURN False
		ENDIF
		llReturn = True
		FOR lnRow=tnBegRow TO tnEndRow
			FOR lnCol=tnBegCol TO tnEndCol
				IF !this.SetCellFill(tnWB, tnSheet, lnRow, lnCol, tnFColor, tnBColor, tcPatternType)
					llReturn = False
					EXIT
				ENDIF
			ENDFOR
		ENDFOR
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellFont		&& Sets the selected cell font format
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos
		LOCAL llReturn, lcAlias
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF VARTYPE(tcFName) != 'C' .OR. EMPTY(tcFName)
				tcFName = 'Calibri'
			ENDIF
			tcFName = PROPER(ALLTRIM(tcFName))
			IF VARTYPE(tnFSize) != 'N' .OR. EMPTY(tnFSize) .OR. tnFSize < 0.5
				tnFSize = 11
			ELSE
				tnFSize = INT(tnFSize)
			ENDIF
			IF VARTYPE(tlBold) != 'L'
				tlBold = False
			ENDIF
			IF VARTYPE(tlItalic) != 'L'
				tlItalic = False
			ENDIF
			IF VARTYPE(tnFColor) = 'N' .AND. BETWEEN(tnFColor, 0, RGB(255, 255, 255))
				tnFColor = FLOOR(tnFColor)
			ELSE
				tnFColor = RGB(0, 0, 0)
			ENDIF
			IF VARTYPE(tlStrikThr) != 'L'
				tlStrikThr = False
			ENDIF
			IF VARTYPE(tcULine) != 'C' .OR. !INLIST(tcULine, UNDERLINE_SINGLE, UNDERLINE_DOUBLE, UNDERLINE_SINGLEACCOUNTING, UNDERLINE_DOUBLEACCOUNTING, UNDERLINE_NONE)
				tcULine = UNDERLINE_NONE
			ENDIF
			IF VARTYPE(tcVPos) != 'C' .OR. !INLIST(tcVPos, FONT_VERTICAL_BASELINE, FONT_VERTICAL_SUBSCRIPT, FONT_VERTICAL_SUPERSCRIPT)
				tcVPos = FONT_VERTICAL_BASELINE
			ENDIF
		*-*	Get the font record id
			IF SEEK(PADR(tcFName, 100) + STR(tnFSize, 5, 1) + TRANSFORM(tlBold) + TRANSFORM(tlItalic) + PADL(tnFColor, 15) + PADR(tcULine, 16) + ;
					TRANSFORM(tlStrikThr) + PADR(tcVPos, 11), "xl_fonts", "cellformat")
		
				lnFontId = xl_fonts.id
				REPLACE xl_fonts.theme   WITH 0, ;
						xl_fonts.tint    WITH 0, ;
						xl_fonts.indexed WITH "" IN xl_fonts
			ELSE
				lnFontId = this.GetNextId(tnWB, 'xl_fonts')
				INSERT INTO xl_fonts (workbook, id, fname, fsize, fbold, fitalic, fcolor, uline, strkthr, fvpos) ;
					VALUES (tnWB, lnFontId, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos)
			ENDIF
		*-*	Set the XfsId to the cell record
			IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
				IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
					lnCellXfsId = xl_cellxfs.id
					SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
					IF _TALLY > 1
						lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, lnFontId, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
					ELSE
						REPLACE xl_cellxfs.fontid WITH lnFontId IN xl_cellxfs
					ENDIF
					USE IN SELECT('c_temp')
				ELSE
					lnCellXfsId = this.GetCellXfsId(tnWB, 0, lnFontId, 0, 0, "", "", 0, 0, 0)
				ENDIF
				REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
			ELSE
				lnCellXfsId = this.GetCellXfsId(tnWB, 0, lnFontId, 0, 0, "", "", 0, 0, 0)
				INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
					VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellFontRange		&& Sets the cell font format for a range of cells
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos
		LOCAL lnRow, lnCol, llReturn
		IF PCOUNT() < 7
			RETURN False
		ENDIF
		IF tnBegRow > tnEndRow .OR. tnBegCol > tnEndCol
			RETURN False
		ENDIF
		llReturn = True
		FOR lnRow=tnBegRow TO tnEndRow
			FOR lnCol=tnBegCol TO tnEndCol
				IF !this.SetCellFont(tnWB, tnSheet, lnRow, lnCol, tcFName, tnFSize, tlBold, tlItalic, tnFColor, tcULine, tlStrikThr, tcVPos)
					llReturn = False
					EXIT
				ENDIF
			ENDFOR
		ENDFOR
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellFormula		&& Sets the cell formula expression
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tcCellFormula
		LOCAL llReturn, lcAlias
		IF PCOUNT() < 5 .OR. VARTYPE(tcCellFormula) != "C"
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
				REPLACE xl_cells.cellvalue   WITH "", ;
						xl_cells.cellformula WITH tcCellFormula, ;
						xl_cells.stringid    WITH 0, ;
						xl_cells.datatype    WITH DATA_TYPE_FORMULA, ;
						xl_cells.celldeleted WITH False IN xl_cells
			ELSE
				INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, cellformula, datatype, cellxfs, celldeleted, numdec, validndx) ;
					VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, tcCellFormula, DATA_TYPE_FORMULA, 0, False, -1, 0)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellIndent		&& Sets the cell indentation value
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tnIndent
		LOCAL lnCellXfsId, lcAlias
		IF PCOUNT() != 5
			RETURN False
		ENDIF
		IF VARTYPE(tnIndent) != 'N'
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		tnIndent = FLOOR(tnIndent)
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
				lnCellXfsId = xl_cellxfs.id
				SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
				IF _TALLY > 1
					lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontid, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, tnIndent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
				ELSE
					REPLACE xl_cellxfs.indent WITH tnIndent IN xl_cellxfs
				ENDIF
				USE IN SELECT('c_temp')
			ELSE
				lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", tnIndent, 0, 0)
			ENDIF
			REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
		ELSE
			lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", tnIndent, 0, 0)
			INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
				VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN True
	ENDPROC

	PROCEDURE SetCellInLineFormatText		&& Saves the in-line format definition to a cell value
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, toInLine
		LOCAL lnNdx, lcRText, llFBold, llFItalic, lnFColor, lcFName, lnFSize, lcULine, llStrkThr, lcFVPos, lcAlias
		IF tnWB = toInLine.Workbook
			lcAlias = ALIAS()
			IF ISNULL(toInLine.StringId)
				toInLine.StringId = this.AddStringValue(toInLine.Workbook, toInLine.StringValue, True)
			ENDIF
			IF this.GetCellRecord(toInLine.Workbook, tnSheet, tnCellRow, tnCellCol)
				REPLACE xl_cells.cellvalue   WITH "StringValue", ;
						xl_cells.cellxfs     WITH 0, ;
						xl_cells.cellformula WITH "", ;
						xl_cells.stringid    WITH toInLine.StringId, ;
						xl_cells.datatype    WITH DATA_TYPE_CHAR, ;
						xl_cells.celldeleted WITH False IN xl_cells
			ELSE
				INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, cellvalue, stringid, datatype, cellxfs, celldeleted, numdec, validndx) ;
					VALUES (toInLine.Workbook, tnSheet, tnCellRow, tnCellCol, "StringValue", toInLine.StringId, DATA_TYPE_CHAR, 0, False, -1, 0)
			ENDIF
			FOR lnNdx=1 TO toInLine.Count
				lcRText   = SUBSTR(toInLine.StringValue, toInLine.Characters[lnNdx].BegPos, toInLine.Characters[lnNdx].Length)
				llFBold   = toInLine.Characters[lnNdx].FontBold
				llFItalic = toInLine.Characters[lnNdx].FontItalic
				lnFColor  = toInLine.Characters[lnNdx].FontColor
				lcFName   = toInLine.Characters[lnNdx].FontName
				lnFSize   = toInLine.Characters[lnNdx].FontSize
				lcULine   = toInLine.Characters[lnNdx].Underline
				llStrkThr = toInLine.Characters[lnNdx].StrikeThru
				lcFVPos   = ICASE(toInLine.Characters[lnNdx].SubScript, FONT_VERTICAL_SUBSCRIPT, toInLine.Characters[lnNdx].SuperScript, FONT_VERTICAL_SUPERSCRIPT, FONT_VERTICAL_BASELINE)
			
				INSERT INTO xl_strformat (workbook, id, index, stringvalue, string, fbold, fitalic, fcolor, fname, fsize, uline, strkthr, fvpos, theme, tint, indexed) ;
					VALUES (toInLine.Workbook, toInLine.StringId, lnNdx, this.GetXMLString(lcRText), lcRText, llFBold, llFItalic, lnFColor, lcFName, lnFSize, lcULine, ;
							llStrkThr, lcFVPos, 0, 0, 0)
			ENDFOR
			IF !EMPTY(lcAlias)
				SELECT &lcAlias
			ENDIF
			RETURN True
		ELSE
			RETURN False
		ENDIF
	ENDPROC

	PROCEDURE SetCellNumberDecimals		&& Sets the number of decimals to display
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tnNumDecimals
		LOCAL lcAlias
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		IF VARTYPE(tnNumDecimals) != 'N' .OR. tnNumDecimals < 0
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			REPLACE xl_cells.numdec WITH tnNumDecimals IN xl_cells
		ELSE
			INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, nbrfmtid, numdec, celldeleted) ;
				VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, 0, tnNumDecimals, False)
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN True
	ENDPROC

	PROCEDURE SetCellNumberFormat		&& Sets the cell number format
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tnNumFormat
		LOCAL llReturn, lnNumFmtId, lcAlias
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		IF VARTYPE(tnNumFormat) != 'N'
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			DO CASE
				CASE tnNumFormat < 164
					lnNumFmtId = tnNumFormat
		
				CASE tnNumFormat >= 164
					IF SEEK(BINTOC(tnWB)+BINTOC(tnNumFormat), "xl_numfmts", "id")
						lnNumFmtId = xl_numfmts.id
					ELSE
						IF !this.AddClassDefinedNumericFormats(tnWB, tnNumFormat)
							RETURN False
						ENDIF
					ENDIF
		
				OTHERWISE
					RETURN False
			ENDCASE
			IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
				IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
					lnCellXfsId = xl_cellxfs.id
					SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
					IF _TALLY > 1
						lnCellXfsId = this.GetCellXfsId(tnWB, lnNumFmtId, xl_cellxfs.fontid, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
					ELSE
						REPLACE xl_cellxfs.numFmtId WITH lnNumFmtId IN xl_cellxfs
					ENDIF
					USE IN SELECT('c_temp')
				ELSE
					lnCellXfsId = this.GetCellXfsId(tnWB, lnNumFmtId, 0, 0, 0, "", "", 0, 0, 0)
				ENDIF
				REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
			ELSE
				lnCellXfsId = this.GetCellXfsId(tnWB, lnNumFmtId, 0, 0, 0, "", "", 0, 0, 0)
				INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
					VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellNumberFormatRange		&& Sets the number format for a range of cells
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tnNumFormat
		LOCAL lnRow, lnCol, llReturn
		IF PCOUNT() < 7
			RETURN False
		ENDIF
		IF tnBegRow > tnEndRow .OR. tnBegCol > tnEndCol
			RETURN False
		ENDIF
		llReturn = True
		FOR lnRow=tnBegRow TO tnEndRow
			FOR lnCol=tnBegCol TO tnEndCol
				IF !this.SetCellNumberFormat(tnWB, tnSheet, lnRow, lnCol, tnNumFormat)
					llReturn = False
					EXIT
				ENDIF
			ENDFOR
		ENDFOR
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellTextRotation		&& Sets the cell text rotation value
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tnRotation
		LOCAL lnCellXfsId, lcAlias
		IF PCOUNT() != 5
			RETURN False
		ENDIF
		IF VARTYPE(tnRotation) != 'N'
			RETURN False
		ENDIF
		IF !BETWEEN(tnRotation, -90, 90)
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		tnRotation = FLOOR(tnRotation)
		IF tnRotation < 0
			tnRotation = 90 - tnRotation
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
				lnCellXfsId = xl_cellxfs.id
				SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
				IF _TALLY > 1
					lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontid, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, tnRotation)
				ELSE
					REPLACE xl_cellxfs.rotation WITH tnRotation IN xl_cellxfs
				ENDIF
				USE IN SELECT('c_temp')
			ELSE
				lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", 0, 0, tnRotation)
			ENDIF
			REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
		ELSE
			lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", 0, 0, tnRotation)
			INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
				VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN True
	ENDPROC

	PROCEDURE SetCellValidation		&& Adds a cell validation
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tnType, tnStyle, tnOperator, tlAllowBlank, tlShowInputMsg, tlShowErrMsg, tcErrMsg, tcErrTitle, tcPrompt, tcFormula1, tcFormula2
		LOCAL lcAlias, lnIndex, llFormula
		lcAlias = ALIAS()
		IF PCOUNT() < 14
			RETURN False
		ENDIF
		IF !BETWEEN(tnType, 0, CUSTOM_VALID_TYPE)
			RETURN False
		ENDIF
		IF VARTYPE(tcFormula1) != "C"
			tcFormula1 = TRANSFORM(tcFormula1)
		ENDIF
		IF EMPTY(tcFormula1) .OR. LEN(tcFormula1) > 254
			RETURN False
		ENDIF
		IF LEFT(tcFormula1, 1) = "="
			llFormula  = True
			tcFormula1 = ALLTRIM(SUBSTR(tcFormula1, 2))
		ELSE
			llFormula  = False
		ENDIF
		IF PCOUNT() < 15
			tcFormula2 = ""
		ENDIF
		IF VARTYPE(tcFormula2) != "C"
			tcFormula2 = TRANSFORM(tcFormula2)
		ENDIF
		IF LEN(tcFormula2) > 254
			RETURN False
		ENDIF
		IF LEFT(tcFormula2, 1) = "="
			tcFormula2 = ALLTRIM(SUBSTR(tcFormula2, 2))
		ENDIF
		IF VARTYPE(tnStyle) = "N"
			IF !BETWEEN(tnStyle, 0, INFO_VALID_STYLE)
				RETURN False
			ENDIF
		ELSE
			tnStyle = 0
		ENDIF
		IF VARTYPE(tnOperator) = "N"
			IF !BETWEEN(tnOperator, 0, GREATOREQUAL_VALID_OPER)
				RETURN False
			ENDIF
		ELSE
			tnOperator = 0
		ENDIF
		IF VARTYPE(tcErrMsg) != "C"
			tcErrMsg = ""
		ENDIF
		IF VARTYPE(tcErrTitle) != "C"
			tcErrTitle = ""
		ENDIF
		IF VARTYPE(tcPrompt) != "C"
			tcPrompt = ""
		ENDIF
		IF VARTYPE(tlAllowBlank) != "L"
			tlAllowBlank = True
		ENDIF
		IF VARTYPE(tlShowInputMsg) != "L"
			tlShowInputMsg = True
		ENDIF
		IF VARTYPE(tlShowErrMsg) != "L"
			tlShowErrMsg = True
		ENDIF
		*-*	Check if the cell is part of a merged range of cells; if so set the cell to the upper left cell of the merged range
		IF RECCOUNT('xl_mergecells') > 0
			SELECT xl_mergecells
			LOCATE FOR workbook = tnWB .AND. sheet = tnSheet .AND. BETWEEN(tnCellRow, begrow, endrow) .AND. BETWEEN(tnCellCol, begcol, endcol) .AND. !DELETED()
			IF FOUND()
				tnCellRow = xl_mergecells.begrow
				tnCellCol = xl_mergecells.begcol
			ENDIF
		ENDIF
		SELECT xl_validation
		LOCATE FOR BINTOC(workbook)+BINTOC(sheet) = BINTOC(tnWB)+BINTOC(tnSheet) ;
			.AND. UPPER(formula1) = UPPER(PADR(tcFormula1, 240)) ;
			.AND. UPPER(formula2) = UPPER(PADR(tcFormula2, 240)) .AND. !DELETED()
		IF FOUND()
			lnIndex = 0
			DO WHILE FOUND()
				IF xl_validation.vtype = tnType ;
				  .AND. xl_validation.vstyle = tnStyle ;
				  .AND. xl_validation.voperator = tnOperator ;
				  .AND. xl_validation.errmsg = tcErrMsg ;
				  .AND. xl_validation.errtitle = tcErrTitle ;
				  .AND. xl_validation.allowblank = tlAllowBlank ;
				  .AND. xl_validation.showinpmsg = tlShowInputMsg ;
				  .AND. xl_validation.showerrmsg = tlShowErrMsg ;
				  .AND. xl_validation.vprompt = tcPrompt
		
					lnIndex = xl_validation.validndx
					EXIT
				ENDIF
				CONTINUE
			ENDDO
			IF lnIndex = 0
				INSERT INTO xl_validation (workbook, sheet, vtype, vstyle, voperator, errmsg, errtitle, vprompt, allowblank, showinpmsg, showerrmsg, formula, formula1, formula2) ;
					VALUES (tnWB, tnSheet, tnType, tnStyle, tnOperator, tcErrMsg, tcErrTitle, tcPrompt, tlAllowBlank, tlShowInputMsg, tlShowErrMsg, llFormula, tcFormula1, tcFormula2)
				lnIndex = xl_validation.validndx
			ENDIF
		ELSE
			INSERT INTO xl_validation (workbook, sheet, vtype, vstyle, voperator, errmsg, errtitle, vprompt, allowblank, showinpmsg, showerrmsg, formula, formula1, formula2) ;
				VALUES (tnWB, tnSheet, tnType, tnStyle, tnOperator, tcErrMsg, tcErrTitle, tcPrompt, tlAllowBlank, tlShowInputMsg, tlShowErrMsg, llFormula, tcFormula1, tcFormula2)
			lnIndex = xl_validation.validndx
		ENDIF
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			REPLACE xl_cells.validndx WITH lnIndex IN xl_cells
		ELSE
			INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
				VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, 0, False, -1, lnIndex)
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN True
	ENDPROC

	PROCEDURE SetCellValue		&& Sets the cell value
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, txCellValue
		LOCAL lcCellValue, lcDataType, lnStringNdx, lnSetDecimals, lnWholePart, lnFractPart, lcAlias, lnNumFmtId, lcHorzAlign
		LOCAL lcSetDate, lcSetPoint, lcSeparator, lcCurrency
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		*-*	Check if the cell is part of a merged range of cells; if so set the cell to the upper left cell of the merged range
		IF RECCOUNT('xl_mergecells') > 0
			SELECT xl_mergecells
			LOCATE FOR workbook = tnWB .AND. sheet = tnSheet .AND. BETWEEN(tnCellRow, begrow, endrow) .AND. BETWEEN(tnCellCol, begcol, endcol) .AND. !DELETED()
			IF FOUND()
				tnCellRow = xl_mergecells.begrow
				tnCellCol = xl_mergecells.begcol
			ENDIF
		ENDIF
		*-*	Assign the data type based on type of value and add to cell
		lnStringNdx = 0
		lcHorzAlign = ""
		lnNumFmtId  = 0
		lcSetPoint  = SET("POINT")
		lcSeparator = SET("SEPARATOR")
		SET POINT TO "."
		SET SEPARATOR TO ","
		DO CASE
			CASE VARTYPE(txCellValue) = DATA_TYPE_LOGICAL
				lcDataType  = DATA_TYPE_LOGICAL
				lcCellValue = "StringValue"
				txCellValue = IIF(txCellValue, GETWORDNUM(this.TrueFalseValue, 1, "|"), GETWORDNUM(this.TrueFalseValue, 2, "|"))
				lnStringNdx = this.AddStringValue(tnWB, txCellValue, False)
		
			CASE VARTYPE(txCellValue) = DATA_TYPE_CHAR
				lcDataType  = DATA_TYPE_CHAR
				lcCellValue = "StringValue"
				lnStringNdx = this.AddStringValue(tnWB, txCellValue, False)
				DELETE FOR workbook = tnWB .AND. id = lnStringNdx IN xl_strformat
		
			CASE VARTYPE(txCellValue) = DATA_TYPE_DATE
				IF txCellValue >= DATE(1900, 1, 1)
					lcDataType  = DATA_TYPE_DATE
					lcCellValue = TRANSFORM(INT(txCellValue - DATE(1900, 1, 1) + 2))
				ELSE
					lcDataType  = DATA_TYPE_CHAR
					lcCellValue = "StringValue"
					lcSetDate   = SET("DATE")
					SET DATE TO AMERICAN
					lnStringNdx = this.AddStringValue(tnWB, TRANSFORM(txCellValue), False)
					SET DATE TO (lcSetDate)
				ENDIF
				lcHorzAlign = CELL_HORIZ_ALIGN_LEFT
				lnNumFmtId  = CELL_FORMAT_DATE_MMDDYY
		
			CASE VARTYPE(txCellValue) = DATA_TYPE_DATETIME
				IF TTOD(txCellValue) >= DATE(1900, 1, 1)
					lnSetDecimals = SET("DECIMALS")
					SET DECIMALS TO 12
					lcDataType  = DATA_TYPE_DATETIME
					lnWholePart = INT(TTOD(txCellValue) - DATE(1900, 1, 1) + 2)
					lnFractPart = ((HOUR(txCellValue) * 60 + MINUTE(txCellValue)) * 60 + SEC(txCellValue)) / (24 * 60 * 60)
					lcCellValue = TRANSFORM(lnWholePart + lnFractPart)
					SET DECIMALS TO (lnSetDecimals)
				ELSE
					lcDataType  = DATA_TYPE_CHAR
					lcCellValue = "StringValue"
					lcSetDate   = SET("DATE")
					SET DATE TO AMERICAN
					lnStringNdx = this.AddStringValue(tnWB, TRANSFORM(txCellValue), False)
					SET DATE TO (lcSetDate)
				ENDIF
				lcHorzAlign = CELL_HORIZ_ALIGN_LEFT
				lnNumFmtId  = CELL_FORMAT_DATETIME_MMMDDYYYY_TTAM
		
			CASE VARTYPE(txCellValue) = DATA_TYPE_FLOAT
				lcCellValue = TRANSFORM(txCellValue)
				IF ATC(".", lcCellValue) > 0
					lcDataType = DATA_TYPE_FLOAT
				ELSE
					lcDataType = DATA_TYPE_INT
				ENDIF
		
			CASE VARTYPE(txCellValue) = DATA_TYPE_CURRENCY
				lcCurrency  = SET("Currency", 1)
				lcCellValue = CHRTRAN(TRANSFORM(txCellValue), lcCurrency+",", "")
				lcDataType  = DATA_TYPE_CURRENCY
				lcHorzAlign = CELL_HORIZ_ALIGN_RIGHT
				DO CASE
					CASE lcCurrency = "£"
						lnNumFmtId = CELL_FORMAT_CURRENCY_POUNDS
		
					CASE lcCurrency = ""
						lnNumFmtId = CELL_FORMAT_CURRENCY_EURO
		
					OTHERWISE
						lnNumFmtId = CELL_FORMAT_CURRENCY_PAREN
				ENDCASE
		
			CASE VARTYPE(txCellValue) = DATA_TYPE_GENERAL
				lcDataType  = DATA_TYPE_GENERAL
				lcCellValue = ""                                      && Change recommendation by Doug Hennig
		
			OTHERWISE
				lcDataType  = DATA_TYPE_GENERAL
				lcCellValue = TRANSFORM(txCellValue)
		ENDCASE
		IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
			IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
				lnCellXfsId = xl_cellxfs.id
				SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
				IF _TALLY > 1
					lnCellXfsId = this.GetCellXfsId(tnWB, lnNumFmtId, xl_cellxfs.fontid, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, xl_cellxfs.wraptext, xl_cellxfs.rotation)
				ELSE
					REPLACE xl_cellxfs.numFmtId WITH lnNumFmtId IN xl_cellxfs
				ENDIF
				USE IN SELECT('c_temp')
			ELSE
				lnCellXfsId = this.GetCellXfsId(tnWB, lnNumFmtId, 0, 0, 0, "", "", 0, 0, 0)
			ENDIF
			REPLACE xl_cells.cellvalue   WITH lcCellValue, ;
					xl_cells.cellxfs     WITH lnCellXfsId, ;
					xl_cells.cellformula WITH "", ;
					xl_cells.stringid    WITH lnStringNdx, ;
					xl_cells.datatype    WITH lcDataType, ;
					xl_cells.celldeleted WITH False IN xl_cells
		ELSE
			IF lnNumFmtId > 0
				lnCellXfsId = this.GetCellXfsId(tnWB, lnNumFmtId, 0, 0, 0, "", "", 0, 0, 0)
			ELSE
				lnCellXfsId = 0
			ENDIF
			INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, cellvalue, stringid, datatype, cellxfs, celldeleted, numdec, validndx) ;
				VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, lcCellValue, lnStringNdx, lcDataType, lnCellXfsId, False, -1, 0)
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		SET POINT TO (lcSetPoint)
		SET SEPARATOR TO (lcSeparator)
		RETURN True
	ENDPROC

	PROCEDURE SetCellWordWrap		&& Sets the cell word-wrapping value
		LPARAMETERS tnWB, tnSheet, tnCellRow, tnCellCol, tlWordWrap
		LOCAL llReturn, lnWrapText, lnCellXfsId, lcAlias
		IF PCOUNT() < 5 .OR. VARTYPE(tlWordWrap) != "L"
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			lnWrapText = IIF(tlWordWrap, 1, 0)
		*-*	Set the XfsId to the cell record
			IF this.GetCellRecord(tnWB, tnSheet, tnCellRow, tnCellCol)
				IF xl_cells.cellxfs > 0 .AND. this.GetCellXfsRecord(tnWB, xl_cells.cellxfs)
					lnCellXfsId = xl_cellxfs.id
					SELECT workbook FROM xl_cells WHERE workbook = tnWB AND cellxfs = lnCellXfsId INTO CURSOR c_temp
					IF _TALLY > 1
						lnCellXfsId = this.GetCellXfsId(tnWB, xl_cellxfs.numFmtId, xl_cellxfs.fontId, xl_cellxfs.fillid, xl_cellxfs.borderId, xl_cellxfs.halign, xl_cellxfs.valign, xl_cellxfs.indent, lnWrapText, xl_cellxfs.rotation)
					ELSE
						REPLACE xl_cellxfs.wraptext WITH lnWrapText IN xl_cellxfs
					ENDIF
					USE IN SELECT('c_temp')
				ELSE
					lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", 0, lnWrapText, 0)
				ENDIF
				REPLACE xl_cells.cellxfs WITH lnCellXfsId IN xl_cells
			ELSE
				lnCellXfsId = this.GetCellXfsId(tnWB, 0, 0, 0, 0, "", "", 0, lnWrapText, 0)
				INSERT INTO xl_cells (workbook, sheet, cellrow, cellcol, datatype, cellxfs, celldeleted, numdec, validndx) ;
					VALUES (tnWB, tnSheet, tnCellRow, tnCellCol, DATA_TYPE_NONE, lnCellXfsId, False, -1, 0)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCellWordWrapRange		&& Sets the word wrap for a range of cells
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol, tlWordWrap
		LOCAL lnRow, lnCol, llReturn
		IF PCOUNT() < 7 .OR. VARTYPE(tlWordWrap) != "L"
			RETURN False
		ENDIF
		IF tnBegRow > tnEndRow .OR. tnBegCol > tnEndCol
			RETURN False
		ENDIF
		llReturn = True
		FOR lnRow=tnBegRow TO tnEndRow
			FOR lnCol=tnBegCol TO tnEndCol
				IF !this.SetCellWordWrap(tnWB, tnSheet, lnRow, lnCol, tlWordWrap)
					llReturn = False
					EXIT
				ENDIF
			ENDFOR
		ENDFOR
		RETURN llReturn
	ENDPROC

	PROCEDURE SetColumnBestFit		&& Set the column to best fit
		LPARAMETERS tnWB, tnSheet, tnColumn, tlBestFit
		LOCAL llReturn, lcAlias
		IF PCOUNT() < 4
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF SEEK(this.GetColWidthKeyExpr(tnWB, tnSheet, tnColumn), "xl_colwidths", "shcolumn")
				REPLACE xl_colwidths.bestfit WITH tlBestFit IN xl_colwidths
			ELSE
				INSERT INTO xl_colwidths (workbook, sheet, column, bestfit) VALUES (tnWB, tnSheet, tnColumn, tlBestFit)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetColumnWidth		&& Sets the column width
		LPARAMETERS tnWB, tnSheet, tnColumn, tnWidth
		LOCAL llReturn, lcAlias
		IF PCOUNT() < 4 .OR. VARTYPE(tnWidth) != "N"
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF SEEK(this.GetColWidthKeyExpr(tnWB, tnSheet, tnColumn), "xl_colwidths", "shcolumn")
				REPLACE xl_colwidths.width WITH tnWidth IN xl_colwidths
			ELSE
				INSERT INTO xl_colwidths (workbook, sheet, column, width, bestfit) VALUES (tnWB, tnSheet, tnColumn, tnWidth, False)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetColumnWidthRange		&& Sets the column width for a range of columns
		LPARAMETERS tnWB, tnSheet, tnBegCol, tnEndCol, tnWidth
		LOCAL lnCol, llReturn
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		IF tnBegCol > tnEndCol
			RETURN False
		ENDIF
		llReturn = True
		FOR lnCol=tnBegCol TO tnEndCol
			IF !this.SetColumnWidth(tnWB, tnSheet, lnCol, tnWidth)
				llReturn = False
				EXIT
			ENDIF
		ENDFOR
		RETURN llReturn
	ENDPROC

	PROCEDURE SetCustomPaperSize		&& Sets the paper size based on custom dimensions
		LPARAMETERS tnWB, tnSheet, tnWidth, tnHeight, tcDimen
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		IF PCOUNT() = 5 .AND. this.GetSheetRecord(tnWB, tnSheet)
			DO CASE
				CASE tnWidth=0 .OR. tnHeight=0
					REPLACE xl_sheets.paperwidth  WITH 0, ;
							xl_sheets.paperheight WITH 0, ;
							xl_sheets.paperdimen  WITH "" IN xl_sheets
					llReturn = True
		
				CASE tnWidth>0 .AND. tnHeight>0 .AND. INLIST(tcDimen, "mm", "in")
					REPLACE xl_sheets.paperwidth  WITH tnWidth, ;
							xl_sheets.paperheight WITH tnHeight, ;
							xl_sheets.paperdimen  WITH LOWER(tcDimen) IN xl_sheets
					llReturn = True
					
				OTHERWISE
					llReturn = False
			ENDCASE
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetDefaultBorder		&& Sets the default border style for the workbook
		LPARAMETERS tnWB, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp
		LOCAL lcAlias
		IF PCOUNT() < 2
			RETURN False
		ENDIF
		IF VARTYPE(tcLStyle) != "C"
			tcLStyle = BORDER_STYLE_NONE
		ENDIF
		lcAlias = ALIAS()
		DO CASE
			CASE PCOUNT() = 2
				tnLColor = 0
				tcRStyle = tcLStyle
				tnRColor = 0
				tcTStyle = tcLStyle
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 3
				tcRStyle = tcLStyle
				tnRColor = 0
				tcTStyle = tcLStyle
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 4
				tnRColor = 0
				tcTStyle = tcLStyle
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 5
				tcTStyle = tcLStyle
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 6
				tnTColor = 0
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 7
				tcBStyle = tcLStyle
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 8
				tnBColor = 0
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 9
				tcDStyle = tcLStyle
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 10
				tnDColor = 0
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 11
				tnDiagDn = 0
				tnDiagUp = 0
		
			CASE PCOUNT() = 12
				tnDiagUp = 0
		
		ENDCASE
		IF VARTYPE(tnLColor) != "N"
			tnLColor = 0
		ENDIF
		IF VARTYPE(tcRStyle) != "C"
			tcRStyle = tcLStyle
		ENDIF
		IF VARTYPE(tnRColor) != "N"
			tnRColor = 0
		ENDIF
		IF VARTYPE(tcTStyle) != "C"
			tcTStyle = tcLStyle
		ENDIF
		IF VARTYPE(tnTColor) != "N"
			tnTColor = 0
		ENDIF
		IF VARTYPE(tcBStyle) != "C"
			tcBStyle = tcLStyle
		ENDIF
		IF VARTYPE(tnBColor) != "N"
			tnBColor = 0
		ENDIF
		IF VARTYPE(tcDStyle) != "C"
			tcDStyle = tcLStyle
		ENDIF
		IF VARTYPE(tnDColor) != "N"
			tnDColor = 0
		ENDIF
		IF VARTYPE(tnDiagDn) != "N"
			tnDiagDn = 0
		ENDIF
		IF VARTYPE(tnDiagUp) != "N"
			tnDiagUp = 0
		ENDIF
		IF SEEK(BINTOC(tnWB)+BINTOC(0), "xl_borders", "id")
			REPLACE xl_borders.lstyle WITH tcLStyle, ;
					xl_borders.lcolor WITH tnLColor, ;
					xl_borders.rstyle WITH tcRStyle, ;
					xl_borders.rcolor WITH tnRColor, ;
					xl_borders.tstyle WITH tcTStyle, ;
					xl_borders.tcolor WITH tnTColor, ;
					xl_borders.bstyle WITH tcBStyle, ;
					xl_borders.bcolor WITH tnBColor, ;
					xl_borders.dstyle WITH tcDStyle, ;
					xl_borders.dcolor WITH tnDColor, ;
					xl_borders.diagdn WITH tnDiagDn, ;
					xl_borders.diagup WITH tnDiagUp IN xl_borders
		ELSE
			INSERT INTO xl_borders (workbook, id, lstyle, lcolor, rstyle, rcolor, tstyle, tcolor, bstyle, bcolor, dstyle, dcolor, diagdn, diagup) ;
				VALUES (tnWB, 0, tcLStyle, tnLColor, tcRStyle, tnRColor, tcTStyle, tnTColor, tcBStyle, tnBColor, tcDStyle, tnDColor, tnDiagDn, tnDiagUp)
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN True
	ENDPROC

	PROCEDURE SetDefaultFill		&& Sets the default fill for the workbook
		LPARAMETERS tnWB, tcPatternType, tnFColor, tnBColor
		LOCAL lnFIndex, lnBIndex, lcAlias
		IF PCOUNT() < 2
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF VARTYPE(tcPatternType) != "C"
			tcPatternType = FILL_STYLE_NONE
		ENDIF
		DO CASE
			CASE PCOUNT() = 2
				tnFColor = 0
				lnFIndex = 0
				tnBColor = 0
				lnBIndex = 0
		
			CASE PCOUNT() = 3
				tnBColor = 0
				lnBIndex = 64
		ENDCASE
		IF VARTYPE(tnFColor) != "N"
			tnFColor = 0
		ENDIF
		IF VARTYPE(tnBColor) != "N"
			tnBColor = RGB(255,255,255)
		ENDIF
		IF SEEK(BINTOC(tnWB)+BINTOC(0), "xl_fills", "id")
			REPLACE xl_fills.fgcolor   WITH tnFColor, ;
					xl_fills.bgcolor   WITH tnBColor, ;
					xl_fills.patttype  WITH tcPatternType, ;
					xl_fills.theme     WITH 0, ;
					xl_fills.tint      WITH 0, ;
					xl_fills.fgindexed WITH 0, ;
					xl_fills.bgindexed WITH 0 IN xl_fills
		ELSE
			INSERT INTO xl_fills (workbook, id, fgcolor, bgcolor, patttype, theme, tint, fgindexed, bgindexed) ;
				VALUES (tnWB, 0, tnFColor, tnBColor, tcPatternType, 0, 0, lnFIndex, lnBIndex)
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN True
	ENDPROC

	PROCEDURE SetDefaultFont		&& Sets the default font for the workbook
		LPARAMETERS tnWB, tcFontName, tnSize, tlBold, tlItalic, tnColor, tcUline, tlStrkthr, tcFVPos, tnTheme, tnTint, tnIndexed
		LOCAL lcAlias
		IF PCOUNT() < 2
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		DO CASE
			CASE PCOUNT() = 2
				tnSize    = 0
				tlBold    = False
				tlItalic  = False
				tnColor   = 0
				tcUline   = ""
				tlStrkthr = False
				tcFVPos   = ""
				tnTheme   = 0
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 3
				tlBold    = False
				tlItalic  = False
				tnColor   = 0
				tcUline   = ""
				tlStrkthr = False
				tcFVPos   = ""
				tnTheme   = 0
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 4
				tlItalic  = False
				tnColor   = 0
				tcUline   = ""
				tlStrkthr = False
				tcFVPos   = ""
				tnTheme   = 0
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 5
				tnColor   = 0
				tcUline   = ""
				tlStrkthr = False
				tcFVPos   = ""
				tnTheme   = 0
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 6
				tcUline   = ""
				tlStrkthr = False
				tcFVPos   = ""
				tnTheme   = 0
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 7
				tlStrkthr = False
				tcFVPos   = ""
				tnTheme   = 0
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 8
				tcFVPos   = ""
				tnTheme   = 0
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 9
				tnTheme   = 0
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 10
				tnTint    = 0
				tnIndexed = 0
		
			CASE PCOUNT() = 11
				tnIndexed = 0
		ENDCASE
		IF VARTYPE(tcFontName) != "C"
			tcFontName = "Calibri"
		ENDIF
		IF VARTYPE(tnSize) != "N"
			tnSize = 11
		ENDIF
		IF VARTYPE(tlBold) != "L"
			tlBold = False
		ENDIF
		IF VARTYPE(tlItalic) != "L"
			tlItalic = False
		ENDIF
		IF VARTYPE(tnColor) != "N"
			tnColor = 0
		ENDIF
		IF VARTYPE(tcUline) != "C"
			tcUline = ""
		ENDIF
		IF VARTYPE(tlStrkthr) != "L"
			tlStrkthr = False
		ENDIF
		IF VARTYPE(tcFVPos) != "C"
			tcFVPos = ""
		ENDIF
		IF VARTYPE(tnTheme) != "N"
			tnTheme = 0
		ENDIF
		IF VARTYPE(tnTint) != "N"
			tnTint = 0
		ENDIF
		IF VARTYPE(tnIndexed) != "N"
			tnTint = 0
		ENDIF
		IF SEEK(BINTOC(tnWB)+BINTOC(0), "xl_fonts", "id")
			REPLACE xl_fonts.fname   WITH tcFontName, ;
					xl_fonts.fsize   WITH tnSize, ;
					xl_fonts.fbold   WITH tlBold, ;
					xl_fonts.fitalic WITH tlItalic, ;
					xl_fonts.fcolor  WITH tnColo , ;
					xl_fonts.uline   WITH tcUline, ;
					xl_fonts.strkthr WITH tlStrkthr, ;
					xl_fonts.fvpos   WITH tcFVPos, ;
					xl_fonts.theme   WITH tnTheme, ;
					xl_fonts.tint    WITH tnTint, ;
					xl_fonts.indexed WITH tnIndexed IN xl_fonts
		ELSE
			INSERT INTO xl_fonts (workbook, id, fname, fsize, fbold, fitalic, fcolor, uline, strkthr, fvpos, theme, tint, indexed) ;
				VALUES (tnWB, 0, tcFontName, tnSize, tlBold, tlItalic, tnColor, tcUline, tlStrkthr, tcFVPos, tnTheme, tnTint, tnIndexed)
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN true
	ENDPROC

	PROCEDURE SetHeaderFooterSetup		&& Sets the header and footer setup for the sheet
		LPARAMETERS tnWB, tnSheet, tlAlignMargin, tlDiffFirstPg, tlDiffOddEven, tlScaleWDoc
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		IF PCOUNT() = 6 .AND. this.GetSheetRecord(tnWB, tnSheet)
			IF SEEK(BINTOC(tnWB)+BINTOC(tnSheet), "xl_hdrfooterdefn", "wbsheet")
				REPLACE xl_hdrfooterdefn.alignmargin WITH tlAlignMargin, ;
						xl_hdrfooterdefn.difffirstpg WITH tlDiffFirstPg, ;
						xl_hdrfooterdefn.diffoddeven WITH tlDiffOddEven, ;
						xl_hdrfooterdefn.scalewdoc   WITH tlScaleWDoc IN xl_hdrfooterdefn
			ELSE
				INSERT INTO xl_hdrfooterdefn (workbook, sheet, alignmargin, difffirstpg, diffoddeven, scalewdoc) ;
					VALUES (tnWB, tnSheet, tlAlignMargin, tlDiffFirstPg, tlDiffOddEven, tlScaleWDoc)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetHeaderFooterText		&& Sets the header/footer text for the sheet
		LPARAMETERS tnWB, tnSheet, tnPage, tnSection, tcText, tcFontName, tnFontSize, tnFontEffect, tnFontColor
		LOCAL llReturn, lcAlias
		DO CASE
			CASE PCOUNT() < 5
				RETURN False
		
			CASE PCOUNT() = 5
				tcFontName   = ""
				tnFontSize   = 0
				tnFontEffect = 0
				tnFontColor  = 0
		
			CASE PCOUNT() = 6
				tnFontSize   = 0
				tnFontEffect = 0
				tnFontColor  = 0
		
			CASE PCOUNT() = 7
				tnFontEffect = 0
				tnFontColor  = 0
		
			CASE PCOUNT() = 8
				tnFontColor = 0
		ENDCASE
		IF VARTYPE(tcFontName) != "C"
			tcFontName = ""
		ENDIF
		IF VARTYPE(tnFontSize) != "N"
			tnFontSize = 0
		ENDIF
		IF VARTYPE(tnFontEffect) != "N"
			tnFontEffect = 0
		ENDIF
		IF VARTYPE(tnFontColor) != "N"
			tnFontColor = 0
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF SEEK(BINTOC(tnWB)+BINTOC(tnSheet), "xl_hdrfooterdefn", "wbsheet")
				IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, tnPage, tnSection), "xl_hdrfootertext", "hdrfootr")
					REPLACE xl_hdrfootertext.text      WITH tcText, ;
							xl_hdrfootertext.fontname  WITH tcFontName, ;
							xl_hdrfootertext.fontsize  WITH tnFontSize, ;
							xl_hdrfootertext.fontstyle WITH tnFontEffect, ;
							xl_hdrfootertext.fontcolor WITH tnFontColor IN xl_hdrfootertext
				ELSE
					INSERT INTO xl_hdrfootertext (workbook, sheet, page, section, text, fontname, fontsize, fontstyle, fontcolor) ;
						VALUES (tnWB, tnSheet, tnPage, tnSection, tcText, tcFontName, tnFontSize, tnFontEffect, tnFontColor)
				ENDIF
				llReturn = True
			ELSE
				llReturn = False
			ENDIF
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetPaperSize		&& Sets the paper size for the selected sheet
		LPARAMETERS tnWB, tnSheet, tnPaperSize
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		IF PCOUNT() = 3 .AND. this.GetSheetRecord(tnWB, tnSheet)
			IF BETWEEN(tnPaperSize, 0, 118)
				REPLACE xl_sheets.papersize WITH tnPaperSize IN xl_sheets
				llReturn = True
			ELSE
				llReturn = False
			ENDIF
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetPrintFitToHeight		&& Number of vertical pages to fit on for printing
		LPARAMETERS tnWB, tnSheet, tnFitToHeight
		LOCAL llReturn
		lcAlias = ALIAS()
		IF PCOUNT() = 3 .AND. this.GetSheetRecord(tnWB, tnSheet)
			IF INT(tnFitToHeight) >= 0
				REPLACE xl_sheets.fittoheight WITH INT(tnFitToHeight) IN xl_sheets
				llReturn = True
			ELSE
				llReturn = False
			ENDIF
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetPrintFitToWidth		&& Number of horizontal pages to fit on for printing
		LPARAMETERS tnWB, tnSheet, tnFitToWidth
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		IF PCOUNT() = 3 .AND. this.GetSheetRecord(tnWB, tnSheet)
			IF INT(tnFitToWidth) >= 0
				REPLACE xl_sheets.fittowidth WITH INT(tnFitToWidth) IN xl_sheets
				llReturn = True
			ELSE
				llReturn = False
			ENDIF
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetPrintOrientation		&& Sets the printer orientation for sheet output
		LPARAMETERS tnWB, tnSheet, tnOrientation
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		IF PCOUNT() = 3 .AND. this.GetSheetRecord(tnWB, tnSheet)
			REPLACE xl_sheets.prnorient WITH tnOrientation IN xl_sheets
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetRowHeight		&& Sets the row height
		LPARAMETERS tnWB, tnSheet, tnRow, tnHeight
		LOCAL llReturn, lcAlias
		IF PCOUNT() < 4 .OR. VARTYPE(tnHeight) != "N"
			RETURN False
		ENDIF
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF SEEK(this.GetRowHeightKeyExpr(tnWB, tnSheet, tnRow), "xl_rowheights", "shrow")
				REPLACE xl_rowheights.height WITH tnHeight IN xl_rowheights
			ELSE
				INSERT INTO xl_rowheights (workbook, sheet, row, height) VALUES (tnWB, tnSheet, tnRow, tnHeight)
			ENDIF
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetRowHeightRange		&& Sets the row height for a range of rows
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnEndRow, tnHeight
		LOCAL lnRow, llReturn
		IF PCOUNT() < 5
			RETURN False
		ENDIF
		IF tnBegRow > tnEndRow
			RETURN False
		ENDIF
		llReturn = True
		FOR lnRow=tnBegRow TO tnEndRow
			IF !this.SetRowHeight(tnWB, tnSheet, lnRow, tnHeight)
				llReturn = False
				EXIT
			ENDIF
		ENDFOR
		RETURN llReturn
	ENDPROC

	PROCEDURE SetSheetMargins		&& Sets the sheet margin values
		LPARAMETERS tnWB, tnSheet, tnLeft, tnRight, tnTop, tnbot, tnHeader, tnFooter
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		IF PCOUNT() = 8 .AND. this.GetSheetRecord(tnWB, tnSheet)
			REPLACE xl_sheets.mleft   WITH tnLeft, ;
					xl_sheets.mright  WITH tnRight, ;
					xl_sheets.mtop    WITH tnTop, ;
					xl_sheets.mbot    WITH tnbot, ;
					xl_sheets.mheader WITH tnHeader, ;
					xl_sheets.mfooter WITH tnFooter IN xl_sheets
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetSheetScale		&& Sets the print scale; must be between 10 and 400; i.e. 10=10%, 100=100%, etc.
		LPARAMETERS tnWB, tnSheet, tnScale
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		IF PCOUNT() = 3 .AND. this.GetSheetRecord(tnWB, tnSheet)
			IF BETWEEN(INT(tnScale), 10, 400)
				REPLACE xl_sheets.scale WITH INT(tnScale) IN xl_sheets
				llReturn = True
			ELSE
				llReturn = False
			ENDIF
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE SetSheetVisibility		&& Sets the sheet visibility
		LPARAMETERS tnWB, tnSheet, tnVisiblity
		LOCAL llReturn, lcAlias
		llReturn = False
		lcAlias = ALIAS()
		IF PCOUNT() = 3 .AND. this.GetSheetRecord(tnWB, tnSheet)
			IF BETWEEN(tnVisiblity, VISIBLE_SHEET_STATE, VERYHIDDEN_SHEET_STATE)
				REPLACE xl_sheets.state WITH tnVisiblity IN xl_sheets
				llReturn = True
			ENDIF
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROTECTED PROCEDURE TTOC3		&& Equlivalent of TTOC() function for pre VFP9 support
		LPARAMETERS ttime
		LOCAL lct
		IF PCOUNT() < 1 OR VARTYPE(m.ttime) != "T"
			RETURN
		ENDIF
		lct = TTOC(m.ttime,1)
		RETURN LEFT(m.lct,4) + "-" + SUBSTR(m.lct,5,2) + "-" + SUBSTR(m.lct,7,2) + "T" + SUBSTR(m.lct,9,2) + ":" + SUBSTR(m.lct,11,2) + ":" + RIGHT(m.lct,2)
	ENDPROC

	PROCEDURE UnFreezePanes		&& Removes the pane freeze from the sheet
		LPARAMETERS tnWB, tnSheet
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		IF this.GetSheetRecord(tnWB, tnSheet)
			REPLACE xl_sheets.xsplit WITH 0, ;
					xl_sheets.ysplit WITH 0 IN xl_sheets
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROCEDURE UnMergedCells		&& Unmerges merged cells
		LPARAMETERS tnWB, tnSheet, tnBegRow, tnBegCol, tnEndRow, tnEndCol
		LOCAL llReturn, lcAlias
		lcAlias = ALIAS()
		SELECT xl_mergecells
		LOCATE FOR workbook=tnWB .AND. sheet=tnSheet .AND. begrow=tnBegRow .AND. begcol=tnBegCol .AND. endrow=tnEndRow .AND. endcol=tnEndCol .AND. !DELETED()
		IF FOUND()
			DELETE IN xl_mergecells
			llReturn = True
		ELSE
			llReturn = False
		ENDIF
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llReturn
	ENDPROC

	PROTECTED PROCEDURE WriteSheetXMLs		&& Writes the Sheet XML files
		LPARAMETERS tnWB, tnSheetNbr, tnSheet, tcPath
		LOCAL llSuccess, lcAlias, lhFile, lcRow, lnMinCol, lnMaxCol, lnWidth, lnLastRow
		llSuccess = False
		*-*	Write the sheet XML
		IF this.GetSheetRecord(tnWB, tnSheet)
			IF xl_sheets.shdeleted
				RETURN True
			ENDIF
			lcAlias = ALIAS()
		*-*	Write the sheet
			TRY
				lhFile = FCREATE(tcPath + "xl\worksheets\sheet" + TRANSFORM(tnSheetNbr) + ".xml")
				IF lhFile < 0
					RETURN False
				ENDIF
		
		*-*		Write sheet XML header information
				FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
				FWRITE(lhFile, '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"')
				FWRITE(lhFile, ' xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"')
				FWRITE(lhFile, ' xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac"')
				FWRITE(lhFile, ' xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">')
		
		*-*		Verify cells have been written
				SELECT xl_cells
				LOCATE FOR workbook = tnWB .AND. sheet = tnSheet .AND. !celldeleted
				IF FOUND()
		*-*			Write the sheet view information which includes the freeze pane information
					SELECT cel.sheet, MAX(cel.cellrow) AS maxrow, MAX(cel.cellcol) AS maxcol ;
						FROM xl_cells AS cel ;
						WHERE cel.workbook = tnWB ;
							AND cel.sheet = tnSheet ;
							AND cel.celldeleted = False ;
						GROUP BY 1 ;
						INTO CURSOR t_max READWRITE
			
					FWRITE(lhFile, '<dimension ref="A1:' + this.ColumnIndexToAscii(t_max.maxcol) + TRANSFORM(t_max.maxrow) + '"/>')
					DO CASE
						CASE xl_sheets.ysplit > 0 .AND. xl_sheets.xsplit = 0      && Freeze top row(s) only
							FWRITE(lhFile, '<sheetViews><sheetView workbookViewId="0">')
							lcRow = TRANSFORM(xl_sheets.ysplit+1)
							FWRITE(lhFile, '<pane state="frozenSplit" activePane="bottomLeft" topLeftCell="A' + lcRow + '" ySplit="' + TRANSFORM(xl_sheets.ysplit) + '"/>')
							FWRITE(lhFile, '<selection activeCell="A' + lcRow + '" sqref="A' + lcRow + '" pane="bottomLeft"/>')
			
						CASE xl_sheets.ysplit = 0 .AND. xl_sheets.xsplit > 0      && Freeze side column(s) only
							FWRITE(lhFile, '<sheetViews><sheetView workbookViewId="0">')
							lcColumn = this.ColumnIndexToAscii(xl_sheets.xsplit+1)
							FWRITE(lhFile, '<pane state="frozenSplit" activePane="bottomLeft" topLeftCell="' + lcColumn + '1" xSplit="' + TRANSFORM(xl_sheets.xsplit) + '"/>')
							FWRITE(lhFile, '<selection activeCell="' + lcColumn + '1" sqref="' + lcColumn + '1" pane="topRight"/>')
			
						CASE xl_sheets.ysplit > 0 .AND. xl_sheets.xsplit > 0      && Freeze both top row(s) and side column(s)
							FWRITE(lhFile, '<sheetViews><sheetView workbookViewId="0">')
							lcRow = TRANSFORM(xl_sheets.ysplit+1)
							lcColumn = this.ColumnIndexToAscii(xl_sheets.xsplit+1)
							FWRITE(lhFile, '<pane state="frozenSplit" activePane="bottomRight" topLeftCell="' + lcColumn + lcRow + ;
								'" ySplit="' + TRANSFORM(xl_sheets.ysplit) + '" xSplit="' + TRANSFORM(xl_sheets.xsplit) + '"/>')
							FWRITE(lhFile, '<selection activeCell="' + this.ColumnIndexToAscii(xl_sheets.xsplit) + '1" sqref="' + this.ColumnIndexToAscii(xl_sheets.xsplit) + '1" pane="topRight"/>')
							FWRITE(lhFile, '<selection activeCell="' + this.ColumnIndexToAscii(xl_sheets.xsplit) + lcRow + '" sqref="' + this.ColumnIndexToAscii(xl_sheets.xsplit) + lcRow + '" pane="bottomLeft"/>')
							FWRITE(lhFile, '<selection activeCell="' + lcColumn + lcRow + '" sqref="' + lcColumn + lcRow + '" pane="bottomRight"/>')
			
						OTHERWISE
							FWRITE(lhFile, '<sheetViews><sheetView workbookViewId="0"><selection activeCell="A1" sqref="A1"/>')
		*					FWRITE(lhFile, '<sheetViews><sheetView tabSelected="1" workbookViewId="0">')
					ENDCASE
					FWRITE(lhFile, '</sheetView></sheetViews>')
					FWRITE(lhFile, '<sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>')
		
		*-*			Write sheet Column widths
					SELECT clm.column, clm.width, clm.bestfit FROM xl_colwidths AS clm ;
						WHERE clm.workbook = tnWB ;
							AND clm.sheet = tnSheet ;
						ORDER BY clm.column ;
						INTO CURSOR t_colwidths READWRITE
					
					IF _TALLY > 0
						FWRITE(lhFile, '<cols>')
						SELECT t_colwidths
						GOTO TOP
						lnMinCol = t_colwidths.column
						lnMaxCol = t_colwidths.column
						lnWidth  = t_colwidths.width
						SKIP IN t_colwidths
						DO WHILE !EOF('t_colwidths')
							DO CASE
		*						CASE t_colwidths.bestfit    && Not yet working!!!
		*							FWRITE(lhFile, '<col min="' + TRANSFORM(t_colwidths.column) + '" max="' + TRANSFORM(t_colwidths.column) + '" bestFit="1" customWidth="1"/>')
		
								CASE t_colwidths.width = lnWidth .AND. t_colwidths.column-1 = lnMinCol
									lnMaxCol = t_colwidths.column
								
								OTHERWISE
									FWRITE(lhFile, '<col min="' + TRANSFORM(lnMinCol) + '" max="' + TRANSFORM(lnMaxCol) + ;
										'" width="' + TRANSFORM(lnWidth+0.7109375) + '" customWidth="1"/>')
									lnMinCol = t_colwidths.column
									lnMaxCol = t_colwidths.column
									lnWidth  = t_colwidths.width
							ENDCASE
							SKIP IN t_colwidths
						ENDDO
						FWRITE(lhFile, '<col min="' + TRANSFORM(lnMinCol) + '" max="' + TRANSFORM(lnMaxCol) + '" width="' + TRANSFORM(lnWidth+0.7109375) + '" customWidth="1"/>')
						FWRITE(lhFile, '</cols>')
					ENDIF
					USE IN SELECT('t_colwidths')
		
		*-*			Write sheet cell data values
					FWRITE(lhFile, '<sheetData>')
					lnLastRow = 0
					lnHeadRow = 0
					SELECT xl_cells
					SET ORDER TO TAG cellindex
					SCAN FOR workbook = tnWB .AND. sheet = tnSheet .AND. !celldeleted
		*-*				Add any missing rows
						IF xl_cells.cellrow - lnLastRow > 1
							IF lnLastRow = 0
								lnLastRow = 1
							ENDIF
							DO WHILE lnLastRow != xl_cells.cellrow
								IF SEEK(this.GetRowHeightKeyExpr(tnWB, tnSheet, lnLastRow), "xl_rowheights", "shrow")
									FWRITE(lhFile, '<row r="' + TRANSFORM(lnLastRow) + '" spans="1:1" ht="' + TRANSFORM(xl_rowheights.height) + '" customHeight="1" x14ac:dyDescent="0.25"/>')
								ELSE
									FWRITE(lhFile, '<row r="' + TRANSFORM(lnLastRow) + '" spans="1:1" x14ac:dyDescent="0.25"/>')
								ENDIF
								lnLastRow = lnLastRow + 1
							ENDDO
						ELSE
							lnLastRow = xl_cells.cellrow
						ENDIF
		*-*				Write row header
						IF lnHeadRow != xl_cells.cellrow
							IF lnHeadRow != 0
								FWRITE(lhFile, '</row>')
							ENDIF
							lnHeadRow = xl_cells.cellrow
							IF SEEK(this.GetRowHeightKeyExpr(tnWB, tnSheet, xl_cells.cellrow), "xl_rowheights", "shrow")
								FWRITE(lhFile, '<row r="' + TRANSFORM(xl_cells.cellrow) + '" spans="1:' + TRANSFORM(t_max.maxcol) + ;
									'" ht="' + TRANSFORM(xl_rowheights.height) + '" customHeight="1" x14ac:dyDescent="0.25">')
							ELSE
								FWRITE(lhFile, '<row r="' + TRANSFORM(xl_cells.cellrow) + '" spans="1:' + TRANSFORM(t_max.maxcol) + '" x14ac:dyDescent="0.25">')
							ENDIF
						ENDIF
		*-*				Write columns
						IF xl_cells.cellxfs > 0
							lcStyle = ' s="' + TRANSFORM(xl_cells.cellxfs) + '"'
						ELSE
							lcStyle = ''
						ENDIF
						DO CASE
							CASE xl_cells.datatype = DATA_TYPE_TIME
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '"' + ;
									lcStyle + '><v>' + ALLTRIM(xl_cells.cellvalue) + '</v></c>')
		
							CASE xl_cells.datatype = DATA_TYPE_DATE
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '"' + ;
									lcStyle + '><v>' + ALLTRIM(xl_cells.cellvalue) + '</v></c>')
			
							CASE xl_cells.datatype = DATA_TYPE_DATETIME
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '"' + ;
									lcStyle + '><v>' + ALLTRIM(xl_cells.cellvalue) + '</v></c>')
		
							CASE xl_cells.datatype = DATA_TYPE_LOGICAL
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '" t="s"' + ;
									lcStyle + '><v>' + TRANSFORM(xl_cells.stringid) + '</v></c>')
			
							CASE xl_cells.datatype = DATA_TYPE_CHAR
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '" t="s"' + ;
									lcStyle + '><v>' + TRANSFORM(xl_cells.stringid) + '</v></c>')
			
							CASE xl_cells.datatype = DATA_TYPE_INT
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '"' + ;
									lcStyle + '><v>' + ALLTRIM(xl_cells.cellvalue) + '</v></c>')
			
							CASE xl_cells.datatype = DATA_TYPE_FLOAT
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '"' + ;
									lcStyle + '><v>' + ALLTRIM(xl_cells.cellvalue) + '</v></c>')
			
							CASE xl_cells.datatype = DATA_TYPE_CURRENCY
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '"' + ;
									lcStyle + '><v>' + ALLTRIM(xl_cells.cellvalue) + '</v></c>')
			
							CASE xl_cells.datatype = DATA_TYPE_PERCENT
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '"' + ;
									lcStyle + '><v>' + ALLTRIM(xl_cells.cellvalue) + '</v></c>')
			
							CASE xl_cells.datatype = DATA_TYPE_FORMULA
								FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '" t="str"' + ;
									lcStyle + '><f>' + ALLTRIM(xl_cells.cellformula) + '</f><v>' + ALLTRIM(xl_cells.cellvalue) + '</v></c>')
			
							CASE xl_cells.datatype = DATA_TYPE_NONE
								IF !EMPTY(lcStyle)
									FWRITE(lhFile, '<c r="' + this.ColumnIndexToAscii(xl_cells.cellcol) + TRANSFORM(xl_cells.cellrow) + '"' + lcStyle + '><v/></c>')
								ENDIF
						ENDCASE
					ENDSCAN
					FWRITE(lhFile, '</row>')
					FWRITE(lhFile, '</sheetData>')
					SET ORDER TO
					USE IN t_max
		
				ELSE
		*-*			No cell data has been created/written
					FWRITE(lhFile, '<dimension ref="A1"/>')
					FWRITE(lhFile, '<sheetViews>')
					FWRITE(lhFile, '<sheetView workbookViewId="0"/>')
					FWRITE(lhFile, '</sheetViews>')
					FWRITE(lhFile, '<sheetFormatPr defaultRowHeight="14.4"/>')
					FWRITE(lhFile, '<sheetData/>')
				ENDIF
		*-*		Write sheet merge data
				SELECT mrg.begrow, mrg.begcol, mrg.endrow, mrg.endcol FROM xl_mergecells AS mrg ;
					WHERE mrg.workbook = tnWB ;
						AND mrg.sheet = tnSheet ;
					ORDER BY mrg.begrow ;
					INTO CURSOR t_merge
		
				IF _TALLY > 0
					FWRITE(lhFile, '<mergeCells>')
					SELECT t_merge
					SCAN
						FWRITE(lhFile, '<mergeCell ref="' + this.ColumnIndexToAscii(t_merge.begcol) + TRANSFORM(t_merge.begrow) + ':' + ;
							   this.ColumnIndexToAscii(t_merge.endcol) + TRANSFORM(t_merge.endrow) + '"/>')
					ENDSCAN
					FWRITE(lhFile, '</mergeCells>')
				ENDIF
				USE IN t_merge
		
		*-*		Write the cell validation data
				SELECT xl_validation
				COUNT FOR xl_validation.workbook = tnWB .AND. xl_validation.sheet = tnSheet .AND. !DELETED() TO lnValidCnt
				IF lnValidCnt > 0
					FWRITE(lhFile, '<dataValidations count="' + TRANSFORM(lnValidCnt) + '">')
					SCAN
						SELECT xl.cellrow, xl.cellcol FROM xl_cells AS xl ;
							WHERE BINTOC(xl.workbook)+BINTOC(xl.sheet)+BINTOC(xl.validndx) = BINTOC(tnWB)+BINTOC(tnSheet)+BINTOC(xl_validation.validndx) ;
							ORDER BY xl.cellrow, xl.cellcol ;
							INTO CURSOR t_celllist
						SELECT t_celllist
						lcSqRef = ""
						SCAN
							lcSqRef = lcSqRef + this.ColumnIndexToAscii(t_celllist.cellcol) + TRANSFORM(t_celllist.cellrow) + " "
						ENDSCAN
						lcSqRef = ALLTRIM(lcSqRef)
						DO CASE
							CASE xl_validation.vtype = NONE_VALID_TYPE
								lcValidationText = 'type="none"'
		
							CASE xl_validation.vtype = WHOLE_VALID_TYPE
								lcValidationText = 'type="whole"'
		
							CASE xl_validation.vtype = DECIMAL_VALID_TYPE
								lcValidationText = 'type="decimal"'
		
							CASE xl_validation.vtype = LIST_VALID_TYPE
								lcValidationText = 'type="list"'
		
							CASE xl_validation.vtype = DATE_VALID_TYPE
								lcValidationText = 'type="date"'
		
							CASE xl_validation.vtype = TIME_VALID_TYPE
								lcValidationText = 'type="time"'
		
							CASE xl_validation.vtype = TXTLEN_VALID_TYPE
								lcValidationText = 'type="textLength"'
		
							CASE xl_validation.vtype = CUSTOM_VALID_TYPE
								lcValidationText = 'type="custom"'
		
							OTHERWISE
								lcValidationText = 'type="none"'
						ENDCASE
						IF xl_validation.vstyle > 0
							DO CASE
								CASE xl_validation.vstyle = STOP_VALID_STYLE
									lcValidationText = lcValidationText + ' errorStyle="stop"'
		
								CASE xl_validation.vstyle = WARN_VALID_STYLE
									lcValidationText = lcValidationText + ' errorStyle="warning"'
		
								CASE xl_validation.vstyle = INFO_VALID_STYLE
									lcValidationText = lcValidationText + ' errorStyle="information"'
							ENDCASE
						ENDIF
						IF xl_validation.voperator > 0
							DO CASE
								CASE xl_validation.voperator = BETWEEN_VALID_OPER
									lcValidationText = lcValidationText + ' operator="between"'
		
								CASE xl_validation.voperator = NOTBETW_VALID_OPER
									lcValidationText = lcValidationText + ' operator="notBetween"'
		
								CASE xl_validation.voperator = EQUAL_VALID_OPER
									lcValidationText = lcValidationText + ' operator="equal"'
		
								CASE xl_validation.voperator = NOTEQUAL_VALID_OPER
									lcValidationText = lcValidationText + ' operator="notEqual"'
		
								CASE xl_validation.voperator = LESSTHAN_VALID_OPER
									lcValidationText = lcValidationText + ' operator="lessThan"'
		
								CASE xl_validation.voperator = LESSOREQUAL_VALID_OPER
									lcValidationText = lcValidationText + ' operator="lessThanOrEqual"'
		
								CASE xl_validation.voperator = GREATTHAN_VALID_OPER
									lcValidationText = lcValidationText + ' operator="greaterThan"'
		
								CASE xl_validation.voperator = GREATOREQUAL_VALID_OPER
									lcValidationText = lcValidationText + ' operator="greaterThanOrEqual"'
							ENDCASE
						ENDIF
						lcValidationText = lcValidationText + ' allowBlank="' + IIF(xl_validation.allowblank, '1', '0') + '"'
						lcValidationText = lcValidationText + ' showInputMessage="' + IIF(xl_validation.showinpmsg, '1', '0') + '"'
						lcValidationText = lcValidationText + ' showErrorMessage="' + IIF(xl_validation.showerrmsg, '1', '0') + '"'
						IF !EMPTY(xl_validation.errtitle)
							lcValidationText = lcValidationText + ' errorTitle="' + ALLTRIM(xl_validation.errtitle) + '"'
						ENDIF
						IF !EMPTY(xl_validation.errmsg)
							lcValidationText = lcValidationText + ' error="' + ALLTRIM(xl_validation.errmsg) + '"'
						ENDIF
						IF !EMPTY(xl_validation.vprompt)
							lcValidationText = lcValidationText + ' prompt="' + ALLTRIM(xl_validation.vprompt) + '"'
						ENDIF
						FWRITE(lhFile, '<dataValidation ' + lcValidationText + ' sqref="' + lcSqRef + '">')
						IF xl_validation.formula
							FWRITE(lhFile, '<formula1>' + ALLTRIM(xl_validation.formula1) + '</formula1>')
							IF !EMPTY(xl_validation.formula2)
								FWRITE(lhFile, '<formula2>' + ALLTRIM(xl_validation.formula2) + '</formula2>')
							ENDIF
						ELSE
							FWRITE(lhFile, '<formula1>"' + ALLTRIM(xl_validation.formula1) + '"</formula1>')
							IF !EMPTY(xl_validation.formula2)
								FWRITE(lhFile, '<formula2>"' + ALLTRIM(xl_validation.formula2) + '"</formula2>')
							ENDIF
						ENDIF
						FWRITE(lhFile, '</dataValidation>')
					ENDSCAN
					USE IN SELECT('t_celllist')
					FWRITE(lhFile, '</dataValidations>')
				ENDIF
		
		*-*		Write sheet margin data
				FWRITE(lhFile, '<pageMargins left="' + RTRIM(TRANSFORM(xl_sheets.mleft), 1, '0') + '" right="' + RTRIM(TRANSFORM(xl_sheets.mright), 1, '0') + ;
					'" top="' + RTRIM(TRANSFORM(xl_sheets.mtop), 1, '0') + '" bottom="' + RTRIM(TRANSFORM(xl_sheets.mbot), 1, '0') + ;
					'" header="' + RTRIM(TRANSFORM(xl_sheets.mheader), 1, '0') + '" footer="' + RTRIM(TRANSFORM(xl_sheets.mfooter), 1, '0') + '"/>')
		
		*-*		Write the sheet page print setup
				FWRITE(lhFile, '<pageSetup orientation="' + IIF(xl_sheets.prnorient=PORTRAIT_PRINT_ORIENTATION, 'portrait', 'landscape') + '"')
				IF xl_sheets.paperwidth > 0 .AND. xl_sheets.paperheight > 0
					FWRITE(lhFile, ' paperHeight="' + TRANSFORM(xl_sheets.paperheight) + xl_sheets.paperdimen + '"')
					FWRITE(lhFile, ' paperWidth="' + TRANSFORM(xl_sheets.paperwidth) + xl_sheets.paperdimen + '"')
				ELSE
					IF xl_sheets.papersize > 0
						FWRITE(lhFile, ' paperSize="' + TRANSFORM(xl_sheets.papersize) + '"')
					ENDIF
				ENDIF
				DO CASE
					CASE xl_sheets.fittowidth > 0 .AND. xl_sheets.fittoheight > 0
						FWRITE(lhFile, ' fitToWidth="'  + TRANSFORM(xl_sheets.fittowidth) + '"')
						FWRITE(lhFile, ' fitToHeight="' + TRANSFORM(xl_sheets.fittoheight) + '"')
		
					CASE xl_sheets.fittowidth = 0 .AND. xl_sheets.fittoheight > 0
						FWRITE(lhFile, ' fitToHeight="' + TRANSFORM(xl_sheets.fittoheight) + '"')
		
					CASE xl_sheets.fittowidth > 0 .AND. xl_sheets.fittoheight = 0
						FWRITE(lhFile, ' fitToWidth="'  + TRANSFORM(xl_sheets.fittowidth) + '"')
					
					OTHERWISE
						IF xl_sheets.scale != 100
							FWRITE(lhFile, ' scale="' + TRANSFORM(xl_sheets.scale) + '"')
						ENDIF
				ENDCASE
				FWRITE(lhFile, '/>')
		
		*-*		Write the header and footer for the sheet if defined
				IF SEEK(BINTOC(tnWB)+BINTOC(tnSheet), "xl_hdrfooterdefn", "wbsheet")
					FWRITE(lhFile, '<headerFooter')
					IF xl_hdrfooterdefn.alignmargin
						FWRITE(lhFile, ' alignWithMargins="1"')
					ENDIF
					IF xl_hdrfooterdefn.difffirstpg
						FWRITE(lhFile, ' differentFirst="1"')
					ENDIF
					IF xl_hdrfooterdefn.diffoddeven
						FWRITE(lhFile, ' differentOddEven="1"')
					ENDIF
					IF xl_hdrfooterdefn.scalewdoc
						FWRITE(lhFile, ' scaleWithDoc="1"')
					ENDIF
					FWRITE(lhFile, '>')
		
		*-*			Get the page header text
					lcOddText = ""
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_HDR_LEFT), "xl_hdrfootertext", "hdrfootr")
						lcOddText = IIF(EMPTY(lcOddText), '<oddHeader>', lcOddText) + '&amp;L&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_HDR_CENTER), "xl_hdrfootertext", "hdrfootr")
						lcOddText = IIF(EMPTY(lcOddText), '<oddHeader>', lcOddText) + '&amp;C&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_HDR_RIGHT), "xl_hdrfootertext", "hdrfootr")
						lcOddText = IIF(EMPTY(lcOddText), '<oddHeader>', lcOddText) + '&amp;R&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF !EMPTY(lcOddText)
						lcOddText = lcOddText + '</oddHeader>'
					ENDIF
		
					lcEvenText = ""
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_HDR_LEFT), "xl_hdrfootertext", "hdrfootr")
						lcEvenText = IIF(EMPTY(lcEvenText), '<evenHeader>', lcEvenText) + '&amp;L&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_HDR_CENTER), "xl_hdrfootertext", "hdrfootr")
						lcEvenText = IIF(EMPTY(lcEvenText), '<evenHeader>', lcEvenText) + '&amp;C&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_HDR_RIGHT), "xl_hdrfootertext", "hdrfootr")
						lcEvenText = IIF(EMPTY(lcEvenText), '<evenHeader>', lcEvenText) + '&amp;R&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF !EMPTY(lcEvenText)
						lcEvenText = lcEvenText + '</evenHeader>'
					ENDIF
		
					lcSameText = ""
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_HDR_LEFT), "xl_hdrfootertext", "hdrfootr")
						lcSameText = IIF(EMPTY(lcSameText), '<oddHeader>', lcSameText) + '&amp;L&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_HDR_CENTER), "xl_hdrfootertext", "hdrfootr")
						lcSameText = IIF(EMPTY(lcSameText), '<oddHeader>', lcSameText) + '&amp;C&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_HDR_RIGHT), "xl_hdrfootertext", "hdrfootr")
						lcSameText = IIF(EMPTY(lcSameText), '<oddHeader>', lcSameText) + '&amp;R&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF !EMPTY(lcSameText)
						lcSameText = lcSameText + '</oddHeader>'
					ENDIF
					IF EMPTY(lcSameText)
						lcHeaderText = lcOddText + lcEvenText
					ELSE
						lcHeaderText = lcSameText
					ENDIF
		
		*-*			Get the page footer text
					lcOddText = ""
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_FTR_LEFT), "xl_hdrfootertext", "hdrfootr")
						lcOddText = IIF(EMPTY(lcOddText), '<oddFooter>', lcOddText) + '&amp;L&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_FTR_CENTER), "xl_hdrfootertext", "hdrfootr")
						lcOddText = IIF(EMPTY(lcOddText), '<oddFooter>', lcOddText) + '&amp;C&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_ODD_PAGE, HEADERFOOTER_SECT_FTR_RIGHT), "xl_hdrfootertext", "hdrfootr")
						lcOddText = IIF(EMPTY(lcOddText), '<oddFooter>', lcOddText) + '&amp;R&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF !EMPTY(lcOddText)
						lcOddText = lcOddText + '</oddFooter>'
					ENDIF
		
					lcEvenText = ""
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_FTR_LEFT), "xl_hdrfootertext", "hdrfootr")
						lcEvenText = IIF(EMPTY(lcEvenText), '<evenFooter>', lcEvenText) + '&amp;L&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_FTR_CENTER), "xl_hdrfootertext", "hdrfootr")
						lcEvenText = IIF(EMPTY(lcEvenText), '<evenFooter>', lcEvenText) + '&amp;C&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_EVEN_PAGE, HEADERFOOTER_SECT_FTR_RIGHT), "xl_hdrfootertext", "hdrfootr")
						lcEvenText = IIF(EMPTY(lcEvenText), '<evenFooter>', lcEvenText) + '&amp;R&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF !EMPTY(lcEvenText)
						lcEvenText = lcEvenText + '</evenFooter>'
					ENDIF
		
					lcSameText = ""
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_FTR_LEFT), "xl_hdrfootertext", "hdrfootr")
						lcSameText = IIF(EMPTY(lcSameText), '<oddFooter>', lcSameText) + '&amp;L&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_FTR_CENTER), "xl_hdrfootertext", "hdrfootr")
						lcSameText = IIF(EMPTY(lcSameText), '<oddFooter>', lcSameText) + '&amp;C&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_SAME_PAGE, HEADERFOOTER_SECT_FTR_RIGHT), "xl_hdrfootertext", "hdrfootr")
						lcSameText = IIF(EMPTY(lcSameText), '<oddFooter>', lcSameText) + '&amp;R&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF !EMPTY(lcSameText)
						lcSameText = lcSameText + '</oddFooter>'
					ENDIF
					IF EMPTY(lcSameText)
						lcFooterText = lcOddText + lcEvenText
					ELSE
						lcFooterText = lcSameText
					ENDIF
		
		*-*			Get the first page text
					lcFirstHdrText = ""
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_HDR_LEFT), "xl_hdrfootertext", "hdrfootr")
						lcFirstHdrText = IIF(EMPTY(lcFirstHdrText), '<firstHeader>', lcFirstHdrText) + '&amp;L&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_HDR_CENTER), "xl_hdrfootertext", "hdrfootr")
						lcFirstHdrText = IIF(EMPTY(lcFirstHdrText), '<firstHeader>', lcFirstHdrText) + '&amp;C&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_HDR_RIGHT), "xl_hdrfootertext", "hdrfootr")
						lcFirstHdrText = IIF(EMPTY(lcFirstHdrText), '<firstHeader>', lcFirstHdrText) + '&amp;R&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF !EMPTY(lcFirstHdrText)
						lcFirstHdrText = lcFirstHdrText + '</firstHeader>'
					ENDIF
		
					lcFirstFtrText = ""
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_FTR_LEFT), "xl_hdrfootertext", "hdrfootr")
						lcFirstFtrText = IIF(EMPTY(lcFirstFtrText), '<firstFooter>', lcFirstFtrText) + '&amp;L&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_FTR_CENTER), "xl_hdrfootertext", "hdrfootr")
						lcFirstFtrText = IIF(EMPTY(lcFirstFtrText), '<firstFooter>', lcFirstFtrText) + '&amp;C&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF SEEK(this.GetHeaderFooterKeyExpr(tnWB, tnSheet, HEADERFOOTER_FIRST_PAGE, HEADERFOOTER_SECT_FTR_RIGHT), "xl_hdrfootertext", "hdrfootr")
						lcFirstFtrText = IIF(EMPTY(lcFirstFtrText), '<firstFooter>', lcFirstFtrText) + '&amp;R&amp;' + this.GetXMLHeaderFooterText()
					ENDIF
					IF !EMPTY(lcFirstFtrText)
						lcFirstFtrText = lcFirstFtrText + '</firstFooter>'
					ENDIF
		*-*			Write the header/footer text to XML
					FWRITE(lhFile, lcHeaderText + lcFooterText + lcFirstHdrText + lcFirstFtrText + '</headerFooter>')
				ENDIF
		*-*		Completed writing sheet
				FWRITE(lhFile, '</worksheet>')
				llSuccess = True
		
			CATCH TO loException
				llSuccess = False
				SET STEP ON
				MESSAGEBOX(loException.message)
		
			FINALLY
				FCLOSE(lhFile)
			ENDTRY
			IF !EMPTY(lcAlias)
				SELECT &lcAlias
			ENDIF
		ENDIF
		RETURN llSuccess
	ENDPROC

	PROTECTED PROCEDURE WriteStylesXML		&& Writes the styles.xml support file
		LPARAMETERS tnWB, tcPath
		LOCAL lcAlias, lcFileName, lhFile, lnNumFmtsId, lnRecCount, lcNumFmtId, lcFormatCode, lnRotation
		TRY
			lcAlias = ALIAS()
			lcFileName = tcPath + "xl\styles.xml"
			lhFile = FCREATE(lcFileName)
			IF lhFile < 0
				THROW 11
			ENDIF
			FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
			FWRITE(lhFile, '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" ')
			FWRITE(lhFile, 'xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" ')
			FWRITE(lhFile, 'mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">')
		
		*-*	Write the Number format section
			lnNumFmtsId = 164
			SELECT xl_numfmts
			SET ORDER TO TAG sortorder
			COUNT FOR workbook = tnWB TO lnRecCount
			FWRITE(lhFile, '<numFmts count="' + TRANSFORM(lnRecCount) + '">')
			SCAN FOR workbook = tnWB
				lcFormatCode = ALLTRIM(xl_numfmts.posformat)
				IF !EMPTY(xl_numfmts.negformat)
					lcFormatCode = lcFormatCode + ";" + ALLTRIM(xl_numfmts.negformat)
				ENDIF
				IF !EMPTY(xl_numfmts.zeroformat)
					lcFormatCode = lcFormatCode + ";" + ALLTRIM(xl_numfmts.zeroformat)
				ENDIF
				IF !EMPTY(xl_numfmts.textformat)
					lcFormatCode = lcFormatCode + ";" + ALLTRIM(xl_numfmts.textformat)
				ENDIF
				IF xl_numfmts.id > 900
					lnNumFmtsId = lnNumFmtsId + 1
					FWRITE(lhFile, '<numFmt numFmtId="' + TRANSFORM(lnNumFmtsId) + '" formatCode="' + lcFormatCode + '"/>')
				ELSE
					lnNumFmtsId = xl_numfmts.id
					FWRITE(lhFile, '<numFmt numFmtId="' + TRANSFORM(xl_numfmts.id) + '" formatCode="' + lcFormatCode + '"/>')
				ENDIF
				REPLACE xl_numfmts.tempid WITH lnNumFmtsId IN xl_numfmts
			ENDSCAN
			FWRITE(lhFile, '</numFmts>')
			SET ORDER TO
		
		*-*	Write the fonts section
			SELECT xl_fonts
			SET ORDER TO TAG sortorder
			COUNT FOR workbook = tnWB TO lnRecCount
			FWRITE(lhFile, '<fonts count="' + TRANSFORM(lnRecCount) + '" x14ac:knownFonts="1">')
			SCAN FOR workbook = tnWB
				FWRITE(lhFile, '<font>')
				FWRITE(lhFile, '<name val="' + ALLTRIM(xl_fonts.fname) + '"/>')
				FWRITE(lhFile, '<sz val="' + TRANSFORM(xl_fonts.fsize) + '"/>')
				IF xl_fonts.fbold
					FWRITE(lhFile, '<b/>')
				ENDIF
				IF xl_fonts.fitalic
					FWRITE(lhFile, '<i/>')
				ENDIF
				IF !EMPTY(xl_fonts.uline)
					FWRITE(lhFile, '<u val="' + ALLTRIM(xl_fonts.uline) + '"/>')
				ENDIF
				IF xl_fonts.strkthr
					FWRITE(lhFile, '<strike/>')
				ENDIF
				IF !EMPTY(xl_fonts.fvpos)
					FWRITE(lhFile, '<vertAlign val="' + ALLTRIM(xl_fonts.fvpos) + '"/>')
				ENDIF
				DO CASE
					CASE xl_fonts.fcolor > 0
						FWRITE(lhFile, '<color rgb="' + this.ConvertColorToHex(xl_fonts.fcolor) + '"/>')
		
					CASE xl_fonts.indexed > 0
						FWRITE(lhFile, '<color indexed="' + TRANSFORM(xl_fonts.indexed) + '"/>')
					
					CASE xl_fonts.theme > 0
						FWRITE(lhFile, '<color theme="' + TRANSFORM(xl_fonts.theme) + '" tint="' + TRANSFORM(xl_fonts.tint, "99.999999999999999") + '"/>')
				ENDCASE
				FWRITE(lhFile, '</font>')
			ENDSCAN
			FWRITE(lhFile, '</fonts>')
			SET ORDER TO
		
		*-*	Write the fills section
			SELECT xl_fills
			SET ORDER TO TAG sortorder
			COUNT FOR workbook = tnWB TO lnRecCount
			FWRITE(lhFile, '<fills count="' + TRANSFORM(lnRecCount) + '">')
			SCAN FOR workbook = tnWB
				FWRITE(lhFile, '<fill><patternFill patternType="' + ALLTRIM(xl_fills.patttype) + '"')
				DO CASE
					CASE xl_fills.fgindexed > 0 .AND. xl_fills.bgindexed > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<fgColor indexed="' + TRANSFORM(xl_fills.fgindexed) + '"/>')
						FWRITE(lhFile, '<bgColor indexed="' + TRANSFORM(xl_fills.bgindexed) + '"/>')
						FWRITE(lhFile, '</patternFill>')
		
					CASE xl_fills.fgcolor > 0 .AND. xl_fills.bgindexed > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<fgColor rgb="' + this.ConvertColorToHex(xl_fills.fgcolor) + '"/>')
						FWRITE(lhFile, '<bgColor indexed="' + TRANSFORM(xl_fills.bgindexed) + '"/>')
						FWRITE(lhFile, '</patternFill>')
					
					CASE xl_fills.bgcolor > 0 .AND. xl_fills.fgindexed > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<fgColor indexed="' + TRANSFORM(xl_fills.fgindexed) + '"/>')
						FWRITE(lhFile, '<bgColor rgb="' + this.ConvertColorToHex(xl_fills.bgcolor) + '"/>')
						FWRITE(lhFile, '</patternFill>')
		
					CASE xl_fills.fgcolor > 0 .AND. xl_fills.bgcolor > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<fgColor rgb="' + this.ConvertColorToHex(xl_fills.fgcolor) + '"/>')
						FWRITE(lhFile, '<bgColor rgb="' + this.ConvertColorToHex(xl_fills.bgcolor) + '"/>')
						FWRITE(lhFile, '</patternFill>')
		
					CASE xl_fills.theme > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<fgColor theme="' + TRANSFORM(xl_fills.theme) + '" tint="' + TRANSFORM(xl_fills.tint, "99.999999999999999") + '"/>')
						FWRITE(lhFile, '<bgColor indexed="64"/>')
						FWRITE(lhFile, '</patternFill>')
					
					OTHERWISE
						FWRITE(lhFile, '/>')
				ENDCASE
				FWRITE(lhFile, '</fill>')
			ENDSCAN
			FWRITE(lhFile, '</fills>')
		
		*-*	Write the borders section
			SELECT xl_borders
			SET ORDER TO TAG sortorder
			COUNT FOR workbook = tnWB TO lnRecCount
			FWRITE(lhFile, '<borders count="' + TRANSFORM(lnRecCount) + '">')
			SCAN FOR workbook = tnWB
				FWRITE(lhFile, '<border' + IIF(xl_borders.diagdn=1, ' diagonalDown="1"', '') + IIF(xl_borders.diagup=1, ' diagonalUp="1"', '') +'>')
				IF xl_borders.lstyle = BORDER_STYLE_NONE
					FWRITE(lhFile, '<left')
				ELSE
					FWRITE(lhFile, '<left style="' + ALLTRIM(xl_borders.lstyle) + '"')
				ENDIF
				DO CASE
					CASE xl_borders.lcolor > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color rgb="' + this.ConvertColorToHex(xl_borders.lcolor) + '"/>')
						FWRITE(lhFile, '</left>')
			
					CASE xl_borders.lindexed > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color indexed="' + TRANSFORM(xl_borders.lindexed) + '"/>')
						FWRITE(lhFile, '</left>')
		
					CASE xl_borders.ltheme > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color theme="' + TRANSFORM(xl_borders.ltheme) +'" tint="' + TRANSFORM(xl_borders.ltint, "99.999999999999999") + '"/>')
						FWRITE(lhFile, '</left>')
					
					OTHERWISE
						FWRITE(lhFile, '/>')
				ENDCASE
				IF xl_borders.rstyle = BORDER_STYLE_NONE
					FWRITE(lhFile, '<right')
				ELSE
					FWRITE(lhFile, '<right style="' + ALLTRIM(xl_borders.rstyle) + '"')
				ENDIF
				DO CASE
					CASE xl_borders.rcolor > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color rgb="' + this.ConvertColorToHex(xl_borders.rcolor) + '"/>')
						FWRITE(lhFile, '</right>')
		
					CASE xl_borders.rindexed > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color indexed="' + TRANSFORM(xl_borders.rindexed) + '"/>')
						FWRITE(lhFile, '</right>')
		
		
					CASE xl_borders.rtheme > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color theme="' + TRANSFORM(xl_borders.rtheme) +'" tint="' + TRANSFORM(xl_borders.rtint, "99.999999999999999") + '"/>')
						FWRITE(lhFile, '</right>')
		
					OTHERWISE
						FWRITE(lhFile, '/>')
				ENDCASE
				IF xl_borders.tstyle = BORDER_STYLE_NONE
					FWRITE(lhFile, '<top')
				ELSE
					FWRITE(lhFile, '<top style="' + ALLTRIM(xl_borders.tstyle) + '"')
				ENDIF
				DO CASE
					CASE xl_borders.tcolor > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color rgb="' + this.ConvertColorToHex(xl_borders.tcolor) + '"/>')
						FWRITE(lhFile, '</top>')
			
					CASE xl_borders.tindexed > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color indexed="' + TRANSFORM(xl_borders.tindexed) + '"/>')
						FWRITE(lhFile, '</top>')
		
					CASE xl_borders.ttheme > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color theme="' + TRANSFORM(xl_borders.ttheme) +'" tint="' + TRANSFORM(xl_borders.ttint, "99.999999999999999") + '"/>')
						FWRITE(lhFile, '</top>')
		
					OTHERWISE
						FWRITE(lhFile, '/>')
				ENDCASE
				IF xl_borders.bstyle = BORDER_STYLE_NONE
					FWRITE(lhFile, '<bottom')
				ELSE
					FWRITE(lhFile, '<bottom style="' + ALLTRIM(xl_borders.bstyle) + '"')
				ENDIF
				DO CASE
					CASE xl_borders.bcolor > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color rgb="' + this.ConvertColorToHex(xl_borders.bcolor) + '"/>')
						FWRITE(lhFile, '</bottom>')
			
					CASE xl_borders.bindexed > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color indexed="' + TRANSFORM(xl_borders.bindexed) + '"/>')
						FWRITE(lhFile, '</bottom>')
		
					CASE xl_borders.btheme > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color theme="' + TRANSFORM(xl_borders.btheme) +'" tint="' + TRANSFORM(xl_borders.btint, "99.999999999999999") + '"/>')
						FWRITE(lhFile, '</bottom>')
		
					OTHERWISE
						FWRITE(lhFile, '/>')
				ENDCASE
				IF xl_borders.dstyle = BORDER_STYLE_NONE
					FWRITE(lhFile, '<diagonal')
				ELSE
					FWRITE(lhFile, '<diagonal style="' + ALLTRIM(xl_borders.dstyle) + '"')
				ENDIF
				DO CASE
					CASE xl_borders.dcolor > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color rgb="' + this.ConvertColorToHex(xl_borders.dcolor) + '"/>')
						FWRITE(lhFile, '</diagonal>')
		
					CASE xl_borders.dindexed > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color indexed="' + TRANSFORM(xl_borders.dindexed) + '"/>')
						FWRITE(lhFile, '</diagonal>')
		
					CASE xl_borders.dtheme > 0
						FWRITE(lhFile, '>')
						FWRITE(lhFile, '<color theme="' + TRANSFORM(xl_borders.dtheme) +'" tint="' + TRANSFORM(xl_borders.dtint, "99.999999999999999") + '"/>')
						FWRITE(lhFile, '</diagonal>')
		
					OTHERWISE
						FWRITE(lhFile, '/>')
				ENDCASE
				FWRITE(lhFile, '</border>')
			ENDSCAN
			FWRITE(lhFile, '</borders>')
		*-*	Write the cellStyleXfs section
		
		*-*	Write the cellXfs section
			SELECT xl_cellxfs
			SET ORDER TO TAG sortorder
			COUNT FOR workbook = tnWB TO lnRecCount
			FWRITE(lhFile, '<cellXfs count="' + TRANSFORM(lnRecCount) + '">')
			SCAN FOR workbook = tnWB
				IF xl_cellxfs.numFmtId > 0 .AND. SEEK(BINTOC(tnWB)+BINTOC(xl_cellxfs.numFmtId), "xl_numfmts", "id")
					lcNumFmtId = TRANSFORM(xl_numfmts.tempid)
				ELSE
					lcNumFmtId = TRANSFORM(xl_cellxfs.numFmtId)
				ENDIF
				FWRITE(lhFile, '<xf numFmtId="' + lcNumFmtId + '" fontId="' + TRANSFORM(xl_cellxfs.fontid) + ;
						'" fillId="' + TRANSFORM(xl_cellxfs.fillid) + '" borderId="' + TRANSFORM(xl_cellxfs.borderid) + '"' + ;
						IIF(lcNumFmtId = '0', '', ' applyNumberFormat="1"') + IIF(xl_cellxfs.fontid > 0, ' applyFont="1"', '') + ;
						IIF(xl_cellxfs.fillid > 0, ' applyFill="1"', '') + IIF(xl_cellxfs.borderid > 0, ' applyBorder="1"', '') + ' applyAlignment="1"')
		
				IF !EMPTY(xl_cellxfs.halign) .OR. !EMPTY(xl_cellxfs.valign) .OR. xl_cellxfs.wraptext > 0 .OR. xl_cellxfs.indent > 0 .OR. xl_cellxfs.rotation > 0
					FWRITE(lhFile, '><alignment')
					IF !EMPTY(xl_cellxfs.halign)
						FWRITE(lhFile, ' horizontal="' + ALLTRIM(xl_cellxfs.halign) + '"')
					ENDIF
					IF !EMPTY(xl_cellxfs.valign)
						FWRITE(lhFile, ' vertical="' + ALLTRIM(xl_cellxfs.valign) + '"')
					ENDIF
					IF xl_cellxfs.wraptext > 0
						FWRITE(lhFile, ' wrapText="1"')
					ENDIF
					IF xl_cellxfs.indent > 0
						FWRITE(lhFile, ' indent="' + TRANSFORM(xl_cellxfs.indent) + '"')
					ENDIF
					IF xl_cellxfs.rotation != 0
						FWRITE(lhFile, ' textRotation="' + TRANSFORM(xl_cellxfs.rotation) + '"')
					ENDIF
					FWRITE(lhFile, '/></xf>')
				ELSE
					FWRITE(lhFile, '/>')
				ENDIF
			ENDSCAN
			FWRITE(lhFile, '</cellXfs>')
		
			FWRITE(lhFile, '</styleSheet>')
			FCLOSE(lhFile)
			llSuccess = True
			STRTOFILE(FILETOSTR(lcFileName), lcFileName, 4)      && Save as UTF-8
		
		CATCH TO loException
			SET STEP ON
			llSuccess = False
		
		ENDTRY
		IF !EMPTY(lcAlias)
			SELECT &lcAlias
		ENDIF
		RETURN llSuccess
	ENDPROC

	PROTECTED PROCEDURE WriteSupportXMLs		&& Writes the [Content_Types].xml, .rels, core.xml, workbook.xml.rels and app.xml files
		LPARAMETERS tnWB, tcPath, toSheets
		LOCAL llSuccess, loException, lhFile, lnSheet, lnUniqueCnt, lcCurr, lcColor, lnTotCount, lcFileName
		TRY
			lhFile  = FCREATE(tcPath + "[Content_Types].xml")
			IF lhFile < 0
				THROW 11
			ENDIF
			FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
			FWRITE(lhFile, '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">')
			FWRITE(lhFile, '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>')
			FWRITE(lhFile, '<Default Extension="xml" ContentType="application/xml"/>')
			FWRITE(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" PartName="/xl/workbook.xml"/>')
			FOR lnSheet=1 TO toSheets.Count
				FWRITE(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" PartName="/xl/worksheets/sheet' + TRANSFORM(lnSheet) + '.xml"/>')
			ENDFOR
			FWRITE(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" PartName="/xl/styles.xml"/>')
			FWRITE(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" PartName="/xl/sharedStrings.xml"/>')
			FWRITE(lhFile, '<Override ContentType="application/vnd.openxmlformats-package.core-properties+xml" PartName="/docProps/core.xml"/>')
			FWRITE(lhFile, '<Override ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" PartName="/docProps/app.xml"/>')
			FWRITE(lhFile, '</Types>')
			FCLOSE(lhFile)
		
			lhFile = FCREATE(tcPath + "_rels\.rels")
			IF lhFile < 0
				THROW 11
			ENDIF
			FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
			FWRITE(lhFile, '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">')
			FWRITE(lhFile, '<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>')
			FWRITE(lhFile, '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>')
			FWRITE(lhFile, '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>')
			FWRITE(lhFile, '</Relationships>')
			FCLOSE(lhFile)
		
			lcFileName = tcPath + "docProps\app.xml"
			lhFile = FCREATE(lcFileName)
			IF lhFile < 0
				THROW 11
			ENDIF
			FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
			FWRITE(lhFile, '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">')
			FWRITE(lhFile, '<Application>ExcelXMLX Release ' + TRANSFORM(this.ExcelXlsxRelease) + '</Application>')
			IF !EMPTY(this.CompanyName)
				FWRITE(lhFile, '<Company>' + this.CompanyName + '</Company>')
			ENDIF
			FWRITE(lhFile, '</Properties>')
			FCLOSE(lhFile)
			STRTOFILE(STRCONV(FILETOSTR(lcFileName), 9), lcFileName, 4)      && Save as UTF-8
		
			lcFileName = tcPath + "docProps\core.xml"
			lhFile = FCREATE(lcFileName)
			IF lhFile < 0
				THROW 11
			ENDIF
			FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
			FWRITE(lhFile, '<cp:coreProperties ')
			FWRITE(lhFile, 'xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" ')
			FWRITE(lhFile, 'xmlns:dc="http://purl.org/dc/elements/1.1/" ')
			FWRITE(lhFile, 'xmlns:dcterms="http://purl.org/dc/terms/" ')
			FWRITE(lhFile, 'xmlns:dcmitype="http://purl.org/dc/dcmitype/" ')
			FWRITE(lhFile, 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">')
			IF !EMPTY(this.Title)
			    FWRITE(lhFile, '<dc:title>' + this.Title + '</dc:title>')
			ENDIF
			IF !EMPTY(this.Subject)
			    FWRITE(lhFile, '<dc:subject>' + this.Subject + '</dc:subject>')
			ENDIF
			IF !EMPTY(this.CreatorName)
				FWRITE(lhFile, '<dc:creator>' + this.CreatorName + '</dc:creator>')
			ENDIF
			IF !EMPTY(this.UserName)
				FWRITE(lhFile, '<cp:lastModifiedBy>' + this.UserName + '</cp:lastModifiedBy>')
			ENDIF
			IF VERSION(5) < 900
				FWRITE(lhFile, '<dcterms:created xsi:type="dcterms:W3CDTF">' + This.TTOC3(DATETIME()) + 'Z</dcterms:created>')
				FWRITE(lhFile, '<dcterms:modified xsi:type="dcterms:W3CDTF">' + This.TTOC3(DATETIME()) + 'Z</dcterms:modified>')
			ELSE
				FWRITE(lhFile, '<dcterms:created xsi:type="dcterms:W3CDTF">' + TTOC(DATETIME(), 3) + 'Z</dcterms:created>')
				FWRITE(lhFile, '<dcterms:modified xsi:type="dcterms:W3CDTF">' + TTOC(DATETIME(), 3) + 'Z</dcterms:modified>')
			ENDIF
			FWRITE(lhFile, '</cp:coreProperties>')
			FCLOSE(lhFile)
			STRTOFILE(STRCONV(FILETOSTR(lcFileName), 9), lcFileName, 4)      && Save as UTF-8
		
			lcFileName = tcPath + "xl\sharedStrings.xml"
			lhFile = FCREATE(lcFileName)
			IF lhFile < 0
				THROW 11
			ENDIF
		
			SELECT xl_strformat
			SET ORDER TO TAG sortorder
			COUNT FOR workbook = tnWB .AND. !DELETED() TO lnTotCount
		
			SELECT xl_strings
			SET ORDER TO TAG sortorder
			COUNT FOR workbook = tnWB .AND. !DELETED() TO lnUniqueCnt
			lnTotCount = lnTotCount + lnUniqueCnt
		
			FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + LF)
			FWRITE(lhFile, '<sst uniqueCount="' + TRANSFORM(lnUniqueCnt) + '" count="' + TRANSFORM(lnTotCount) + '" xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">')
			SCAN FOR workbook = tnWB .AND. !DELETED()
				IF xl_strings.formatted
					FWRITE(lhFile, '<si>')
					SELECT xl_strformat
					SCAN FOR workbook = tnWB .AND. id = xl_strings.id .AND. !DELETED()
						FWRITE(lhFile, '<r>')
						IF xl_strformat.fbold .OR. xl_strformat.fitalic .OR. xl_strformat.fcolor>0 .OR. !EMPTY(xl_strformat.fname) .OR. xl_strformat.fsize>0 .OR. !EMPTY(xl_strformat.uline) ;
						.OR. xl_strformat.strkthr .OR. !EMPTY(xl_strformat.fvpos) .OR. xl_strformat.theme>0 .OR. xl_strformat.indexed>0
		
							FWRITE(lhFile, '<rPr>')
							IF xl_strformat.fbold
								FWRITE(lhFile, '<b/>')
							ENDIF
							IF xl_strformat.fitalic
								FWRITE(lhFile, '<i/>')
							ENDIF
							IF xl_strformat.uline != UNDERLINE_NONE
								FWRITE(lhFile, '<u/>')
							ENDIF
							IF xl_strformat.strkthr
								FWRITE(lhFile, '<strike/>')
							ENDIF
							IF xl_strformat.fsize > 0
								FWRITE(lhFile, '<sz val="' + TRANSFORM(xl_strformat.fsize) + '"/>')
							ENDIF
							DO CASE
								CASE xl_strformat.fcolor > 0
									FWRITE(lhFile, '<color rgb="' + this.ConvertColorToHex(xl_strformat.fcolor) +'"/>')
								
								CASE xl_strformat.indexed > 0
									FWRITE(lhFile, '<color indexed="' + TRANSFORM(xl_strformat.indexed) + '"/>')
		
								CASE xl_strformat.theme > 0
									FWRITE(lhFile, '<color theme="' + TRANSFORM(xl_strformat.theme) +'" tint="' + TRANSFORM(xl_strformat.tint, "99.999999999999999") + '"/>')
							ENDCASE
							IF !EMPTY(xl_strformat.fvpos)
								FWRITE(lhFile, '<vertAlign val="' + ALLTRIM(xl_strformat.fvpos) + '"/>')
							ENDIF
							IF !EMPTY(xl_strformat.fname)
								FWRITE(lhFile, '<rFont val="' + ALLTRIM(xl_strformat.fname) + '"/>')
							ENDIF
							FWRITE(lhFile, '</rPr>')
						ENDIF
						IF LEFT(xl_strformat.stringvalue, 1) = " "
							FWRITE(lhFile, '<t xml:space="preserve">' + xl_strformat.stringvalue + '</t>')
						ELSE
							FWRITE(lhFile, '<t>' + xl_strformat.stringvalue + '</t>')
						ENDIF
						FWRITE(lhFile, '</r>')
					ENDSCAN
					FWRITE(lhFile, '</si>')
					SELECT xl_strings
				ELSE
					IF xl_strings.presvspace
						FWRITE(lhFile, '<si><t xml:space="preserve">' + xl_strings.stringvalue + '</t></si>')
					ELSE
						FWRITE(lhFile, '<si><t>' + xl_strings.stringvalue + '</t></si>')
					ENDIF
				ENDIF
			ENDSCAN
			SET ORDER TO
			FWRITE(lhFile, '</sst>')
			FCLOSE(lhFile)
			STRTOFILE(STRCONV(FILETOSTR(lcFileName), 9), lcFileName, 4)      && Save as UTF-8
		
			llSuccess = True
		
		CATCH TO loException
			SET STEP ON
			llSuccess = False
		
		ENDTRY
		RETURN llSuccess
	ENDPROC

	PROTECTED PROCEDURE WriteWorkbookXML		&& Writes the workbook XML
		LPARAMETERS tnWB, tcPath, toSheets
		LOCAL lcFileName, lhFile, lnSheet, loException, llSuccess, lcSheetName
		TRY
			lcFileName = tcPath + "xl\workbook.xml"
			lhFile = FCREATE(lcFileName)
			IF lhFile < 0
				THROW 11
			ENDIF
			FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'+ LF)
			FWRITE(lhFile, '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">')
		*-*	Write thw sheet information
			FWRITE(lhFile, '<sheets>')
			FOR lnSheet=1 TO toSheets.Count
				DO CASE
					CASE toSheets.List[lnSheet, 4] = VISIBLE_SHEET_STATE
						FWRITE(lhFile, '<sheet r:id="' + toSheets.List[lnSheet, 3] + '" sheetId="' + TRANSFORM(lnSheet) + '" name="' + toSheets.List[lnSheet, 2] + '"/>')
		
					CASE toSheets.List[lnSheet, 4] = HIDDEN_SHEET_STATE
						FWRITE(lhFile, '<sheet r:id="' + toSheets.List[lnSheet, 3] + '" sheetId="' + TRANSFORM(lnSheet) + '" state="hidden" name="' + toSheets.List[lnSheet, 2] + '"/>')
					
					CASE toSheets.List[lnSheet, 4] = VERYHIDDEN_SHEET_STATE
						FWRITE(lhFile, '<sheet r:id="' + toSheets.List[lnSheet, 3] + '" sheetId="' + TRANSFORM(lnSheet) + '" state="veryHidden" name="' + toSheets.List[lnSheet, 2] + '"/>')
				ENDCASE
			ENDFOR
			FWRITE(lhFile, '</sheets>')
		*-*	Write the named range information
			SELECT xl_namerange
			LOCATE FOR workbook = tnWB .AND. !DELETED()
			IF FOUND()
				FWRITE(lhFile, '<definedNames>')
				SCAN FOR workbook = tnWB .AND. !DELETED()
					FWRITE(lhFile, '<definedName name="' + ALLTRIM(xl_namerange.rname) + '"')
					IF !EMPTY(xl_namerange.comment)
						FWRITE(lhFile, ' comment="' + ALLTRIM(xl_namerange.comment) + '"')
					ENDIF
					IF xl_namerange.scope = SCOPE_SH_NAMED_RANGE
						FWRITE(lhFile, ' localSheetId="' + TRANSFORM(xl_namerange.sheet))
					ENDIF
					lcSheetName = this.GetSheetName(tnWB, xl_namerange.sheet)
					FWRITE(lhFile,  + '>')
					FWRITE(lhFile, IIF(OCCURS(" ", lcSheetName)>0, "'", "") + lcSheetName + IIF(OCCURS(" ", lcSheetName)>0, "'", ""))
					FWRITE(lhFile, '!$' + this.ColumnIndexToAscii(xl_namerange.begcol) + '$' + TRANSFORM(xl_namerange.begrow))
					FWRITE(lhFile, ':$' + this.ColumnIndexToAscii(xl_namerange.endcol) + '$' + TRANSFORM(xl_namerange.endrow))
					FWRITE(lhFile, '</definedName>')
				ENDSCAN
				FWRITE(lhFile, '</definedNames>')
			ENDIF
		*-*	Close the workbook
			FWRITE(lhFile, '<calcPr calcId="0"/>')
			FWRITE(lhFile, '</workbook>')
			FCLOSE(lhFile)
			STRTOFILE(STRCONV(FILETOSTR(lcFileName), 9), lcFileName, 4)      && Save as UTF-8
		
		*-*	Write the workbook relationships file
			lhFile = FCREATE(tcPath + "xl\_rels\workbook.xml.rels")
			IF lhFile < 0
				THROW 11
			ENDIF
			FWRITE(lhFile, '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>')
			FWRITE(lhFile, '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">')
			FOR lnSheet=1 TO toSheets.Count
				FWRITE(lhFile, '<Relationship Id="' + toSheets.List[lnSheet, 3] + '" Target="worksheets/sheet' + TRANSFORM(lnSheet) + '.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet"/>')
			ENDFOR
			FWRITE(lhFile, '<Relationship Id="rId' + TRANSFORM(toSheets.Count+1) + '" Target="styles.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles"/>')
			FWRITE(lhFile, '<Relationship Id="rId' + TRANSFORM(toSheets.Count+2) + '" Target="sharedStrings.xml" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings"/>')
			FWRITE(lhFile, '</Relationships>')
			FCLOSE(lhFile)
		
			llSuccess = True
		
		CATCH TO loException
			SET STEP ON
			llSuccess = False
		ENDTRY
		RETURN llSuccess
	ENDPROC

ENDDEFINE
