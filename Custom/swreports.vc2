*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="swreports.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS swprogress AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: updateprogress
		*p: oprogress
		*p: _memberdata
	*</DefinedPropArrayMethod>

	Name = "swprogress"
	oprogress = .NULL.
	_memberdata = <VFPData>
		<memberdata name="oprogress" display="oProgress"/>
		</VFPData>
	
	PROCEDURE Destroy
		this.oProgress.closeprogress()
		DODEFAULT()
	ENDPROC

	PROCEDURE Init
		this.oProgress = m.goapp.omessage.progressbar('Report in progress...')
		this.oProgress.setProgressRange(0,100)
	ENDPROC

	PROCEDURE updateprogress
		LPARAMETERS tnPageno, tnReportNo, tnPct
		
		this.oProgress.updateprogress(tnpct)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS swreport AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: calcpaidowners		&& Calculates the payments to royalty and working interest owners to plug into wellhist
		*m: rptwellprod		&& Method for creating well production report
		*m: sendreport		&& Sends the data through the report format and to either a preview window or the printer.
		*p: calias
		*p: cfriendlyname
		*p: cprocessor
		*p: creportname
		*p: cselectioncriteria
		*p: csortorder
		*p: csvfilename
		*p: ctitle1
		*p: ctitle2
		*p: ctitle3
		*p: datasessionid		&& Returns the data session ID that identifies the private data session for the FormSet, Form, or ToolBar.
		*p: lsummary
		*p: omessage
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	calias = 
	cfriendlyname = 
	cprocessor = 
	creportname = 
	cselectioncriteria = 
	csortorder = 
	csvfilename = 
	ctitle1 = 
	ctitle2 = 
	ctitle3 = 
	Height = 50
	lsummary = .F.
	Name = "swreport"
	omessage = .NULL.
	Width = 100
	_memberdata = <VFPData>
		<memberdata name="rptwellprod" display="rptWellProd"/>
		<memberdata name="calcpaidowners" display="CalcPaidOwners"/>
		<memberdata name="ctitle1" display="cTitle1"/>
		<memberdata name="ctitle2" display="cTitle2"/>
		<memberdata name="ctitle3" display="cTitle3"/>
		<memberdata name="cselectioncriteria" display="cSelectionCriteria"/>
		<memberdata name="csortorder" display="cSortOrder"/>
		<memberdata name="creportname" display="cReportName"/>
		<memberdata name="omessage" display="oMessage"/>
		<memberdata name="sendreport" display="SendReport"/>
		<memberdata name="lsummary" display="lSummary"/>
		<memberdata name="cprocessor" display="cProcessor"/>
		<memberdata name="calias" display="cAlias"/>
		<memberdata name="datasessionid" display="DatasessionID"/>
		<memberdata name="cfriendlyname" display="cFriendlyName"/>
		<memberdata name="csvfilename" display="CSVFilename"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE calcpaidowners		&& Calculates the payments to royalty and working interest owners to plug into wellhist
	ENDPROC

	PROCEDURE rptwellprod		&& Method for creating well production report
	ENDPROC

	PROCEDURE sendreport		&& Sends the data through the report format and to either a preview window or the printer.
		LPARA tcButton, tlFile, tcGroupname
		LOCAL lnResult, lcAlias, llError
		PRIV lcTitle1, lcTitle2, lcSortOrder, lcSelect, glGrpName, m.cGrpName, llPrinted, m.cproducer
		
		IF this.DatasessionID # 0
		   SET DATASESSION TO (this.DatasessionID)
		ENDIF 
		
		lcDefault = SET('default')
		*SET DEFAULT TO FULLPATH('datafiles\bin')
		
		lcPath = LOWER(SET('path'))
		IF NOT 'commonsource' $ LOWER(lcPath)
		   IF RIGHT(ALLTRIM(lcpath),1)=','
		      lcpath = lcpath + 'commonsource\'
		   ELSE    
		      lcpath = lcpath + ',commonsource\'
		   ENDIF
		ENDIF
		IF NOT ',source' $ lcpath
		   IF RIGHT(ALLTRIM(lcpath),1)=','
		      lcpath = lcpath + 'source\'
		   ELSE
		      lcpath = lcpath + ',source\' 
		   ENDIF
		ENDIF 
		
		SET PATH to (lcPath)
		
		* Check for the parameter. If it's not a character we're being called by the toolbar print button
		* Bail out if we got here by the toolbar button.
		IF VARTYPE(tcButton) <> 'C'
		    RETURN
		ENDIF
		
		IF NOT '.frx' $ LOWER(this.cReportName) AND ;
		   NOT '.lbx' $ LOWER(this.cReportName)
		   this.cReportName = ALLTRIM(this.cReportName)+'.frx'
		ENDIF 
		*!*	IF NOT FILE(THIS.cReportName)
		*!*	   MESSAGEBOX('Unable to find the report format for this report: ' + THIS.cReportName + CHR(10) + ;
		*!*	              'Can not continue.',16,'Missing Report Format')
		*!*	   RETURN .f.
		*!*	ENDIF 
		*
		*  Check to see if the requirements for calling this method are met.
		*
		ASSERT TYPE('this.cReportName') = 'C' MESSAGE 'You must set the cReportName property to use this class'
		ASSERT INLIST(tcButton, 'F', 'P', 'S')  MESSAGE 'The parm to the report method must be either "F" or "P"'
		
		IF TYPE('this.ctitle1') <> 'C'
		    THIS.ctitle1 = ''
		ENDIF
		IF TYPE('this.ctitle2') <> 'C'
		    THIS.ctitle2 = ''
		ENDIF
		
		lcAlias = ALIAS()
		
		llPrinted = .F.
		llError   = .F.
		
		ON KEY LABEL CTRL+C gnStopXFRX = 1
		
		IF EMPTY(this.csvfilename)
		   this.csvfilename = this.cAlias
		ENDIF 
		
		*
		*  Check on using group name in place of company name
		*
		swselect('options')
		swselect('groups')
		
		* If the form doesn't have a swgroup control
		* don't try to get the company name from the group
		IF VARTYPE(tcGroupname) = 'C'
		   m.cGrpName = tcGroupName
		   glGrpName = .t.
		ELSE
		   m.cGrpName = ''
		   glGrpName = .f.
		ENDIF 
		
		*
		*  Make the cProducer variable a default value for development purposes
		*
		m.cProducer = m.goapp.cCompanyName
		IF m.goapp.lDemo
		    m.cProducer = 'Demo Version of Software'
		    m.cGrpName  = m.cProducer
		ENDIF
		
		
		IF TYPE('this.cProcessor') <> 'C'
		    m.cProcessor = ''
		ELSE
		   m.cProcessor = this.cProcessor    
		ENDIF
		
		IF EMPTY(m.cProducer) OR m.cProducer = "''"
		    m.cProducer = 'Sample Development Company'
		ENDIF
		
		lcTitle1    = THIS.ctitle1
		lcTitle2    = THIS.ctitle2
		lcSortOrder = THIS.cSortOrder
		lcSelect    = THIS.cSelectionCriteria
		
		*
		*  Set defaults for titles and criteria if not in correct format
		*
		IF TYPE('lcTitle1') <> 'C'
		    lcTitle1 = ''
		ENDIF
		IF TYPE('lcTitle2') <> 'C'
		    lcTitle2 = ''
		ENDIF
		IF TYPE('lcSortOrder') <> 'C'
		    lcSortOrder = ''
		ENDIF
		IF TYPE('lcSelect') <> 'C'
		    lcSelect = ''
		ENDIF
		
		SELECT (this.cAlias)
		
		* Disable F1 Help
		ON KEY LABEL F1 *
		
		* Disable the picklist key
		ON KEY LABEL F2 *
		
		*
		*  Send the report to the proper location based upon the button pressed.
		*
		DO CASE
		
		    CASE tcButton = 'P'
		        SET REPORTBEHAVIOR 90
		        TRY
		            LOCAL loSession, lnRetval, loXFF, loPreview, loScripts
		*!*	            loSession = EVALUATE([xfrx("XFRX#LISTENER")])
		*!*	            loUpdate = CREATEOBJECT("updatelistener")
		*!*	            loUpdate.thermFormCaption = ALLTRIM(this.cFriendlyName)+" Report in progress ..."
		*!*	            loSession.successor = loUpdate
		*!*	            lnRetval  = loSession.SetParams(, , , , , , "XFF") && no name = just in memory
		*!*	            loSession.SetOtherParams("PRINT_BOOKMARKS",.t.)
		*!*	            loSession.PrintJobName = this.cFriendlyname
		*!*	            loSession.CallEvaluateContents=2
		*!*	            loSession.PrintJobName = this.cFriendlyname
		                TRY
		                    IF NOT THIS.lSummary
		                        REPORT FORM (THIS.cReportName) TO PRINTER PROMPT && OBJECT loSession
		                    ELSE
		                        REPORT FORM (THIS.cReportName) TO PRINTER PROMPT SUMMARY && OBJECT loSession SUMMARY 
		                    ENDIF
		                CATCH TO loError
		                    llError = .T.
		                ENDTRY
		
		        CATCH TO loError
		            llError = .T.
		        ENDTRY
		        IF llError
		            IF loError.ERRORNO = 1958
		                MESSAGEBOX('There was an error loading the printer driver. Make sure you have a valid printer selected or setup as your default printer.', 16, 'Windows Printer Driver Error')
		            ELSE
		                MESSAGEBOX('Error sending the report to the printer.' + CHR(10) + ;
		                      'Error: ' + loError.MESSAGE, 16, 'Report Print Problem')
		            ENDIF
		        ENDIF
		
		    CASE tcButton = 'S'
		        IF tlFile
		            SET REPORTBEHAVIOR 80
		            IF LOWER(this.cAlias) = 'balance'
		               SELECT glmast
		            ENDIF 
		            DO FORM exportcsv WITH THIS.cFriendlyName, this.cReportName, this.csvfilename, lcTitle1, lcTitle2, lcSortOrder, lcSelect
		        ELSE
		            SET REPORTBEHAVIOR 90
		            LOCAL loPreviewContainer, loReportListener
		            LOCAL loSession, lnRetval, loXFF, loPreview, loScripts
		            loSession = xfrx("XFRX#LISTENER")
		            loUpdate = CREATEOBJECT("updatelistener")
		            loUpdate.thermFormCaption = ALLTRIM(this.cFriendlyName)+" Report in progress ..."
		            loSession.successor = loUpdate
		            lnRetval  = loSession.SetParams(, , , , , , "XFF") && no name = just in memory
		            loSession.SetOtherParams("PRINT_BOOKMARKS",.t.,0)
		            loSession.PrintJobName = this.cFriendlyname
		            loSession.CallEvaluateContents=2
		            IF lnRetval = 0
		                TRY
		                    IF NOT THIS.lSummary
		                        REPORT FORM (THIS.cReportName) OBJECT loSession
		                    ELSE
		                        REPORT FORM (THIS.cReportName) OBJECT loSession SUMMARY 
		                    ENDIF
		                CATCH TO loError
		                    llError = .T.
		                ENDTRY
		
		                loXFF     = loSession.oxfDocument
		                loPreview = CREATEOBJECT("frmMPPreviewer")
		                loPreview.oDisplayDefaults.nOutlineType = 1
		                loPreview.ShowStatus = .F.
		                loPreview.oDisplayDefaults.ZoomFactor = -2
		                loPreview.PreviewXFF(loXFF)
		                loPreview.SHOW(0)
		            ENDIF
		
		
		            IF llError
		                IF loError.ERRORNO = 1958
		                    MESSAGEBOX('There was an error loading the printer driver. Make sure you have a valid printer selected or setup as your default printer.', 16, 'Windows Printer Driver Error')
		                ELSE
		                    MESSAGEBOX('Error sending the report to the printer.' + CHR(10) + ;
		                          'Error: ' + loError.MESSAGE, 16, 'Report Print Problem')
		                ENDIF
		            ENDIF
		        ENDIF
		ENDCASE
		*SET DEFAULT TO &lcDefault
		ON KEY LABEL CTRL+C 
		
		
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS swreportlistener AS _reportlistener OF "..\..\..\3rdparty\ffc\_reportlistener.vcx" 
 	*< CLASSDATA: Baseclass="reportlistener" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\..\..\program files\microsoft visual foxpro 9\ffc\reportlisteners.h"
	*<DefinedPropArrayMethod>
		*p: ccursors
		*p: datacursors		&& Cursor Collection that contains data used by the reports
	*</DefinedPropArrayMethod>

	ccursors = .F.
	datacursors = (NULL)		&& Cursor Collection that contains data used by the reports
	FRXDataSession = -1
	Name = "swreportlistener"
	
	PROCEDURE addreport
		LPARAMETERS m.tcFRXName, m.tcClauses, m.toListener, m.cCursor
		LOCAL lcAlias
		
		lcAlias = ALIAS()
		
		* Create the data cursors collection to hold the cursor names
		* to be used by chained reports
		IF ISNULL(THIS.DataCursors)
		   THIS.DataCursors = CREATEOBJECT("Collection")
		ENDIF
		
		* Add the cursor name passed to the cursor collection
		IF VARTYPE(m.cCursor) = "C"
		   THIS.DataCursors.Add(m.cCursor)
		ELSE
		   THIS.DataCursors.Add(lcAlias)
		ENDIF
		
		DODEFAULT(m.tcFRXName, m.tcClauses, m.toListener)
		
		
	ENDPROC

	PROCEDURE runreports
		LPARAMETERS m.tlRemoveReportsAfterRun, m.tlOmitListenerReferences
		
		IF NOT ;
		      (THIS.IsRunningReports OR ;
		        ISNULL(THIS.ReportFileNames) OR ;
		        THIS.ReportFileNames.COUNT = 0)
		
		   LOCAL m.oError, m.liIndex, m.lcClauses, m.loListener, m.lcParse
		   m.oError = NULL
		
		   THIS.IsRunningReports = .T.
		
		   TRY
		
		      FOR m.liIndex = 1 TO THIS.ReportFileNames.COUNT
		         * the clauses, filenames, and listener collections are 
		         * protected properties, we're
		         * taking care of how they match up, 
		         * that FRXs exist, etc.
		         m.lcClauses  = UPPER(THIS.ReportClauses[m.liIndex])
		         m.loListener = THIS.Listeners[m.liIndex]
		         * Get the cursor which contains the data for this report - pws 2/9/2008
		         m.cCursor    = THIS.DataCursors[m.liIndex]
		         * Select the chosen cursor before running the report - pws 2/9/2008
		         SELECT (m.cCursor)
		         DO CASE
		            CASE ' OBJE ' $ STRTRAN(' ' + m.lcClauses, 'CT', ' ') OR ;
		                  ' OBJEC ' $ ' ' + m.lcClauses OR ;
		                  m.tlOmitListenerReferences
		               m.loListener = NULL
		               REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses
		               TRY
		                  m.lcParse = ' ' + STRTRAN(' ' + m.lcClauses, ' OBJECT ', ' OBJE ')
		                  m.lcParse = STRTRAN(m.lcParse, ' OBJEC ', ' OBJE ')
		                  m.lcParse = SUBSTR(m.lcParse, AT(' OBJE ', m.lcParse) + 5)
		                  DO CASE
		                     CASE m.tlOmitListenerReferences
		                        * we're going with old-style behavior for sure here
		                     CASE ' TYPE ' $ ' ' + m.lcClauses
		                        m.lcParse = ALLTRIM(STRTRAN(' ' + m.lcParse, ' TYPE ', ''))
		                        IF ' ' $ m.lcParse
		                           m.lcParse = ALLTRIM(LEFT(m.lcParse, AT(' ', m.lcParse, 1)))
		                        ENDIF
		                        IF VAL(m.lcParse) > 0
		                           m.loListener = EVALUATE("_oReportOutput['" + m.lcParse + "']")
		                        ENDIF
		                     OTHERWISE
		                        m.lcParse = ALLTRIM(m.lcParse)
		                        IF ' ' $ m.lcParse
		                           m.lcParse = ALLTRIM(LEFT(m.lcParse, AT(' ', m.lcParse, 1)))
		                        ENDIF
		                        m.loListener = EVALUATE(m.lcParse)
		                  ENDCASE
		               CATCH
		                  m.loListener = NULL
		               ENDTRY
		            CASE ISNULL(loListener)
		               REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses  OBJECT THIS
		               m.loListener = THIS
		            OTHERWISE
		               REPORT FORM (THIS.ReportFileNames[m.liIndex]) &lcClauses  OBJECT m.loListener
		         ENDCASE
		
		         THIS.adjustReportPagesInfo(m.liIndex, m.lcClauses, m.loListener)
		
		         *&* Sedna change: 
		         *&*  see new THIS.adjustReportPagesInfo method, to which we pass report index, clauses, and 
		         *&*  evaluated listener ref.  Original code here was:
		         *&*          IF NOT (" NOWA " $ STRTRAN(" "+m.lcClauses,"IT"," ") OR ;
		         *&*                  " NOWAI " $ " " + m.lcClauses) 
		         *&*             THIS.ReportPages[m.liIndex] = THIS.SharedPageTotal
		         *&*             * TBD: make this a two-column array with 
		         *&*             * output pages (responsive to RANGE clause)
		         *&*             * represented as well?
		         *&*          ENDIF
		
		      ENDFOR
		
		
		   CATCH TO m.oError
		      LOCAL lcErrMsg
		      IF (ISNULL(m.oError))
		         lcErrMsg = MESSAGE() + CHR(13) + MESSAGE(1)
		      ELSE
		         lcErrMsg = THIS.PrepareErrorMessage(;
		              m.oError.ERRORNO, ;
		              m.oError.PROCEDURE, ;
		              m.oError.LINENO, ;
		              THIS.AppName, ;
		              m.oError.MESSAGE, ;
		              m.oError.LINECONTENTS)
		      ENDIF
		      THIS.DOMESSAGE(lcErrMsg, 16)
		      THIS.lastErrorMessage = lcErrMsg
		      #IF OUTPUTCLASS_DEBUGGING
		         SUSPEND
		      #ENDIF
		      EXIT
		   FINALLY
		
		      THIS.IsRunningReports = .F.
		      IF m.tlRemoveReportsAfterRun
		         THIS.RemoveReports()
		      ENDIF
		      STORE NULL TO m.loListener, m.oError
		
		   ENDTRY
		
		
		ENDIF
		
		
		
		
		
		
	ENDPROC

ENDDEFINE
