*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="mwresize.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS mwresize AS control 
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblShading" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblHighLight" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: doinit
		*m: frmresize
		*m: getname
		*m: position
		*m: resetsize
		*m: resizecontainer
		*m: resizecontrol
		*m: resizedelayed
		*m: savecontainer
		*m: saveformsize
		*m: saveoriginalsize
		*m: setcolor
		*m: zz_readme
		*p: cmenupads
		*p: lautosaveformsize
		*p: lresizegridcontents
		*p: nminfactor
		*p: nzorder
		*p: _lformsizesaved
		*p: _linitdone
		*p: _nlastwindowstate
		*p: _nversion
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	cmenupads = 75=Size \<75%;85=Size \<85%;95=Size \<95%;100=\<Orginal size;115=Size 1\<15%;125=Size 1\<25%;140=Size 1\<40%;160=Size 1\<60%;180=Size 18\<0%
	Height = 16
	lautosaveformsize = .T.
	lresizegridcontents = .F.
	Name = "mwresize"
	nminfactor = 0.5
	nzorder = 0
	Width = 16
	_lformsizesaved = .F.
	_linitdone = .F.
	_nlastwindowstate = 0
	_nversion = 5.1

	ADD OBJECT 'lblHighLight' AS label WITH ;
		BackStyle = 0, ;
		Caption = "o", ;
		FontName = "Marlett", ;
		FontSize = 12, ;
		ForeColor = 224,224,224, ;
		Height = 16, ;
		Name = "lblHighLight", ;
		Width = 16
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblShading' AS label WITH ;
		BackStyle = 0, ;
		Caption = "p", ;
		FontName = "Marlett", ;
		FontSize = 12, ;
		ForeColor = 127,127,127, ;
		Height = 16, ;
		Name = "lblShading", ;
		Width = 16
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE doinit
		IF m.This._lInitDone
			RETURN
		ENDIF
		
		WITH This
			._lInitDone = .T.
			IF NOT ._lFormSizeSaved
				.SaveFormSize()
			ENDIF
			.SaveContainer( m.Thisform )
		ENDWITH
		
	ENDPROC

	PROCEDURE frmresize
		*--------------------------------------------
		* For compatibility with Markus Auers Sizer.
		*--------------------------------------------
		LPARAMETERS toContainer
		
		IF PCOUNT() == 0
			m.This.ResizeContainer( m.Thisform )
		ELSE
			*--------------------------------------------
			* Zur einfacheren Fehlersuche merken wir uns
			* den Namen des Controls.
			*--------------------------------------------
			LOCAL lcContainerName
			lcContainerName = m.This.GetName( m.toContainer )
		
			m.This.ResizeDelayed( m.toContainer )
		ENDIF
		
		toContainer = .NULL.
		RELEASE toContainer
		
	ENDPROC

	PROCEDURE getname
		LPARAMETERS toControl
		
		*--------------------------------------------
		* Setup.
		*--------------------------------------------
		LOCAL lcName
		
		*--------------------------------------------
		* Objektpfad des übergebenen Controls
		* ermitteln.
		*--------------------------------------------
		IF VARTYPE( m.toControl ) == "O"
			lcName = SYS( 1272, m.toControl )
		ELSE
			lcName = ""
		ENDIF
		
		*--------------------------------------------
		* Cleanup.
		*--------------------------------------------
		toControl = .NULL.
		RELEASE toControl
		
		RETURN m.lcName
		
	ENDPROC

	PROCEDURE Init
		WITH This
			IF m.Thisform.Borderstyle == 3
				.Position()
				IF .lAutoSaveFormSize
					.SaveFormSize()
				ENDIF
				.SetColor()
			ELSE
				.Visible = .F.
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE position
		WITH This
			.Move( .parent.Width  - .Width, .parent.Height - .Height )
		ENDWITH
		
	ENDPROC

	PROCEDURE resetsize
		LPARAMETERS tnPercent
		
		IF EMPTY( m.tnPercent )
			tnPercent = 100
		ENDIF
		
		WITH This
			IF NOT ._lInitDone
				.DoInit()
			ENDIF
		ENDWITH
		
		WITH Thisform
			.LockScreen = .T.
			IF NOT .WindowState == 0
				.WindowState = 0
			ENDIF
			.Move( .Left, .Top, ._nOriginalWidth * m.tnPercent / 100, ._nOriginalHeight * m.tnPercent / 100 )
			.LockScreen = .F.
			IF TYPE( ".ActiveControl.BaseClass" ) == "C" ;
					AND .ActiveControl.BaseClass == "Editbox" ;
					AND .ActiveControl.ReadOnly
				*--------------------------------------------
				* Zur einfacheren Fehlersuche merken wir uns
				* den Namen des Controls.
				*--------------------------------------------
				LOCAL lcEditboxName
				lcEditboxName = m.This.GetName( .ActiveControl )
		
				.Draw()
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE Resize
		LPARAMETERS toContainer
		
		IF NOT VARTYPE( m.toContainer ) == "O"
			RETURN
		ENDIF
		
		*--------------------------------------------
		* Zur einfacheren Fehlersuche merken wir uns
		* den Namen des Controls.
		*--------------------------------------------
		LOCAL lcContainerName
		lcContainerName = m.This.GetName( m.toContainer )
		
		NODEFAULT
		
		m.This.ResizeContainer( m.toContainer )
		
		toContainer = .NULL.
		RELEASE toContainer
		
	ENDPROC

	PROCEDURE resizecontainer
		LPARAMETERS toContainer
		
		*--------------------------------------------
		* Zur einfacheren Fehlersuche merken wir uns
		* den Namen des Controls.
		*--------------------------------------------
		LOCAL lcContainerName, lcControlName, lcSubContainerName
		lcContainerName = m.This.GetName( m.toContainer )
		
		WITH This
			
			IF m.toContainer.BASECLASS == "Form"
				.Position()
				IF NOT ._lInitDone
					.DoInit()
				ENDIF
				LOCAL llLockScreen
				llLockScreen = NOT m.toContainer.LOCKSCREEN
				IF m.llLockScreen
					toContainer.LOCKSCREEN = .T.
				ENDIF
				DO CASE
					CASE ._nLastWindowState == 2 ;
							AND m.toContainer.WindowState == 0
						*--------------------------------------------
						*(..)Bug Workaround: beim Wiederherstellen
						*(..)der Form-Größe werden die Textboxen zu
						*(..)breit resized. Beim zweiten Durchlauf
						*(..)klappts dann.
						*--------------------------------------------
						._nLastWindowState	= 0
						.ResizeContainer( m.toContainer )
					CASE m.toContainer.WindowState == 2 ;
							AND NOT ._nLastWindowState == 2
						._nLastWindowState = 2
				ENDCASE
			ELSE
				.ResizeControl( m.toContainer )
			ENDIF
		
			LOCAL lcBaseClass, loControl, loSubContainer
		
			*--------------------------------------------
			* Resize container contents?
			*--------------------------------------------
			IF NOT PEMSTATUS( m.toContainer, "Comment", 3 ) == "Property" ;
					OR NOT "*NORESIZE*" $ m.toContainer.Comment
			
				FOR EACH loControl IN m.toContainer.CONTROLS
		
					*--------------------------------------------
					* Zur einfacheren Fehlersuche merken wir uns
					* den Namen des Controls.
					*--------------------------------------------
					lcControlName = m.This.GetName( m.loControl )
		
					IF PEMSTATUS( m.loControl, "BaseClass", 2 )
						*--------------------------------------------
						* Protected property or protected object.
						*--------------------------------------------
						LOOP
					ENDIF
		
					lcBaseClass = m.loControl.BASECLASS
		
					IF NOT m.lcBaseClass $ "Container,Custom,Timer,Pageframe"		&& beinhaltet auch "Page"
						.ResizeControl( m.loControl )
					ENDIF
		
					DO CASE
		
						CASE m.lcBaseClass == "Container"
							.ResizeContainer( m.loControl )
		
						CASE m.lcBaseClass == "Pageframe"
							*--------------------------------------------
							* Da das Ändern der Page.Fontsize die Höhe
							* des PageTab ändert, muß die Fontsize der
							* Pages angepaßt werden, bevor die Höhe
							* des Pageframe angepaßt wird.
							* Deshalb werden zuerst alle Pages rekursiv
							* resized und danach erst der Pageframe.
							*--------------------------------------------
							FOR EACH loSubContainer IN m.loControl.PAGES
								*--------------------------------------------
								* Zur einfacheren Fehlersuche merken wir uns
								* den Namen des Controls.
								*--------------------------------------------
								lcSubContainerName = m.This.GetName( m.loSubContainer )
								
								.ResizeControl( m.loSubContainer )
							ENDFOR
							.ResizeControl( m.loControl )
							FOR EACH loSubContainer IN m.loControl.PAGES
								*--------------------------------------------
								* Zur einfacheren Fehlersuche merken wir uns
								* den Namen des Controls.
								*--------------------------------------------
								lcSubContainerName = m.This.GetName( m.loSubContainer )
		
								.ResizeContainer( m.loSubContainer )
							ENDFOR
		
						CASE m.lcBaseClass == "Grid"
							IF .lResizeGridContents
								FOR EACH loSubContainer IN m.loControl.COLUMNS
									*--------------------------------------------
									* Zur einfacheren Fehlersuche merken wir uns
									* den Namen des Controls.
									*--------------------------------------------
									lcSubContainerName = m.This.GetName( m.loSubContainer )
		
									.ResizeContainer( m.loSubContainer )
								ENDFOR
							ENDIF
		
						CASE m.lcBaseClass $ "Commandgroup,Optiongroup"
							*--------------------------------------------
							* Bei AutoSize=.T. kann es passieren, daß Vfp
							* versucht den vorhandenen Platz optimal
							* auszunutzen und dazu die enthaltenen
							* Optionbuttons selbstständig verschiebt.
							*--------------------------------------------
							LOCAL llAutoSize
							llAutoSize = m.loControl.AutoSize
							IF m.llAutoSize
								loControl.AutoSize = .F.
							ENDIF
							FOR EACH loSubContainer IN m.loControl.BUTTONS
								*--------------------------------------------
								* Zur einfacheren Fehlersuche merken wir uns
								* den Namen des Controls.
								*--------------------------------------------
								lcSubContainerName = m.This.GetName( m.loSubContainer )
		
								.ResizeControl( m.loSubContainer )
							ENDFOR
							IF m.llAutoSize
								loControl.AutoSize = .T.
							ENDIF
		
					ENDCASE
		
				ENDFOR
		
			ENDIF
		
		ENDWITH
		
		IF m.toContainer.BASECLASS == "Form" ;
				AND m.llLockScreen
			toContainer.LOCKSCREEN = .F.
		ENDIF
		
		toContainer = .NULL.
		loControl = .NULL.
		loSubContainer = .NULL.
		RELEASE toContainer, loControl, loSubContainer
		
	ENDPROC

	PROCEDURE resizecontrol
		LPARAMETERS toControl
		#DEFINE BORDER_3D     4
		#DEFINE MIN_FONT_SIZE 4
		
		*--------------------------------------------
		* Zur einfacheren Fehlersuche merken wir uns
		* den Namen des Controls.
		*--------------------------------------------
		LOCAL lcControlName
		lcControlName = m.This.GetName( m.toControl )
		*!* - rk - 2013-4-2 - check if tocontrol is certain type and in grid column
		LOCAL m.llUseColumnFontsize AS Boolean
		
		TRY
		   IF m.toControl.BASECLASS $ "TextboxCombobox" AND m.toControl.PARENT.BASECLASS = [Column]	&& control in grid column
		      m.llUseColumnFontsize = .T.
		   ELSE
		      m.llUseColumnFontsize = .F.
		   ENDIF
		
		
		   LOCAL lnHeightRatio, lnWidthRatio, llAutosize, llSetRowHeight, llIntegralHeight
		   llIntegralHeight = .F.
		
		   WITH THISFORM
		      lnHeightRatio	= .HEIGHT / ._nOriginalheight
		      lnWidthRatio	= .WIDTH  / ._nOriginalwidth
		   ENDWITH
		
		   DO WHILE .T.
		      WITH toControl
		
		         IF PEMSTATUS( m.toControl, "_nOriginalWidth", 5 )
		            IF PEMSTATUS( m.toControl, "_nOriginalHeight", 5 )
		               IF PEMSTATUS( m.toControl, "Move", 3 ) == "Method"		&& Einige ActiveX Controls verbergen die Move-Methode des OleControls.
		
		*--------------------------------------------
		* Fehler unterdrücken, falls das Property
		* keinen numerischen Wert hat.
		*--------------------------------------------
		                  IF NOT VARTYPE( ._nOriginalheight ) == "N"
		                     EXIT
		                  ENDIF
		
		                  IF .BASECLASS == "Shape" AND .SPECIALEFFECT == 0	&& 3D.
		*--------------------------------------------
		* Special handling of '3D line' shapes.
		*--------------------------------------------
		                     LOCAL lnShapeWidthRatio, lnShapeHeightRatio
		                     lnShapeWidthRatio	= IIF( ._nOriginalwidth == 2, 1, m.lnWidthRatio )
		                     lnShapeHeightRatio	= IIF( ._nOriginalheight == 2, 1, m.lnHeightRatio )
		                     .MOVE( ._nOriginalLeft * m.lnWidthRatio, ;
		                          ._nOriginalTop * m.lnHeightRatio, ;
		                          ._nOriginalwidth * m.lnShapeWidthRatio, ;
		                          ._nOriginalheight * m.lnShapeHeightRatio )
		                  ELSE
		*--------------------------------------------
		*(..)If Textbox.IntegralHeight=.T. sometimes
		*(..)the IntegralHeight feature resets
		*(..)Textbox.Height during a resize, which
		*(..)results in Textbox.Height beeing too
		*(..)small after the resize.
		*--------------------------------------------
		                     IF .BASECLASS == "Textbox" AND .INTEGRALHEIGHT
		                        llIntegralHeight = .T.
		                        .INTEGRALHEIGHT	 = .F.
		                     ENDIF
		*--------------------------------------------
		* Resize of the current control.
		*--------------------------------------------
		                     .MOVE( ._nOriginalLeft * m.lnWidthRatio, ;
		                          ._nOriginalTop * m.lnHeightRatio, ;
		                          ._nOriginalwidth * m.lnWidthRatio, ;
		                          ._nOriginalheight * m.lnHeightRatio )
		                  ENDIF
		               ENDIF
		            ELSE
		               .WIDTH  = ._nOriginalwidth * m.lnWidthRatio
		            ENDIF
		         ENDIF
		
		*--------------------------------------------
		* Is it a grid?
		*--------------------------------------------
		         IF PEMSTATUS( m.toControl, "_nOriginalRowHeight", 5 )
		            IF NOT m.This.lResizeGridContents
		               EXIT
		            ENDIF
		            llSetRowHeight = .T.
		         ELSE
		            llSetRowHeight = .F.
		         ENDIF
		
		*--------------------------------------------
		* Adjust FontSize.
		*--------------------------------------------
		         IF PEMSTATUS( m.toControl, "_nOriginalFontsize", 5 )
		
		*--------------------------------------------
		* Randeinstellung muß eventuell angepaßt
		* werden.
		*(..)Ein Abrunden mit INT() ist nicht nötig,
		*(..)das macht das Margin-Property von selbst.
		*--------------------------------------------
		            IF PEMSTATUS( m.toControl, '_nOriginalMargin', 5 )
		               .MARGIN = MAX( 0, ._nOriginalMargin * ;
		                    IIF( m.lnHeightRatio < m.lnWidthRatio, ;
		                  	m.lnHeightRatio, m.lnWidthRatio ))
		            ENDIF
		
		*--------------------------------------------
		* Höhen- und Breitenänderung neu bestimmen.
		* Jetzt wird der Anzeigebereich des Controls
		* benötigt.
		*--------------------------------------------
		            IF .BASECLASS $ "TextboxComboboxEditboxSpinnerListboxCommandbutton"
		               LOCAL lnLostWidth, lnMargin, lnOriginalMargin
		               lnLostWidth		= IIF( .BASECLASS $ "TextboxCommandbutton", 0, SYSMETRIC(5) )
		               IF .BASECLASS $ "ListboxCommandbutton"
		                  STORE 0 TO lnMargin, lnOriginalMargin
		               ELSE
		                  lnMargin		   = .MARGIN
		                  lnOriginalMargin = ._nOriginalMargin
		               ENDIF
		               IF .BASECLASS $ "ComboboxSpinner" AND m.lnWidthRatio < 1
		*--------------------------------------------
		* Wenn Comboboxen und Spinner verkleinert
		* werden, dann nur den Textbereich
		* verkleinern.
		*--------------------------------------------
		                  .WIDTH = ( ._nOriginalwidth - SYSMETRIC(5) ) * m.lnWidthRatio + SYSMETRIC(5)
		               ENDIF
		               lnWidthRatio	 = (.WIDTH - BORDER_3D - m.lnMargin - m.lnLostWidth) / (._nOriginalwidth - BORDER_3D - m.lnOriginalMargin - m.lnLostWidth)
		               lnHeightRatio = (.HEIGHT - BORDER_3D - m.lnMargin) / (._nOriginalheight - BORDER_3D - m.lnOriginalMargin)
		            ENDIF
		
		*--------------------------------------------
		* Die ursprüngliche Font-Berechnung dieses
		* Resizers.
		*--------------------------------------------
		*!* - rk - 2013-4-2 - fall back to column font size for certain controls
		            IF m.llUseColumnFontsize && fall back to column's original font size
		               .FONTSIZE = MAX( MIN_FONT_SIZE, .PARENT.FONTSIZE )
		            ELSE
		               .FONTSIZE = MAX( MIN_FONT_SIZE, INT( ._nOriginalFontsize * ;
		                  	IIF(m.lnHeightRatio < m.lnWidthRatio, ;
		                  	  m.lnHeightRatio, m.lnWidthRatio) ) )
		            ENDIF
		*--------------------------------------------
		* Spaltenbreiten bei Combobox und Listbox.
		*--------------------------------------------
		            IF PEMSTATUS( m.toControl, '_cOriginalColumnWidths', 5 ) ;
		                  AND NOT EMPTY( ._cOriginalColumnWidths )
		               LOCAL i, laWidths[1], lcNewColumnWidhts
		               lcNewColumnWidhts = ""
		               FOR i = 1 TO ALINES( laWidths, STRTRAN( ._cOriginalColumnWidths, ",", CHR(13) + CHR(10) ) )
		                  lcNewColumnWidhts = m.lcNewColumnWidhts + "," + ;
		                     LTRIM(STR( VAL( laWidths[i] ) * m.lnWidthRatio ))
		               ENDFOR
		               .COLUMNWIDTHS = SUBSTR( m.lcNewColumnWidhts, 2 )
		            ENDIF
		
		*--------------------------------------------
		* Nachbehandlung für rechtsbündige Controls.
		*(..)Spezialbehandlung für VPME-Labels.
		*--------------------------------------------
		            IF ( .BASECLASS $ "LabelCheckboxOptionbutton" AND .ALIGNMENT == 1 ) ;
		                  OR ( .BASECLASS == "Label" AND PEMSTATUS( m.toControl, 'lOverrideLeftAlignment', 5 ) ;
		                    AND .lOverrideLeftAlignment AND .ALIGNMENT == 0 )
		               .LEFT = ( ._nOriginalLeft + ._nOriginalwidth ) * m.lnWidthRatio - .WIDTH
		            ENDIF
		
		         ENDIF
		
		*--------------------------------------------
		* Restore IntegralHeight setting.
		*--------------------------------------------
		         IF m.llIntegralHeight
		            .INTEGRALHEIGHT = .T.
		         ENDIF
		
		*--------------------------------------------
		* Grid.RowHeight und Grid.HeaderHeight darf
		* erst nach der Änderung der FontSize gesetzt
		* werden, sonst wirds ignoriert.
		*--------------------------------------------
		         IF m.llSetRowHeight
		            .ROWHEIGHT	  = ._nOriginalRowHeight * m.lnHeightRatio
		            .HEADERHEIGHT = ._nOriginalHeaderHeight * m.lnHeightRatio
		         ENDIF
		
		*--------------------------------------------
		* Bei Basisklasse 'Control' rufen wir deren
		* Methode 'Resize' auf.
		*--------------------------------------------
		         IF .BASECLASS == "Control" ;
		               AND NOT .NAME == m.This.NAME
		            .RESIZE()
		         ENDIF
		
		      ENDWITH
		*--------------------------------------------
		* Zwangsausstieg.
		*--------------------------------------------
		      EXIT
		   ENDDO
		
		CATCH TO loerror
		ENDTRY
		
		toControl = .NULL.
		RELEASE toControl
		
		*/* Alternative FontSize-Berechnungsmöglichkeiten:
		*!*			DO CASE
		*!*				CASE .F.
		*!*					*--------------------------------------------
		*!*					* Die Font-Berechnung des Resizers von Markus
		*!*					* Auer.
		*!*					*--------------------------------------------
		*!*					.FontSize = 0.5 + ._nOriginalFontsize * MIN( ;
		*!*						IIF( m.lnHeightRatio>1, m.lnHeightRatio, (m.lnHeightRatio*2+1)/3 ), ;
		*!*						IIF( m.lnWidthRatio >1, m.lnWidthRatio,  (m.lnWidthRatio *3+1)/4 ) )
		*!*				OTHERWISE
		*!*					*--------------------------------------------
		*!*					* Die Font-Berechnung aus meinem alten
		*!*					* Resizer.
		*!*					*--------------------------------------------
		*!*					LOCAL lnNewFontSize, lnPFontHeight
		*!*					lnNewFontSize = MAX( MIN_FONT_SIZE, ;
		*!*						INT( ._nOriginalFontsize * m.lnWidthRatio ) )
		*!*					DO CASE
		*!*						CASE .BaseClass == "Page"
		*!*							lnPFontHeight = FONTMETRIC( 1, .FontName, m.lnNewFontSize ) / (.Parent.PageHeight - BORDER_3D)
		*!*							DO WHILE m.lnNewFontSize > MIN_FONT_SIZE AND m.lnPFontHeight > ;
		*!*									FONTMETRIC( 1, .FontName, ._nOriginalFontSize ) / (.Parent._nOriginalPageHeight - BORDER_3D)
		*!*								lnNewFontSize = m.lnNewFontSize - 1
		*!*								lnPFontHeight = FONTMETRIC( 1, .FontName, m.lnNewFontSize ) / (.Parent.PageHeight - BORDER_3D)
		*!*							ENDDO
		*!*						CASE .BaseClass == "Column"
		*!*							lnPFontHeight = FONTMETRIC( 1, .FontName, m.lnNewFontSize ) / .Parent.RowHeight
		*!*							DO WHILE m.lnNewFontSize > MIN_FONT_SIZE AND m.lnPFontHeight > ;
		*!*									FONTMETRIC( 1, .FontName, ._nOriginalFontSize ) / .Parent._nOriginalRowHeight
		*!*								lnNewFontSize = m.lnNewFontSize - 1
		*!*								lnPFontHeight = FONTMETRIC( 1, .FontName, m.lnNewFontSize ) / .Parent.RowHeight
		*!*							ENDDO
		*!*						OTHERWISE
		*!*							lnPFontHeight = FONTMETRIC( 1, .FontName, m.lnNewFontSize ) / .Height
		*!*							DO WHILE m.lnNewFontSize > MIN_FONT_SIZE AND m.lnPFontHeight > ;
		*!*									FONTMETRIC( 1, .FontName, ._nOriginalFontSize ) / ._nOriginalHeight
		*!*								lnNewFontSize = m.lnNewFontSize - 1
		*!*								lnPFontHeight = FONTMETRIC( 1, .FontName, m.lnNewFontSize ) / .Height
		*!*							ENDDO
		*!*					ENDCASE
		*!*					.FontSize = m.lnNewFontSize
		*!*			ENDCASE
		
		
		
		
		
	ENDPROC

	PROCEDURE resizedelayed
		LPARAMETERS toControl
		
		*--------------------------------------------
		* Zur einfacheren Fehlersuche merken wir uns
		* den Namen des Controls.
		*--------------------------------------------
		LOCAL lcControlName, lcSubControlName
		lcControlName = m.This.GetName( m.toControl )
		
		*--------------------------------------------
		* Feststellen, ob bereits mindestens 1 Resize
		* der Form vorausgegangen ist (nur dann ist
		* es notwendig, die neu hinzugefügten Objekte
		* zu resizen).
		*--------------------------------------------
		LOCAL llResizeNeeded, lcBaseClass, loSubControl
		DO CASE
			CASE TYPE( "m.toControl.Parent._nOriginalFontSize" ) == "N"
				llResizeNeeded = .T.
			CASE TYPE( "m.toControl.Parent._nOriginalWidth" ) == "N"
				llResizeNeeded = .T.
			OTHERWISE
				llResizeNeeded = .F.
		ENDCASE
		
		IF m.llResizeNeeded
			WITH This
		
				lcBaseClass = m.toControl.BaseClass
		
				IF NOT m.lcBaseClass == "Custom"
					.SaveOriginalSize( m.toControl )
				ENDIF
		
				DO CASE
		
					CASE m.lcBaseClass $ "Container,Page"
						.SaveContainer( m.toControl )
						.ResizeContainer( m.toControl )
		
					CASE m.lcBaseClass == "Pageframe"
						FOR EACH loSubControl IN m.toControl.PAGES
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.SaveContainer( m.loSubControl )
						ENDFOR
						*--------------------------------------------
						* Da das Ändern der Page.Fontsize die Höhe
						* des PageTab ändert, muß die Fontsize der
						* Pages angepaßt werden, bevor die Höhe
						* des Pageframe angepaßt wird.
						* Deshalb werden zuerst alle Pages rekursiv
						* resized und danach erst der Pageframe.
						*--------------------------------------------
						FOR EACH loSubControl IN m.toControl.PAGES
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.ResizeControl( m.loSubControl )
						ENDFOR
						.ResizeControl( m.toControl )
						FOR EACH loSubControl IN m.toControl.PAGES
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.ResizeControl( m.loSubControl )
						ENDFOR
		
					CASE m.lcBaseClass == "Grid"
						FOR EACH loSubControl IN m.toControl.COLUMNS
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.SaveContainer( m.loSubControl )
						ENDFOR
						.ResizeControl( m.toControl )
						IF .lResizeGridContents
							FOR EACH loSubControl IN m.toControl.COLUMNS
								*--------------------------------------------
								* Zur einfacheren Fehlersuche merken wir uns
								* den Namen des Controls.
								*--------------------------------------------
								lcSubControlName = m.This.GetName( m.loSubControl )
		
								.ResizeContainer( m.loSubControl )
							ENDFOR
						ENDIF
		
					CASE m.lcBaseClass == "Column"
						.SaveContainer( m.toControl )
						.ResizeControl( m.toControl )
						IF .lResizeGridContents
							.ResizeContainer( m.toControl )
						ENDIF
		
					CASE m.lcBaseClass $ "Commandgroup,Optiongroup"
						FOR EACH loSubControl IN m.toControl.BUTTONS
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.SaveOriginalSize( m.loSubControl )
						ENDFOR
						.ResizeControl( m.toControl )
						*--------------------------------------------
						* Bei AutoSize=.T. kann es passieren, daß Vfp
						* versucht den vorhandenen Platz optimal
						* auszunutzen und dazu die enthaltenen
						* Optionbuttons selbstständig verschiebt.
						*--------------------------------------------
						LOCAL llAutoSize
						llAutoSize = m.toControl.AutoSize
						IF m.llAutoSize
							toControl.AutoSize = .F.
						ENDIF
						FOR EACH loSubControl IN m.toControl.BUTTONS
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.ResizeControl( m.loSubControl )
						ENDFOR
						IF m.llAutoSize
							toControl.AutoSize = .T.
						ENDIF
					
					CASE NOT m.lcBaseClass == "Custom"
						.ResizeControl( m.toControl )
		
				ENDCASE
		
			ENDWITH
		ENDIF
		
		toControl = .NULL.
		loSubControl = .NULL.
		RELEASE toControl, loSubControl
		
	ENDPROC

	PROCEDURE RightClick
		LOCAL loResizer, i, lcPercent, laMenuPads[1]
		loResizer = m.This
		DEFINE POPUP mwResize SHORTCUT RELATIVE FROM MROW(),MCOL()
		FOR i=1 TO ALINES( laMenuPads, STRTRAN( m.THIS.cMenuPads, ";", CHR(13)+CHR(10) ) )
		
			lcPercent = STR(VAL( laMenuPads[i] ))
		
			DEFINE BAR (i) OF mwResize PROMPT (SUBSTR( laMenuPads[i], AT("=",laMenuPads[i]) + 1 ))
			ON SELECTION BAR (i) OF mwResize m.loResizer.ResetSize( &lcPercent. )
		
		ENDFOR
		
		ACTIVATE POPUP mwResize
		
		loResizer = .NULL.
		RELEASE loResizer
		
	ENDPROC

	PROCEDURE savecontainer
		LPARAMETERS toContainer
		
		*--------------------------------------------
		* Zur einfacheren Fehlersuche merken wir uns
		* den Namen des Controls.
		*--------------------------------------------
		LOCAL lcContainerName, lcControlName, lcSubControlName
		lcContainerName = m.This.GetName( m.toContainer )
		
		WITH This
		
			LOCAL lcBaseClass, loControl, loSubControl
		
			IF NOT m.toContainer.BaseClass == "Form"
				.SaveOriginalSize( m.toContainer )
			ENDIF
			
			FOR EACH loControl IN m.toContainer.CONTROLS
		
				*--------------------------------------------
				* Zur einfacheren Fehlersuche merken wir uns
				* den Namen des Controls.
				*--------------------------------------------
				lcControlName = m.This.GetName( m.loControl )
		
				IF PEMSTATUS( m.loControl, "BaseClass", 2 )
					*--------------------------------------------
					* Protected property or protected object.
					*--------------------------------------------
					LOOP
				ENDIF
		
				lcBaseClass = m.loControl.BaseClass
		
				IF NOT m.lcBaseClass == "Custom"
					.SaveOriginalSize( m.loControl )
				ENDIF
		
				DO CASE
		
					CASE m.lcBaseClass == "Container"
						.SaveContainer( m.loControl )
		
					CASE m.lcBaseClass == "Pageframe"
						FOR EACH loSubControl IN m.loControl.PAGES
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.SaveContainer( m.loSubControl )
						ENDFOR
		
					CASE m.lcBaseClass == "Grid"
						FOR EACH loSubControl IN m.loControl.COLUMNS
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.SaveContainer( m.loSubControl )
						ENDFOR
		
					CASE m.lcBaseClass $ "Commandgroup,Optiongroup"
						FOR EACH loSubControl IN m.loControl.BUTTONS
							*--------------------------------------------
							* Zur einfacheren Fehlersuche merken wir uns
							* den Namen des Controls.
							*--------------------------------------------
							lcSubControlName = m.This.GetName( m.loSubControl )
		
							.SaveOriginalSize( m.loSubControl )
						ENDFOR
		
				ENDCASE
		
			ENDFOR
		
		ENDWITH
		
		toContainer = .NULL.
		loControl = .NULL.
		loSubContainer = .NULL.
		RELEASE toContainer, loControl, loSubContainer
		
	ENDPROC

	PROCEDURE saveformsize
		WITH This
			.SaveOriginalSize( m.Thisform )
			._lFormSizeSaved = .T.
			.ZOrder( .nZOrder )	&& Resize-Bitmap in den Vordergrund (0) oder Hintergrund (1)
		ENDWITH
		
		WITH Thisform
			IF .MinHeight == -1
				.MinHeight = INT( ._nOriginalHeight * m.This.nMinFactor )
			ENDIF
			IF .MinWidth == -1
				.MinWidth = INT( ._nOriginalWidth * m.This.nMinFactor )
			ENDIF
		ENDWITH
		
	ENDPROC

	PROCEDURE saveoriginalsize
		LPARAMETERS toControl
		
		*--------------------------------------------
		* Zur einfacheren Fehlersuche merken wir uns
		* den Namen des Controls.
		*--------------------------------------------
		LOCAL lcControlName
		lcControlName = m.This.GetName( m.toControl )
		
		IF m.toControl.Name == m.This.Name
			toControl = .NULL.
			RELEASE toControl
			RETURN
		ENDIF
		
		WITH toControl
		
			*--------------------------------------------
			*(..)Vfp8: Pages die visuell designed und via
			*(..)Pageframe.MemberClass hinzugefügt wurden
			*(..)haben ein verstecktes 'Width' Property.
			*(..)Allerdings sieht das nur PEMSTATUS(),
			*(..)beim Zugriff gibts eine Fehlermeldung.
			*--------------------------------------------
			IF PEMSTATUS( m.toControl, 'Width', 5 ) ;
					AND NOT m.toControl.BaseClass == "Page"
				*--------------------------------------------
				*(..)Sonderbehandlung für Controls mit
				*(..)Visible=.F., Alignment=1 (Right) und
				*(..)Width=(default). In diesem Fall liest
				*(..)VFP die Width der *ParentClass* aus. Die
				*(..)Width *dieses* Controls wird neu
				*(..)gesetzt, sobald Visible=.T. gesetzt
				*(..)wird.
				*(..)Sonderbehandlung für VPME Labels.
				*--------------------------------------------
				IF ( .BaseClass $ "LabelCheckboxOptionbutton" AND NOT .Visible AND .Alignment == 1 ) ;
						OR ( .BaseClass == "Label" AND PEMSTATUS( m.toControl, 'lOverrideLeftAlignment', 5 ) ;
						AND .lOverrideLeftAlignment AND .Alignment == 0 )
					LOCAL lnLeft, lnRight, llAutoSize, llVisible
					lnLeft			= .Left
					lnRight			= m.lnLeft + .Width
					llAutoSize		= .AutoSize
					llVisible		= .Visible
					IF NOT m.llAutoSize
						.AutoSize	= .T.
					ENDIF
					IF NOT m.llVisible
						.Left		= -2000
					ENDIF
					.Visible		= .T.
					IF NOT m.llAutoSize
						.AutoSize	= .F.
					ENDIF
					IF NOT m.llVisible
						.Visible	= .F.
					ENDIF
					.Left			= IIF( .Alignment == 0, m.lnLeft, m.lnRight - .Width )
				ENDIF
				*--------------------------------------------
				* Es gibt einen Bug in VFP6 und VFP7 der dazu
				* führt, daß 3D-Shapes mit Height<2 oder
				* Width<2 beim Resize dunkelgraue oder weiße
				* Linien hinterlassen können. Der Bug tritt
				* nur auf, wenn das Shape direkt auf der Form
				* liegt und kein Objekt optisch hinter dem 
				* Shape liegt.
				* Ob dieser Bug auch in VFP3 oder VFP5
				* auftritt wurde nicht getestet.
				*--------------------------------------------
				ASSERT NOT ( m.toControl.BaseClass == "Shape" ;
					AND m.toControl.Parent.BaseClass == "Form" ;
					AND m.toControl.SpecialEffect == 0 ;		&& 3D.
					AND m.toControl.Width < 2 ) ;
					MESSAGE IIF( VERSION(3) == "49", ;
					"Warnung von mwResize: Wegen eines Fehlers in VFP sollten sie " + ;
					m.toControl.Parent.Name + "." + m.toControl.Name + ".Width = 2 " + ;
					"setzen um deplazierte Linien auf der Form zu vermeiden.", ;
					"Warning from mwResize: Due to a bug in VFP you should set " + ;
					m.toControl.Parent.Name + "." + m.toControl.Name + ".Width = 2 " + ;
					"to avoid misplaced lines on the form." )
				ASSERT NOT ( m.toControl.BaseClass == "Shape" ;
					AND m.toControl.Parent.BaseClass == "Form" ;
					AND m.toControl.SpecialEffect == 0 ;		&& 3D.
					AND m.toControl.Height < 2 ) ;
					MESSAGE IIF( VERSION(3) == "49", ;
					"Warnung von mwResize: Wegen eines Fehlers in VFP sollten sie " + ;
					m.toControl.Parent.Name + "." + m.toControl.Name + ".Height = 2 " + ;
					"setzen um deplazierte Linien auf der Form zu vermeiden.", ;
					"Warning from mwResize: Due to a bug in VFP you should set " + ;
					m.toControl.Parent.Name + "." + m.toControl.Name + ".Height = 2 " + ;
					"to avoid misplaced lines on the form." )
				*--------------------------------------------
				* Originalmaße merken.
				*--------------------------------------------
		*!* - rk - 2013-4-2 - treat width the same as the rest. check for existence before adding.
				IF PEMSTATUS( m.toControl, 'Width', 5 )
					.ADDPROPERTY( '_nOriginalWidth', .WIDTH )
				ENDIF 
				IF PEMSTATUS( m.toControl, 'Height', 5 )
					.ADDPROPERTY( '_nOriginalHeight', .HEIGHT )
				ENDIF
				IF PEMSTATUS( m.toControl, 'Left', 5 )
					.ADDPROPERTY( '_nOriginalLeft', .LEFT )
				ENDIF
				IF PEMSTATUS( m.toControl, 'Top', 5 )
					.ADDPROPERTY( '_nOriginalTop', .TOP )
				ENDIF
			ENDIF
		
			IF PEMSTATUS( m.toControl, 'Fontsize', 5 )
				.ADDPROPERTY( '_nOriginalFontsize', .FONTSIZE )
			ENDIF
		
			IF PEMSTATUS( m.toControl, 'RowHeight', 5 )
				.ADDPROPERTY( '_nOriginalRowHeight', .RowHeight )
				.ADDPROPERTY( '_nOriginalHeaderheight', .HEADERHEIGHT )
			ENDIF
		
			IF PEMSTATUS( m.toControl, 'PageHeight', 5 )
				.ADDPROPERTY( '_nOriginalPageheight', .PAGEHEIGHT )
				.ADDPROPERTY( '_nOriginalPagewidth', .PAGEWIDTH )
			ENDIF
		
			IF PEMSTATUS( m.toControl, 'Margin', 5 )
				.ADDPROPERTY( '_nOriginalMargin', .MARGIN )
			ENDIF
		
			IF PEMSTATUS( m.toControl, 'ColumnWidths', 5 )
				.ADDPROPERTY( '_cOriginalColumnWidths', .COLUMNWIDTHS )
			ENDIF
		
		ENDWITH
		
		toContainer = .NULL.
		RELEASE toContainer
		
	ENDPROC

	PROCEDURE setcolor
		#DEFINE COLOR_SCROLLBAR         0
		#DEFINE COLOR_BACKGROUND        1
		#DEFINE COLOR_ACTIVECAPTION     2
		#DEFINE COLOR_INACTIVECAPTION   3
		#DEFINE COLOR_MENU              4
		#DEFINE COLOR_WINDOW            5
		#DEFINE COLOR_WINDOWFRAME       6
		#DEFINE COLOR_MENUTEXT          7
		#DEFINE COLOR_WINDOWTEXT        8
		#DEFINE COLOR_CAPTIONTEXT       9
		#DEFINE COLOR_ACTIVEBORDER      10
		#DEFINE COLOR_INACTIVEBORDER    11
		#DEFINE COLOR_APPWORKSPACE      12
		#DEFINE COLOR_HIGHLIGHT         13
		#DEFINE COLOR_HIGHLIGHTTEXT     14
		#DEFINE COLOR_BTNFACE           15
		#DEFINE COLOR_BTNSHADOW         16
		#DEFINE COLOR_GRAYTEXT          17
		#DEFINE COLOR_BTNTEXT           18
		#DEFINE COLOR_INACTIVECAPTIONTEXT 19
		#DEFINE COLOR_BTNHIGHLIGHT      20
		#DEFINE COLOR_3DDKSHADOW        21
		#DEFINE COLOR_3DLIGHT           22
		#DEFINE COLOR_INFOTEXT          23
		#DEFINE COLOR_INFOBK            24
		#DEFINE COLOR_DESKTOP           COLOR_BACKGROUND
		#DEFINE COLOR_3DFACE            COLOR_BTNFACE
		#DEFINE COLOR_3DSHADOW          COLOR_BTNSHADOW
		#DEFINE COLOR_3DHIGHLIGHT       COLOR_BTNHIGHLIGHT
		#DEFINE COLOR_3DHILIGHT         COLOR_BTNHIGHLIGHT
		#DEFINE COLOR_BTNHILIGHT        COLOR_BTNHIGHLIGHT
		
		IF NOT TYPE( [GetSysColor( COLOR_BTNHIGHLIGHT )] ) == "N"
			DECLARE INTEGER GetSysColor IN Win32API INTEGER nIndex
		ENDIF
		
		WITH This
			.lblHighLight.FORECOLOR	= GetSysColor( COLOR_BTNHIGHLIGHT )
			.lblShading.FORECOLOR	= GetSysColor( COLOR_BTNSHADOW )
		ENDWITH
		
	ENDPROC

	PROCEDURE zz_readme
		#IF .F.
		
		***************************************************************************
		mwResize Version 5.1 (3rd of April, 2013)
		Author: Markus Winhard, mw@bingo-ev.de, 
		modified by Richard Kaye, richakaye@gmail.com
		***************************************************************************
		mwResize Version 5.0 (1st of October, 2008)
		Author: Markus Winhard, mw@bingo-ev.de
		Resize (zoom, stretch, shrink) all controls on a VFP 6/7/8/9 form 
		while the form is resized.
		***************************************************************************
		This resizer was developed based on the VFP6 FFC resizer, Markus Auer's
		public domain resizer (ftp.prolib.de), Soft Classics public domain
		'Stretchy Resize Control' (www.codemine.com), and some resize code found on
		Compuserve's VFOX forum some years ago. Thanks to all of them for showing
		me their ideas. I've learned much from all of them.
		***************************************************************************
		* All files are provided 'as is' without warranty of any kind.            *
		* In no event shall its authors, contributors, or distributors be         *
		* liable for any damages.                                                 *
		***************************************************************************
		As this is for free, use it on your own risk <g>.
		***************************************************************************
		
		How to use it:
		
		Drop it on a form or form class in any place (it positions itself at runtime).
		The only code snippet you really need is this:
		
		in Form.Resize:
		  *********************************
		  m.This.mwResize1.Resize( m.This )
		  *********************************
		  
		The only thing you have to add to your project is the mwResize class library.
		The other files are only for demonstration purposes (see below).
		
		It has a rightclick menu with predefined form sizes (you can change 
		them, see property cMenuPads).
		
		If the form's MinWidth and MinHeight are left at their default value of -1
		mwResize sets them to 50% of the form's original dimensions. You can change 
		the minimum zoom factor: see property nMinFactor. Tip: Don't forget to 
		remove unwanted zoom factors from the property cMenuPads, too, if you set
		nMinFactor to any value higher than 0.75.
		
		If you want the columns and textboxes of a grid to be resized too, 
		set lResizeGridContents=.T..
		
		If you want mwResize to stay behind other controls set nZOrder=1.
		
		If Form.Borderstyle is anything else than 3 the control is made invisible.
		  
		If you use visible classes based on 'Control' and want it's contents to be
		resized, add code to the Resize() method of the Control to resize the 
		contents yourself. The mwResize calls the Control's Resize() method 
		at the appropriate time.
		
		If you don't want a control to be resized by mwResize write NODEFAULT
		into its Move() method.
		
		If you don't want a container's contents to be resized by mwResize write
		the string *NORESIZE* into the container's comment property. If you like
		to resize the container's contents yourself write code in its Resize()
		method. This works for every control that can contain other controls.
		
		As mwResize by default reads a form's original width and height at first 
		resize, one of these two values is wrong by one pixel. If you are one of 
		these 110% programmers <g> set lAutoSaveformSize=.F. in design and call
		  ***********************************
		  m.Thisform.mwResize1.SaveFormSize()
		  ***********************************
		whenever all of your controls are instantiated, but before changing the 
		form's size to the size it had when it was closed last time or whatever.
		Decide for your situation if this is in a form's Init(), *first* Show(), 
		or *first* Activate(). The very latest place for this task ist the end 
		of a form's first Activate().
		
		Attention: There's a bug in VFP6 and VFP7 with 3D shapes. You may see
		misplaced lines on the form after a resize when the shape's Width or 
		Height property was initially set to 0 or 1. 
		The bug does only appear when the shape is directly on the form and 
		there's no other control in the background of the shape. Shapes on a 
		page or inside a container are not affected.
		The solution is simple: Set the property to 2. This will keep the 
		'3D line' appearance of the shape and avoid the VFP bug.
		To help you identify these shapes there's an ASSERT command in mwResize. 
		If you have SET ASSERTS ON mwResize will remind you with a warning 
		whenever it finds such a shape.
		
		If you have to add an object at runtime (this is what I call "delayed 
		instantiation") you can resize it according to the current form size before 
		you make it visible.
		  ********************************************************
		  m.This.AddObject( "myContainer", "AnyClass" )
		  m.Thisform.mwResize1.ResizeDelayed( m.This.myContainer )
		  This.myContainer.Visible = .T.
		  ********************************************************
		
		If you want a form to be initially maximized setting WindowState=2 in
		design will not resize the controls on your form. Instead add this code
		to the form's show event:
		  ********************************************************
		  WITH This
		    LOCAL lnInitialWidth, lnInitialHeight
		    lnInitialWidth = .Width
		    lnInitialHeight = .Height
		    .Width = _Screen.Width  - SYSMETRIC(3)*2
		    .Height = _Screen.Height - SYSMETRIC(4)*2 - SYSMETRIC(9)
		    .WindowState = 2
		    .Resize()
		    .Width = lnInitialWidth
		    .Height = lnInitialHeight
		  ENDWITH
		  ********************************************************
		In case you have a big grid on your form the following additional code 
		will speed up the initial display of this grid. However it may break 
		other code in your form class. So use it with care <g>.
		  ********************************************************
		  * in Form.Show()
		  IF NOT m.This.LockScreen
		    This.LockScreen = .T.
		  ENDIF
		  ********************************************************
		  * in Form.Activate()
		  IF m.This.LockScreen
		    This.LockScreen = .F.
		  ENDIF
		  ********************************************************
		
		If you have visible ActiveX controls on your forms and want them to change
		their font size just like the VFP controls do when you resize the form
		this is the way that works with most ActiveX controls:
		  - create a class based on OleControl for this ActiveX control
		    (just in case you have not already done this)
		  - create a new property 'fontsize1' together with an access and 
		    an assign method
		  - save the class and close the class designer
		  - CLEAR ALL
		  - open your OleControl class once again
		  - rename the property 'fontsize1' to 'fontsize' and allow VFP to rename
		  	the access and assign methods to fontsize_access() and 
		  	fontsize_assign() when VFP asks you for it
		  - remove all code from the access method, paste this code there instead:
		    ****************************************
		    RETURN INT(VAL(STR( m.This.Font.Size )))
		    ****************************************
		  - remove all code from the assign method, paste this code there instead:
			********************************
			LPARAMETERS tnNewFontSize
			This.Font.Size = m.tnNewFontSize    
			********************************
		Attention: This example assumes your ActiveX control uses one single Font 
		object named 'Font' and this Font object has a 'Size' property. Be sure to 
		check the ActiveX control's documentation that this is true for your special
		ActiveX control. There are many ActiveX controls around that use more than 
		one font and organize the Font objects in collections, arrays or whatever. 
		An example for these controls is bbListView (a List View ActiveX control 
		made by a VFP programmer that is able to fill itself from a VFP cursor or 
		a VFP array, www.officeline.hu/bb). Just to give you an idea I show you 
		what I did with bbListView:
		  *************************************************************************
		  PROCEDURE Init
		    WITH This
		      .AddProperty( "_aOriginalLogicalFontsize[" + ;
		        LTRIM(STR( ._nLogicalFontsUsed )) + "]" )
		      LOCAL i
		      FOR i=1 TO ._nLogicalFontsUsed	&& property added at design time
		        ._aOriginalLogicalFontsize[i] = .LogicalFonts[i].Size
		      ENDFOR
		    ENDWITH
		  ENDPROC
		  *************************************************************************
		  PROCEDURE FontSize_Access
		    RETURN INT(VAL(STR( m.This.LogicalFonts[1].Size )))
		  ENDPROC
		  *************************************************************************
		  PROCEDURE FontSize_Assign
		    LPARAMETERS tnNewFontSize
		    LOCAL i
		    WITH This
		      .LockState = .T.
		      FOR i=1 TO ._nLogicalFontsUsed
		        .LogicalFonts[i].Size = MIN( ._aOriginalLogicalFontsize[i], ;
		          m.tnNewFontSize * ._aOriginalLogicalFontsize[i] / ;
		          ._aOriginalLogicalFontsize[1] )
		      ENDFOR
		      .LockState = .F.
		    ENDWITH
		  ENDPROC
		  *************************************************************************
		I store the initial size of each font in a VFP array and resize them based
		on the size change for the first font in the array. As bbListView uses a 
		collection of 99 fonts and I'm using only the first two of them I set
		_nLogicalFontsUsed=2 at design time for performance reasons.
		  
		If you are using Markus Auer's 'Sizer' class and want to substitute it 
		with mwResize follow these steps:
		  - remove the sizer control from your form or form class, 
		  	remember it's name (probably it's 'Sizer')
		  - drop mwResize on the form or form class and give it the name the
		    removed sizer object had before
		  - set mwResize.lResizeGridContents=.T.
		That's all. See form SizeDemo for an example.
		
		For changes from prior versions see below.
		
		Enjoy,
		
		Markus Winhard
		
		
		----------------------------------------------------------------------
		Changes in Version 5.1:
		 - Fixed:  resizeControl - Fontsize of textboxes and comboboxes contained in columns
		 			was not scaling properly
		
		Changes in Version 5.0:
		- Fixed: No more RETURN statements within WITH...ENDWITH. Thanks to
			Jan Bucek for reporting this possible source of C0000005 errors.
		- Added new method GetName(). Called it whenever a control is going
			to be resized and stored its name and container hierarchy in a 
			variable. Now when there's an error during a resize operation you
			can do a LIST MEMORY in your errorhandler and look at the variables
			lcContainerName, lcSubContainerName, lcControlName, lcSubControlName
			and lcEditboxName to find the control that caused the error.
		- Fixed: With lResizeGridContents=.T. a grid's HeaderHeight was not
			adjusted. Controls on a container within a grid column were also not
			adjusted.
		
		Changes in Version 4.6:
		- Fixed: Protected member objects no longer raise an error.
			They are ignored as expected. It's up to the developer to resize
			these objects manually, e.g. from the resize() method of the
			surrounding container. The same applies to member objects that
			have their 'BaseClass' property marked 'Protected'.
			Thanks to Don Higgins for reporting this problem with the
			'VFPSkin' classes (http://www.vfpskin.com.ar/).
			Be aware that you have to call some VFPSkin method after mwResize
			has resized the objects to bring the skin back in synch with the
			resized objects. However at this time there's no documentation 
			with VFPSkin that describes how to do this.
		
		Changes in Version 4.5:
		- Fixed: Worked around a bug in VFP 8: Visually designed pages added 
			using the pageframe's MemberClass property have a hidden Width
			property. PEMSTATUS() sees it but you can't access it.
			Thanks to Thomas Geissler for reporting this problem.
		
		Changes in Version 4.4:
		- *NORESIZE* in comment property prevents resizing of contained controls
			(the resize of a single control could always be suppressed by a
			NODEFAULT in its Move() method).
		
		Changes in Version 4.3:
		- Fixed: Textbox.Height sometimes was too small when IntegralHeight=.T.
			Thanks to Peter Pledel for reporting this bug.
		- Fixed: Controls within Containers within Grid Columns were ignored 
			before.
		
		Changes in Version 4.2:
		- Fixed: The ResizeDelayed() method didn't work for delayed added
			Grid, Pageframe, Optiongroup and Commandgroup classes. 
			Thanks to Thomas Geissler for reporting this bug.
		
		Changes in Version 4.1:
		- Fixed: Controls on a page now can rely on Pageframe.PageHeight and
			.PageWidth during a resize.
		- During tests with ActiveX controls suddenly the resize event of
			mwResize was triggered. As it wasn't called as a method the
			parameter toObject was .F.. No idea why this happened but I 
			included a workaround.
		- Fixed: When a form was maximized and then zoomed using mwResize' 
			context menu the form's Top ans Left properties were not restored.
		- There's a new property: nMinFactor=0.5. It sets the value for the
			minimum zoom factor if the form's MinWidth=-1 and/or MinHeight=-1.
		- Fixed: Worked around a VFP bug. It happened when an Editbox had the 
			input focus while you were resizing the form using mwResize' 
			context menu and the Editbox was read only. Sometimes parts of the 
			Editbox were not drawn properly after the resize.
		- Fixed: Worked around another VFP bug. Shapes with Height < 2 or
			Width < 2 can lead to misplaced lines on the form after a resize.
			The bug affects only shapes directly on the form with no other 
			control behind them. Unfortunately mwResize cannot work around 
			this bug without some help on the developer's side. The developer 
			has to set a 3D shape's Width and Height not below 2. mwResize
			will keep the '3D line' appearance of shapes with Width or Height
			set to 2. 
			When a shape is on a page or inside a container there's no problem
			at all. You can set it's Width and Height to 2 or 0 (zero) to 
			achieve the '3D line' appearance.
		
		Changes in Version 4.0:
		- Fixed: Custom rowheight is no longer reset to default rowheight at 
			first resize when lResizeGridContents=.T..
		- Added support for delayed instantiated controls (most of the time
			these objects are containers on pages that are not initially 
			visible).
		- Changed base class to "Control" and added two labels using Marlett 
			font to get rid of the dependece on resize.bmp/msk. Moved the code
			from the "Image" based control's custom resize() method to a new 
			ResizeContainer() method because the Resize() method of objects
			based on 'Control' can't be called recursively (you can do this
			but VFP ignores it <eg>).
		- The color of the 3 shadowed diagonal lines in the lower right corner
			is automatically adjusted to the user's desktop settings in 
			mwResize.Init().
		- Changed the default shortcut menu to show 75%/85%/95% instead of 
			80%/90% because I feel we get smoother font sizing with these 
			proportions using the standard fontsize of 9. Of course you can 
			still define your own preferences using the property 
			mwResize.cMenuPads.
		- Added property mwResize.nZOrder. Set it to 1 if you want mwResize
			to stay behind other controls.
		- Added support for ActiveX controls that have a .Move() method or
			a .Move property but don't show it in VFP's property sheet.
		- Fixed: Minor bugs with left aligned or centered Visual ProMatrix 
			labels having lOverrideLeftAlignment=.T..
		- Added frmResize() method for compatibility with Markus Auer's 'Sizer'
			class. Changed the two label's names to lblHighLight and lblShading
			for the same reason.
		- Added Markus Auer's SizeDemo form to the package, substituted the 
			'Sizer' object with an instance of mwResize named 'Sizer' and set
			lResizeGridContents=.T.. This was done to prove that mwResize is 
			really compatible without changing a line of code.
		- Fixed: Removing the delayed instantiated container from page 2 of the
			SizeDemo form no longer triggers a GPF in VFP6 (hi wOOdy <g>).
		- Added a FontSize property to SizeDemo.vcx;Outline class along with 
			FontSize_Access() and FontSize_Assign() methods. It shows how 
			automatic font resizing can be done with ActiveX controls if 
			necessary.
		- Added a method zz_ReadMe() and moved this text there.
		
		Changes in version 3.2:
		- Fixed: Controls having Alignment=1 and Visual ProMatrix label having
			lOverrideLeftAlignment=.T. should be positioned correctly now.
		- Fixed: The automatically set Form.MinHeight and Form.MinWidth are now 
			immediately respected.
		- Fixed: Optiongroup and Commandgroup having AutoSize=.T. now position 
			their contained Optionbuttons / Commandbuttons correctly.
		- Smarter font sizing and margin adjustment.
		- Resize bitmap moved to foreground in SaveFormSize().
		- When a form is shrinked below her original width, the *text* portion of 
			comboboxes and spinners is shrinked proportional. This means that in 
			this situation comboboxes and spinners are shrinked less than other 
			controls for the sake of readability.
		
		Changes in version 3.1:
		- New property _nVersion (just holds the version number of mwResize).
		- Added special handling for right aligned Label/Checkbox/Optionbutton.
		- Added special handling for Visual ProMatrix label having
			lOverrideLeftAlignment=.T..
		
		Changes in version 3.0:
		- Fixed: Pageframe with tabs is now correctly resized.
		- Fixed: Some control's width wasn't correct after restoring a maximized
			form.
		- ColumnWidths (Combobox/Listbox) are adjusted now.
		- Margin is adjusted now.
		- Better font sizing.
		- If Form.MinHeight = -1 it's set to 50% of Form.Height.
			The same applies to Form.MinWidth.
		- New method SaveFormSize(). For explanations see above.
		
		Changes in version 2.0:
		- Fixed: In some environments the resize bitmap wasn't positioned in 
			the right lower corner until the first resize.
		- This.mwResize1.DoInit() in Form.Init() is no more necessary 
			(but you can still do this if you want for any reason).
		- No more delay at form init time. Original control sizes are now caught
			at first resize.
		- Enhanced rightclick menu with predefined form sizes (i.e. resize
			percentages). You can change them, see property cMenuPads.
		- Resize bitmap is only visible when Form.BorderStyle=3.
		
		Version 1.0:
		- was developed just because I thought it must be possible to program a
			resize class without the bugs and drawbacks the other resize classes 
			have. If I just knew then what it takes to get there...
		
		#ENDIF
		
	ENDPROC

	PROCEDURE lblHighLight.RightClick
		m.This.Parent.RightClick()
		
	ENDPROC

	PROCEDURE lblShading.RightClick
		m.This.Parent.RightClick()
		
	ENDPROC

ENDDEFINE
