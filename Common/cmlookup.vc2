*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmlookup.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
*< LIBCOMMENT: Form Lookup Manager and Find/List Dialogs />
*
DEFINE CLASS cmbinlookup AS cmlookupabstract OF "cmlookup.vcx" 		&& Lookup records by Date/numeric based keys.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: convertvalue		&& Parse and Convert the character source value into the appropriate binary data type.
		*m: lookup		&& Find a record using the date/numeric based key tag specified.
		*m: supportedoptions		&& Return a bitmask of lookup options supported by this class for the specified datatype.
	*</DefinedPropArrayMethod>

	Name = "cmbinlookup"
	
	PROCEDURE convertvalue		&& Parse and Convert the character source value into the appropriate binary data type.
		LPARAMETERS cValue, cType, uValue
		*++
		*>>Parse and Convert the character source value into the appropriate binary data type.
		* Return .T. if value was successfuly converted.
		*--
		  DO CASE
		    CASE TRIM(m.cValue) == '*' OR TRIM(m.cValue) == ''
		      m.uValue = .NULL.
		
		    CASE m.cType = 'D'
		      m.uValue = THISFORM.oString.ParseDate(m.cValue)
		      IF ISNULL(m.uValue)
		        IF NOT ISNULL(THISFORM.oMessage)
		          THISFORM.oMessage.SetLastMessage('%MsgBadDate')
		        ENDIF
		        RETURN .F.
		      ENDIF
		
		    CASE m.cType $ 'NYI'
		      IF m.cType = 'Y'  && Strip off any currency indicator
		        m.cValue = STRTRAN(UPPER(m.cValue), UPPER(SET('CURRENCY', 1)), '')
		      ENDIF
		      IF TYPE(m.cValue) != 'N'
		        IF NOT ISNULL(THISFORM.oMessage)
		          THISFORM.oMessage.SetLastMessage('%MsgBadNumber')
		        ENDIF
		        RETURN .F.
		      ENDIF
		      IF m.cType = 'Y'
		        m.uValue = VAL('$' + m.cValue)           && '$' prefix will cause conversion to currency type
		      ELSE
		        m.uValue = VAL(m.cValue)
		      ENDIF
		
		    OTHERWISE
		      ERROR 'Unsupported Type'
		      RETURN .F.
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE lookup		&& Find a record using the date/numeric based key tag specified.
		LPARAMETERS cFullMatchValue, cTagName, cPhoneticTag, cWorkArea, nFlags, cDisplayExp, oProgress
		*++
		*>>Find a record using the date/numeric based key tag specified.
		*
		* nFlags bitmask can contain bits:
		*  LOOKUPMASK_FINDALL - Find all matches, putting results in a temporary cursor
		*  LOOKUPMASK_RANGE     - Enables a range of matching values
		*--
		PRIVATE plAbort
		LOCAL lRange, cKeyExpression, uLowValue, uHighValue, cFldName, cGlobalFilterExpression
		
		  * Progress indicator is optional
		  IF PCOUNT() < 7
		    m.oProgress = .NULL.
		  ENDIF
		
		  * Get flag settings for optional behaviors
		  THIS.lFindAll = BITTEST(m.nFlags, LOOKUPFLAG_FINDALL)
		
		  * Apply index normalization to match string.
		  SELECT (m.cWorkarea)
		  IF TAGNO(m.cTagName) = 0
		    m.cFldName = m.cTagname
		    m.cTagName = ''
		    m.cKeyExpression = m.cFldName
		  ELSE
		    m.cFldName = TagField(m.cTagname)
		    m.cKeyExpression = NORMALIZE(KEY(TAGNO(m.cTagName)))
		  ENDIF
		
		  * Parse the match values and convert to appropriate binary format per datatype.
		  m.lRange = CHR(0) $ m.cFullMatchValue
		  IF m.lRange
		    IF NOT THIS.ConvertValue(GetToken(@m.cFullMatchValue, CHR(0)), TYPE(m.cFldname), @m.uLowValue) ;
		    OR NOT THIS.ConvertValue(m.cFullMatchValue, TYPE(m.cFldname), @m.uHighValue)
		      RETURN 0
		    ENDIF
		    IF m.uLowValue > m.uHighValue
		      IF NOT ISNULL(THISFORM.oMessage)
		        THISFORM.oMessage.SetLastMessage('%MsgBadRange')
		      ENDIF
		      RETURN 0
		    ENDIF
		  ELSE
		    IF NOT THIS.ConvertValue(m.cFullMatchValue, TYPE(m.cFldname), @m.uLowValue)
		      RETURN 0
		    ENDIF
		    m.uHighValue = .NULL.
		  ENDIF
		
		  * Re-open the source cursor in a private workarea so we don't affect record buffering
		  m.cGlobalFilterExpression = THIS.OpenSource(m.cWorkarea)
		
		  IF '(' $ m.cKeyExpression
		    IF NOT ISNULL(m.uLowValue)
		      m.uLowValue = TRIM(EVALUATE(STRTRAN(m.cKeyExpression, '(' + UPPER(m.cFldName), '(m.uLowValue')))
		    ENDIF
		    IF NOT ISNULL(m.uHighValue)
		      m.uHighValue = TRIM(EVALUATE(STRTRAN(m.cKeyExpression, '(' + UPPER(m.cFldName), '(m.uHighValue')))
		    ENDIF
		  ENDIF
		  * Generate default display expression if none specified.
		  IF EMPTY(m.cDisplayExp)
		    IF TYPE(m.cFldname) = 'D'
		      m.cDisplayExp = 'THISFORM.oString.FormatDate(' + m.cFldName + ')'
		    ELSE
		      m.cDisplayExp = 'STR(' + m.cFldName + ',16,' +  LTRIM(STR(SET('DECIMALS'))) + ')'
		      IF TYPE(m.cFldname) = 'Y'
		        IF SET('CURRENCY') = 'LEFT'
		          m.cDisplayExp = '"' + SET('CURRENCY',1) + '" + LTRIM(' + m.cDisplayExp + ')'
		        ELSE
		          m.cDisplayExp = m.cDisplayExp + ' + "' + SET('CURRENCY',1) + '"'
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  IF NOT ISNULL(m.uLowValue) OR NOT ISNULL(m.uHighValue)
		    IF NOT EMPTY(m.cTagname)
		      SET ORDER TO (m.cTagname)
		      DO CASE
		        CASE NOT m.lRange
		          SET KEY TO (m.uLowValue)
		        CASE ISNULL(m.uLowValue)
		          SET KEY TO RANGE ,(m.uHighValue)
		        CASE ISNULL(m.uHighValue)
		          SET KEY TO RANGE (m.uLowValue),
		        OTHERWISE
		          SET KEY TO RANGE (m.uLowValue),(m.uHighValue)
		      ENDCASE
		      GO TOP
		    ELSE
		      LOCAL cMatchExp
		      DO CASE
		        CASE NOT m.lRange
		          m.cMatchExp = m.cKeyExpression + '=m.uLowValue'
		        CASE ISNULL(m.uLowValue)
		          m.cMatchExp = m.cKeyExpression + '<=m.uHigh'
		        CASE ISNULL(m.uHighValue)
		          m.cMatchExp = m.cKeyExpression + '>=m.uLowValue'
		        OTHERWISE
		          m.cMatchExp = m.cKeyExpression + '>=m.uLowValue AND ' + m.cKeyExpression + '<=m.uHighValue'
		      ENDCASE
		      m.cGlobalFilterExpression = m.cGlobalFilterExpression + ' AND ' +  m.cMatchExp
		    ENDIF
		  ENDIF
		
		  m.plAbort = .F.
		  SCAN ALL FOR &cGlobalFilterExpression ;
		       WHILE NOT m.plAbort AND THIS.nHitCount < THIS.nMaxHits    && Limit result set scan to a practical number.
		
		    * If we are only looking for 1 result, stop looking once we get a partial exact match or better.
		    IF NOT THIS.AddHit(1, EVALUATE(m.cDisplayExp), RECNO(), m.oProgress)
		      EXIT
		    ENDIF
		  ENDSCAN
		
		  IF THIS.nHitCount = 0 AND NOT ISNULL(THISFORM.oMessage)
		    IF m.lRange
		      THISFORM.oMessage.SetLastMessage('%MsgRangeNotFound')
		    ELSE
		      THISFORM.oMessage.SetLastMessage('%MsgNotFound', m.cFullMatchValue)
		    ENDIF
		  ENDIF
		
		  THIS.CloseSource(m.oProgress)
		  RETURN THIS.nBestRecord
		
	ENDPROC

	PROCEDURE supportedoptions		&& Return a bitmask of lookup options supported by this class for the specified datatype.
		*++
		*>>Return a bitmask of lookup options supported by this class for the specified datatype.
		*--
		  DODEFAULT()
		  RETURN LOOKUPMASK_FINDALL + LOOKUPMASK_RANGE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdatelookup AS custom 		&& Lookup records by date based keys.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: lookup		&& Find a record using the character based key tag specified.
		*p: cversion
		*p: lallowwildcard		&& Set to .F. to treat wildcard characters in match values as regular characters.
		*p: nhitcount		&& Number of hits found by the last lookup call.
		*p: ninterval		&& Progress indicator update interval
		*p: nmaxhits		&& Maximum number of matching records to consider for result set.
		*p: nsupportedflags		&& Bitmask of lookup options supported by this class, set by the Init() method.
	*</DefinedPropArrayMethod>

	cversion = 2.0.0
	lallowwildcard = .T.		&& Set to .F. to treat wildcard characters in match values as regular characters.
	Name = "cmdatelookup"
	nhitcount = 0		&& Number of hits found by the last lookup call.
	ninterval = 50		&& Progress indicator update interval
	nmaxhits = 5000		&& Maximum number of matching records to consider for result set.
	nsupportedflags = 0		&& Bitmask of lookup options supported by this class, set by the Init() method.
	
	PROCEDURE init
		LOCAL oRegistry
		  * Set mask of lookup options that this class supports.
		  THIS.nSupportedFlags = LOOKUPMASK_FINDALL + LOOKUPMASK_RANGE
		
		  * Get the phonetic normalization function from the registry.
		  m.oRegistry = FindGlobalObject('cmRegistry')
		
	ENDPROC

	PROCEDURE lookup		&& Find a record using the character based key tag specified.
		LPARAMETERS cTagName, cFullMatchValue, cWorkArea, cDisplayExp, nFlags, oProgress
		*++
		*>>Find a record using the character based key tag specified.
		*
		* nFlags bitmask can contain bits:
		*  LOOKUPMASK_FINDALL  - Find all matches, putting results in a temporary cursor
		*  LOOKUPMASK_RANGE - Match a range of values
		*--
		PRIVATE plAbort
		LOCAL lFindAll
		LOCAL nTag, nWeight, nBestWeight, nBestRecord, nWildChar
		LOCAL cNormalKeyExpression, cNormalMatchValue
		LOCAL cFldName, cLeftMatch, cRightMatch, cLeftFullMatch, cDisplay, cFilter
		
		  * Close old results cursor if it is still left around.
		  IF USED('cmSearchResultsCursor')
		    USE IN cmSearchResultsCursor
		  ENDIF
		
		  * Default to current workarea if none specified.
		  IF EMPTY(m.cWorkArea)
		    m.cWorkArea = ALIAS()
		  ENDIF
		  IF PCOUNT() < 6
		    m.oProgress = .NULL.
		  ENDIF
		
		  * Get flag settings for optional behaviors
		  m.lFindAll = BITTEST(m.nFlags, LOOKUPFLAG_FINDALL)
		
		  * Open the source cursor in a private workarea so we dont affect any buffered changes in original.
		  SELECT 0
		  USE (DBF(m.cWorkarea)) AGAIN SHARED ALIAS cmSearchCursor
		  m.cFldName = TagField(m.cTagname)
		  IF NOT EMPTY(FILTER(m.cWorkarea))
		    m.cFilter = FILTER(m.cWorkarea)
		    SET FILTER TO &cFilter
		  ENDIF
		  SELECT (m.cWorkarea)
		  m.cFilter = SET('KEY', 1)
		  SELECT cmSearchCursor
		  IF NOT EMPTY(m.cFilter)
		    SET ORDER TO (ORDER(m.cWorkarea))
		    SET KEY TO m.cFilter
		    GO TOP
		  ENDIF
		
		  * Apply index normalization to match string.
		  m.cNormalKeyExpression = NORMALIZE(KEY(TAGNO(m.cTagName)))
		  IF '(' $ m.cNormalKeyExpression
		    m.cNormalMatchValue = TRIM(EVALUATE(STRTRAN(m.cNormalKeyExpression, '(' + UPPER(m.cFldName), '(m.cFullMatchValue')))
		  ELSE
		    m.cNormalMatchValue = m.cFullMatchValue
		  ENDIF
		
		  * Strip out wildcards, leaving only match characters to the left of the first wildcard
		  m.nWildChar = IIF(THIS.lAllowWildcard, AT('*', CHRTRAN(m.cNormalMatchValue, '?', '*')), 0)
		
		  * Pad string key to the full length of the table field.
		  m.cLeftMatch = PADR(m.cNormalMatchValue, LEN(EVALUATE(m.cFldName)))
		
		  * Allow search to be interrupted. Need to turn on autoyield as well.
		  m.plAbort = .F.
		  ON ESCAPE m.plAbort = .T.
		  STORE 0 TO THIS.nHitCount, m.nBestWeight, m.nBestRecord
		
		  SCAN FOR &cNormalKeyExpression = m.cLeftMatch ;
		       WHILE NOT m.plAbort AND THIS.nHitCount < THIS.nMaxHits    && Limit result set scan to a practical number.
		
		    THIS.nHitCount = THIS.nHitCount + 1       && Count number of hits.
		    IF m.nWeight > m.nBestWeight
		      m.nBestWeight = m.nWeight
		      m.nBestRecord = RECNO()
		    ENDIF
		    IF m.lFindAll
		      THIS.AddToCursor(m.nWeight, EVALUATE(m.cDisplayExp), RECNO())
		      * Insert New record into result cursor
		      IF NOT USED('cmSearchResultsCursor')
		        LOCAL nSelect
		        m.nSelect = SELECT()
		        CREATE CURSOR cmSearchResultsCursor (display C(MAX(50, LEN(m.cDisplay))), recno I, weight I)
		        SELECT (m.nSelect)
		      ENDIF
		      INSERT INTO cmSearchResultsCursor ;
		           VALUES(m.cDisplay, m.nRecno, m.nWeight)
		    ELSE
		      EXIT
		    ENDIF
		
		    * Update caller progress indicator, if any.
		    IF NOT ISNULL(m.oProgress) AND THIS.nHitCount > 0 AND THIS.nHitCount % THIS.nInterval = 0
		      m.oProgress.UpdateProgress(THIS.nHitCount)
		    ENDIF
		  ENDSCAN
		
		  IF THIS.nHitCount = 0
		    IF NOT ISNULL(THISFORM.oMessage)
		      THISFORM.oMessage.SetLastMessage('%MsgNotFound', m.cFullMatchValue)
		    ENDIF
		  ELSE
		    IF m.lFindAll AND NOT ISNULL(m.oProgress)
		      m.oProgress.UpdateProgress(THIS.nHitCount)
		    ENDIF
		    IF m.lFindAll AND THIS.nHitCount > 1
		      SELECT cmSearchResultsCursor
		      INDEX ON display TAG sortorder
		    ENDIF
		  ENDIF
		
		  USE IN cmSearchCursor
		  RETURN m.nBestRecord
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmlookupabstract AS custom 		&& Abstract lookup engine class. Subclass this to create type-specific search engines.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addhit		&& Add current source record to the output hit results cursor.
		*m: closesource		&& Close our private workarea, and restore environment.
		*m: lookup		&& Find a record using the character based key tag specified.
		*m: opensource		&& Re-open the source cursor in a private workarea so we don't affect record buffering.
		*m: supportedoptions		&& Return a bitmask of lookup options supported by this class for the specified datatype.
		*p: cversion
		*p: lallowwildcard		&& Set to .F. to treat wildcard characters in match values as regular characters.
		*p: lautoyield
		*p: lescape
		*p: lexact
		*p: lfindall		&& Internal flag set true if finding all matching records.
		*p: lsortresults		&& Set .T. to sort result cursor from best to worst match
		*p: nbestrecord
		*p: nbestweight
		*p: nhitcount		&& Number of hits found by the last lookup call.
		*p: ninterval		&& Progress indicator update interval
		*p: nmaxhits		&& Maximum number of matching records to consider for result set.
	*</DefinedPropArrayMethod>

	cversion = 7.0
	lallowwildcard = .T.		&& Set to .F. to treat wildcard characters in match values as regular characters.
	lautoyield = .F.
	lescape = .F.
	lexact = .F.
	lfindall = .F.		&& Internal flag set true if finding all matching records.
	lsortresults = .T.		&& Set .T. to sort result cursor from best to worst match
	Name = "cmlookupabstract"
	nbestrecord = 0
	nbestweight = 0
	nhitcount = 0		&& Number of hits found by the last lookup call.
	ninterval = 50		&& Progress indicator update interval
	nmaxhits = 2500		&& Maximum number of matching records to consider for result set.
	
	PROCEDURE addhit		&& Add current source record to the output hit results cursor.
		LPARAMETERS nWeight, cDisplay, nRecno, oProgress, cSort
		*++
		*>>Add current source record to the output hit results cursor.
		*--
		  IF m.nWeight > THIS.nBestWeight          && Remember best record.
		    THIS.nBestWeight = m.nWeight
		    THIS.nBestRecord = m.nRecno
		  ENDIF
		
		  * Update caller progress indicator, if any.
		  THIS.nHitCount = THIS.nHitCount + 1      && Count number of hits.
		  IF NOT ISNULL(m.oProgress) AND THIS.nHitCount % THIS.nInterval = 0
		    m.oProgress.UpdateProgress(THIS.nHitCount)
		  ENDIF
		
		  IF THIS.lFindAll
		    IF PCOUNT() < 5
		      m.cSort = m.cDisplay
		    ENDIF
		    * Insert New record into result cursor
		    IF NOT USED('cmSearchResultsCursor')
		      CREATE CURSOR cmSearchResultsCursor (display C(MAX(50, LEN(m.cDisplay))), recno I, weight I, sortkey C(20))
		      SELECT cmSearchCursor
		    ENDIF
		    INSERT INTO cmSearchResultsCursor ;
		         VALUES(m.cDisplay, m.nRecno, m.nWeight, m.cSort)
		    RETURN .T.
		  ENDIF
		  RETURN .F.    && Record not added to cursor
		
	ENDPROC

	PROCEDURE closesource		&& Close our private workarea, and restore environment.
		LPARAMETERS oProgress
		*++
		*>>Close our private workarea, and restore environment.
		*--
		  * Restore original environment settings
		  IF THIS.lExact
		    SET EXACT ON
		  ENDIF
		  IF NOT THIS.lEscape
		    SET ESCAPE OFF
		  ENDIF
		  ON ESCAPE
		  _VFP.AutoYield = THIS.lAutoYield
		
		  IF THIS.nHitCount > 0
		    IF THIS.lFindAll AND NOT ISNULL(m.oProgress)
		      m.oProgress.UpdateProgress(THIS.nHitCount)
		    ENDIF
		    IF THIS.lFindAll AND THIS.nHitCount > 1
		      SELECT cmSearchResultsCursor
		      * Sort result cursor alphabetically or by weight, per preference setting.
		      IF THIS.lSortResults
		        INDEX ON STR(10000 - weight) + sortkey TAG sortorder
		      ELSE
		        INDEX ON UPPER(sortkey) TAG sortorder
		      ENDIF
		    ENDIF
		  ENDIF
		  USE IN cmSearchCursor
		
	ENDPROC

	PROCEDURE init
		  * Make sure form has a reference to the string tools object
		  IF ISNULL(THISFORM.oString)
		    THISFORM.oString = CreateGlobalObject('cmStringTools')
		  ENDIF
		
	ENDPROC

	PROCEDURE lookup		&& Find a record using the character based key tag specified.
		LPARAMETERS cFullMatchValue, cTagName, cPhoneticTag, cWorkArea, nFlags, cDisplayExp, oProgress
		*++
		*>>Find a record using the character based key tag specified.
		*--
		
	ENDPROC

	PROCEDURE opensource		&& Re-open the source cursor in a private workarea so we don't affect record buffering.
		LPARAMETERS cWorkarea
		*++
		*>>Re-open the source cursor in a private workarea so we don't affect record buffering.
		*--
		LOCAL cFilter, cGlobalFilterExpression
		  * Allow search to be interrupted. Need to turn on autoyield as well.
		  THIS.lAutoYield = _VFP.AutoYield
		  _VFP.AutoYield = .T.
		  THIS.lExact = SET('EXACT') == 'ON'
		  SET EXACT OFF
		  THIS.lEscape = SET('ESCAPE') == 'ON'
		  SET ESCAPE ON
		  ON ESCAPE m.plAbort = .T.
		
		  * Initialize result stats
		  STORE 0 TO THIS.nHitCount, THIS.nBestWeight, THIS.nBestRecord
		
		  * Close old results cursor if it is still left around.
		  IF USED('cmSearchResultsCursor')
		    USE IN cmSearchResultsCursor
		  ENDIF
		
		  * Open the source cursor in a private workarea so we dont affect any buffered changes in original.
		  SELECT 0
		  USE (DBF(m.cWorkarea)) AGAIN SHARED ALIAS cmSearchCursor
		  IF NOT EMPTY(FILTER(m.cWorkarea))
		    m.cFilter = FILTER(m.cWorkarea)
		    SET FILTER TO &cFilter
		  ENDIF
		
		  * If the cursor is filtered via SET KEY, build an optimizable FOR clause from the expression
		  SELECT (m.cWorkarea)
		  m.cFilter = SET('KEY', 1)
		  IF EMPTY(m.cFilter)
		    m.cGlobalFilterExpression = '.T.'
		  ELSE
		    m.cGlobalFilterExpression = KEY(TAGNO()) + '=' + THISFORM.oString.ValueToChar(m.cFilter, TYPE(KEY(TAGNO())) = 'C')
		  ENDIF
		
		  SELECT cmSearchCursor
		  LOCATE FOR &cGlobalFilterExpression
		
		  RETURN m.cGlobalFilterExpression
		
	ENDPROC

	PROCEDURE supportedoptions		&& Return a bitmask of lookup options supported by this class for the specified datatype.
		*++
		*>>Return a bitmask of lookup options supported by this class for the specified datatype.
		*--
		  * Refresh app registry preferences here, each time options are queried.
		  IF NOT ISNULL(THISFORM.oRegistry)
		    THIS.nMaxHits = THISFORM.oRegistry.GetKeyValue(KEYNAME_LOOKUP_MAXHITS, KEY_TYPE_NUMERIC, THIS.nMaxHits)
		    THIS.lSortResults = THISFORM.oRegistry.GetKeyValue(KEYNAME_LOOKUP_SORT, KEY_TYPE_LOGICAL, THIS.lSortResults)
		  ENDIF
		  RETURN 0
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmlookupmanager AS cuscustom OF "..\common\codemine.vcx" 		&& Manage record lookup key index tags and lookup classes
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: definetag		&& Add a new lookup tag to the list of defined tags for the currently selected workarea.
		*m: gentaglist		&& Generate a list of default lookup keys by scanning all index tags in the current workarea.
		*m: getdisplaynamefromtag		&& Return display name associated with the specified lookup tag.
		*m: getlookuptaglist		&& Return a coma separated list of all lookup keys defined.
		*m: getordertaglist		&& Return a coma separated list of all order keys defined.
		*m: gettagfromdisplayname		&& Return index tag name associated with the specified tag display name
		*m: gettagindex		&& Find the array index of the specified tag, and instantiate its lookup class if needed.
		*m: gettagoptions		&& Return option flags for the specified tag in the current workarea.
		*m: inittaglist		&& Initialize lookup tag list, and generate defaults as needed.
		*m: lookup		&& Lookup the specified value using the specified Lookup Manager tag and associated lookup class.
		*m: preparetag		&& Make sure that all specified options are supported by the target lookup engine and available indexes.
		*m: setdisplayexpression		&& Set the default display expression to use for all tags in a given workarea.
		*m: settag		&& Modify properties of a defined lookup tag in the currently selected workarea.
		*p: cdatelookupclass		&& Default class used to perform lookups on date fields
		*p: cnamelookupclass		&& Default class used to perform lookups on parsed proper names
		*p: cnumericlookupclass		&& Default class used to perform lookups on numeric fields
		*p: csoundfunction		&& Phonetic conversion function name
		*p: cstringlookupclass		&& Default class used to perform lookups on character string fields
		*p: cversion		&& Lookup manager class version
		*p: cworkarealist		&& List of workareas that have been initialized
		*p: lsorttaglist		&& Set to .T. to sort the defined tag list alphabetically.
	*</DefinedPropArrayMethod>

	cdatelookupclass = cmBinLookup		&& Default class used to perform lookups on date fields
	cnamelookupclass = cmNameLookup		&& Default class used to perform lookups on parsed proper names
	cnumericlookupclass = cmBinLookup		&& Default class used to perform lookups on numeric fields
	csoundfunction = Soundslike		&& Phonetic conversion function name
	cstringlookupclass = cmStringLookup		&& Default class used to perform lookups on character string fields
	cversion = 7.0		&& Lookup manager class version
	cworkarealist = 		&& List of workareas that have been initialized
	lsorttaglist = .T.		&& Set to .T. to sort the defined tag list alphabetically.
	Name = "cmlookupmanager"
	
	PROCEDURE definetag		&& Add a new lookup tag to the list of defined tags for the currently selected workarea.
		LPARAMETERS cTagname, cDisplayExpression, cLookupClass, nFlags, cDisplayName
		*++
		*>>Add a new lookup tag to the list of defined tags for the currently selected workarea.
		* Only nFlag bits LOOKUPFLAG_ORDER and/or LOOKUPFLAG_LOOKUP may be set here.
		*--
		LOCAL ix
		
		  * Use default display expression for workarea if none specified.
		  IF EMPTY(m.cDisplayExpression)
		    FOR ix = 1 TO ALEN(THIS.aDisplayExpressions, 1)
		      IF THIS.aDisplayExpressions[m.ix, 1] == ALIAS()
		        m.cDisplayExpression = THIS.aDisplayExpressions[m.ix, 2]
		        EXIT
		      ENDIF
		    ENDFOR
		  ENDIF
		
		  m.cTagname = UPPER(m.cTagname)
		  FOR ix = 1 TO THIS.nTagCount
		    IF THIS.aKeyList[m.ix, KEYLIST_TAG_NAME] == m.cTagName ;
		    AND THIS.aKeyList[m.ix, KEYLIST_WORKAREA] == ALIAS()
		      EXIT
		    ENDIF      
		  ENDFOR
		  IF m.ix > THIS.nTagCount
		    THIS.nTagCount = m.ix
		    DIMENSION THIS.aKeyList[m.ix, KEYLIST_NCOLS]
		  ENDIF
		
		  THIS.aKeyList[THIS.nTagCount, KEYLIST_WORKAREA] = UPPER(ALIAS())
		  THIS.aKeyList[THIS.nTagCount, KEYLIST_TAG_NAME] = m.cTagname
		
		  THIS.aKeyList[THIS.nTagCount, KEYLIST_DISPLAY_NAME] = m.cDisplayName
		  THIS.aKeyList[THIS.nTagCount, KEYLIST_DISPLAY_EXPRESSION] = m.cDisplayExpression
		  THIS.aKeyList[THIS.nTagCount, KEYLIST_LOOKUP_CLASS] = IIF(EMPTY(m.cLookupClass), '', LOWER(m.cLookupClass))
		
		  * Default to all optional behaviors. Unsupported ones will be cleared later.
		  IF EMPTY(m.nFlags)
		    m.nFlags = 0
		  ENDIF
		  THIS.aKeyList[THIS.nTagCount, KEYLIST_FLAGS] = ;
		       BITOR(IIF(BITAND(m.nFlags, LOOKUPMASK_TAGTYPE) = 0, LOOKUPMASK_ORDER + LOOKUPMASK_LOOKUP, m.nFlags), BITNOT(LOOKUPMASK_TAGTYPE))
		
	ENDPROC

	PROCEDURE gentaglist		&& Generate a list of default lookup keys by scanning all index tags in the current workarea.
		*++
		*>>Generate a list of default lookup keys by scanning all index tags in the current workarea.
		* Developer subclasses can call THIS.DefineTag() to define custom tag sets.
		* Or call THIS.SetTag() after DODEFAULT() to modify attributes of default tag list.
		*--
		LOCAL ix, cExpression, nTagType, lChild
		
		  m.lChild = NOT EMPTY(THISFORM.cmDataManager.GetParent(ALIAS()))
		  FOR ix = 1 TO TAGCOUNT()
		    m.cExpression = NORMALIZE(KEY(m.ix))
		
		    * Child workareas in a navigational relation cannot change order.
		    m.nTagType = IIF(m.lChild, 0, LOOKUPMASK_ORDER)
		
		    * Complex expressions default to Order tags only, as they are probably not meant as lookup expressions.
		    IF NOT '+' $ m.cExpression OR NOT '(' $ m.cExpression ;
		    OR NOT (AT('+', m.cExpression) < AT('(', m.cExpression) OR RAT('+', m.cExpression) > RAT(')', m.cExpression))
		      m.nTagType = m.nTagType + LOOKUPMASK_LOOKUP
		    ENDIF
		
		    IF NOT EMPTY(TagField(TAG(m.ix))) ;
		    AND NOT THIS.cSoundFunction + '(' $ m.cExpression AND NOT 'SOUNDEX(' $ m.cExpression
		      THIS.DefineTag(TAG(m.ix), , , m.nTagType)
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE getdisplaynamefromtag		&& Return display name associated with the specified lookup tag.
		LPARAMETERS cTag, cWorkarea
		*++
		*>>Return display name associated with the specified lookup tag.
		*--
		LOCAL ix
		  m.cWorkarea = UPPER(m.cWorkarea)
		  FOR ix = 1 TO THIS.nTagCount
		    IF UPPER(THIS.aKeyList[m.ix, KEYLIST_TAG_NAME]) == UPPER(m.cTag) AND THIS.aKeyList[m.ix, KEYLIST_WORKAREA] == m.cWorkarea
		      RETURN THIS.aKeyList[m.ix, KEYLIST_DISPLAY_NAME]
		    ENDIF
		  ENDFOR
		  RETURN m.cTag
		
	ENDPROC

	PROCEDURE getlookuptaglist		&& Return a coma separated list of all lookup keys defined.
		LPARAMETERS cWorkarea
		*++
		*>>Return a coma separated list of all lookup keys defined.
		* Lookup list may be a subset of the full tag list. Some tags may be defined only for special
		* filters or sort orders.
		*--
		LOCAL ix, cList
		  m.cList = ''
		  m.cWorkarea = UPPER(m.cWorkarea)
		  THIS.InitTagList(m.cWorkarea)    && Build the lookup tag list if it is not already built.
		  FOR ix = 1 TO THIS.nTagCount
		    IF BITTEST(THIS.aKeyList[m.ix, KEYLIST_FLAGS], LOOKUPFLAG_LOOKUP) AND THIS.aKeyList[m.ix, KEYLIST_WORKAREA] == m.cWorkarea
		      m.cList = m.cList + IIF(EMPTY(m.cList), '', ',') + THIS.aKeyList[m.ix, KEYLIST_DISPLAY_NAME]
		    ENDIF
		  ENDFOR
		  RETURN m.cList
		
	ENDPROC

	PROCEDURE getordertaglist		&& Return a coma separated list of all order keys defined.
		LPARAMETERS cWorkarea
		*++
		*>>Return a coma separated list of all order keys defined.
		*--
		LOCAL ix, cList
		  m.cList = ''
		  m.cWorkarea = UPPER(m.cWorkarea)
		  THIS.InitTagList(m.cWorkarea)    && Build the lookup tag list if it is not already built.
		  FOR ix = 1 TO THIS.nTagCount
		    IF BITTEST(THIS.aKeyList[m.ix, KEYLIST_FLAGS], LOOKUPFLAG_ORDER) AND THIS.aKeyList[m.ix, KEYLIST_WORKAREA] == m.cWorkarea
		      m.cList = m.cList + IIF(EMPTY(m.cList), '', ',') + THIS.aKeyList[m.ix, KEYLIST_DISPLAY_NAME]
		    ENDIF
		  ENDFOR
		  RETURN m.cList
		
	ENDPROC

	PROCEDURE gettagfromdisplayname		&& Return index tag name associated with the specified tag display name
		LPARAMETERS cDisplayname, cWorkarea
		*++
		*>>Return index tag name associated with the specified tag display name
		*--
		LOCAL ix
		  m.cWorkarea = UPPER(m.cWorkarea)
		  FOR ix = 1 TO THIS.nTagCount
		    IF UPPER(THIS.aKeyList[m.ix, KEYLIST_DISPLAY_NAME]) == UPPER(m.cDisplayName) AND THIS.aKeyList[m.ix, KEYLIST_WORKAREA] == m.cWorkarea
		      RETURN THIS.aKeyList[m.ix, KEYLIST_TAG_NAME]
		    ENDIF
		  ENDFOR
		  RETURN m.cDisplayname
		
	ENDPROC

	PROCEDURE gettagindex		&& Find the array index of the specified tag, and instantiate its lookup class if needed.
		LPARAMETERS cTagName, cWorkarea
		*++
		*>>Find the array index of the specified tag, and instantiate its lookup class if needed.
		*--
		LOCAL ix
		
		  m.cTagName = UPPER(m.cTagName)
		  m.cWorkarea = UPPER(m.cWorkarea)
		  THIS.InitTagList(m.cWorkarea)     && Build the lookup key list if it is not already built.
		
		  FOR ix = 1 TO THIS.nTagCount
		    IF THIS.aKeyList[m.ix, KEYLIST_TAG_NAME] == m.cTagName AND THIS.aKeyList[m.ix, KEYLIST_WORKAREA] == m.cWorkarea
		      RETURN m.ix
		    ENDIF      
		  ENDFOR
		  ERROR 'Undefined tag: ' + m.cTagName
		  RETURN 0  && tag not found
		
	ENDPROC

	PROCEDURE gettagoptions		&& Return option flags for the specified tag in the current workarea.
		LPARAMETERS cTagName, cWorkarea
		*++
		*>>Return option flags for the specified tag in the current workarea.
		*
		* This allows interface elements, such as a Find dialog, to correctly enable 
		* only those options that apply to the selected lookup tag.
		*--
		LOCAL nTagix
		  m.nTagix = THIS.GetTagIndex(m.cTagName, m.cWorkarea)
		
		  * Make sure that all specified options are supported by the target lookup engine.
		  THIS.PrepareTag(m.nTagix)
		
		  RETURN THIS.aKeyList[m.nTagix, KEYLIST_FLAGS]
		
	ENDPROC

	PROCEDURE init
		  DODEFAULT()
		
		  * Add internal runtime properties
		  THIS.AddProperty('nTagCount', 0)                 && Number of lookup keys for all workareas
		  THIS.AddProperty('aKeyList[1]')                  && Array of defined lookup tags
		  THIS.AddProperty('aDisplayExpressions[1,2]', '') && Default display expressions
		
	ENDPROC

	PROCEDURE inittaglist		&& Initialize lookup tag list, and generate defaults as needed.
		LPARAMETERS cWorkarea
		*++
		*>>Initialize lookup tag list, and generate defaults as needed.
		*--
		LOCAL ix, nFlags, cField, cTagName, nSelect, oRegistry, oName, aNames[1]
		
		  * We only initialize once for each workarea.
		  IF NOT USED(m.cWorkarea) OR PROPER(m.cWorkarea) + ',' $ THIS.cWorkareaList
		    RETURN .T.
		  ENDIF
		  THIS.cWorkareaList = THIS.cWorkareaList + PROPER(m.cWorkarea) + ','
		  m.cWorkarea = UPPER(m.cWorkarea)
		
		  * Get the default phonetic normalization function from the registry.
		  IF ISNULL(THISFORM.oRegistry)
		    THIS.cSoundFunction = UPPER(THIS.cSoundFunction)
		  ELSE
		    THIS.cSoundFunction = UPPER(THISFORM.oRegistry.GetKeyValue(KEYNAME_LOOKUP_PHONETIC, KEY_TYPE_CHAR, THIS.cSoundFunction))
		  ENDIF
		
		  m.nSelect = SELECT()
		  SELECT (m.cWorkarea)
		
		  * Generate list of available lookup/order tags for this workarea.
		  THIS.GenTagList()
		  DIMENSION aNames[ALEN(THIS.aKeyList, 1)]
		
		  * Loop through every tag in this workarea, and initialize properties.
		  FOR ix = 1 TO THIS.nTagCount
		    IF NOT THIS.aKeyList[m.ix, KEYLIST_WORKAREA] == m.cWorkarea
		      LOOP
		    ENDIF
		
		    * See if there is a corresponding CDX index tag for the named lookup tag.
		    m.cTagName = THIS.aKeyList[m.ix, KEYLIST_TAG_NAME]
		    IF TAGNO(m.cTagName) = 0
		      m.cField = m.cTagName
		      m.cTagName = ''
		      THIS.aKeyList[m.ix, KEYLIST_FLAGS] = BITCLEAR(THIS.aKeyList[m.ix, KEYLIST_FLAGS], LOOKUPFLAG_ORDER)
		    ELSE
		      m.cField = TagField(m.cTagName)
		    ENDIF
		    IF EMPTY(m.cField)
		      THISFORM.DisplayMessage('cmLookupManager - Unsupported Index Tag: ' + m.cTagname)
		      THIS.aKeyList[m.ix, KEYLIST_FLAGS] = 0
		      LOOP
		    ENDIF
		
		    * Generate default value for displayname, from help key, DBC caption, tag name, or field name.
		    IF EMPTY(THIS.aKeyList[m.ix, KEYLIST_DISPLAY_NAME])
		      LOCAL ix, cName
		
		      * If index is a compound expression, isolate the first field of the expression and use that.
		      m.cName = THISFORM.NiceFieldName(GetToken(m.cField, '+'))
		
		      * If this field name is already used, use the tag name instead.
		      IF ASCAN(aNames, PROPER(m.cName) + '.') > 0
		        m.cName = PROPER(m.cTagname)
		      ENDIF
		      m.aNames[m.ix] = PROPER(m.cName) + '.'
		      THIS.aKeyList[m.ix, KEYLIST_DISPLAY_NAME] = m.cName
		    ENDIF
		  ENDFOR
		
		  * Sort tag array by display name before returning
		  IF THIS.nTagCount > 0 AND THIS.lSortTagList
		    =ASORT(THIS.aKeyList, KEYLIST_DISPLAY_NAME)
		  ENDIF
		  SELECT (m.nSelect)
		
	ENDPROC

	PROCEDURE lookup		&& Lookup the specified value using the specified Lookup Manager tag and associated lookup class.
		LPARAMETERS cValue, cTagName, cWorkarea, nFlags, oProgress
		*++
		*>>Lookup the specified value using the specified Lookup Manager tag and associated lookup class.
		*--
		LOCAL nTagix, oLookupEngine
		  IF EMPTY(m.cWorkarea)      && Workarea defaults to current
		    m.cWorkarea = ALIAS()
		  ENDIF
		  IF EMPTY(m.nFlags)         && Deafult to no option bits selected (ensure it is numeric though)
		    m.nFlags = 0
		  ENDIF
		  IF PCOUNT() < 5            && Progress indicator is optional
		    m.oProgress = .NULL.
		  ENDIF
		  m.nTagix = THIS.GetTagIndex(m.cTagName, m.cWorkarea)
		
		  * Make sure that all specified options are supported by the target lookup engine.
		  THIS.PrepareTag(m.nTagix)
		  m.nFlags = BITAND(m.nFlags, THIS.aKeyList[m.nTagix, KEYLIST_FLAGS])
		
		  * Call the lookup method in the Lookup class associated with the specified tag.
		  m.oLookupEngine = EVALUATE('THIS.' + THIS.aKeyList[m.nTagIx, KEYLIST_LOOKUP_CLASS])
		  RETURN m.oLookupEngine.Lookup(m.cValue, m.cTagName, ;
		                                THIS.aKeyList[m.nTagIx, KEYLIST_PHONETIC_TAG], ;
		                                m.cWorkarea, m.nFlags, ;
		                                THIS.aKeyList[m.nTagix, KEYLIST_DISPLAY_EXPRESSION], m.oProgress)
		
	ENDPROC

	PROCEDURE preparetag		&& Make sure that all specified options are supported by the target lookup engine and available indexes.
		LPARAMETERS nTagix
		*++
		*>>Make sure that all specified options are supported by the target lookup engine and available indexes.
		*--
		LOCAL oLookupEngine, cLookupClass, nFlags, nSelect
		
		  m.nFlags = THIS.aKeyList[m.nTagix, KEYLIST_FLAGS]
		  IF BITTEST(m.nFlags, LOOKUPFLAG_CHECKFLAGS)
		    LOCAL ix, oName, cType, cField, cTagname, cExpression
		
		    m.nSelect = SELECT()
		    SELECT (THIS.aKeyList[m.nTagix, KEYLIST_WORKAREA])
		
		    * Determine if there is a physical index for the lookup tag, and extract the field name.
		    m.cTagName = THIS.aKeyList[m.nTagix, KEYLIST_TAG_NAME]
		    IF TAGNO(m.cTagName) = 0
		      m.cField = m.cTagName
		      m.cTagName = ''
		    ELSE
		      m.cField = TagField(m.cTagName)
		    ENDIF
		
		    * Determine lookup engine class to use, if none was specified.
		    m.cLookupClass = THIS.aKeyList[m.nTagix, KEYLIST_LOOKUP_CLASS]
		    IF EMPTY(m.cLookupClass)
		      m.cType = TYPE(m.cField)
		      DO CASE
		        CASE m.cType $ 'CM'
		          * If the name parser object exists, use it to detect registered proper name key tags.
		          m.oName = FindGlobalObject('cmNameparser')
		          IF NOT EMPTY(m.cTagName) AND NOT ISNULL(m.oName) AND m.oName.GetNameFields(m.cField)
		            m.cLookupClass = THIS.cNameLookupClass
		          ELSE
		            m.cLookupClass = THIS.cStringLookupClass
		          ENDIF
		        CASE m.cType $ 'NYI'
		          m.cLookupClass = THIS.cNumericLookupClass
		        CASE m.cType $ 'D'
		          m.cLookupClass = THIS.cDateLookupClass
		        OTHERWISE
		          ERROR 'Unsupported cmLookupManager Datatype for ' + m.cField
		      ENDCASE
		      THIS.aKeyList[m.nTagix, KEYLIST_LOOKUP_CLASS] = m.cLookupClass
		    ENDIF
		
		    * Create an instance of the lookup engine class if needed.
		    IF NOT PEMSTATUS(THIS, m.cLookupClass, 5)
		      THIS.AddNewObject(m.cLookupClass, m.cLookupClass)
		    ENDIF
		
		    * Mask off flag bits with those supported by the specific lookup engine class.
		    m.oLookupEngine = EVALUATE('THIS.' + m.cLookupClass)
		    m.nFlags = BITAND(m.nFlags, LOOKUPMASK_TAGTYPE) + m.oLookupEngine.SupportedOptions()
		
		    * If phonetic matching is supported, make sure there is a phonetic index to use, or disable the option.
		    IF BITTEST(m.nFlags, LOOKUPFLAG_PHONETIC)
		      m.nFlags = BITCLEAR(m.nFlags, LOOKUPFLAG_PHONETIC)
		      IF NOT EMPTY(m.cTagname)   && CDX index required to consider phonetic matching
		        m.cExpression = NORMALIZE(THIS.cSoundFunction + '(' + m.cField + ')')
		        FOR ix = 1 TO TAGCOUNT()
		          IF LEFT(NORMALIZE(KEY(m.ix)), LEN(m.cExpression)) == m.cExpression
		            m.nFlags = BITSET(m.nFlags, LOOKUPFLAG_PHONETIC)
		            THIS.aKeyList[m.nTagIx, KEYLIST_PHONETIC_TAG] = TAG(m.ix)
		            EXIT
		          ENDIF
		        ENDFOR
		      ENDIF
		    ENDIF
		    THIS.aKeyList[m.nTagix, KEYLIST_FLAGS] = m.nFlags
		  SELECT (m.nSelect)
		  ENDIF
		
	ENDPROC

	PROCEDURE setdisplayexpression		&& Set the default display expression to use for all tags in a given workarea.
		LPARAMETERS cExpression, cWorkarea
		*++
		*>>Set the default display expression to use for all tags in a given workarea.
		*--
		LOCAL ix
		  m.cWorkarea = IIF(EMPTY(m.cWorkarea), ALIAS(), UPPER(m.cWorkarea))
		  FOR ix = 1 TO ALEN(THIS.aDisplayExpressions, 1)
		    IF THIS.aDisplayExpressions[m.ix, 1] == m.cWorkarea
		      EXIT
		    ENDIF
		  ENDFOR
		  IF m.ix > ALEN(THIS.aDisplayExpressions, 1)
		    DIMENSION THIS.aDisplayExpressions[m.ix, 2]
		    THIS.aDisplayExpressions[m.ix, 1] = m.cWorkarea
		  ENDIF
		  THIS.aDisplayExpressions[m.ix, 2] = m.cExpression
		
	ENDPROC

	PROCEDURE settag		&& Modify properties of a defined lookup tag in the currently selected workarea.
		LPARAMETERS cTagname, cItem, uValue
		*++
		*>>Modify properties of a defined lookup tag in the currently selected workarea.
		* Provides a way to change key array elements without messing directly with the array structure.
		*--
		LOCAL ix
		  m.cTagName = UPPER(m.cTagName)
		  m.cItem = PROPER(m.cItem)
		  FOR ix = 1 TO THIS.nTagCount
		    IF THIS.aKeyList[m.ix, KEYLIST_TAG_NAME] == m.cTagName AND THIS.aKeyList[m.ix, KEYLIST_WORKAREA] == ALIAS()
		      DO CASE
		        CASE 'name' $ m.cItem
		          THIS.aKeyList[m.ix, KEYLIST_DISPLAY_NAME] = m.uValue
		        CASE 'class' $ m.cItem
		          THIS.aKeyList[m.ix, KEYLIST_LOOKUP_CLASS] = m.uValue
		        CASE 'exp' $ m.cItem
		          THIS.aKeyList[m.ix, KEYLIST_DISPLAY_EXPRESSION] = m.uValue
		        CASE 'Enable' $ m.cItem
		          THIS.aKeyList[m.ix, KEYLIST_FLAGS] = BITOR(THIS.aKeyList[m.ix, KEYLIST_FLAGS], m.uValue)
		        CASE 'Disable' $ m.cItem
		          THIS.aKeyList[m.ix, KEYLIST_FLAGS] = BITAND(THIS.aKeyList[m.ix, KEYLIST_FLAGS], BITNOT(m.uValue))
		        OTHERWISE
		          ERROR 'Invalid Item code: ' + m.cItem
		      ENDCASE
		      RETURN .T.
		    ENDIF
		  ENDFOR
		  ERROR 'Tag not found: ' + m.cTagname
		  RETURN .F.   && Tag not found
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmnamelookup AS cmlookupabstract OF "cmlookup.vcx" 		&& Codemine proper name fuzzy search and lookup class.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: lookup		&& Look for the specified name in the specified workarea
		*m: supportedoptions		&& Return a bitmask of lookup options supported by this class for the specified datatype.
		*p: oname		&& Runtime reference to global name parser
	*</DefinedPropArrayMethod>

	Name = "cmnamelookup"
	oname = .NULL.		&& Runtime reference to global name parser
	
	PROCEDURE destroy
		  THIS.oName = .NULL.
		
	ENDPROC

	PROCEDURE init
		  DODEFAULT()
		  THIS.oName = CreateGlobalObject('cmNameParser')
		
	ENDPROC

	PROCEDURE lookup		&& Look for the specified name in the specified workarea
		LPARAMETERS cFullMatchValue, cTagName, cPhoneticTag, cWorkArea, nFlags, cDisplayExp, oProgress
		*++
		*>>Look for the specified name in the specified workarea
		*
		* Name lookup rules:
		*  prefix & suffix are not normalized for comparisons, except for conversion to uppercase
		*  no wildcards allowed for prefix or suffix - ommit to match on all
		*  first & middle names get same normalization as last, derived from index expression.
		*  Key normalization may be: UPPER(), NormalizeString(), SoundsLike(), but cannot be SOUNDEX()!!!
		*  Note that the amount of normalization modification can affect behavior of wildcards.
		*  If phonetic index exists, and phonetic matching enabled, use phonetic index, else use textual index
		*
		* nFlags can contain a combination of:
		*  LOOKUPMASK_FINDALL  - Return all matches
		*  LOOKUPMASK_PHONETIC - Enables phonetic matching
		*  LOOKUPMASK_PARTIAL  - to allow partial matches
		*  LOOKUPMASK_NICKNAME - to match first name against common nicknames
		*--
		PRIVATE plAbort
		LOCAL ix, nWeight, nWildLast, cGlobalFilterExpression
		LOCAL lPartialMatch, lMatchNickNames, lPhonetic
		LOCAL cFldLast, cFldFirst, cFldMiddle, cFldPrefix, cFldSuffix
		LOCAL cGender, cKeyLast, cKeyFirst, cMatchKey, cSort
		LOCAL cMatchPrefix, cMatchFirst, cMatchMiddle, cMatchLast, cMatchSuffix, cMatchGender
		LOCAL cPhoneticMatchFirst, cPhoneticMatchMiddle, cPhoneticMatchLast
		LOCAL cNormalMatchFirst, cNormalMatchMiddle, cNormalMatchLast
		LOCAL cPhoneticFirstExpression, cPhoneticMiddleExpression, cPhoneticLastExpression
		LOCAL cNormalFirstExpression, cNormalMiddleExpression, cNormalLastExpression
		
		  * Parse the comparison name value. If an error occurs, the global message object has details of the error.
		  IF NOT THIS.oName.ParseName(m.cFullMatchValue, @m.cMatchPrefix, @m.cMatchFirst, @m.cMatchMiddle, @m.cMatchLast, @m.cMatchSuffix)
		    RETURN 0
		  ENDIF
		
		  * Progress indicator is optional
		  IF PCOUNT() < 7
		    m.oProgress = .NULL.
		  ENDIF
		  m.cGlobalFilterExpression = THIS.OpenSource(m.cWorkarea)
		
		  * Get flag settings for optional behaviors
		  THIS.lFindAll = BITTEST(m.nFlags, LOOKUPFLAG_FINDALL)
		  m.lPartialMatch = BITTEST(m.nFlags, LOOKUPFLAG_PARTIAL)
		  m.lPhonetic = BITTEST(m.nFlags, LOOKUPFLAG_PHONETIC)
		  m.lMatchNickNames = BITTEST(m.nFlags, LOOKUPFLAG_NICKNAME)
		
		  * Get the 5 cursor field names from the name parsing object, based on the lastname field.
		  m.cFldLast = TagField(m.cTagname)
		  IF NOT THIS.oName.GetNameFields(m.cFldLast, @m.cFldPrefix, @m.cFldFirst, @m.cFldMiddle, @m.cFldSuffix)
		    ERROR m.cFldLast + ' is not a registered last name field'
		  ENDIF
		
		  * Generate default display expression if none specified.
		  IF EMPTY(m.cDisplayExp)
		    m.cDisplayExp = 'THIS.oName.FormatName(' ;
		             + m.cFldPrefix + ',' + m.cFldFirst + ',' + m.cFldMiddle + ',' + m.cFldLast + ',' + m.cFldSuffix + ')'
		  ENDIF
		
		  * First and middle names can match on a single initial. Strip any periods.
		  m.cMatchGender = THIS.oName.GetGender(m.cMatchPrefix)
		  m.cMatchFirst = TRIM(CHRTRAN(m.cMatchFirst, '.', ''))
		  m.cMatchMiddle = TRIM(CHRTRAN(m.cMatchMiddle, '.', ''))
		  m.cMatchPrefix = UPPER(m.cMatchPrefix)
		  m.cMatchSuffix = UPPER(m.cMatchSuffix)
		
		  * Apply index normalization to first, last, and middle name match values.
		  m.cNormalLastExpression = NORMALIZE(KEY(TAGNO(m.cTagName)))
		  IF '+' $ m.cNormalLastExpression    && Remove firstname portion of index if present
		    m.cNormalLastExpression = LEFT(m.cNormalLastExpression, AT('+', m.cNormalLastExpression) - 1)
		  ENDIF
		  m.cNormalFirstExpression = STRTRAN(m.cNormalLastExpression, '(' + UPPER(m.cFldLast), '(' + UPPER(m.cFldFirst))
		  m.cNormalMiddleExpression = STRTRAN(m.cNormalLastExpression, '(' + UPPER(m.cFldLast), '(' + UPPER(m.cFldMiddle))
		  m.cNormalMatchFirst = TRIM(EVALUATE(STRTRAN(m.cNormalLastExpression, '(' + UPPER(m.cFldLast), '(m.cMatchFirst')))
		  m.cNormalMatchMiddle = TRIM(EVALUATE(STRTRAN(m.cNormalLastExpression, '(' + UPPER(m.cFldLast), '(m.cMatchMiddle')))
		  m.cNormalMatchLast = TRIM(EVALUATE(STRTRAN(m.cNormalLastExpression, '(' + UPPER(m.cFldLast), '(m.cMatchLast')))
		  m.cKeyLast = cNormalMatchLast
		  m.cKeyFirst = cNormalMatchFirst
		
		  * Search for a phonetic index for this field, in addition to textual normalized one.
		  * If there is one, and phonetic lookup is enabled, use the phonetic index instead.
		  IF NOT EMPTY(m.cPhoneticTag) AND m.lPhonetic  && If phonetic search is enabled
		    m.cPhoneticLastExpression = NORMALIZE(KEY(TAGNO(m.cPhoneticTag)))
		
		    * Apply index normalization to first, last and middle name match values.
		    IF '+' $ m.cPhoneticLastExpression       && Remove firstname portion of index if present
		      m.cPhoneticLastExpression = LEFT(m.cPhoneticLastExpression, AT('+', m.cPhoneticLastExpression) - 1)
		    ENDIF
		    m.cPhoneticFirstExpression = STRTRAN(m.cPhoneticLastExpression, '(' + UPPER(m.cFldLast), '(' + UPPER(m.cFldFirst))
		    m.cPhoneticMiddleExpression = STRTRAN(m.cPhoneticLastExpression, '(' + UPPER(m.cFldLast), '(' + UPPER(m.cFldMiddle))
		    m.cPhoneticMatchFirst = TRIM(EVALUATE(STRTRAN(m.cPhoneticLastExpression, '(' + UPPER(m.cFldLast), '(LOWER(m.cMatchFirst)')))
		    m.cPhoneticMatchMiddle = TRIM(EVALUATE(STRTRAN(m.cPhoneticLastExpression, '(' + UPPER(m.cFldLast), '(LOWER(m.cMatchMiddle)')))
		    m.cPhoneticMatchLast = TRIM(EVALUATE(STRTRAN(m.cPhoneticLastExpression, '(' + UPPER(m.cFldLast), '(LOWER(m.cMatchLast)')))
		    m.cTagName = m.cPhoneticTag     && Use this tag as primary key for lookup
		    m.cKeyLast = m.cPhoneticMatchLast
		    m.cKeyFirst = m.cPhoneticMatchFirst
		  ENDIF
		
		  * Build the index key value to use for the SET KEY command to filter records for primary scan loop
		  * We use SET KEY and SCAN...ENDSCAN because Rushmore doesnt like UDFs in index expressions.
		  m.nWildLast = AT('*', CHRTRAN(m.cKeyLast, '?', '*'))
		  m.lPartialMatch = m.lPartialMatch OR m.nWildLast > 0
		  IF m.lPartialMatch
		    IF m.nWildLast = 0
		      m.cMatchKey = m.cKeyLast
		    ELSE
		      m.cMatchKey = LEFT(m.cKeyLast, m.nWildLast - 1)
		    ENDIF
		  ELSE
		    * Pad last name key to the full length of the last name field.
		    m.cMatchKey = PADR(m.cKeyLast, LEN(EVALUATE(m.cFldLast)))
		
		    * Add first name to index match expression if possible.
		    IF NOT m.lMatchNickNames
		      m.cMatchKey = m.cMatchKey + TRIM(CHRTRAN(m.cKeyFirst, '?', '*'))
		      m.ix = AT('*', m.cMatchKey)
		      IF m.ix > 0
		        m.cMatchKey = LEFT(m.cMatchKey, m.ix - 1)
		      ENDIF
		    ENDIF
		  ENDIF
		
		  IF LEN(m.cMatchKey) > 0
		    SET ORDER TO (m.cTagname)
		    SET KEY TO (m.cMatchKey)
		    GO TOP
		  ELSE
		    * Physical record order is fastest if considering all records, with no filter.
		    SET ORDER TO
		  ENDIF
		
		  * Scan all matching names and apply wildcards, nicknames, and other component matches as needed
		  * to narrow results.
		  m.plAbort = .F.
		
		  SCAN ALL FOR &cGlobalFilterExpression ;
		       WHILE NOT m.plAbort AND THIS.nHitCount < THIS.nMaxHits    && Limit result set scan to a practical number.
		    * Here we evaluate the quality of the match based on how close it is to name we are matching against.
		    * We only reject a name at this point if remaining portion of wildcard match fails.
		    DO CASE
		      CASE EMPTY(EVALUATE(m.cFldLast))   && Always skip records with no last name specified
		        LOOP
		      CASE m.nWildLast > 0
		        IF LIKE(m.cNormalMatchLast, TRIM(EVALUATE(m.cNormalLastExpression)))
		          m.nWeight = 5000
		        ELSE
		          IF m.lPhonetic AND LIKE(m.cPhoneticMatchLast, TRIM(EVALUATE(m.cPhoneticLastExpression)))
		            m.nWeight = 3000
		          ELSE
		            LOOP
		          ENDIF
		        ENDIF
		      CASE UPPER(TRIM(EVALUATE(m.cFldLast))) == UPPER(TRIM(m.cMatchLast))
		        m.nWeight = 7000     && Bonus for full exact match.
		      CASE NOT m.lPhonetic OR TRIM(EVALUATE(m.cNormalLastExpression)) = m.cNormalMatchLast
		        m.nWeight = 5000     && Partial normalized match
		      CASE TRIM(EVALUATE(m.cPhoneticLastExpression)) == m.cPhoneticMatchLast
		        m.nWeight = 4000     && Full phonetic match
		      OTHERWISE
		        m.nWeight = 3000     && partial phonetic
		    ENDCASE
		
		    * Prefix must match only if it exists in both candidate record and match criteria.
		    IF NOT EMPTY(m.cMatchPrefix)
		      m.cName = UPPER(TRIM(EVALUATE(m.cFldPrefix)))
		      IF NOT EMPTY(m.cName)
		        IF m.cName == m.cMatchPrefix
		          m.nWeight = m.nWeight + 3     && Bonus for prefix match.
		        ELSE
		          * Prefixes don't match, but still allow it if the prefix gender matches or
		          * cannot be determined.  IE. 'Ms. Smith' would find 'Mrs. Smith' or even 'Dr. Smith'
		          m.cGender = THIS.oName.GetGender(m.cName)
		          IF NOT EMPTY(m.cGender) AND NOT EMPTY(m.cMatchGender)
		            IF m.cMatchGender == m.cGender
		              m.nWeight = m.nWeight + 2   && Prefix gender match bonus
		            ELSE
		              LOOP     && No match and different genders - reject it.
		            ENDIF
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		
		    * Suffix must match only if it exists in both candidate record and match criteria.
		    IF NOT EMPTY(m.cMatchSuffix)
		      m.cName = UPPER(TRIM(EVALUATE(m.cFldSuffix)))
		      IF NOT EMPTY(m.cName)
		        IF NOT m.cMatchSuffix == m.cName
		          LOOP
		        ENDIF
		        m.nWeight = m.nWeight + 3     && Bonus for suffix match.
		      ENDIF
		    ENDIF
		
		    * Resolve Wildcards and nicknames for first name. Phonetic and wildcard matches on base name
		    * If no wildcard, then add nickname compare, and optional phonetic nichname match
		    m.cName = EVALUATE(m.cFldFirst)
		    IF NOT EMPTY(m.cMatchFirst) AND NOT EMPTY(m.cName)
		      DO CASE
		        CASE '*' $ CHRTRAN(m.cMatchFirst, '?', '*')  && If wildcard
		          IF LIKE(m.cNormalMatchFirst, TRIM(EVALUATE(m.cNormalFirstExpression)))
		            m.nWeight = m.nWeight + 500
		          ELSE
		            IF m.lPhonetic AND LIKE(m.cPhoneticMatchFirst, TRIM(EVALUATE(m.cPhoneticFirstExpression)))
		              m.nWeight = m.nWeight + 300
		            ELSE
		              LOOP
		            ENDIF
		          ENDIF
		        CASE UPPER(TRIM(m.cName)) == UPPER(m.cMatchFirst)
		          m.nWeight = m.nWeight + 700     && Bonus for full exact match.
		        CASE LEN(TRIM(m.cName)) = 1 OR LEN(TRIM(m.cMatchFirst)) = 1
		          IF NOT (UPPER(LEFT(m.cName,1)) == UPPER(LEFT(m.cMatchFirst, 1)))
		            LOOP
		          ENDIF
		          m.nWeight = m.nWeight + 300     && Bonus for first initial match.
		        CASE m.lPartialMatch AND TRIM(EVALUATE(m.cNormalFirstExpression)) = m.cNormalMatchFirst
		          m.nWeight = m.nWeight + 500     && Bonus for partial normalized match.
		        CASE m.lMatchNickNames AND NOT EMPTY(m.cMatchGender) AND THIS.oName.FormalName(m.cName, m.cMatchGender) == THIS.oName.FormalName(m.cMatchFirst, m.cMatchGender)
		          m.nWeight = m.nWeight + 500     && Bonus for nickname match.
		        CASE m.lMatchNickNames AND EMPTY(m.cMatchGender) ;
		                      AND (THIS.oName.FormalName(m.cName, 'M') == THIS.oName.FormalName(m.cMatchFirst, 'M') ;
		                       OR THIS.oName.FormalName(m.cName, 'F') == THIS.oName.FormalName(m.cMatchFirst, 'F'))
		          m.nWeight = m.nWeight + 500     && Bonus for nickname match.
		        CASE m.lPhonetic AND TRIM(EVALUATE(m.cPhoneticFirstExpression)) == m.cPhoneticMatchFirst
		          m.nWeight = m.nWeight +  400     && Full phonetic match
		        CASE m.lPhonetic AND TRIM(EVALUATE(m.cPhoneticFirstExpression)) = m.cPhoneticMatchFirst
		          m.nWeight = m.nWeight +  300     && partial phonetic
		        OTHERWISE
		          LOOP     && First name didn't match, reject the hit
		      ENDCASE
		    ENDIF
		
		    * Middle name must match if it exists in both candidate record and match criteria.
		    m.cName = EVALUATE(m.cFldMiddle)
		    IF NOT EMPTY(m.cMatchMiddle) AND NOT EMPTY(m.cName)
		      DO CASE
		        CASE '*' $ CHRTRAN(m.cMatchMiddle, '?', '*')  && If wildcard
		          IF LIKE(m.cNormalMatchMiddle, TRIM(EVALUATE(m.cNormalMiddleExpression)))
		            m.nWeight = m.nWeight + 50
		          ELSE
		            IF m.lPhonetic AND LIKE(m.cPhoneticMatchMiddle, TRIM(EVALUATE(m.cPhoneticMiddleExpression)))
		              m.nWeight = m.nWeight + 30
		            ELSE
		              LOOP
		            ENDIF
		          ENDIF
		        CASE UPPER(TRIM(m.cName)) == UPPER(m.cMatchMiddle)
		          m.nWeight = m.nWeight + 70      && Bonus for full exact match.
		        CASE LEN(TRIM(m.cName)) = 1 OR LEN(TRIM(m.cMatchMiddle)) = 1
		          IF NOT (UPPER(LEFT(m.cName,1)) == UPPER(LEFT(m.cMatchMiddle, 1)))
		            LOOP
		          ENDIF
		          m.nWeight = m.nWeight + 30      && Bonus for first initial match.
		        CASE m.lPartialMatch AND TRIM(EVALUATE(m.cNormalMiddleExpression)) = m.cNormalMatchMiddle
		          m.nWeight = m.nWeight + 50      && Bonus for partial normalized match.
		        CASE m.lPhonetic AND TRIM(EVALUATE(m.cPhoneticMiddleExpression)) == m.cPhoneticMatchMiddle
		          m.nWeight = m.nWeight +  40     && Full phonetic match
		        CASE m.lPhonetic AND TRIM(EVALUATE(m.cPhoneticMiddleExpression)) = m.cPhoneticMatchMiddle
		          m.nWeight = m.nWeight +  30     && partial phonetic
		        OTHERWISE
		          LOOP     && Middle name didn't match, reject the hit
		      ENDCASE
		    ENDIF
		
		    THIS.AddHit(m.nWeight, EVALUATE(m.cDisplayExp), RECNO(), m.oProgress, EVALUATE(m.cFldLast))
		  ENDSCAN
		
		  IF THIS.nHitCount = 0 AND NOT ISNULL(THISFORM.oMessage)
		    THISFORM.oMessage.SetLastMessage('%MsgNotFound', m.cFullMatchValue)
		  ENDIF
		
		  THIS.CloseSource(m.oProgress)
		  RETURN THIS.nBestRecord
		
	ENDPROC

	PROCEDURE supportedoptions		&& Return a bitmask of lookup options supported by this class for the specified datatype.
		*++
		*>>Return a bitmask of lookup options supported by this class for the specified datatype.
		*--
		  DODEFAULT()
		  RETURN LOOKUPMASK_FINDALL + LOOKUPMASK_PARTIAL + LOOKUPMASK_PHONETIC + LOOKUPMASK_NICKNAME
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmstringlookup AS cmlookupabstract OF "cmlookup.vcx" 		&& Lookup records by character string based keys.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: lookup		&& Find a record using the character based key tag specified.
		*m: supportedoptions		&& Return a bitmask of lookup options supported by this class for the specified datatype.
	*</DefinedPropArrayMethod>

	Name = "cmstringlookup"
	
	PROCEDURE lookup		&& Find a record using the character based key tag specified.
		LPARAMETERS cFullMatchValue, cTagName, cPhoneticTag, cWorkArea, nFlags, cDisplayExp, oProgress
		*++
		*>>Find a record using the character based key tag specified.
		*
		* nFlags bitmask can contain bits:
		*  LOOKUPMASK_FINDALL  - Find all matches, putting results in a temporary cursor
		*  LOOKUPMASK_PHONETIC - Enables phonetic matching
		*  LOOKUPMASK_PARTIAL  - to allow partial matches
		*--
		PRIVATE plAbort
		LOCAL lPartialMatch, nFirstPassHits, nWeight, nWildChar
		LOCAL cNormalKeyExpression, cPhoneticKeyExpression, cNormalMatchValue, cPhoneticMatchValue
		LOCAL cFldName, cLeftMatch, cRightMatch, cLeftFullMatch, cGlobalFilterExpression
		
		  * Progress indicator is optional
		  IF PCOUNT() < 7
		    m.oProgress = .NULL.
		  ENDIF
		
		  * Re-open the source cursor in a private workarea so we don't affect record buffering
		  m.cGlobalFilterExpression = THIS.OpenSource(m.cWorkarea)
		
		  * Get flag settings for optional behaviors
		  THIS.lFindAll = BITTEST(m.nFlags, LOOKUPFLAG_FINDALL)
		  m.lPartialMatch = BITTEST(m.nFlags, LOOKUPFLAG_PARTIAL)
		
		  * Apply index normalization to match string.
		  IF TAGNO(m.cTagName) = 0
		    m.cFldName = m.cTagname
		    m.cTagName = ''
		    m.cNormalKeyExpression = 'NormalizeString(' + m.cFldName + ')'
		    m.cNormalMatchValue = NormalizeString(m.cFullMatchValue)
		  ELSE
		    m.cFldName = TagField(m.cTagname)
		    m.cNormalKeyExpression = NORMALIZE(KEY(TAGNO(m.cTagName)))
		    IF '(' $ m.cNormalKeyExpression
		      m.cNormalMatchValue = TRIM(EVALUATE(STRTRAN(m.cNormalKeyExpression, '(' + UPPER(m.cFldName), '(m.cFullMatchValue')))
		    ELSE
		      m.cNormalMatchValue = m.cFullMatchValue
		    ENDIF
		  ENDIF
		
		  * Generate default display expression if none specified.
		  IF EMPTY(m.cDisplayExp)
		    m.cDisplayExp = m.cFldName
		  ENDIF
		
		  * Strip out wildcards, leaving ony match characters to the left of the first wildcard
		  m.nWildChar = IIF(THIS.lAllowWildcard, AT('*', CHRTRAN(m.cNormalMatchValue, '?', '*')), 0)
		  m.lPartialMatch = m.lPartialMatch OR m.nWildChar > 0
		  IF NOT m.lPartialMatch
		    * Pad string key to the full length of the table field.
		    m.cLeftMatch = PADR(m.cNormalMatchValue, LEN(EVALUATE(m.cFldName)))
		  ELSE
		    IF m.nWildChar = 0
		      m.cLeftMatch = m.cNormalMatchValue
		    ELSE
		      m.cLeftMatch = LEFT(m.cNormalMatchValue, m.nWildChar - 1)
		      IF SUBSTR(m.cNormalMatchValue, m.nWildChar) == '*'  && Treat single trailing wildcard as standard partial match
		        m.nWildChar = 0
		      ENDIF
		    ENDIF
		  ENDIF
		
		  IF LEN(m.cLeftMatch) > 0
		    IF NOT EMPTY(m.cTagname)
		      SET ORDER TO (m.cTagname)
		      SET KEY TO (m.cLeftMatch)
		      GO TOP
		    ELSE
		      m.cGlobalFilterExpression = m.cGlobalFilterExpression + ' AND ' + m.cNormalKeyExpression + ' = m.cLeftMatch'
		    ENDIF
		  ENDIF
		
		  m.plAbort = .F.
		  SCAN ALL FOR &cGlobalFilterExpression ;
		       WHILE NOT m.plAbort AND THIS.nHitCount < THIS.nMaxHits    && Limit result set scan to a practical number.
		    * Resolve wildcard characters, and assign weights for quality of match.
		    DO CASE
		      CASE NOT EMPTY(m.nWildChar)
		        IF LIKE(m.cNormalMatchValue, TRIM(EVALUATE(m.cNormalKeyExpression)))
		          m.nWeight = 5
		        ELSE
		          LOOP
		        ENDIF
		
		      CASE UPPER(TRIM(EVALUATE(m.cFldName))) = UPPER(TRIM(m.cFullMatchValue))
		        IF UPPER(TRIM(EVALUATE(m.cFldName))) == UPPER(TRIM(m.cFullMatchValue))
		          m.nWeight = 8        && Bonus for full exact match.
		        ELSE
		          m.nWeight = 7        && Bonus for partial exact match.
		        ENDIF
		
		      CASE TRIM(EVALUATE(m.cNormalKeyExpression)) == m.cNormalMatchValue
		        m.nWeight = 6        && Bonus for full normalized match.
		      OTHERWISE
		        m.nWeight = 5        && Partial normalized match
		    ENDCASE
		
		    * If we are only looking for 1 result, stop looking once we get a partial exact match or better.
		    IF NOT THIS.AddHit(m.nWeight, EVALUATE(m.cDisplayExp), RECNO(), m.oProgress) AND m.nWeight >= 7
		      EXIT
		    ENDIF
		  ENDSCAN
		
		  * We may need to make a second pass over the records using a phonetic index.
		  * The phonetic index may not find acronyms due to word break rules (C.I.A. = cia) so first 
		  * pass uses normalized lookup, then a second pass to find additional phonetic possibilities.
		  IF BITTEST(m.nFlags, LOOKUPFLAG_PHONETIC) AND NOT EMPTY(m.cPhoneticTag) AND (THIS.lFindAll OR THIS.nHitCount = 0)
		    m.cPhoneticKeyExpression = NORMALIZE(KEY(TAGNO(m.cPhoneticTag)))
		    m.cPhoneticMatchValue = TRIM(EVALUATE(STRTRAN(m.cPhoneticKeyExpression, '(' + UPPER(m.cFldName), '(m.cFullMatchValue')))
		
		    * Build a phonetic key value to match against for second pass.
		    m.nWildChar = IIF(THIS.lAllowWildcard, AT('*', CHRTRAN(m.cPhoneticMatchValue, '?', '*')), 0)
		    IF NOT m.lPartialMatch
		      * Pad string key to the full length of the table field.
		      m.cLeftMatch = PADR(m.cPhoneticMatchValue, LEN(EVALUATE(m.cFldName)))
		    ELSE
		      IF m.nWildChar = 0
		        m.cLeftMatch = m.cPhoneticMatchValue
		      ELSE
		        m.cLeftMatch = LEFT(m.cPhoneticMatchValue, m.nWildChar - 1)
		        IF SUBSTR(m.cPhoneticMatchValue, m.nWildChar) == '*'  && Treat single trailing wildcard as standard partial match
		          m.nWildChar = 0
		        ENDIF
		      ENDIF
		    ENDIF
		
		    IF LEN(m.cLeftMatch) > 0
		      SET ORDER TO (m.cPhoneticTag)
		      SET KEY TO (m.cLeftMatch)
		      GO TOP
		    ELSE
		      * Physical record order is fastest if considering all records, with no filter.
		      SET ORDER TO
		    ENDIF
		
		    m.nFirstPassHits = THIS.nHitCount
		    IF THIS.lFindAll AND m.nFirstPassHits > 0
		      SELECT cmSearchResultsCursor
		      INDEX ON STR(recno, 8) tag recno
		      SELECT cmSearchCursor
		    ENDIF
		    SCAN ALL FOR &cGlobalFilterExpression ;
		         WHILE NOT m.plAbort AND THIS.nHitCount < THIS.nMaxHits    && Limit result set scan to a practical number.
		      * Skip records already processed during first pass, if any.
		      IF THIS.lFindAll AND m.nFirstPassHits > 0
		        IF SEEK(STR(RECNO(), 8), 'cmSearchResultsCursor')
		          LOOP
		        ENDIF
		      ENDIF
		
		      * Resolve wildcard characters, and assign weights for quality of match.
		      DO CASE
		        CASE NOT EMPTY(m.nWildChar)
		          IF LIKE(m.cPhoneticMatchValue, TRIM(EVALUATE(m.cPhoneticKeyExpression)))
		            m.nWeight = 3
		          ELSE
		            LOOP
		          ENDIF
		        CASE TRIM(EVALUATE(m.cPhoneticKeyExpression)) == m.cPhoneticMatchValue
		          m.nWeight = 4        && Full phonetic match
		        OTHERWISE
		          m.nWeight = 3        && partial phonetic
		      ENDCASE
		
		      IF NOT THIS.AddHit(m.nWeight, EVALUATE(m.cDisplayExp), RECNO(), m.oProgress)
		        EXIT   && Once we get at least a partial phonetic match, thats the best we will ever get.
		      ENDIF
		    ENDSCAN
		  ENDIF
		
		  IF THIS.nHitCount = 0 AND NOT ISNULL(THISFORM.oMessage)
		    THISFORM.oMessage.SetLastMessage('%MsgNotFound', m.cFullMatchValue)
		  ENDIF
		
		  THIS.CloseSource(m.oProgress)
		  RETURN THIS.nBestRecord
		
	ENDPROC

	PROCEDURE supportedoptions		&& Return a bitmask of lookup options supported by this class for the specified datatype.
		*++
		*>>Return a bitmask of lookup options supported by this class for the specified datatype.
		*--
		  DODEFAULT()
		  RETURN LOOKUPMASK_FINDALL + LOOKUPMASK_PARTIAL + LOOKUPMASK_PHONETIC
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmdatalistform AS frmformcustom OF "..\custom\cforms.vcx" 		&& Form to list the available records in a frmDataForm based form.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdListGrid" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdListGrid.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdListGrid.Column1.txtFirstColumn" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: first		&& Select first record
		*m: initgrid		&& Set up the controlSource for the grid columns after the rowsource has been established.
		*m: last		&& Select last record
		*m: next		&& Select next record
		*m: prior		&& Select prior record
		*m: setorder		&& Change the sort order of the display grid
		*m: showrecord		&& Update the calling form to display the current list record.
		*p: ctitle		&& Title string used to set form caption on init()
		*p: cworkarea		&& Workarea to list records of.
		*p: ocaller		&& Object reference to the form that called us.
	*</DefinedPropArrayMethod>

	Caption = "List"
	ctitle = %txtListFormTitle		&& Title string used to set form caption on init()
	cworkarea = 		&& Workarea to list records of.
	DoCreate = .T.
	Height = 198
	KeyPreview = .T.
	lcloseonescape = .T.
	MinButton = .F.
	Name = "frmdatalistform"
	ShowWindow = 1
	Width = 351
	WindowState = 0

	ADD OBJECT 'grdListGrid' AS grdgridcustom WITH ;
		AllowRowSizing = .F., ;
		ColumnCount = 1, ;
		creadonlydisplay = Normal, ;
		creposition = vStretch,hStretch, ;
		GridLineColor = 192,192,192, ;
		Height = 200, ;
		Left = 0, ;
		llocalizecaption = .T., ;
		lsearch = .T., ;
		Name = "grdListGrid", ;
		Panel = 1, ;
		ReadOnly = .T., ;
		RecordMark = .F., ;
		Top = 0, ;
		Width = 351, ;
		Column1.Name = "Column1", ;
		Column1.ReadOnly = .T., ;
		Column1.Width = 500
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="grid" />

	ADD OBJECT 'grdListGrid.Column1.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Available Records", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdListGrid.Column1.txtFirstColumn' AS txttextboxcustom WITH ;
		Left = 54, ;
		lnativebinding = .T., ;
		Name = "txtFirstColumn", ;
		ReadOnly = .F., ;
		Top = 54
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		* Update order if it changed.
		IF NOT ORDER(THIS.cWorkarea) == ORDER('cmListNavigationAlias')
		  SET ORDER TO (ORDER(THIS.cWorkarea)) IN cmListNavigationAlias
		ENDIF
		
		* Keep this window in sync with caller when we are reactivated.
		IF RECNO(THIS.cWorkarea) != RECNO('cmListNavigationAlias') ;
		AND RECNO(THIS.cWorkarea) > 0 AND RECNO(THIS.cWorkarea) <= RECCOUNT('cmListNavigationAlias')
		  GOTO (RECNO(THIS.cWorkarea)) IN cmListNavigationAlias
		ENDIF
		DODEFAULT()
		
	ENDPROC

	PROCEDURE first		&& Select first record
		GO TOP IN cmListNavigationAlias
		RETURN THIS.ShowRecord()
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS oCaller, cWorkarea, cRowExpression
		
		* Keep a reference to our calling form
		THIS.oCaller = m.oCaller
		THIS.cWorkarea = m.cWorkarea
		THIS.Caption = THIS.oMessage.Format(THIS.oMessage.TranslateString(THIS.cTitle), m.oCaller.Caption)
		
		* If name parser is referenced in display expression, load a reference to it.
		IF '.oname.' $ LOWER(m.cRowExpression) AND ISNULL(THIS.oName)
		  THIS.oName = CreateGlobalObject('cmNameParser')
		ENDIF
		
		* Open another copy of the navigation cursor so we don't 
		* interfere with any buffering in the original workarea.
		IF USED(m.cWorkarea)
		  UseAgain(m.cWorkarea, 'cmListNavigationAlias')
		
		  IF RECNO(m.cWorkarea) <= RECCOUNT('cmListNavigationAlias')
		    GOTO (RECNO(m.cWorkarea)) IN cmListNavigationAlias
		  ENDIF
		
		  STORE 'cmListNavigationAlias' TO THIS.grdListGrid.cWorkarea, THIS.grdListGrid.RecordSource
		
		  THIS.InitGrid(m.cRowExpression)
		
		  * Put the initial record a little ways down from the top
		  THIS.grdListGrid.DoScroll(0)
		  THIS.grdListGrid.DoScroll(0)
		ENDIF
		
		THIS.nInstance = 0   && Don't display our instance number in title bar
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE initgrid		&& Set up the controlSource for the grid columns after the rowsource has been established.
		LPARAMETER cRowExpression
		*++
		* Set the controlSource for each grid column. 
		* Called after the grid RowSource has been set.
		*--
		  * Default code sets 1 column to the expression passed.
		  THIS.grdListGrid.Column1.ControlSource = m.cRowExpression
		
	ENDPROC

	PROCEDURE isenabled
		LPARAMETERS cMethod, cWorkArea
		*++
		* Used to determine when the specified form method can be 
		* called from toolbar action buttons.
		*--
		  m.cMethod = PROPER(m.cMethod)
		  DO CASE
		    CASE m.cMethod == 'Close'
		      RETURN .T.
		    CASE m.cMethod $ 'Next,Prior,First,Last'      && Toolbar navigation action buttons
		      RETURN THIS.oCaller.IsEnabled(m.cMethod, THIS.cWorkarea)
		    CASE m.cMethod == 'Setorder'
		      RETURN THIS.oCaller.IsEnabled(m.cMethod, THIS.cWorkarea)
		  ENDCASE
		  RETURN .F.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		  IF m.nKeyCode = 13
		    * Close on a Carriage Return in the list window
		    RETURN THISFORM.Close()
		  ENDIF
		  DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
	ENDPROC

	PROCEDURE last		&& Select last record
		GO BOTTOM IN cmListNavigationAlias
		RETURN THIS.ShowRecord()
		
	ENDPROC

	PROCEDURE next		&& Select next record
		IF NOT EOF('cmListNavigationAlias')
		  SKIP 1 IN cmListNavigationAlias
		  RETURN THIS.ShowRecord()
		ENDIF
		
	ENDPROC

	PROCEDURE prior		&& Select prior record
		IF NOT BOF('cmListNavigationAlias')
		  SKIP -1 IN cmListNavigationAlias
		  RETURN THIS.ShowRecord()
		ENDIF
		
	ENDPROC

	PROCEDURE setorder		&& Change the sort order of the display grid
		LPARAMETER cOrder, cWorkarea
		  * Calling FlushControlBuffer() will put focus of the grid, allowing the grid to 
		  * refresh without moving the record pointer.
		  * The parent SetOrder() will translate lookupManager tag names into the correct index tag.
		  IF THIS.FlushControlBuffer() AND THIS.oCaller.SetOrder(cOrder, cWorkarea)
		    SET ORDER TO (ORDER(THIS.cWorkarea)) IN cmListNavigationAlias
		    THIS.Refresh()
		
		    * Refresh any navigation order controls that may be present in toolbars.
		    THIS.oStateManager.RefreshAll('Form Order')
		  ENDIF
		  THIS.ActivateNextControl()   && Put focus back on the grid
		  RETURN .T.
		
	ENDPROC

	PROCEDURE showrecord		&& Update the calling form to display the current list record.
		* Move caller's record pointer if it is different.
		IF RECNO('cmListNavigationAlias') != RECNO(THIS.cWorkarea)
		  IF THIS.oCaller.BeforeNav(THIS.cWorkarea, .T.)  && Ask what to do with any changes.
		    IF THIS.oCaller.Goto(RECNO('cmListNavigationAlias'), THIS.cWorkarea)
		      * Refresh all form navigaton related states and actions.
		      SELECT cmListNavigationAlias
		      THIS.oStatemanager.RefreshAll('Form Nav')
		      RETURN .T.
		    ENDIF
		  ENDIF
		
		  * Form couldn't move, so put us back where the form is.
		  IF RECNO(THIS.cWorkarea) <= RECCOUNT('cmListNavigationAlias')
		    GOTO (RECNO(THIS.cWorkarea)) IN cmListNavigationAlias
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Unload
		DODEFAULT()
		IF USED('cmListNavigationAlias')
		  USE IN cmListNavigationAlias
		ENDIF
		
	ENDPROC

	PROCEDURE grdListGrid.afterrowchange
		THISFORM.ShowRecord()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmfinddialog AS frmformcustom OF "..\custom\cforms.vcx" 		&& Common Find Dialog for performing interactive keyed record lookups.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Shpshape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkNickname" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkPhonetic" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkPartial" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSearchString" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboSearchKey" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Lbllabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblHigh" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstItems" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgLookupType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtSearchHigh" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkRange" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntOkCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntOkCancel.cmdListAll" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: clearresults		&& Clear result set for a new search
		*m: selectlookuptag		&& Select a new keytag, and enable/disable lookup options accordingly.
		*m: updateprogress		&& Report search progress for long large result sets.
		*p: cclosecaption		&& Caption for Close button, set after Find All.
		*p: cfindoptionsroot		&& System registry root key for storing lookup options preferences.
		*p: clookuptag		&& Currently selected lookup tag name
		*p: cprogresstext		&& Progress indicator message text translation
		*p: cworkarea		&& Workarea to operate in
		*p: lfindall		&& True to find all matching values
		*p: lnicknames		&& Match on nicknames for parsed name keys.
		*p: lpartial		&& Allow Partial matches
		*p: lphonetic		&& Allow phonetic matching if a suitable index is available.
		*p: lrange		&& Accept a range of search values
		*p: ocaller		&& Reference to calling form
	*</DefinedPropArrayMethod>

	Caption = ""
	cclosecaption = \<Close		&& Caption for Close button, set after Find All.
	cfindoptionsroot = 		&& System registry root key for storing lookup options preferences.
	chelpkey = %hlpLookupDialogHelp
	clookuptag = 		&& Currently selected lookup tag name
	ControlBox = .F.
	cprogresstext = 		&& Progress indicator message text translation
	cworkarea = 		&& Workarea to operate in
	DataSession = 1
	Desktop = .T.
	DoCreate = .T.
	Height = 184
	lnicknames = .T.		&& Match on nicknames for parsed name keys.
	lpartial = .T.		&& Allow Partial matches
	lphonetic = .T.		&& Allow phonetic matching if a suitable index is available.
	MinHeight = (THIS.Height)
	MinWidth = (THIS.Width)
	Name = "frmfinddialog"
	ocaller = .NULL.		&& Reference to calling form
	ShowWindow = 1
	Width = 265
	WindowType = 1

	ADD OBJECT 'cboSearchKey' AS cbocomboboxcustom WITH ;
		chelpkey = %hlpLookupKey, ;
		Height = 22, ;
		Left = 52, ;
		Name = "cboSearchKey", ;
		Style = 2, ;
		TabIndex = 13, ;
		Tag = "", ;
		Top = 5, ;
		Value = 1, ;
		Width = 204, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkNickname' AS chkcheckbox WITH ;
		Caption = "Match Nicknames", ;
		chelpkey = %hlpLookupNickname, ;
		ControlSource = "THISFORM.lNicknames", ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 133, ;
		Name = "chkNickname", ;
		TabIndex = 9, ;
		Top = 122, ;
		Visible = .F., ;
		Width = 105, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkPartial' AS chkcheckbox WITH ;
		Caption = "Allow Partial Match", ;
		chelpkey = %hlpLookupPartial, ;
		ControlSource = "THISFORM.lPartial", ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 133, ;
		Name = "chkPartial", ;
		TabIndex = 7, ;
		Top = 90, ;
		Width = 109, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkPhonetic' AS chkcheckbox WITH ;
		Caption = "Phonetic Match", ;
		chelpkey = %hlpLookupPhonetic, ;
		ControlSource = "THISFORM.lPhonetic", ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 133, ;
		Name = "chkPhonetic", ;
		TabIndex = 8, ;
		Top = 106, ;
		Visible = .F., ;
		Width = 92, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkRange' AS chkcheckbox WITH ;
		Caption = "Range of Values", ;
		chelpkey = %hlpLookupNickname, ;
		ControlSource = "THISFORM.lRange", ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 133, ;
		Name = "chkRange", ;
		TabIndex = 10, ;
		Top = 106, ;
		Visible = .F., ;
		Width = 105, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cntOkCancel' AS cntokcancelcustom WITH ;
		BackStyle = 0, ;
		creposition = vFollow, ;
		Height = 26, ;
		Left = 12, ;
		Name = "cntOkCancel", ;
		TabIndex = 12, ;
		Top = 153, ;
		Width = 241, ;
		cmdcancel.Left = 166, ;
		cmdcancel.Name = "cmdcancel", ;
		cmdcancel.Top = 1, ;
		cmdok.Caption = "\<Find", ;
		cmdok.Default = .T., ;
		cmdok.Left = 0, ;
		cmdok.Name = "cmdok", ;
		cmdok.Top = 1
		*< END OBJECT: ClassLib="..\custom\cbutton.vcx" BaseClass="container" />

	ADD OBJECT 'cntOkCancel.cmdListAll' AS cmdcommandbuttoncustom WITH ;
		Caption = "\<List All", ;
		Left = 83, ;
		Name = "cmdListAll", ;
		Top = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblFind' AS lblfieldlabelcustom WITH ;
		Caption = "Matching:", ;
		FontBold = .F., ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 7, ;
		Name = "lblFind", ;
		TabIndex = 1, ;
		Top = 35, ;
		Width = 47, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblHigh' AS lblfieldlabelcustom WITH ;
		Caption = "to:", ;
		FontBold = .F., ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 21, ;
		Name = "lblHigh", ;
		TabIndex = 2, ;
		Top = 58, ;
		Visible = .F., ;
		Width = 32, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'Lbllabel1' AS lblfieldlabelcustom WITH ;
		Caption = "Look for:", ;
		FontBold = .F., ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 4, ;
		Name = "Lbllabel1", ;
		TabIndex = 3, ;
		Top = 8, ;
		Width = 47, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lstItems' AS lstlistboxcustom WITH ;
		creposition = hStretch,Vstretch, ;
		Height = 174, ;
		Left = 267, ;
		Name = "lstItems", ;
		TabIndex = 11, ;
		Top = 5, ;
		Visible = .F., ;
		Width = 211, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="listbox" />

	ADD OBJECT 'opgLookupType' AS opgoptiongroup WITH ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		chelpkey = %hlpLookupType, ;
		Height = 45, ;
		Left = 15, ;
		Name = "opgLookupType", ;
		TabIndex = 6, ;
		Top = 92, ;
		Value = 1, ;
		Width = 97, ;
		ZOrderSet = 10, ;
		Option1.BackStyle = 0, ;
		Option1.Caption = "Find Best Match", ;
		Option1.FontSize = 8, ;
		Option1.Height = 17, ;
		Option1.Left = 0, ;
		Option1.Name = "optBest", ;
		Option1.Top = 1, ;
		Option1.Value = 1, ;
		Option1.Width = 103, ;
		Option2.BackStyle = 0, ;
		Option2.Caption = "Find All Matches", ;
		Option2.FontSize = 8, ;
		Option2.Height = 17, ;
		Option2.Left = 0, ;
		Option2.Name = "optAll", ;
		Option2.Top = 24, ;
		Option2.Width = 104
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'Shpshape1' AS shpshapecustom WITH ;
		BackStyle = 0, ;
		Height = 66, ;
		Left = 7, ;
		Name = "Shpshape1", ;
		Top = 81, ;
		Width = 249, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />

	ADD OBJECT 'txtSearchHigh' AS txttextboxcustom WITH ;
		chelpkey = %hlpLookupMatch, ;
		Height = 22, ;
		Left = 57, ;
		Name = "txtSearchHigh", ;
		SelectOnEntry = .T., ;
		TabIndex = 5, ;
		Top = 54, ;
		Visible = .F., ;
		Width = 191, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtSearchString' AS txttextboxcustom WITH ;
		chelpkey = %hlpLookupMatch, ;
		Height = 22, ;
		Left = 57, ;
		Name = "txtSearchString", ;
		SelectOnEntry = .T., ;
		TabIndex = 4, ;
		Top = 31, ;
		Width = 191, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="textbox" />
	
	PROCEDURE clearresults		&& Clear result set for a new search
		THIS.Caption = THIS.cDisplayName
		THISFORM.lstItems.RowSource = ''
		THISFORM.lstItems.RowSourceType = 0
		
	ENDPROC

	PROCEDURE confirmcancel
		RETURN .T.  && never need confirmation
		
	ENDPROC

	PROCEDURE confirmclose
		RETURN .T.    && Confirmation never needed
		
	ENDPROC

	PROCEDURE Destroy
		DODEFAULT()
		
		* Save dialog options for next time
		IF NOT ISNULL(THIS.oCaller)
		  LOCAL cOptions
		  m.cOptions = ALLTRIM(STR(THIS.cboSearchKey.Value)) + ','
		  IF THIS.opgLookupType.Value = 2
		    m.cOptions = m.cOptions + 'Findall,'
		  ENDIF
		  IF NOT EMPTY(THIS.chkPartial.Value)
		    m.cOptions = m.cOptions + 'Partial,'
		  ENDIF
		  IF NOT EMPTY(THIS.chkPhonetic.Value)
		    m.cOptions = m.cOptions + 'Phonetic,'
		  ENDIF
		  IF NOT EMPTY(THIS.chkNickname.Value)
		    m.cOptions = m.cOptions + 'Nickname,'
		  ENDIF
		  IF NOT EMPTY(THIS.chkRange.Value)
		    m.cOptions = m.cOptions + 'Range,'
		  ENDIF
		  cmRegSetString(HKEY_CURRENT_USER, THIS.cFindOptionsRoot, m.cOptions)
		ENDIF
		
		* Close (and delete) the search results cursor, if it is open.
		IF USED('cmSearchResultsCursor')
		  USE IN cmSearchResultsCursor
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		LPARAMETER oCaller, cWorkarea
		LOCAL nValue, cOptions, cTags
		
		  THIS.oCaller = m.oCaller
		  THIS.cWorkarea = PROPER(TRIM(m.cWorkarea))
		
		  * Get the list of available lookup keys from the caller's lookup manager.
		  m.cTags = m.oCaller.cmLookupManager.GetLookupTagList(m.cWorkarea)
		  ASSERT NOT EMPTY(m.cTags) MESSAGE THIS.name + ' No Lookup keys Defined'
		  DO WHILE NOT EMPTY(m.cTags)
		    THIS.cboSearchKey.AddItem(GetToken(@m.cTags, ','))
		  ENDDO
		  THIS.cboSearchKey.ListIndex = 1
		
		  THIS.MaxWidth = THIS.Width
		  THIS.MaxHeight = THIS.Height
		
		  * Restore dialog settings from last instance, if any.
		  THIS.cFindOptionsRoot = THIS.oCaller.cSysRegFormRoot + '\LookupOptions\' + THIS.cWorkarea
		  IF cmRegGetValue(HKEY_CURRENT_USER, THIS.cFindOptionsRoot, @m.cOptions)
		    m.nValue = VAL(m.cOptions)
		    THIS.cboSearchKey.Value = MAX(MIN(THIS.cboSearchKey.Listcount, m.nValue), 1)
		    THIS.opgLookupType.SetValue(IIF('Findall,' $ m.cOptions, 2, 1))
		    THIS.chkPartial.SetValue('Partial,' $ m.cOptions)
		    THIS.chkPhonetic.SetValue('Phonetic,' $ m.cOptions)
		    THIS.chkNickname.SetValue('Nickname,' $ m.cOptions)
		    THIS.chkRange.SetValue('Range,' $ m.cOptions)
		  ENDIF
		
		  THIS.SelectLookupTag()
		
		  * Call class init method
		  IF DODEFAULT()
		    * Localized form caption text is loaded from the form's help key
		    THIS.Caption = TRIM(THIS.Caption) + ' ' + THIS.oCaller.NiceCursorName(m.cWorkarea)
		    THIS.cDisplayName = THIS.Caption
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE saveallchanges
		LOCAL nRecno, cValue, nFlags
		
		m.nFlags = 0
		IF THIS.lFindAll
		  m.nFlags = LOOKUPMASK_FINDALL
		ENDIF
		IF THIS.lPartial
		  m.nFlags = BITSET(m.nFlags, LOOKUPFLAG_PARTIAL)
		ENDIF
		IF THIS.lPhonetic AND THIS.chkPhonetic.Visible
		  m.nFlags = BITSET(m.nFlags, LOOKUPFLAG_PHONETIC)
		ENDIF
		IF THIS.lNicknames AND THIS.chkNickname.Visible
		  m.nFlags = BITSET(m.nFlags, LOOKUPFLAG_NICKNAME)
		ENDIF
		IF THIS.lRange AND THIS.chkRange.Visible
		  m.nFlags = BITSET(m.nFlags, LOOKUPFLAG_RANGE)
		ENDIF
		
		* Clear any existing result list contents
		THISFORM.ClearResults()
		
		m.cValue = TRIM(THIS.txtSearchString.Value)
		IF BITTEST(m.nFlags, LOOKUPFLAG_RANGE)
		  m.cValue = m.cValue + CHR(0) + TRIM(THIS.txtSearchHigh.Value)
		ENDIF
		
		m.nRecno = THIS.oCaller.cmLookupManager.Lookup(m.cValue, ;
		                         THIS.cLookupTag, THIS.cWorkarea, m.nFlags, THIS)
		DO CASE
		  CASE EMPTY(m.nRecno)
		    THIS.oMessage.DisplayLastMessage()
		    RETURN .F.  && Don't close the dialog
		
		  CASE BITTEST(m.nFlags, LOOKUPFLAG_FINDALL)
		    THIS.lstItems.RowSourceType = 2
		    THIS.lstItems.RowSource = 'cmSearchResultsCursor'
		    THIS.lstItems.ListIndex = 1
		
		    * Expand dialog to show results list the first time results are displayed.
		    IF NOT THIS.lstItems.Visible
		      THIS.lstItems.Visible = .T.
		      THISFORM.MaxWidth = -1
		      THISFORM.MaxHeight = -1
		      THISFORM.nOriginalWidth = THIS.lstItems.Left + THIS.lstItems.Width + THIS.lstItems.Top
		      THISFORM.Width = THISFORM.nOriginalWidth
		      THISFORM.MinWidth = THISFORM.nOriginalWidth
		    ENDIF
		
		    * Temporarily disable the find button. Will be re-enabled on next refresh.
		    THIS.cntOkCancel.cmdOk.Enabled = .F.
		    THIS.cntOkCancel.cmdCancel.Caption = THIS.cCloseCaption
		    THIS.SetNextControl(THIS.lstItems)
		    RETURN .F.  && Don't close the dialog
		
		  OTHERWISE
		    RETURN THIS.oCaller.Goto(m.nRecno, THIS.cWorkarea)
		ENDCASE
		
	ENDPROC

	PROCEDURE selectlookuptag		&& Select a new keytag, and enable/disable lookup options accordingly.
		LOCAL nFlags
		
		IF THIS.cboSearchKey.ListIndex > 0
		  THIS.cLookupTag = THIS.oCaller.cmLookupManager.GetTagFromDisplayName( ;
		                             THIS.cboSearchKey.List[THIS.cboSearchKey.ListIndex], THIS.cWorkarea)
		
		  * Get a list of the lookup control options available for this key.
		  m.nFlags = THIS.oCaller.cmLookupManager.GetTagOptions(THIS.cLookupTag, THIS.cWorkarea)
		
		  IF BITTEST(m.nFlags, LOOKUPFLAG_FINDALL)
		    THIS.opgLookupType.optAll.Enabled = .T.
		    THIS.cntOkCancel.cmdListAll.Set('lEnabled', .T.)
		  ELSE
		    THIS.opgLookupType.SetValue(1)
		    THIS.opgLookupType.optAll.Enabled = .F.
		    THIS.cntOkCancel.cmdListAll.Set('lEnabled', .F.)
		  ENDIF
		
		  THIS.chkPartial.Visible = BITTEST(m.nFlags, LOOKUPFLAG_PARTIAL)
		  THIS.chkPhonetic.Visible = BITTEST(m.nFlags, LOOKUPFLAG_PHONETIC)
		  THIS.chkNickname.Visible = BITTEST(m.nFlags, LOOKUPFLAG_NICKNAME)
		  THIS.chkRange.Visible = BITTEST(m.nFlags, LOOKUPFLAG_RANGE)
		  THIS.txtSearchHigh.Refresh()
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE updateprogress		&& Report search progress for long large result sets.
		LPARAMETER nHits
		
		IF EMPTY(THIS.cProgressText)
		  THIS.cProgressText = THIS.oMessage.TranslateString('%txtLookupProgress')
		ENDIF
		THIS.Caption = THIS.oMessage.Format(THIS.cProgressText, m.nHits)
		
	ENDPROC

	PROCEDURE cboSearchKey.afterchange
		* Clear any existing result list contents
		THISFORM.ClearResults()
		THISFORM.SelectLookupTag()
		THISFORM.cntOkCancel.Refresh()
		
		IF NOT EMPTY(THIS.Tag)
		  THISFORM.txtSearchString.SetFocus()
		ENDIF
		
	ENDPROC

	PROCEDURE cboSearchKey.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		  * Set flag for mouse access
		  THIS.Tag = 'M'
		  DODEFAULT()
		
	ENDPROC

	PROCEDURE cboSearchKey.When
		THIS.Tag = ''   && Used as a flag for detecting change-by-mouse
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE chkNickname.Click
		THISFORM.txtSearchString.SetFocus()
		THISFORM.cntOkCancel.Refresh()
		
	ENDPROC

	PROCEDURE chkPartial.Click
		THISFORM.txtSearchString.SetFocus()
		THISFORM.cntOkCancel.Refresh()
		
	ENDPROC

	PROCEDURE chkPhonetic.Click
		THISFORM.txtSearchString.SetFocus()
		THISFORM.cntOkCancel.Refresh()
		
	ENDPROC

	PROCEDURE chkRange.afterchange
		THISFORM.txtSearchHigh.Refresh()
		THISFORM.cntOkCancel.Refresh()
		
	ENDPROC

	PROCEDURE chkRange.Click
		IF THIS.Value
		  THISFORM.txtSearchHigh.Visible = .T.
		  THISFORM.txtSearchHigh.SetFocus()
		ELSE
		  THISFORM.txtSearchString.SetFocus()
		ENDIF
		
	ENDPROC

	PROCEDURE cntOkCancel.cmdListAll.Click
		LOCAL lOldFindAll
		
		* Perform a full wildcard search.
		THISFORM.txtSearchString.SetValue('*')
		THISFORM.chkRange.SetValue(.F.)
		
		m.lOldFindAll = THISFORM.lFindall
		THISFORM.lFindall = .T.
		THISFORM.Save()
		THISFORM.lFindall = m.lOldFindAll
		
		THIS.Enabled = .F.   && Disable until next refresh
		
	ENDPROC

	PROCEDURE cntOkCancel.cmdok.Refresh
		THIS.Enabled = NOT EMPTY(THISFORM.txtSearchString.Value) OR  NOT EMPTY(THISFORM.txtSearchHigh.Value)
		
	ENDPROC

	PROCEDURE lstItems.DblClick
		THISFORM.Release()
		
	ENDPROC

	PROCEDURE lstItems.GotFocus
		IF NOT ISNULL(THISFORM.oCaller)
		  THISFORM.oCaller.Goto(cmSearchResultsCursor.Recno, THISFORM.cWorkarea)
		ENDIF
		
	ENDPROC

	PROCEDURE lstItems.InteractiveChange
		THISFORM.oCaller.Goto(cmSearchResultsCursor.Recno, THISFORM.cWorkarea)
		
	ENDPROC

	PROCEDURE opgLookupType.afterchange
		THISFORM.lFindAll = THIS.Value > 1
		THISFORM.ClearResults()
		THISFORM.cntOkCancel.Refresh()
		
	ENDPROC

	PROCEDURE txtSearchHigh.InteractiveChange
		DODEFAULT()
		THISFORM.cntOkCancel.Refresh()
		
	ENDPROC

	PROCEDURE txtSearchHigh.Refresh
		THIS.Visible = THISFORM.lRange AND THISFORM.chkRange.Visible
		THIS.Parent.lblHigh.Visible = THIS.Visible
		
	ENDPROC

	PROCEDURE txtSearchString.InteractiveChange
		DODEFAULT()
		THISFORM.cntOkCancel.Refresh()
		
	ENDPROC

ENDDEFINE
