*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmstate.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
*< LIBCOMMENT: CodeMine Global State Manager />
*
DEFINE CLASS cmcollectionmanager AS cmserviceabstract OF "cmdataa.vcx" 		&& Codemine form/toolbar collection manager
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: add		&& Create a new instance of the specified class/SCX.
		*m: clear		&& Release all objects added by the Add() method.
		*m: enumobjects		&& Enumerate the objects in this collection.
		*m: find		&& Find any managed instance of the specified class/SCX name.
		*m: forms		&& Return a reference to a particular form object by index number.
		*m: inspectordetails
		*m: remove		&& Remove an instance of the specified class.
		*m: removename		&& Remove a specific instance of a class by object name, if it exists.
		*m: _releaseobject		&& Internal method to Remove the object at the specified index position
	*</DefinedPropArrayMethod>

	Name = "cmcollectionmanager"
	
	PROCEDURE add		&& Create a new instance of the specified class/SCX.
		LPARAMETERS cClass, nPcount, uArg1, uArg2, uArg3, uArg4, uArg5, uArg6, uArg7
		*++
		*>>Create a new instance of the specified class/SCX.
		*-- 
		LOCAL ix, cParamlist, oInstance, cCommand
		
		  m.cClass = PROPER(m.cClass)
		  IF EMPTY(m.nPcount)
		    m.nPcount = 0
		  ENDIF
		
		  m.cParamlist = ''
		  FOR ix = 1 TO m.nPcount
		    m.cParamlist = m.cParamlist + ',@m.uArg' + STR(m.ix,1)
		  ENDFOR
		
		  * Build the command to Instantiate the form, and pass any parameters to it.
		  IF '.scx' $ LOWER(m.cClass)
		    * Remote app source for the .scx
		    IF '::' $ m.cClass
		      LOCAL cApp, cForm
		      m.cApp = LEFT(m.cClass, AT('::', m.cClass) - 1)
		      m.cForm = SUBSTR(m.cClass, AT('::', m.cClass) + 2)
		      m.cCommand = 'DO OpenForm IN "' + m.cApp + '" WITH "' + m.cForm + '", m.oInstance' + STRTRAN(m.cParamlist, '@', '')
		    ELSE
		      m.cCommand = 'DO FORM "' + m.cClass + '" NAME m.oInstance LINKED NOSHOW'
		      IF NOT EMPTY(m.cParamlist)
		        m.cCommand = m.cCommand + ' WITH ' + STRTRAN(SUBSTR(m.cParamlist, 2), '@', '')
		      ENDIF
		    ENDIF
		
		    * If path or remote app path is included in SCX name, strip before storing in name array
		    IF '::' $ m.cClass
		      m.cClass = PROPER(SUBSTR(m.cClass, RAT('::', m.cClass) + 2))
		    ENDIF
		    IF '\' $ m.cClass
		      m.cClass = PROPER(SUBSTR(m.cClass, RAT('\', m.cClass) + 1))
		    ENDIF
		  ELSE
		    m.cCommand = 'm.oInstance = CreateLocalized(m.cClass' + m.cParamList + ')'
		  ENDIF
		  &cCommand
		
		  IF VARTYPE(m.oInstance) = 'O'
		    IF ALEN(THIS.aObjects,1) > 1 OR NOT EMPTY(THIS.aObjects[1, 2])
		      DIMENSION THIS.aObjects[ALEN(THIS.aObjects,1) + 1, 3]
		    ENDIF
		    THIS.nCount = THIS.nCount + 1
		    THIS.aObjects[THIS.nCount, 1] = m.oInstance
		    THIS.aObjects[THIS.nCount, 2] = m.cClass                 && Class name in proper case
		    THIS.aObjects[THIS.nCount, 3] = UPPER(m.oInstance.Name)  && Object name in uppercase
		  ELSE
		    m.oInstance = .NULL.
		  ENDIF
		  RETURN m.oInstance
		
	ENDPROC

	PROCEDURE clear		&& Release all objects added by the Add() method.
		*++
		*>>Release all objects added by the Add() method.
		*--
		LOCAL nIndex
		  FOR nIndex = THIS.nCount TO 1 STEP -1
		    IF NOT THIS._ReleaseObject(m.nIndex)
		      RETURN .F.
		    ENDIF
		  ENDFOR
		  RETURN .T.
		
	ENDPROC

	PROCEDURE enumobjects		&& Enumerate the objects in this collection.
		LPARAMETERS nIndex, oResult
		*++
		*>>Enumerate the objects in this collection.
		*--
		  IF EMPTY(m.nIndex) OR m.nIndex < 0
		    m.nIndex = 1
		  ELSE
		    m.nIndex = m.nIndex + 1
		  ENDIF
		
		  IF m.nIndex <= THIS.nCount
		    m.oResult = THIS.aObjects[m.nIndex, 1]
		  ELSE
		    m.nIndex = -1    && No more objects
		  ENDIF
		  RETURN m.nIndex
		
	ENDPROC

	PROCEDURE find		&& Find any managed instance of the specified class/SCX name.
		LPARAMETERS cClass
		*++
		*>>Find any managed instance of the specified class/SCX name.
		*--
		LOCAL oInstance, nIndex, cExact
		
		  * If path or remote app path is included in SCX name, strip before searching name array
		  IF '::' $ m.cClass
		    m.cClass = PROPER(SUBSTR(m.cClass, RAT('::', m.cClass) + 2))
		  ENDIF
		  IF '\' $ m.cClass
		    m.cClass = PROPER(SUBSTR(m.cClass, RAT('\', m.cClass) + 1))
		  ENDIF
		
		  m.oInstance = .NULL.
		  m.cExact = SET('EXACT')
		  SET EXACT ON
		  DO WHILE NOT EMPTY(m.cClass)
		    m.nIndex = ASCAN(THIS.aObjects, PROPER(m.cClass))
		    IF m.nIndex > 0
		      m.nIndex = ASUBSCRIPT(THIS.aObjects, m.nIndex, 1)
		      m.oInstance = THIS.aObjects[m.nIndex, 1]
		
		      * If the object no longer exists, remove the row and try again.
		      IF ISNULL(m.oInstance)
		        THIS._ReleaseObject(m.nIndex)
		        LOOP
		      ENDIF
		    ENDIF
		    EXIT
		  ENDDO
		  IF m.cExact = 'OFF'
		    SET EXACT OFF
		  ENDIF
		  RETURN m.oInstance
		
	ENDPROC

	PROCEDURE forms		&& Return a reference to a particular form object by index number.
		LPARAMETERS ix
		*++
		*>>Return a reference to a particular form object by index number.
		*--
		  IF m.ix <= THIS.nCount
		    RETURN THIS.aObjects[m.ix, 1]
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE Init
		*++
		* Initialize the object collection manager.
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('aObjects[1,3]')  && Columns are: objref(col1), class(col2), name(col3)
		  THIS.AddProperty('nCount', 0)      && Number of managed objects currently defined
		
		  THIS.aObjects[1,1] = .NULL.
		  THIS.aObjects[1,2] = ''
		  THIS.aObjects[1,3] = ''
		
	ENDPROC

	PROCEDURE inspectordetails
		LPARAMETERS oNodes, cRoot
		*++
		* Display object-specific information in the Codemine object inspector.
		*--
		LOCAL ix, cName, oNode, oTemp
		
		  m.oNodes.Add(m.cRoot, 4, 'Objs', 'Managed Objects')
		  FOR ix = 1 TO THIS.nCount
		    m.oTemp = THIS.aObjects[m.ix, 1]
		    IF TYPE('m.oTemp.Name') = 'C'
		      m.cName = PROPER(m.oTemp.Name)
		      IF TYPE('m.oTemp.cVersion') = 'C'   && Watch out for numeric versions
		        m.cName = m.cName + ' (V' + m.oTemp.cVersion + ')'
		      ENDIF
		      m.oNode = m.oNodes.Add('Objs', 4,, m.cName)
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE remove		&& Remove an instance of the specified class.
		LPARAMETERS cClass, lForceRelease
		*++
		*>>Remove an instance of the specified class.
		*--
		LOCAL nIndex, cExact
		
		  m.cExact = SET('EXACT')
		  SET EXACT ON
		  m.nIndex = ASCAN(THIS.aObjects, PROPER(m.cClass))
		  IF m.cExact = 'OFF'
		    SET EXACT OFF
		  ENDIF
		
		  IF m.nIndex > 0
		    RETURN THIS._ReleaseObject(ASUBSCRIPT(THIS.aObjects, m.nIndex, 1), m.lForceRelease)
		  ENDIF
		  RETURN .T.   && If object not found, return success status
		
	ENDPROC

	PROCEDURE removename		&& Remove a specific instance of a class by object name, if it exists.
		LPARAMETERS cName, lForceRelease
		*++
		*>>Remove a specific instance of a class by object name, if it exists.
		*
		* This method only returns failure if the specified object is found, 
		* but cannot be released for some reason.
		*--
		LOCAL nIndex, cExact
		
		  IF NOT EMPTY(m.cName)
		    m.cExact = SET('EXACT')
		    SET EXACT ON
		    m.nIndex = ASCAN(THIS.aObjects, UPPER(m.cName))
		    IF m.cExact = 'OFF'
		      SET EXACT OFF
		    ENDIF
		
		    IF m.nIndex > 0
		      RETURN THIS._ReleaseObject(ASUBSCRIPT(THIS.aObjects, m.nIndex, 1), m.lForceRelease)
		    ENDIF
		  ENDIF
		  RETURN .T.   && If object not found, return success status
		
	ENDPROC

	PROCEDURE _releaseobject		&& Internal method to Remove the object at the specified index position
		LPARAMETERS nIndex, lForceRelease
		*++
		*>>Internal method to Remove the object at the specified index position
		*--
		LOCAL oRef, lStatus
		  m.lStatus = .T.
		  m.oRef = THIS.aObjects[m.nIndex,1]
		  IF VARTYPE(m.oRef) = 'O'
		    IF m.lForceRelease
		      IF PEMSTATUS(m.oRef, 'Release', 5) 
		        m.lStatus = m.oRef.Release()
		      ENDIF
		    ELSE
		      * If it is a form with a toolbar Close interface, then call the Close() method to release.
		      IF m.oRef.BaseClass == 'Form' AND PEMSTATUS(m.oRef, 'Close', 5) 
		        m.lStatus = m.oRef.Close()
		      ELSE
		        * If the object has a QueryUnload() method, call it first. If not, look for a Release() 
		        * method. If neither method exists, just clear the reference and hope the object goes away.
		        IF PEMSTATUS(m.oRef, 'QueryUnload', 5) 
		          m.lStatus = m.oRef.QueryUnload()
		        ENDIF
		        IF m.lStatus 
		          IF PEMSTATUS(m.oRef, 'Release', 5) 
		            m.lStatus = m.oRef.Release()
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  m.oRef = .NULL.
		  IF m.lStatus
		    THIS.aObjects[m.nIndex,1] = .NULL.
		    ADEL(THIS.aObjects, m.nIndex)
		    IF ALEN(THIS.aObjects,1) > 1
		      DIMENSION THIS.aObjects[ALEN(THIS.aObjects,1) - 1, 3]
		    ELSE
		      THIS.aObjects[1, 1] = .NULL.
		      THIS.aObjects[1, 2] = ''
		      THIS.aObjects[1, 3] = ''
		    ENDIF
		    THIS.nCount = THIS.nCount - 1
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmevent AS custom 		&& CodeMine Event object. Track and manage a defined state or action.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: broadcast		&& Call the method specified in cBroadcastMessage, for all subscribers to this event.
		*m: release		&& Releases a FormSet or Form from memory.
		*m: subscribe		&& Register an object to recieve a specified message when this event occurs.
		*m: unsubscribe		&& Remove an object from the list of subscribers
		*p: cbroadcastmethod
		*p: cexecutemethod
		*p: cfilemenubar
		*p: cname
		*p: lstopbroadcastonfailure		&& If set to .F., the Broadcast method will ignore error returns from subscribers. If set to .T., the first subscriber error stops the broadcast.
	*</DefinedPropArrayMethod>

	cbroadcastmethod = 
	cexecutemethod = 
	cfilemenubar = 
	cname = 
	lstopbroadcastonfailure = .F.		&& If set to .F., the Broadcast method will ignore error returns from subscribers. If set to .T., the first subscriber error stops the broadcast.
	Name = "cmevent"
	
	PROCEDURE broadcast		&& Call the method specified in cBroadcastMessage, for all subscribers to this event.
		LPARAMETERS nParams, uP1, uP2
		*++
		*>>Call the method specified in cBroadcastMessage, for all subscribers to this event.
		*--
		LOCAL ix, lStatus, cParams, cMethod, oTarget
		
		  * Save most recent parameters for rebroadcast to future subscribers.
		  THIS.nParamCount = IIF(PCOUNT() > 0, m.nParams, 0)
		  IF THIS.nParamCount >= 1
		    THIS.uValue1 = m.uP1
		  ENDIF
		  IF THIS.nParamCount >= 2
		    THIS.uValue2 = m.uP2
		  ENDIF
		
		  * Build parameters string
		  m.cParams = ''
		  FOR ix = 1 TO THIS.nParamCount
		    m.cParams = m.cParams + ', @m.uP' + STR(m.ix,1)
		  ENDFOR
		  m.cParams = '(' + SUBSTR(m.cParams, 3) + ')'
		
		  IF NOT EMPTY(THIS.cBroadcastMethod)
		    m.lStatus = .T.   && Assume successful execution
		
		    * Go through the list backwards, in case some objects release themselves as a result of the broadcast.
		    FOR ix = THIS.nSubscribers TO 1 STEP -1
		      m.oTarget = THIS.aSubscribers[m.ix, 1]
		      IF NOT ISNULL(m.oTarget) AND (m.lStatus OR NOT THIS.lStopBroadcastOnFailure)
		        m.cMethod = THIS.aSubscribers[m.ix, 2]
		        ASSERT PEMSTATUS(m.oTarget, m.cMethod, 5) MESSAGE ;
		            'Broadcast Error: ' + SYS(1272, m.oTarget) + ' Does not have method ' + m.cMethod
		
		        * Execute the method for this subscriber, retrieving return status (non-empty means success)
		        m.lStatus = NOT EMPTY(EVALUATE('m.oTarget.' + m.cMethod+ m.cParams)) AND m.lStatus
		
		        * Broadcast may result in multiple targets (especially forms) being closed, so watch out for that.
		        IF m.ix > THIS.nSubscribers + 1
		          m.ix = THIS.nSubscribers + 1
		        ENDIF
		      ENDIF
		    ENDFOR
		  ENDIF
		
		  * Return .T. if all subscribers returned success.
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE Destroy
		*++
		*>>Clear all subscriber references when we are destroyed.
		*--
		LOCAL ix
		  FOR ix = 1 TO THIS.nSubscribers
		    THIS.aSubscribers[m.ix, 1] = .NULL.
		  ENDFOR
		
		  THIS.uValue1 = .NULL.
		  THIS.uValue2 = .NULL.
		
	ENDPROC

	PROCEDURE Init
		*++
		* Copyright 2001-2002 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('nParamCount', 0)
		  THIS.AddProperty('uValue1')
		  THIS.AddProperty('uValue2')
		  THIS.AddProperty('nSubscribers', 0)
		  THIS.AddProperty('aSubscribers[1]', .NULL.)
		
	ENDPROC

	PROCEDURE release		&& Releases a FormSet or Form from memory.
		  RELEASE THIS
		
	ENDPROC

	PROCEDURE subscribe		&& Register an object to recieve a specified message when this event occurs.
		LPARAMETERS oSubscriber, cMethod, lNoBroadcast
		*++
		*>>Register an object to recieve a specified message when this event occurs.
		*--
		  THIS.nSubscribers = THIS.nSubscribers + 1
		  DIMENSION THIS.aSubscribers[THIS.nSubscribers, 2]
		  IF EMPTY(m.cMethod)
		    m.cMethod = THIS.cBroadcastMethod
		  ENDIF
		  THIS.aSubscribers[THIS.nSubscribers, 1] = m.oSubscriber
		  THIS.aSubscribers[THIS.nSubscribers, 2] = m.cMethod
		
		  * Send initial broadcast to subscriber, if caller wants it.
		  IF NOT m.lNoBroadcast AND NOT EMPTY(m.cMethod)
		    LOCAL ix, cParams
		    m.cParams = ''    && Build parameters string
		    FOR ix = 1 TO THIS.nParamCount
		      m.cParams = m.cParams + ', THIS.uValue' + STR(m.ix,1)
		    ENDFOR
		    EVALUATE('m.oSubscriber.' + m.cMethod + '(' + SUBSTR(m.cParams, 3) + ')')
		  ENDIF
		
	ENDPROC

	PROCEDURE unsubscribe		&& Remove an object from the list of subscribers
		LPARAMETERS oSubscriber
		*++
		*>>Remove an object from the list of subscribers
		*--
		LOCAL ix, cObjectName, oTmp
		
		  m.cObjectName = SYS(1272, m.oSubscriber) + '.'
		  FOR ix = THIS.nSubscribers TO 1 STEP -1
		    * Deleting the reference may cause the object to be destroyed, triggering a recursive 
		    * call here from the subscriber's Destroy() method. This may in turn shrink 
		    * the subscriber array size, so we need to re-sync our index after this possibility.
		    m.ix = MIN(m.ix, THIS.nSubscribers)
		
		    * If object no longer exists, or is part of specified object, remove entry.
		    IF VARTYPE(THIS.aSubscribers[m.ix, 1]) != 'O' ;
		    OR LEFT(SYS(1272, THIS.aSubscribers[m.ix, 1]) + '.', LEN(m.cObjectName)) == m.cObjectName
		      * Hold a temporary ref to the object, before removing its reference from the arry.
		      * This prevents a possible pre-mature recursion when last remaining ref is released.
		      * Otherwise, recursion can occurr from within the ADEL() call, causing errors.
		      m.oTmp = THIS.aSubscribers[m.ix, 1]
		      THIS.aSubscribers[m.ix, 1] = .NULL.
		      THIS.nSubscribers = THIS.nSubscribers - 1
		      IF THIS.nSubscribers > 0
		        ADEL(THIS.aSubscribers, m.ix)
		      ENDIF
		      m.oTmp = .NULL.
		    ENDIF
		  ENDFOR
		
		  * Shrink the array, if it now has empty space in it
		  IF THIS.nSubscribers < ALEN(THIS.aSubscribers, 1)
		    DIMENSION THIS.aSubscribers[MAX(1, THIS.nSubscribers), 2]
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmstatecleanup AS cmserviceabstract OF "..\common\cmdataa.vcx" 		&& CodeMine work-around for VFP Page Fault crash bug on CLEAR ALL command.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: cversion
		*p: ostatemanager
	*</DefinedPropArrayMethod>

	cversion = 7.0.0
	Name = "cmstatecleanup"
	ostatemanager = .NULL.
	
	PROCEDURE destroy
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.Clear()
		  ENDIF
		
	ENDPROC

	PROCEDURE init
		LPARAMETERS oStateManager
		*++
		* VFP will crash if the state manager is released while holding links to any form/toolbar 
		* controls during a CLEAR ALL. Since memvars are cleared first by CLEAR ALL, we create
		* this object with a single global memvar ref. Then on CLEAR ALL, we are destroyed before 
		* any other object.
		*
		* Copyright 2001 Soft Classics, Ltd. All rights reserved.
		*--
		  IF VARTYPE(m.oStateManager) = 'O'
		    THIS.oStateManager = m.oStateManager
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmstatemanager AS cmserviceabstract OF "cmdataa.vcx" 		&& CodeMine Interface State and Event Manager
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addtoolbar		&& Add a toolbar to the list of defined available toolbars, and optionally open it.
		*m: broadcast		&& Refresh all objects associated with the specified event.
		*m: cancelrefresh		&& Cancel all refresh request entries for the specified object, and any contained objects.
		*m: clear		&& Clear all event definitions, and all object ref links to external objects. Generally only called before app shutdown.
		*m: closeallforms		&& Close all open forms, following the on-screen Z order from top to bottom.
		*m: closeform		&& Find a reference to any instance of the specified form and close it by calling its Close() method.
		*m: closetoolbar		&& Find a reference to the specified toolbar and close it by calling its Release() method.
		*m: createstates		&& Create default set of managed states.
		*m: defineaction		&& Define a new System Action, and return the index number assigned to it.
		*m: definestate		&& Define a new System State, and return the index number assigned to it.
		*m: delete		&& Delete a state/event/action and remove all refresh object references.
		*m: enableinterrupts		&& API library call to monitor system states inside VFP's idle loop.
		*m: enumforms		&& Enumerate the currently open modeless forms.
		*m: enumtoolbars		&& Enumerate the available toolbars (including both open and closed ones).
		*m: execute		&& Execute the Method or System menu function associated with the specified action.
		*m: findform		&& Return an object reference to the first instance found of the specified form. Return .NULL. if none found.
		*m: findtoolbar		&& Return an object reference to the instance found of the specified toolbar. Return .NULL. if none found.
		*m: getactiveform		&& Return a refrerence to the active VFP form, or NULL if no user form is active.
		*m: getevent		&& Return a refrerence to the specified event object.
		*m: getindex		&& Return the State array index of a state. Allows for optimization of future GetValue() or Execute() calls.
		*m: getstateindex		&& Find the index of the specified state name.
		*m: getvalue		&& Return the current value of a state or action.
		*m: inspectordetails		&& Display State-manager-specific information in the Codemine object inspector.
		*m: isformopen		&& Return .T. if the specified form is currently open.
		*m: istoolbaropen		&& Return .T. if the specified toolbar is currently open.
		*m: omessage_access		&& Fill in the reference to the message display service object on first reference.
		*m: onidle		&& Called when VFP enters its Idle loop. Used to trigger background operations.
		*m: onleftmouse		&& Called on trapped left mouse clicks. Default code Starts the CM Object Inspector.
		*m: onmainwindowresize		&& Called when the main VFP window is resized. Default code broadcasts the event to subscribers.
		*m: onrightmouse		&& Called on trapped right mouse clicks
		*m: openform		&& Open a single instance of a form, or return reference to an existing instance.
		*m: openformmulti		&& Open a new instance of a form.
		*m: openmodalform		&& Instantiate a modal form, show it, and return its value if any.
		*m: opentoolbar		&& Open an instance of a toolbar, or return reference to an existing instance.
		*m: refresh		&& For backward compatibility only. Use Broadcast() method instead for new code.
		*m: refreshall		&& Broadcast Refresh() events to all subscribers to states/actions matching the specified name prefix.
		*m: removetoolbar		&& Decrement reference count and remove a toolbar from the list of available toolbars when the count reaches zero.
		*m: requestbackgroundrefresh		&& Add an object to list of objects to receive the next background refresh event message.
		*m: requestrefresh		&& Register an object (usually a toolbar button) to refresh when a state/action changes.
		*m: setformmenu		&& Set a form-specific context menu pad on the system menu bar.
		*m: setvalue		&& Set the value of a given state. Create the state if it doesn't exist yet.
		*m: subscribe		&& Register an object to recieve a specified message when a specified event occurs.
		*m: subscribenoinit		&& Register an object to recieve a message when a specified event occurs.
		*m: unsubscribe		&& UnSubscribe an object from the subscriber list for the specified event.
		*p: ccollectionmanagerclass		&& Class name of the collection manager object to use for form and toolbar collections.
		*p: cinspectorclass		&& Class name of the object inspector to create on ctrl+shift+click.
		*p: cversion		&& Internal codemine version string for this object.
		*p: lcallbacksenabled		&& True if callback timer is enabled. Read by Developer toolbar buttons.
		*p: leventsoffwarning		&& If true, a WAIT WINDOW message will be displayed for developer when callback interupts are disabled via the EnableInterrupts() method.
		*p: oapp		&& Runtime Reference to global application manager object
		*p: omessage		&& Runtime Reference to message object for class name localization - filled in at runtime via an access method.
	*</DefinedPropArrayMethod>

	ccollectionmanagerclass = cmCollectionManager		&& Class name of the collection manager object to use for form and toolbar collections.
	cinspectorclass = cmInspect.frmObjectInspector		&& Class name of the object inspector to create on ctrl+shift+click.
	cversion = 7.9		&& Internal codemine version string for this object.
	lcallbacksenabled = .F.		&& True if callback timer is enabled. Read by Developer toolbar buttons.
	leventsoffwarning = .T.		&& If true, a WAIT WINDOW message will be displayed for developer when callback interupts are disabled via the EnableInterrupts() method.
	Name = "cmstatemanager"
	oapp = .NULL.		&& Runtime Reference to global application manager object
	omessage = .NULL.		&& Runtime Reference to message object for class name localization - filled in at runtime via an access method.
	
	PROCEDURE addtoolbar		&& Add a toolbar to the list of defined available toolbars, and optionally open it.
		LPARAMETERS cName, lMemory, lDefault
		*++
		*>>Add a toolbar to the list of defined available toolbars, and optionally open it.
		* Use internal array to track: Name, Title, RefCount, and MemoryFlag for each toolbar.
		* Toolbar title is defined in the app registry as a simple text string.
		*--
		LOCAL ix, lOpen, cExact
		
		  m.cExact = SET('EXACT')
		  SET EXACT ON
		
		  * If no application object, disable memory and always create the toolbar
		  IF ISNULL(THIS.oApp)
		    m.lMemory = .F.
		    m.lDefault = .T.
		  ENDIF
		
		  m.cName = UPPER(m.cName)
		  m.ix = ASCAN(THIS.aToolbars, m.cName)
		  IF m.ix > 0
		    m.ix = ASUBSCRIPT(THIS.aToolbars, m.ix, 1)
		    THIS.aToolbars[m.ix, TOOL_REFCOUNT] = THIS.aToolbars[m.ix, TOOL_REFCOUNT] + 1
		  ELSE
		    m.ix = IIF(EMPTY(THIS.aToolbars), 0, ALEN(THIS.aToolbars, 1)) + 1
		    DIMENSION THIS.aToolbars[m.ix, TOOL_NCOLS]
		    THIS.aToolbars[m.ix, TOOL_NAME] = m.cName
		    THIS.aToolbars[m.ix, TOOL_REFCOUNT] = 1
		    THIS.aToolbars[m.ix, TOOL_MEMORY] = m.lMemory
		
		    * Open the toolbar now if it is supposed to be open
		    m.lOpen = m.lDefault
		    IF m.lMemory AND NOT ISNULL(THIS.oApp) ;
		    AND cmRegGetValue(HKEY_CURRENT_USER, THIS.oApp.cSysRegRoot + '\Toolbars\' + LOWER(m.cName) + '\Open', @m.lOpen)
		      m.lOpen = NOT EMPTY(m.lOpen)
		    ENDIF
		    IF m.lOpen
		      THIS.OpenToolbar(m.cName)
		    ENDIF
		  ENDIF
		
		  IF m.cExact = 'OFF'
		    SET EXACT OFF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE broadcast		&& Refresh all objects associated with the specified event.
		LPARAMETERS uEvent, uP1, uP2
		*++
		*>>Refresh all objects associated with the specified event.
		*--
		LOCAL nEvent
		
		  m.nEvent = IIF(VARTYPE(m.uEvent) = 'N', m.uEvent, THIS.GetStateIndex(m.uEvent))
		  IF m.nEvent > 0
		    RETURN THIS.aEventList[m.nEvent, 2].Broadcast(PCOUNT() - 1, @m.uP1, @m.uP2)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE cancelrefresh		&& Cancel all refresh request entries for the specified object, and any contained objects.
		LPARAMETERS oObject
		*++
		*>>Cancel all refresh request entries for the specified object, and any contained objects.
		*--
		  RETURN THIS.UnSubscribe('*', m.oObject)
		
	ENDPROC

	PROCEDURE clear		&& Clear all event definitions, and all object ref links to external objects. Generally only called before app shutdown.
		*++
		*>>Clear all event definitions, and all object ref links to external objects. Generally only called before app shutdown.
		*--
		LOCAL ix
		  * Clear idle callback requestors list.
		  THIS.aRequestors = .NULL.
		
		  * Release all event objects before releasing ourself.
		  FOR ix = 1 TO THIS.nEvents
		    IF NOT ISNULL(THIS.aEventList[m.ix, 2])
		      THIS.aEventList[m.ix, 2].Release()
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE closeallforms		&& Close all open forms, following the on-screen Z order from top to bottom.
		LPARAMETERS lForceRelease
		*++
		*>>Close all open forms, following the on-screen Z order from top to bottom.
		*
		* Use lForceRelease to release all forms (including modal ones), discarding any uncommited changes.
		*--
		LOCAL ix, nCount, oForm
		
		  * Release modal dialogs first, if lForceRelease is set.
		  IF m.lForceRelease
		    m.ix = 1
		    DO WHILE m.ix <= _SCREEN.FormCount
		      m.oForm = _SCREEN.Forms[m.ix]
		      m.nCount = _SCREEN.FormCount
		
		      IF m.oForm.BaseClass == 'Form' AND m.oForm.WindowType = 1
		        IF PEMSTATUS(m.oForm, 'lReleaseOnClose', 5)
		          m.oForm.lReleaseOnClose = .T.
		        ENDIF
		        m.oForm.Release()
		
		        * If not a form, or form was "stuck" move on to the next in the collection.
		        IF m.nCount != _SCREEN.FormCount
		          * Closing a form may close 1 or more toolbars, and since toolbars are always listed
		          * before forms, we need to start the loop over again to be sure we dont miss any forms.
		          IF m.nCount - _SCREEN.FormCount > 1
		            m.ix = 0
		          ENDIF
		        ENDIF
		      ENDIF
		      m.ix = m.ix + 1
		    ENDDO
		  ENDIF
		
		  m.ix = 1
		  DO WHILE m.ix <= _SCREEN.FormCount
		    m.oForm = _SCREEN.Forms[m.ix]
		    m.nCount = _SCREEN.FormCount
		    IF m.oForm.BaseClass == 'Form'
		      IF NOT THIS.cmFormCollection.RemoveName(m.oForm.Name, m.lForceRelease)
		        RETURN .F.
		      ENDIF
		    ENDIF
		
		    * If not a form, or form was "stuck" move on to the next in the collection.
		    IF m.nCount = _SCREEN.FormCount
		      m.ix = m.ix + 1
		    ELSE
		      * Closing a form may close 1 or more toolbars, and since toolbars are always listed
		      * before forms, we need to start the loop over again to be sure we dont miss any forms.
		      IF m.nCount - _SCREEN.FormCount > 1
		        m.ix = 1
		      ENDIF
		    ENDIF
		  ENDDO
		  RETURN .T.
		
	ENDPROC

	PROCEDURE closeform		&& Find a reference to any instance of the specified form and close it by calling its Close() method.
		LPARAMETERS cClass
		*++
		*>>Find a reference to any instance of the specified form and close it by calling its Close() method.
		*--
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  RETURN THIS.cmFormCollection.Remove(m.cClass)
		
	ENDPROC

	PROCEDURE closetoolbar		&& Find a reference to the specified toolbar and close it by calling its Release() method.
		LPARAMETERS cClass
		*++
		*>>Find a reference to the specified toolbar and close it by calling its Release() method.
		*--
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  RETURN THIS.cmToolbarCollection.Remove(m.cClass)
		
	ENDPROC

	PROCEDURE createstates		&& Create default set of managed states.
		*++
		*>>Create default set of managed states.
		*--
		  * Create System states managed internally here.
		  THIS.DefineState('System Edit State')
		  THIS.DefineState('System Modal')
		  THIS.DefineState('System Key Toggle')
		  THIS.DefineState('Window Change')
		  THIS.DefineState('Main Window Resize')
		
		  * Define events for app registry modification by users.
		  THIS.DefineState('Registry Update Local',, 'RegistryUpdate')
		  THIS.DefineState('Registry Update Shared',, 'RegistryUpdate')
		
		  * And create the default set of form actions
		  THIS.DefineAction('Form Edit Save', 'Save', '_MFI_SAVE')
		  THIS.DefineAction('Form Edit Cancel', 'Cancel', '_MFI_REVRT')
		  THIS.DefineAction('Form Edit Start', 'Editmode')
		  THIS.DefineAction('Form Edit', 'Edit')
		  THIS.DefineAction('Form Refresh Data', 'RefreshData')
		  THIS.DefineAction('Form Report', 'Report', '_MFI_SYSPRINT')
		  THIS.DefineAction('Form Report Preview', 'Report', '_MFI_PREVU')
		  THIS.DefineAction('Form Close', 'Close', '_MFI_CLOSE')
		  THIS.DefineAction('Form Nav Next', 'Next')
		  THIS.DefineAction('Form Nav Last', 'Last')
		  THIS.DefineAction('Form Nav Prior', 'Prior')
		  THIS.DefineAction('Form Nav First', 'First')
		  THIS.DefineAction('Form List', 'List')
		  THIS.DefineAction('Form Find', 'Find')
		  THIS.DefineAction('Form New', 'New')
		  THIS.DefineAction('Form Delete', 'Delete')
		  THIS.DefineAction('Form Requery', 'Requery')
		
	ENDPROC

	PROCEDURE defineaction		&& Define a new System Action, and return the index number assigned to it.
		LPARAMETERS cEvent, cMethod, cSystemBar, lStopBroadcastOnFailure
		*++
		*>>Define a new System Action, and return the index number assigned to it.
		*--
		LOCAL ix, oEvent
		  IF EMPTY(m.cMethod) AND ' ' $ m.cEvent
		    ERROR 'Action method name is required'
		  ENDIF
		
		  m.ix = THIS.GetStateIndex(m.cEvent, .T.)   && Create if not found.
		  m.oEvent = THIS.aEventList[m.ix, 2]
		  m.oEvent.cExecuteMethod = PROPER(IIF(EMPTY(m.cMethod), m.cEvent, m.cMethod))
		  m.oEvent.cFileMenuBar = IIF(EMPTY(m.cSystembar), '', m.cSystembar)
		  m.oEvent.lStopBroadcastOnFailure = m.lStopBroadcastOnFailure
		
		  ASSERT NOT ' ' $ m.oEvent.cExecuteMethod MESSAGE THIS.Name + ' Invalid Action Method Name: ' + m.oEvent.cExecuteMethod
		  RETURN m.ix
		
	ENDPROC

	PROCEDURE definestate		&& Define a new System State, and return the index number assigned to it.
		LPARAMETERS cEvent, uValue, cMethod
		*++
		*>>Define a new System State, and return the index number assigned to it.
		*--
		LOCAL ix, oEvent
		  m.ix = THIS.GetStateIndex(m.cEvent, .T.)   && Create if not found.
		  m.oEvent = THIS.aEventList[m.ix, 2]
		  m.oEvent.uValue1 = m.uValue
		  IF NOT EMPTY(m.cMethod)
		    m.oEvent.cBroadcastMethod = m.cMethod
		  ENDIF
		  RETURN m.ix
		
	ENDPROC

	PROCEDURE delete		&& Delete a state/event/action and remove all refresh object references.
		LPARAMETERS uState
		*++
		*>>Delete a state/event/action and remove all refresh object references.
		*--
		LOCAL ix
		  * State identifier passed may be a state name, or index value.
		  m.ix = IIF(TYPE('m.uState') = 'N', m.uState, THIS.GetStateIndex(m.uState))
		
		  IF m.ix > 0
		    THIS.aEventList[m.ix, 1] = ''
		    THIS.aEventList[m.ix, 2] = .NULL.
		
		    * If we just deleted the last entry in the array, we can shrink it...
		    DO WHILE m.ix = THIS.nEvents AND ISNULL(THIS.aEventList[m.ix, 2])
		      m.ix = m.ix - 1
		      THIS.nEvents = m.ix
		      DIMENSION THIS.aEventList[m.ix, 2]
		    ENDDO
		  ENDIF
		
	ENDPROC

	PROCEDURE enableinterrupts		&& API library call to monitor system states inside VFP's idle loop.
		LPARAMETERS lEnable, lNotify
		*++
		*>>API library call to monitor system states inside VFP's idle loop.
		* Will enable the callback timer for a single tick when it detects a state change.
		* Timer is disabled at all other times, so there is no performance penalty for using it.
		*--
		  THIS.lCallbacksEnabled = m.lEnable
		  IF m.lEnable
		    #IF VERSION(5) < 800
		      * Enable all events, except for idle.
		      cmSetCallbackTimer(THIS.tmrCallbackTimer, CBR_STATE_CHANGE + CBR_TOGGLE + CBR_MAIN_RESIZE + CBR_WINDOW_CHANGE + CBR_LEFT_MOUSE + CBR_RIGHT_MOUSE)
		    #ELSE
		      * Enable all events, except for idle and Main Window resize (handled directly in VFP8 and later).
		      cmSetCallbackTimer(THIS.tmrCallbackTimer, CBR_STATE_CHANGE + CBR_TOGGLE + CBR_WINDOW_CHANGE + CBR_LEFT_MOUSE + CBR_RIGHT_MOUSE)
		      BINDEVENT(_SCREEN, 'Resize', THIS, 'OnMainWindowResize')
		    #ENDIF
		    IF m.lNotify AND THIS.lEventsOffWarning
		      WAIT CLEAR
		    ENDIF
		  ELSE
		    cmCancelCallbackTimer()
		    #IF VERSION(5) >= 800
		      UNBINDEVENT(_SCREEN, 'Resize', THIS, 'OnMainWindowResize')
		    #ENDIF
		    IF m.lNotify AND THIS.lEventsOffWarning
		      WAIT WINDOW NOWAIT NOCLEAR [State Manager events have been turned off so they don't interfere with debugging.] ;
		                     + CHR(13) + [Toolbars will not refresh while events are turned off.] ;
		                     + CHR(13) + [Use the "Interrupts" button on the Developer Toolbar to re-enable]
		    ENDIF
		  ENDIF
		
		  * Tell any interface controls (like dev toolbar butons) that interrupt state has changed.
		  THIS.SetValue('Interrupts', m.lEnable)
		
	ENDPROC

	PROCEDURE enumforms		&& Enumerate the currently open modeless forms.
		LPARAMETERS nIndex, oForm
		*++
		*>>Enumerate the currently open modeless forms.
		*--
		  RETURN THIS.cmFormCollection.EnumObjects(@m.nIndex, @m.oForm)
		
	ENDPROC

	PROCEDURE enumtoolbars		&& Enumerate the available toolbars (including both open and closed ones).
		LPARAMETERS nIndex, cName, oToolbar
		*++
		*>>Enumerate the available toolbars (including both open and closed ones).
		*--
		  IF EMPTY(m.nIndex) OR m.nIndex < 0
		    m.nIndex = 1
		  ELSE
		    m.nIndex = m.nIndex + 1
		  ENDIF
		
		  IF m.nIndex <= ALEN(THIS.aToolbars, 1)
		    m.cName = THIS.aToolbars[m.nIndex, TOOL_NAME]
		    IF NOT EMPTY(m.cName)
		      m.oToolbar = THIS.FindToolbar(m.cName)  && Returns NULL if not open
		      RETURN m.nIndex
		    ENDIF
		  ENDIF
		
		  m.nIndex = -1    && No more available toolbars
		  RETURN m.nIndex
		
	ENDPROC

	PROCEDURE execute		&& Execute the Method or System menu function associated with the specified action.
		LPARAMETERS uAction, oForm, uParam1, uParam2
		*++
		*>>Execute the Method or System menu function associated with the specified action.
		* If the oForm parameter is a form, use it, otherwise use _SCREEN.Activeform.
		*--
		LOCAL ix, oAction, cMethod, cBar
		  * State identifier passed may be a state name, or index value.
		  m.ix = IIF(VARTYPE(m.uAction) = 'N', m.uAction, THIS.GetStateIndex(m.uAction))
		  IF m.ix > 0
		    m.oAction = THIS.aEventList[m.ix, 2]
		    m.cBar = m.oAction.cFileMenuBar
		    m.cMethod = m.oAction.cExecuteMethod
		  ELSE
		    * If the action name is not defined, default to a method of the same name (If a legal name)
		    IF VARTYPE(m.uAction) = 'C' AND NOT ' ' $ m.uAction
		      m.cMethod = m.uAction
		    ENDIF
		  ENDIF
		
		  IF NOT EMPTY(m.cMethod)
		    IF PCOUNT() = 1 OR ISNULL(m.oForm) OR NOT m.oForm.Baseclass == 'Form'
		      m.oForm = THIS.GetActiveForm()
		    ENDIF
		
		    IF NOT ISNULL(m.oForm)
		      IF PEMSTATUS(m.oForm, m.cMethod, 5)
		        DO CASE
		          CASE PCOUNT() = 3
		            RETURN EVALUATE('m.oForm.' + m.cMethod + '(@m.uParam1)')
		          CASE PCOUNT() = 4
		            RETURN EVALUATE('m.oForm.' + m.cMethod + '(@m.uParam1, @m.uParam2)')
		          OTHERWISE
		            RETURN EVALUATE('m.oForm.' + m.cMethod + '()')
		        ENDCASE
		      ENDIF
		    ELSE
		      * Command window, system window (browse, text editor, etc), or no window is active.
		      IF NOT EMPTY(m.cBar)
		        RETURN SYS(1500, m.cBar, '_MFILE')
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE findform		&& Return an object reference to the first instance found of the specified form. Return .NULL. if none found.
		LPARAMETERS cClass
		*++
		*>>Return an object reference to the first instance found of the specified form. Return .NULL. if none found.
		*--
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  RETURN THIS.cmFormCollection.Find(m.cClass)
		
	ENDPROC

	PROCEDURE findtoolbar		&& Return an object reference to the instance found of the specified toolbar. Return .NULL. if none found.
		LPARAMETERS cClass
		*++
		*>>Return an object reference to the instance found of the specified toolbar. Return .NULL. if none found.
		*--
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  RETURN THIS.cmToolbarCollection.Find(m.cClass)
		
	ENDPROC

	PROCEDURE getactiveform		&& Return a refrerence to the active VFP form, or NULL if no user form is active.
		*++
		*>>Return a refrerence to the active VFP form, or NULL if no user form is active.
		*--
		LOCAL oForm
		  IF TYPE('_SCREEN.activeform.Baseclass') = 'C'
		    m.oForm = _SCREEN.Activeform
		    IF m.oForm.Baseclass = 'Memo'    && Internal class used by VFP for memo editing windows
		      RETURN .NULL.
		    ELSE
		      * Certain activeX controls may be mistakenly referenced by _Screen.Activeform
		      DO WHILE NOT m.oForm.Baseclass == 'Form'
		        m.oForm = m.oForm.Parent
		      ENDDO
		    ENDIF
		
		    * In VFP 7.0, design mode forms will show up in _SCREEN.Activeform
		    IF TYPE('m.oForm.Parent') = 'O' AND m.oForm.Parent.Class == 'Formset'
		      RETURN .NULL.
		    ENDIF
		    RETURN m.oForm
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE getevent		&& Return a refrerence to the specified event object.
		LPARAMETERS uState
		*++
		*>>Return a refrerence to the specified event object.
		*--
		  m.ix = IIF(VARTYPE(m.uState) = 'N', m.uState, THIS.GetStateIndex(m.uState, .F.))
		  RETURN THIS.aEventList[m.ix, 2]
		
	ENDPROC

	PROCEDURE getindex		&& Return the State array index of a state. Allows for optimization of future GetValue() or Execute() calls.
		LPARAMETERS cState
		*++
		*>>Return the State array index of a state. Allows for optimization of future GetValue() or Execute() calls.
		*--
		  RETURN THIS.GetStateIndex(m.cState, .F.)
		
	ENDPROC

	PROCEDURE getstateindex		&& Find the index of the specified state name.
		LPARAMETERS cState, lCreate
		*++
		*>>Find the index of the specified state name. 
		* If not found and lCreate is .T., create a new state with the given name and return its index.
		*--
		LOCAL ix, lExact
		
		  m.lExact = SET('EXACT') == 'ON'
		  SET EXACT ON
		
		  m.ix = ASCAN(THIS.aEventList, PROPER(m.cState))
		  IF m.ix > 0 
		    m.ix = ASUBSCRIPT(THIS.aEventList, m.ix, 1)
		  ELSE
		    IF m.lCreate
		      * Look for an empty slot in array map. If none, then grow the array.
		      m.ix = ASCAN(THIS.aEventList, '')
		      IF m.ix = 0
		        THIS.nEvents = THIS.nEvents + 1
		        m.ix = THIS.nEvents
		        DIMENSION THIS.aEventList[m.ix, 2]
		      ELSE
		        m.ix = ASUBSCRIPT(THIS.aEventList, m.ix, 1)
		      ENDIF
		
		      THIS.aEventList[m.ix, 1] = PROPER(m.cState)
		      THIS.aEventList[m.ix, 2] = CREATEOBJECT('cmEvent')
		      WITH THIS.aEventList[m.ix, 2]
		        .cName = PROPER(m.cState)
		        .cBroadcastMethod = 'Refresh'
		      ENDWITH
		    ENDIF
		  ENDIF
		
		  IF NOT m.lExact
		    SET EXACT OFF
		  ENDIF
		  RETURN m.ix
		
	ENDPROC

	PROCEDURE getvalue		&& Return the current value of a state or action.
		LPARAMETERS uState, oForm, uParam
		*++
		*>>Return the current value of a state or action.
		* Example: DEFINE BAR ... SKIP FOR m.goStateManager.GetValue('System Modal')
		*--
		LOCAL ix, cBar, cMethod, oAction
		  * State identifier passed may be a state name, or index value.
		  m.ix = IIF(VARTYPE(m.uState) = 'N', m.uState, THIS.GetStateIndex(m.uState))
		  IF m.ix > 0
		    m.oAction = THIS.aEventList[m.ix, 2]
		    m.cBar = m.oAction.cFileMenuBar
		    m.cMethod = m.oAction.cExecuteMethod
		    IF EMPTY(m.cMethod)
		      * A simple state/event. Return its current value.
		      RETURN m.oAction.uValue1
		    ENDIF
		  ELSE
		    * If the state/action name is not defined, default to a method of the same name (If a legal name)
		    * This means that undefined names are treated as if they were actions with a same-name method.
		    * If there is a space in the undefined name, then its value is always .F. If the active form
		    * doesnt have the method, the value is also .F.
		    IF VARTYPE(m.uState) = 'C' AND NOT ' ' $ m.uState
		      m.cMethod = m.uState
		    ENDIF
		  ENDIF
		
		  IF NOT EMPTY(m.cMethod)
		    * A system action. Determine the form that the action applies to.
		    IF PCOUNT() = 1 OR ISNULL(m.oForm) OR NOT m.oForm.Baseclass == 'Form'
		      m.oForm = THIS.GetActiveForm()
		    ENDIF
		
		    IF NOT ISNULL(m.oForm)
		      LOCAL cExpr
		      * Determine if the specified action is currently available in the form.
		      IF PEMSTATUS(m.oForm, m.cMethod, 5)
		        IF PEMSTATUS(m.oForm, 'IsEnabled', 5)
		          IF PCOUNT() >= 3
		            RETURN m.oForm.IsEnabled(m.cMethod, @m.uParam)
		          ELSE
		            RETURN m.oForm.IsEnabled(m.cMethod)
		          ENDIF
		        ELSE
		          RETURN .T.
		        ENDIF
		      ENDIF
		    ELSE
		      * System window (browse, text editor, etc), or no window is active.
		      * If action is also linked to a file menu bar, check its enabled flag.
		      IF NOT EMPTY(m.cBar)
		        LOCAL lSkip, cError
		        * For unknown reason (VFP bug?), _MFI_CLOSE cannot be accessed if menu is activated
		        * by pressing and releasing the ALT key. Add a trap to ignore the resulting error.
		        m.cError = ON('ERROR')
		        ON ERROR *
		        TRY 
		           m.lSkip = EMPTY(WONTOP()) OR SKPBAR('_MFILE', EVALUATE(m.cBar))
		        CATCH 
		        FINALLY 
		        ENDTRY    
		        ON ERROR &cError
		        RETURN NOT m.lSkip
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Init
		*++
		* Copyright 1996-2003 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.Name = 'cmStateManager'
		
		  THIS.AddProperty('nEvents', 0)             && Number of defined states & events.
		  THIS.AddProperty('aEventList[1]')          && State and action definition array
		  THIS.AddProperty('aToolbars[1]')           && Array of available toolbars
		  THIS.AddProperty('aRequestors[1]', .NULL.) && List of objects requesting backgroundRefresh.
		  THIS.AddProperty('cFormMenu', '')          && Current form-specific menu program name
		  THIS.AddProperty('nLastWindowHeight', _SCREEN.Height)
		  THIS.AddProperty('nLastWindowWidth', _SCREEN.Width)
		
		  IF SET('DataSession') != 1
		    RELEASE THIS
		    ERROR 'CodeMine State Manager must be created in default datasession'
		    RETURN .F.
		  ENDIF
		
		  * If the application object exists, get a reference to it, and get the sysreg key to use.
		  THIS.oApp = FindGlobalObject('appApplication')
		
		  * And here we cheat a little, and create a public reference to ourself. We do this in order
		  * to make it easy for menu SKIP expressions to access the global states. Skip expressions
		  * as well as the various ON ... commands have no object context associated with them,
		  * so we must resort to PUBLIC references to make sure they are always in scope.
		  PUBLIC goStateManager
		  m.goStateManager = THIS
		
		  * Create default set of pre-defined states & actions
		  THIS.CreateStates()
		
		  * Add form and toolbar object collection managers.
		  THIS.AddNewObject('cmFormCollection', THIS.cCollectionManagerClass)
		  THIS.AddNewObject('cmToolbarCollection', THIS.cCollectionManagerClass)
		
		  * Create callback timer for monitoring internal VFP system states.
		  THIS.AddNewObject('tmrCallbackTimer', 'tmrCallbackTimer')
		  THIS.EnableInterrupts(.T.)
		
		  * Create this special object to act as a CLEAR ALL detection mechanism
		  PUBLIC goCodeMineClearAllHandler
		  m.goCodeMineClearAllHandler = CREATEOBJECT('cmStateCleanup', THIS)
		
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE inspectordetails		&& Display State-manager-specific information in the Codemine object inspector.
		LPARAMETERS oNode, cRoot
		*++
		*>>Display State-manager-specific information in the Codemine object inspector.
		*--
		LOCAL ix, cName, oSubscriber , oString
		
		  m.oString = CreateGlobalObject('cmStringTools')
		  m.oNode.Add(m.cRoot, 4, 'Actions', 'System Actions')
		  FOR ix = 1 TO THIS.nEvents
		    m.oEvent = THIS.aEventList[m.ix, 2]
		    IF NOT ISNULL(m.oEvent) AND NOT EMPTY(m.oEvent.cExecuteMethod)
		      m.cName = 'Action' + LTRIM(STR(m.ix))
		      m.oNode.Add('Actions', 4, m.cName, PROPER(m.oEvent.cName))
		      FOR EACH oSubscriber IN m.oEvent.aSubscribers
		        IF VARTYPE(m.oSubscriber) = 'O'
		          m.oNode.Add(m.cName, 4, , SYS(1272, m.oSubscriber) + '::' + m.oEvent.cBroadcastMethod + '()')
		        ENDIF
		      ENDFOR
		    ENDIF
		  ENDFOR
		
		  m.oNode.Add(m.cRoot, 4, 'States', 'System Events')
		  FOR ix = 1 TO THIS.nEvents
		    m.oEvent = THIS.aEventList[m.ix, 2]
		    IF NOT ISNULL(m.oEvent) AND EMPTY(m.oEvent.cExecuteMethod)
		      m.cName = 'State' + LTRIM(STR(m.ix))
		      m.oNode.Add('States', 4, m.cName, PROPER(m.oEvent.cName) ;
		                          + ' (Value: ' + LTRIM(m.oString.ValueToChar(m.oEvent.uValue1)) + ')')
		      FOR EACH oSubscriber IN m.oEvent.aSubscribers
		        IF VARTYPE(m.oSubscriber) = 'O'
		          m.oNode.Add(m.cName, 4, , SYS(1272, m.oSubscriber) + '::' + m.oEvent.cBroadcastMethod + '()')
		        ENDIF
		      ENDFOR
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE isformopen		&& Return .T. if the specified form is currently open.
		LPARAMETERS cClass
		*++
		*>>Return .T. if the specified form is currently open.
		*--
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  RETURN NOT ISNULL(THIS.cmFormCollection.Find(m.cClass))
		
	ENDPROC

	PROCEDURE istoolbaropen		&& Return .T. if the specified toolbar is currently open.
		LPARAMETERS cClass
		*++
		*>>Return .T. if the specified toolbar is currently open.
		*--
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  RETURN NOT ISNULL(THIS.cmToolbarCollection.Find(m.cClass))
		
	ENDPROC

	PROCEDURE omessage_access		&& Fill in the reference to the message display service object on first reference.
		*++
		*>>Fill in the reference to the message display service object on first reference.
		*--
		  IF ISNULL(THIS.oMessage)
		    THIS.oMessage = FindGlobalObject('cmMessage')
		  ENDIF
		  RETURN THIS.oMessage
		
	ENDPROC

	PROCEDURE onidle		&& Called when VFP enters its Idle loop. Used to trigger background operations.
		*++
		*>>Called when VFP enters its Idle loop. Used to trigger background operations.
		*--
		LOCAL ix, aRequestors[1]
		
		  * Copy requestors list before first call, as background methods may 
		  * make further background refresh requests.
		  ACOPY(THIS.aRequestors, aRequestors)
		
		  * Only one message per request - Once the background refresh message is sent, clear the list.
		  THIS.aRequestors = .NULL.
		  DIMENSION THIS.aRequestors[1]
		
		  * Call BackgroundRefresh() method for each requesting object.
		  FOR ix = 1 TO ALEN(aRequestors)
		    IF NOT ISNULL(aRequestors[m.ix])
		      aRequestors[m.ix].BackgroundRefresh()
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE onleftmouse		&& Called on trapped left mouse clicks. Default code Starts the CM Object Inspector.
		*++
		*>>Called on trapped left mouse clicks. Default code Starts the CM Object Inspector.
		*--
		  LOCAL oTarget, oInspect
		  IF cmKeyModifier() = 3   && Ctrl+Shift
		    m.oTarget = SYS(1270)
		    IF VARTYPE(m.oTarget) = 'O'
		      m.oInspect = THIS.Openform(THIS.cInspectorClass)
		      IF VARTYPE(m.oInspect) = 'O'
		        m.oInspect.Inspect(m.oTarget)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE onmainwindowresize		&& Called when the main VFP window is resized. Default code broadcasts the event to subscribers.
		*++
		*>>Called when the main VFP window is resized. Default code broadcasts the event to subscribers.
		*--
		  THIS.nLastWindowHeight = _SCREEN.Height
		  THIS.nLastWindowWidth = _SCREEN.Width
		
		  RETURN THIS.Broadcast('Main Window Resize')
		
	ENDPROC

	PROCEDURE onrightmouse		&& Called on trapped right mouse clicks
		*++
		*>>Called on trapped right mouse clicks
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE openform		&& Open a single instance of a form, or return reference to an existing instance.
		LPARAMETERS cClass, uArg1, uArg2, uArg3, uArg4, uArg5, uArg6, uArg7
		*++
		*>>Open a single instance of a form, or return reference to an existing instance.
		*--
		LOCAL oForm
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		
		  * Find an instance of the form, or create a new one if none found.
		  m.oForm = THIS.cmFormCollection.Find(m.cClass)
		  IF ISNULL(m.oForm)
		    m.oForm = THIS.cmFormCollection.Add(m.cClass, PCOUNT() - 1, @m.uArg1, @m.uArg2, @m.uArg3, @m.uArg4, @m.uArg5, @m.uArg6, @m.uArg7)
		  ENDIF
		
		  * Show the new or previously-existing instance.
		  IF NOT ISNULL(m.oForm)
		    m.oForm.Show()
		  ENDIF
		  RETURN m.oForm
		
	ENDPROC

	PROCEDURE openformmulti		&& Open a new instance of a form.
		LPARAMETERS cClass, uArg1, uArg2, uArg3, uArg4, uArg5, uArg6, uArg7
		*++
		*>>Open a new instance of a form.
		*--
		LOCAL oForm
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  m.oForm = THIS.cmFormCollection.Add(m.cClass, PCOUNT() - 1, @m.uArg1, @m.uArg2, @m.uArg3, @m.uArg4, @m.uArg5, @m.uArg6, @m.uArg7)
		  IF NOT ISNULL(m.oForm)
		    m.oForm.Show()
		  ENDIF
		  RETURN m.oForm
		
	ENDPROC

	PROCEDURE openmodalform		&& Instantiate a modal form, show it, and return its value if any.
		LPARAMETERS cName, uArg1, uArg2, uArg3, uArg4, uArg5, uArg6, uArg7
		*++
		*>>Instantiate a modal form, show it, and return its value if any.
		* Returns the value from the form's ReturnValue method, if it has one.
		*--
		LOCAL ix, oForm, lReturnValue, cParamlist, cCommand
		
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cName = THIS.oMessage.LocalizeClass(m.cName)
		  ENDIF
		
		  m.cParamlist = ''
		  FOR ix = 1 TO PCOUNT() - 1
		    m.cParamlist = m.cParamlist + ',@m.uArg' + STR(m.ix,1)
		  ENDFOR
		
		  * Instantiate the form, and pass any parameters to it.
		  IF '.scx' $ LOWER(m.cName)
		    m.cCommand = 'DO FORM "' + m.cName + '" NAME m.oForm LINKED NOSHOW'
		    IF NOT EMPTY(m.cParamlist)
		      m.cCommand = m.cCommand + ' WITH ' + STRTRAN(SUBSTR(m.cParamlist, 2), '@', '')
		    ENDIF
		  ELSE
		    m.cCommand = 'm.oForm = CreateLocalized(m.cName' + m.cParamList + ')'
		  ENDIF
		
		  * Create the form object
		  &cCommand
		
		  IF VARTYPE(m.oForm) = 'O'
		    * Remember if it is a modal form with a Codemine style return value method.
		    m.lReturnValue = PEMSTATUS(m.oForm, 'ReturnValue', 5)
		    oForm.Show(1)
		  ENDIF
		
		  * Return value from the form, if any.
		  IF m.lReturnValue AND VARTYPE(m.oForm) = 'O'
		    RETURN m.oForm.ReturnValue()
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE opentoolbar		&& Open an instance of a toolbar, or return reference to an existing instance.
		LPARAMETERS cClass
		*++
		*>>Open an instance of a toolbar, or return reference to an existing instance.
		*--
		LOCAL oTool
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  m.oTool = THIS.cmToolbarCollection.Find(m.cClass)
		  IF ISNULL(m.oTool)
		    m.oTool = THIS.cmToolbarCollection.Add(m.cClass)
		  ENDIF
		  IF NOT ISNULL(m.oTool)
		    m.oTool.Show()
		  ENDIF
		  RETURN m.oTool
		
	ENDPROC

	PROCEDURE refresh		&& For backward compatibility only. Use Broadcast() method instead for new code.
		LPARAMETERS uState
		*++
		*>>For backward compatibility only. Use Broadcast() method instead for new code.
		*--
		  RETURN THIS.Broadcast(@m.uState)
		
	ENDPROC

	PROCEDURE refreshall		&& Broadcast Refresh() events to all subscribers to states/actions matching the specified name prefix.
		LPARAMETERS cState
		*++
		*>>Broadcast Refresh() events to all subscribers to states/actions matching the specified name prefix.
		*--
		LOCAL ix, oEvent, nCursor
		
		  * VFP can set an hourglass while code executes, and sometimes doesnt reset it. We
		  * remember the current cursor, and restore it after.
		  m.nCursor = GetMouseCursor()
		
		  m.cState = IIF(EMPTY(m.cState), '', PROPER(m.cState))
		  FOR ix = 1 TO THIS.nEvents
		    * Only matching events with "Refresh" as their Broadcast method are considered for matches here.
		    IF LEFT(THIS.aEventList[m.ix,1], LEN(m.cState)) == m.cState
		      m.oEvent = THIS.aEventList[m.ix, 2]
		      IF m.oEvent.cBroadcastMethod == 'Refresh'
		        m.oEvent.Broadcast()
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  * Ensure the original cursor image is restored.
		  SetMouseCursor(m.nCursor)
		
	ENDPROC

	PROCEDURE release
		*++
		*>>Release method is called by the global object manager just before we are released.
		*--
		  * Stop watching for system state changes.
		  THIS.EnableInterrupts(.F.)
		
		  * Clear idle callback requestors list.
		  THIS.Clear()
		
		  * Release the public reference to ourself, in preperation for being destroyed.
		  RELEASE m.goStateManager
		  RELEASE THIS
		
	ENDPROC

	PROCEDURE removetoolbar		&& Decrement reference count and remove a toolbar from the list of available toolbars when the count reaches zero.
		LPARAMETERS cName
		*++
		*>>Decrement reference count and remove a toolbar from the list of available toolbars when the count reaches zero.
		*--
		LOCAL ix, lOpen, cExact
		
		  m.cExact = SET('EXACT')
		  SET EXACT ON
		
		  m.cName = UPPER(m.cName)
		  m.ix = ASCAN(THIS.aToolbars, m.cName)
		  IF m.ix > 0
		    m.ix = ASUBSCRIPT(THIS.aToolbars, m.ix, 1)
		    THIS.aToolbars[m.ix, TOOL_REFCOUNT] = THIS.aToolbars[m.ix, TOOL_REFCOUNT] - 1
		    IF THIS.aToolbars[m.ix, TOOL_REFCOUNT] = 0
		      * Update open memory if enabled for this toolbar
		      m.lOpen = THIS.IsToolbarOpen(m.cName)
		      IF THIS.aToolbars[m.ix, TOOL_MEMORY] AND NOT ISNULL(THIS.oApp)
		        cmRegSetInteger(HKEY_CURRENT_USER, THIS.oApp.cSysRegRoot + '\Toolbars\' + LOWER(m.cName) + '\Open', IIF(m.lOpen, 1, 0))
		      ENDIF
		
		      * Close the toolbar if it is open
		      IF m.lOpen
		        THIS.CloseToolbar(m.cName)
		      ENDIF
		
		      * And remove it from list of available toolbars.
		      ADEL(THIS.aToolbars, m.ix)
		      IF ALEN(THIS.aToolbars, 1) > 1
		        DIMENSION THIS.aToolbars[ALEN(THIS.aToolbars, 1) - 1, TOOL_NCOLS]
		      ELSE
		        THIS.aToolbars[1, TOOL_NAME] = ''
		      ENDIF
		    ENDIF
		  ENDIF
		
		  IF m.cExact = 'OFF'
		    SET EXACT OFF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE requestbackgroundrefresh		&& Add an object to list of objects to receive the next background refresh event message.
		LPARAMETERS oRequestor
		*++
		*>>Add an object to list of objects to receive the next background refresh event message.
		*--
		  IF NOT ISNULL(m.oRequestor)
		    * Expand the array as needed to hold new entry.
		    IF NOT ISNULL(THIS.aRequestors[1])
		      DIMENSION THIS.aRequestors[ALEN(THIS.aRequestors,1) + 1]
		    ENDIF
		    THIS.aRequestors[ALEN(THIS.aRequestors)] = m.oRequestor
		
		    * Set trap to call OnIdle handler next idle.
		    cmTriggerCallback(CBR_IDLE)
		  ENDIF
		
	ENDPROC

	PROCEDURE requestrefresh		&& Register an object (usually a toolbar button) to refresh when a state/action changes.
		LPARAMETERS uEvent, oObject
		*++
		*>>Register an object (usually a toolbar button) to refresh when a state/action changes.
		* Create the state if it does not already exist.
		*--
		LOCAL ix, oForm
		
		  m.ix = IIF(TYPE('m.uEvent') = 'N', m.uEvent, THIS.GetStateIndex(m.uEvent, .T.))
		  THIS.aEventList[m.ix, 2].Subscribe(m.oObject, 'Refresh', .T.)
		
		  * If it is a form action with an associated system action, add requesting
		  * object to the System Edit State refresh list too, but only when in a toolbar.
		  * This helps keep the toolbar buttons refreshed properly while system windows are active.
		  IF NOT EMPTY(THIS.aEventList[m.ix, 2].cFileMenuBar)
		    * Find a reference to the topmost container for the requesting object.
		    m.oForm = m.oObject
		    DO WHILE TYPE('m.oForm.Parent') = 'O'
		      m.oForm = m.oForm.Parent
		    ENDDO
		    IF m.oForm.Baseclass == 'Toolbar'
		      THIS.SubscribeNoInit('System Edit State', m.oObject, 'Refresh')
		    ENDIF
		  ENDIF
		  RETURN m.ix
		
	ENDPROC

	PROCEDURE setformmenu		&& Set a form-specific context menu pad on the system menu bar.
		LPARAMETERS cMenu, lForceReload
		*++
		*>>Set a form-specific context menu pad on the system menu bar.
		*--
		LOCAL cMenuName
		  IF EMPTY(m.cMenu)
		    m.cMenu = ''
		  ELSE
		    m.cMenu = UPPER(m.cMenu)
		    IF NOT '.' $ m.cMenu
		      m.cMenu = m.cMenu + '.MPR'
		    ENDIF
		  ENDIF
		
		  IF NOT m.cMenu == THIS.cFormMenu AND NOT EMPTY(THIS.cFormMenu)
		    * Pad and popup name must match program name in order for this all to work correctly.
		    * We can't use Push/Pop menu due to VFP bugs that cause internal corruption.
		    m.cMenuName = SUBSTR(THIS.cFormMenu, RAT('\', THIS.cFormMenu) + 1)
		    IF '.' $ m.cMenuName
		      m.cMenuName = LEFT(m.cMenuName, RAT('.', m.cMenuName) - 1)
		    ENDIF
		    RELEASE PAD (m.cMenuName) OF _MSYSMENU       && Clear the old form-specific menu pad
		    RELEASE POPUP (m.cMenuName) EXTENDED         && and the menu definition with all related ON commands
		  ENDIF
		
		  IF NOT m.cMenu == THIS.cFormMenu OR m.lForceReload
		    IF NOT EMPTY(m.cMenu)
		      DO (m.cMenu)            && Put up the new form menu
		    ENDIF
		    THIS.cFormMenu = m.cMenu
		  ENDIF
		
	ENDPROC

	PROCEDURE setvalue		&& Set the value of a given state. Create the state if it doesn't exist yet.
		LPARAMETERS uState, uValue, lForce
		*++
		*>>Set the value of a given state. Create the state if it doesn't exist yet.
		*--
		LOCAL ix, oEvent, uOldValue
		
		  * State identifier passed may be a state name, or index value.
		  m.ix = IIF(VARTYPE(m.uState) = 'N', m.uState, THIS.GetStateIndex(m.uState, .T.))
		  m.oEvent = THIS.aEventList[m.ix, 2]
		
		  m.uOldValue = m.oEvent.uValue1
		  m.oEvent.uValue1 = m.uValue
		
		  * Send a refresh message to each object requesting one for this state.
		  * Only send refresh messqage if the new value is different from the old.
		  IF m.lForce OR TYPE('m.uOldValue') != TYPE('m.uValue') OR NOT m.uOldValue == m.uValue
		    m.oEvent.Broadcast()
		  ENDIF
		  RETURN m.uValue
		
	ENDPROC

	PROCEDURE subscribe		&& Register an object to recieve a specified message when a specified event occurs.
		LPARAMETERS uEvent, oSubscriber, cMethod
		*++
		*>>Register an object to recieve a specified message when a specified event occurs.
		* Create the event name if it does not already exist.
		*--
		LOCAL nEvent
		
		  * State identifier passed may be a state name, or index value.
		  m.nEvent = IIF(VARTYPE(m.uEvent) = 'N', m.uEvent, THIS.GetStateIndex(m.uEvent, .T.))
		  THIS.aEventList[m.nEvent, 2].Subscribe(m.oSubscriber, m.cMethod)
		  RETURN m.nEvent
		
	ENDPROC

	PROCEDURE subscribenoinit		&& Register an object to recieve a message when a specified event occurs.
		LPARAMETERS uEvent, oSubscriber, cMethod
		*++
		*>>Register an object to recieve a message when a specified event occurs.
		* Create the event name if it does not already exist.
		*--
		LOCAL nEvent
		  * State identifier passed may be a state name, or index value.
		  m.nEvent = IIF(VARTYPE(m.uEvent) = 'N', m.uEvent, THIS.GetStateIndex(m.uEvent, .T.))
		  THIS.aEventList[m.nEvent, 2].Subscribe(m.oSubscriber, m.cMethod, .T.)
		  RETURN m.nEvent
		
	ENDPROC

	PROCEDURE unsubscribe		&& UnSubscribe an object from the subscriber list for the specified event.
		LPARAMETERS uEvent, oObject
		*++
		*>>UnSubscribe an object from the subscriber list for the specified event.
		*--
		LOCAL ix
		
		  IF EMPTY(m.uEvent) OR (VARTYPE(m.uEvent) = 'C' AND m.uEvent = '*')
		    * Unsubcribe the object from all events/actions
		    FOR ix = 1 TO THIS.nEvents
		      IF NOT ISNULL(THIS.aEventList[m.ix, 2])
		        THIS.aEventList[m.ix, 2].Unsubscribe(m.oObject)
		      ENDIF
		    ENDFOR
		  ELSE
		    * Unsubcribe the object from one particular event
		    m.ix = IIF(VARTYPE(m.uEvent) = 'N', m.uEvent, THIS.GetStateIndex(m.uEvent))
		    IF m.ix > 0 AND NOT ISNULL(THIS.aEventList[m.ix, 2])
		      THIS.aEventList[m.ix, 2].Unsubscribe(m.oObject)
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tmrcallbacktimer AS timer 		&& Codemine state manager callback timer
 	*< CLASSDATA: Baseclass="timer" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: nlasthit
		*p: nlastwarning
		*p: nreasonmask
	*</DefinedPropArrayMethod>

	PROTECTED nlastwarning
	Enabled = .F.
	Interval = 200
	Name = "tmrcallbacktimer"
	nlasthit = 0
	nlastwarning = 0
	nreasonmask = 0
	
	PROCEDURE Init
		  DECLARE INTEGER GetCursor IN user32 AS GetMouseCursor
		  DECLARE INTEGER SetCursor IN user32 AS SetMouseCursor INTEGER nHandle
		
	ENDPROC

	PROCEDURE Timer
		*++
		* Timer event activated when FLL detexts that a monitored event has occured.
		*--
		LOCAL nCursor
		
		  * VFP can set an hourglass while code executes, and sometimes doesnt reset it. We
		  * remember the current cursor, and restore it after.
		  m.nCursor = GetMouseCursor()
		  THIS.Enabled = .F.
		  THIS.Reset()
		
		  #IF EVALUATION_ONLY  && .T. for evaluation version, .F. otherwise
		    * For evaluation copies of the framework, this code displays a dialog every few minutes 
		    * when running as a standalone EXE.
		    IF VERSION(2) == 0 AND (SECONDS() - THIS.nLastWarning) > (60*10)   && Message every 10 minutes
		      LOCAL oMessage
		      m.oMessage = FindGlobalObject('cmMessage')
		      m.oMessage.Dialog(MSG_DIALOG_CONFIRM_OK, MSG_SEVERITY_WARNING, 'This applicaiton is built with an evalution copy of CodeMine, and is not licensed for distribution. It may be used for evaluation only.', ;
		                        'To purchase a full version of CodeMine with no-royalty distribution license, visit www.codemine.com or call USA 207-942-4112', 'For Evaluation Only')
		      THIS.nLastWarning = SECONDS()
		    ENDIF
		  #ENDIF
		
		  IF NOT EMPTY(THIS.nReasonMask) AND (SECONDS() - THIS.nLasthit > 0.05 OR SECONDS() < THIS.nLasthit)
		    THIS.nLasthit = SECONDS()
		    IF NOT EMPTY(BITAND(THIS.nReasonMask, CBR_STATE_CHANGE))  && System edit menu states have changed
		      * Actual value of this state is not important, just signal a change has occurred.
		      * Details are determined by the various system menu option enable states.
		      THIS.Parent.Broadcast('System Edit State')
		    ENDIF
		
		    IF NOT EMPTY(BITAND(THIS.nReasonMask, CBR_WINDOW_CHANGE)) && Active Window changed
		      * Set system modal state to true if a modal form has focus. Do this first
		      * on window changes, because control may query the value during refresh.
		
		      * Force modal setting if WONTOP() is empty and "Print Preview" toolbar exists. This usually
		      * means that the print preview window is open, and is the only way I can find (short of 
		      * FLL file) to detect when the print preview is open.
		      THIS.Parent.SetValue('System Modal', ;
		         (EMPTY(WONTOP()) AND WEXIST('Print Preview')) ;
		            OR (TYPE('_SCREEN.Activeform.WindowType') = 'N' AND _SCREEN.Activeform.WindowType = 1 AND TYPE('_SCREEN.Activeform.Parent') = 'U' ))
		
		      * Force refresh of system edit state on new window, if not already done.
		      IF EMPTY(BITAND(THIS.nReasonMask, CBR_STATE_CHANGE))
		        THIS.Parent.Broadcast('System Edit State')
		      ENDIF
		
		      * Window Change state value is true whenever a form is open, and refreshes whenever window changes.
		      THIS.Parent.SetValue('Window Change', TYPE('_SCREEN.Activeform.WindowType') = 'N', .T.)
		    ENDIF
		
		    IF NOT EMPTY(BITAND(THIS.nReasonMask, CBR_TOGGLE))        && Insmode/Caps/numlock changed
		      THIS.Parent.Broadcast('System Key Toggle')
		    ENDIF
		
		    IF NOT EMPTY(BITAND(THIS.nReasonMask, CBR_MAIN_RESIZE))   && Main window resize
		      THIS.Parent.OnMainWindowResize()
		    ENDIF
		
		    IF NOT EMPTY(BITAND(THIS.nReasonMask, CBR_IDLE))          && Entered Idle loop
		      THIS.Parent.OnIdle()
		    ENDIF
		
		    IF NOT EMPTY(BITAND(THIS.nReasonMask, CBR_LEFT_MOUSE))    && Left Mousetrap
		      THIS.Parent.OnLeftMouse()
		    ENDIF
		
		    IF NOT EMPTY(BITAND(THIS.nReasonMask, CBR_RIGHT_MOUSE))   && Right Mousetrap
		      THIS.Parent.OnRightMouse()
		    ENDIF
		
		    * Ensure the original cursor image is restored.
		    SetMouseCursor(m.nCursor)
		  ENDIF
		
		  * Clear reason mask, which will re-enable callback triggers by the API.
		  THIS.nReasonMask = 0
		
	ENDPROC

ENDDEFINE
