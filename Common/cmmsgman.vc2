*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmmsgman.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cmhelpvalue AS cmdatatransport OF "cmdataa.vcx" 		&& Pack and unpack Rich text Help key values.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: deletetext		&& Delete all message text for the specified language.
		*m: gettext		&& Get short message text for specified language.
		*m: hastranslation		&& Return .T. if the key has an explicit translation for the specified field & language.
		*m: settext		&& Set the message text for the specified language.
		*p: clinks
		*p: ncount
		*p: nhelptype
		*p: omessage
		*a: atext[1,4]
	*</DefinedPropArrayMethod>

	clinks = 
	Name = "cmhelpvalue"
	ncount = 0
	nhelptype = 0
	omessage = .NULL.
	
	PROCEDURE deletetext		&& Delete all message text for the specified language.
		LPARAMETERS cLanguageID
		*++
		*>>Delete all message text for the specified language.
		*--
		LOCAL ix
		  FOR ix = 1 TO THIS.nCount
		    IF THIS.aText[m.ix, MSGVAL_LANG_ID] = m.cLanguageID
		      =ADEL(THIS.aText, m.ix)
		      THIS.nCount = THIS.nCount - 1
		      IF THIS.nCount > 0
		        DIMENSION THIS.aText[THIS.nCount, 4]
		      ENDIF
		      EXIT
		    ENDIF
		  ENDFOR
		  RETURN .T.
		
	ENDPROC

	PROCEDURE gather
		*++
		*>>Gather all the type specific value parameters into one string field.
		*--
		LOCAL ix, cValue, cText
		
		  * Store help key type and links
		  m.cValue = STR(THIS.nHelpType, 2) + CR_LF + THIS.cLinks + CR_LF + CR_LF + STR(THIS.nCount, 2) + CR_LF
		
		  * Now store the statusbar and tip text for each language.
		  FOR ix = 1 TO THIS.nCount
		    m.cValue = m.cValue + THIS.aText[m.ix, MSGVAL_LANG_ID] + CR_LF ;
		             + THIS.aText[m.ix, MSGVAL_FIELD_SHORT] + CR_LF + THIS.aText[m.ix, MSGVAL_FIELD_TIP] + CR_LF
		  ENDFOR
		
		  * Followed by rich text description for each language, as a counted string.
		  FOR ix = 1 TO THIS.nCount
		    m.cValue = m.cValue + STR(LEN(THIS.aText[m.ix, MSGVAL_FIELD_RICH])) ;
		             + CR_LF + THIS.aText[m.ix, MSGVAL_FIELD_RICH] + CR_LF
		  ENDFOR
		  RETURN m.cValue
		
	ENDPROC

	PROCEDURE gettext		&& Get short message text for specified language.
		LPARAMETERS nField, nLangIx, cLanguageID
		*++
		*>>Get short message text for specified language.
		*--
		LOCAL ix
		
		  IF EMPTY(m.cLanguageID)  && If ID is empty, language index must be specified.
		    IF NOT EMPTY(m.nLangIx)
		      m.cLanguageID = THIS.oMessage.aLanguages[m.nLangIx, LANGUAGE_ID]
		    ENDIF
		  ENDIF
		
		  IF NOT EMPTY(m.cLanguageID)
		    FOR ix = 1 TO THIS.nCount
		      IF THIS.aText[m.ix, MSGVAL_LANG_ID] == m.cLanguageID
		        IF LEN(THIS.aText[m.ix, m.nField]) > 0
		          RETURN THIS.aText[m.ix, m.nField]
		        ELSE
		          EXIT
		        ENDIF
		      ENDIF
		    ENDFOR
		
		    * If no translation found, try parent language, if any.
		    IF THIS.nCount > 1
		      IF EMPTY(m.nLangIx)
		        m.nLangIx = ASCAN(THIS.oMessage.aLanguages, m.cLanguageID)
		        m.nLangIx = ASUBSCRIPT(THIS.oMessage.aLanguages, m.nLangIx, 1)
		      ENDIF
		      m.nLangIx = THIS.oMessage.aLanguages[m.nLangIx, LANGUAGE_PARENT]
		      IF NOT EMPTY(m.nLangIx)
		        RETURN THIS.GetText(m.nField, m.nLangIx)
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN THIS.aText[1, m.nField]
		
	ENDPROC

	PROCEDURE hastranslation		&& Return .T. if the key has an explicit translation for the specified field & language.
		LPARAMETERS cLanguageID, nField
		*++
		*>>Return .T. if the key has an explicit translation for the specified field & language.
		*--
		LOCAL ix
		  FOR ix = 1 TO THIS.nCount
		    IF THIS.aText[m.ix, MSGVAL_LANG_ID] == m.cLanguageID
		      * If optional item parameter is specified, must have an explicit translation for that item.
		      RETURN PCOUNT() = 1 OR LEN(THIS.aText[m.ix, m.nField]) > 0
		    ENDIF
		  ENDFOR
		  RETURN THIS.nCount = 0    && A new value with no default translations returns .T. also
		
	ENDPROC

	PROCEDURE Init
		  * Load reference to message object, for access to language
		  THIS.oMessage = FindGlobalObject('cmMessage')
		
	ENDPROC

	PROCEDURE scatter
		LPARAMETERS cValue, lGetRich
		*++
		*>>Break the packed help key value string into its individual components.
		*--
		LOCAL ix, nLength, nMemoWidth
		
		  _MLINE = 0
		  THIS.nCount = 0
		  IF EMPTY(m.cValue)
		    THIS.nHelpType = 0
		    THIS.cLinks = ''
		    DIMENSION THIS.aText[1, 4]
		    THIS.aText = ''
		  ELSE
		    m.nMemoWidth = SET('MEMOWIDTH')
		    SET MEMOWIDTH TO 1024
		
		    THIS.nHelpType = VAL(MLINE(m.cValue, 1, _MLINE))  && Only one type so far
		    THIS.cLinks = MLINE(m.cValue, 1, _MLINE)
		    =MLINE(m.cValue, 1, _MLINE)                       && Placeholder for expansion
		    THIS.nCount = VAL(MLINE(m.cValue, 1, _MLINE))     && Number of translations for each compoment
		
		    IF THIS.nCount > 0
		      * Get all the statusbar and tooltip strings.
		      DIMENSION THIS.aText[THIS.nCount, 4]
		      FOR ix = 1 TO THIS.nCount
		        THIS.aText[m.ix, MSGVAL_LANG_ID] = MLINE(m.cValue, 1, _MLINE)    && Language ID
		
		        * Parse out statusbar and tooltip text as appropriate (no multiline support on these)
		        THIS.aText[m.ix, MSGVAL_FIELD_SHORT] = MLINE(m.cValue, 1, _MLINE)    && statusbar text
		        THIS.aText[m.ix, MSGVAL_FIELD_TIP] = MLINE(m.cValue, 1, _MLINE)    && Tooltip text
		        THIS.aText[m.ix, MSGVAL_FIELD_RICH] = ''
		      ENDFOR
		
		      * Rich text string may be very long, so for effieciency we only load them when requested.
		      IF m.lGetRich
		        FOR ix = 1 TO THIS.nCount
		          * Rich text Strings are stored as length on one line, then text to allow line breaks in text.
		          m.nLength = VAL(MLINE(m.cValue, 1, _MLINE))
		          THIS.aText[m.ix, MSGVAL_FIELD_RICH] = SUBSTR(m.cValue, _MLINE + 2, m.nLength)
		          _MLINE = _MLINE + m.nLength + 2
		        ENDFOR
		      ENDIF
		    ENDIF
		    SET MEMOWIDTH TO (m.nMemoWidth)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE settext		&& Set the message text for the specified language.
		LPARAMETERS cLanguageID, cText, cTipText, cRichtext
		*++
		*>>Set the message text for the specified language.
		*--
		LOCAL ix
		  FOR ix = 1 TO THIS.nCount
		    IF THIS.aText[m.ix, MSGVAL_LANG_ID] = m.cLanguageID
		      EXIT
		    ENDIF
		  ENDFOR
		
		  IF m.ix > THIS.nCount
		    THIS.nCount = m.ix
		    DIMENSION THIS.aText[m.ix, 4]
		    THIS.aText[m.ix, 1] = m.cLanguageID
		    THIS.aText[m.ix, 2] = ''
		    THIS.aText[m.ix, 3] = ''
		    THIS.aText[m.ix, 4] = ''
		  ENDIF
		
		  IF TYPE('m.cText') = 'C'
		    THIS.aText[m.ix, MSGVAL_FIELD_SHORT] = m.cText
		  ENDIF
		  IF TYPE('m.cTipText') = 'C'
		    THIS.aText[m.ix, MSGVAL_FIELD_TIP] = m.cTipText
		  ENDIF
		  IF TYPE('m.cRichText') = 'C'
		    THIS.aText[m.ix, MSGVAL_FIELD_RICH] = m.cRichText
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmlanguagevalue AS cmdatatransport OF "cmdataa.vcx" 		&& Pack and unpack Language key values.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: ccurrencyformat
		*p: ccurrencysymbol
		*p: cdateformat
		*p: cdecimal
		*p: clanguageid
		*p: clongmonth
		*p: cmark
		*p: cname
		*p: cparentlanguageid
		*p: cseparator
		*p: cshortmonth
		*p: lcentury
		*p: lsysformat
		*p: ndecimals
		*p: nhourformat
	*</DefinedPropArrayMethod>

	ccurrencyformat = 
	ccurrencysymbol = 
	cdateformat = 
	cdecimal = 
	clanguageid = 
	clongmonth = 
	cmark = 
	cname = Language
	cparentlanguageid = 
	cseparator = 
	cshortmonth = 
	lcentury = .T.
	lsysformat = .F.
	Name = "cmlanguagevalue"
	ndecimals = 2
	nhourformat = 12
	
	PROCEDURE gather
		*++
		*>>Gather all the type specific value parameters into one string field.
		*--
		  * Assign a language ID if none is present (ie a new language definition).
		  IF LEN(THIS.cLanguageID) = 0
		    * Use a hash value. Language ID must remain constant even if the key is later renamed.
		    THIS.cLanguageID = SYS(2007, UPPER(ALLTRIM(THIS.cName)))
		  ENDIF
		
		  RETURN THIS.cLanguageID + CR_LF ;
		         + IIF(THIS.lSysFormat, 'SysFormat', '') + CR_LF ;
		         + THIS.cShortMonth + CR_LF ;
		         + THIS.cLongMonth + CR_LF ;
		         + THIS.cDateFormat + CR_LF ;
		         + THIS.cMark + CR_LF ;
		         + LTRIM(STR(THIS.nHourFormat, 2)) + CR_LF ;
		         + THIS.cCurrencyFormat + CR_LF ;
		         + THIS.cCurrencySymbol + CR_LF ;
		         + THIS.cDecimal + CR_LF ;
		         + THIS.cSeparator + CR_LF ;
		         + IIF(THIS.lCentury, 'Century', '') + CR_LF ;
		         + THIS.cParentLanguageID + CR_LF ;
		         + LTRIM(STR(THIS.nDecimals, 2)) + CR_LF
		
	ENDPROC

	PROCEDURE scatter
		LPARAMETERS cValue, cName
		*++
		*>>Break the compound value string into its individual components.
		* Returns False if user data is corrupted.
		*--
		LOCAL ix, nMemoWidth
		
		  _MLINE = 0
		  THIS.cName = m.cName
		  IF EMPTY(m.cValue)
		    THIS.cLanguageID = ''
		
		    * Get default settings from current system values.
		    THIS.lSysFormat = SET('SYSFORM') = 'ON'
		    THIS.cShortMonth = ''
		    THIS.cLongMonth = ''
		    FOR ix = 1 TO 12
		      m.cMonth = CMONTH(DATE(2000, m.ix, 1))
		      THIS.cShortMonth = THIS.cShortMonth + LEFT(m.cMonth, 3) + IIF(m.ix < 12, ',', '')
		      THIS.cLongMonth = THIS.cLongMonth + m.cMonth + IIF(m.ix < 12, ',', '')
		    ENDFOR
		
		    DO CASE
		      CASE INLIST(SET('Date'), 'AMERICAN','USA','MYD')
		        THIS.cDateFormat = 'MDY'
		      CASE INLIST(SET('Date'), 'JAPAN','ANSI','YMD')
		        THIS.cDateFormat = 'YMD'
		      OTHERWISE
		        THIS.cDateFormat = 'DMY'
		    ENDCASE
		
		    THIS.cMark = IIF(EMPTY(SET('MARK')), '/', SET('MARK'))
		    THIS.nHourFormat = SET('HOUR')
		    THIS.cCurrencyFormat = PROPER(SET('Currency'))
		    THIS.cCurrencySymbol = SET('Currency', 1)
		    THIS.cDecimal = SET('POINT')
		    THIS.cSeparator = SET('SEPARATOR')
		    THIS.lCentury = .T.
		    THIS.nDecimals = SET('DECIMALS')
		  ELSE
		    m.nMemoWidth = SET('MEMOWIDTH')
		    SET MEMOWIDTH TO 512
		
		    THIS.cLanguageID = MLINE(m.cValue, 1, _MLINE)
		    THIS.lSysFormat = NOT EMPTY(MLINE(m.cValue, 1, _MLINE))
		    THIS.cShortMonth = MLINE(m.cValue, 1, _MLINE)
		    THIS.cLongMonth = MLINE(m.cValue, 1, _MLINE)
		    THIS.cDateFormat = MLINE(m.cValue, 1, _MLINE)
		    THIS.cMark = MLINE(m.cValue, 1, _MLINE)
		    THIS.nHourFormat = VAL(MLINE(m.cValue, 1, _MLINE))
		    THIS.cCurrencyFormat = MLINE(m.cValue, 1, _MLINE)
		    THIS.cCurrencySymbol = MLINE(m.cValue, 1, _MLINE)
		    THIS.cDecimal = MLINE(m.cValue, 1, _MLINE)
		    THIS.cSeparator = MLINE(m.cValue, 1, _MLINE)
		    THIS.lCentury = NOT EMPTY(MLINE(m.cValue, 1, _MLINE))
		    THIS.cParentLanguageID = MLINE(m.cValue, 1, _MLINE)
		    THIS.nDecimals = VAL(MLINE(m.cValue, 1, _MLINE))
		    IF EMPTY(THIS.nDecimals)
		      THIS.nDecimals = SET('DECIMALS')
		    ENDIF
		    SET MEMOWIDTH TO (m.nMemoWidth)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmmessage AS cmserviceabstract OF "cmdataa.vcx" 		&& CodeMine Multi-lingual help and error message manager V7.0
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: beginmultimessage		&& Begin message batching to display all following messages in a single dialog.
		*m: confirm		&& Display a formatted message in a Yes/No dialog. Returns .T. or .F., or .NULL.
		*m: confirmync		&& Display a formatted message in a Yes/No/Cancel dialog. Returns .T. or .F., or .NULL.
		*m: dialog		&& Display a formatted message in the specified dialog type, with the specified icon & title.
		*m: display		&& Display a formatted message with dialog specified in message key.
		*m: displayhelp		&& Display modeless context help dialog
		*m: displaylastmessage		&& Display the message stored in the cFormattedText property, in the appropriate dialog.
		*m: endmultimessage		&& Ends message batching, and if one or more messages have been queued, display them all.
		*m: fatalerror		&& Issued when a fatal coding error occurs, displays stack dump and "Cancel" button.
		*m: flashmessage		&& Display a temporary formatted modeless WAIT WINDOW message, if a UI is present.
		*m: format		&& Replace embedded string parameters with their expanded value.
		*m: getlastmessage		&& Return info about the last message displayed.
		*m: gettext		&& Display message dialog and accept a text string in reply.
		*m: inform		&& Display a formatted informational message and return .F.
		*m: lautotab_assign		&& Keep the SET CONFIRM setting for the default data session in sync with the lAutoTab property.
		*m: loadlocalizedlibraries		&& Loads the list of localized VCX libraries specified in the cLocalizedLibraryList property of appSettings object.
		*m: localize		&& Translate a short string into the current language.
		*m: localizeclass		&& If there is a localized version of the specified class, return its name.
		*m: logerror		&& Make an event log entry for an unhandled fatal error.
		*m: logmessage
		*m: logverbose
		*m: luserinterfaceavailable_access		&& Determine if a user interface is available for this application.
		*m: progressbar		&& Display a progress bar. Returns object reference to the bar.
		*m: progressbarex		&& Display a progress bar with two message lines. Returns object reference to the bar.
		*m: registryupdate		&& Initialize exposed properties from stored registry values. Called on Init and whenever the app registry is changed.
		*m: setlanguage		&& Set the current language, and associated localization settings.
		*m: setlastmessage		&& Format and store the last message string, but do not display it.
		*m: setlastmessageex		&& Format and store the last message string & optional description text, but do not display it.
		*m: severe		&& Display a formatted severe error message and return .F.
		*m: statusclear		&& Clear the last status message display.
		*m: statusmessage		&& Display a formatted modeless informational message, if a UI is present. Message stays visible until StatusClear() is called.
		*m: translate		&& Translate a system message identifier into the current language.
		*m: translatebar		&& Translate a menu bar identifier into the current language.
		*m: translatehelp		&& Translate a Help message or Richtext identifier into the current language.
		*m: translatestring		&& Translate a simple text string key into the current language.
		*m: warning		&& Display a formatted warning message and return .F.
		*m: _getcallstack
		*m: _initlanguages		&& Initialize internal language meta-data based on current language definitions in app registry.
		*m: _loadmessage		&& Lookup a message key, and load its values into a Message value object.
		*p: cerrortitle		&& Default caption for severe error dialogs.
		*p: cfatalerrorsound		&& Name of WAV file to play when the fatal error dialog is displayed. Set to 'Default' for Windows default beep, or empty for no sound.
		*p: cfrmconfirm		&& Default class for message and confirmation dialogs
		*p: cfrmfatalerror		&& Default form class for the fatal error dialog
		*p: cfrmgettext		&& Default class for get-text-string dialog
		*p: cfrmhelp		&& Default form class for help message display
		*p: cfrmmultimessage		&& Default class for multi-message dialog
		*p: cfrmprogress		&& Default class for single text line Progress bars
		*p: cfrmprogressex		&& Default class for double text line Progress bars
		*p: cinfotitle		&& Default caption for informational dialogs.
		*p: cquestiontitle		&& Default caption for question dialogs.
		*p: ctextlog
		*p: ctexttitle		&& Default caption for the Enter Text dialog.
		*p: cversion		&& Version string of this class
		*p: cwarningtitle		&& Default caption for Warning dialogs.
		*p: lautotab		&& Determines whether or not focus leaves a textbox when it is full.
		*p: lbeep		&& If .T. then Beep on errors
		*p: lflashinform		&& If .T. then Flash informational msgs in a WAIT WINDOW NOWAIT display.
		*p: llogerrors		&& Record all unhandled system errors in the system event log (requires security component)
		*p: lmultimessage		&& Set to .T. to enable message batching capabilities
		*p: luserinterfaceavailable		&& Set to .F. to prevent display of messages. Useful for server components that have no user interface.
		*p: lusestatusbar		&& Set to .T. to use the VFP status bar for StatusMessage() displays, or .F. to display via WAIT WINDOW commands.
		*p: lusestatusbarprogress		&& If .T. then use status bar for standard progress bar display.
		*p: lusesystemdialog		&& Use MESSSAGEBOX() dialog in cases where ther is no explaination text.
		*p: lverboselog
		*p: ncentury		&& Current century used in calculating default century values
		*p: nflashduration		&& Minimum duration of Wait Window display.
		*p: nrollover		&& Century rollover value
	*</DefinedPropArrayMethod>

	cerrortitle = Severe Error		&& Default caption for severe error dialogs.
	cfatalerrorsound = Error.wav		&& Name of WAV file to play when the fatal error dialog is displayed. Set to 'Default' for Windows default beep, or empty for no sound.
	cfrmconfirm = frmConfirm		&& Default class for message and confirmation dialogs
	cfrmfatalerror = frmSWIError		&& Default form class for the fatal error dialog
	cfrmgettext = frmGetText		&& Default class for get-text-string dialog
	cfrmhelp = frmDisplayHelp		&& Default form class for help message display
	cfrmmultimessage = frmMultiMessage		&& Default class for multi-message dialog
	cfrmprogress = frmProgress		&& Default class for single text line Progress bars
	cfrmprogressex = frmProgressEx		&& Default class for double text line Progress bars
	cinfotitle = Information		&& Default caption for informational dialogs.
	cquestiontitle = Confirmation Required		&& Default caption for question dialogs.
	ctextlog = 
	ctexttitle = Enter Text		&& Default caption for the Enter Text dialog.
	cversion = 7.0.0		&& Version string of this class
	cwarningtitle = Warning		&& Default caption for Warning dialogs.
	lautotab = .T.		&& Determines whether or not focus leaves a textbox when it is full.
	lbeep = .T.		&& If .T. then Beep on errors
	lflashinform = .T.		&& If .T. then Flash informational msgs in a WAIT WINDOW NOWAIT display.
	llogerrors = .T.		&& Record all unhandled system errors in the system event log (requires security component)
	lmultimessage = .T.		&& Set to .T. to enable message batching capabilities
	luserinterfaceavailable = .T.		&& Set to .F. to prevent display of messages. Useful for server components that have no user interface.
	lusestatusbar = .F.		&& Set to .T. to use the VFP status bar for StatusMessage() displays, or .F. to display via WAIT WINDOW commands.
	lusestatusbarprogress = .F.		&& If .T. then use status bar for standard progress bar display.
	lusesystemdialog = .F.		&& Use MESSSAGEBOX() dialog in cases where ther is no explaination text.
	Name = "cmmessage"
	ncentury = 20		&& Current century used in calculating default century values
	nflashduration = 2		&& Minimum duration of Wait Window display.
	nrollover = 50		&& Century rollover value
	
	PROCEDURE beginmultimessage		&& Begin message batching to display all following messages in a single dialog.
		*++
		*>>Begin message batching to display all following messages in a single dialog.
		* Returns .T. if multimessage feature is currently available, false if it is disabled.
		*--
		  IF THIS.lMultiMessage
		    THIS.nMessageCount = 0
		    DIMENSION THIS.aMessageText[1,2]
		    THIS.aMessageText = ''
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE confirm		&& Display a formatted message in a Yes/No dialog. Returns .T. or .F., or .NULL.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a formatted message in a Yes/No dialog. Returns .T. or .F., or .NULL.
		* If message is a key name (starts with %) and message is defined as YNC, then a 
		* Y/N/C dialog is used instead of Y/N.
		*--
		  IF NOT THIS._LoadMessage(m.cMessage)
		    THIS.cmMessageValue.nIcon = MSG_SEVERITY_QUESTION
		  ENDIF
		  IF THIS.cmMessageValue.nDialog != MSG_DIALOG_CONFIRM_YNC
		    THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_YN
		  ENDIF
		
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		  RETURN THIS.DisplayLastMessage()
		
	ENDPROC

	PROCEDURE confirmync		&& Display a formatted message in a Yes/No/Cancel dialog. Returns .T. or .F., or .NULL.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a formatted message in a Yes/No/Cancel dialog. Returns .T. or .F., or .NULL.
		*--
		  IF NOT THIS._LoadMessage(m.cMessage)
		    THIS.cmMessageValue.nIcon = MSG_SEVERITY_QUESTION
		  ENDIF
		  THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_YNC
		
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		  RETURN THIS.DisplayLastMessage()
		
	ENDPROC

	PROCEDURE Destroy
		*++
		* Restore default system mesages on VFP toolbar when we are released.
		*--
		  *SET MESSAGE TO
		
	ENDPROC

	PROCEDURE dialog		&& Display a formatted message in the specified dialog type, with the specified icon & title.
		LPARAMETERS nDialog, nIcon, cMessage, cDetails, cTitle, cP1, cP2, cP3, cP4
		*++
		*>>Display a formatted message in the specified dialog type, with the specified icon & title.
		* First 3 parameters are required:
		*  nDialog   - Dialog type code, as defined in Codemine.h
		*  nIcon     - Icon index, as defined in Codemine.h
		*  cMessage  - Message text
		*--
		  IF PCOUNT() < 3
		    ERROR "Required parameters missing"
		  ENDIF
		  THIS._LoadMessage(m.cMessage)
		  THIS.cmMessageValue.nIcon = m.nIcon
		  THIS.cmMessageValue.nDialog = m.nDialog
		  IF NOT EMPTY(m.cDetails)
		    THIS.cmMessageValue.SetText(THIS.cLanguageId,,m.cDetails)
		  ENDIF
		
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), m.cP1, m.cP2, m.cP3, m.cP4)
		  RETURN THIS.DisplayLastMessage(m.cTitle)
		
	ENDPROC

	PROCEDURE display		&& Display a formatted message with dialog specified in message key.
		LPARAMETERS cMessage, cTitle, cP1, cP2, cP3, cP4
		*++
		*>>Display a formatted message with dialog specified in message key.
		*--
		  THIS._LoadMessage(m.cMessage)
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		
		  * Store messages if message batching is enabled
		  IF THIS.nMessageCount >= 0
		    THIS.nMessageCount = THIS.nMessageCount + 1
		    IF THIS.nMessageCount = 1
		      THIS.cMultiTitle = m.cTitle
		    ELSE
		      DIMENSION THIS.aMessageText[THIS.nMessageCount, 2]
		    ENDIF
		    THIS.aMessageText[THIS.nMessageCount, 1] = THIS.cFormattedText
		    THIS.aMessageText[THIS.nMessageCount, 2] = THIS.cmMessageValue.GetText(MSGVAL_FIELD_LONG, THIS.nLanguageIndex)
		  ELSE
		    RETURN THIS.DisplayLastMessage(m.cTitle)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE displayhelp		&& Display modeless context help dialog
		LPARAMETERS cRichText, cTitle, cArg1, cArg2
		*++
		*>>Display modeless context help dialog
		*--
		  * Open instance or get reference to existing instance of the help form.
		  IF THIS.lUserInterfaceAvailable AND NOT ISNULL(THIS.oStateManager)
		    LOCAL oHelp
		    m.oHelp = THIS.oStateManager.OpenForm(THIS.cFrmHelp)
		    RETURN m.oHelp.ShowHelp(@m.cRichText, THIS.Format(THIS.TranslateString(m.cTitle), m.cArg1, m.cArg2))
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE displaylastmessage		&& Display the message stored in the cFormattedText property, in the appropriate dialog.
		LPARAMETERS cTitle, nDialog, nIcon
		*++
		*>>Display the message stored in the cFormattedText property, in the appropriate dialog.
		*     cTitle   - Dialog title
		*     nDialog  - Optional Dialog type code, as defined in Codemine.h
		*     nIcon    - Optional Icon index, as defined in Codemine.h
		*--
		LOCAL cText, cLongtext, nButton, nButtonType, oDialog
		
		    * Write any displayed messages to the text log, if one is enabled.
		    IF NOT EMPTY(THIS.cTextLog)
		      TRY
		        STRTOFILE(TTOC(DATETIME()) + ' - ' + THIS.cFormattedText + CHR(13)+CHR(10), THIS.cTextLog, 1)
		      CATCH
		      ENDTRY
		    ENDIF
		
		    IF THIS.lUserInterfaceAvailable
		      * If no message value loaded, return now.
		      IF NOT PEMSTATUS(THIS, 'cmMessageValue', 5)
		        RETURN .T.
		      ENDIF
		
		      * If main VFP window is minimized, restore it to normal size first.
		      IF _SCREEN.WindowState = 1
		        _SCREEN.WindowState = 0
		      ENDIF
		
		      IF NOT EMPTY(m.nDialog)
		        THIS.cmMessageValue.nDialog = m.nDialog
		      ENDIF
		      IF NOT EMPTY(m.nIcon)
		        THIS.cmMessageValue.nIcon = m.nIcon
		      ENDIF
		
		      * Clear any pre-existing status message before display of new message dialog.
		      THIS.StatusClear()
		
		      DO CASE
		        CASE THIS.lFlashInform AND THIS.cmMessageValue.nDialog = MSG_DIALOG_INFORM
		          IF THIS.lBeep
		            MessageBeep(MB_ICONASTERISK)
		          ENDIF
		          DO CASE
		            CASE THIS.nFlashDuration < 0
		              WAIT WINDOW THIS.cFormattedText
		            CASE THIS.nFlashDuration = 0
		              WAIT WINDOW NOWAIT THIS.cFormattedText
		            CASE THIS.nFlashDuration > 0
		              * Display the message for at least nFlashDuration seconds, then allow clear
		              WAIT WINDOW THIS.cFormattedText NOCLEAR TIMEOUT (THIS.nFlashDuration)
		              WAIT WINDOW NOWAIT THIS.cFormattedText
		          ENDCASE
		          RETURN .T.
		
		        CASE THIS.cmMessageValue.nDialog = MSG_DIALOG_TEXT
		          * If main VFP window not visible, and no Toplevel window, we need to show main to see dialog.
		          IF NOT _SCREEN.Visible AND EMPTY(WONTOP())
		            _SCREEN.Visible = .T.
		          ENDIF
		          m.cLongText = THIS.cmMessageValue.GetText(MSGVAL_FIELD_LONG, THIS.nLanguageIndex)
		          m.oDialog = CreateNewObject(THIS.cFrmGetText, IIF(EMPTY(m.cTitle), THIS.Localize(THIS.cTextTitle), m.cTitle), ;
		                                    THIS.cFormattedText, m.cLongText, THIS.cmMessageValue.nIcon)
		          IF VARTYPE(m.oDialog) = 'O'
		            m.oDialog.Show(1)
		            RETURN IIF(VARTYPE(m.oDialog) = 'O', m.oDialog.ReturnValue(), .F.)
		          ENDIF
		
		        OTHERWISE
		          DO CASE
		            CASE THIS.cmMessageValue.nIcon = MSG_SEVERITY_WARNING
		              m.nButtonType = 48
		              m.cTitle = IIF(EMPTY(m.cTitle), THIS.Localize(THIS.cWarningTitle, .T.), m.cTitle)
		            CASE THIS.cmMessageValue.nIcon = MSG_SEVERITY_ERROR
		              m.nButtonType = 16
		              m.cTitle = IIF(EMPTY(m.cTitle), THIS.Localize(THIS.cErrorTitle, .T.), m.cTitle)
		            CASE THIS.cmMessageValue.nIcon = MSG_SEVERITY_QUESTION
		              m.nButtonType = 32
		              m.cTitle = IIF(EMPTY(m.cTitle), THIS.Localize(THIS.cQuestionTitle, .T.), m.cTitle)
		            OTHERWISE     && Informational
		              m.nButtonType = 64
		              m.cTitle = IIF(EMPTY(m.cTitle), THIS.Localize(THIS.cInfoTitle, .T.), m.cTitle)
		          ENDCASE
		
		          * If there is no long text for this message, use a standard system
		          * dialog because it is faster.
		          m.cLongText = THIS.cmMessageValue.GetText(MSGVAL_FIELD_LONG, THIS.nLanguageIndex)
		
		          * If main VFP window is not visible, we must use MESSAGEBOX() so it can be seen.
		          IF (NOT _SCREEN.Visible AND EMPTY(WONTOP())) OR (EMPTY(m.cLongText) AND THIS.lUseSystemDialog)
		            DO CASE
		              CASE THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_OKC
		                m.nButtonType = m.nButtonType + 1
		              CASE THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_YN
		                m.nButtonType = m.nButtonType + 4
		              CASE THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_YNC
		                m.nButtonType = m.nButtonType + 3
		              CASE THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_RC
		                m.nButtonType = m.nButtonType + 5
		            ENDCASE
		            m.cText = THIS.cFormattedText
		            IF LEN(m.cText) < 75
		              m.cText = PADR(m.cText, 75)
		            ENDIF
		            m.nButton = MESSAGEBOX(m.cText, m.nButtonType, m.cTitle)
		            IF (THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_YNC AND m.nButton = 2)
		              RETURN .NULL.
		            ENDIF
		            RETURN INLIST(m.nButton, 1, 4, 6)
		          ELSE
		            * Longest message text string displayable in the dialog label caption is 253 characters.
		            m.oDialog = CreateNewObject(THIS.cFrmConfirm, m.cTitle, LEFT(THIS.cFormattedText, 253), m.cLongText, ;
		                        THIS.cmMessageValue.nDialog, THIS.cmMessageValue.nIcon, THIS.cmMessageValue.nDefault, THIS.lBeep)
		            IF VARTYPE(m.oDialog) = 'O'
		              m.oDialog.Show(1)
		              RETURN IIF(VARTYPE(m.oDialog) = 'O', m.oDialog.ReturnValue(), .F.)
		            ENDIF
		          ENDIF
		      ENDCASE
		    ENDIF
		    RETURN .T.
		
	ENDPROC

	PROCEDURE endmultimessage		&& Ends message batching, and if one or more messages have been queued, display them all.
		*++
		*>>Ends message batching, and if one or more messages have been queued, display them all.
		*--
		  IF THIS.nMessageCount > 0
		    LOCAL oDialog, cText
		    IF THIS.nMessageCount = 1
		      THIS.DisplayLastMessage(THIS.cMultiTitle)
		    ELSE
		      m.cText = THIS.Format(THIS.TranslateString('%txtFormMultiError'), THIS.nMessageCount)
		      m.oDialog = CreateLocalized(THIS.cFrmMultiMessage, THIS.cMultiTitle, m.cText)
		      IF VARTYPE(m.oDialog) = 'O'
		        m.oDialog.Show(1)
		      ENDIF
		    ENDIF
		
		    * Clear message array after display to save a little memory.
		    DIMENSION THIS.aMessageText[1,2]
		    THIS.aMessageText = ''
		  ENDIF
		  THIS.nMessageCount = -1   && Disable batching untilk next call to this.BeginMultiMessage()
		
	ENDPROC

	PROCEDURE fatalerror		&& Issued when a fatal coding error occurs, displays stack dump and "Cancel" button.
		LPARAMETERS cMsg, cMethod, nLine
		*++
		*>>Issued when a fatal coding error occurs, displays stack dump and "Cancel" button.
		*--
		LOCAL oDialog, cOption
		
		  * Store call stack in a local property so it is available for error dialog and event log.
		  THIS.cErrorCallStack = THIS._GetCallStack()
		
		  IF THIS.lUserInterfaceAvailable
		    m.oDialog = CreateLocalized(THIS.cFrmFatalError, @m.cMsg, @m.cMethod, @m.nLine)
		    IF VARTYPE(m.oDialog) = 'O'
		      m.oDialog.Show()
		      m.cOption = m.oDialog.ReturnValue()
		    ENDIF
		  ELSE
		    m.cOption = 'CANCEL'
		  ENDIF
		
		  * Write detaisl of the error to the error log, if it is enabled.
		  THIS.LogError(@m.cMsg, m.nLine, THIS.cErrorCallStack)
		
		  DO CASE
		    CASE EMPTY(m.cOption)    && Error dialog creation failed. App is too messed up to run.
		      MESSAGEBOX('Error Dialog failed to open. Message was: ' + m.cMsg, 16, _SCREEN.Caption)
		      ON SHUTDOWN
		      CLEAR EVENTS
		      CANCEL
		
		    CASE m.cOption = 'CANCEL'
		      IF THIS.lUserInterfaceAvailable AND WEXIST('command')
		        ACTIVATE WINDOW command
		      ENDIF
		      ON SHUTDOWN
		      CLEAR EVENTS
		      IF VERSION(2) != 0
		        SET SYSMENU TO DEFAULT
		      ENDIF
		      CANCEL
		
		    CASE m.cOption = 'DEBUG'
		      IF NOT ISNULL(THIS.oStateManager)
		        THIS.oStateManager.EnableInterrupts(.F., .T.)
		      ENDIF
		      KEYBOARD "{F8}" PLAIN
		      SET STEP ON
		      RETRY
		
		    CASE m.cOption = 'SUSPEND'
		      IF WEXIST('command')
		        ACTIVATE WINDOW command
		      ENDIF
		      WAIT WINDOW NOWAIT 'Suspended...'
		      SUSPEND
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE flashmessage		&& Display a temporary formatted modeless WAIT WINDOW message, if a UI is present.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a temporary formatted modeless WAIT WINDOW message, if a UI is present. 
		*--
		LOCAL cValue, oMsg, cMsg
		
		  IF THIS.lUserInterfaceAvailable
		    * If it is in key format (begins with %) find the key in the registry.
		    IF LEFT(m.cMessage, 1) = '%' AND NOT ISNULL(THIS.oRegistry)
		      m.oMsg = CreateNewObject('cmMessageValue')
		      m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.System Messages.' + SUBSTR(m.cMessage, 2), 'Message', '')
		      m.oMsg.Scatter(m.cValue)
		      m.cMsg = m.oMsg.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex)
		    ENDIF
		
		    IF EMPTY(m.cMsg)
		      m.cMsg = m.cMessage
		    ENDIF
		    m.cMsg = THIS.Format(m.cMsg, @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		
		    IF THIS.lBeep
		      =MessageBeep(MB_ICONASTERISK)
		    ENDIF
		    WAIT WINDOW NOWAIT m.cMsg
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE format		&& Replace embedded string parameters with their expanded value.
		LPARAMETERS cInString, cP1, cP2, cP3, cP4, cP5, cP6, cP7
		*++
		*>>Replace embedded string parameters with their expanded value.
		* The string '\c' in the source string is replaced with the 
		* corresponding string parameter. Up to 7 parameters are allowed.
		* Returns formatted string with parameters in place.
		*
		* Special directives: 
		*        \c    Character arg
		*        \d    Numeric (decimal) arg
		*        \s    Insert an 's' if the most recent numeric arg != 1
		*        \n    Insert line break
		*        \\    Insert a literal backslash
		*        \-    Disable all arg processing, treat '\' as regular character
		*     \1 thru \4 Use the specified argument number as value for next directive.
		*           Useful when different translations of a message want args in different order.
		*--
		LOCAL ix, lArgDisabled, nArgIndex, nValue, cOutString, cValue
		
		  m.nValue = 0
		  m.nArgIndex = 1
		  m.ix = AT('\', m.cInString)
		  IF m.ix > 0 AND m.ix < LEN(m.cInString)
		    m.cOutString = LEFT(m.cInString, m.ix - 1)
		    FOR m.ix = m.ix TO LEN(m.cInString)
		      m.ch = SUBSTR(m.cInstring, m.ix, 1)
		      IF m.ch = '\' AND m.ix < LEN(m.cInString) AND NOT lArgDisabled
		        m.ix = m.ix + 1
		        m.ch = LOWER(SUBSTR(m.cInString, m.ix, 1))
		        DO CASE
		          CASE m.ch = 'c'
		            IF m.nArgIndex < PCOUNT()
		              m.cValue = EVALUATE('m.cP' + STR(m.nArgIndex,1))
		              m.nArgIndex = m.nArgIndex + 1
		              IF TYPE('m.cValue') = 'C'
		                m.cOutString = m.cOutString + m.cValue
		              ENDIF
		            ENDIF
		          CASE m.ch = 'd'
		            IF m.nArgIndex < PCOUNT()
		              m.nValue = EVALUATE('m.cP' + STR(m.nArgIndex,1))
		              m.nArgIndex = m.nArgIndex + 1
		              IF TYPE('m.nValue') $ 'NYI'
		                IF m.nValue % 1 != 0
		                  m.cOutString = m.cOutString + LTRIM(STR(m.nValue, 9, SET('DECIMALS')))
		                ELSE
		                  m.cOutString = m.cOutString + LTRIM(STR(m.nValue))
		                ENDIF
		              ELSE
		                m.nValue = 0
		              ENDIF
		            ENDIF
		          CASE m.ch = 's'
		            IF m.nValue != 1
		              m.cOutString = m.cOutString + SUBSTR(m.cInString, m.ix, 1)
		            ENDIF
		          CASE m.ch = 'n'
		            m.cOutString = m.cOutString + CR_LF
		          CASE m.ch = '\'
		            m.cOutString = m.cOutString + '\'
		          CASE m.ch = '-'
		            m.lArgDisabled = .T.
		          CASE m.ch > '0' AND m.ch <= '9'      && Select argument to use with next directive
		            m.nArgIndex = VAL(m.ch)
		        ENDCASE
		      ELSE
		        m.cOutString = m.cOutString + m.ch
		      ENDIF
		    ENDFOR
		  ELSE
		    m.cOutString = m.cInString
		  ENDIF
		  RETURN m.cOutString
		
	ENDPROC

	PROCEDURE getlastmessage		&& Return info about the last message displayed.
		LPARAMETERS cItem
		*++
		*>>Return info about the last message displayed.
		*--
		  m.cItem = IIF(EMPTY(m.cItem), 'TEXT', UPPER(m.cItem))
		  DO CASE
		    CASE m.cItem = 'TEXT'
		      RETURN THIS.cFormattedText    && cText value with any arguments already in place.
		    CASE m.cItem = 'LONG'
		      RETURN THIS.cmMessageValue.GetText(MSGVAL_FIELD_LONG, THIS.nLanguageIndex)
		    CASE m.cItem = 'NUMB'
		      RETURN THIS.cmMessageValue.cNumber
		    OTHERWISE
		      ERROR 'GetLastMessage - Unknown Item: ' + m.cItem
		  ENDCASE
		
	ENDPROC

	PROCEDURE gettext		&& Display message dialog and accept a text string in reply.
		LPARAMETERS cMessage, cTitle, cDefault, cP1, cP2, cP3, cP4
		*++
		*>>Display message dialog and accept a text string in reply.
		* Optional cP1-cP4 parameters apply to the cMessage string.
		* Returns the string entered, or .NULL. if user pressed Cancel.
		*--
		LOCAL oDialog, cText
		  IF NOT THIS._LoadMessage(m.cMessage)
		    THIS.cmMessageValue.nIcon = MSG_SEVERITY_QUESTION
		  ENDIF
		
		  m.cText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		  IF THIS.lUserInterfaceAvailable
		    m.oDialog = CreateLocalized(THIS.cFrmGetText, IIF(EMPTY(m.cTitle), THIS.cTextTitle, m.cTitle), m.cText, ;
		                THIS.cmMessageValue.GetText(MSGVAL_FIELD_LONG, THIS.nLanguageIndex), , ;
		                IIF(EMPTY(m.cDefault), '', m.cDefault) )
		    IF VARTYPE(m.oDialog) = 'O'
		      m.oDialog.Show(1)
		      IF VARTYPE(m.oDialog) = 'O'
		        RETURN m.oDialog.ReturnValue()
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE inform		&& Display a formatted informational message and return .F.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a formatted informational message and return .F.
		* Returns .F., so functions can use code like the following on error returns:
		*    RETURN oMsg.Inform('msg')
		*--
		  IF NOT THIS._LoadMessage(m.cMessage)
		    THIS.cmMessageValue.nIcon = MSG_SEVERITY_INFORM
		  ENDIF
		  THIS.cmMessageValue.nDialog = MSG_DIALOG_INFORM
		
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		  THIS.DisplayLastMessage()
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Init
		*++
		*>>Initialize the message display object, and get a pointer to the registry.
		*
		* CodeMine Multi-Lingual Message Manager
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  DECLARE INTEGER MessageBeep IN user32 INTEGER nType
		#Include win32.h
		  THIS.AddProperty('oRegistry', FindGlobalObject('cmRegistry', '7.0'))
		  THIS.AddProperty('oStateManager', FindGlobalObject('cmStateManager'))
		  THIS.AddProperty('oStatusBar', .NULL.)
		  THIS.AddProperty('cLanguage', '')           && Name of current language
		  THIS.AddProperty('cLanguageID', '')         && ID of current language
		  THIS.AddProperty('cDefaultLanguage', '')    && Default language as defined in the app registry
		  THIS.AddProperty('cFormattedText', '')      && Store formatted message text here.
		  THIS.AddProperty('aClasses[1]')
		  THIS.AddProperty('nClasses', 0)
		  THIS.AddProperty('nLanguageIndex', 0)      && Index into aLanguage array for the current language
		  THIS.AddProperty('aLanguages[1,2]')        && Array of defined language ID's and links to parent languages
		  THIS.AddProperty('aBarCache[1,3]')         && Translation cache for context menu bars.
		  THIS.AddProperty('aMessageText[1,2]')      && Array of batched messages when multi-message feature is enabled.
		  THIS.AddProperty('aCaptionCache[1,2]')
		  THIS.AddProperty('nMessageCount', -1)      && Number of msgs in multi-message list. -1 if disabled.
		  THIS.AddProperty('cMultiTitle', '')        && Multimessage dialog title, from 1st msg in list.
		  THIS.AddProperty('cErrorCallStack', '')    && Call stack for last fatal error.
		
		  * Add a language value object for decoding language key values
		  THIS.AddNewObject('cmLanguageValue', 'cmLanguageValue')
		
		  * Load the list of localized class libraries for all languages
		  THIS.LoadLocalizedLibraries()
		
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.Subscribe('Registry Update Local', THIS)
		  ENDIF
		
	ENDPROC

	PROCEDURE lautotab_assign		&& Keep the SET CONFIRM setting for the default data session in sync with the lAutoTab property.
		LPARAMETERS lValue
		*++
		*>>Keep the SET CONFIRM setting for the default data session in sync with the lAutoTab property.
		*--
		  THIS.lAutoTab = m.lValue
		  IF THIS.lAutoTab
		    SET CONFIRM OFF
		  ELSE
		    SET CONFIRM ON
		  ENDIF
		
	ENDPROC

	PROCEDURE loadlocalizedlibraries		&& Loads the list of localized VCX libraries specified in the cLocalizedLibraryList property of appSettings object.
		*++
		*>>Loads the list of localized VCX libraries specified in the cLocalizedLibraryList property of appSettings object.
		*--
		  LOCAL oApp, nSelect, nCount, cVCX, cVCXlist, aNames[1]
		  m.nSelect = SELECT()
		
		  * Clear away any previous libraries.
		  DIMENSION THIS.aClasses[1]
		  THIS.aClasses = ''
		
		  m.oApp = FindGlobalObject('appApplication')
		  IF NOT ISNULL(m.oApp)
		    m.cVCXlist = m.oApp.appSettings.cLocalizedLibraryList
		    DO WHILE NOT EMPTY(m.cVCXlist)
		      m.cVCX = GetToken(@m.cVCXlist, ',')
		      IF NOT EMPTY(m.cVCX)
		        SELECT 0
		        USE (m.cVCX) ALIAS _cmVcxLibrary AGAIN NOUPDATE
		        SELECT objname FROM _cmVcxLibrary INTO ARRAY aNames ;
		               WHERE platform = 'WINDOWS' AND EMPTY(parent) AND NOT EMPTY(objname) AND NOT DELETED()
		        USE IN _cmVcxLibrary
		
		        IF NOT EMPTY(aNames[1])
		          m.nCount = ALEN(THIS.aClasses) - IIF(EMPTY(THIS.aClasses[1]), 1, 0)
		          DIMENSION THIS.aClasses[m.nCount + ALEN(aNames)]
		          ACOPY(aNames, THIS.aClasses, 1, ALEN(aNames), m.nCount + 1)
		        ENDIF
		      ENDIF
		    ENDDO
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE localize		&& Translate a short string into the current language.
		LPARAMETERS cString, lCache
		*++
		*>>Translate a short string into the current language.
		* Returns translated text as Value.
		*--
		LOCAL ix, cKeyname, cValue, lExact, cResult
		
		  * Key name used is limited to 40 characters.
		  * Strip out any periods, double-quotes, or "\<" directives in the string.
		  m.cKeyName = UPPER(ALLTRIM(STRTRAN(CHRTRAN(m.cString, '."', ''), '\<', '')))
		  IF NOT EMPTY(m.cKeyName) AND NOT ISNULL(THIS.oRegistry)
		    IF m.lCache
		      m.lExact = SET('EXACT') == 'ON'
		      SET EXACT ON
		      m.ix = ASCAN(THIS.aCaptionCache, '%~' + m.cKeyname)
		      IF NOT m.lExact
		        SET EXACT OFF
		      ENDIF
		      IF m.ix > 0
		        RETURN THIS.aCaptionCache[m.ix + 1]
		      ENDIF
		    ENDIF
		
		    * If caching not enabled, or Value is not cached.
		    m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.Captions.' + m.cKeyname, 'Message', '')
		    IF NOT EMPTY(m.cValue)
		      * Create a cmMessageValue object the first time we are called. This object
		      * knows how to unpack and interpret the value of Message keys.
		      IF NOT PEMSTATUS(THIS, 'cmTextValue', 5)
		        THIS.AddNewObject('cmTextValue', 'cmMessageValue')
		      ENDIF
		
		      THIS.cmTextValue.Scatter(m.cValue)
		      m.cResult = THIS.cmTextValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex,, '')
		
		      * If no explicit translation, use original string
		      IF EMPTY(m.cResult)
		        m.cResult = m.cString
		      ENDIF
		
		      * If caching enabled for this string, add it to the cache.
		      IF m.lCache
		        m.ix = ALEN(THIS.aCaptionCache, 1) + IIF(EMPTY(THIS.aCaptionCache[1]), 0, 1)
		        DIMENSION THIS.aCaptionCache[m.ix, 2]
		        THIS.aCaptionCache[m.ix, 1] = '%~' + m.cKeyname
		        THIS.aCaptionCache[m.ix, 2] = m.cResult
		      ENDIF
		      RETURN m.cResult
		    ENDIF
		  ENDIF
		  RETURN m.cString  && No translation found, return original string
		
	ENDPROC

	PROCEDURE localizeclass		&& If there is a localized version of the specified class, return its name.
		LPARAMETERS cClass
		*++
		*>>If there is a localized version of the specified class, return its name.
		*--
		  LOCAL ix, lExact
		  IF NOT EMPTY(THIS.aClasses[1])
		    m.lExact = (SET('EXACT') == 'ON')
		    SET EXACT ON
		    m.ix = ASCAN(THIS.aClasses, LOWER(SUBSTR(m.cClass, RAT('.', m.cClass) + 1) + THIS.cLanguage))
		    IF NOT m.lExact
		      SET EXACT OFF
		    ENDIF
		    IF m.ix > 0
		      RETURN THIS.aClasses[m.ix]
		    ENDIF
		  ENDIF
		  RETURN m.cClass
		
	ENDPROC

	PROCEDURE logerror		&& Make an event log entry for an unhandled fatal error.
		LPARAMETERS cMsg, nLine, cDetails
		*++
		*>>Make an event log entry for an unhandled fatal error.
		*--
		LOCAL ix, cText, oSecurity
		
		    IF THIS.lLogErrors
		      m.ix = 1
		      DO WHILE NOT EMPTY(SYS(16, m.ix + 1))
		        m.ix = m.ix + 1
		      ENDDO
		
		      * Strip off this method, and two before us, if present, since these are normally after the error occured.
		      m.ix = MAX(1, m.ix - 3)
		      DO WHILE m.ix > 1 AND ('ON...' $ SYS(16, m.ix) OR '.ERROR ' $ SYS(16, m.ix) + ' ')
		        m.ix = m.ix - 1
		      ENDDO
		
		      * Format the error message and call stack for the log message.
		      m.cText = PROPER(SYS(16, m.ix)) + ' (line ' + LTRIM(STR(m.nLine)) + ') ' ;
		              + CR_LF + '"' + m.cMsg + '"' + CR_LF + IIF(EMPTY(m.cDetails), '', m.cDetails)
		
		      m.oSecurity = FindGlobalObject('cmSecurity')
		      IF NOT ISNULL(m.oSecurity)
		        m.oSecurity.RecordEvent('Err# ' + LTRIM(STR(ERROR())), 'Error', @m.cText)
		      ENDIF
		
		      * Write the message to the current text log too, if any.
		      THIS.LogMessage('\-' + m.cText + CR_LF)
		    ENDIF
		
	ENDPROC

	PROCEDURE logmessage
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Write a message to the current text log file.
		*--
		
		  THIS._LoadMessage(m.cMessage)
		  IF NOT EMPTY(THIS.cTextLog)
		    THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		    THIS.cFormattedText = STRTRAN(THIS.cFormattedText, CR_LF, CR_LF + CHR(9))  && Hanging Indent for multiLine messages
		    TRY
		      STRTOFILE(TTOC(DATETIME()) + ' - ' + THIS.cFormattedText + CHR(13)+CHR(10), THIS.cTextLog, 1)
		    CATCH
		    ENDTRY
		  ENDIF
		
	ENDPROC

	PROCEDURE logverbose
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Write a message to the current text log file, but only if the lVerboseLog property is set to .T.
		*--
		  IF THIS.lVerboseLog
		    RETURN THIS.LogMessage(@m.cMessage, @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		  ENDIF
		
	ENDPROC

	PROCEDURE luserinterfaceavailable_access		&& Determine if a user interface is available for this application.
		*++
		*>>Determine if a user interface is available for this application.
		*--
		  IF THIS.lUserInterfaceAvailable
		    RETURN NOT SYS(2335) == '0'
		  ENDIF
		  RETURN THIS.lUserInterfaceAvailable
		
	ENDPROC

	PROCEDURE progressbar		&& Display a progress bar. Returns object reference to the bar.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a progress bar. Returns object reference to the bar.
		* The actual bar may be a standalone progressbar form, or the built in progress
		* bar in the Codemine status bar, depending on local preference settings.
		*--
		  LOCAL cText
		  m.cText = THIS.Format(THIS.TranslateString(m.cMessage), m.cP1, m.cP2, m.cP3, m.cP4)
		  IF THIS.lUseStatusbarProgress
		    IF ISNULL(THIS.oStatusbar)
		      THIS.oStatusbar = FindGlobalObject('frmStatusbar')
		    ENDIF
		    IF ISNULL(THIS.oStatusbar)
		      THIS.lUseStatusbarProgress = .F.
		    ELSE
		      THIS.oStatusbar.InitProgress(m.cText)
		      RETURN THIS.oStatusbar
		    ENDIF
		  ENDIF
		  RETURN CreateLocalized(THIS.cFrmProgress, m.cText)
		
	ENDPROC

	PROCEDURE progressbarex		&& Display a progress bar with two message lines. Returns object reference to the bar.
		LPARAMETERS cTitle, cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a progress bar with two message lines. Returns object reference to the bar.
		* The actual bar may be a standalone progressbar form, or the built in progress
		* bar in the Codemine status bar, depending on local preference settings.
		*--
		LOCAL cText
		  IF EMPTY(m.cMessage)
		    m.cMessage = ''
		  ENDIF
		  m.cText = THIS.Format(THIS.TranslateString(m.cMessage), m.cP1, m.cP2, m.cP3, m.cP4)
		  RETURN CreateLocalized(THIS.cFrmProgressEx, THIS.TranslateString(m.cTitle), m.cText)
		
	ENDPROC

	PROCEDURE registryupdate		&& Initialize exposed properties from stored registry values. Called on Init and whenever the app registry is changed.
		*++
		*>>Initialize exposed properties from stored registry values. Called on Init and whenever the app registry is changed.
		*--
		  IF NOT ISNULL(THIS.oRegistry)
		    THIS.lBeep = THIS.oRegistry.GetKeyValue('%Local.Message.Preferences.Beep on Messages', KEY_TYPE_LOGICAL, THIS.lBeep)
		    THIS.lFlashInform = THIS.oRegistry.GetKeyValue('%Local.Message.Preferences.Flash Info Messages', KEY_TYPE_LOGICAL, THIS.lFlashInform)
		    THIS.nFlashDuration = THIS.oRegistry.GetKeyValue('%Local.Message.Preferences.Flash Info Duration', KEY_TYPE_NUMERIC, THIS.nFlashDuration)
		    THIS.lMultiMessage = THIS.oRegistry.GetKeyValue('%Local.Message.Preferences.Batch Messages', KEY_TYPE_LOGICAL, THIS.lMultiMessage)
		
		    * Update century settings in default datasession to match desired property settings.
		    * Forms with a private datasession should request their own registryUpdate notification
		    * to update their datasession.
		    THIS.nCentury = THIS.oRegistry.GetKeyValue(KEYNAME_CENTURY, KEY_TYPE_NUMERIC, THIS.nCentury)
		    THIS.nRollover = THIS.oRegistry.GetKeyValue(KEYNAME_ROLLOVER, KEY_TYPE_NUMERIC, THIS.nRollover)
		    SET CENTURY TO (THIS.nCentury) ROLLOVER (THIS.nRollover)
		
		    * Set the desired autotab setting.
		    THIS.lAutoTab = THIS.oRegistry.GetKeyValue(KEYNAME_AUTO_TAB, KEY_TYPE_LOGICAL, THIS.lAutoTab)
		
		    THIS._InitLanguages()
		
		    * Reset lanuage-related properties when registry values change.
		    IF NOT EMPTY(THIS.cLanguage)
		      THIS.SetLanguage(THIS.cLanguage)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE release
		*++
		*>>Tell registry we no longer exist, and release ourself.
		*--
		  * Cancel outstanding subscriptions to Registry Update events.
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.UnSubscribe('Registry Update Local', THIS)
		  ENDIF
		
		  STORE .NULL. TO THIS.oStateManager, THIS.oRegistry, THIS.oStatusbar
		  RELEASE THIS
		
	ENDPROC

	PROCEDURE setlanguage		&& Set the current language, and associated localization settings.
		LPARAMETERS cLanguage
		*++
		*>>Set the current language, and associated localization settings.
		*--
		LOCAL ix, cValue, oString
		
		  m.cValue = ''
		  IF NOT ISNULL(THIS.oRegistry)
		    IF EMPTY(THIS.cLanguage)
		      THIS._InitLanguages()
		    ENDIF
		
		    m.cValue = THIS.oRegistry.GetGlobalKeyValue('%Local.Message.Languages.' + ALLTRIM(m.cLanguage), 'Language', '')
		  ENDIF
		
		  * First time we set defaults if specified language doesn't exist, otherwise do nothing.
		  IF EMPTY(THIS.cLanguageID) OR NOT EMPTY(m.cValue)
		    THIS.cmLanguageValue.Scatter(m.cValue)
		    THIS.cLanguage = UPPER(m.cLanguage)
		    THIS.cLanguageID = THIS.cmLanguageValue.cLanguageID
		
		    * Find the new language in the language array. This array is used to quickly trace
		    * up the language definition hierarchy for "subclassed" languages.
		    m.ix = ASCAN(THIS.aLanguages, THIS.cLanguageID)
		    IF m.ix > 0
		      THIS.nLanguageIndex = ASUBSCRIPT(THIS.aLanguages, m.ix, 1)
		    ENDIF
		
		    * Reset context menu bar translation cache
		    DIMENSION THIS.aCaptionCache[1, 2]
		    THIS.aCaptionCache = ''
		    DIMENSION THIS.aBarCache[1,3]
		    THIS.aBarCache = ''
		
		    * Reset month name translations in string tools object, if it exists.
		    m.oString = FindGlobalObject('cmStringTools')
		    IF NOT ISNULL(m.oString)
		      m.oString.aMonths = ''
		    ENDIF
		
		    * Set various localization strings based on new language setting.
		    IF THIS.cmLanguageValue.lSysFormat
		      SET SYSFORMATS ON
		    ELSE
		      SET SYSFORMATS OFF
		      IF PROPER(THIS.cmLanguageValue.cCurrencyFormat) = 'Left'
		        SET CURRENCY LEFT
		      ELSE
		        SET CURRENCY RIGHT
		      ENDIF
		      SET CURRENCY TO (THIS.cmLanguageValue.cCurrencySymbol)
		      SET POINT TO (THIS.cmLanguageValue.cDecimal)
		      SET SEPARATOR TO (THIS.cmLanguageValue.cSeparator)
		      SET MARK TO (THIS.cmLanguageValue.cMark)
		      SET DATE TO  (THIS.cmLanguageValue.cDateFormat)
		      SET HOURS TO  (THIS.cmLanguageValue.nHourFormat)
		    ENDIF
		    IF THIS.cmLanguageValue.lCentury
		      SET CENTURY ON
		    ELSE
		      SET CENTURY OFF
		    ENDIF
		  ENDIF
		  RETURN NOT EMPTY(m.cValue)
		
	ENDPROC

	PROCEDURE setlastmessage		&& Format and store the last message string, but do not display it.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Format and store the last message string, but do not display it.
		*--
		  THIS._LoadMessage(m.cMessage)
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), m.cP1, m.cP2, m.cP3, m.cP4)
		
	ENDPROC

	PROCEDURE setlastmessageex		&& Format and store the last message string & optional description text, but do not display it.
		LPARAMETERS cMessage, cDetails, cP1, cP2, cP3, cP4
		*++
		*>>Format and store the last message string & optional description text, but do not display it.
		*--
		  THIS._LoadMessage(m.cMessage)
		  IF NOT EMPTY(m.cDetails)
		    THIS.cmMessageValue.SetText(THIS.cLanguageId,,m.cDetails)
		  ENDIF
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), m.cP1, m.cP2, m.cP3, m.cP4)
		
	ENDPROC

	PROCEDURE severe		&& Display a formatted severe error message and return .F.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a formatted severe error message and return .F.
		*--
		  THIS._LoadMessage(m.cMessage)
		  THIS.cmMessageValue.nIcon = MSG_SEVERITY_ERROR
		  THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_OK
		
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		  THIS.DisplayLastMessage()
		  RETURN .F.
		
	ENDPROC

	PROCEDURE statusclear		&& Clear the last status message display.
		*++
		*>>Clear the last status message display.
		*--
		  IF THIS.lUserInterfaceAvailable
		    IF THIS.lUseStatusBar
		      TRY 
		         SET MESSAGE TO 'Data Path: ' + LOWER(m.goapp.cdatafilepath) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		      CATCH
		      ENDTRY    
		    ELSE
		      WAIT CLEAR
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE statusmessage		&& Display a formatted modeless informational message, if a UI is present. Message stays visible until StatusClear() is called.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a formatted modeless informational message, if a UI is present. Message stays visible until StatusClear() is called.
		*--
		LOCAL cValue, oMsg, cMsg
		
		  IF THIS.lUserInterfaceAvailable
		    * If it is in key format (begins with %) find the key in the registry.
		    IF LEFT(m.cMessage, 1) = '%' AND NOT ISNULL(THIS.oRegistry)
		      m.oMsg = CreateNewObject('cmMessageValue')
		      m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.System Messages.' + SUBSTR(m.cMessage, 2), 'Message', '')
		      m.oMsg.Scatter(m.cValue)
		      m.cMsg = m.oMsg.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex)
		    ENDIF
		
		    IF EMPTY(m.cMsg)
		      m.cMsg = m.cMessage
		    ENDIF
		    m.cMsg = THIS.Format(m.cMsg, @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		
		    IF THIS.lUseStatusBar
		      SET MESSAGE TO m.cMsg
		    ELSE
		      WAIT WINDOW NOWAIT NOCLEAR m.cMsg
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE translate		&& Translate a system message identifier into the current language.
		LPARAMETERS cTextID, cShortText, cLongText
		*++
		*>>Translate a system message identifier into the current language.
		* Returns ShortText as Value.
		*--
		  IF LEFT(m.cTextID, 1) = '%' AND NOT ISNULL(THIS.oRegistry)
		    LOCAL cValue
		    m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.System Messages.' + SUBSTR(m.cTextID, 2), 'Message', '')
		
		    IF NOT EMPTY(m.cValue)
		      * Create a cmMessageValue object the first time we are called. This object
		      * knows how to unpack and interpret the value of Message keys.
		      IF NOT PEMSTATUS(THIS, 'cmTextValue', 5)
		        THIS.AddNewObject('cmTextValue', 'cmMessageValue')
		      ENDIF
		
		      THIS.cmTextValue.Scatter(m.cValue)
		      m.cShortText = THIS.cmTextValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex)
		      IF PCOUNT() >= 3
		        m.cLongText = THIS.cmTextValue.GetText(MSGVAL_FIELD_LONG, THIS.nLanguageIndex)
		      ENDIF
		      RETURN m.cShortText
		    ENDIF
		    m.cTextID = SUBSTR(m.cTextID, 2)
		  ENDIF
		
		  * Not in key format (no %) or no key found return original string.
		  m.cShortText = m.cTextID
		  STORE '' TO m.cLongText
		  RETURN m.cTextID
		
	ENDPROC

	PROCEDURE translatebar		&& Translate a menu bar identifier into the current language.
		LPARAMETERS cBarName, nBar, cPrompt, cStatusText
		*++
		*>>Translate a menu bar identifier into the current language.
		* The translation is cached by bar number, so subsequent translations of the same 
		* bar will be very fast.
		*--
		  IF ALEN(THIS.aBarCache, 1) < m.nBar OR EMPTY(THIS.aBarCache[m.nBar, 1]) ;
		  OR NOT PROPER(m.cBarName) == THIS.aBarCache[m.nBar, 1]
		    * Reload the cache for this bar
		    IF ALEN(THIS.aBarCache, 1) < m.nBar
		      DIMENSION THIS.aBarCache[m.nBar, 3]
		    ENDIF
		
		    THIS.aBarCache[m.nBar, 1] = PROPER(m.cBarName)
		    THIS.aBarCache[m.nBar, 2] = m.cBarname            && Menu bar text
		    THIS.aBarCache[m.nBar, 3] = ''                    && Status bar text
		
		    IF LEFT(m.cBarName, 1) = '%' AND NOT ISNULL(THIS.oRegistry)
		      LOCAL cValue
		      m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.Context Menu Bars.' + SUBSTR(m.cBarName, 2), 'Message', '')
		      IF NOT EMPTY(m.cValue)
		        * Create a cmMessageValue object the first time we are called. This object
		        * knows how to unpack and interpret the value of Message keys.
		        IF NOT PEMSTATUS(THIS, 'cmTextValue', 5)
		          THIS.AddNewObject('cmTextValue', 'cmMessageValue')
		        ENDIF
		        THIS.cmTextValue.Scatter(m.cValue)
		        THIS.aBarCache[m.nBar, 2] = THIS.cmTextValue.GetText(MSGVAL_FIELD_PROMPT, THIS.nLanguageIndex)
		        THIS.aBarCache[m.nBar, 3] = THIS.cmTextValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex)
		      ENDIF
		    ENDIF
		  ENDIF
		
		  m.cPrompt = THIS.aBarCache[m.nBar, 2]
		  IF NOT EMPTY(THIS.aBarCache[m.nBar, 3])
		    m.cStatusText = THIS.aBarCache[m.nBar, 3]
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE translatehelp		&& Translate a Help message or Richtext identifier into the current language.
		LPARAMETERS cHelpID, cStatusText, cTipText, cRichText, cLinks
		*++
		*>>Translate a Help message or Richtext identifier into the current language.
		* Return .T. if translation was successful.
		*--
		LOCAL cValue, cKey
		
		  IF NOT ISNULL(THIS.oRegistry)
		    m.cKey = TRIM(IIF(LEFT(m.cHelpID, 1) = '%', SUBSTR(m.cHelpID, 2), m.cHelpID))
		    m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.Help Messages.' + m.cKey, 'Helptext', '')
		    IF NOT EMPTY(m.cValue)
		      * Create a cmHelpValue object the first time we are called. This object
		      * knows how to unpack and interpret the value of Help keys.
		      IF NOT PEMSTATUS(THIS, 'cmHelpValue', 5)
		        THIS.AddNewObject('cmHelpValue', 'cmHelpValue')
		      ENDIF
		
		      THIS.cmHelpValue.Scatter(m.cValue, PCOUNT() >= 4)
		      m.cStatusText = TRIM(THIS.cmHelpValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex))
		      m.cTipText = TRIM(THIS.cmHelpValue.GetText(MSGVAL_FIELD_TIP, THIS.nLanguageIndex))
		      IF PCOUNT() > 3
		        m.cRichText = THIS.cmHelpValue.GetText(MSGVAL_FIELD_RICH, THIS.nLanguageIndex)
		        m.cLinks = THIS.cmHelpValue.cLinks
		      ENDIF
		
		      * Free memory used to store translations, but keep object for faster translation next time.
		      THIS.cmHelpValue.Scatter('')
		      RETURN .T.
		    ENDIF
		  ENDIF
		
		  * No key found. Return failure.
		  STORE '' TO m.cRichText, m.cStatusText, m.cTipText, m.cLinks
		  RETURN .F.
		
	ENDPROC

	PROCEDURE translatestring		&& Translate a simple text string key into the current language.
		LPARAMETERS cTextID
		*++
		*>>Translate a simple text string key into the current language.
		* Returns translated text as Value.
		*--
		  IF LEFT(m.cTextID, 1) = '%' AND NOT ISNULL(THIS.oRegistry)
		    LOCAL cValue
		    m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.Text Strings.' + SUBSTR(m.cTextID, 2), 'Message', '')
		    IF NOT EMPTY(m.cValue)
		      * Create a cmMessageValue object the first time we are called. This object
		      * knows how to unpack and interpret the value of Message keys.
		      IF NOT PEMSTATUS(THIS, 'cmTextValue', 5)
		        THIS.AddNewObject('cmTextValue', 'cmMessageValue')
		      ENDIF
		
		      THIS.cmTextValue.Scatter(m.cValue)
		      RETURN THIS.cmTextValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex)
		    ENDIF
		  ENDIF
		
		  * Not in key format (no %) or no key found return original string.
		  RETURN m.cTextID
		
	ENDPROC

	PROCEDURE warning		&& Display a formatted warning message and return .F.
		LPARAMETERS cMessage, cP1, cP2, cP3, cP4
		*++
		*>>Display a formatted warning message and return .F.
		*--
		  THIS._LoadMessage(m.cMessage)
		  THIS.cmMessageValue.nIcon = MSG_SEVERITY_WARNING
		  THIS.cmMessageValue.nDialog = MSG_DIALOG_CONFIRM_OK
		
		  THIS.cFormattedText = THIS.Format(THIS.cmMessageValue.GetText(MSGVAL_FIELD_SHORT, THIS.nLanguageIndex), @m.cP1, @m.cP2, @m.cP3, @m.cP4)
		  THIS.DisplayLastMessage()
		  RETURN .F.
		
	ENDPROC

	PROCEDURE _getcallstack
		*++
		* Build a string representing the current Program call stack.
		*--
		LOCAL ix, cLine, cFile, cMethod, aCallStack[1], cStack
		
		  m.ix = 1
		  m.cStack = ''
		  DO WHILE NOT EMPTY(SYS(16,m.ix))
		    DIMENSION aCallStack[m.ix]
		    aCallStack[m.ix] = STR(m.ix, 2) + ' ' + SYS(16, m.ix)
		    m.ix = m.ix + 1
		  ENDDO
		
		  * Strip off this method, and one before us, if present, since these are normally after the error occured.
		  FOR ix = 1 to 2
		    IF ALEN(aCallStack) > 1
		      DIMENSION aCallStack[ALEN(aCallStack) - 1]
		    ENDIF
		  ENDFOR
		
		  * If called from an error method, strip that from the callback as well.
		  DO WHILE ALEN(aCallStack) > 1 ;
		  AND ('.ERROR ' $ aCallStack[ALEN(aCallStack)] + ' ' OR 'ON...' $ aCallStack[ALEN(aCallStack)])
		    DIMENSION aCallStack[ALEN(aCallStack) - 1]
		  ENDDO
		
		  * Re-sort so most recent call is first in list
		  =ASORT(aCallStack, 1, -1, 1)
		
		  FOR ix = 1 TO ALEN(aCallStack)
		    m.cLine = STRTRAN(ALLTRIM(LOWER(aCallStack[m.ix])), ' procedure ', ' ')
		    IF AT(' ', m.cLine, 2) > 0
		      m.cMethod = PROPER(STRTRAN(LEFT(m.cLine, AT(' ', m.cLine, 2) - 1), '.', '. '))
		      m.cFile = LOWER(SYS(2014, SUBSTR(m.cLine, AT(' ', m.cLine, 2) + 1)))
		      m.cMethod = STRTRAN(m.cMethod, '. ', '.')
		      m.cLine = m.cMethod + ' (' + m.cFile + ')'
		    ENDIF
		    m.cStack = m.cStack + m.cLine + CR_LF
		  ENDFOR
		  RETURN m.cStack
		
	ENDPROC

	PROCEDURE _initlanguages		&& Initialize internal language meta-data based on current language definitions in app registry.
		*++
		*>>Initialize internal language meta-data based on current language definitions in app registry.
		*--
		LOCAL ix, nCount, nIndex, cValue
		
		  * Set the default laguage for message keys. Only change the current language if none specified yet, 
		  * or the default language key value has been explicitly changed.
		  m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.Preferences.Default Language', KEY_TYPE_CHAR, 'English')
		  IF EMPTY(THIS.cLanguage) OR NOT THIS.cDefaultLanguage == m.cValue
		    STORE m.cValue TO THIS.cLanguage, THIS.cDefaultLanguage
		  ENDIF
		
		  * Build array of all languages, and their parents
		  m.nIndex = 0
		  m.nCount = 0
		  DO WHILE THIS.oRegistry.EnumKeys('%Local.Message.Languages', 'Language', @m.nIndex,,, @m.cValue) > 0
		    m.nCount = m.nCount + 1
		    DIMENSION THIS.aLanguages[m.nCount, 2]
		    THIS.cmLanguageValue.Scatter(@m.cValue)
		    THIS.aLanguages[m.nCount, LANGUAGE_ID] = THIS.cmLanguageValue.cLanguageID
		    THIS.aLanguages[m.nCount, LANGUAGE_PARENT] = THIS.cmLanguageValue.cParentLanguageID
		  ENDDO
		  ASSERT m.nCount > 0 MESSAGE 'No languages are defined under the "%Local.Message.Languages" appreg key.'
		
		  * Convert parent language ID column into array index for faster parent dereferencing.
		  FOR nIndex = 1 TO m.nCount
		    IF EMPTY(THIS.aLanguages[m.nIndex, LANGUAGE_PARENT])
		      THIS.aLanguages[m.nIndex, LANGUAGE_PARENT] = 0
		    ELSE
		      m.cValue = THIS.aLanguages[m.nIndex, LANGUAGE_PARENT]
		      FOR ix = 1 TO m.nCount
		        IF THIS.aLanguages[m.ix, LANGUAGE_ID] == m.cValue
		          THIS.aLanguages[m.nIndex, LANGUAGE_PARENT] = m.ix
		          EXIT
		        ENDIF
		      ENDFOR
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE _loadmessage		&& Lookup a message key, and load its values into a Message value object.
		LPARAMETERS cMsgKey
		*++
		*>>Lookup a message key, and load its values into a Message value object.
		* Returns .T. if a message key was found, .F. otherwise.
		*--
		LOCAL cValue
		  IF NOT PEMSTATUS(THIS, 'cmMessageValue', 5)
		    THIS.AddNewObject('cmMessageValue', 'cmMessageValue')
		  ENDIF
		
		  * If it is in key format (begins with %) find the key in the registry.
		  IF LEFT(m.cMsgKey, 1) = '%' AND LEN(m.cMsgKey) > 1 AND NOT ISNULL(THIS.oRegistry)
		    m.cValue = THIS.oRegistry.GetKeyValue('%Local.Message.System Messages.' + SUBSTR(m.cMsgKey, 2), 'Message', '')
		  ENDIF
		  THIS.cmMessageValue.Scatter((m.cValue))
		  IF EMPTY(m.cValue)
		    THIS.cmMessageValue.SetText(THIS.cLanguageID, m.cMsgKey)
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmmessagevalue AS cmdatatransport OF "cmdataa.vcx" 		&& Pack and unpack Message key values.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: deletetext		&& Delete the message text for the specified language.
		*m: gettext		&& Get short message text for specified language.
		*m: hastranslation		&& Return .T. if the key has any explicit translations for the specified language.
		*m: settext		&& Set the message text for the specified language.
		*p: cnumber
		*p: ncount
		*p: ndefault
		*p: ndialog
		*p: nicon
		*p: nmsgtype
		*p: omessage
		*a: atext[1,4]
	*</DefinedPropArrayMethod>

	cnumber = 
	Name = "cmmessagevalue"
	ncount = 0
	ndefault = 0
	ndialog = 0
	nicon = 0
	nmsgtype = 0
	omessage = .NULL.
	
	PROCEDURE deletetext		&& Delete the message text for the specified language.
		LPARAMETERS cLanguageID
		*++
		*>>Delete the message text for the specified language.
		*--
		LOCAL ix
		  FOR ix = 1 TO THIS.nCount
		    IF THIS.aText[m.ix, MSGVAL_LANG_ID] = m.cLanguageID
		      =ADEL(THIS.aText, m.ix)
		      THIS.nCount = THIS.nCount - 1
		      IF THIS.nCount > 0
		        DIMENSION THIS.aText[THIS.nCount, 4]
		      ENDIF
		      EXIT
		    ENDIF
		  ENDFOR
		  RETURN .T.
		
	ENDPROC

	PROCEDURE gather
		*++
		*>>Gather all the type specific value parameters into one string field.
		*--
		LOCAL ix, cValue, cText
		
		  * Store message type and number. Leave one extra line for future extensions.
		  m.cValue = STR(THIS.nMsgType, 2) + CR_LF + THIS.cNumber + CR_LF + CR_LF
		
		  * Add additional dialog-specific fields now, plus an extra blank line.
		  IF THIS.nMsgType = MSG_TYPE_DIALOG
		    m.cValue = m.cValue + STR(THIS.nIcon,2) + CR_LF ;
		       + STR(THIS.nDialog, 2) + CR_LF + STR(THIS.nDefault, 1) + CR_LF + CR_LF
		  ENDIF
		
		  * Now store the actual message text for each language.
		  FOR ix = 1 TO THIS.nCount
		     * Short message text as a counted string. All types have this.
		     m.cText = THIS.aText[m.ix, MSGVAL_LANG_ID] + CR_LF ;
		              + STR(LEN(THIS.aText[m.ix, MSGVAL_FIELD_SHORT]), 5) + CR_LF + THIS.aText[m.ix, MSGVAL_FIELD_SHORT] + CR_LF
		
		     * Add explaination text for msgtypes that have it.
		     IF THIS.nMsgType = MSG_TYPE_DIALOG
		       m.cText = m.cText + STR(LEN(THIS.aText[m.ix, MSGVAL_FIELD_LONG]), 5) + CR_LF + THIS.aText[m.ix, MSGVAL_FIELD_LONG] + CR_LF
		     ENDIF
		
		     * Add tooltip/prompt text as appropriate (no multiline support on this one)
		     IF THIS.nMsgType = MSG_TYPE_PROMPT
		       m.cText = m.cText + THIS.aText[m.ix, MSGVAL_FIELD_PROMPT] + CR_LF
		     ENDIF
		     m.cValue = m.cValue + m.cText
		  ENDFOR
		  RETURN m.cValue
		
	ENDPROC

	PROCEDURE gettext		&& Get short message text for specified language.
		LPARAMETERS nField, nLangIx, cLanguageID, cDefault
		*++
		*>>Get short message text for specified language.
		*--
		LOCAL ix
		  IF EMPTY(m.cLanguageID)  && If ID is empty, language index must be specified.
		    IF NOT EMPTY(m.nLangIx)
		      m.cLanguageID = THIS.oMessage.aLanguages[m.nLangIx, LANGUAGE_ID]
		    ENDIF
		  ENDIF
		
		  IF NOT EMPTY(m.cLanguageID)
		    FOR ix = 1 TO THIS.nCount
		      IF THIS.aText[m.ix, MSGVAL_LANG_ID] == m.cLanguageID
		        IF LEN(THIS.aText[m.ix, m.nField]) > 0
		          RETURN THIS.aText[m.ix, m.nField]
		        ENDIF
		        EXIT
		      ENDIF
		    ENDFOR
		
		    * If no translation found, try parent language, if any.
		    IF THIS.nCount > 1
		      IF EMPTY(m.nLangIx)
		        m.nLangIx = ASCAN(THIS.oMessage.aLanguages, m.cLanguageID)
		        m.nLangIx = ASUBSCRIPT(THIS.oMessage.aLanguages, m.nLangIx, 1)
		      ENDIF
		      m.nLangIx = THIS.oMessage.aLanguages[m.nLangIx, LANGUAGE_PARENT]
		      IF NOT EMPTY(m.nLangIx)
		        RETURN THIS.GetText(m.nField, m.nLangIx,,m.cDefault)
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * If still no translation found, return caller specified default.
		  IF PCOUNT() >= 4 AND TYPE('m.cDefault') == 'C'
		    RETURN m.cDefault
		  ENDIF
		  RETURN THIS.aText[1, m.nField]  && Last resort, return text for first defined language.
		
	ENDPROC

	PROCEDURE hastranslation		&& Return .T. if the key has any explicit translations for the specified language.
		LPARAMETERS cLanguageID, nField
		*++
		*>>Return .T. if the key has any explicit translations for the specified language.
		*--
		LOCAL ix
		  FOR ix = 1 TO THIS.nCount
		    IF THIS.aText[m.ix, MSGVAL_LANG_ID] == m.cLanguageID
		      * If optional item parameter is specified, must have an explicit translation for that item.
		      RETURN PCOUNT() = 1 OR LEN(THIS.aText[m.ix, m.nField]) > 0
		    ENDIF
		  ENDFOR
		  RETURN THIS.nCount = 0    && A new value with no default translations returns .T. also
		
	ENDPROC

	PROCEDURE Init
		  * Load reference to message object, for access to language
		  THIS.oMessage = FindGlobalObject('cmMessage')
		
	ENDPROC

	PROCEDURE scatter
		LPARAMETERS cValue
		*++
		*>>Break the compound value string into its individual components.
		*--
		LOCAL nMemoWidth
		
		  DIMENSION THIS.aText[1, 4]
		  THIS.aText = ''
		
		  _MLINE = 0
		  THIS.nCount = 0
		  IF EMPTY(m.cValue)
		    THIS.nMsgType = MSG_TYPE_DIALOG
		    THIS.nIcon = MSG_SEVERITY_INFORM
		    THIS.nDialog = MSG_DIALOG_INFORM
		    THIS.nDefault = 1
		  ELSE
		    m.nMemoWidth = SET('MEMOWIDTH')
		    SET MEMOWIDTH TO 512
		
		    THIS.nMsgType = VAL(MLINE(m.cValue, 1, _MLINE))
		    THIS.cNumber = MLINE(m.cValue, 1, _MLINE)
		    MLINE(m.cValue, 1, _MLINE)   && Placeholder for expansion
		
		    IF THIS.nMsgType = MSG_TYPE_DIALOG
		      THIS.nIcon = VAL(MLINE(m.cValue, 1, _MLINE))
		      THIS.nDialog = VAL(MLINE(m.cValue, 1, _MLINE))
		      THIS.nDefault = VAL(MLINE(m.cValue, 1, _MLINE))
		      MLINE(m.cValue, 1, _MLINE)   && Placeholder for expansion
		    ENDIF
		
		    DO WHILE _MLINE < LEN(m.cValue) - 1
		      DIMENSION THIS.aText[THIS.nCount + 1, 4]
		      THIS.aText[THIS.nCount + 1, MSGVAL_LANG_ID] = MLINE(m.cValue, 1, _MLINE)    && Language ID
		
		      IF LEN(THIS.aText[THIS.nCount + 1, 1]) > 0
		        THIS.nCount = THIS.nCount + 1
		
		        * Strings are stored as length on one line, then text to allow line breaks in text.
		        m.nLength = VAL(MLINE(m.cValue, 1, _MLINE))    && Length of Short Text
		        THIS.aText[THIS.nCount, MSGVAL_FIELD_SHORT] = SUBSTR(m.cValue, _MLINE + 2, m.nLength)
		        _MLINE = _MLINE + m.nLength + 2
		
		        * Get explaination text for msgtypes that have it.
		        IF THIS.nMsgType = MSG_TYPE_DIALOG
		          m.nLength = VAL(MLINE(m.cValue, 1, _MLINE))    && Length of Long Text
		          THIS.aText[THIS.nCount, MSGVAL_FIELD_LONG] = SUBSTR(m.cValue, _MLINE + 2, m.nLength)
		          _MLINE = _MLINE + m.nLength + 2
		        ELSE
		          THIS.aText[THIS.nCount, MSGVAL_FIELD_LONG] = ''
		        ENDIF
		
		        * Parse out tooltip/prompt text as appropriate (no multiline support on this one)
		        IF THIS.nMsgType = MSG_TYPE_PROMPT
		          THIS.aText[THIS.nCount, MSGVAL_FIELD_PROMPT] = MLINE(m.cValue, 1, _MLINE)    && Tooltip/Prompt text
		        ELSE
		          THIS.aText[THIS.nCount, MSGVAL_FIELD_PROMPT] = ''
		        ENDIF
		      ENDIF
		    ENDDO
		
		    SET MEMOWIDTH TO (m.nMemoWidth)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE settext		&& Set the message text for the specified language.
		LPARAMETERS cLanguageID, cText, cLongtext, cPromptText
		*++
		*>>Set the message text for the specified language.
		*--
		LOCAL ix
		  FOR ix = 1 TO THIS.nCount
		    IF THIS.aText[m.ix, MSGVAL_LANG_ID] = m.cLanguageID
		      EXIT
		    ENDIF
		  ENDFOR
		
		  IF m.ix > THIS.nCount
		    THIS.nCount = m.ix
		    DIMENSION THIS.aText[m.ix, 4]
		    THIS.aText[m.ix, MSGVAL_LANG_ID] = m.cLanguageID
		    THIS.aText[m.ix, MSGVAL_FIELD_SHORT] = ''
		    THIS.aText[m.ix, MSGVAL_FIELD_LONG] = ''
		    THIS.aText[m.ix, MSGVAL_FIELD_PROMPT] = ''
		  ENDIF
		
		  IF TYPE('m.cText') = 'C'
		    THIS.aText[m.ix, MSGVAL_FIELD_SHORT] = m.cText
		  ENDIF
		  IF TYPE('m.cLongText') = 'C'
		    THIS.aText[m.ix, MSGVAL_FIELD_LONG] = m.cLongText
		  ENDIF
		  IF TYPE('m.cPromptText') = 'C'
		    THIS.aText[m.ix, MSGVAL_FIELD_PROMPT] = m.cPromptText
		  ENDIF
		
	ENDPROC

ENDDEFINE
