*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmgadget.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
*< LIBCOMMENT: CodeMine custom interface Gadgets. Copyright 1997 Soft Classics, Ltd. />
*
DEFINE CLASS cboquickfill AS cbocomboboxcustom OF "..\custom\ccontrol.vcx" 		&& CodeMine Quickfill Combo Box
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: value_access
		*m: value_assign
		*p: cblanktext		&& Text displayed when no list record matches the parent key value when cRelationTag is used.
		*p: cfilter		&& Filter expression applied to cListworkarea to restrict the available records.
		*p: clistexpression		&& Expression to evaluate for each list item. Usually a field name in the cListWorkarea cursor.
		*p: clistsuffix		&& Suffix expression appended to cListexpression only for items displayed in the popup.
		*p: clistworkarea		&& Workarea of list item cursor
		*p: crelationexpression		&& Expression (based on fields in cListWorkarea) to evaluate to produce value stored to bound source.
		*p: crowsource		&& Comma separated list of possible values for the control. Leave empty to use cursor specified in cListWorkarea.
		*p: lallowexceptions
		*p: lexactcase
		*p: lpropercase		&& Set to .T. if manuallyentered items should be set to Proper case.
		*p: npopupkeycode
		*p: npopuprows		&& Max number of popup rows to display.
		*p: nspacemode		&& Determines the behaviour of the Space key in quickfill: 0 = Advance one space, 1 = advance to next word break
	*</DefinedPropArrayMethod>

	BoundTo = .T.
	cblanktext = 		&& Text displayed when no list record matches the parent key value when cRelationTag is used.
	cfilter = 		&& Filter expression applied to cListworkarea to restrict the available records.
	clistexpression = 		&& Expression to evaluate for each list item. Usually a field name in the cListWorkarea cursor.
	clistsuffix = 		&& Suffix expression appended to cListexpression only for items displayed in the popup.
	clistworkarea = 		&& Workarea of list item cursor
	crelationexpression = 		&& Expression (based on fields in cListWorkarea) to evaluate to produce value stored to bound source.
	crowsource = 		&& Comma separated list of possible values for the control. Leave empty to use cursor specified in cListWorkarea.
	lpropercase = .F.		&& Set to .T. if manuallyentered items should be set to Proper case.
	Name = "cboquickfill"
	npopupkeycode = (ASC('?'))
	npopuprows = 5		&& Max number of popup rows to display.
	nspacemode = 1		&& Determines the behaviour of the Space key in quickfill: 0 = Advance one space, 1 = advance to next word break
	SelectOnEntry = .T.
	Style = 0
	
	PROCEDURE Click
		IF THIS.SelLength = 0
		  THIS.SelStart=0
		  THIS.SelLength = LEN(TRIM(NVL(THIS.DisplayValue,'')))
		ENDIF
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE contextmenubuild
		IF NOT THIS.lWritelock
		  THISFORM.ContextMenuBar(CTX_BAR_CTL_QUICKPOP, '%barquickpopup')
		  THISFORM.ContextMenuSeparator(CTX_BAR_CTL_QUICK_SEP)
		ENDIF
		
		RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETERS cOption
		
		IF m.cOption == '%barquickpopup'
		  RETURN THISFORM.cmQuickfillSupport.ShowPopup(THIS, LEFT(THIS.Value, IIF(THIS.SelLength > 0, THIS.SelStart, 0)))
		ENDIF
		
		IF DODEFAULT(@m.cOption)
		  IF m.cOption == '%barrevert'
		    THIS.SelStart = 0
		    THIS.SelLength = LEN(TRIM(THIS.Value))
		  ENDIF
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE DropDown
		LOCAL cValue
		  m.cValue = TRIM(THIS.Value)
		  IF THIS.SelLength > 0
		    m.cValue = LEFT(m.cValue, THIS.SelStart)
		  ENDIF
		  THISFORM.cmQuickfillSupport.ShowPopup(THIS, m.cValue)
		
	ENDPROC

	PROCEDURE GotFocus
		THIS.SelStart=0
		THIS.SelLength = LEN(TRIM(NVL(THIS.value,'')))
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE Init
		  ASSERT EMPTY(THIS.RowSource) MESSAGE THIS.Name + ' RowSource must be Empty. Use cRowSource for Quickfill Combo'
		
		  IF NOT PEMSTATUS(THISFORM, 'cmQuickfillSupport', 5)
		    THISFORM.AddNewObject('cmQuickfillSupport', 'cmQuickfillSupport')
		  ENDIF
		
		  THISFORM.cmQuickfillSupport.QuickFillInit(THIS)
		  DODEFAULT()
		
		  * If in a grid, value is not loaded on init. Make sure it is at least set to a character type.
		  * Must only be done after default init() code completes (and native controlSource is cleared)
		  * or VFP access violation errors may result in VFP8 SP1.
		  THIS.BoundTo = .T.
		  THIS.RowSourceType = 0
		  IF THIS.Parent.BaseClass == 'Column'
		    THIS.Value = ''
		  ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		LOCAL cValue
		
		IF DODEFAULT()
		  * Don't trim explicitly entered trailing spaces.
		  IF THIS.SelStart > LEN(TRIM(THIS.DisplayValue))
		    m.cValue = LEFT(THIS.DisplayValue, THIS.SelStart)
		  ELSE
		    m.cValue = TRIM(THIS.DisplayValue)
		  ENDIF
		
		  * Apply quick fill value if one can be found
		  THISFORM.cmQuickfillSupport.QuickFill(THIS, m.cValue)
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Process special keys for incremental search text boxes
		*--
		  IF THISFORM.cmQuickfillSupport.ProcessKey(THIS, m.nKeyCode)
		    NODEFAULT
		    RETURN .T.
		  ENDIF
		  RETURN DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
	ENDPROC

	PROCEDURE loadtranslation
		LPARAMETER cValue
		
		  IF THISFORM.cmQuickfillSupport.LoadTranslation(THIS, @m.cValue)
		    RETURN DODEFAULT(m.cValue)   && Execute Default Custom Class code
		  ENDIF
		  RETURN m.cValue
		
	ENDPROC

	PROCEDURE loadvalue
		IF DODEFAULT()
		  * If a value was loaded from a bound data source, remember it as last valid value
		  * This is used to restore value after a bad key is pressed, and optimize out
		  * redundant calls to AfterChange() while typing in the quickfill.
		  THIS.cLastValue = THIS.Value
		  THIS.nLastPos = 0
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE Refresh
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    IF NOT PEMSTATUS(THISFORM, 'cmQuickfillSupport', 5)
		      THISFORM.AddNewObject('cmQuickfillSupport', 'cmQuickfillSupport')
		    ENDIF
		    THISFORM.cmQuickfillSupport.QuickFillInit(THIS)
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE setvalue
		LPARAMETERS cNewValue
		
		* Remember the last value set, so it can be restored after an invalid entry
		IF DODEFAULT(@m.cNewValue)
		  THIS.nLastPos = 0
		  THIS.cLastValue = THIS.Value
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE storetranslation
		LPARAMETERS cValue
		LOCAL nSelect, cListExpr, cListValue
		
		IF NOT EMPTY(THIS.cListWorkarea)
		  m.nSelect = SELECT()
		  SELECT (THIS.cListWorkarea)
		
		  * Make sure the list record that matches displayed expression is current.
		  m.cListExpr = THIS.cListExpression
		  m.cListValue = EVALUATE(m.cListExpr)
		  IF NOT TRIM(m.cListValue) == TRIM(m.cValue)
		    IF THIS.lExactCase
		      LOCATE FOR &cListExpr == PADR(m.cValue, LEN(&cListExpr))
		    ELSE
		      LOCATE FOR UPPER(&cListExpr) == PADR(UPPER(m.cValue), LEN(&cListExpr))
		    ENDIF
		  ENDIF
		
		  * If a different relation expression is specified, evaluate it for result to store.
		  IF NOT EMPTY(THIS.cRelationExpression)
		    m.cValue = EVALUATE(THIS.cRelationExpression)
		  ENDIF
		  SELECT (m.nSelect)
		ENDIF
		RETURN DODEFAULT(m.cValue)
		
	ENDPROC

	PROCEDURE Valid
		IF THIS.lPropercase AND THIS.lChanged AND THIS.lException
		  THIS.Value = THISFORM.oString.ProperCase(THIS.DisplayValue)
		ENDIF
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE value_access
		* For quickfill, value must always return the displayed text value.
		RETURN THIS.DisplayValue
		
	ENDPROC

	PROCEDURE value_assign
		LPARAMETERS vNewVal
		*++
		* For quickfill, value and DisplayValue must always match.
		*--
		  * Allowing the value to be modified befoer the native controlSource is cleared
		  * will cause bound data to be marked as modified, so we can't allow that.
		  IF EMPTY(THIS.ControlSource)
		    THIS.Value = m.vNewVal
		    THIS.DisplayValue = m.vNewVal
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdadjustablelistheader AS cmdcommandbuttoncustom OF "..\custom\ccontrol.vcx" 		&& Header buttons used internally by cntAdjustableList
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\no.bmp" ClassIcon="..\graphics\no.bmp" />

	#INCLUDE "win32.h"
	*<DefinedPropArrayMethod>
		*p: ncolumn		&& The list column this button is associated with.
		*p: nleftlimit		&& Left boundry for moving this divider.
	*</DefinedPropArrayMethod>

	AutoSize = .F.
	FontName = "MS Sans Serif"
	Height = 18
	Name = "cmdadjustablelistheader"
	ncolumn = 0		&& The list column this button is associated with.
	Width = 145
	
	PROCEDURE Click
		  * If style is 0 (standard) then this is a column header button.
		  IF THIS.Style = 0
		    THIS.Parent.SortColumn(THIS.nColumn)
		  ENDIF
		  THIS.Parent.lstColumnList.Setfocus()
		
	ENDPROC

	PROCEDURE RightClick
		* Heador Buttons inherit context menu from the main listbox.
		THIS.Parent.lstColumnList.RightClick()
		
	ENDPROC

	PROCEDURE When
		LOCAL nLeftBase, nTopBase, oParent, nRlimit, nCol
		LOCAL nHFoxelToFormUnits, nHPixelToFormUnits, nVPixelToFormUnits
		LOCAL nUsed, nWidth, cWidths, cNewWidths, nCursorHandle
		LOCAL nLineTop, nLineBot, nLineCol, mDrawCol, nOldDrawmode, nOldDrawWidth
		
		  * If we're invisible, then this is a column divider mover button.
		  IF THIS.Style = 1
		    m.nHFoxelToFormUnits = IIF(THISFORM.ScaleMode = 3, FONTMETRIC(6), 1)
		    m.nHPixelToFormUnits = IIF(THISFORM.ScaleMode = 0, FONTMETRIC(6), 1)
		    m.nVPixelToFormUnits = IIF(THISFORM.ScaleMode = 0, FONTMETRIC(1) + FONTMETRIC(5), 1)
		
		    m.nOldDrawmode = THISFORM.Drawmode
		    m.nOldDrawWidth = THISFORM.DrawWidth
		    THISFORM.DrawMode = 6  && Invert Pen
		    THISFORM.DrawWidth = 1
		
		    m.nTopBase = (OBJTOCLIENT(THIS, 1) * m.nVPixelToFormUnits) - THIS.Top
		    m.nLeftBase = (OBJTOCLIENT(THIS, 2) * m.nHPixelToFormUnits) - THIS.Left
		
		    * Draw temporary positioning guide line at current divider position.
		    m.nLineTop = THIS.Top + m.nTopBase
		    m.nLineBot = m.nLineTop + THIS.height + THIS.Parent.lstColumnList.height - (4 / m.nVPixelToFormUnits)
		    m.nLineCol = THIS.Left + (THIS.width / 2) - (1 / m.nHPixelToFormUnits)
		    IF THISFORM.ScaleMode = 3
		      m.nLineCol = INT(m.nLineCol)
		    ENDIF
		    m.nDrawCol = m.nLineCol + m.nLeftBase
		    THISFORM.Line(m.nDrawCol, m.nLineTop, m.nDrawCol, m.nLineBot)
		
		    m.nCursorHandle = GetMouseCursor()
		    m.nRlimit = THIS.Parent.lstColumnList.left ;
		              + THIS.Parent.lstColumnList.width - ((SYSMETRIC(5) + 3) / m.nHPixelToFormUnits)
		
		    DO WHILE MDOWN()
		      IF MCOL() < 0
		        m.nCol = -1
		      ELSE
		        m.nCol = MCOL(WONTOP()) * m.nHFoxelToFormUnits - m.nLeftBase
		        m.nCol = MAX(MIN(m.nRlimit, m.nCol), THIS.nLeftLimit)
		      ENDIF
		      IF m.nLineCol != m.nCol
		        IF m.nLineCol > 0  && Clear old line
		          THISFORM.Line(m.nDrawCol, m.nLineTop, m.nDrawCol, m.nLineBot)
		        ENDIF
		        m.nLineCol = m.nCol
		        m.nDrawCol = m.nLineCol + m.nLeftBase
		        IF m.nLineCol > 0  && Draw new line if cursor is still in the window
		          THISFORM.Line(m.nDrawCol, m.nLineTop, m.nDrawCol, m.nLineBot)
		        ENDIF
		      ENDIF
		      =SetMouseCursor(m.nCursorHandle)
		    ENDDO
		    IF m.nLineCol > 0  && Clear positioning line.
		      THISFORM.Line(m.nDrawCol, m.nLineTop, m.nDrawCol, m.nLineBot)
		    ENDIF
		
		    * Edit the column width string to define new column widths
		    IF m.nLineCol >= 0
		      m.nUsed = (2 + IIF(THIS.Parent.lstColumnList.Moverbars, 18, 0) / m.nHPixelToFormUnits)
		      m.cWidths = THIS.Parent.lstColumnList.ColumnWidths
		      m.cNewWidths  = ''
		      FOR ix = 1 TO THIS.Parent.lstColumnList.ColumnCount
		        IF m.ix = THIS.nColumn
		          m.nWidth = m.nLineCol - THIS.Parent.lstColumnList.left - m.nUsed - (2 / m.nHPixelToFormUnits)
		        ELSE
		          * Comma may be used as decimal point in some locales, so replace with X before VAL().
		          m.nWidth  = VAL(STRTRAN(m.cWidths, ',', 'X'))
		        ENDIF
		        m.nUsed = m.nUsed + m.nWidth + (3 / m.nHPixelToFormUnits)
		        m.cWidths = SUBSTR(m.cWidths, AT(',', m.cWidths) + 1)
		        m.cNewWidths = m.cNewWidths + LTRIM(STR(m.nWidth)) + IIF(m.ix = THIS.Parent.lstColumnList.ColumnCount, '', ',')
		      ENDFOR
		      THIS.Parent.lstColumnList.ColumnWidths = m.cNewWidths
		      THIS.Parent.SetColumnWidths()
		    ENDIF
		
		    THISFORM.DrawMode = m.nOldDrawmode
		    THISFORM.DrawWidth = m.nOldDrawWidth
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmquickfillsupport AS cmserviceabstract OF "cmdataa.vcx" 		&& CodeMine Quick-fill Control Common Support Code
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: loadtranslation		&& If there is a cRelationExpression we need to look up the source record to evaluate the cListExpression.
		*m: processkey		&& Process special keys for incremental search controls
		*m: quickfill		&& Find the first item that matches the specified value.
		*m: quickfillinit		&& Common Initialization code for quickfil textboxes.
		*m: showpopup		&& Build and Display the dropdown list of available options
		*m: swquickfill
	*</DefinedPropArrayMethod>

	Name = "cmquickfillsupport"
	
	PROCEDURE loadtranslation		&& If there is a cRelationExpression we need to look up the source record to evaluate the cListExpression.
		LPARAMETERS oThis, cValue
		*++
		*>>If there is a cRelationExpression we need to look up the source record to evaluate the cListExpression.
		*
		* The cValue parameter is both input and output paramater, passed by reference.
		*--
		LOCAL nSelect, cExpr
		
		  WITH m.oThis
		    * If we are allowing exceptions on a cursor source, then we need 
		    * to lookup to set the lException flag for the value.
		    IF NOT EMPTY(.cListWorkarea) ;
		    AND (NOT EMPTY(.cRelationExpression) OR .lAllowExceptions)
		      m.nSelect = SELECT()
		      SELECT (.cListWorkarea)
		
		      * Find the list record that matches the specified relation key.
		      * Use LOCATE so an index will be used if present (Rushmore), but is not required.
		      IF EMPTY(.cRelationExpression)
		        m.cExpr = .cListExpression
		      ELSE
		        m.cExpr = .cRelationExpression
		      ENDIF
		      LOCATE FOR &cExpr == m.cValue
		      IF FOUND()
		        .lException = .F.
		        m.cValue = EVALUATE(.cListExpression)
		      ELSE
		        * No matching record was found for the specified key.
		        .lException = .T.
		        IF NOT EMPTY(.cRelationExpression) AND NOT ISNULL(.cBlankText)
		          IF EMPTY(m.cValue)
		            m.cValue = ''
		          ELSE
		            m.cValue = .cBlankText
		          ENDIF
		          SELECT (m.nSelect)
		          RETURN .F.   && Do not apply default translation code to this value.
		        ENDIF
		      ENDIF
		      SELECT (m.nSelect)
		    ENDIF
		  ENDWITH
		  RETURN .T.
		
	ENDPROC

	PROCEDURE processkey		&& Process special keys for incremental search controls
		LPARAMETERS oThis, nKeyCode
		*++
		*>>Process special keys for incremental search controls
		*--
		  WITH m.oThis
		    DO CASE
		    CASE m.nKeyCode == .nPopupKeycode
		      LOCAL cValue
		      m.cValue = TRIM(.Value)
		      IF .SelLength > 0
		        m.cValue = LEFT(m.cValue, .SelStart)
		      ENDIF
		      THIS.ShowPopup(m.oThis, m.cValue)
		      RETURN .T.
		
		    CASE m.nKeyCode = 127 AND .SelLength > 0    && Rubout/backspace
		      * Handle deletion when text is selected
		      IF .lChanged OR .BeforeChange()
		        .SelStart = MAX(.SelStart - 1, 0)
		        THIS.QuickFill(m.oThis, LEFT(.Value, .SelStart))
		        RETURN .T.
		      ENDIF
		
		    CASE m.nKeyCode = 1                     && Home
		      IF .SelLength >= LEN(TRIM(.Value))
		        .SelStart = 0
		        .SelLength = 0
		      ELSE
		        .SelStart = 0
		        .SelLength = LEN(TRIM(.Value))
		      ENDIF
		      .nLastPos = .SelStart
		      RETURN .T.
		
		    CASE m.nKeyCode = 6                     && End
		      .SelStart = LEN(TRIM(.Value))
		      .nLastPos = .SelStart
		      RETURN .T.
		
		    CASE m.nKeyCode = 26 AND .SelStart > 0  && CTRL + Left Arrow
		      .SelStart = RAT(' ', LEFT(.Value, .SelStart - 1))
		      .SelLength = MAX(LEN(TRIM(.Value)) - .SelStart, 0)
		      .nLastPos = .SelStart
		      RETURN .T.
		    CASE m.nKeyCode = 19 AND .SelStart > 0 AND (.SelLength > 0 OR NOT .lAllowExceptions)
		      * Left (Back) Arrow
		      .SelStart = MAX(.SelStart - 1, 0)
		      .SelLength = MAX(LEN(TRIM(.Value)) - .SelStart, 0)
		      .nLastPos = .SelStart
		      RETURN .T.
		
		    CASE m.nKeyCode = 2 AND .SelLength > 0
		      * CTRL + Right Arrow - .SelLength should only be 0 when cursor is at end of value.
		      LOCAL nOffset
		      m.nOffset = AT(' ', SUBSTR(TRIM(.Value), .SelStart + 1) + ' ')
		      .SelStart = MIN(.SelStart + m.nOffset, LEN(TRIM(.Value)))
		      .SelLength = MAX(LEN(TRIM(.Value)) - .SelStart, 0)
		      .nLastPos = .SelStart
		      RETURN .T.
		    CASE m.nKeyCode = 4 AND .SelLength > 0 && AND NOT .lAllowExceptions
		      * Right (Forward) Arrow - .SelLength should only be 0 when cursor is at end of value.
		      * .SelLength must be < LEN(.Value) in a grid so that right arrow 
		      * with all selected (as on initial entry) will move to next cell.
		      IF .SelLength < LEN(.Value) OR NOT .Parent.Baseclass == 'Column'
		        .SelStart = MIN(.SelStart + 1, LEN(TRIM(.Value)))
		        .SelLength = MAX(LEN(TRIM(.Value)) - .SelStart, 0)
		        .nLastPos = .SelStart
		        RETURN .T.
		      ENDIF
		
		    CASE m.nKeyCode = ASC(' ') AND NOT .lAllowExceptions
		      * Space - Advance to the next character position
		      .SelStart = MIN(.SelStart + 1, MAX(LEN(.Value), LEN(TRIM(.Value)) + 1))
		      IF .nSpaceMode = 1
		        * Advance to the next word break
		        LOCAL ix
		        FOR ix = .SelStart TO LEN(.Value)
		          IF SUBSTR(.Value, m.ix, 1) == ' '
		            EXIT
		          ENDIF
		          .SelStart = .SelStart + 1
		        ENDFOR
		      ENDIF
		      .SelLength = MAX(LEN(TRIM(.Value)) - .SelStart, 0)
		      .nLastPos = .SelStart
		      RETURN .T.
		    ENDCASE
		  ENDWITH
		  RETURN .F.
		
	ENDPROC

	PROCEDURE quickfill		&& Find the first item that matches the specified value.
		LPARAMETERS oThis, cValue
		RETURN (this.swquickfill(oThis,cValue))
		
		*++
		*>>Find the first item that matches the specified value.
		*--
		LOCAL lExact, nSelect, nPos, cNewValue, lFound, cFilter
		
		  * If the field is not blank then search for a quick fill value.
		  WITH m.oThis
		    m.nPos = 0
		    m.cNewValue = ''
		    IF NOT EMPTY(m.cValue)
		      m.nPos = .SelStart          && Save cursor position
		
		      * Preserve original SET EXACT setting.
		      m.lExact = (SET('EXACT') = 'ON')
		      SET EXACT OFF
		      IF NOT EMPTY(.cRowSource)   && Items come from cRowSorce string
		        LOCAL cItem, cRowSource
		        m.cRowSource = .cRowSource
		        DO WHILE NOT EMPTY(m.cRowSource)
		          m.cItem = ALLTRIM(GetToken(@m.cRowSource, ','))
		          IF UPPER(m.cItem) = UPPER(m.cValue)
		            m.lFound = .T.
		            m.cNewValue = PADR(m.cItem, 128)  && Pad to a fixed length
		            EXIT
		          ENDIF
		        ENDDO
		      ELSE                            && Items come from cListWorkarea cursor
		        m.nSelect = SELECT()
		        IF NOT EMPTY(.cListWorkarea)
		          SELECT (.cListWorkarea)
		
		          * Use display expression to locate matches.
		          m.cFilter = IIF(EMPTY(.cFilter), '.T.', .cFilter)
		          m.cExpr = .cListExpression
		          IF .lExactCase
		            LOCATE FOR &cExpr = m.cValue AND &cFilter
		          ELSE
		            LOCATE FOR UPPER(&cExpr) = UPPER(m.cValue) AND &cFilter
		          ENDIF
		          m.cNewValue = EVALUATE(m.cExpr)
		          m.lFound = FOUND()
		          SELECT (m.nSelect)
		        ENDIF
		      ENDIF
		      IF m.lExact 
		        SET EXACT ON
		      ENDIF
		
		      IF NOT m.lFound
		        IF .lAllowExceptions
		          IF NOT .lException
		            .lException = .T.
		            IF NOT .SetValue(m.cValue)
		              m.nPos = .nLastPos
		              .Value = .cLastValue
		            ENDIF
		          ELSE
		            .Value = m.cValue
		          ENDIF
		          STORE m.nPos TO .SelStart, .nLastPos
		          RETURN .T.
		        ELSE
		          ??CHR(7)   && Invalid character(s) entered, restore previous state of the control.
		          IF NOT EMPTY(.cLastValue)
		            m.nPos = .nLastPos
		            m.cNewValue = .cLastValue
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		
		    * Calling SetValue() here means Afterchange() will fire after each new value.
		    .lException = .F.
		    IF NOT m.cNewValue == .Value OR NOT m.cNewValue == .cLastValue
		      IF m.cNewValue == .cLastValue
		        .Value = m.cNewValue
		      ELSE
		        * Call SetValue() only when displayed value is actually different 
		        * than last time it was set.
		        IF NOT .SetValue(m.cNewValue)
		          m.nPos = .nLastPos
		          .Value = .cLastValue
		        ENDIF
		      ENDIF
		      STORE m.nPos TO .SelStart, .nLastPos
		    ENDIF
		
		    IF .lAllowExceptions
		      .SelStart = MIN(.SelStart, LEN(m.cValue))
		    ELSE
		      .SelStart = MIN(.SelStart, LEN(TRIM(.Value)))
		    ENDIF
		
		    * Highlight the text that was NOT keyed by the user
		    .SelLength = MAX(0, LEN(TRIM(.Value)) - .SelStart)
		  ENDWITH
		
	ENDPROC

	PROCEDURE quickfillinit		&& Common Initialization code for quickfil textboxes.
		LPARAMETERS oThis
		*++
		*>>Common Initialization code for quickfil textboxes.
		*--
		
		  WITH m.oThis
		    .AddProperty('cLastValue', '')
		    .AddProperty('lException')
		    .AddProperty('nLastPos', 0)    && Cursor position when last accepted value prefix was entered.
		
		    * Literal rowsource overrides cursor source, and cannot have a relationExpression.
		    IF NOT EMPTY(.cRowSource)
		      STORE '' TO .cListWorkarea, .cRelationExpression
		    ENDIF
		
		    * If bound to a relational child, there are no allowable exceptions.
		    IF NOT EMPTY(.cRelationExpression)
		      .lAllowExceptions = .F.
		    ENDIF
		    .lException = .F.
		
		    * If no explicit filter property is set, apply filter from source cursor.
		    IF NOT EMPTY(.cListWorkarea) AND EMPTY(.cFilter) AND NOT EMPTY(FILTER(.cListWorkarea))
		      .cFilter = FILTER(.cListWorkarea)
		    ENDIF
		  ENDWITH
		
	ENDPROC

	PROCEDURE showpopup		&& Build and Display the dropdown list of available options
		LPARAMETERS oThis, cValue
		*++
		*>>Build and Display the dropdown list of available options
		*--
		LOCAL cExpr, cWhere, nSelect, lExact, nHeight, cStyle, nHconvert, nVconvert, nTop, nLeft
		
		  WITH m.oThis
		    IF .lWritelock OR (EMPTY(.cListWorkarea) AND EMPTY(.cRowSource))
		      RETURN .F.
		    ENDIF
		
		    IF VARTYPE(m.cValue) != 'C'
		      m.cValue = ''
		    ENDIF
		    m.nSelect = SELECT()
		    m.lExact = (SET('EXACT') = 'ON')
		    SET EXACT OFF
		
		    * Create a temporary cursor with all the possible completion values for this input.
		    IF NOT EMPTY(.cRowSource)  && Literal rowSource string
		      LOCAL cItem, cRowSource
		      CREATE CURSOR cmItemListCursor (item C(128), recno I)
		      m.cRowSource = .cRowSource
		      DO WHILE NOT EMPTY(m.cRowSource)
		        m.cItem = ALLTRIM(GetToken(@m.cRowSource, ','))
		        IF UPPER(m.cItem) = UPPER(m.cValue)
		          APPEND BLANK
		          REPLACE Item WITH m.cItem
		        ENDIF
		      ENDDO
		    ELSE                           && RowSource from cursor
		      SELECT (.cListWorkarea)
		      IF EMPTY(.cListSuffix)
		        m.cExpr = .cListExpression + ' AS item'
		      ELSE
		        m.cExpr = .cListExpression + ' AS data, ';
		                + .cListExpression + ' + ' + .cListSuffix + ' AS item'
		      ENDIF
		
		      IF .lExactCase
		        m.cWhere = .cListExpression + ' = m.cValue'
		      ELSE
		        m.cWhere = 'UPPER(' + .cListExpression + ') = UPPER(m.cValue)'
		      ENDIF
		      m.cWhere = m.cWhere + IIF(EMPTY(.cFilter), '', ' AND ' + .cFilter)
		      SELECT &cExpr FROM (.cListWorkarea) WHERE &cWhere ;
		             INTO CURSOR cmItemListCursor
		      INDEX ON UPPER(Item) TAG SortOrder
		    ENDIF
		
		    IF RECCOUNT('cmItemListCursor') < 1
		      ??CHR(7)
		    ELSE
		      * Position of popup is in "Foxels" based on form font.
		      * Height of popup needs to be an even multiple of rows in popup font, expressed in units of form font.
		      * First, Calculate height in pixels, using popup font metrics.
		      m.nVconvert = FONTMETRIC(1, .FontName, .FontSize) ;
		                  + FONTMETRIC(5, .FontName, .FontSize)
		      m.nHeight = MIN(RECCOUNT('cmItemListCursor'), .nPopupRows) * (m.nVconvert + 2) - 1
		
		      * Now convert popup height into units of the form font
		      m.cStyle = IIF(THISFORM.FontBold, 'B', '') + IIF(THISFORM.FontItalic, 'I', '')
		      m.nHconvert = FONTMETRIC(6, THISFORM.FontName, THISFORM.FontSize, m.cStyle)
		      m.nVconvert = FONTMETRIC(1, THISFORM.FontName, THISFORM.FontSize, m.cStyle) ;
		                  + FONTMETRIC(5, THISFORM.FontName, THISFORM.FontSize, m.cStyle)
		      m.nHeight = m.nHeight / m.nVconvert
		      m.cStyle = IIF(.FontBold, 'B', '') + IIF(.FontItalic, 'I', '')
		
		      * Support Foxel form mode too.
		      IF THISFORM.Scalemode = 0
		        STORE 1 TO m.nHconvert, m.nVconvert
		      ENDIF
		
		      m.nTop = OBJTOCLIENT(m.oThis, 1) + .Height
		      m.nLeft = OBJTOCLIENT(m.oThis, 2) + 1
		      DEFINE POPUP cmItemPopup ;
		             FONT (.FontName),.Fontsize STYLE (m.cStyle) ;
		             FROM m.nTop/m.nVconvert, m.nLeft/m.nHconvert ;
		             TO   m.nTop/m.nVconvert + m.nHeight, (m.nLeft + MAX(.Width, THISFORM.TextWidth(item)) - 2 + SYSMETRIC(5))/m.nHconvert ;
		             PROMPT FIELD item SCROLL
		      ON SELECTION POPUP cmItemPopup DEACTIVATE POPUP cmItemPopup
		
		      * Find the record in the cursor that matches current input, and initially select it in popup
		      LOCATE FOR UPPER(item) = UPPER(TRIM(m.oThis.Value))
		
		      * Bug in VFP popups will not show seleced item if it requires scrolling the popup.
		      * Forcing an up/down arrow will fix the positioning.
		      IF RECNO() > .nPopupRows
		        KEYBOARD '{DNARROW}' PLAIN
		        IF RECNO() < RECCOUNT()    && Put it back if not on the last record.
		          KEYBOARD '{UPARROW}' PLAIN
		        ENDIF
		      ENDIF
		
		      ACTIVATE POPUP cmItemPopup REST
		      IF BAR() > 0
		        IF EMPTY(.cListSuffix)
		          .SetValue(cmItemListCursor.item)
		        ELSE
		          .SetValue(cmItemListCursor.data)
		        ENDIF
		        .SelStart = 0
		        .SelLength = LEN(TRIM(.Value))
		      ENDIF
		      RELEASE POPUP cmItemPopup EXTENDED
		    ENDIF
		    USE IN cmItemListCursor
		
		    * Restore original workarea and EXACT setting
		    SELECT (m.nSelect)
		    IF m.lExact 
		      SET EXACT ON
		    ENDIF
		  ENDWITH
		
	ENDPROC

	PROCEDURE swquickfill
		LPARAMETER oThis, cValue
		LOCAL lExact, nSelect, nPos, cNewValue, lFound, cFilter
		
		WITH m.oThis
		  * If the field is not blank then search for a quick fill value.
		  m.nPos = 0
		  m.cNewValue = ''
		  IF NOT EMPTY(m.cValue)
		    m.nPos = .SelStart          && Save cursor position
		
		    * Preserve original SET EXACT setting.
		    m.lExact = (SET('EXACT') = 'ON')
		    SET EXACT OFF
		    IF NOT EMPTY(.cRowSource)   && Items come from cRowSorce string
		      LOCAL cItem, cRowSource
		      m.cRowSource = .cRowSource
		      DO WHILE NOT EMPTY(m.cRowSource)
		        m.cItem = ALLTRIM(GetToken(@m.cRowSource, ','))
		        IF UPPER(m.cItem) = UPPER(m.cValue)
		          m.lFound = .T.
		          m.cNewValue = PADR(m.cItem, 128)  && Pad to a fixed length
		          EXIT
		        ENDIF
		      ENDDO
		    ELSE                            && Items come from cListWorkarea cursor
		      m.nSelect = SELECT()
		      SELECT (.cListWorkarea)
		
		      * Use display expression to locate matches.
		      m.cFilter = IIF(EMPTY(.cFilter), '.T.', .cFilter)
		      m.cExpr = .cListExpression
		      m.cTag  = IIF(at('.',.clistexpression)>0,substr(.clistexpression,at('.',.clistexpression)+1),.clistexpression)
		      lntagcount = tagcount(.clistworkarea)
		      llFoundTag = .f.
		      for lntag = 1 to lntagcount
		         if lower(tag(lntag)) = lower(m.ctag)
		            llfoundtag = .t.
		            exit
		         endif
		      endfor   
		      if llFoundTag 
		         set order to (m.ctag)
		         SEEK(m.cValue)
		         m.cNewValue = EVALUATE(m.cExpr)
		         m.lFound = FOUND()
		         SELECT (m.nSelect)
		      else
		         IF .lExactCase
		           LOCATE FOR &cExpr = m.cValue AND &cFilter
		         ELSE
		           LOCATE FOR UPPER(&cExpr) = UPPER(m.cValue) AND &cFilter
		         ENDIF
		         m.cNewValue = EVALUATE(m.cExpr)
		         m.lFound = FOUND()
		         SELECT (m.nSelect)
		      endif   
		    ENDIF
		    IF m.lExact 
		      SET EXACT ON
		    ENDIF
		
		    IF NOT m.lFound
		      IF .lAllowExceptions
		        IF NOT .lException
		          .lException = .T.
		          IF NOT .SetValue(m.cValue)
		            m.nPos = .nLastPos
		            .Value = .cLastValue
		          ENDIF
		        ELSE
		          .Value = m.cValue
		        ENDIF
		        STORE m.nPos TO .SelStart, .nLastPos
		        RETURN .T.
		      ELSE
		        ??CHR(7)   && Invalid character(s) entered, restore previous state of the control.
		        IF NOT EMPTY(.cLastValue)
		          m.nPos = .nLastPos
		          m.cNewValue = .cLastValue
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Calling SetValue() here means Afterchange() will fire after each new value.
		  .lException = .F.
		  IF NOT m.cNewValue == .Value OR NOT m.cNewValue == .cLastValue
		    IF m.cNewValue == .cLastValue
		      .Value = m.cNewValue
		    ELSE
		      * Call SetValue() only when displayed value is actually different 
		      * than last time it was set.
		      IF NOT .SetValue(m.cNewValue)
		        m.nPos = .nLastPos
		        .Value = .cLastValue
		      ENDIF
		    ENDIF
		    STORE m.nPos TO .SelStart, .nLastPos
		  ENDIF
		  .SelStart = MIN(.SelStart, LEN(TRIM(.Value)))
		
		  * Highlight the text that was NOT keyed by the user
		  .SelLength = MAX(0, LEN(TRIM(.Value)) - .SelStart)
		ENDWITH   
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntadjustablelist AS cntcontainercustom OF "..\custom\ccontrol.vcx" 		&& Adjustable listbox control with column headings and user adjustable column widths
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\adjlstbx.bmp" ClassIcon="..\graphics\adjlstbx.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstColumnList" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: ccolumnheadings_assign
		*m: createcolumns		&& Create column header button controls
		*m: setcolumns		&& Set or change the number of display columns.
		*m: setcolumnwidths		&& Set position and widths of column headers.
		*m: sortcolumn		&& Called when a column header button is pushed.
		*m: _setheadings		&& Set the heading captions for the header buttons
		*p: cbuttonclass		&& Class name of column header buttons.
		*p: ccolumnheadings		&& Comma seperated list of column Heading text strings.
		*p: lcolumnmemory		&& Set .T. to remember current column positions set by user.
		*p: lfillframe		&& Automatically size contained listbox to fill entire container frame on init().
		*p: lthinheaderlines		&& Set to .T. for a thinner line between each header button in the header row.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	cbuttonclass = cmdAdjustableListHeader		&& Class name of column header buttons.
	ccolumnheadings = 		&& Comma seperated list of column Heading text strings.
	Height = 90
	lcolumnmemory = .T.		&& Set .T. to remember current column positions set by user.
	Name = "cntadjustablelist"
	SpecialEffect = 2
	Width = 230

	ADD OBJECT 'lstColumnList' AS lstlistnavigator WITH ;
		ColumnLines = .F., ;
		creposition = vStretch,hStretch, ;
		Height = 90, ;
		Left = 0, ;
		lnavigator = .F., ;
		Name = "lstColumnList", ;
		Top = 0, ;
		Width = 228
		*< END OBJECT: ClassLib="cmgadget.vcx" BaseClass="listbox" />
	
	PROCEDURE ccolumnheadings_assign
		LPARAMETERS cHeadings
		  THIS.cColumnHeadings = m.cHeadings
		  THIS._SetHeadings(THIS.cColumnHeadings)
		
	ENDPROC

	PROCEDURE createcolumns		&& Create column header button controls
		LPARAMETER nCount
		LOCAL ix, cButton, oButton, nRowHeight, nButtonHeight, cStyle
		
		  * If a value is passed to us, it is the new coulmn count value.
		  IF PCOUNT() = 1
		    IF THIS.lstColumnList.ColumnCount = m.nCount
		      RETURN .T.   && No change, nothing to do.
		    ENDIF
		    THIS.lstColumnList.ColumnCount = m.nCount
		  ELSE
		    m.nCount = THIS.lstColumnList.ColumnCount
		  ENDIF
		
		  * Get rid of any pre-existing column header controls.
		  FOR ix = THIS.ControlCount TO 1 STEP -1
		    m.oButton = THIS.Controls[m.ix]
		    IF PROPER(m.oButton.Class) == PROPER(THIS.cButtonClass)
		      THIS.RemoveObject(m.oButton.Name)
		    ENDIF
		  ENDFOR
		
		  * Create the correct number of new header controls
		  FOR ix = 1 TO m.nCount
		    m.cButton = 'cmdHeader' + LTRIM(STR(m.ix))
		    THIS.AddObject(m.cButton, THIS.cButtonClass)
		    m.oButton = EVALUATE('THIS.' + m.cButton)
		
		    IF m.ix = 1
		      m.nButtonHeight = m.oButton.Height
		
		      * Add background text box for 3d effect around heading buttons. Only
		      * Needs to be done first time. Skip on subsequent calls to redefine buttons.
		      IF NOT PEMSTATUS(THIS, 'txtBevel', 5)
		        THIS.AddObject('txtBevel', 'TextBox')
		        WITH THIS.txtBevel
		          .Top = THIS.lstColumnList.Top
		          .Left = THIS.lstColumnList.Left
		          .Width = THIS.lstColumnList.Width
		          .Height = m.nButtonHeight + 2
		          .Enabled = .F.
		        ENDWITH
		
		        * Adjust listbox size to allow for button headers.
		        WITH THIS.lstColumnList
		          .Top = .Top + m.nButtonHeight
		          m.cStyle = IIF(.FontBold, 'B', '') +  IIF(.FontItalic, 'I', '')
		          m.nRowHeight = FONTMETRIC(1, .FontName, .FontSize, m.cStyle) ;
		                       + FONTMETRIC(5, .FontName, .FontSize, m.cStyle) + 2
		          .Height = INT((.Height - m.nButtonHeight - 4) / m.nRowHeight) * m.nRowHeight + 4
		          .ListIndex = .ListIndex
		        ENDWITH
		      ENDIF
		    ENDIF
		
		    WITH m.oButton
		      .TabStop = .F.
		      .Top = THIS.nHeaderTop
		      .nColumn = m.ix
		    ENDWITH
		
		    IF m.ix > 1
		      m.cButton = 'cmdDivider' + LTRIM(STR(m.ix))
		      THIS.AddObject(m.cButton, THIS.cButtonClass)
		      WITH EVALUATE('THIS.' + m.cButton)
		        .top = THIS.nHeaderTop
		        .width = 9
		        .Style = 1             && Invisible
		        .MousePointer = 9
		        .tabstop = .F.
		        .nColumn = m.ix - 1
		        .MousePointer = 99
		        .MouseIcon = '..\graphics\ve_sizeb.cur'
		      ENDWITH
		    ENDIF
		  ENDFOR
		
		  THIS._SetHeadings(THIS.cColumnHeadings)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Destroy
		* Save column positions if memory is enabled
		IF THIS.lColumnMemory
		  IF PEMSTATUS(THISFORM, 'cSysRegFormRoot', 5)
		    cmRegSetString((HKEY_CURRENT_USER), (THISFORM.cSysRegFormRoot + '\ControlMemory\' + SYS(1272, THIS)), (THIS.lstColumnList.ColumnWidths))
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		LOCAL nOldScale
		
		  DECLARE INTEGER GetCursor IN user32 AS GetMouseCursor
		  DECLARE INTEGER SetCursor IN user32 AS SetMouseCursor INTEGER nHandle
		
		  IF THIS.ControlCount = 0
		    RETURN .F.   && Fail if our listbox failed creation
		  ENDIF
		
		  m.nOldScale = THISFORM.ScaleMode
		  THISFORM.ScaleMode = 3
		  
		  IF THIS.lFillFrame
		    WITH THIS.lstColumnList
		      .Top = 0
		      .Left = 0
		      .Width = THIS.Width
		      .Height = THIS.Height
		    ENDWITH
		  ENDIF
		
		  * Save original widths, and restore memory widths, if any.
		  THIS.AddProperty('nHeaderTop', THIS.lstColumnList.Top + 2)
		  THIS.AddProperty('cOriginalWidths', THIS.lstColumnList.ColumnWidths)
		  IF THIS.lColumnMemory
		    IF PEMSTATUS(THISFORM, 'cSysRegFormRoot', 5)
		      LOCAL cWidths
		      IF cmRegGetValue(HKEY_CURRENT_USER, THISFORM.cSysRegFormRoot + '\ControlMemory\' + SYS(1272, THIS), @m.cWidths)
		        THIS.lstColumnList.ColumnWidths = m.cWidths
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Define heading buttons, and invisible column divider buttons for interactive resizing.
		  THIS.CreateColumns()
		  THIS.SetColumnWidths()
		
		  THISFORM.ScaleMode = m.nOldScale
		  DODEFAULT()
		
		  * Put our 3d effects txtbox behind the listbox and column buttons.
		  THIS.txtBevel.zOrder(1)
		  THIS.txtBevel.visible = .T.
		
	ENDPROC

	PROCEDURE Resize
		*++
		* Adjust listbox size after a form resize event.
		*--
		  IF PEMSTATUS(THIS, 'txtBevel', 5)  && Make sure Init() has completed before doing anything
		*!*  LOCAL nRowHeight, nPixelToFormUnits, cStyle
		*!*    * Resize the list inside to fill the new container size, stoping at an even
		*!*    * multiple of line heights.
		*!*    m.nPixelToFormUnits = IIF(THISFORM.ScaleMode = 0, FONTMETRIC(1) + FONTMETRIC(5), 1)
		*!*	    m.cStyle = IIF(THIS.lstColumnList.FontBold, 'B', '') +  IIF(THIS.lstColumnList.FontItalic, 'I', '')
		*!*	    m.nRowHeight = (FONTMETRIC(1, THIS.lstColumnList.FontName, THIS.lstColumnlist.fontSize, m.cStyle) ;
		*!*	                 +  FONTMETRIC(5, THIS.lstColumnList.FontName, THIS.lstColumnlist.fontSize, m.cStyle) + 2) / m.nPixelToFormUnits
		*!*	    THIS.lstColumnList.height = INT((THIS.Height - THIS.lstColumnList.Top - (4 / m.nPixelToFormUnits)) ;
		*!*	                              / m.nRowHeight) * m.nRowHeight + (4 / m.nPixelToFormUnits)
		    DODEFAULT()
		    THIS.SetColumnWidths()
		  ENDIF
		
	ENDPROC

	PROCEDURE setcolumns		&& Set or change the number of display columns.
	ENDPROC

	PROCEDURE setcolumnwidths		&& Set position and widths of column headers.
		LPARAMETERS cWidths
		*++
		* Adjust column heading buttons to fit current dimensions.
		*--
		LOCAL ix, nLeft, nLastLeft, nWidth, nRlimit, oButton, nPixelToFormUnits
		
		  * If a string is passed to us, it is the new width definition string to use.
		  IF PCOUNT() = 1
		    STORE m.cWidths TO THIS.cOriginalWidths, THIS.lstColumnList.ColumnWidths
		  ELSE
		    m.cWidths = THIS.lstColumnList.ColumnWidths
		  ENDIF
		
		  m.nPixelToFormUnits = IIF(THISFORM.ScaleMode = 0, FONTMETRIC(6), 1)
		  m.nRlimit = THIS.lstColumnList.left ;
		            + THIS.lstColumnList.width - ((SYSMETRIC(5) + 3) / m.nPixelToFormUnits)
		
		  THIS.txtBevel.width = THIS.lstColumnList.Width
		
		  * There is an apparent bug in VFP, where if fontsize is > 10, and moverbars is on,
		  * then the first column width measurement starts on top of the mover button.
		  * This bug breaks the following code. I havent decided how to workaround that yet. 
		  m.nLeft = (2 + IIF(THIS.lstColumnList.Moverbars, 18, 0)/ m.nPixelToFormUnits)
		
		  FOR ix = 1 TO THIS.lstColumnList.ColumnCount
		    m.oButton = EVALUATE('THIS.' + 'cmdHeader' + LTRIM(STR(m.ix)))
		    m.oButton.left = THIS.lstColumnList.left + m.nLeft
		
		    DO CASE
		      CASE m.oButton.left = m.nRlimit
		        * Display partial button over scroll bar for first column that starts past end of list.
		        m.nWidth = ((SYSMETRIC(5) + 2) / m.nPixelToFormUnits)
		      CASE m.oButton.left > m.nRlimit
		        * Buttons for columns off list are invisible.
		        m.nWidth = 0
		      OTHERWISE
		        * Last button goes to end of listbox.
		        IF m.ix = THIS.lstColumnList.ColumnCount
		          m.nWidth = THIS.lstColumnList.width ;
		                   - (m.oButton.left - THIS.lstColumnList.left) - (2 / m.nPixelToFormUnits)
		        ELSE
		          * Commas may be a decimal point in some locales, so convert to something else before VAL().
		          m.nWidth = VAL(STRTRAN(m.cWidths, ',', 'X')) + (3 / m.nPixelToFormUnits) ;
		                   - IIF(THIS.lstColumnList.ColumnLines, 0, 1)
		
		          * If left + width is past end of list, cut off the buttons.
		          IF m.oButton.left + m.nWidth > m.nRlimit
		            m.nWidth = m.nRlimit - m.oButton.left
		          ENDIF
		        ENDIF
		    ENDCASE
		
		    m.oButton.width = m.nWidth + IIF(THIS.lThinHeaderLines, 1, 0)
		    m.oButton.Visible = (m.nWidth > 0)
		
		    IF m.ix > 1
		      WITH EVALUATE('THIS.' + 'cmdDivider' + LTRIM(STR(m.ix)))
		        .left = THIS.lstColumnList.left + m.nLeft - (4 / m.nPixelToFormUnits)
		        .width = (9 / m.nPixelToFormUnits)
		        .nLeftLimit = THIS.lstColumnList.left + m.nLastLeft + (5 / m.nPixelToFormUnits)
		        .Visible = (m.nWidth > 0)
		      ENDWITH
		    ENDIF
		    m.nLastLeft = m.nLeft
		    m.nLeft = m.nLeft + m.nWidth && - IIF(THIS.lstColumnList.ColumnLines, 0, 1)
		
		    * Advance to next column width, if any.
		    IF ',' $ m.cWidths
		      m.cWidths = SUBSTR(m.cWidths, AT(',', m.cWidths) + 1)
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE sortcolumn		&& Called when a column header button is pushed.
		LPARAMETER nColumn
		
		  WITH THIS.lstColumnList
		    * If this is being used as a navigation control, we support automatic sorting by column.
		    IF .lNavigator
		      =ASORT(.aRecordList, m.nColumn)
		      THIS.lstColumnList.ListIndex = 1
		      THIS.lstColumnList.Refresh()
		    ENDIF
		  ENDWITH
		  RETURN .T.
		
	ENDPROC

	PROCEDURE _setheadings		&& Set the heading captions for the header buttons
		LPARAMETERS cHeadings
		LOCAL ix, oButton
		
		  FOR ix = 1 TO THIS.lstColumnList.ColumnCount
		    m.oButton = EVALUATE('THIS.' + 'cmdHeader' + LTRIM(STR(m.ix)))
		    m.oButton.Caption = GetToken(@m.cHeadings, ',')
		  ENDFOR
		
	ENDPROC

	PROCEDURE lstColumnList.contextmenubuild
		* Define all the bars for a context menu. Return false if no bars are defined.
		DODEFAULT()
		IF THIS.ColumnWidths != THIS.Parent.cOriginalWidths
		  THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP4)
		  THISFORM.ContextMenuBar(CTX_BAR_CTL_COLUMNS, '%barResetColumns')
		ENDIF
		
	ENDPROC

	PROCEDURE lstColumnList.contextmenuexecute
		LPARAMETER cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%barresetcolumns'
		      THIS.ColumnWidths = THIS.Parent.cOriginalWidths
		      THIS.Parent.SetColumnWidths()
		    OTHERWISE
		      RETURN DODEFAULT(m.cOption)
		  ENDCASE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntgetfile AS cntcontainercustom OF "..\custom\ccontrol.vcx" 		&& A text control for entering file paths
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="edtPath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPath" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: formatvalue		&& Format filespec value
		*m: setvalue		&& Set value for this compound control.
		*p: cdefaultextension		&& Default file extension
		*p: cextensionlist		&& Comma seperated list of extensions to include in dialog.
		*p: cvalue		&& Current control value - name of file entered.
		*p: lfullpath		&& Return a full path name if .T. Otherwise, use relative path.
		*p: lmustexist		&& If true, the path entered must already exist.
		*p: lpathonly		&& If true, return only a folder name.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	cdefaultextension = dbf		&& Default file extension
	cextensionlist = 		&& Comma seperated list of extensions to include in dialog.
	cvalue = 		&& Current control value - name of file entered.
	Height = 24
	lfullpath = .F.		&& Return a full path name if .T. Otherwise, use relative path.
	lmustexist = .T.		&& If true, the path entered must already exist.
	lpathonly = .F.		&& If true, return only a folder name.
	Name = "cntgetfile"
	Width = 277

	ADD OBJECT 'cmdPath' AS cmdcommandbuttoncustom WITH ;
		Caption = "...", ;
		creposition = hFollow, ;
		Height = 22, ;
		Left = 254, ;
		lskipvalid = .T., ;
		Name = "cmdPath", ;
		TabIndex = 2, ;
		Top = 0, ;
		Width = 22, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtPath' AS edteditboxcustom WITH ;
		ControlSource = "", ;
		creposition = hStretch, ;
		FontSize = 9, ;
		Height = 23, ;
		lallowenter = .F., ;
		lallowzoom = .F., ;
		Left = 0, ;
		MaxLength = 0, ;
		Name = "edtPath", ;
		TabIndex = 1, ;
		Top = 0, ;
		Width = 247, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="editbox" />
	
	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		  * Ignore this particular parse error from FULLPATH()
		  IF m.nError = 202 AND m.cMethod = 'formatvalue'
		    RETURN .T.
		  ENDIF
		  RETURN DODEFAULT(m.nError, m.cMethod, m.nLine)
		
	ENDPROC

	PROCEDURE formatvalue		&& Format filespec value
		LPARAMETER cInValue
		LOCAL cOutValue
		
		  IF NOT EMPTY(m.cInValue)
		    IF THIS.lFullPath
		      m.cOutValue = LOWER(FULLPATH(m.cInValue, '.\'))
		    ELSE
		      m.cOutValue = LOWER(SYS(2014, m.cInValue, '.\'))
		    ENDIF
		
		    IF EMPTY(m.cOutValue)  && Parse error from FULLPATH()
		      m.cOutValue = m.cInValue
		    ENDIF
		
		    IF THIS.lPathOnly 
		      IF RIGHT(m.cOutValue, 1) != '\'
		        m.cOutValue = m.cOutValue + '\'
		      ENDIF
		    ELSE
		      IF RAT('.', m.cOutValue) < MAX(1, LEN(m.cOutValue) - 3)
		        m.cOutValue = m.cOutValue + '.' + THIS.cDefaultExtension
		      ENDIF
		    ENDIF
		  ELSE
		    m.cOutValue = ''
		  ENDIF
		
		  * Store copy of control value for easy accessibility from outside.
		  THIS.cValue = m.cOutValue
		  RETURN m.cOutValue
		
	ENDPROC

	PROCEDURE setvalue		&& Set value for this compound control.
		LPARAMETER cValue
		
		RETURN THIS.edtPath.SetValue(THIS.FormatValue(m.cValue))
		
	ENDPROC

	PROCEDURE cmdPath.Click
		LOCAL cPath
		  IF THIS.Parent.lPathOnly
		    IF VERSION(5) >= 700
		      * Need to use macro expansion here to avoid compile errors under VFP 6, 
		      * even though this code will only run on VFP 7
		      m.cPath = "GETDIR(THIS.Parent.edtPath.Value, '', '')"
		      m.cPath = &cPath
		    ELSE
		      m.cPath = GETDIR(THIS.Parent.edtPath.Value)
		    ENDIF
		  ELSE
		    m.cPath = GETFILE(THIS.Parent.cExtensionList)
		  ENDIF
		  IF NOT EMPTY(m.cPath)
		    THIS.Parent.SetValue(m.cPath)
		  ENDIF
		
	ENDPROC

	PROCEDURE edtPath.fieldvalid
		IF THIS.Parent.lMustExist AND NOT EMPTY(THIS.Value)
		  IF THIS.Parent.lPathOnly AND NOT cmIsPath(THIS.Value)
		    THISFORM.DisplayMessage('%msgBadPath', THIS.Value)
		    RETURN 0
		  ENDIF
		
		  IF NOT THIS.Parent.lPathOnly AND NOT FILE(THIS.Value)
		    THISFORM.DisplayMessage('%msgFileNotFoundInfo', THIS.Value)
		    RETURN 0
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE edtPath.Valid
		THIS.Value = THIS.Parent.FormatValue(THIS.Value)
		RETURN DODEFAULT()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntgrowframe AS cntcontainercustom OF "..\custom\ccontrol.vcx" 		&& A grow frame, for creating dialogs that expand by pressing a More>> button
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\growfram.bmp" ClassIcon="..\graphics\growfram.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdMore" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: growform		&& Set form to its full size.
		*m: ongrowform		&& User function called before form is grown to its full size. Return .T. if ok to expand form.
		*m: onshrinkform		&& User function called before form is set to its small size. Return .T. if ok to shrink.
		*m: shrinkform		&& Set the form to its small size.
		*p: clessprompt		&& Prompt text to reduce size.
		*p: cmoreprompt		&& Prompt text to expand size.
		*p: linitialsmall		&& Set to true if containing forms initial size is small.
		*p: lreversible		&& Size change may be reversed if true.
		*p: nbigheight		&& Height when big - set automatically at runtime by Init() method.
		*p: nbigwidth		&& Width when big- set automatically at runtime by Init() method.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	clessprompt = <<		&& Prompt text to reduce size.
	cmoreprompt = >>		&& Prompt text to expand size.
	Height = 116
	linitialsmall = .T.		&& Set to true if containing forms initial size is small.
	Name = "cntgrowframe"
	nbigheight = 0		&& Height when big - set automatically at runtime by Init() method.
	nbigwidth = 0		&& Width when big- set automatically at runtime by Init() method.
	SpecialEffect = 2
	Width = 238

	ADD OBJECT 'cmdMore' AS cmdcommandbuttoncustom WITH ;
		Caption = ">>", ;
		Left = 156, ;
		Name = "cmdMore", ;
		Top = 86
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />
	
	PROCEDURE growform		&& Set form to its full size.
		*++
		* Grow form to its full size.
		*--
		  IF THIS.OnGrowForm()
		    THISFORM.Height = THIS.nBigHeight
		    THISFORM.Width = THIS.nBigWidth
		    IF THIS.lReversible
		      THIS.cmdMore.Caption = THIS.cLessPrompt
		    ELSE
		      THIS.cmdMore.Enabled = .F.
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Init
		*++
		* Copyright 1996-2002 Soft Classics, Ltd. All rights reserved.
		*--
		
		  * Border needs to be fixed for proper operation.
		  IF THISFORM.BorderStyle = 3
		    THISFORM.BorderStyle = 2
		  ENDIF
		
		  * Original form size is used as "big" size. Size of this container is the "small" size.
		  THIS.nBigHeight = THISFORM.Height
		  THIS.nBigWidth = THISFORM.Width
		
		  THISFORM.MinHeight = THIS.Top + THIS.Height
		  THISFORM.MinWidth = THIS.Left + THIS.Width
		  IF THIS.lInitialSmall
		    THIS.cmdMore.Caption = THIS.cMorePrompt
		    THISFORM.Height = THIS.Top + THIS.Height
		    THISFORM.Width = THIS.Left + THIS.Width
		  ELSE
		    THIS.cmdMore.Caption = THIS.cLessPrompt
		  ENDIF
		
	ENDPROC

	PROCEDURE ongrowform		&& User function called before form is grown to its full size. Return .T. if ok to expand form.
		RETURN .T.
		
	ENDPROC

	PROCEDURE onshrinkform		&& User function called before form is set to its small size. Return .T. if ok to shrink.
		RETURN .T.
		
	ENDPROC

	PROCEDURE shrinkform		&& Set the form to its small size.
		*++
		* Set form to its smaller size.
		*--
		  IF THIS.OnShrinkForm()
		    THISFORM.Height = THIS.Top + THIS.Height
		    THISFORM.Width = THIS.Left + THIS.Width
		
		    IF THIS.lReversible
		      THIS.cmdMore.Caption = THIS.cMorePrompt
		    ELSE
		      THIS.cmdMore.Enabled = .F.
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE cmdMore.Click
		IF THIS.Parent.nBigHeight <= THISFORM.Height AND THIS.Parent.nBigWidth <= THISFORM.Width
		  THIS.Parent.ShrinkForm()
		ELSE
		  THIS.Parent.GrowForm()
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntmoverlistpair AS cntcontainercustom OF "..\custom\ccontrol.vcx" 		&& A mover listbox pair
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\mvrlstbx.bmp" ClassIcon="..\graphics\mvrlstbx.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lstSource" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstSelected" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelect" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelectAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDeselectAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDeselect" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addselecteditem		&& Add an individual selected item
		*m: addsourceitem		&& Add an individual source item
		*m: afterchange		&& This event Occurs after an item is selcted or deselected.
		*m: afterdeselect		&& Event occurs after an item is removed from the "selected" listbox.
		*m: afterinit		&& This event is called after the default Init() code completes, and can be used to ititialize the values of the listboxes.
		*m: afterselect		&& Event occurs after an item is added to the "selected" listbox.
		*m: beforechange		&& Called before an item is selected or deselected. Calls Form.beforeChange() by default.
		*m: beforedeselect		&& Event occurs before an item is removed from the "selected" listbox.
		*m: beforeselect		&& Event occurs before an item is added to the "selected" listbox.
		*m: clear		&& clear source and selected lists.
		*m: deselectitem		&& Remove item from selected list.
		*m: gettoken		&& Return the next item from a coma delimited list
		*m: getvalue		&& Return an array of all selected items.
		*m: getvaluelist		&& Return a comma seperated list of all selected items.
		*m: selectitem		&& Add item to selected list.
		*m: setvalue		&& Set the values for the source and selected list boxes.
		*m: setvaluelist		&& Set list box values from comma seperated list of source values.
		*p: cdropicon		&& Icon for valid drop zone.
		*p: cnodropicon		&& Icon for no drop zone.
		*p: lchanged		&& Flag set if changes made.
		*p: ndragthreshold		&& Number of pixels cursor can move before triggering a drag operation.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	cdropicon = Dragmove.cur		&& Icon for valid drop zone.
	cnodropicon = Nodrop01.cur		&& Icon for no drop zone.
	Height = 107
	Name = "cntmoverlistpair"
	ndragthreshold = 3		&& Number of pixels cursor can move before triggering a drag operation.
	SpecialEffect = 2
	Width = 458

	ADD OBJECT 'cmdDeselect' AS cmdcommandbuttoncustom WITH ;
		Caption = "<", ;
		Height = 23, ;
		Left = 195, ;
		Name = "cmdDeselect", ;
		TabIndex = 3, ;
		Top = 56, ;
		Width = 70
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdDeselectAll' AS cmdcommandbuttoncustom WITH ;
		Caption = "<<", ;
		Height = 23, ;
		Left = 195, ;
		Name = "cmdDeselectAll", ;
		TabIndex = 5, ;
		Top = 83, ;
		Width = 70
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelect' AS cmdcommandbuttoncustom WITH ;
		Caption = ">", ;
		Height = 23, ;
		Left = 195, ;
		Name = "cmdSelect", ;
		TabIndex = 2, ;
		Top = 1, ;
		Width = 70
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelectAll' AS cmdcommandbuttoncustom WITH ;
		Caption = ">>", ;
		Height = 23, ;
		Left = 195, ;
		Name = "cmdSelectAll", ;
		TabIndex = 4, ;
		Top = 29, ;
		Width = 70
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lstSelected' AS lstlistboxcustom WITH ;
		DragIcon = ..\graphics\dragmove.cur, ;
		Height = 118, ;
		Left = 277, ;
		MultiSelect = .T., ;
		Name = "lstSelected", ;
		RowSource = "", ;
		RowSourceType = 0, ;
		Sorted = .F., ;
		TabIndex = 6, ;
		Top = 0, ;
		Width = 180
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="listbox" />

	ADD OBJECT 'lstSource' AS lstlistboxcustom WITH ;
		DragIcon = ..\graphics\dragmove.cur, ;
		Height = 118, ;
		Left = 0, ;
		MultiSelect = .T., ;
		Name = "lstSource", ;
		RowSource = "", ;
		RowSourceType = 0, ;
		Sorted = .F., ;
		TabIndex = 1, ;
		Top = 0, ;
		Width = 181
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="listbox" />
	
	PROCEDURE addselecteditem		&& Add an individual selected item
		LPARAMETER cItem, nItemData
		*++
		* Add an individual item, and its optional numeric data value, to the selected listbox. Normally used to set the initial state of the mover.
		*--
		  WITH THIS.lstSelected
		    .AddItem(m.cItem)
		    IF PCOUNT() > 1 AND VARTYPE(m.nItemData) $ 'NI'
		      .ItemData[.NewIndex] = m.nItemData
		    ENDIF
		  ENDWITH
		  THIS.lstSelected.ListIndex = 0
		
	ENDPROC

	PROCEDURE addsourceitem		&& Add an individual source item
		LPARAMETER cItem, nItemData
		*++
		* Add an individual item, and its optional numeric data value, to the source listbox.  Normally used to set the initial state of the mover.
		*--
		  WITH THIS.lstSource
		    .AddItem(m.cItem)
		    IF PCOUNT() > 1 AND VARTYPE(m.nItemData) $ 'NI'
		      .ItemData[.NewIndex] = m.nItemData
		    ENDIF
		  ENDWITH
		  THIS.lstSource.ListIndex = 0
		
	ENDPROC

	PROCEDURE afterchange		&& This event Occurs after an item is selcted or deselected.
		RETURN .T.
		
	ENDPROC

	PROCEDURE afterdeselect		&& Event occurs after an item is removed from the "selected" listbox.
		LPARAMETERS nIndex
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterinit		&& This event is called after the default Init() code completes, and can be used to ititialize the values of the listboxes.
	ENDPROC

	PROCEDURE afterselect		&& Event occurs after an item is added to the "selected" listbox.
		LPARAMETERS nIndex
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforechange		&& Called before an item is selected or deselected. Calls Form.beforeChange() by default.
		*++
		* Called before an item is selected or deselected. 
		* Default code calls form BeforeChange() to set form level change flag when an item is changed.
		*--
		  IF NOT THIS.lChanged AND THISFORM.BeforeChange()
		    THIS.lChanged = .T.
		  ENDIF
		  RETURN THIS.lChanged
		
	ENDPROC

	PROCEDURE beforedeselect		&& Event occurs before an item is removed from the "selected" listbox.
		LPARAMETERS nIndex
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeselect		&& Event occurs before an item is added to the "selected" listbox.
		LPARAMETERS nIndex
		  RETURN .T.
		
	ENDPROC

	PROCEDURE clear		&& clear source and selected lists.
		THIS.lChanged = .F.
		THIS.lstSelected.Clear()
		THIS.lstSource.Clear()
		
	ENDPROC

	PROCEDURE deselectitem		&& Remove item from selected list.
		LPARAMETER nIndex
		*++
		* Move specified item from selected list to source list.
		*--
		LOCAL ix, cItem, nItemData
		
		  IF m.nIndex > 0 AND THIS.BeforeDeselect(m.nIndex) AND THIS.BeforeChange()
		    WITH THIS.lstSelected
		      m.cItem = .List[m.nIndex]
		      m.nItemData = .ItemData[m.nIndex]
		      .RemoveItem(m.nIndex)
		    ENDWITH
		    WITH THIS.lstSource
		      .AddItem(m.cItem)
		      m.ix = .NewIndex
		      .Selected[m.ix] = .T.
		      .ItemData[m.ix] = m.nItemData
		    ENDWITH
		    THIS.AfterDeselect(m.ix)
		    THIS.AfterChange()
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE gettoken		&& Return the next item from a coma delimited list
		LPARAMETER cSourceLine
		*++
		* Return the next delimited token from the beginning of the source string.
		* Parameter 'cSourceLine' is passed by reference, and is updated past the 
		* returned token.
		*
		* Implimented localy so this control can be used without the other Codemine Libraries.
		*--
		LOCAL nDelim, cToken
		  m.nDelim = AT(',', m.cSourceLine)
		  IF (m.nDelim == 0)
		     m.cToken = ALLTRIM(m.cSourceLine)
		     m.cSourceLine = ''
		  ELSE
		     m.cToken = TRIM(LEFT(m.cSourceLine, m.nDelim - 1))
		     m.cSourceLine = LTRIM(STUFF(m.cSourceLine, 1, m.nDelim, ''))
		  ENDIF
		  RETURN m.cToken
		
	ENDPROC

	PROCEDURE getvalue		&& Return an array of all selected items.
		LPARAMETER aSelected
		*++
		* Returns the list of selected items in the passed array parameter (passed by reference).
		* Return value is the total number of selected items.
		*--
		EXTERNAL ARRAY aSelected
		LOCAL ix, nCols
		
		  m.nCols = MAX(1, ALEN(aSelected, 2))
		
		  * Return the selected items. If a 2 column array is passed, return itemdata field also.
		  IF THIS.lstSelected.ListCount > 0
		    DIMENSION aSelected[THIS.lstSelected.ListCount, m.nCols]
		    FOR ix = 1 TO ALEN(aSelected, 1)
		      aSelected[m.ix, 1] = THIS.lstSelected.List[m.ix]
		      IF m.nCols > 1
		        aSelected[m.ix, 2] = THIS.lstSelected.ItemData[m.ix]
		      ENDIF
		    ENDFOR
		  ENDIF
		  RETURN THIS.lstSelected.ListCount
		
	ENDPROC

	PROCEDURE getvaluelist		&& Return a comma seperated list of all selected items.
		LPARAMETER cSelected
		*++
		* Returns the list of selected items as a coma separated string, in the cSelected 
		* parameter (passed by reference). Return value is the total number of selected items.
		*--
		LOCAL ix
		
		  * Return the selected items.
		  m.cSelected = ''
		  FOR ix = 1 TO THIS.lstSelected.ListCount
		    m.cSelected = m.cSelected + IIF(m.ix > 1, ',', '') + THIS.lstSelected.List[m.ix]
		  ENDFOR
		  RETURN THIS.lstSelected.ListCount
		
	ENDPROC

	PROCEDURE Init
		THIS.AddProperty('nXcoord', 0)
		THIS.AddProperty('nYcoord', 0)
		IF DODEFAULT()
		  THIS.AfterInit()
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE selectitem		&& Add item to selected list.
		LPARAMETER nIndex
		*++
		* Move specified item from source list to selected list.
		*--
		LOCAL ix, cItem, nItemData
		  IF m.nIndex > 0 AND THIS.BeforeSelect(m.nIndex) AND THIS.BeforeChange()
		    WITH THIS.lstSource
		      m.cItem = .List[m.nIndex]
		      m.nItemData = .ItemData[m.nIndex]
		      IF m.nindex < 32768
		         .RemoveItem(m.nIndex)
		      ENDIF    
		    ENDWITH
		  
		    WITH THIS.lstSelected
		      .AddItem(m.cItem)
		      m.ix = .NewIndex
		      .Selected[m.ix] = .T.
		      .ItemData[m.ix] = m.nItemData
		    ENDWITH
		    THIS.AfterSelect(m.ix)
		    THIS.AfterChange()
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setvalue		&& Set the values for the source and selected list boxes.
		LPARAMETER aSource, aSelected
		*++
		* Initialize list boxes from arrays of items. Array may have one column or two. 
		* If two columns, the second column is a numeric value used to identify the element.
		*--
		EXTERNAL ARRAY aSource, aSelected
		LOCAL ix, nCols, nNewIndex
		
		  THISFORM.LockScreen = .T.
		  THIS.Clear()
		
		  * Process the selected items.
		  m.nCols = MAX(1, ALEN(aSelected, 2))
		  FOR ix = 1 TO ALEN(aSelected, 0) STEP m.nCols
		    * Discard empty items or items not in the source list.
		    IF NOT EMPTY(aSelected[m.ix]) AND ASCAN(aSource, aSelected[m.ix]) > 0
		      WITH THIS.lstSelected
		        .AddItem(aSelected[m.ix])
		        IF m.nCols > 1
		          .ItemData[.NewIndex] = aSelected[m.ix + 1]
		        ENDIF
		      ENDWITH
		    ENDIF
		  ENDFOR
		  THIS.lstSelected.ListIndex = 0
		
		  * Process the source list items.
		  m.nCols = MAX(1, ALEN(aSource, 2))
		  FOR ix = 1 TO ALEN(aSource, 0) STEP m.nCols
		    IF NOT EMPTY(aSource[m.ix]) AND ASCAN(aSelected, aSource[m.ix]) = 0
		      WITH THIS.lstSource
		        .AddItem(aSource[m.ix])
		        IF m.nCols > 1
		          .ItemData[.NewIndex] = aSource[m.ix + 1]
		        ENDIF
		      ENDWITH
		    ENDIF
		  ENDFOR
		  THIS.lstSource.ListIndex = 0
		  THIS.Refresh()
		
		  THISFORM.LockScreen = .F.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setvaluelist		&& Set list box values from comma seperated list of source values.
		LPARAMETER cSource, cSelected
		*++
		* Initialize list boxes from comma seperated list of items.
		*--
		LOCAL cItem
		
		  THISFORM.LockScreen = .T.
		  THIS.Clear()
		
		  * Process the selected items.
		  m.cSource = ',' + m.cSource + ','
		  DO WHILE NOT EMPTY(m.cSelected)
		    m.cItem = THIS.GetToken(@cSelected)
		
		    * Discard empty items or items not in the source list.
		    IF NOT EMPTY(m.cItem) AND  ',' + m.cItem + ',' $ m.cSource
		      m.cSource = STRTRAN(m.cSource, ',' + m.cItem + ',', ',', 1, 1)
		      THIS.lstSelected.AddItem(m.cItem)
		    ENDIF
		  ENDDO
		  THIS.lstSelected.ListIndex = 0
		
		  * Process the source list items.
		  DO WHILE NOT EMPTY(m.cSource)
		    m.cItem = THIS.GetToken(@cSource)
		    IF NOT EMPTY(m.cItem)
		      THIS.lstSource.AddItem(m.cItem)
		    ENDIF
		  ENDDO
		  THIS.lstSource.ListIndex = 0
		  THIS.Refresh
		
		  THISFORM.LockScreen = .F.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE cmdDeselect.Click
		LOCAL ix
		  THISFORM.LockScreen = .T.
		
		  FOR ix = 1 TO THIS.Parent.lstSelected.ListCount
		    IF THIS.Parent.lstSelected.Selected[m.ix]
		      IF NOT THIS.Parent.DeselectItem(m.ix)
		        EXIT
		      ENDIF
		      m.ix = m.ix - 1
		    ENDIF
		  ENDFOR
		  THIS.Parent.Refresh
		  THISFORM.LockScreen = .F.
		
	ENDPROC

	PROCEDURE cmdDeselect.Refresh
		LOCAL ix
		  FOR ix = 1 TO THIS.Parent.lstSelected.ListCount
		    IF THIS.Parent.lstSelected.Selected(m.ix)
		    THIS.Enabled = .T.
		      RETURN
		    ENDIF
		  ENDFOR
		  THIS.Enabled = .F.
		
	ENDPROC

	PROCEDURE cmdDeselectAll.Click
		LOCAL ix
		  THISFORM.LockScreen = .T.
		
		  * Clear 'selected' flag for all original items in destination listbox.
		  FOR ix = 1 TO THIS.Parent.lstSource.ListCount
		    THIS.Parent.lstSource.Selected[m.ix] = .F.
		  ENDFOR
		
		  DO WHILE THIS.Parent.lstSelected.ListCount > 0
		    IF NOT THIS.Parent.DeselectItem(1)
		      EXIT
		    ENDIF
		  ENDDO
		  THIS.Parent.Refresh()
		  THISFORM.LockScreen = .F.
		
	ENDPROC

	PROCEDURE cmdDeselectAll.Refresh
		THIS.Enabled = THIS.Parent.lstSelected.ListCount > 0
		
	ENDPROC

	PROCEDURE cmdSelect.Click
		LOCAL ix
		  THISFORM.LockScreen = .T.
		
		  FOR ix = 1 TO THIS.Parent.lstSource.ListCount
		    IF THIS.Parent.lstSource.Selected[m.ix]
		      IF NOT THIS.Parent.SelectItem(m.ix)
		        EXIT
		      ENDIF
		      m.ix = m.ix - 1
		    ENDIF
		  ENDFOR
		  THIS.Parent.Refresh
		  THISFORM.LockScreen = .F.
		
	ENDPROC

	PROCEDURE cmdSelect.Refresh
		LOCAL ix
		  FOR ix = 1 TO THIS.Parent.lstSource.ListCount
		    IF THIS.Parent.lstSource.Selected(m.ix)
		      THIS.Enabled = .T.
		      RETURN
		    ENDIF
		  ENDFOR
		  THIS.Enabled = .F.
		
	ENDPROC

	PROCEDURE cmdSelectAll.Click
		LOCAL ix
		  THISFORM.LockScreen = .T.
		
		  * Clear 'selected' flag for all original items in destination listbox.
		  FOR ix = 1 TO THIS.Parent.lstSelected.ListCount
		    THIS.Parent.lstSelected.Selected[m.ix] = .F.
		  ENDFOR
		
		  DO WHILE THIS.Parent.lstSource.ListCount > 0
		    IF NOT THIS.Parent.SelectItem(1)
		      EXIT
		    ENDIF
		  ENDDO
		  THIS.Parent.Refresh()
		  THISFORM.LockScreen = .F.
		
	ENDPROC

	PROCEDURE cmdSelectAll.Refresh
		THIS.Enabled = THIS.Parent.lstSource.ListCount > 0
		
	ENDPROC

	PROCEDURE lstSelected.Click
		* Clear 'selected' flag for all original items in destination listbox.
		FOR ix = 1 TO THIS.Parent.lstSource.ListCount
		  THIS.Parent.lstSource.Selected[m.ix] = .F.
		ENDFOR
		
		THIS.Parent.Refresh
		
	ENDPROC

	PROCEDURE lstSelected.DblClick
		THIS.Parent.DeselectItem(THIS.ListIndex)
		THIS.Parent.Refresh
		
	ENDPROC

	PROCEDURE lstSelected.DragDrop
		LPARAMETERS oSource, nXCoord, nYCoord
		IF oSource.Name != THIS.Name
		  THIS.Parent.cmdSelect.Click()
		ENDIF
		
	ENDPROC

	PROCEDURE lstSelected.DragOver
		LPARAMETERS oSource, nXCoord, nYCoord, nState
		  DO CASE
		    CASE .T.
		      * A VFP 3.0 bug prevents drag icons (.cur files) from being changed at runtime
		      * unless the .CUR files exists as a seperate file - the icon cannot be built into 
		      * the .APP file. Until VFP fixes this bug, we don't change the icon at runtime.
		      RETURN .T.
		    CASE nState = 0 && Enter object
		      oSource.DragIcon = THIS.Parent.cDropIcon
		    CASE nState = 1 && Leave object
		      oSource.DragIcon = THIS.Parent.cNoDropIcon
		  ENDCASE
		
	ENDPROC

	PROCEDURE lstSelected.GotFocus
		THIS.Parent.Refresh
		
	ENDPROC

	PROCEDURE lstSelected.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		THIS.Parent.nXCoord = m.nXCoord
		THIS.Parent.nYCoord = m.nYCoord
		
	ENDPROC

	PROCEDURE lstSelected.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF m.nButton = 1 && Left Mouse
		  IF ABS(m.nXCoord - THIS.Parent.nXCoord) > THIS.Parent.nDragThreshold ;
		  OR ABS(m.nYCoord - THIS.Parent.nYCoord) > THIS.Parent.nDragThreshold
		    * A VFP 3.0 bug prevents drag icons (.cur files) from being changed at runtime
		    * unless the .CUR files exists as a seperate file - the icon cannot be built into 
		    * the .APP file. Until VFP fixes this bug, we don't change the icon at runtime.
		    * THIS.DragIcon = THIS.Parent.cDropIcon
			THIS.Drag(1)
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE lstSelected.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		THIS.Parent.Refresh
		
	ENDPROC

	PROCEDURE lstSource.Click
		* Clear 'selected' flag for all original items in destination listbox.
		FOR ix = 1 TO THIS.Parent.lstSelected.ListCount
		  THIS.Parent.lstSelected.Selected[m.ix] = .F.
		ENDFOR
		THIS.Parent.Refresh()
		
	ENDPROC

	PROCEDURE lstSource.DblClick
		THIS.Parent.SelectItem(THIS.ListIndex)
		THIS.Parent.Refresh()
		
	ENDPROC

	PROCEDURE lstSource.DragDrop
		LPARAMETERS oSource, nXCoord, nYCoord
		IF oSource.Name != THIS.Name
		  THIS.Parent.cmdDeselect.Click()
		ENDIF
		
	ENDPROC

	PROCEDURE lstSource.DragOver
		LPARAMETERS oSource, nXCoord, nYCoord, nState
		  DO CASE
		    CASE .T.
		      * A VFP 3.0 bug prevents drag icons (.cur files) from being changed at runtime
		      * unless the .CUR files exists as a seperate file - the icon cannot be built into 
		      * the .APP file. Until VFP fixes this bug, we don't change the icon at runtime.
		      RETURN .T.
		    CASE nState = 0 && Enter object
		      oSource.DragIcon = THIS.Parent.cDropIcon
		    CASE nState = 1 && Leave object
		      oSource.DragIcon = THIS.Parent.cNoDropIcon
		  ENDCASE
		
	ENDPROC

	PROCEDURE lstSource.GotFocus
		THIS.Parent.Refresh()
		
	ENDPROC

	PROCEDURE lstSource.MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		THIS.Parent.nXCoord = m.nXCoord
		THIS.Parent.nYCoord = m.nYCoord
		
	ENDPROC

	PROCEDURE lstSource.MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		IF m.nButton = 1 && Left Mouse
		  IF ABS(m.nXCoord - THIS.Parent.nXCoord) > THIS.Parent.nDragThreshold ;
		  OR ABS(m.nYCoord - THIS.Parent.nYCoord) > THIS.Parent.nDragThreshold
		    * A VFP 3.0 bug prevents drag icons (.cur files) from being changed at runtime
		    * unless the .CUR files exists as a seperate file - the icon cannot be built into 
		    * the .APP file. Until VFP fixes this bug, we don't change the icon at runtime.
		    * THIS.DragIcon = THIS.Parent.cDropIcon
			THIS.Drag(1)
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE lstSource.MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		THIS.Parent.Refresh()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntprogressbar AS cntcontainercustom OF "..\custom\ccontrol.vcx" 		&& A progress indicator bar
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\progbar.bmp" ClassIcon="..\graphics\progbar.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblPercent" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="shpProgress" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: drawframe		&& Draw frame box around progress bar.
		*m: percent		&& Return current percent displayed.
		*m: setrange		&& Set low and high end of progress range. Default is 0 to 100.
		*m: update		&& Update progress display
		*p: l3dframe		&& True to display a 3d frame around bar.
		*p: ncursorhandle		&& Hourglass cursor handle
		*p: nmaxvalue		&& Value corresponding to 100%
		*p: nminvalue		&& Value corresponding to 0%
		*p: nvalue		&& Current progress bar value displayed
	*</DefinedPropArrayMethod>

	PROTECTED ncursorhandle
	BackStyle = 1
	BorderWidth = 0
	ColorSource = 0
	Height = 17
	l3dframe = .T.		&& True to display a 3d frame around bar.
	MousePointer = 11
	Name = "cntprogressbar"
	nmaxvalue = 100		&& Value corresponding to 100%
	nminvalue = 0		&& Value corresponding to 0%
	nvalue = 0		&& Current progress bar value displayed
	Width = 324

	ADD OBJECT 'lblPercent' AS lbltextcustom WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "0%", ;
		Height = 16, ;
		Left = 34, ;
		MousePointer = 11, ;
		Name = "lblPercent", ;
		Top = 1, ;
		Width = 255, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'shpProgress' AS shpshapecustom WITH ;
		BackStyle = 1, ;
		BorderStyle = 0, ;
		BorderWidth = 0, ;
		ColorSource = 0, ;
		DrawMode = 14, ;
		Height = 17, ;
		Left = 0, ;
		MousePointer = 11, ;
		Name = "shpProgress", ;
		SpecialEffect = 1, ;
		Top = 0, ;
		Width = 325, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="shape" />
	
	PROCEDURE drawframe		&& Draw frame box around progress bar.
		LOCAL nTop, nLeft
		
		THISFORM.Draw()
		m.nTop = OBJTOCLIENT(THIS, 1)
		m.nLeft = OBJTOCLIENT(THIS, 2)
		IF THIS.l3dFrame
		  THISFORM.BeveledBox(m.nLeft - 2, m.nTop - 2, m.nLeft + THIS.Width + 2, m.nTop + THIS.Height + 2)
		ELSE
		  THISFORM.ForeColor = 0
		  THISFORM.Box(m.nLeft - 2, m.nTop - 2, m.nLeft + THIS.Width + 2, m.nTop + THIS.Height + 2)
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		*++
		* Simple progress indicator bar.
		*
		* Copyright 1997-2003, Soft Classics, Ltd.
		*--
		#include ..\common\win32.h
		DECLARE INTEGER LoadCursor IN user32 AS LoadMouseCursor INTEGER nInstance, INTEGER nCursor
		
		THIS.nCursorHandle = LoadMouseCursor(0, IDC_WAIT)
		
		WITH THIS.shpProgress
		  .Left = 0
		  .Top = 0
		  .Width = 0
		  .Height = THIS.Height + 1   && Containers are one pixel bigger than shapes at the same size
		  .BackColor = GetSysColor(COLOR_HIGHLIGHT)
		ENDWITH
		
		WITH THIS.lblPercent
		  .Left = 0
		  .Top = INT((THIS.Height - .Height) / 2)
		  .Width = THIS.Width
		ENDWITH
		
	ENDPROC

	PROCEDURE percent		&& Return current percent displayed.
		* Return current percentage displayed.
		RETURN (THIS.shpProgress.Width / (THIS.Width + 1)) * 100
		
	ENDPROC

	PROCEDURE Refresh
		IF THIS.Visible AND THIS.Parent.Visible
		  THIS.DrawFrame()
		ENDIF
		
	ENDPROC

	PROCEDURE setrange		&& Set low and high end of progress range. Default is 0 to 100.
		LPARAMETER nMin, nMax
		
		THIS.shpProgress.Width = 0
		THIS.lblPercent.Caption = '0%'
		
		IF TYPE('m.nMin') = 'N'
		  THIS.nMinValue = m.nMin
		ENDIF
		IF TYPE('m.nMax') = 'N'
		  THIS.nMaxValue = m.nMax
		ENDIF
		
	ENDPROC

	PROCEDURE update		&& Update progress display
		LPARAMETER nValue
		*++
		* Update progress bar. Return .T. if displayed width has changed.
		*--
		LOCAL nWidth
		
		IF PCOUNT() > 0
		  THIS.nValue = MAX(THIS.nMinValue, MIN(m.nValue, THIS.nMaxValue)) - THIS.nMinValue
		ENDIF
		m.nWidth = INT((THIS.Width + 1) * (THIS.nValue / (THIS.nMaxValue - THIS.nMinValue)))
		
		* Actual display updates are expensive, so optimize out unnecessary ones.
		IF m.nWidth != THIS.shpProgress.Width
		  THIS.lblPercent.Caption = LTRIM(STR((m.nWidth / THIS.Width) * 100)) + '%'
		  THIS.shpProgress.Width = m.nWidth
		  = SetMouseCursor(THIS.nCursorHandle)    && Force cursor to an hourglass
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE lblPercent.Refresh
		THIS.Caption = ALLTRIM(STR(THIS.Parent.Percent())) + '%'
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cntrichtexteditor AS cntcontainercustom OF "..\custom\ccontrol.vcx" 		&& Rich Textbox with controls for applying text formatting
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\richtext.bmp" ClassIcon="..\graphics\richtext.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="chkBold" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkItalic" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUnderline" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboFont" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdColor" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="spnFontsize" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkCenter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkRight" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkBullet" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oleRichText" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*p: lnostore		&& Internal flag for optimization
		*p: nbulletindent		&& Indentation for bulleted items
		*a: afontnames[1,0]		&& Array of available fonts
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Height = 114
	Name = "cntrichtexteditor"
	nbulletindent = 12		&& Indentation for bulleted items
	Width = 368

	ADD OBJECT 'cboFont' AS combobox WITH ;
		FontSize = 8, ;
		Height = 21, ;
		Left = 64, ;
		Name = "cboFont", ;
		RowSource = "", ;
		RowSourceType = 5, ;
		Style = 2, ;
		TabIndex = 5, ;
		TabStop = .F., ;
		ToolTipText = "Font Name", ;
		Top = 0, ;
		Width = 138, ;
		ZOrderSet = 3
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'chkBold' AS checkbox WITH ;
		Caption = "", ;
		FontBold = .T., ;
		Height = 20, ;
		Left = 2, ;
		Name = "chkBold", ;
		Picture = ..\graphics\bld.bmp, ;
		Style = 1, ;
		TabIndex = 2, ;
		TabStop = .F., ;
		ToolTipText = "Bold", ;
		Top = 0, ;
		Width = 19, ;
		ZOrderSet = 0
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkBullet' AS checkbox WITH ;
		Caption = "", ;
		FontUnderline = .T., ;
		Height = 20, ;
		Left = 346, ;
		Name = "chkBullet", ;
		Picture = ..\graphics\bullet.bmp, ;
		Style = 1, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		ToolTipText = "Bullet", ;
		Top = 0, ;
		Width = 20, ;
		ZOrderSet = 9
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkCenter' AS checkbox WITH ;
		Caption = "", ;
		FontItalic = .T., ;
		Height = 20, ;
		Left = 299, ;
		Name = "chkCenter", ;
		Picture = ..\graphics\ctr.bmp, ;
		Style = 1, ;
		TabIndex = 3, ;
		TabStop = .F., ;
		ToolTipText = "Align Center", ;
		Top = 0, ;
		Width = 20, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkItalic' AS checkbox WITH ;
		Caption = "", ;
		FontItalic = .T., ;
		Height = 20, ;
		Left = 22, ;
		Name = "chkItalic", ;
		Picture = ..\graphics\itl.bmp, ;
		Style = 1, ;
		TabIndex = 3, ;
		TabStop = .F., ;
		ToolTipText = "Italic", ;
		Top = 0, ;
		Width = 19, ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkLeft' AS checkbox WITH ;
		Caption = "", ;
		FontBold = .T., ;
		Height = 20, ;
		Left = 278, ;
		Name = "chkLeft", ;
		Picture = ..\graphics\lft.bmp, ;
		Style = 1, ;
		TabIndex = 2, ;
		TabStop = .F., ;
		ToolTipText = "Align Left", ;
		Top = 0, ;
		Width = 20, ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkRight' AS checkbox WITH ;
		Caption = "", ;
		FontUnderline = .T., ;
		Height = 20, ;
		Left = 320, ;
		Name = "chkRight", ;
		Picture = ..\graphics\rt.bmp, ;
		Style = 1, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		ToolTipText = "Align Right", ;
		Top = 0, ;
		Width = 20, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkUnderline' AS checkbox WITH ;
		Caption = "", ;
		FontUnderline = .T., ;
		Height = 20, ;
		Left = 42, ;
		Name = "chkUnderline", ;
		Picture = ..\graphics\undrln.bmp, ;
		Style = 1, ;
		TabIndex = 4, ;
		TabStop = .F., ;
		ToolTipText = "Underline", ;
		Top = 0, ;
		Width = 19, ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'cmdColor' AS commandbutton WITH ;
		Caption = "", ;
		Height = 20, ;
		Left = 252, ;
		Name = "cmdColor", ;
		Picture = ..\graphics\color.bmp, ;
		TabIndex = 6, ;
		TabStop = .F., ;
		ToolTipText = "Color", ;
		Top = 0, ;
		Width = 20, ;
		ZOrderSet = 4
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'oleRichText' AS olerichtextbox WITH ;
		creposition = vStretch,hStretch, ;
		Height = 90, ;
		Left = 0, ;
		Name = "oleRichText", ;
		TabIndex = 1, ;
		Top = 23, ;
		Width = 367, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="cmactivx.vcx" BaseClass="olecontrol" OLEObject="c:\winnt\system32\richtx32.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAi53Z26MMBAwAAAIABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAfAAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABPAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAGAAAAAAAAAABAAAAAIAAAD+////BQAAAP7////+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9giHw7j9cbELm1BAIcAJQCIUM0EggAAADuJQAATQkAACFDNBIBAAYAMAAAAAAAAAAAAAEAAQAAAAAAtEQAgB1GTwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABcAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgcWhqIFp0dVFoYTtqZGZuW2lhZXRyIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAACADgAAAEhpZGVTZWxlY3Rpb24ABQAAAEwAAAAADAAAAFJpZ2h0TWFyZ2luABEAAABODQAAAAcAAAAAAAAAAAAAAAUAAIAAAAAAAAABAAIAAQABAAIAAgAAAANS4wuRj84RneMAqgBLuFEBAAAAkAGQXwEABUFyaWFsAAAAAACww0ALAAAAU2Nyb2xsQmFycwAJAAAASQoAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABcZnBycTIgU3lzdGVtO317XGYzXGZuaWwgQXJpYWw7fX0NCntcY29sb3J0YmxccmVkMFxncmVlbjBcYmx1ZTA7fQ0KXGRlZmxhbmcxMDMzXHBhcmRccGxhaW5cZjNcZnMxOCANClxwYXIgfQ0KAAEAAACQAZBfAQAFQXJpYWwAAA==" />

	ADD OBJECT 'spnFontsize' AS spinner WITH ;
		FontSize = 8, ;
		Height = 20, ;
		InputMask = "999", ;
		KeyboardHighValue = 120, ;
		KeyboardLowValue = 4, ;
		Left = 205, ;
		Margin = 1, ;
		Name = "spnFontsize", ;
		NullDisplay = " ", ;
		SpinnerHighValue = 120.00, ;
		SpinnerLowValue = 4.00, ;
		TabIndex = 7, ;
		TabStop = .F., ;
		ToolTipText = "Font Size", ;
		Top = 0, ;
		Width = 42, ;
		ZOrderSet = 5
		*< END OBJECT: BaseClass="spinner" />
	
	PROCEDURE Resize
		THISFORM.LockScreen = .F.
		DODEFAULT()
		
	ENDPROC

	PROCEDURE cboFont.Click
		IF THIS.Parent.oleRichText.BeforeChange()
		  THIS.Parent.oleRichText.SelFontName = THIS.Value
		ENDIF
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE cboFont.Init
		=AFONT(THIS.Parent.aFontNames)
		THIS.RowSource = 'THIS.Parent.aFontNames'
		
	ENDPROC

	PROCEDURE cboFont.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE cboFont.Refresh
		THIS.Value = THIS.Parent.oleRichText.SelFontName
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE cboFont.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE chkBold.Click
		IF THIS.Parent.oleRichText.BeforeChange()
		  THIS.Parent.oleRichText.SelBold = NOT THIS.Parent.oleRichText.SelBold
		  THIS.Refresh()
		ENDIF
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE chkBold.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE chkBold.Refresh
		THIS.Value = THIS.Parent.oleRichText.SelBold
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE chkBold.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE chkBullet.Click
		IF THIS.Parent.oleRichText.BeforeChange()
		  IF NOT THIS.Parent.oleRichText.SelBullet
		    THIS.Parent.oleRichText.SelTabcount = 1
		    THIS.Parent.oleRichText.SelTabs[0] = THIS.Parent.nBulletIndent * 2
		    THIS.Parent.oleRichText.BulletIndent = THIS.Parent.nBulletIndent
		    THIS.Parent.oleRichText.SelBullet = .T.
		  ELSE
		    THIS.Parent.oleRichText.SelBullet = .F.
		  ENDIF
		  THIS.Refresh()
		ENDIF
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE chkBullet.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE chkBullet.Refresh
		THIS.Value = THIS.Parent.oleRichText.SelBullet
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE chkBullet.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE chkCenter.Click
		IF THIS.Parent.oleRichText.BeforeChange()
		  THIS.Parent.oleRichText.SelAlignment = 2
		ENDIF
		THIS.Parent.chkLeft.Refresh()
		THIS.Parent.chkRight.Refresh()
		THIS.Parent.chkCenter.Refresh()
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE chkCenter.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE chkCenter.Refresh
		THIS.Value = NOT ISNULL(THIS.Parent.oleRichText.SelAlignment) AND THIS.Parent.oleRichText.SelAlignment = 2
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE chkCenter.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE chkItalic.Click
		IF THIS.Parent.oleRichText.BeforeChange()
		  THIS.Parent.oleRichText.SelItalic = NOT THIS.Parent.oleRichText.SelItalic
		  THIS.Refresh()
		ENDIF
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE chkItalic.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE chkItalic.Refresh
		THIS.Value = THIS.Parent.oleRichText.SelItalic
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE chkItalic.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE chkLeft.Click
		IF THIS.Parent.oleRichText.BeforeChange()
		  THIS.Parent.oleRichText.SelAlignment = 0
		ENDIF
		THIS.Parent.chkLeft.Refresh()
		THIS.Parent.chkRight.Refresh()
		THIS.Parent.chkCenter.Refresh()
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE chkLeft.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE chkLeft.Refresh
		THIS.Value = NOT ISNULL(THIS.Parent.oleRichText.SelAlignment) AND THIS.Parent.oleRichText.SelAlignment = 0
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE chkLeft.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE chkRight.Click
		IF THIS.Parent.oleRichText.BeforeChange()
		  THIS.Parent.oleRichText.SelAlignment = 1
		ENDIF
		THIS.Parent.chkLeft.Refresh()
		THIS.Parent.chkRight.Refresh()
		THIS.Parent.chkCenter.Refresh()
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE chkRight.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE chkRight.Refresh
		THIS.Value = NOT ISNULL(THIS.Parent.oleRichText.SelAlignment) AND THIS.Parent.oleRichText.SelAlignment = 1
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE chkRight.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE chkUnderline.Click
		IF THIS.Parent.oleRichText.BeforeChange()
		  THIS.Parent.oleRichText.SelUnderline = NOT THIS.Parent.oleRichText.SelUnderline
		  THIS.Refresh()
		ENDIF
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE chkUnderline.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE chkUnderline.Refresh
		THIS.Value = THIS.Parent.oleRichText.SelUnderline
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE chkUnderline.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE cmdColor.Click
		LOCAL nColor
		IF THIS.Parent.oleRichText.BeforeChange()
		  m.nColor = GETCOLOR()
		  IF m.nColor >= 0
		    THIS.Parent.oleRichText.SelColor = m.nColor
		  ENDIF
		ENDIF
		THIS.Parent.oleRichText.SetFocus
		
	ENDPROC

	PROCEDURE cmdColor.LostFocus
		THIS.Parent.lNoStore = .NULL.
		
	ENDPROC

	PROCEDURE cmdColor.Refresh
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE cmdColor.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

	PROCEDURE oleRichText.contextmenubuild
		DODEFAULT()
		
		IF NOT THIS.Locked
		  THISFORM.ContextMenuBar(CTX_BAR_CUSTOM, '\-')
		  THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 1, '%barleftindentplus')
		  THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 2, '%barleftindentminus')
		  THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 3, '%barlefthangplus')
		  THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 4, '%barlefthangminus')
		  THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 5, '\-')
		  THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 6, '%barindentreset')
		
		  THISFORM.ContextMenuBarDisable(CTX_BAR_CUSTOM + 1, ISNULL(THIS.SelIndent))
		  THISFORM.ContextMenuBarDisable(CTX_BAR_CUSTOM + 2, ISNULL(THIS.SelIndent))
		  THISFORM.ContextMenuBarDisable(CTX_BAR_CUSTOM + 3, ISNULL(THIS.SelHangingIndent))
		  THISFORM.ContextMenuBarDisable(CTX_BAR_CUSTOM + 4, ISNULL(THIS.SelHangingIndent))
		ENDIF
		
	ENDPROC

	PROCEDURE oleRichText.contextmenuexecute
		LPARAMETER cOption
		*++
		* Process custom context menu items for this form.
		*--
		
		* VFP/COM bug will not allow read & write to same RTF property in the same line
		* So we need to use an intermediate memory variable.
		LOCAL nIndent
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%barleftindentplus'
		      IF THIS.BeforeChange()
		        m.nIndent = THIS.SelIndent + 4
		        THIS.SelIndent = m.nIndent
		      ENDIF
		    CASE m.cOption = '%barleftindentminus'
		      IF THIS.BeforeChange()
		        m.nIndent = THIS.SelIndent - 4
		        THIS.SelIndent = m.nIndent
		      ENDIF
		    CASE m.cOption = '%barlefthangplus'
		      IF THIS.BeforeChange()
		        m.nIndent = THIS.SelHangingIndent + 4
		        THIS.SelHangingIndent = m.nIndent
		      ENDIF
		    CASE m.cOption = '%barlefthangminus'
		      IF THIS.BeforeChange()
		        m.nIndent = THIS.SelHangingIndent - 4
		        THIS.SelHangingIndent = m.nIndent
		      ENDIF
		    CASE m.cOption = '%barindentreset'
		      IF THIS.BeforeChange()
		        THIS.SelIndent = 0
		        THIS.SelHangingIndent = 0
		      ENDIF
		    OTHERWISE
		      DODEFAULT(m.cOption)
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE oleRichText.DblClick
		THIS.SelChange()
		
	ENDPROC

	PROCEDURE oleRichText.LostFocus
		* Don't update bound data if user is clicking on a formatting button.
		IF NOT THIS.Parent.lNoStore
		  DODEFAULT()
		ENDIF
		THIS.Parent.lNoStore = .F.
		
	ENDPROC

	PROCEDURE oleRichText.SelChange
		* Refresh formatting buttons whenever the selected text changes
		THIS.Parent.ChkBold.refresh()
		THIS.Parent.ChkItalic.refresh()
		THIS.Parent.ChkUnderline.refresh()
		THIS.Parent.cboFont.refresh()
		THIS.Parent.spnFontSize.refresh()
		THIS.Parent.cmdColor.refresh()
		THIS.Parent.chkLeft.refresh()
		THIS.Parent.chkCenter.refresh()
		THIS.Parent.chkRight.refresh()
		THIS.Parent.chkBullet.refresh()
		
	ENDPROC

	PROCEDURE oleRichText.showcontrol
		DODEFAULT()
		
		* Refresh editing buttons whenever locked state may have changed.
		THIS.SelChange()
		
	ENDPROC

	PROCEDURE spnFontsize.DblClick
		THIS.Parent.oleRichText.SetFocus()
		
	ENDPROC

	PROCEDURE spnFontsize.DownClick
		THIS.DblClick()
		
	ENDPROC

	PROCEDURE spnFontsize.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		IF INLIST(m.nKeycode, 13, 9)
		  THIS.DblClick()
		ENDIF
		
	ENDPROC

	PROCEDURE spnFontsize.LostFocus
		THIS.Parent.lNoStore = .NULL.
		IF NOT ISNULL(THIS.Value) AND THIS.Parent.oleRichText.BeforeChange()
		  THIS.Parent.oleRichText.SelFontSize = THIS.Value
		ENDIF
		
	ENDPROC

	PROCEDURE spnFontsize.Refresh
		THIS.Value = THIS.Parent.oleRichText.SelFontSize
		THIS.Enabled = NOT THIS.Parent.oleRichText.Locked
		
	ENDPROC

	PROCEDURE spnFontsize.UpClick
		THIS.DblClick()
		
	ENDPROC

	PROCEDURE spnFontsize.When
		* Don't update RTF datasource every time user clicks a formatting button.
		THIS.Parent.lNoStore = NOT ISNULL(THIS.Parent.lNoStore)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctlcombonavigator AS control 		&& A combobox record navigation control for data forms
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboNavigate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNavUp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNavDn" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: add		&& Adds a new member to a Collection.
		*m: contextmenubuild
		*m: contextmenuexecute
		*m: delete		&& Delete Event.
		*m: findrecord
		*m: needrebuild		&& Mark the contents of the nav control invalid, so next refresh will trigger a rebuild.
		*m: rebuild
		*m: set		&& set property values for embedded controls
		*m: settipstatus		&& Set tooltip and statusbar text for component controlss
		*p: ccolumnwidths		&& This property is written to the contained combobox ColumnWidths property. For a multicolumn popup display, specify the column widths here.
		*p: cdisplayexpression		&& Expression to display for each row in the navigation array.
		*p: cdisplayname		&& Localized control name used in help and error message dialogs.
		*p: cemptytext		&& Text displayed in navigator when there are no records.
		*p: cfilter		&& Filter expression to apply to recordset being navigated.
		*p: chelpclasskey		&& Class help key list
		*p: chelpkey
		*p: cmenubardelete		&& Context menu bar prompt for Delete option.
		*p: cmenubaredit		&& Context menu bar prompt for Edit option.
		*p: cmenubarnew		&& Context menu bar prompt for New option.
		*p: cnewtext		&& Text displayed in navigator for a new record.
		*p: creposition
		*p: cworkarea		&& Workarea name that this control navigates through.
		*p: lallowdelete		&& Set true to enable "Delete Record" context menu bar
		*p: lallowedit		&& Set true to enable "Edit Record" context menu bar.
		*p: lallownew		&& Set true to enable "New Record" context menu bar
		*p: lsorted		&& If true, navigation list is sorted alphabeticaly by display expression.
	*</DefinedPropArrayMethod>

	ccolumnwidths = 		&& This property is written to the contained combobox ColumnWidths property. For a multicolumn popup display, specify the column widths here.
	cdisplayexpression = .F.		&& Expression to display for each row in the navigation array.
	cdisplayname = 		&& Localized control name used in help and error message dialogs.
	cemptytext = %txtNavigatorEmpty		&& Text displayed in navigator when there are no records.
	cfilter = 		&& Filter expression to apply to recordset being navigated.
	chelpclasskey = %hlpNavigator		&& Class help key list
	chelpkey = 
	cmenubardelete = %barDeleteRecord		&& Context menu bar prompt for Delete option.
	cmenubaredit = %barEditRecord		&& Context menu bar prompt for Edit option.
	cmenubarnew = %barNewRecord		&& Context menu bar prompt for New option.
	cnewtext = %txtNavigatorNew		&& Text displayed in navigator for a new record.
	creposition = 
	cworkarea = 		&& Workarea name that this control navigates through.
	Height = 21
	lallowdelete = .T.		&& Set true to enable "Delete Record" context menu bar
	lallownew = .T.		&& Set true to enable "New Record" context menu bar
	Name = "ctlcombonavigator"
	Width = 151

	ADD OBJECT 'cboNavigate' AS combobox WITH ;
		Height = 22, ;
		Left = 0, ;
		Name = "cboNavigate", ;
		RowSourceType = 5, ;
		StatusBarText = " ", ;
		Style = 2, ;
		Top = 0, ;
		Width = 108
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'cmdNavDn' AS commandbutton WITH ;
		Caption = "", ;
		Height = 10, ;
		Left = 107, ;
		Name = "cmdNavDn", ;
		Picture = ..\graphics\navdn.bmp, ;
		TabStop = .F., ;
		Top = 11, ;
		Width = 11
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdNavUp' AS commandbutton WITH ;
		Caption = "", ;
		Height = 10, ;
		Left = 107, ;
		Name = "cmdNavUp", ;
		Picture = ..\graphics\navup.bmp, ;
		TabStop = .F., ;
		Top = 0, ;
		Width = 11
		*< END OBJECT: BaseClass="commandbutton" />
	
	PROCEDURE add		&& Adds a new member to a Collection.
		*++
		* Add a new row to the end of the current navigation array. The current record in the
		* control workarea contains the new record to reference.
		*--
		LOCAL nNewRow, cText, cEmpty, cExpressions
		
		  * Rebuild the control if parent changed since last refresh, or rebuild explicitly requested via flag.
		  IF THIS.lNeedRebuild OR NOT BITTEST(THIS.nControlFlags, CTLFLAG_INITIALIZED) ;
		  OR (NOT EMPTY(THIS.cParentAlias) AND THIS.nParentRecno != RECNO(THIS.cParentAlias))
		    THIS.Rebuild()
		
		    * For table-buffered cursors, the new row may already exist in the array.
		    m.nNewRow = ASCAN(THIS.aRecordList, RECNO(THIS.cWorkarea))
		    IF m.nNewRow > 0
		      m.nNewRow = ASUBSCRIPT(THIS.aRecordList, m.nNewRow, 1)
		    ENDIF
		  ENDIF
		    
		  IF EMPTY(m.nNewRow)
		    THIS.nRecordCount = THIS.nRecordCount + 1
		    m.nNewRow = THIS.nRecordCount
		    DIMENSION THIS.aRecordList[m.nNewRow, THIS.cboNavigate.ColumnCount + 1]
		    THIS.aRecordList[m.nNewRow, THIS.cboNavigate.ColumnCount + 1] = RECNO()
		  ENDIF
		
		  * Translate NewText string if necessary
		  IF LEFT(THIS.cNewText, 1) = '%' AND NOT ISNULL(THISFORM.oMessage)
		    THIS.cNewText = THISFORM.oMessage.TranslateString(THIS.cNewText)
		  ENDIF
		  m.cExpressions = THIS.cNewText
		
		  FOR nCol = 1 TO THIS.cboNavigate.ColumnCount
		    m.cText = EVALUATE(THIS.aDisplayExpression[m.nCol])
		    m.cEmpty = GetToken(@m.cExpressions, '|')
		    IF EMPTY(m.cText)
		     THIS.aRecordList[m.nNewRow, m.nCol] = m.cEmpty
		    ELSE
		      THIS.aRecordList[m.nNewRow, m.nCol] = m.cText
		    ENDIF
		  ENDFOR
		  WITH THIS.cboNavigate
		    .Rowsource = 'THIS.Parent.aRecordList'
		    .ListIndex = m.nNewRow
		  ENDWITH
		  RETURN .T.
		
	ENDPROC

	PROCEDURE contextmenubuild
		*++
		*>>Define all the bars for a navigator context menu. Return false if no bars are defined.
		*--
		  IF NOT EMPTY(THIS.cWorkarea)
		    LOCAL cName
		    m.cName = IIF(EMPTY(THIS.cDisplayName), THISFORM.NiceCursorName(THIS.cWorkarea), THIS.cDisplayName)
		    IF THIS.lAllowNew AND NOT EMPTY(THIS.cMenuBarNew)
		      THISFORM.ContextMenuBar(CTX_BAR_CTL_NEW, THIS.cMenuBarNew, m.cName)
		      IF NOT THISFORM.IsEnabled('New', THIS.cWorkarea)
		        THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_NEW, .T.)
		      ENDIF
		    ENDIF
		    IF THIS.lAllowEdit AND NOT EMPTY(THIS.cMenuBarEdit)
		      THISFORM.ContextMenuBar(CTX_BAR_CTL_EDIT, THIS.cMenuBarEdit, m.cName)
		      IF NOT THISFORM.IsEnabled('Edit', THIS.cWorkarea)
		        THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_EDIT, .T.)
		      ENDIF
		      THISFORM.ContextMenuSeparator(CTX_BAR_CTL_NULL)
		    ENDIF
		    IF THIS.lAllowDelete AND NOT EMPTY(THIS.cMenuBarDelete)
		      THISFORM.ContextMenuBar(CTX_BAR_CTL_DELETE, THIS.cMenuBarDelete, m.cName)
		      IF NOT THISFORM.IsEnabled('Delete', THIS.cWorkarea)
		        THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_DELETE, .T.)
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .T.
		
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETER cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption == '%barhelp'
		      THIS.ShowWhatsThis(THIS.WhatsThisHelpID)
		
		    CASE m.cOption == PROPER(THIS.cMenuBarNew)
		      THISFORM.New(THIS.cWorkarea)
		
		    CASE m.cOption == PROPER(THIS.cMenuBarEdit)
		      THISFORM.Edit(THIS.cWorkarea)
		
		    CASE m.cOption == PROPER(THIS.cMenuBarDelete)
		      THISFORM.Delete(THIS.cWorkarea)
		
		    OTHERWISE
		      RETURN DODEFAULT(m.cOption)
		  ENDCASE
		
	ENDPROC

	PROCEDURE delete		&& Delete Event.
		*++
		* Delete the current navigation array row.
		*--
		LOCAL ix, nCol, cExpressions
		  m.ix = THIS.cboNavigate.ListIndex
		
		  * If the current record is not deleted, assume the current row was removed from the edit buffer.
		  IF m.ix > 0 AND THIS.nRecordCount > 0 ;
		  AND (NOT DELETED(THIS.cWorkarea) OR RECNO(THIS.cWorkarea) = THIS.aRecordList[m.ix, THIS.cboNavigate.ColumnCount + 1])
		    ADEL(THIS.aRecordList, m.ix)
		    THIS.nRecordCount = THIS.nRecordCount - 1
		    IF THIS.nRecordCount > 0
		      DIMENSION THIS.aRecordList[THIS.nRecordCount, THIS.cboNavigate.ColumnCount + 1]
		    ELSE
		      * If there are no records left, evaluate the cEmptyText expression list
		      IF LEFT(THIS.cEmptyText, 1) = '%' AND NOT ISNULL(THISFORM.oMessage)
		        THIS.cEmptyText = THISFORM.oMessage.TranslateString(THIS.cEmptyText)
		      ENDIF
		      m.cExpressions = THIS.cEmptyText
		      FOR nCol = 1 TO THIS.cboNavigate.ColumnCount
		        THIS.aRecordList[1, m.nCol] = GetToken(@m.cExpressions, '|')
		      ENDFOR
		      THIS.aRecordList[1, THIS.cboNavigate.ColumnCount + 1] = 0
		    ENDIF
		    THIS.cboNavigate.Rowsource = 'THIS.Parent.aRecordList'
		  ENDIF
		
	ENDPROC

	PROCEDURE findrecord
		LPARAMETERS nRecno
		LOCAL ix
		
		  m.ix = ASCAN(THIS.aRecordList, m.nRecno)
		  IF m.ix > 0
		    RETURN ASUBSCRIPT(THIS.aRecordList, m.ix, 1)
		  ENDIF
		  RETURN 0   && Not found
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine cursor navigation control
		*
		* Copyright 1997 Soft Classics, Ltd. All Rights Reserved worldwide.
		*--
		  THIS.BorderWidth = 0
		
		  THIS.AddProperty('nControlFlags', 0)
		  THIS.AddProperty('lNeedRebuild')
		  THIS.AddProperty('nDataColumns', 0)
		  THIS.AddProperty('aRecordList[1]', '')
		  THIS.AddProperty('aDisplayExpression[1]', '')
		  THIS.AddProperty('cParentAlias', '')
		  THIS.AddProperty('nParentRecno', 0)
		  THIS.AddProperty('nRecordCount', 0)
		  THIS.AddProperty('nRight', .NULL.)      && Offset of right edge from right of parent container.
		  THIS.AddProperty('nBottom', .NULL.)     && Offset of bottom edge from bottom of parent container.
		
		  * VFP does not always trigger resize() on init() for subclasses, so 
		  * we force it here to be sure contained controls are repositioned correctly in all cases.
		  THIS.Resize()
		
	ENDPROC

	PROCEDURE needrebuild		&& Mark the contents of the nav control invalid, so next refresh will trigger a rebuild.
		* Mark the contents of the nav control invalid, so next refresh will trigger a rebuild.
		THIS.lNeedRebuild = .T.
		
	ENDPROC

	PROCEDURE rebuild
		LOCAL ix, nCol, nSelect, nRecno, cExpressions, nColumnCount
		
		  * Initialize the control as soon as the workarea becomes available
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_INITIALIZED)
		    IF EMPTY(THIS.cWorkarea) OR NOT USED(THIS.cWorkarea)
		      RETURN .F.
		    ENDIF
		    THIS.cWorkarea = PROPER(THIS.cWorkarea)
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_INITIALIZED)
		    THIS.cParentAlias = THISFORM.cmDataManager.GetParent(THIS.cWorkarea)
		    THISFORM.cmDataManager.RegisterNavControl(THIS, THIS.cWorkarea, THISFORM)
		  ENDIF
		  THIS.lNeedRebuild = .F.
		
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		  m.nRecno = RECNO()
		
		  * If Row-Buffering Open the table in another workarea so we dont mess up buffering
		  IF NOT ISREADONLY(THIS.cWorkarea) AND CURSORGETPROP('Buffering', THIS.cWorkarea) <=3
		    UseAgain(THIS.cWorkarea)
		  ENDIF
		
		  * Remember the parent record number, and check for change on each refresh.
		  IF NOT EMPTY(THIS.cParentAlias)
		    THIS.nParentRecno = RECNO(THIS.cParentAlias)
		  ENDIF
		
		  * Copy the display expression string into an array, one element per column.
		  IF NOT ISNULL(THIS.cDisplayExpression)  && First time processing only
		    LOCAL cDelimiter
		    m.cExpressions = THIS.cDisplayExpression
		    m.cDelimiter = IIF('|' $ m.cExpressions OR EMPTY(THIS.cColumnWidths), '|', ',')
		    THIS.cboNavigate.ColumnCount = OCCURS(m.cDelimiter, m.cExpressions) + 1
		    IF NOT EMPTY(THIS.cColumnWidths)
		      THIS.cboNavigate.ColumnWidths = THIS.cColumnWidths
		    ENDIF
		
		    m.nColumnCount = THIS.cboNavigate.ColumnCount
		    DIMENSION THIS.aDisplayExpression[m.nColumnCount]
		    FOR nCol = 1 TO m.nColumnCount
		      * If no display expresson specified, default to the table field for this column.
		      THIS.aDisplayExpression[m.nCol] = ;
		                     IIF(EMPTY(m.cExpressions), FIELD(m.nCol), GetToken(@m.cExpressions, m.cDelimiter))
		    ENDFOR
		    THIS.cDisplayExpression = .NULL.
		  ELSE
		    m.nColumnCount = THIS.cboNavigate.ColumnCount
		  ENDIF
		
		  m.ix = 0
		  DIMENSION THIS.aRecordList[1, m.nColumnCount + 1]
		  IF EMPTY(THIS.cFilter)
		    THIS.cFilter = '.T.'
		  ENDIF
		  SCAN FOR EVALUATE(THIS.cFilter)
		    m.ix = m.ix + 1
		    DIMENSION THIS.aRecordList[ix, m.nColumnCount + 1]
		    FOR nCol = 1 TO m.nColumnCount
		      THIS.aRecordList[ix, m.nCol] = EVALUATE(THIS.aDisplayExpression[m.nCol])
		    ENDFOR
		    THIS.aRecordList[ix, m.nColumnCount + 1] = RECNO()
		  ENDSCAN
		
		  * If there are no records, evaluate the cEmptyText expression list
		  IF m.ix = 0
		    IF LEFT(THIS.cEmptyText, 1) = '%' AND NOT ISNULL(THISFORM.oMessage)
		      THIS.cEmptyText = THISFORM.oMessage.TranslateString(THIS.cEmptyText)
		    ENDIF
		    m.cExpressions = THIS.cEmptyText
		    FOR nCol = 1 TO m.nColumnCount
		      THIS.aRecordList[1, m.nCol] = GetToken(@m.cExpressions, '|')
		    ENDFOR
		    THIS.aRecordList[1, m.nColumnCount + 1] = 0
		  ENDIF
		
		  * Sort navigation array if desired.
		  IF THIS.lSorted
		    =ASORT(THIS.aRecordList, 1)
		  ENDIF
		
		  THIS.nRecordCount = m.ix
		  THIS.cboNavigate.Rowsource = 'THIS.Parent.aRecordList'
		
		  * Sync nav control to actual current record.
		  THIS.cboNavigate.ListIndex = MAX(1, THIS.FindRecord(m.nRecno))
		
		  * Restore original record position, or close clone as appropriate.
		  IF ALIAS() == UPPER(TRIM(THIS.cWorkarea))
		    IF m.nRecno <= RECCOUNT()
		      GOTO (m.nRecno)
		    ENDIF
		  ELSE
		    USE   && Close temporary workarea
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Refresh
		* If called before Init() event completes, we don't do anything. All CodeMine controls
		* need to allow for the possibility of Refresh() being called before Init(), since user
		* code in controls lower in Z order may trigger the refresh of other controls.
		IF PEMSTATUS(THIS, 'nControlFlags', 5)
		  * Container refresh occurs before combobox refresh.
		  * Rebuild display if the parent record has changed.
		  IF THIS.lNeedRebuild OR NOT BITTEST(THIS.nControlFlags, CTLFLAG_INITIALIZED) ;
		  OR (NOT EMPTY(THIS.cParentAlias) AND THIS.nParentRecno != RECNO(THIS.cParentAlias))
		    THIS.Rebuild()
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE Resize
		THIS.cboNavigate.Height = THIS.Height
		THIS.cboNavigate.Width = THIS.Width - THIS.cmdNavUp.Width
		
		THIS.cmdNavup.Left = THIS.Width - THIS.cmdNavup.Width
		THIS.cmdNavup.Height = (THIS.Height / 2) - 1
		
		THIS.cmdNavdn.Left = THIS.Width - THIS.cmdNavdn.Width
		THIS.cmdNavdn.Height = (THIS.Height / 2) - 1
		THIS.cmdNavdn.Top = THIS.cmdNavup.Height + 1
		
	ENDPROC

	PROCEDURE RightClick
		*++
		*>>Put up context menu on a right-click.
		*--
		LOCAL cOption
		
		  IF THISFORM.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		    m.cOption = THISFORM.ContextMenuActivate()
		    IF NOT EMPTY(m.cOption)
		      THIS.ContextMenuExecute(m.cOption)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE set		&& set property values for embedded controls
		LPARAMETER cProperty, uValue
		*++
		* Set various properties for the contained combobox.
		*--
		  m.cProperty = PROPER(TRIM(m.cProperty))
		  IF PEMSTATUS(THIS.cboNavigate, m.cProperty, 5)
		    STORE m.uValue TO ('THIS.cboNavigate.' + m.cProperty)
		  ENDIF
		
		  * Set property for the buttons too, if they have it.
		  IF PEMSTATUS(THIS.cmdNavUp, m.cProperty, 5)
		    STORE m.uValue TO ('THIS.cmdNavUp.' + m.cProperty)
		    STORE m.uValue TO ('THIS.cmdNavDn.' + m.cProperty)
		  ENDIF
		
	ENDPROC

	PROCEDURE settipstatus		&& Set tooltip and statusbar text for component controlss
		LPARAMETER cTiptext, cStatusText
		*++
		* Set tooltip and statusbar text for contained controls.
		*--
		  IF EMPTY(THIS.cboNavigate.ToolTipText) ;
		  AND (NOT PEMSTATUS(THISFORM, 'lButtonTipsOnly', 5) OR NOT THISFORM.lButtonTipsOnly)
		    THIS.cboNavigate.ToolTipText = m.cTipText
		  ENDIF
		  IF EMPTY(THIS.cmdNavUp.ToolTipText)
		    THIS.cmdNavUp.ToolTipText = m.cTipText
		  ENDIF
		  IF EMPTY(THIS.cmdNavDn.ToolTipText)
		    THIS.cmdNavDn.ToolTipText = m.cTipText
		  ENDIF
		  IF EMPTY(THIS.cboNavigate.StatusbarText)
		    THIS.cboNavigate.StatusbarText = m.cStatusText
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nWhatsThisHelpID
		*++
		* Show context help for the navigator.
		*--
		  IF PEMSTATUS(THISFORM, 'lCodemineHelp', 5)
		    IF THISFORM.lCodemineHelp
		      NODEFAULT                        && Don't process native help if using Codemine context help
		      THISFORM.DisplayHelp(THIS)       && Display help dialog.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnable
		
		* Refresh navigator whenever it's page activates.
		IF m.lEnable
		  THIS.Refresh()   && will call rebuild() if needed
		  THIS.cboNavigate.Refresh()
		  THIS.cmdNavUp.Refresh()
		  THIS.cmdNavDn.Refresh()
		ENDIF
		
	ENDPROC

	PROCEDURE cboNavigate.Refresh
		LOCAL ix, nCol, cText, nSelect
		
		IF BITTEST(THIS.Parent.nControlFlags, CTLFLAG_INITIALIZED)
		  IF THIS.Parent.nRecordCount = 0
		    THIS.ListIndex = 1
		  ELSE
		    * Use ASCAN() to re-sync nav control to actual current record.
		    IF THIS.ListIndex = 0 OR THIS.ListIndex > ALEN(THIS.Parent.aRecordList, 1) ;
		    OR RECNO(THIS.Parent.cWorkarea) != THIS.Parent.aRecordList[THIS.ListIndex, THIS.ColumnCount + 1]
		      m.ix = ASCAN(THIS.Parent.aRecordList, RECNO(THIS.Parent.cWorkarea))
		      IF m.ix > 0
		        m.ix = ASUBSCRIPT(THIS.Parent.aRecordList, m.ix, 1)
		      ENDIF
		      THIS.ListIndex = m.ix
		    ENDIF
		
		    * Update the displayed text for the current record on each refresh
		    IF THIS.ListIndex > 0
		      m.nSelect = SELECT()
		
		      * Evaluate the display expression in the navigator workarea.
		      SELECT (THIS.Parent.cWorkarea)
		      FOR nCol = 1 TO THIS.ColumnCount
		        m.cText = EVALUATE(THIS.Parent.aDisplayExpression[m.nCol])
		        IF NOT EMPTY(m.cText) OR NOT THISFORM.cmDataManager.IsNew(THIS.Parent.cWorkarea)
		          THIS.Parent.aRecordList[THIS.ListIndex, m.nCol] = m.cText
		        ENDIF
		      ENDFOR
		      SELECT (m.nSelect)
		    ENDIF
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE cboNavigate.RightClick
		THIS.Parent.RightClick()
		
	ENDPROC

	PROCEDURE cboNavigate.ShowWhatsThis
		LPARAMETERS nWhatsThisHelpID
		  NODEFAULT   && Defer to parent control object
		  RETURN THIS.Parent.ShowWhatsThis(m.nWhatsThisHelpID)
		
	ENDPROC

	PROCEDURE cboNavigate.Valid
		IF THIS.ListIndex > 0
		  LOCAL nNewRec
		  m.nNewRec = THIS.Parent.aRecordList[THIS.ListIndex, THIS.ColumnCount + 1]
		  IF NOT EMPTY(m.nNewRec) AND m.nNewRec != RECNO(THIS.Parent.cWorkarea)
		    IF NOT THISFORM.Goto(m.nNewRec, THIS.Parent.cWorkarea)
		      * If record couldn't move, make sure we correctly display whatever record we are left on.
		      THIS.Refresh()
		    ENDIF
		  ENDIF
		ENDIF
		RETURN .T.
		
	ENDPROC

	PROCEDURE cboNavigate.When
		IF PEMSTATUS(THISFORM, 'InitializeHelp', 5)
		  THISFORM.InitializeHelp(THIS.Parent)
		ENDIF
		
	ENDPROC

	PROCEDURE cmdNavDn.Click
		IF THIS.Parent.cboNavigate.ListIndex < THIS.Parent.cboNavigate.ListCount
		  THIS.Parent.cboNavigate.ListIndex = THIS.Parent.cboNavigate.ListIndex + 1
		  THIS.Parent.cboNavigate.Valid()
		ENDIF
		
	ENDPROC

	PROCEDURE cmdNavDn.Refresh
		THIS.Enabled = (THIS.Parent.cboNavigate.ListIndex < THIS.Parent.cboNavigate.ListCount)
		
	ENDPROC

	PROCEDURE cmdNavDn.ShowWhatsThis
		LPARAMETERS nWhatsThisHelpID
		  NODEFAULT   && Defer to parent control object
		  RETURN THIS.Parent.ShowWhatsThis(m.nWhatsThisHelpID)
		
	ENDPROC

	PROCEDURE cmdNavDn.When
		* Remember the control that had focus so we can return to it after.
		IF THISFORM.Baseclass == 'Form' AND TYPE('THISFORM.ActiveControl.Baseclass') = 'C' ;
		AND NOT THISFORM.ActiveControl.Baseclass $ 'Commandbutton,Checkbox,Pageframe'
		  THISFORM.SetLastControl(THISFORM.activecontrol)
		ENDIF
		RETURN .T.
		
	ENDPROC

	PROCEDURE cmdNavUp.Click
		IF THIS.Parent.cboNavigate.ListIndex > 1
		  THIS.Parent.cboNavigate.ListIndex = THIS.Parent.cboNavigate.ListIndex - 1
		  THIS.Parent.cboNavigate.Valid()
		ENDIF
		
	ENDPROC

	PROCEDURE cmdNavUp.Refresh
		THIS.Enabled = (THIS.Parent.cboNavigate.ListIndex > 1)
		
	ENDPROC

	PROCEDURE cmdNavUp.ShowWhatsThis
		LPARAMETERS nWhatsThisHelpID
		  NODEFAULT   && Defer to parent control object
		  RETURN THIS.Parent.ShowWhatsThis(m.nWhatsThisHelpID)
		
	ENDPROC

	PROCEDURE cmdNavUp.When
		* Remember the control that had focus so we can return to it after.
		IF THISFORM.Baseclass == 'Form' AND TYPE('THISFORM.ActiveControl.Baseclass') = 'C' ;
		AND NOT THISFORM.ActiveControl.Baseclass $ 'Commandbutton,Checkbox,Pageframe'
		  THISFORM.SetLastControl(THISFORM.activecontrol)
		ENDIF
		RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmstatusbar AS frmform OF "cmforms.vcx" 		&& A Custom status bar form class
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\no.bmp" ClassIcon="..\graphics\no.bmp" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Timer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAbout" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblMessage" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblProgress" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntProgressBar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtUser" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linUserTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linUserLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linTop1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linTop2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtInsMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linOverTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linOverLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNumLock" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linNumTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linNumLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtCapsLock" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linCapsTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linCapsLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtClock" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linClockTop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linClockLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cntOptions" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addindicator		&& Add an indicator to the rightmost free spot on the status bar.
		*m: cleartimedmessage		&& Clear timed message display.
		*m: closeprogress		&& Close Progress bar.
		*m: drawgrowbars		&& Draw little grow bars in bottom right of window.
		*m: initprogress
		*m: redraw		&& Redraw the status bar, and make sure it is positioned corectly.
		*m: setmessage		&& Display a message in the message area of the status bar.
		*m: setprogressmessage
		*m: setprogressrange
		*m: settimedmessage		&& Set temporary message to display over current message.
		*m: updateprogress		&& Update the progress bar.
		*p: cdateformat		&& Controls date format displayed. Values are STRING, NUMERIC, or NONE
		*p: lshowabout		&& Set to .T. to show the "About" button on the status bar.
		*p: lshowcaps		&& Show status of CAPSLOCK key
		*p: lshowclock		&& Show clock
		*p: lshowinsert		&& Show status of Insert/Overwrite mode
		*p: lshownumlock		&& Show Status of NUMLOCK
		*p: lshowoptions		&& Show developer custom container on the toolbar
		*p: lshowuser		&& Show current username
		*p: nrightoffset		&& Tracks status bar positions used as indicators are added.
		*p: nslowinterval		&& Interval use to update the clock, when nothing else needs to be done.
		*p: nthreshold		&& Number of seconds to wait before displaying a progress bar.
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BorderStyle = 0
	Caption = ""
	cdateformat = String		&& Controls date format displayed. Values are STRING, NUMERIC, or NONE
	cformbackground = .NULL.
	Closable = .F.
	ControlBox = .F.
	DoCreate = .T.
	FontBold = .F.
	FontSize = 8
	Height = 27
	lshowabout = .T.		&& Set to .T. to show the "About" button on the status bar.
	lshowcaps = .T.		&& Show status of CAPSLOCK key
	lshowclock = .T.		&& Show clock
	lshowinsert = .T.		&& Show status of Insert/Overwrite mode
	lshownumlock = .T.		&& Show Status of NUMLOCK
	lshowoptions = .F.		&& Show developer custom container on the toolbar
	lshowuser = .T.		&& Show current username
	lwindowmenu = .F.
	MinButton = .F.
	Movable = .F.
	Name = "frmstatusbar"
	nrightoffset = 0		&& Tracks status bar positions used as indicators are added.
	nslowinterval = 20000		&& Interval use to update the clock, when nothing else needs to be done.
	nthreshold = 0		&& Number of seconds to wait before displaying a progress bar.
	osecurity = .NULL.
	ShowTips = .T.
	Width = 640

	ADD OBJECT 'cmdAbout' AS cmdcommandbuttoncustom WITH ;
		Caption = "", ;
		FontBold = .T., ;
		FontItalic = .F., ;
		FontName = "Arial", ;
		FontSize = 12, ;
		Height = 20, ;
		Left = 312, ;
		Name = "cmdAbout", ;
		Picture = ..\graphics\copyrite.bmp, ;
		SpecialEffect = 1, ;
		Style = 0, ;
		TabStop = .F., ;
		Top = 4, ;
		Visible = .F., ;
		Width = 20
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cntOptions' AS cntcontainer WITH ;
		BorderWidth = 0, ;
		Height = 20, ;
		Left = 290, ;
		Name = "cntOptions", ;
		Top = 4, ;
		Visible = .F., ;
		Width = 21
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="container" />

	ADD OBJECT 'cntProgressBar' AS cntprogressbar WITH ;
		Height = 14, ;
		Left = 91, ;
		Name = "cntProgressBar", ;
		Top = 7, ;
		Visible = .F., ;
		Width = 195, ;
		lblPercent.FontSize = 8, ;
		lblPercent.Height = 14, ;
		lblPercent.Name = "lblPercent", ;
		shpprogress.Name = "shpprogress"
		*< END OBJECT: ClassLib="cmgadget.vcx" BaseClass="container" />

	ADD OBJECT 'lblMessage' AS lbltextcustom WITH ;
		Alignment = 0, ;
		AutoSize = .F., ;
		Caption = "", ;
		FontBold = .F., ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 7, ;
		Name = "lblMessage", ;
		Top = 5, ;
		Width = 141
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'lblProgress' AS lblfieldlabelcustom WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Progress Prompt:", ;
		FontBold = .F., ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 3, ;
		Name = "lblProgress", ;
		Top = 6, ;
		Visible = .F., ;
		Width = 85
		*< END OBJECT: ClassLib="..\custom\ccontrol.vcx" BaseClass="label" />

	ADD OBJECT 'linCapsLeft' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 18, ;
		Left = 480, ;
		Name = "linCapsLeft", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linCapsTop' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 0, ;
		Left = 481, ;
		Name = "linCapsTop", ;
		Top = 5, ;
		Width = 34
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linClockLeft' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 18, ;
		Left = 520, ;
		Name = "linClockLeft", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linClockTop' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 0, ;
		Left = 521, ;
		Name = "linClockTop", ;
		Top = 5, ;
		Width = 116
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linNumLeft' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 18, ;
		Left = 451, ;
		Name = "linNumLeft", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linNumTop' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 0, ;
		Left = 452, ;
		Name = "linNumTop", ;
		Top = 5, ;
		Width = 27
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linOverLeft' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 18, ;
		Left = 420, ;
		Name = "linOverLeft", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linOverTop' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 0, ;
		Left = 421, ;
		Name = "linOverTop", ;
		Top = 5, ;
		Width = 28
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linTop1' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 0, ;
		Left = 0, ;
		Name = "linTop1", ;
		Top = 0, ;
		Width = 100
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linTop2' AS linline WITH ;
		BorderColor = 255,255,255, ;
		Height = 0, ;
		Left = 0, ;
		Name = "linTop2", ;
		Top = 1, ;
		Width = 100
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linUserLeft' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 18, ;
		Left = 335, ;
		Name = "linUserLeft", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'linUserTop' AS linline WITH ;
		BorderColor = 128,128,128, ;
		Height = 0, ;
		Left = 336, ;
		Name = "linUserTop", ;
		Top = 5, ;
		Width = 82
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="line" />

	ADD OBJECT 'Timer' AS timer WITH ;
		Height = 23, ;
		Interval = 20000, ;
		Left = 0, ;
		Name = "Timer", ;
		Top = 0, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'txtCapsLock' AS txttextbox WITH ;
		Alignment = 2, ;
		BorderColor = 255,255,255, ;
		creadonlydisplay = Dim,Nofocus, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		FontSize = 8, ;
		Height = 18, ;
		InputMask = "XXXX", ;
		Left = 480, ;
		Margin = 1, ;
		Name = "txtCapsLock", ;
		ReadOnly = .T., ;
		SpecialEffect = 1, ;
		Top = 5, ;
		Width = 35
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtClock' AS txttextbox WITH ;
		BorderColor = 255,255,255, ;
		creadonlydisplay = Dim,Nofocus, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 520, ;
		Margin = 1, ;
		Name = "txtClock", ;
		ReadOnly = .T., ;
		SpecialEffect = 1, ;
		Top = 5, ;
		Width = 117
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtInsMode' AS txttextbox WITH ;
		Alignment = 2, ;
		BorderColor = 255,255,255, ;
		creadonlydisplay = Dim,Nofocus, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		FontSize = 8, ;
		Height = 18, ;
		InputMask = "XXX", ;
		Left = 420, ;
		Margin = 1, ;
		Name = "txtInsMode", ;
		ReadOnly = .T., ;
		SpecialEffect = 1, ;
		Top = 5, ;
		Width = 29
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtNumLock' AS txttextbox WITH ;
		Alignment = 2, ;
		BorderColor = 255,255,255, ;
		creadonlydisplay = Dim,Nofocus, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		FontSize = 8, ;
		Height = 18, ;
		InputMask = "XXX", ;
		Left = 451, ;
		Margin = 1, ;
		Name = "txtNumLock", ;
		ReadOnly = .T., ;
		SpecialEffect = 1, ;
		Top = 5, ;
		Width = 28
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtUser' AS txttextbox WITH ;
		BorderColor = 255,255,255, ;
		creadonlydisplay = Dim,Nofocus, ;
		DisabledForeColor = 0,0,0, ;
		Enabled = .F., ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 335, ;
		Margin = 1, ;
		Name = "txtUser", ;
		ReadOnly = .T., ;
		SpecialEffect = 1, ;
		Top = 5, ;
		Width = 83
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="textbox" />
	
	PROCEDURE Activate
		THIS.Timer.Interval = 200
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE addindicator		&& Add an indicator to the rightmost free spot on the status bar.
		LPARAMETERS oIndicator, lEnabled
		
		IF m.lEnabled
		  THISFORM.nRightOffset = THISFORM.nRightOffset + m.oIndicator.Width + 2
		  m.oIndicator.Visible = .T.
		  IF m.oIndicator.Baseclass $ 'Label,Textbox'
		    m.oIndicator.Left = THISFORM.Width - THISFORM.nRightOffset && + 3
		    m.oIndicator.Refresh()
		  ELSE
		    m.oIndicator.Left = THISFORM.Width - THISFORM.nRightOffset
		  ENDIF
		ELSE
		  m.oIndicator.Visible = .F.              && Hide disabled indicators.
		ENDIF
		
	ENDPROC

	PROCEDURE afterload
		THIS.AddProperty('lAutoHide')
		THIS.AddProperty('cHoldMessage', .NULL.)
		THIS.AddProperty('lFoxStatbar', (SET('STATUS BAR') = 'ON'))
		SET STATUS BAR OFF
		
	ENDPROC

	PROCEDURE cleartimedmessage		&& Clear timed message display.
		* Clear timed message and restore regulare message
		IF NOT ISNULL(THISFORM.cHoldMessage)
		  THISFORM.lblMessage.Caption = THISFORM.cHoldMessage
		  THISFORM.cHoldMessage = .NULL.
		  THISFORM.Timer.Interval = THIS.nSlowInterval   && Restore to default interval (20 seconds for clock update)
		ENDIF
		
	ENDPROC

	PROCEDURE closeprogress		&& Close Progress bar.
		THIS.lblProgress.Visible = .F.
		THISFORM.cntProgressBar.Visible = .F.
		THISFORM.lblMessage.Visible = .T.    && Put statusbar msg back on.
		
	ENDPROC

	PROCEDURE contextmenubuild
		* Don't allow standard context menu for status bar, especially the "Center Form" option
		RETURN .F.
		
	ENDPROC

	PROCEDURE Deactivate
		IF THIS.Visible
		  THIS.Timer.Interval = THIS.nSlowInterval
		ENDIF
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE Destroy
		* Restore status bar to original setting.
		IF THIS.lFoxStatbar
		  SET STATUS BAR ON
		ENDIF
		
		* Cancel refresh requests.
		IF THIS.Visible
		  THIS.oStateManager.CancelRefresh(THIS)
		ENDIF
		
	ENDPROC

	PROCEDURE drawgrowbars		&& Draw little grow bars in bottom right of window.
		* Draw diagonal lines at bottom right of window border.
		LOCAL ix
		
		IF _SCREEN.WindowState = 0
		  THISFORM.forecolor = GetSysColor(COLOR_BTNSHADOW)
		  THISFORM.DrawWidth = 1
		  FOR ix = 3 TO 11 STEP 4
		    THISFORM.currentX = THISFORM.Width - m.ix
		    THISFORM.currentY = THISFORM.height
		    THISFORM.line(THISFORM.Width, THISFORM.height - m.ix)
		  ENDFOR
		  FOR ix = 4 TO 12 STEP 4
		    THISFORM.currentX = THISFORM.Width - m.ix
		    THISFORM.currentY = THISFORM.height
		    THISFORM.line(THISFORM.Width, THISFORM.height - m.ix)
		  ENDFOR
		  THISFORM.forecolor = GetSysColor(COLOR_BTNHIGHLIGHT)
		  FOR ix = 5 TO 13 STEP 4
		    THISFORM.currentX = THISFORM.Width - m.ix
		    THISFORM.currentY = THISFORM.height
		    THISFORM.line(THISFORM.Width, THISFORM.height - m.ix)
		  ENDFOR
		ENDIF
		
	ENDPROC

	PROCEDURE Hide
		* If we are explicitly hidden, don't reappear automatically when VFP status bar is not detected.
		THISFORM.lAutoHide = .F.
		
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE Init
		*++
		* CodeMine status bar gadget class.
		*
		* Copyright 1996,1997 Soft Classics, Ltd. All rights reserved.
		*--
		  SET TALK OFF
		  IF NOT DODEFAULT()
		    RETURN .F.
		  ENDIF
		
		  IF ISNULL(THIS.oStateManager)
		    =Messagebox('Codemine global state manager must be instantiated before StatusBar')
		    THIS.Release()
		    RETURN .F.
		  ENDIF
		
		  * Request refresh on toggle keys (Ins/Caps/Numlock) and on main window resize.
		  THIS.oStateManager.RequestRefresh('System Key Toggle', THIS)
		  THIS.oStateManager.RequestRefresh('Main Window Resize', THIS)
		
		  * Never show username if global security module is not loaded.
		  IF TYPE('THISFORM.oSecurity.Name') = 'C'
		    THIS.oStateManager.RequestRefresh('System Privilege', THIS.txtUser)
		  ELSE
		    THISFORM.lShowUser = .F.
		  ENDIF
		
		  * If VFP status bar wasn't originaly showing, main resize event wont fire.
		  THIS.Redraw(.T.)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE initprogress
		LPARAMETER cText, nMinCount, nMaxCount
		LOCAL nMaxTextWidth
		
		  THIS.lblMessage.Visible = .F.    && Hide status bar message text, if any
		
		  THIS.SetProgressMessage(m.cText)
		  THIS.cntProgressBar.SetRange(m.nMinCount, m.nMaxCount)
		  THIS.cntProgressBar.Refresh()
		
	ENDPROC

	PROCEDURE redraw		&& Redraw the status bar, and make sure it is positioned corectly.
		LPARAMETERS lForceVisible
		LOCAL ix, obj, nChars, nScalemode
		
		  * Don't do anything if the VFP status bar is displayed.
		  IF SET('STATUS BAR') = 'ON'
		    THIS.Visible = .F.
		    * When AutoHide is in effect, we check several times per second (via timer) to see if we
		    * should re-enable ourself. This is necessary because VFP sometimes missed Resize events.
		    THIS.lAutoHide = .T.
		    THIS.Timer.Interval = 250
		    RETURN .T.
		  ENDIF
		
		  * Turning VFP status bar on may hide us, so now we can show ourself again.
		  IF THIS.lAutoHide AND NOT THIS.Visible
		    THIS.lAutoHide = .F.
		    m.lForceVisible = .T.
		  ENDIF
		  THIS.LockScreen = .T.
		
		  * Size the status bar to fill the whole bottom of the main VFP window.
		  m.nScaleMode = _SCREEN.ScaleMode
		  IF m.lForceVisible OR THIS.Top != _SCREEN.Height - THIS.Height OR THIS.Width != _SCREEN.Width
		    THIS.Cls()
		
		    * Window border of non-maximized window appears as extra height of status bar.
		    IF _SCREEN.WindowState = 0
		      THIS.Height = THIS.nOriginalHeight - 2
		    ELSE
		      THIS.Height = THIS.nOriginalHeight
		    ENDIF
		
		    THIS.Top = _SCREEN.Height - THIS.Height
		    THIS.Left = 0
		    THIS.Width = _SCREEN.Width
		
		    * Recalculate width of date/time indicator to match current format.
		    * String = 26/29 chars, Numeric = 14/16/19, None = 5/8
		    DO CASE
		      CASE 'STR' $ UPPER(THISFORM.cDateFormat)
		        m.nChars = LEN(CMONTH(DATE())) + 17
		      CASE 'NUM' $ UPPER(THISFORM.cDateFormat)
		        m.nChars = IIF(SET('CENT') == 'ON', 16, 14) + 1
		      OTHERWISE
		        m.nChars = 5
		    ENDCASE
		    IF SET('HOURS') = 12
		      m.nChars = m.nChars + 3
		    ENDIF
		    WITH THIS.txtClock
		      .Width = m.nChars * FONTMETRIC(6, .Fontname, .FontSize) + 8
		    ENDWITH
		
		    THIS.nRightOffset = IIF(_SCREEN.WindowState = 0, 14, 2)
		    IF THIS.Width < 450
		      * Hide indicator controls that will not fit in current width.
		      THIS.AddIndicator(THISFORM.txtClock, .F.)
		      THIS.AddIndicator(THISFORM.txtCapslock, .F.)
		      THIS.AddIndicator(THISFORM.txtNumlock, .F.)
		      THIS.AddIndicator(THISFORM.txtInsmode, .F.)
		      THIS.AddIndicator(THISFORM.txtUser, .F.)
		      THIS.AddIndicator(THISFORM.cmdAbout, .F.)
		      THIS.AddIndicator(THISFORM.cntOptions, .F.)
		
		      * Adjust size of the temporary message control.
		      THIS.lblMessage.Width = MAX(0, THIS.Width - THIS.lblMessage.Left - THIS.nRightOffset - 5)
		    ELSE
		      * Add enabled indicator controls one by one starting from the right edge.
		      THIS.AddIndicator(THISFORM.txtClock, THISFORM.lShowClock)
		      THIS.AddIndicator(THISFORM.txtCapslock, THISFORM.lShowCaps)
		      THIS.AddIndicator(THISFORM.txtNumlock, THISFORM.lShowNumlock)
		      THIS.AddIndicator(THISFORM.txtInsmode, THISFORM.lShowinsert)
		      THIS.AddIndicator(THISFORM.txtUser, THISFORM.lShowUser)
		      THIS.AddIndicator(THISFORM.cmdAbout, THISFORM.lShowAbout)
		      THIS.AddIndicator(THISFORM.cntOptions, THISFORM.lShowOptions)
		
		      * Adjust size of the temporary message control.
		      THIS.lblMessage.Width = MAX(0, THIS.Width - THIS.lblMessage.Left - THIS.nRightOffset - 5)
		
		    ENDIF
		
		    * After screen controls are drawn, draw top border effect lines and 3d boxes.
		    IF m.lForceVisible
		      THIS.Visible = .T.
		    ENDIF
		    THIS.Draw()
		    THIS.DrawGrowBars()
		  ENDIF
		
		  STORE THIS.Width TO THIS.linTop1.Width, THIS.linTop2.Width
		  THIS.LockScreen = .F.
		
		  THIS.Timer.Interval = THIS.nSlowInterval
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Refresh
		THIS.Redraw()
		
	ENDPROC

	PROCEDURE Release
		* Cancel refresh requests. There is a bug in VFP5.0 that occurs only
		* immediately after stating a frsh instance of VFP. For some reason, 
		* removing external references to form controls in the Destroy() event
		* can cause VFP to mess up the object reference count, and not properly
		* release the form. Canceling the refresh callback refs from the release
		* method seems to solve the problem.
		THIS.oStateManager.CancelRefresh(THIS)
		
		* Go away faster. Also used as a flag to Destory() event that .CancelRefresh() was called.
		THIS.Visible = .T.
		
	ENDPROC

	PROCEDURE setmessage		&& Display a message in the message area of the status bar.
		LPARAMETER cMessage
		
		IF ISNULL(THISFORM.cHoldMessage)
		  THISFORM.lblMessage.Caption = m.cMessage
		ELSE
		  THISFORM.cHoldMessage = m.cMessage
		ENDIF
		
	ENDPROC

	PROCEDURE setprogressmessage
		LPARAMETER cText
		
		  * Set progress label and adjust position of progress bar.
		  THISFORM.LockScreen = .T.
		  m.nMaxTextWidth = MAX(0, THIS.lblMessage.Width - THIS.cntProgressBar.Width - 10)
		  WITH THIS.lblProgress
		    .Visible = .T.
		    .Autosize = .T.
		    .Caption = m.cText
		    .Autosize = .F.
		    IF .Width > m.nMaxTextWidth
		      .Width = m.nMaxTextWidth
		    ENDIF
		  ENDWITH
		
		  THIS.cntProgressBar.Left = THIS.lblProgress.Left + THIS.lblProgress.Width + 5
		  IF THIS.cntProgressBar.Visible
		    THIS.lblMessage.Visible = .T.
		    THIS.lblMessage.Visible = .F.
		    THISFORM.LockScreen = .F.
		    THIS.cntProgressBar.Refresh()
		  ELSE
		    THISFORM.LockScreen = .F.
		    THIS.cntProgressBar.Visible = .T.
		  ENDIF
		
	ENDPROC

	PROCEDURE setprogressrange
		LPARAMETER nMinCount, nMaxCount
		
		THIS.cntProgressBar.SetRange(m.nMinCount, m.nMaxCount)
		
	ENDPROC

	PROCEDURE settimedmessage		&& Set temporary message to display over current message.
		LPARAMETER cMessage, nSeconds
		
		  IF ISNULL(THISFORM.cHoldMessage)
		    THISFORM.cHoldMessage = THISFORM.lblMessage.Caption
		  ENDIF
		  THISFORM.lblMessage.Caption = m.cMessage
		
		  * Defaults to 5 seconds. min of 1, maximum of 45.
		  IF VARTYPE(m.nSeconds) = 'N'
		    m.nSeconds = MAX(MIN(m.nSeconds, 45), 1)
		  ELSE
		    m.nSeconds = 5
		  ENDIF
		
		  THISFORM.Timer.Interval = 0
		  THISFORM.Timer.Interval = m.nSeconds * 1000
		
	ENDPROC

	PROCEDURE updateprogress		&& Update the progress bar.
		LPARAMETER nCount
		  IF THISFORM.cntProgressBar.Update(m.nCount)
		    THISFORM.Draw()
		  ENDIF
		
	ENDPROC

	PROCEDURE cmdAbout.Click
		IF NOT ISNULL(THISFORM.oApp)
		  THISFORM.oApp.About()
		ENDIF
		
	ENDPROC

	PROCEDURE Timer.Timer
		* Clear timed message display
		THISFORM.ClearTimedMessage()
		
		* If something happened to put us in the wrong spot, fix it now. This can be necessary
		* after a print-preview window closes.
		IF THISFORM.lAutoHide OR THISFORM.Top != _SCREEN.Height - THISFORM.Height
		  THISFORM.Redraw()
		ENDIF
		
		IF THISFORM.Visible
		  * Refresh clock display
		  THISFORM.txtClock.Refresh()
		
		  * We should never keep focus on this form. Find another form to activate if we are active.
		  IF BITTEST(THISFORM.nControlFlags, FRMFLAG_ACTIVE)
		    THISFORM.nControlFlags = BITCLEAR(THISFORM.nControlFlags, FRMFLAG_ACTIVE)
		    LOCAL oForm
		    FOR EACH oForm IN _SCREEN.Forms
		      IF m.oForm.Baseclass == 'Form' AND m.oForm.Visible AND NOT m.oForm.Name == THISFORM.Name
		        m.oForm.Show()
		        RETURN
		      ENDIF
		    ENDFOR
		    _SCREEN.Show()   && If no other form, activate the main window background.
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE txtCapsLock.Refresh
		WITH THIS.Parent
		  STORE THIS.Visible TO .linCapsTop.Visible, .linCapsLeft.Visible
		  .linCapsTop.Left = THIS.Left
		  .linCapsLeft.Left = THIS.Left
		ENDWITH
		
		IF NOT EMPTY(CAPSLOCK())
		  THIS.Value = 'CAPS'
		ELSE
		  THIS.Value = ''
		ENDIF
		
	ENDPROC

	PROCEDURE txtClock.Refresh
		LOCAL cDate, cTime
		
		WITH THIS.Parent
		  STORE THIS.Visible TO .linClockTop.Visible, .linClockLeft.Visible
		  .linClockTop.Left = THIS.Left
		  .linClockTop.Width = THIS.Width
		  .linClockLeft.Left = THIS.Left
		ENDWITH
		
		IF THIS.Visible
		  * Format time according to prevailing setting.
		  IF SET('HOUR') = 12
		    m.cTime = RIGHT(TTOC(DATETIME()), 11)
		    m.cTime = STUFF(m.cTime, 6, 3, '')
		  ELSE
		    m.cTime = LEFT(TIME(), 5)
		  ENDIF
		
		  * And format the date for display
		  DO CASE
		    CASE UPPER(THISFORM.cDateFormat) = 'STRING'
		      m.cDate = MDY(DATE())
		    CASE UPPER(THISFORM.cDateFormat) = 'NUMERIC'
		      m.cDate = DTOC(DATE())
		    OTHERWISE
		      m.cDate = ''
		  ENDCASE
		
		  THIS.Value = ALLTRIM(m.cDate + ' ' + m.cTime)
		  THIS.ToolTipText = CDOW(DATE()) + ', ' + MDY(DATE())
		ENDIF
		
	ENDPROC

	PROCEDURE txtInsMode.Refresh
		WITH THIS.Parent
		  STORE THIS.Visible TO .linOverTop.Visible, .linOverLeft.Visible
		  .linOverTop.Left = THIS.Left
		  .linOverLeft.Left = THIS.Left
		ENDWITH
		
		IF NOT EMPTY(INSMODE())
		  THIS.Value = 'INS'
		ELSE
		  THIS.Value = 'OVR'
		ENDIF
		
	ENDPROC

	PROCEDURE txtNumLock.Refresh
		WITH THIS.Parent
		  STORE THIS.Visible TO .linNumTop.Visible, .linNumLeft.Visible
		  .linNumTop.Left = THIS.Left
		  .linNumLeft.Left = THIS.Left
		ENDWITH
		
		IF NOT EMPTY(NUMLOCK())
		  THIS.Value = 'NUM'
		ELSE
		  THIS.Value = ''
		ENDIF
		
	ENDPROC

	PROCEDURE txtUser.Refresh
		WITH THIS.Parent
		  STORE THIS.Visible TO .linUserTop.Visible, .linUserLeft.Visible
		  .linUserTop.Left = THIS.Left
		  .linUserLeft.Left = THIS.Left
		ENDWITH
		
		IF NOT ISNULL(THISFORM.oSecurity)
		  * Get username if security object exists
		  THIS.Value = ' ' + PROPER(THISFORM.oSecurity.cUsername)
		ELSE
		  THIS.Value = ''
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS lstchecklist AS lstlistboxcustom OF "..\custom\ccontrol.vcx" 		&& A listbox where each item is a checkbox
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: getchecked		&& Return Checked state for an item.
		*m: setchecked		&& Set the Checked/Unchecked state of an item
		*p: ldoubleclicktoggle		&& Set to .T. to only toggle checked values on a double click, or space press.
	*</DefinedPropArrayMethod>

	Height = 106
	Name = "lstchecklist"
	Picture = ..\graphics\checkoff.bmp
	Width = 138
	
	PROCEDURE beforechange
		  * Specialized BeforeChange code for the checkList
		  IF NOT THIS.lChanged
		    * Dispatch to the appropriate error handler on attempt to edit a read-only control.
		    IF THIS.lWriteLock
		      IF PEMSTATUS(THISFORM, 'lExplicitEditMode', 5)
		        IF NOT THIS.lReadOnly AND THISFORM.lExplicitEditMode AND THISFORM.lWriteLock
		          THISFORM.cmBindingManager.ErrorEditMode(THIS)
		          RETURN .F.
		        ENDIF
		      ENDIF
		      THISFORM.cmBindingManager.ErrorReadonly(THIS)
		      RETURN .F.
		    ENDIF
		
		    * Call form.beforeChange to Lock pessimistic datasource, update form change 
		    * flags, and refresh toolbar save/revert buttons as appropriate.
		    IF EMPTY(THIS.cWorkarea)
		      THIS.lChanged = THISFORM.BeforeChange()
		    ELSE
		      THIS.lChanged = THISFORM.BeforeChange(THIS.cWorkarea)
		    ENDIF
		    RETURN THIS.lChanged
		  ENDIF
		
	ENDPROC

	PROCEDURE Click
		IF NOT THIS.lDoubleClickToggle
		  THIS.Valid()
		ENDIF
		
	ENDPROC

	PROCEDURE DblClick
		IF THIS.lDoubleClickToggle
		  THIS.lMouseDown = .T.
		ENDIF
		
	ENDPROC

	PROCEDURE getchecked		&& Return Checked state for an item.
		LPARAMETERS nIndex
		*++
		* Return checked state for the specified item.
		*--
		  IF NOT PEMSTATUS(THIS, 'aChecked', 5)
		    RETURN .F.
		  ENDIF
		  IF m.nIndex > ALEN(THIS.aChecked)
		    RETURN .F.
		  ENDIF
		  RETURN THIS.aChecked[m.nIndex]
		
	ENDPROC

	PROCEDURE Init
		THIS.AddProperty('lMouseDown')
		IF NOT PEMSTATUS(THIS, 'aChecked', 5)
		  THIS.AddProperty('aChecked[1]')
		ENDIF
		
		THIS.Picture = '..\Graphics\checkoff.bmp'
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		  * Space also toggles the checked state.
		  IF DODEFAULT(m.nKeyCode, m.nShiftAltCtrl) AND m.nKeyCode = ASC(' ')
		    THIS.lMouseDown = .T.
		    THIS.Valid()
		  ELSE
		    THIS.lMouseDown = .F.
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		 IF nButton = 1 AND NOT THIS.lDoubleClickToggle
		   THIS.lMouseDown = .T.
		 ENDIF
		 RETURN DODEFAULT(m.nButton, m.nShift, m.nXCoord, m.nYCoord)
		
	ENDPROC

	PROCEDURE Refresh
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    THISFORM.cmBindingManager.InitBinding(THIS)
		  ENDIF
		
		  THIS.lChanged = .F.
		  THIS.ShowControl()
		
	ENDPROC

	PROCEDURE setchecked		&& Set the Checked/Unchecked state of an item
		LPARAMETERS nIndex, lValue
		  IF m.nIndex > 0 AND m.nIndex <= THIS.ListCount
		    IF NOT PEMSTATUS(THIS, 'aChecked', 5)
		      THIS.AddProperty('aChecked[1]')
		    ENDIF
		
		    IF m.nIndex > ALEN(THIS.aChecked)
		      DIMENSION THIS.aChecked[m.nIndex]   && Make sure array is big enough.
		    ENDIF
		
		    THIS.aChecked[m.nIndex] = m.lValue
		    IF m.lValue
		      THIS.Picture[m.nIndex] = '..\graphics\checkon.bmp'
		    ELSE
		      THIS.Picture[m.nIndex] = '..\graphics\checkoff.bmp'
		    ENDIF
		
		    * Could call StoreValue() from here, if bound to a data source?
		    *THIS.StoreValue()
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE showcontrol
		LOCAL lOldWriteLock
		  * Apply desired Read-only condition, and then apply security and datasource restrictions.
		  m.lOldWriteLock = THIS.lWriteLock
		  THIS.lWriteLock = THIS.lReadOnly
		
		  * Check privileges and apply new setting of read-only attribute
		  THIS.ApplySecurity()
		
		  * Check for no data or Write-Protect (explicit edit mode).
		  IF NOT THIS.lWriteLock AND NOT EMPTY(THIS.cWorkarea)
		    THIS.lWriteLock = NOT THISFORM.IsEditAllowed(THIS.cWorkarea)
		  ENDIF
		
		  * Apply or remove readonly display effect if read-only condition changed.
		  IF m.lOldWriteLock != THIS.lWriteLock
		    IF 'DIM' $ THIS.cReadOnlyDisplay
		      IF THIS.lWriteLock
		        IF ISNULL(THIS.nBackColor)
		          THIS.nBackColor = THIS.ItemBackColor
		        ENDIF
		        THIS.ItemBackColor = THIS.Parent.BackColor
		      ELSE
		        IF NOT ISNULL(THIS.nBackColor)
		          THIS.ItemBackColor = THIS.nBackColor
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Control is Disabled if readonly (optionaly), or if datasource is EOF().
		  IF THIS.lWriteLock AND 'DISABLE' $ THIS.cReadOnlyDisplay
		    THIS.Enabled = .F.
		  ELSE
		    THIS.Enabled = THIS.lEnabled
		  ENDIF
		
		  * Update linked label control, if any.
		  IF NOT EMPTY(THIS.cLinkedLabel)
		    LOCAL oLabel
		    m.oLabel = EVALUATE('THIS.Parent.' + THIS.cLinkedLabel)
		    m.oLabel.Visible = THIS.Visible
		    m.oLabel.Refresh()
		  ENDIF
		
	ENDPROC

	PROCEDURE Valid
		  IF THIS.lMouseDown AND THIS.ListIndex > 0
		    IF THIS.BeforeChange() AND THIS.SetChecked(THIS.ListIndex, NOT THIS.GetChecked(THIS.ListIndex))
		      THIS.AfterChange()
		    ENDIF
		  ENDIF
		  THIS.lMouseDown = .F.
		
		  * Don't process default Codemine Valid event.
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS lstlistnavigator AS lstlistboxcustom OF "..\custom\ccontrol.vcx" 		&& A listbox record navigation control for data forms
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: add		&& Add a new reocrd to navigation array
		*m: delete		&& Delete a record from navigation array
		*m: findrecord		&& Search for a record by record number.
		*m: formatdata1		&& Custom formating code for display expressions
		*m: formatdata2		&& Custom formating code for display expressions
		*m: formatdata3		&& Custom formating code for display expressions
		*m: needrebuild		&& Mark the contents of the nav control invalid, so next refresh will trigger a rebuild.
		*m: rebuild		&& Rebuild list of records to navigate through
		*p: cdisplayexpression		&& Expression to display for each row in the navigation array. For multicolumn display, separate expressions with an OR bar.
		*p: cemptytext		&& Text displayed when navigation array is empty
		*p: cfilter		&& Filter expression to apply to recordset when lNavigator is True.
		*p: cmenubardelete		&& Ctx menu prompt for Delete option
		*p: cmenubaredit		&& Ctx menu prompt for Edit option
		*p: cmenubarnew		&& Ctx menu prompt for New option
		*p: cnewtext		&& Text displayed in listbox for new records.
		*p: lallowdelete		&& Set true to enable "Delete Record" context menu bar
		*p: lallowedit		&& Allow Edit option from context menu
		*p: lallownew		&& Set true to enable "New Record" context menu bar
		*p: lnavigator		&& Set to .T. to enable the record navigation features of the listbox.
		*p: lsorted		&& If true, navigation list is sorted alphabeticaly by display expression.
		*p: nparentrecno		&& Record number in parent alias
		*p: nrecordcount		&& Number of records in navigation array
		*p: nsortcolumn		&& Default column to sort on, if lSorted is set to .T.
	*</DefinedPropArrayMethod>

	cdisplayexpression = 		&& Expression to display for each row in the navigation array. For multicolumn display, separate expressions with an OR bar.
	cemptytext = %txtNavigatorEmpty		&& Text displayed when navigation array is empty
	cfilter = 		&& Filter expression to apply to recordset when lNavigator is True.
	chelpclasskey = %hlpNavigator
	cmenubardelete = %barDeleteRecord		&& Ctx menu prompt for Delete option
	cmenubaredit = %barEditRecord		&& Ctx menu prompt for Edit option
	cmenubarnew = %barNewRecord		&& Ctx menu prompt for New option
	cnewtext = %txtNavigatorNew		&& Text displayed in listbox for new records.
	ColumnCount = 1
	Height = 123
	ItemTips = .T.
	lallowdelete = .T.		&& Set true to enable "Delete Record" context menu bar
	lallownew = .T.		&& Set true to enable "New Record" context menu bar
	lnavigator = .T.		&& Set to .T. to enable the record navigation features of the listbox.
	Name = "lstlistnavigator"
	nparentrecno = 0		&& Record number in parent alias
	nrecordcount = 0		&& Number of records in navigation array
	nsortcolumn = 1		&& Default column to sort on, if lSorted is set to .T.
	RowSourceType = 5
	Width = 157
	
	PROCEDURE add		&& Add a new reocrd to navigation array
		*++
		* Add a new row to the end of the current navigation array. The current record in the
		* control workarea contains the new record to reference.
		*--
		LOCAL nNewRow, cText, cEmpty, cExpressions
		
		  * Rebuild the control if parent changed since last refresh, or rebuild explicitly requested via flag.
		  * Rebuild must be completed before new navigator row is added, since contents of new row come directly
		  * from the cursor update buffer, and are not available during the rebuild cycle.
		  IF THIS.lNeedRebuild OR NOT BITTEST(THIS.nControlFlags, CTLFLAG_INITIALIZED) ;
		  OR (NOT EMPTY(THIS.cParentAlias) AND THIS.nParentRecno != RECNO(THIS.cParentAlias))
		    THIS.Rebuild()
		
		    * For table-buffered cursors, the new row may already exist in the array.
		    m.nNewRow = THIS.FindRecord(RECNO(THIS.cWorkarea))
		  ENDIF
		
		  IF EMPTY(m.nNewRow)
		    THIS.nRecordCount = THIS.nRecordCount + 1
		    m.nNewRow = THIS.nRecordCount
		    DIMENSION THIS.aRecordList[m.nNewRow, THIS.nDataColumns]
		    THIS.aRecordList[m.nNewRow, THIS.nDataColumns] = RECNO(THIS.cWorkarea)
		  ENDIF
		
		  * Translate NewText string if necessary
		  IF LEFT(THIS.cNewText, 1) = '%' AND NOT ISNULL(THISFORM.oMessage)
		    THIS.cNewText = THISFORM.oMessage.TranslateString(THIS.cNewText)
		  ENDIF
		  m.cExpressions = THIS.cNewText
		
		  FOR nCol = 1 TO THIS.nDataColumns - 1
		    m.cText = EVALUATE(THIS.aDisplayExpression[m.nCol])
		    m.cEmpty = GetToken(@m.cExpressions, '|')
		    IF EMPTY(m.cText)
		      THIS.aRecordList[m.nNewRow, m.nCol] = m.cEmpty
		    ELSE
		      THIS.aRecordList[m.nNewRow, m.nCol] = m.cText
		    ENDIF
		  ENDFOR
		
		  IF THIS.lSorted
		    =ASORT(THIS.aRecordList, THIS.nSortColumn)
		    THIS.Rowsource = 'THIS.aRecordList'
		    THIS.ListIndex = THIS.FindRecord(RECNO(THIS.cWorkarea))
		  ELSE
		    THIS.Rowsource = 'THIS.aRecordList'
		    THIS.ListIndex = m.nNewRow
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterchange
		LOCAL nNewRec
		  IF THIS.lNavigator AND THIS.ListIndex > 0
		    m.nNewRec = THIS.aRecordList[THIS.ListIndex, THIS.nDataColumns]
		    IF NOT EMPTY(m.nNewRec) AND m.nNewRec != RECNO(THIS.cWorkarea)
		      IF NOT THISFORM.Goto(m.nNewRec, THIS.cWorkarea)
		        * If record couldn't move, make sure we correctly display whatever record we are left on.
		        THIS.Refresh()
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE contextmenubuild
		*++
		*>>Define all the bars for a navigator context menu. Return false if no bars are defined.
		*--
		  IF THIS.lNavigator
		    IF NOT EMPTY(THIS.cWorkarea)
		      LOCAL cName
		      m.cName = IIF(EMPTY(THIS.cDisplayName), THISFORM.NiceCursorName(THIS.cWorkarea), THIS.cDisplayName)
		      IF THIS.lAllowNew AND NOT EMPTY(THIS.cMenuBarNew)
		        THISFORM.ContextMenuBar(CTX_BAR_CTL_NEW, THIS.cMenuBarNew, m.cName)
		        IF NOT THISFORM.IsEnabled('New', THIS.cWorkarea)
		          THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_NEW, .T.)
		        ENDIF
		      ENDIF
		      IF THIS.lAllowEdit AND NOT EMPTY(THIS.cMenuBarEdit)
		        THISFORM.ContextMenuBar(CTX_BAR_CTL_EDIT, THIS.cMenuBarEdit, m.cName)
		        IF NOT THISFORM.IsEnabled('Edit', THIS.cWorkarea)
		          THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_EDIT, .T.)
		        ENDIF
		        THISFORM.ContextMenuSeparator(CTX_BAR_CTL_NULL)
		      ENDIF
		      IF THIS.lAllowDelete AND NOT EMPTY(THIS.cMenuBarDelete)
		        THISFORM.ContextMenuBar(CTX_BAR_CTL_DELETE, THIS.cMenuBarDelete, m.cName)
		        IF NOT THISFORM.IsEnabled('Delete', THIS.cWorkarea)
		          THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_DELETE, .T.)
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETER cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption == '%barhelp'
		      THIS.ShowWhatsThis(THIS.WhatsThisHelpID)
		
		    CASE m.cOption == PROPER(THIS.cMenuBarNew)
		      THISFORM.New(THIS.cWorkarea)
		
		    CASE m.cOption == PROPER(THIS.cMenuBarEdit)
		      THISFORM.Edit(THIS.cWorkarea)
		
		    CASE m.cOption == PROPER(THIS.cMenuBarDelete)
		      THISFORM.Delete(THIS.cWorkarea)
		
		    OTHERWISE
		      RETURN DODEFAULT(m.cOption)
		  ENDCASE
		
	ENDPROC

	PROCEDURE DblClick
		IF THIS.lNavigator
		  * Edit the current record on dblClick, if editing is enabled.
		  IF THIS.lAllowEdit AND THISFORM.IsEnabled('Edit', THIS.cWorkarea)
		    THISFORM.Edit(THIS.cWorkarea)
		  ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE delete		&& Delete a record from navigation array
		*++
		* Delete the current navigation array row.
		*--
		LOCAL ix, nCol, cExpressions
		  m.ix = THIS.ListIndex
		
		  * If the current record is not deleted, we assume the current row was removed from 
		  * the cursor buffer, and no longer exists.
		  IF m.ix > 0 AND THIS.nRecordCount > 0 ;
		  AND (NOT DELETED(THIS.cWorkarea) OR RECNO(THIS.cWorkarea) = THIS.aRecordList[m.ix, THIS.nDataColumns])
		    ADEL(THIS.aRecordList, m.ix)
		    THIS.nRecordCount = THIS.nRecordCount - 1
		    IF THIS.nRecordCount > 0
		      DIMENSION THIS.aRecordList[THIS.nRecordCount, THIS.nDataColumns]
		    ELSE
		      * If there are no records left, evaluate the cEmptyText expression list
		      IF LEFT(THIS.cEmptyText, 1) = '%' AND NOT ISNULL(THISFORM.oMessage)
		        THIS.cEmptyText = THISFORM.oMessage.TranslateString(THIS.cEmptyText)
		      ENDIF
		      m.cExpressions = THIS.cEmptyText
		      FOR nCol = 1 TO THIS.ColumnCount
		        THIS.aRecordList[1, m.nCol] = GetToken(@m.cExpressions, '|')
		      ENDFOR
		      THIS.aRecordList[1, THIS.ColumnCount + 1] = 0
		    ENDIF
		    THIS.Rowsource = 'THIS.aRecordList'
		  ENDIF
		
	ENDPROC

	PROCEDURE findrecord		&& Search for a record by record number.
		LPARAMETERS nRecno
		LOCAL ix
		
		  m.ix = ASCAN(THIS.aRecordList, m.nRecno)
		  IF m.ix > 0
		    RETURN ASUBSCRIPT(THIS.aRecordList, m.ix, 1)
		  ENDIF
		  RETURN 0   && Not found
		
	ENDPROC

	PROCEDURE formatdata1		&& Custom formating code for display expressions
	ENDPROC

	PROCEDURE formatdata2		&& Custom formating code for display expressions
	ENDPROC

	PROCEDURE formatdata3		&& Custom formating code for display expressions
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine cursor navigation control
		*
		* Copyright 1997-1999 Soft Classics, Ltd. All Rights Reserved worldwide.
		*--
		  IF THIS.lNavigator   && Navigator features are optional.
		    THIS.AddProperty('nDataColumns', 0)
		    THIS.AddProperty('aRecordList[1]', '')
		    THIS.AddProperty('aDisplayExpression[1]', '')
		    THIS.AddProperty('cParentAlias', '')
		    THIS.AddProperty('nParentRecno', 0)
		    THIS.AddProperty('nRecordCount', 0)
		    THIS.AddProperty('lNeedRebuild')
		
		    IF NOT EMPTY(THIS.ControlSource)   && Make sure controlsource is clear.
		      ERROR THIS.Name + ': ControlSource must be empty for Navigator controls'
		    ENDIF
		    STORE '' TO THIS.ControlSource, THIS.cValueSource
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE needrebuild		&& Mark the contents of the nav control invalid, so next refresh will trigger a rebuild.
		  * Mark the contents of the nav control invalid, so next refresh will trigger a rebuild.
		  THIS.lNeedRebuild = .T.
		
	ENDPROC

	PROCEDURE rebuild		&& Rebuild list of records to navigate through
		LOCAL ix, nCol, nSelect, nRecno, cExpressions, nDataCols
		
		  * Initialize the control as soon as the workarea becomes available
		  IF NOT BITTEST(THIS.nControlFlags, CTLFLAG_INITIALIZED)
		    IF EMPTY(THIS.cWorkarea) OR NOT USED(THIS.cWorkarea)
		      RETURN .F.
		    ENDIF
		    THIS.cWorkarea = PROPER(THIS.cWorkarea)
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_INITIALIZED)
		    THIS.cParentAlias = THISFORM.cmDataManager.GetParent(THIS.cWorkarea)
		    THISFORM.cmDataManager.RegisterNavControl(THIS, THIS.cWorkarea, THISFORM)
		  ENDIF
		  THIS.lNeedRebuild = .F.
		
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		  m.nRecno = RECNO()
		
		  * If Row-Buffering Open the table in another workarea so we dont mess up buffering
		  IF NOT ISREADONLY(THIS.cWorkarea) AND CURSORGETPROP('Buffering', THIS.cWorkarea) <=3
		    UseAgain(THIS.cWorkarea)
		  ENDIF
		
		  * Remember the parent record number, and check for change on each refresh.
		  IF NOT EMPTY(THIS.cParentAlias)
		    THIS.nParentRecno = RECNO(THIS.cParentAlias)
		  ENDIF
		
		  * Copy the display expression string into an array, one element per column.
		  IF NOT ISNULL(THIS.cDisplayExpression)  && First time processing only
		    LOCAL cDelimiter
		    * For multi-column displays with no OR bars, allow comma as a column separator.
		    m.cExpressions = THIS.cDisplayExpression
		    m.cDelimiter = IIF('|' $ m.cExpressions OR THIS.ColumnCount = 1, '|', ',')
		    m.nDataCols = MAX(THIS.ColumnCount, OCCURS(m.cDelimiter, THIS.cDisplayExpression) + 1)
		
		    DIMENSION THIS.aDisplayExpression[m.nDataCols]
		
		    FOR nCol = 1 TO m.nDataCols
		      * If no display expresson specified, default to the table field for this column.
		      THIS.aDisplayExpression[m.nCol] = ;
		                     IIF(EMPTY(m.cExpressions), FIELD(m.nCol), GetToken(@m.cExpressions, m.cDelimiter))
		    ENDFOR
		    THIS.cDisplayExpression = .NULL.
		    THIS.nDataColumns = m.nDataCols + 1   && Last column hold record pointer
		  ENDIF
		
		  m.ix = 0
		  DIMENSION THIS.aRecordList[1, THIS.nDataColumns]
		  IF EMPTY(THIS.cFilter)
		    THIS.cFilter = '.T.'
		  ENDIF
		  SCAN FOR EVALUATE(THIS.cFilter)
		    m.ix = m.ix + 1
		    DIMENSION THIS.aRecordList[ix, THIS.nDataColumns]
		    FOR nCol = 1 TO THIS.nDataColumns - 1
		      THIS.aRecordList[ix, m.nCol] = EVALUATE(THIS.aDisplayExpression[m.nCol])
		      IF ISNULL(THIS.aRecordList[ix, m.nCol])
		        THIS.aRecordList[ix, m.nCol] = THIS.NullDisplay
		      ENDIF
		    ENDFOR
		    THIS.aRecordList[ix, THIS.nDataColumns] = RECNO()
		  ENDSCAN
		
		  * If there are no records, evaluate the cEmptyText expression list
		  IF m.ix = 0
		    IF LEFT(THIS.cEmptyText, 1) = '%' AND NOT ISNULL(THISFORM.oMessage)
		      THIS.cEmptyText = THISFORM.oMessage.TranslateString(THIS.cEmptyText)
		    ENDIF
		    m.cExpressions = THIS.cEmptyText
		    FOR nCol = 1 TO THIS.ColumnCount
		      THIS.aRecordList[1, m.nCol] = GetToken(@m.cExpressions, '|')
		    ENDFOR
		    THIS.aRecordList[1, THIS.ColumnCount + 1] = 0
		  ENDIF
		
		  * Sort navigation array if desired.
		  IF THIS.lSorted
		    =ASORT(THIS.aRecordList, THIS.nSortColumn)
		  ENDIF
		  THIS.nRecordCount = m.ix
		  THIS.Rowsource = 'THIS.aRecordList'
		
		  * Sync nav control to actual current record.
		  THIS.ListIndex = MAX(1, THIS.FindRecord(m.nRecno))
		
		  * Restore original record position, or close clone as appropriate.
		  IF ALIAS() == UPPER(TRIM(THIS.cWorkarea))
		    IF m.nRecno <= RECCOUNT()
		      GOTO (m.nRecno)
		    ENDIF
		  ELSE
		    USE   && Close temporary workarea
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Refresh
		LOCAL ix, nCol, cText, nSelect, lReSort
		
		  IF THIS.lNavigator
		    * If called before Init() event completes, we don't do anything. All CodeMine controls
		    * need to allow for the possibility of Refresh() being called before Init(), since user
		    * code in controls lower in Z order may trigger the refresh of other controls.
		    IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		      RETURN .F.
		    ENDIF
		
		    * Rebuild display if the parent record has changed.
		    IF THIS.lNeedRebuild OR NOT BITTEST(THIS.nControlFlags, CTLFLAG_INITIALIZED) ;
		    OR (NOT EMPTY(THIS.cParentAlias) AND THIS.nParentRecno != RECNO(THIS.cParentAlias))
		      IF NOT THIS.Rebuild()
		        RETURN .F.
		      ENDIF
		    ENDIF
		
		    IF THIS.nRecordCount = 0
		      THIS.ListIndex = 1
		    ELSE
		      * Use ASCAN() to re-sync nav control to actual current record.
		      IF THIS.ListIndex = 0 OR THIS.ListIndex > ALEN(THIS.aRecordList, 1) ;
		      OR RECNO(THIS.cWorkarea) != THIS.aRecordList[THIS.ListIndex, THIS.ColumnCount + 1]
		        THIS.ListIndex = THIS.FindRecord(RECNO(THIS.cWorkarea))
		      ENDIF
		
		      * Update the displayed text for the current record on each refresh
		      IF THIS.ListIndex > 0
		        m.nSelect = SELECT()
		 
		        * Evaluate the display expression in the navigator workarea.
		        SELECT (THIS.cWorkarea)
		        FOR nCol = 1 TO THIS.ColumnCount
		          m.cText = EVALUATE(THIS.aDisplayExpression[m.nCol])
		          IF NOT EMPTY(m.cText) OR NOT THISFORM.cmDataManager.IsNew(THIS.cWorkarea)
		            m.cText = NVL(m.cText, THIS.NullDisplay)
		            IF NOT THIS.aRecordList[THIS.ListIndex, m.nCol] == m.cText
		              IF m.nCol = THIS.nSortColumn
		                m.lReSort = .T.  && If data changed for sorted col, resort array.
		              ENDIF
		              THIS.aRecordList[THIS.ListIndex, m.nCol] = m.cText
		            ENDIF
		          ENDIF
		        ENDFOR
		
		        * Resort the rows if data in sort column changed.
		        IF THIS.lSorted AND m.lReSort
		          =ASORT(THIS.aRecordList, THIS.nSortColumn)
		          THIS.Rowsource = 'THIS.aRecordList'
		          THIS.ListIndex = THIS.FindRecord(RECNO(THIS.cWorkarea))
		        ENDIF
		        SELECT (m.nSelect)
		      ENDIF
		    ENDIF
		  ELSE
		    RETURN DODEFAULT()   && Navigator features are disabled
		  ENDIF
		
	ENDPROC

	PROCEDURE UIEnable
		LPARAMETERS lEnable
		
		* Refresh navigator whenever it's page activates.
		IF THIS.lNavigator
		  IF m.lEnable
		    THIS.Refresh()
		  ENDIF
		ELSE
		  DODEFAULT(m.lEnable)
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS shpsplitterbar AS shpshapecustom OF "..\custom\ccontrol.vcx" 		&& Splitter bar control
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\split.bmp" ClassIcon="..\graphics\split.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: aftermove		&& Called after the splitter bar has been moved.
		*m: beforemove		&& Called before the splitter bar is about to be moved. Return .F. to prevent movement.
		*p: cleftpane		&& Object name of left pane container
		*p: crightpane		&& Object name of right pane container
		*p: lvertical		&& Set to .T. if the 2 split panes are arranged vertically on the form.
		*p: nminleft		&& Minimum allowable width for left pane
		*p: nminright		&& Minimum allowable width for right pane
	*</DefinedPropArrayMethod>

	BackStyle = 0
	cleftpane = 		&& Object name of left pane container
	creposition = vStretch
	crightpane = 		&& Object name of right pane container
	Height = 236
	MouseIcon = ..\graphics\splith.cur
	MousePointer = 99
	Name = "shpsplitterbar"
	nminleft = 0		&& Minimum allowable width for left pane
	nminright = 0		&& Minimum allowable width for right pane
	SpecialEffect = 1
	Visible = .F.
	Width = 4
	ZOrderSet = 12
	
	PROCEDURE aftermove		&& Called after the splitter bar has been moved.
	ENDPROC

	PROCEDURE beforemove		&& Called before the splitter bar is about to be moved. Return .F. to prevent movement.
	ENDPROC

	PROCEDURE Init
		DODEFAULT()
		
		IF NOT THIS.Visible
		  THIS.BorderStyle = 0
		  THIS.Visible = .T.
		ENDIF
		
		THIS.lVertical = THIS.Height < THIS.Width
		IF THIS.lVertical
		  THIS.MouseIcon = 'splitV.cur'
		ELSE
		  THIS.MouseIcon = 'splitH.cur'
		ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nCol, nRow
		LOCAL nOffset, nDelta, nCursorHandle, nFoxelToPixel
		LOCAL oLeft, oRight
		
		  DECLARE INTEGER GetCursor IN user32 AS GetMouseCursor
		  DECLARE INTEGER SetCursor IN user32 AS SetMouseCursor INTEGER nHandle
		
		  * Adjust relative size of left and right panels.
		  IF m.nButton = 1 AND NOT EMPTY(THIS.cLeftPane) AND NOT EMPTY(THIS.cRightPane) ;
		  AND THIS.BeforeMove()
		    m.nCursorHandle = GetMouseCursor()
		    m.oLeft = EVALUATE('THIS.Parent.' + THIS.cLeftPane)
		    m.oRight = EVALUATE('THIS.Parent.' + THIS.cRightPane)
		
		    IF NOT THIS.lVertical
		      m.nOffset = m.nCol - THIS.Left
		      m.nFoxelToPixel = FONTMETRIC(6)
		      DO WHILE MDOWN()
		        m.nDelta = INT(MCOL(THISFORM.Name) * m.nFoxelToPixel) - (THIS.Left + m.nOffset)
		
		        * Enforce minimumm panel widths
		        IF 'Ole' $ m.oLeft.baseclass + m.oRight.baseclass
		          IF (m.oLeft.Width + m.nDelta) < THIS.nMinLeft ;
		          OR (m.oRight.Width - m.nDelta) < THIS.nMinRight
		            EXIT && Need to exit at limits, or VFP can miss mouseUp events over activex controls
		          ENDIF
		        ELSE
		          IF (m.oLeft.Width + m.nDelta) < THIS.nMinLeft
		            m.nDelta = THIS.nMinLeft - m.oLeft.Width
		          ENDIF
		          IF (m.oRight.Width - m.nDelta) < THIS.nMinRight
		            m.nDelta = m.oRight.Width - THIS.nMinRight
		          ENDIF
		        ENDIF
		
		        IF m.nDelta != 0
		          =SetMouseCursor(m.nCursorHandle)
		          THIS.Left = THIS.Left + m.nDelta
		          WITH m.oLeft
		            IF .BaseClass == 'Pageframe'
		              .Set('Width', .Width + m.nDelta)  && Use Set() method to avoid VFP pageframe resize bug
		            ELSE
		              .Width = .Width + m.nDelta
		            ENDIF
		            IF PEMSTATUS(m.oLeft, 'nRight', 5)
		              .nRight = .nRight - m.nDelta
		            ENDIF
		            THIS.nRight = THIS.nRight - m.nDelta
		          ENDWITH
		          WITH m.oRight
		            .Left = .Left + m.nDelta
		            IF .BaseClass == 'Pageframe'
		              .Set('Width', .Width - m.nDelta)  && Use Set() method to avoid VFP pageframe resize bug
		            ELSE
		              .Width = .Width - m.nDelta
		            ENDIF
		          ENDWITH
		          THISFORM.Draw()
		        ENDIF
		      ENDDO
		    ELSE
		      m.nOffset = m.nRow - THIS.Top
		      m.nFoxelToPixel = FONTMETRIC(1) + FONTMETRIC(5)
		      DO WHILE MDOWN()
		        m.nDelta = INT(MROW(THISFORM.Name) * m.nFoxelToPixel) - (THIS.Top + m.nOffset)
		
		        * Enforce minimumm panel heights
		        IF 'Ole' $ m.oLeft.baseclass + m.oRight.baseclass
		          IF (m.oLeft.Height + m.nDelta) < THIS.nMinLeft ;
		          OR (m.oRight.Height - m.nDelta) < THIS.nMinRight
		            EXIT && Need to exit at limits, or VFP can miss mouseUp events over activex controls
		          ENDIF
		        ELSE
		          IF (m.oLeft.Height + m.nDelta) < THIS.nMinLeft
		            m.nDelta = THIS.nMinLeft - m.oLeft.Height 
		          ENDIF
		          IF (m.oRight.Height - m.nDelta) < THIS.nMinRight
		            m.nDelta = m.oRight.Height - THIS.nMinRight
		          ENDIF
		        ENDIF
		
		        IF m.nDelta != 0
		          =SetMouseCursor(m.nCursorHandle)
		          THIS.Top = THIS.Top + m.nDelta
		          WITH m.oLeft
		            IF .BaseClass == 'Pageframe'
		              .Set('Height', .Height + m.nDelta)  && Use Set() method to avoid VFP pageframe resize bug
		            ELSE
		              .Height = .Height + m.nDelta
		            ENDIF
		            IF PEMSTATUS(m.oLeft, 'nBottom', 5)
		              .nBottom = .nBottom - m.nDelta
		            ENDIF
		            THIS.nBottom = THIS.nBottom - m.nDelta
		          ENDWITH
		          WITH m.oRight
		            .Top = .Top + m.nDelta
		            IF .BaseClass == 'Pageframe'
		              .Set('Height', .Height - m.nDelta)  && Use Set() method to avoid VFP pageframe resize bug
		            ELSE
		              .Height = .Height - m.nDelta
		            ENDIF
		          ENDWITH
		          THISFORM.Draw()
		        ENDIF
		      ENDDO
		      THIS.AfterMove()
		    ENDIF
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS txtdate AS txttextboxcustom OF "..\custom\ccontrol.vcx" 		&& CodeMine Freeform date entry control
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\dyttxtbx.bmp" ClassIcon="..\graphics\dyttxtbx.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: _setvalue		&& Internal method to update the dValue property of this control.
		*p: ccenturydefault		&& Determines method for determining default century. Values are: Rollover, Current, Future, or Past.
		*p: cdateformat		&& Date display format. Options are: MONTH [Char], MDY [Short], DMY [Short], NUMERIC
		*p: dvalue		&& Control value in FoxPro Date format.
		*p: ndefaultday		&& Default day used if only month and year are entered. -1 to default to last day of month. 0 to require day entry.
		*p: ostring		&& Runtime reference to the string tools object.
	*</DefinedPropArrayMethod>

	PROTECTED ostring
	ccenturydefault = Rollover		&& Determines method for determining default century. Values are: Rollover, Current, Future, or Past.
	cdateformat = Numeric		&& Date display format. Options are: MONTH [Char], MDY [Short], DMY [Short], NUMERIC
	dvalue = {}		&& Control value in FoxPro Date format.
	Name = "txtdate"
	ndefaultday = 0		&& Default day used if only month and year are entered. -1 to default to last day of month. 0 to require day entry.
	ostring = .NULL.		&& Runtime reference to the string tools object.
	SelectOnEntry = .T.
	
	PROCEDURE contextmenubuild
		  IF NOT THIS.lWriteLock
		    THISFORM.ContextMenuSeparator(CTX_BAR_CUSTOM)
		    THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 1, '%barDateToday')
		
		    IF NOT EMPTY(THIS.dValue) AND NOT 'MONTH' $ UPPER(THIS.cDateFormat)
		      THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 3, '%barDateFirstDay')
		      THISFORM.ContextMenuBar(CTX_BAR_CUSTOM + 4, '%barDateLastDay')
		    ENDIF
		    THISFORM.ContextMenuSeparator(CTX_BAR_CUSTOM + 6)
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETER cOption
		*++
		* Execute custom context menu options.
		*--
		LOCAL nDay, nMonth, nYear
		
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%bardatetoday'
		      THIS.SetValue(DATE())
		
		    CASE m.cOption = '%bardatefirstday'
		      m.nDay = 1
		      m.nMonth = MONTH(THIS.dValue)
		      m.nYear = YEAR(THIS.dValue) 
		      THIS.SetValue(THIS.oString.StringToDate(STR(m.nYear, 4) + STR(m.nMonth, 2) + STR(m.nDay, 2)))
		
		    CASE m.cOption = '%bardatelastday'
		      m.nDay = 1
		      m.nMonth = MONTH(THIS.dValue) + 1
		      m.nYear = YEAR(THIS.dValue)
		      IF m.nMonth > 12
		        m.nMonth = 1
		        m.nYear = m.nYear + 1
		      ENDIF
		      THIS.SetValue(THIS.oString.StringToDate(STR(m.nYear, 4) + STR(m.nMonth, 2) + STR(m.nDay, 2)) - 1)
		
		    OTHERWISE
		      RETURN DODEFAULT(m.cOption)
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getvalue
		* The "value" for this control is the dValue property
		RETURN THIS.dValue
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Freeform Date Entry control, with enhanced year 2000 support.
		*
		* Copyright 1996-1998 Soft Classics, Ltd. All rights reserved.
		*--
		
		* If we are using a Month/Year display format, don't require a day number on entry
		IF 'MONTH' $ UPPER(THIS.cDateFormat) AND EMPTY(THIS.nDefaultDay)
		  THIS.nDefaultDay = 1
		ENDIF
		
		THIS.oString = CreateGlobalObject('cmStringTools')
		
		IF NOT DODEFAULT()
		  RETURN .F.
		ENDIF
		
		* VFP will append time to input mask if bound to datetime field with 
		* a numeric input mask. Since this control doesnt support times, we strip it off.
		IF '99:99' $ THIS.InputMask
		  THIS.InputMask = '99/99/9999'
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		IF NOT THIS.lWriteLock
		  DO CASE
		    CASE INLIST(m.nKeyCode, ASC('/'), ASC('-')) AND CHR(m.nKeyCode) $ THIS.InputMask
		      LOCAL ix
		      m.ix = AT(CHR(m.nKeyCode), SUBSTR(THIS.Inputmask, MAX(THIS.Selstart, 1)))
		      IF m.ix > 0
		        THIS.SelStart = THIS.SelStart + m.ix - 1
		      ELSE
		        ??CHR(7)
		      ENDIF
		
		    CASE INLIST(m.nKeyCode, ASC('@'), ASC('='))
		      THIS.SetValue(DATE())
		
		    CASE m.nKeyCode = ASC(']')
		      THIS.SetValue(GOMONTH(THIS.dValue, 1))
		    CASE m.nKeyCode = ASC('[')
		      THIS.SetValue(GOMONTH(THIS.dValue, -1))
		
		    CASE m.nKeyCode = ASC('>')
		      IF 'MONTH' $ UPPER(THIS.cDateFormat)
		        ??CHR(7)
		      ELSE
		        THIS.SetValue(THIS.dValue + 1)
		      ENDIF
		    CASE m.nKeyCode = ASC('<')
		      IF 'MONTH' $ UPPER(THIS.cDateFormat)
		        ??CHR(7)
		      ELSE
		        THIS.SetValue(THIS.dValue - 1)
		      ENDIF
		
		    CASE m.nKeyCode = ASC('}')
		      IF 'MONTH' $ UPPER(THIS.cDateFormat)
		        ??CHR(7)
		      ELSE
		        THIS.ContextMenuExecute('%barDateLastDay')
		      ENDIF
		    CASE m.nKeyCode = ASC('{')
		      IF 'MONTH' $ UPPER(THIS.cDateFormat)
		        ??CHR(7)
		      ELSE
		        THIS.ContextMenuExecute('%barDateFirstDay')
		      ENDIF
		    OTHERWISE
		      RETURN DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		  ENDCASE
		  NODEFAULT
		  RETURN .T.
		ENDIF
		RETURN DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
	ENDPROC

	PROCEDURE loadvalue
		LOCAL uValue
		IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)
		  * Various post-load data conversions
		  IF VARTYPE(m.uValue) = 'T'    && This control does not support DATETIME values.
		    m.uValue = TTOD(m.uValue)
		  ENDIF
		
		  RETURN THIS._SetValue(m.uValue)
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE setvalue
		LPARAMETER dValue
		
		  IF VARTYPE(m.dValue) $ 'DTX'
		    RETURN DODEFAULT(m.dValue)
		  ENDIF
		  ERROR 1732   && Wrong data type
		  RETURN .F.
		
	ENDPROC

	PROCEDURE undochanges
		IF EMPTY(THIS.cValueSource)
		  THIS._SetValue(THIS.uOriginalValue)
		ELSE
		  THIS.LoadValue()
		ENDIF
		THIS.lChanged = .F.
		
	ENDPROC

	PROCEDURE Valid
		LOCAL dValue
		  IF THISFORM.cmBindingManager.ValidNeeded(THIS)
		    * Parse and validate the date before processing default validation.
		    IF ISNULL(THIS.Value)
		      THIS.dValue = .NULL.
		    ELSE
		      m.dValue = THIS.oString.ParseDate(THIS.Value, THIS.cCenturyDefault, THIS.nDefaultDay)
		      IF ISNULL(m.dValue)
		        THISFORM.DisplayMessage('%msgBadDate')
		        RETURN 0
		      ENDIF
		      THIS._SetValue(m.dValue)
		    ENDIF
		
		    * Call binding manager for the remaining common control valid() processing.
		    RETURN THISFORM.cmBindingManager.Valid(THIS)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE _setvalue		&& Internal method to update the dValue property of this control.
		LPARAMETERS dValue
		*++
		* Low-level method to set the internal value of the control (dValue property).
		* Used internally, and by Binding Manager.
		*--
		  IF ISNULL(THIS.oString)
		    THIS.oString = CreateGlobalObject('cmStringTools')
		  ENDIF
		
		  THIS.dValue = m.dValue
		  IF ISNULL(m.dValue)
		    THIS.Value = ''
		    THIS.Value = .NULL.  && Make sure it is a NULL of a character datatype
		  ELSE
		    THIS.Value = THIS.oString.FormatDate(THIS.dValue, THIS.cDateFormat)
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS txtnumeric AS txttextboxcustom OF "..\custom\ccontrol.vcx" 		&& Calculator style numeric data entry
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\numtxtbx.bmp" ClassIcon="..\graphics\numtxtbx.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addinternalproperties		&& Add properties used internally at runtime.
		*m: fixcaret		&& Keep caret within legal bounds.
		*m: gendisplaymask		&& Generate a default display mask based on the bound data field properties.
		*m: parsedisplay
		*m: reset		&& Initialize or re-initialize control properties.
		*m: sellength_assign
		*m: _setvalue		&& Internal method to set the control value and redraw the display.
		*p: ccurrencysource		&& Bound field containing ISO currency abbreviation of cValueSource
		*p: cdisplaycurrency		&& ISO name of currency to display in.
		*p: cnegativesign		&& Controls display of minus sign: Left, Right, Parens, or None.
		*p: csymbol		&& Currency display symbol. Leave empty to use language default.
		*p: csymbolposition		&& Specifies position (LEFT or RIGHT) to display currency symbol. Defaults to SET CURRENCY setting.
		*p: cvaluecurrency		&& ISO name of current value's currency
		*p: lblankwhenzero		&& Control displays blank when value is zero.
		*p: lexplicitdp		&& When True, fixed decimal point fields require an explicit decimal point.
		*p: nnegativecolor		&& Color to display negative numbers in. -1 to use same color as positive numbers.
	*</DefinedPropArrayMethod>

	Alignment = 1
	ccurrencysource = 		&& Bound field containing ISO currency abbreviation of cValueSource
	cdisplaycurrency = 		&& ISO name of currency to display in.
	chelpclasskey = %hlpNumeric,%hlpValueMemory
	cnegativesign = Left		&& Controls display of minus sign: Left, Right, Parens, or None.
	creadprivilege = 
	csymbol = 		&& Currency display symbol. Leave empty to use language default.
	csymbolposition = 		&& Specifies position (LEFT or RIGHT) to display currency symbol. Defaults to SET CURRENCY setting.
	cvaluecurrency = 		&& ISO name of current value's currency
	cvaluesource = 
	cwriteprivilege = 
	FontSize = 9
	lexplicitdp = .T.		&& When True, fixed decimal point fields require an explicit decimal point.
	Name = "txtnumeric"
	nnegativecolor = -1		&& Color to display negative numbers in. -1 to use same color as positive numbers.
	Width = 121
	
	PROCEDURE addinternalproperties		&& Add properties used internally at runtime.
		* Add internal runtime properties, if not already added.
		IF NOT PEMSTATUS(THIS, 'nValue', 5)
		  THIS.AddProperty('nValue', 0)          && Numeric value of the control
		  THIS.AddProperty('cDisplayBuffer', '')
		  THIS.AddProperty('cDisplayMask', '')
		  THIS.AddProperty('cCurrency', '')
		  THIS.AddProperty('lNegative')
		  THIS.AddProperty('nDecimals', 0)
		  THIS.AddProperty('nDisplayDP', 0)
		  THIS.AddProperty('nPrefixLen', 0)      && Currency/sign prefix length
		  THIS.AddProperty('nSuffixLen', 0)      && Currency/sign suffix length
		  
		  THIS.AddProperty('nOriginalColor', THIS.ForeColor)
		  THIS.AddProperty('oCurrConvert', .NULL.)
		ENDIF
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETER cOption
		*++
		* Special txtNumeric processing for Revert and value memory functions.
		*--
		  IF DODEFAULT(m.cOption)
		    THIS.SelStart = 0
		    THIS.KeyPress(6, 0)   && Simulate the 'End' key
		    RETURN .T.
		  ENDIF
		  RETURN .F.  && Option not processed by default code.
		
	ENDPROC

	PROCEDURE Destroy
		* Clear ctrl+z okl command, just to be sure it gets reset. LostFocus() isnt always called on form release.
		ON KEY LABEL CTRL+Z
		
	ENDPROC

	PROCEDURE fixcaret		&& Keep caret within legal bounds.
		* If ResetCaret flag is set and caret is past left of data, set it just before the decimal point.
		IF BITTEST(THIS.nControlFlags, CTLFLAG_RESET_CARET)
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_RESET_CARET)
		  IF THIS.SelStart < LEN(THIS.InputMask) - LEN(THIS.cDisplayBuffer) + THIS.nPrefixLen
		    THIS.KeyPress(6, 0)   && Simulate the 'End' key
		  ENDIF
		ENDIF  
		
		THIS.SelStart = MAX( MIN(THIS.SelStart, LEN(THIS.InputMask) - THIS.nSuffixLen), ;
		                         LEN(THIS.InputMask) - LEN(THIS.cDisplayBuffer) + THIS.nPrefixLen)
		
	ENDPROC

	PROCEDURE gendisplaymask		&& Generate a default display mask based on the bound data field properties.
		*++
		* Generate a default display mask based on bound data field.
		* The number of decimal places in this mask may later be 
		* adjusted by the currency object, if this is currency data.
		*--
		LOCAL cMask
		
		  IF NOT EMPTY(THIS.cValueSource) AND NOT EMPTY(THIS.cWorkarea) 
		    LOCAL cType, nDigits, nDecimals
		
		    * Some Windows Printer drivers have bugs that require this workaround to avoid API Exception errors.
		    DECLARE _fpreset IN MSVCRT.DLL
		    _fpreset()
		
		    * Get bound field length and decimal places.
		    IF PEMSTATUS(THISFORM, 'cmDataManager', 5)
		      m.cType = THISFORM.cmDataManager.FieldType(THIS.cWorkarea, THIS.cValueSource, @m.nDigits, @m.nDecimals)
		    ELSE
		      m.cType = cmFieldInfo(EVALUATE(THIS.cValueSource), @m.nDigits, @m.nDecimals)
		    ENDIF
		
		    IF EMPTY(m.nDigits)   && If we can't determine correct number of digits
		      m.nDigits = 10
		      m.nDecimals = SET('DECIMALS')
		    ELSE
		      DO CASE
		        CASE m.cType = 'Y'
		          m.nDecimals = SET('DECIMALS')  && Default to language currency setting
		          m.nDigits = 16 - 4             && VFP can reliably handle only 16 digits of numeric precision, including DP.
		        CASE m.cType = 'I'
		          m.nDigits = 9
		        OTHERWISE
		          IF m.nDecimals > 0
		            m.nDigits = m.nDigits - m.nDecimals - 1
		          ENDIF
		      ENDCASE
		    ENDIF
		  ELSE
		    * Control is not bound, or bound to a memvar/property - use hardcoded default mask.
		    * Also, if the value of a bound field is .NULL. we can't get the size & DP info.
		    m.nDigits = 10
		    m.nDecimals = SET('DECIMALS')
		  ENDIF
		
		  * Adjust number of digits to account for comma seperators every 3 digits
		  m.nDigits = m.nDigits + INT(m.nDigits / 3) - IIF(m.nDigits % 3 = 0, 1, 0)
		  RETURN RIGHT('999,999,999,999,999,999', m.nDigits) ;
		         + IIF(m.nDecimals > 0, '.' + REPLICATE('9', m.nDecimals), '')
		
	ENDPROC

	PROCEDURE getvalue
		RETURN THIS.nValue
		
	ENDPROC

	PROCEDURE GotFocus
		* Make note that we have focus (before call to DODEFAULT) for processing of lBlankWhenZero
		THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_HAS_FOCUS)
		
		DODEFAULT()
		
		* An unbound control may still be blank after default code, so redraw the 0 value if needed.
		IF THIS.lBlankWhenZero AND EMPTY(THIS.Value)
		  THIS._SetValue(THIS.nValue)
		ENDIF
		
		* ^Z undo must be implimented internally, via OKL, since the std system menu eats it.
		ON KEY LABEL CTRL+Z KEYBOARD '{CTRL+DEL}' PLAIN CLEAR
		
		* If SelectOnEntry is set, and got focus by mouseclick in control, select-all on mouseup.
		THIS.SelStart = 0
		IF 'K' $ UPPER(THIS.Format) OR THIS.SelectOnEntry ;
		OR (THIS.Parent.BaseClass == 'Column' AND THIS.Parent.SelectOnEntry)
		  * Force a select-all. Usually redundant, but there are times VFP's select-all doesn't work.
		  THIS.SelLength = LEN(THIS.InputMask)
		
		  * First time activated in a pageframe, setting selLength doesn't work, so this is the only alternative.
		  KEYBOARD '{CTRL+A}' PLAIN 
		
		  * Tell mouse-up to enforce select-all also.
		  THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		ELSE
		  THIS.KeyPress(6, 0)   && Simulate the 'End' key
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		*++
		* Codemine Calculator mode numeric data entry control.
		*
		* Copyright 1996-1998 Soft Classics, Ltd. All rights reserved.
		*--
		  * Clear these, since they dont apply to numerics.
		  STORE .F. TO THIS.lAllowzoom, THIS.lProperCase
		
		  THIS.AddInternalProperties()
		
		  * Inherit settings from parent column, before calling reset() method.
		  IF THIS.Parent.BaseClass == 'Column' AND THIS.Parent.Bound
		    IF EMPTY(THIS.Inputmask)
		      THIS.Inputmask = THIS.Parent.Inputmask
		    ENDIF
		    IF EMPTY(THIS.Format)
		      THIS.Format = THIS.Parent.Format
		    ENDIF
		  ENDIF
		
		  * If a currency source is specified, load its current value.
		  THIS.cCurrency = ''
		  IF NOT THIS.lNoInitData AND NOT EMPTY(THIS.cCurrencySource)
		    THIS.cValueCurrency = EVALUATE(THIS.cCurrencySource)
		  ENDIF
		
		  * Initialize data related properties
		  THIS.Reset()
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE InteractiveChange
		IF DODEFAULT()
		  THIS.cDisplayBuffer = ALLTRIM(LEFT(THIS.Value, LEN(THIS.Value) - 1))
		  THIS._SetValue(THIS.ParseDisplay())
		
		  * Need to reset caret position if out of bounds.
		  THIS.FixCaret()
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		LOCAL nDP, nOldCaret, nNewCaret, nSelLength, nPosition, cDPAlignment
		
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		
		  m.nDP = THIS.nDisplayDP + THIS.nPrefixLen - 1   && Adjust DP position to account for sign prefix
		  m.nOldCaret = THIS.SelStart
		  m.nSelLength = THIS.SelLength
		
		  * nPosition is the caret position, relative to the start of displayed data.
		  * For example, a leading minus sign is nPosition 1, first digit is nPosition 2.
		  m.nPosition = m.nOldCaret - (LEN(THIS.InputMask) - LEN(THIS.cDisplayBuffer) - 1)
		  IF m.nPosition < 1
		    m.nSelLength = MAX(0, m.nSelLength + m.nPosition - 1)
		    m.nPosition = 1
		  ENDIF
		
		  * In explicit dp mode, and any of selection is to right of DP.
		  IF THIS.lExplicitDP AND THIS.nDecimals > 0 ;
		  AND ((m.nSelLength > 0 AND m.nOldCaret + THIS.SelLength >= m.nDP) OR ISNULL(THIS.Value))
		    DO CASE
		      CASE ISNULL(THIS.Value)
		        * DP is contained in the replacement
		        m.nNewCaret = m.nDP                               && Position caret at dp.
		        m.cDPAlignment = REPLICATE('0', THIS.nDecimals)
		      CASE m.nOldCaret <= m.nDP
		        * DP is contained in the replacement
		        m.nNewCaret = m.nDP                               && Position caret at dp.
		        m.cDPAlignment = REPLICATE('0', MAX(0, MIN(THIS.nDecimals, THIS.SelLength - (m.nDP - m.nOldCaret) - 1), 0))
		      OTHERWISE
		        * Selection is entirely to the right of the DP.
		        m.nNewCaret = m.nOldCaret + 1
		        m.cDPAlignment = REPLICATE('0', MIN(THIS.nDecimals - (m.nOldCaret - m.nDP - 1), THIS.SelLength) ;
		                       - IIF(ISDIGIT(CHR(m.nKeyCode)), 1, 0))
		    ENDCASE
		  ELSE
		    * Not explicit DP, or full selection is to left of DP.
		    m.nNewCaret = IIF(ISNULL(THIS.Value), LEN(THIS.InputMask), m.nOldCaret + THIS.SelLength)
		    m.cDPAlignment = ''
		  ENDIF
		
		  DO CASE
		    CASE m.nKeyCode = 27
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_ESCAPE)      && Flag that we are processing an escape key press.
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_RESET_CARET) && Set caret to field-entry position (usualy at decimal point)
		      THIS.lChanged = .F.       && Escape resets data, so clear change flag to prevent validation
		      RETURN .T.
		
		    CASE INLIST(m.nKeyCode, 9, 15, 10, 13, 18, 3, 5, 24, 2, 26)
		      * Default processing for Tab, Backtab, Enter, ctrl+enter, up, down, pgup, pgdn
		      RETURN DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
		    CASE m.nShiftAltCtrl > 0 AND INLIST(m.nKeyCode, 52, 54)
		      * Default processing for shift/ctrl+left/right arrows
		      RETURN DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
		    CASE m.nShiftAltCtrl >= 2 AND INLIST(m.nKeyCode, 148)
		      * Default processing for ctrl+tab & ctrl+shift+tab
		      RETURN DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
		    CASE m.nKeyCode = 22          && Insert mode toggle
		      m.nNewCaret = -1
		      =INSMODE(NOT INSMODE())
		
		    CASE INLIST(m.nKeyCode, 26, 147)    && ^Z or ctrl+del Undo
		      * The edit menu ^Z is disabled for this control, but still eats the ^Z. We use
		      * CTRL+DEL as a synonym for ^Z, and use OKL to convert ^Z keypress into ctrl+DEL
		      THIS.UndoChanges()
		
		    CASE m.nKeyCode = ASC('0') AND m.nShiftAltCtrl = 2
		      * ctrl+0 (zero) keystroke enters a .NULL. via keyboard.
		      IF THIS.lAllowNull
		        THIS.SetValue(.NULL.)
		      ELSE
		        ??CHR(7)
		      ENDIF
		
		    CASE (m.nKeyCode >= ASC('0') AND m.nKeyCode <= ASC('9')) AND m.nShiftAltCtrl = 0
		      IF THIS.lChanged OR THIS.BeforeChange()
		        IF m.nSelLength > 0 OR ISNULL(THIS.Value)
		          THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, m.nSelLength, CHR(m.nKeyCode)) + m.cDPAlignment
		        ELSE
		          IF THIS.lExplicitDP AND THIS.nDecimals > 0 AND m.nOldCaret > m.nDP
		            * We are past dp in explicit dp mode, use left-to-right data entry.
		            IF m.nPosition > LEN(THIS.cDisplayBuffer) - THIS.nSuffixLen
		              ??CHR(7)
		            ELSE
		              IF INSMODE()
		                THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, 0, CHR(m.nKeyCode))
		                THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, LEN(THIS.cDisplayBuffer) - THIS.nSuffixLen, 1, '')
		              ELSE
		                THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, 1, CHR(m.nKeyCode))
		              ENDIF
		              m.nNewCaret = m.nOldCaret + 1
		            ENDIF
		          ELSE
		            * No DP, Before DP, or in implicit DP mode.
		            LOCAL nCaret
		            m.nCaret = m.nOldCaret
		            IF NOT INSMODE()  && Move over seperators if in overwrite mode.
		              DO WHILE m.nCaret < LEN(THIS.cDisplayMask) + THIS.nPrefixLen ;
		              AND NOT SUBSTR(THIS.cDisplayMask, m.nCaret - THIS.nPrefixLen + 1, 1) $ '9.'
		                m.nCaret = m.nCaret + 1
		                m.nPosition = m.nPosition + 1
		              ENDDO
		            ENDIF
		            DO CASE
		              CASE NOT INSMODE() AND m.nCaret = m.nDP
		                ??CHR(7)    && Stop when we get to DP in overwrite mode
		              CASE (INSMODE() OR m.nPosition > LEN(THIS.cDisplayBuffer) - THIS.nSuffixLen) ;
		                   AND LEN(THIS.cDisplayBuffer) >= LEN(THIS.InputMask)
		                ??CHR(7)
		              OTHERWISE
		                THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, IIF(INSMODE(), 0, 1), CHR(m.nKeyCode))
		                m.nNewCaret = m.nCaret + IIF(INSMODE(), 0, 1)
		            ENDCASE
		          ENDIF
		        ENDIF
		        THIS._SetValue(THIS.ParseDisplay())
		      ENDIF
		
		    CASE THIS.lExplicitDP AND THIS.nDecimals > 0 AND m.nKeyCode = ASC(SET('POINT'))
		      IF THIS.lChanged OR THIS.BeforeChange()
		        m.nNewCaret = m.nDP + 1
		        IF m.nSelLength > 0
		          THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, m.nSelLength, '') + m.cDPAlignment
		          THIS._SetValue(THIS.ParseDisplay())
		        ENDIF
		      ENDIF
		
		    CASE m.nKeyCode = 127         && Rubout/Backspace
		      IF NOT EMPTY(THIS.cDisplayBuffer) AND (THIS.lChanged OR THIS.BeforeChange())
		        IF m.nSelLength > 0
		          THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, m.nSelLength, '') + m.cDPAlignment
		        ELSE
		          IF THIS.lExplicitDP AND THIS.nDecimals > 0 AND m.nOldCaret > m.nDP
		            IF m.nOldCaret > m.nDP + 1
		              THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition - 1, 1, '')
		              THIS.cDisplayBuffer = THIS.cDisplayBuffer + '0'
		            ENDIF
		            m.nNewCaret = m.nOldCaret - 1
		          ELSE
		            * Skip over display filler characters.
		            DO WHILE m.nPosition > 1 AND NOT ISDIGIT(SUBSTR(THIS.cDisplayBuffer, m.nPosition - 1, 1))
		              m.nPosition = m.nPosition - 1
		            ENDDO
		            THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition - 1, 1, '')
		          ENDIF
		        ENDIF
		        THIS._SetValue(THIS.ParseDisplay())
		      ENDIF
		
		    CASE m.nKeyCode = 7           && Delete Key
		      IF NOT EMPTY(THIS.cDisplayBuffer) AND (THIS.lChanged OR THIS.BeforeChange())
		        IF m.nSelLength > 0
		          THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, m.nSelLength, '') + m.cDPAlignment
		        ELSE
		          THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, 1, '')
		          IF THIS.lExplicitDP AND THIS.nDecimals > 0 ;
		          AND m.nOldCaret > m.nDP AND m.nPosition <= LEN(THIS.cDisplayBuffer)
		            THIS.cDisplayBuffer = THIS.cDisplayBuffer + '0'
		          ENDIF
		        ENDIF
		        THIS._SetValue(THIS.ParseDisplay())
		      ENDIF
		
		    CASE m.nKeyCode = ASC('-') AND THIS.cNegativeSign != 'None'    && Negate Sign
		      IF THIS.lChanged OR THIS.BeforeChange()
		        IF m.nSelLength > 0
		          THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, m.nSelLength, '') + m.cDPAlignment
		        ENDIF
		        THIS._SetValue(THIS.ParseDisplay() * -1, NOT THIS.lNegative)
		      ENDIF
		
		    CASE m.nKeyCode = ASC('+')    && Force positive Sign
		      IF THIS.lChanged OR THIS.BeforeChange()
		        IF m.nSelLength > 0
		          THIS.cDisplayBuffer = STUFF(THIS.cDisplayBuffer, m.nPosition, m.nSelLength, '') + m.cDPAlignment
		        ENDIF
		        THIS._SetValue(ABS(THIS.ParseDisplay()))
		      ENDIF
		
		    CASE m.nKeyCode = 19    && Left
		      IF m.nOldCaret <= LEN(THIS.InputMask) - LEN(THIS.cDisplayBuffer) + THIS.nPrefixLen
		        THIS.SelStart = 0
		        RETURN .T.    && Default processing for left arrow off edge of control.
		      ENDIF
		      m.nNewCaret = m.nOldCaret + THIS.SelLength - 1
		
		    CASE m.nKeyCode = 4   && Right
		      IF m.nOldCaret >= LEN(THIS.InputMask) - THIS.nSuffixLen OR THIS.SelLength >= LEN(THIS.InputMask)
		        THIS.SelStart = LEN(THIS.InputMask)
		        RETURN .T.    && Default processing for right arrow off edge of control.
		      ENDIF
		      m.nNewCaret = m.nOldCaret + THIS.SelLength + 1
		
		    CASE m.nKeyCode = 1   && Home
		      m.nNewCaret = 1
		
		    CASE m.nKeyCode = 6  && End
		      IF THIS.lExplicitDP AND THIS.nDecimals > 0 AND m.nOldCaret < m.nDP
		        m.nNewCaret = m.nDP
		      ELSE
		        m.nNewCaret = LEN(THIS.InputMask)
		      ENDIF
		
		    OTHERWISE
		      ??CHR(7)
		      m.nNewCaret = -1
		  ENDCASE
		
		  IF m.nNewCaret >= 0
		    THIS.SelStart = m.nNewCaret
		    THIS.FixCaret()
		  ENDIF
		  NODEFAULT
		  RETURN .T.
		
	ENDPROC

	PROCEDURE loadtranslation
		LPARAMETERS nValue
		  * If display currency and value currency are different, conversion is necessary.
		  IF NOT EMPTY(THIS.cDisplayCurrency) AND NOT EMPTY(THIS.cValueCurrency) ;
		  AND NOT UPPER(THIS.cDisplayCurrency) == UPPER(THIS.cValueCurrency) 
		    IF NOT ISNULL(THIS.oCurrConvert)
		      RETURN THIS.oCurrConvert.Convert(m.nValue, THIS.cValueCurrency, THIS.cDisplayCurrency, .T.)
		    ENDIF
		  ENDIF
		  RETURN m.nValue
		
	ENDPROC

	PROCEDURE loadvalue
		LOCAL uValue
		  IF THISFORM.cmBindingManager.LoadValue(THIS, @m.uValue)
		    THIS._SetValue(m.uValue)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE LostFocus
		* Clear ctrl+z okl command.
		ON KEY LABEL CTRL+Z
		
		* Tell everybody we are no longer active (used by lBlankWhenZero option)
		THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_HAS_FOCUS)
		
		IF THIS.lBlankWhenZero AND THIS.nValue = 0 AND NOT THIS.lChanged
		  THIS.Refresh()
		ENDIF
		DODEFAULT()
		
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		  IF THIS.lChanged AND NOT BITTEST(THISFORM.nControlFlags, FRMFLAG_ACTIVE)
		    ACTIVATE WINDOW (THISFORM.Name)
		  ENDIF
		
		  IF THIS.SelLength = 0
		    IF BITTEST(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		      THIS.SelStart = 0
		      THIS.SelLength = LEN(THIS.InputMask)
		    ELSE
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, CTLFLAG_RESET_CARET)
		      THIS.FixCaret()
		    ENDIF
		  ENDIF
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, CTLFLAG_SELECT_ALL)
		
	ENDPROC

	PROCEDURE parsedisplay
		*++
		* Parse the current display buffer, set lNegative flag, and return the numeric value.
		*--
		LOCAL ix, ch, cData, nValue
		
		  * Trim off all leading zeros, and remove filler characters.
		  m.cData = ''
		  THIS.lNegative = .F.
		  FOR ix = 1 TO LEN(THIS.cDisplayBuffer)
		    m.ch = SUBSTR(THIS.cDisplayBuffer, m.ix, 1)
		    IF ISDIGIT(m.ch) AND (NOT EMPTY(m.cData) OR m.ch != '0')
		      m.cData = m.cData + m.ch
		    ELSE
		      IF m.ch $ '-('
		        THIS.lNegative = .T.
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  m.nValue = VAL(LEFT(m.cData, LEN(m.cData) - THIS.nDecimals))
		  IF THIS.nDecimals > 0
		    m.nValue = m.nValue + VAL('0' + SET('POINT') + PADL(RIGHT(m.cData, THIS.nDecimals), THIS.nDecimals, '0'))
		  ENDIF
		  RETURN m.nValue * IIF(THIS.lNegative, -1, 1)
		
	ENDPROC

	PROCEDURE Refresh
		LOCAL cCurrency, lFormatDone
		
		  * In case refresh() is ever called by user code before control init() completes.
		  THIS.AddInternalProperties()
		
		  * If a currency source is specified, load its current value.
		  IF NOT EMPTY(THIS.cCurrencySource)
		    THIS.cValueCurrency = EVALUATE(THIS.cCurrencySource)
		  ENDIF
		
		  * Reset the control if the display currency has changed.
		  m.cCurrency = IIF(EMPTY(THIS.cDisplayCurrency), THIS.cValueCurrency, THIS.cDisplayCurrency)
		  IF NOT m.cCurrency == THIS.cCurrency
		    THIS.Reset()
		  ENDIF
		
		  DODEFAULT()
		
		  IF EMPTY(THIS.cValueSource)
		    THIS._SetValue(THIS.nValue)   && Reformat unbound control
		  ENDIF
		
	ENDPROC

	PROCEDURE reset		&& Initialize or re-initialize control properties.
		*++
		* Prepare control for use. Called on Initialization. Must also be called
		* explicilty whenever you change display or data-related properties
		* such as sign type, inputMask, or cValueSource.
		*--
		LOCAL oCurrency
		
		  * Make sure we are using our own local value source property.
		  IF NOT EMPTY(THIS.ControlSource)
		    THIS.cValueSource = THIS.ControlSource
		    THIS.ControlSource = ''
		
		    * We need to set cWorkarea if called before default Init() method code.
		    IF NOT EMPTY(THIS.cValueSource)
		      IF EMPTY(THIS.cWorkarea)
		        LOCAL cWorkarea
		        IF '.' $ THIS.cValueSource
		          m.cWorkarea = LEFT(THIS.cValueSource, AT('.', THIS.cValueSource) - 1)
		          IF USED(m.cWorkarea)
		            THIS.cWorkarea = PROPER(m.cWorkarea)
		          ENDIF
		        ELSE
		          IF TYPE(ALIAS() + '.' + THIS.cValueSource) != 'U'
		            THIS.cWorkarea = PROPER(ALIAS())
		            THIS.cValueSource = THIS.cWorkarea + '.' + THIS.cValueSource
		          ENDIF
		        ENDIF
		      ELSE
		        THIS.cWorkarea = PROPER(TRIM(THIS.cWorkarea))
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Calculate display-only prefix and suffix areas of mask for currency indicators.
		  m.oCurrency = .NULL.
		  THIS.nPrefixLen = 0
		  THIS.nSuffixLen = 0
		  THIS.cCurrency = IIF(EMPTY(THIS.cDisplayCurrency), THIS.cValueCurrency, THIS.cDisplayCurrency)
		  IF NOT EMPTY(THIS.cCurrency) OR '$' $ THIS.Format OR '$' $ THIS.Inputmask OR TYPE(THIS.cValueSource) = 'Y'
		    * If any of the currency conditions are met, make sure a $ is in the format string.
		    IF NOT '$' $ THIS.Format
		      THIS.Format = THIS.Format + '$'
		    ENDIF
		
		    IF NOT EMPTY(THIS.cCurrency)
		      * Create or Load reference to currency conversion object.
		      IF ISNULL(THIS.oCurrConvert)
		        THIS.oCurrConvert = CreateGlobalObject('cmCurrencyConversion')
		      ENDIF
		      IF NOT ISNULL(THIS.oCurrConvert)
		        m.oCurrency = THIS.oCurrConvert.LoadCurrency(THIS.cCurrency)
		        IF NOT ISNULL(m.oCurrency)
		          THIS.cSymbol = m.oCurrency.cSymbol
		        ENDIF
		      ENDIF
		    ENDIF
		
		    * Assign default currency symbol if none is specified.
		    IF EMPTY(THIS.cSymbol)
		      THIS.cSymbol = SET('CURRENCY',1)
		    ENDIF
		    IF EMPTY(THIS.cSymbolPosition)
		      THIS.cSymbolPosition = SET('CURRENCY')
		    ENDIF
		    IF UPPER(THIS.cSymbolPosition) = 'LEFT'
		      THIS.nPrefixLen = THIS.nPrefixLen + LEN(THIS.cSymbol)
		    ELSE
		      THIS.nSuffixLen = THIS.nSuffixLen + LEN(THIS.cSymbol)
		    ENDIF
		  ENDIF
		
		  * Calculate display-only prefix and suffix areas of mask for sign indicators.
		  THIS.cNegativeSign = PROPER(LEFT(THIS.cNegativeSign, 5))
		  IF THIS.cNegativeSign $ 'Paren,Left'
		    THIS.nPrefixLen = THIS.nPrefixLen + 1
		  ENDIF
		  IF THIS.cNegativeSign $ 'Paren,Right'
		    THIS.nSuffixLen = THIS.nSuffixLen + 1
		  ENDIF
		  THIS.nSuffixLen = MAX(THIS.nSuffixLen, 1)   && Minimum suffix length of 1 is always required.
		
		  * Original input mask is used only for display formatting.
		  * Create general input mask to allow any character, and add additional positions at end.
		  IF NOT 'X' $ THIS.InputMask
		    THIS.cDisplayMask = CHRTRAN(THIS.InputMask, '$#', '99')
		    IF EMPTY(THIS.cDisplayMask)
		      * No display mask is specified, so create one based on source data length and decimals.
		      THIS.cDisplayMask = THIS.GenDisplayMask()
		    ENDIF
		  ENDIF
		
		  * Adjust display mask to correct number of decimal places for the active currency.
		  IF NOT ISNULL(m.oCurrency)
		    IF '.' $ THIS.cDisplayMask
		      THIS.cDisplayMask = LEFT(THIS.cDisplayMask, RAT('.', THIS.cDisplayMask) - 1)
		    ENDIF
		    IF m.oCurrency.nDecimals > 0
		      THIS.cDisplayMask = THIS.cDisplayMask + '.' + REPLICATE('9', m.oCurrency.nDecimals)
		    ENDIF
		  ENDIF
		  THIS.InputMask = REPL('X', LEN(THIS.cDisplayMask) + THIS.nPrefixLen + THIS.nSuffixLen)
		  
		  * Calculate Number of decimal positions in input mask
		  THIS.nDisplayDP = RAT('.', THIS.cDisplayMask)
		  IF THIS.nDisplayDP > 0
		    THIS.nDecimals = LEN(THIS.cDisplayMask) - THIS.nDisplayDP
		  ELSE
		    THIS.nDecimals = 0
		  ENDIF
		
	ENDPROC

	PROCEDURE sellength_assign
	ENDPROC

	PROCEDURE set
		LPARAMETER cProperty, uValue
		*++
		* Set various control properties. Parameters are property name and value to set.
		*--
		  m.cProperty = LOWER(m.cProperty)
		  DODEFAULT(@m.cProperty, @m.uValue)
		
		  IF INLIST(m.cProperty, 'cvaluesource', 'controlsource', 'inputmask', 'cnegativesign')
		    THIS.Reset()
		    THIS.Refresh()
		  ENDIF
		
	ENDPROC

	PROCEDURE setvalue
		LPARAMETER nValue
		*++
		* Set the current value of the control.
		*--
		  * In case SetValue() is called by user code before control init() completes.
		  THIS.AddInternalProperties()
		
		  IF VARTYPE(m.nValue) $ 'NIYX'  && Integer, Currency, numeric, or NULL
		    RETURN DODEFAULT(m.nValue)
		  ENDIF
		  ERROR 1732   && Wrong data type
		  RETURN .F.
		
	ENDPROC

	PROCEDURE storememory
		*++
		*>>Save current value in system registry for later use.
		*--
		  LOCAL cValue
		  IF THIS.lValueMemory
		    * Convert value to character before saving.
		    IF cmRegSetString((HKEY_CURRENT_USER), (THIS.cMemoryKeyRoot + SYS(1272, THIS)), (STR(THIS.nValue, 16, 4)))
		      RETURN .T.
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE storetranslation
		LPARAMETERS nValue
		  * If display currency and value currency are different, conversion is necessary.
		  IF NOT EMPTY(THIS.cDisplayCurrency) AND NOT EMPTY(THIS.cValueCurrency) ;
		  AND NOT UPPER(THIS.cDisplayCurrency) == UPPER(THIS.cValueCurrency) 
		    IF NOT ISNULL(THIS.oCurrConvert)
		      RETURN THIS.oCurrConvert.Convert(m.nValue, THIS.cDisplayCurrency, THIS.cValueCurrency)
		    ENDIF
		  ENDIF
		  RETURN m.nValue
		
	ENDPROC

	PROCEDURE storevalue
		* Store the numeric control value to the bound value source.
		RETURN DODEFAULT(THIS.nValue)
		
	ENDPROC

	PROCEDURE undochanges
		*++
		*>>Undo changes to the current control, and restore original value.
		*--
		  IF EMPTY(THIS.cValueSource)
		    THIS._SetValue(THIS.uOriginalValue)
		  ELSE
		    THIS.LoadValue()
		  ENDIF
		  THIS.lChanged = .F.
		  THIS.SelStart = 0
		  THIS.KeyPress(6, 0)   && Simulate the 'End' key
		
	ENDPROC

	PROCEDURE _setvalue		&& Internal method to set the control value and redraw the display.
		LPARAMETER nValue, lNegative
		LOCAL ix, ch, cPrefix, cSuffix, cDisplay, cData, lOverflow
		
		  THIS.nValue = m.nValue
		  IF ISNULL(m.nValue)
		    THIS.nValue = 0
		    THIS.lNegative = .F.
		    STORE '' TO THIS.Value, THIS.cDisplayBuffer  && Set value to empty string
		    STORE .NULL. TO THIS.nValue, THIS.Value      && before setting to .null.
		  ELSE
		    THIS.lNegative = IIF(PCOUNT() > 1, m.lNegative, m.nValue < 0)
		    m.cData = STR(ABS(m.nValue), LEN(THIS.Inputmask), THIS.nDecimals)
		
		    * Merge display mask characters into display data.
		    m.lOverflow = '*' $ m.cData OR 'E' $ m.cData
		    IF NOT m.lOverflow
		      THIS.cDisplayBuffer = ''
		      FOR ix = LEN(THIS.cDisplayMask) TO 1 STEP -1
		        IF EMPTY(m.cData)
		          EXIT
		        ELSE
		          m.ch = SUBSTR(THIS.cDisplayMask, m.ix, 1)
		          IF m.ch $ '9.'
		            THIS.cDisplayBuffer = IIF(m.ch = '.', SET('POINT'), RIGHT(m.cData, 1)) + THIS.cDisplayBuffer
		            m.cData = LEFT(m.cData, LEN(m.cData) - 1)
		          ELSE
		            IF m.ch = ','
		              m.ch = SET('SEPARATOR')
		            ENDIF
		            THIS.cDisplayBuffer = m.ch + THIS.cDisplayBuffer
		          ENDIF
		        ENDIF
		      ENDFOR
		      m.lOverflow = NOT EMPTY(m.cData)
		    ENDIF
		
		    IF m.lOverflow
		      STORE REPLICATE('*', LEN(THIS.InputMask)) TO THIS.Value, THIS.cDisplayBuffer
		    ELSE
		      m.cPrefix = ''
		      m.cSuffix = ''
		      IF '$' $ THIS.Format
		        IF UPPER(THIS.cSymbolPosition) = 'LEFT'
		          m.cPrefix = THIS.cSymbol
		        ELSE
		          m.cSuffix = THIS.cSymbol
		        ENDIF
		      ENDIF
		 
		      * Apply correct minus sign display for negative values.
		      IF THIS.lNegative
		        IF THIS.nNegativeColor >= 0
		          THIS.ForeColor = THIS.nNegativeColor
		        ENDIF
		        DO CASE
		          CASE THIS.cNegativeSign = 'Paren'
		            m.cPrefix = '(' + m.cPrefix
		            m.cSuffix = m.cSuffix + ')'
		          CASE THIS.cNegativeSign = 'Left'
		            m.cPrefix = '-' + m.cPrefix
		          CASE THIS.cNegativeSign = 'Right'
		            m.cSuffix = m.cSuffix + '-'
		        ENDCASE
		      ELSE
		        THIS.ForeColor = THIS.nOriginalColor
		      ENDIF
		 
		      THIS.cDisplayBuffer = PADL(m.cPrefix, THIS.nPrefixLen) + THIS.cDisplayBuffer + PADR(m.cSuffix, THIS.nSuffixLen)
		
		      * Blank out the display if value is zero and lBlankWhenZero is set, but only when we are not the active control.
		      IF THIS.lReadLock
		        THIS.Value = ''
		      ELSE
		        IF THIS.lBlankWhenZero AND THIS.nValue = 0 AND NOT BITTEST(THIS.nControlFlags, CTLFLAG_HAS_FOCUS)
		          THIS.Value = PADL('', LEN(THIS.InputMask))
		        ELSE
		          THIS.Value = PADL(THIS.cDisplayBuffer, LEN(THIS.InputMask))
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN NOT m.lOverflow
		
	ENDPROC

ENDDEFINE

DEFINE CLASS txtquickfill AS txttextboxcustom OF "..\custom\ccontrol.vcx" 		&& CodeMine quick-fill text control.
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: showpopup		&& Force Display of dropdown list.
		*p: cblanktext		&& Text displayed when no list record matches the parent key value when cRelationTag is used.
		*p: cfilter		&& Filter expression applied to cListworkarea to restrict the available records.
		*p: clistexpression		&& Expression to evaluate for each list item. Usually a field name in the cListWorkarea cursor.
		*p: clistsuffix		&& Suffix expression appended to cListexpression only for items displayed in the popup.
		*p: clistworkarea		&& Workarea of list item cursor
		*p: crelationexpression		&& Expression (based on fields in cListWorkarea) to evaluate to produce value stored to bound source.
		*p: crowsource		&& Comma separated list of possible values for the control. Leave empty to use cursor specified in cListWorkarea.
		*p: lallowexceptions		&& If set to .T. then user is allowed to enter values that are not in the source table.
		*p: lexactcase		&& Set to .T. if data entered must match list items case exactly.
		*p: npopupkeycode		&& Ascii value of the key used to pop-up the list of available matching entires.
		*p: npopuprows		&& Max number of popup rows to display.
		*p: nspacemode		&& Determines the behaviour of the Space key in quickfill: 0 = Advance one space, 1 = advance to next word break
	*</DefinedPropArrayMethod>

	Alignment = 3
	cblanktext = 		&& Text displayed when no list record matches the parent key value when cRelationTag is used.
	cfilter = 		&& Filter expression applied to cListworkarea to restrict the available records.
	clistexpression = 		&& Expression to evaluate for each list item. Usually a field name in the cListWorkarea cursor.
	clistsuffix = 		&& Suffix expression appended to cListexpression only for items displayed in the popup.
	clistworkarea = 		&& Workarea of list item cursor
	crelationexpression = 		&& Expression (based on fields in cListWorkarea) to evaluate to produce value stored to bound source.
	crowsource = 		&& Comma separated list of possible values for the control. Leave empty to use cursor specified in cListWorkarea.
	lexactcase = .F.		&& Set to .T. if data entered must match list items case exactly.
	Name = "txtquickfill"
	npopupkeycode = (ASC('?'))		&& Ascii value of the key used to pop-up the list of available matching entires.
	npopuprows = 5		&& Max number of popup rows to display.
	nspacemode = 1		&& Determines the behaviour of the Space key in quickfill: 0 = Advance one space, 1 = advance to next word break
	SelectOnEntry = .T.
	
	PROCEDURE Click
		IF THIS.SelLength = 0
		  THIS.SelStart=0
		  THIS.SelLength = LEN(TRIM(THIS.value))
		ENDIF
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE contextmenubuild
		IF NOT THIS.lWritelock
		  THISFORM.ContextMenuBar(CTX_BAR_CTL_QUICKPOP, '%barquickpopup')
		  THISFORM.ContextMenuSeparator(CTX_BAR_CTL_QUICK_SEP)
		ENDIF
		
		RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETERS cOption
		
		IF m.cOption == '%barquickpopup'
		  RETURN THISFORM.cmQuickfillSupport.ShowPopup(THIS, LEFT(THIS.Value, IIF(THIS.SelLength > 0, THIS.SelStart, 0)))
		ENDIF
		
		IF DODEFAULT(@m.cOption)
		  IF m.cOption == '%barrevert'
		    THIS.SelStart = 0
		    THIS.SelLength = LEN(TRIM(THIS.Value))
		  ENDIF
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE GotFocus
		THIS.SelStart=0
		THIS.SelLength = LEN(TRIM(NVL(THIS.value,'')))
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE Init
		  IF NOT PEMSTATUS(THISFORM, 'cmQuickfillSupport', 5)
		    THISFORM.AddNewObject('cmQuickfillSupport', 'cmQuickfillSupport')
		  ENDIF
		
		  THISFORM.cmQuickfillSupport.QuickFillInit(THIS)
		  DODEFAULT()
		
		  * If in a grid, value is not loaded on init. Make sure it is at least set to a character type.
		  * Must only be done after default init() code completes (and native controlSource is cleared)
		  * or VFP access violation errors may result in VFP8 SP1.
		  IF THIS.Parent.BaseClass == 'Column'
		    THIS.Value = ''
		  ENDIF
		
	ENDPROC

	PROCEDURE InteractiveChange
		LOCAL cValue
		
		IF DODEFAULT()
		  * Don't trim explicitly entered trailing spaces.
		  IF THIS.SelStart > LEN(TRIM(THIS.Value))
		    m.cValue = LEFT(THIS.Value, THIS.SelStart)
		  ELSE
		    m.cValue = TRIM(THIS.Value)
		  ENDIF
		
		  * Apply quick fill value if one can be found
		  THISFORM.cmQuickfillSupport.QuickFill(THIS, m.cValue)
		ENDIF
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Process special keys for incremental search text boxes
		*--
		  IF THISFORM.cmQuickfillSupport.ProcessKey(THIS, m.nKeyCode)
		    NODEFAULT
		    RETURN .T.
		  ENDIF
		  RETURN DODEFAULT(m.nKeyCode, m.nShiftAltCtrl)
		
	ENDPROC

	PROCEDURE loadtranslation
		LPARAMETER cValue
		
		  IF THISFORM.cmQuickfillSupport.LoadTranslation(THIS, @m.cValue)
		    RETURN DODEFAULT(m.cValue)   && Default code supports encrypted values.
		  ENDIF
		  RETURN m.cValue
		
	ENDPROC

	PROCEDURE loadvalue
		IF DODEFAULT()
		  * If a value was loaded from a bound data source, remember it as last valid value
		  THIS.cLastValue = THIS.Value
		  THIS.nLastPos = 0
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE Refresh
		  * Initialize the control, if we are called before our Init() method gets to execute.
		  IF NOT PEMSTATUS(THIS, 'nControlFlags', 5)
		    IF NOT PEMSTATUS(THISFORM, 'cmQuickfillSupport', 5)
		      THISFORM.AddNewObject('cmQuickfillSupport', 'cmQuickfillSupport')
		    ENDIF
		    THISFORM.cmQuickfillSupport.QuickFillInit(THIS)
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE setvalue
		LPARAMETERS cNewValue
		
		* Remember the last value set, so it can be restored after an invalid entry
		IF DODEFAULT(@m.cNewValue)
		  THIS.nLastPos = 0
		  THIS.cLastValue = THIS.Value
		  RETURN .T.
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE showpopup		&& Force Display of dropdown list.
		LPARAMETERS cValue
		
		  RETURN THISFORM.cmQuickfillSupport.ShowPopup(THIS, m.cValue)
		
	ENDPROC

	PROCEDURE storetranslation
		LPARAMETERS cValue
		LOCAL nSelect, cListExpr, cListValue
		
		IF NOT EMPTY(THIS.cListWorkarea)
		  m.nSelect = SELECT()
		  SELECT (THIS.cListWorkarea)
		
		  * Make sure the list record that matches displayed expression is current.
		  m.cListExpr = THIS.cListExpression
		  m.cListValue = EVALUATE(m.cListExpr)
		  IF NOT TRIM(m.cListValue) == TRIM(m.cValue)
		    IF THIS.lExactCase
		      LOCATE FOR &cListExpr == PADR(m.cValue, LEN(&cListExpr))
		    ELSE
		      LOCATE FOR UPPER(&cListExpr) == PADR(UPPER(m.cValue), LEN(&cListExpr))
		    ENDIF
		  ENDIF
		
		  * If a different relation expression is specified, evaluate it for result to store.
		  IF NOT EMPTY(THIS.cRelationExpression)
		    m.cValue = EVALUATE(THIS.cRelationExpression)
		  ENDIF
		  SELECT (m.nSelect)
		ENDIF
		RETURN DODEFAULT(m.cValue)
		
	ENDPROC

ENDDEFINE
