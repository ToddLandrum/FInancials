*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmsecman.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cmauthentication AS cmserviceabstract OF "..\common\cmdataa.vcx" 		&& Record Authentication Checksum methods
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: authenticateevent		&& Authenticate an Event Log record.
		*m: authenticaterecord		&& Calculate the checksum value of the encrypted sum of all fields in the current record.
		*p: cfieldexcludelist		&& List of cursor fields to exclude from the checksum.
		*p: cfieldincludelist		&& List of cursor fields to include in the checksum. If empty, all fields may be included.
		*p: ckeycode		&& Authentication key to use.
		*p: cversion
	*</DefinedPropArrayMethod>

	cfieldexcludelist = Checksum		&& List of cursor fields to exclude from the checksum.
	cfieldincludelist = 		&& List of cursor fields to include in the checksum. If empty, all fields may be included.
	ckeycode = 		&& Authentication key to use.
	cversion = 7.0.0
	Name = "cmauthentication"
	
	PROCEDURE authenticateevent		&& Authenticate an Event Log record.
		LPARAMETERS cWorkArea
		*++
		*>>Authenticate an Event Log record.
		*--
		  RETURN THIS.AuthenticateRecord('CodeMine Event Log',, m.cWorkArea)
		
	ENDPROC

	PROCEDURE authenticaterecord		&& Calculate the checksum value of the encrypted sum of all fields in the current record.
		LPARAMETERS cKeyCode, cExcludeList, cWorkArea
		*++
		*>>Calculate the checksum value of the encrypted sum of all fields in the current record.
		*--
		LOCAL ix, cMemo, cValue, nSelect
		
		  m.cMemo = ''
		  m.cValue = ''
		  m.cKeyCode = IIF(EMPTY(m.cKeyCode), THIS.cKeyCode, m.cKeyCode)
		  m.cExcludeFields = ',' + UPPER(IIF(EMPTY(m.cExcludeList), THIS.cFieldExcludeList, m.cExcludeList) + ',')
		
		  m.nSelect = SELECT()
		  IF NOT EMPTY(m.cWorkarea)
		    SELECT (m.cWorkArea)
		  ENDIF
		
		  FOR ix = 1 TO FCOUNT()
		    IF (EMPTY(THIS.cFieldIncludeList) OR ',' + FIELD(m.ix) + ',' $ THIS.cFieldIncludeList) ;
		    AND NOT ',' + FIELD(m.ix) + ',' $ m.cExcludeFields
		      m.cFldType = TYPE(FIELD(m.ix))
		      DO CASE
		        CASE m.cFldTYPE = 'C'
		          m.cValue = m.cValue + TRIM(NVL(EVALUATE(FIELD(m.ix)), ''))
		        CASE m.cFldTYPE = 'M'
		          * Increase speed a bit by keeping long strings separate
		          m.cMemo = m.cMemo + NVL(EVALUATE(FIELD(m.ix)), '')
		        CASE m.cFldTYPE = 'D'
		          m.cValue = m.cValue + DTOC(NVL(EVALUATE(FIELD(m.ix)), {}), 1)
		        CASE m.cFldTYPE = 'T'
		          m.cValue = m.cValue + TTOC(NVL(EVALUATE(FIELD(m.ix)), {}), 1)
		        CASE m.cFldTYPE = 'I'
		          m.cValue = m.cValue + LTRIM(STR(NVL(EVALUATE(FIELD(m.ix)), 0), 12))
		        CASE m.cFldTYPE = 'N'
		          m.cValue = m.cValue + LTRIM(STR(NVL(EVALUATE(FIELD(m.ix)), 0), 16, 5))
		        CASE m.cFldTYPE = 'Y'
		          m.cValue = m.cValue + LTRIM(STR(NVL(EVALUATE(FIELD(m.ix)), 0), 16, 4))
		      ENDCASE
		    ENDIF
		  ENDFOR
		  SELECT (m.nSelect)
		  RETURN VAL(SYS(2007, cmEncrypt(m.cValue + m.cMemo, 'CodeMine Authentication' + m.cKeyCode)))
		
	ENDPROC

	PROCEDURE init
		  THIS.cFieldIncludeList = UPPER(THIS.cFieldIncludeList)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmeventlogcursor AS cmcursor OF "..\common\cmdata.vcx" 		&& PRGTOVCX.CONVERT converted from c:\codemine\common\cmsecman.prg, 03/11/2004 09:25:56 PM
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterinit		&& Set the databse and connection to use the same as the current shared appreg table.
		*m: create		&& Create an empty event log table if none exists.
		*m: createremotetable		&& Create a remote SQL Server event log table on the specified connection.
		*m: createremoteview		&& Create a remote view to access the server event log table.
		*m: createvfptable		&& Create a native VFP event log table in the current DBC.
		*p: csource
		*p: cworkarea
		*p: lautocreate
		*p: lnodataonload
		*p: lrecyclerecords
		*p: luseruntimepath
	*</DefinedPropArrayMethod>

	csource = EventLog
	cworkarea = cmEventLog
	lautocreate = .T.
	lnodataonload = .T.
	lrecyclerecords = .T.
	luseruntimepath = .F.
	Name = "cmeventlogcursor"
	
	PROCEDURE afterinit		&& Set the databse and connection to use the same as the current shared appreg table.
		*++
		*>>Set the databse and connection to use the same as the current shared appreg table.
		*--
		LOCAL oShared, oRegistry
		
		  m.oRegistry = FindGlobalObject('cmRegistry')
		  IF VARTYPE(m.oRegistry) = 'O'
		    m.oShared = m.oRegistry.GetRootCursor('%Shared')
		    IF VARTYPE(m.oShared) = 'O'
		      * Event log must always use the same DBC & connection name/string as the shared appreg.
		      THIS.cDatabase = m.oShared.cDatabase
		      THIS.cConnection = m.oShared.cConnection     && Empty if not a remote table.
		
		      * We need to set type so cursor can load correct access method even if source doesn't
		      * exist yet - so we can implement correct create-on-demand behavior.
		      SET DATABASE TO (THIS.cDatabase)
		      DO CASE
		        * If table or view already exists, that is the type we use
		        CASE INDBC(THIS.cSource, 'TABLE')
		          THIS.cType = 'Table'
		        CASE INDBC(THIS.cSource, 'VIEW')
		          THIS.cType = 'SQLPT'
		        OTHERWISE
		          * If nothing exists currently, determine type based on presence of a connection to shared appreg.
		          THIS.cType = IIF(EMPTY(THIS.cConnection), 'Table', 'SQLPT')
		      ENDCASE
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE create		&& Create an empty event log table if none exists.
		*++
		*>>Create an empty event log table if none exists.
		*--
		LOCAL lStatus
		
		  * Drop any existing event log table or view before creating a new one.
		  IF INDBC(THIS.cSource, 'TABLE')
		    DROP TABLE (THIS.cSource) RECYCLE
		  ENDIF
		  IF INDBC(THIS.cSource, 'VIEW')
		    DROP VIEW (THIS.cSource)
		  ENDIF
		
		  * Create a remote table and view, or a native VFP table, based on cursor type setting.
		  IF PROPER(THIS.cType) = 'Table'
		    m.lStatus = THIS.CreateVfpTable()
		  ELSE
		    m.lStatus = THIS.CreateRemoteTable() AND THIS.CreateRemoteView()
		  ENDIF
		
		  IF m.lStatus
		    THIS.oMessage.Display('%msgEventLogCreated')
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE createremotetable		&& Create a remote SQL Server event log table on the specified connection.
		*++
		*>>Create a remote SQL Server event log table on the specified connection.
		*--
		LOCAL cSql, oConn
		
		  * The connection used to create the remote table may be a named DBC 
		  * connection, or a dynamic connection string. The remote table may need to
		  * be created the first time an EXE is run on a new database, or after the table
		  * was manually deleted.
		  m.oConn = CREATEOBJECT('cmConnectionVFP')
		  IF m.oConn.Open(THIS.cConnection)
		    * Create the Server table
		    m.cSql = 'CREATE TABLE dbo.EventLog (' ;
		           + '[SerialNo]    [int]  NOT NULL, ' ;
		           + '[EventName]   [char] (15), ' ;
		           + '[EventType]   [char] (15), ' ;
		           + '[Username]    [char] (15), ' ;
		           + '[EventTime]   [Datetime], ' ;
		           + '[EventWhere]  [char] (25), ' ;
		           + '[Comment]     [varchar] (2500), ' ;
		           + '[Checksum]    [int] )'
		
		    * If table already existed, we will get an error return. We display the error but still return 
		    * success. We don't Drop the table first, because that might result in accidental loss of data.
		    IF m.oConn.Execute(m.cSql)
		      m.oConn.Execute('CREATE INDEX [EventType] ON [EventLog]([EventType])')
		      m.oConn.Execute('CREATE INDEX [EventTime] ON [EventLog]([EventTime])')
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE createremoteview		&& Create a remote view to access the server event log table.
		*++
		*>>Create a remote view to access the server event log table.
		*--
		  * The connection used to create the remote view must be a named DBC connection.
		  * The view can only be created at development time, when we dont need to worry about
		  * app.GetConnection() translating the connection name into a dynamic connection string.
		  CREATE SQL VIEW (THIS.cSource) REMOTE CONNECTION (THIS.cConnection) AS ;
		       SELECT * FROM dbo.EventLog ORDER BY EventTime DESC
		
		  * Set properties if we succeeded in creating the view.
		  IF INDBC(THIS.cSource, 'VIEW')
		    DBSETPROP(THIS.cSource + '.SerialNo',   'Field', 'KeyField',  .T.)
		    DBSETPROP(THIS.cSource + '.SerialNo',   'Field', 'Updatable', .T.)
		    DBSETPROP(THIS.cSource + '.EventName',  'Field', 'Updatable', .T.)
		    DBSETPROP(THIS.cSource + '.EventType',  'Field', 'Updatable', .T.)
		    DBSETPROP(THIS.cSource + '.Username',   'Field', 'Updatable', .T.)
		    DBSETPROP(THIS.cSource + '.EventTime',  'Field', 'Updatable', .T.)
		    DBSETPROP(THIS.cSource + '.EventWhere', 'Field', 'Updatable', .T.)
		    DBSETPROP(THIS.cSource + '.Comment',    'Field', 'Updatable', .T.)
		    DBSETPROP(THIS.cSource + '.Checksum',   'Field', 'Updatable', .T.)
		
		    DBSETPROP(THIS.cSource, 'View',    'MaxRecords', -1)
		    DBSETPROP(THIS.cSource, 'View',    'UpdateType',  1)
		    DBSETPROP(THIS.cSource, 'View',    'WhereType',   1)
		    DBSETPROP(THIS.cSource, 'View',    'SendUpdates', .T.)
		    DBSETPROP(THIS.cSource, 'View',    'FetchAsNeeded', .T.)
		    DBSETPROP(THIS.cSource, 'View',    'FetchMemo', .T.)
		    DBSETPROP(THIS.cSource, 'View',    'FetchSize', 100)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE createvfptable		&& Create a native VFP event log table in the current DBC.
		*++
		*>>Create a native VFP event log table in the current DBC.
		*--
		  CREATE TABLE (FULLPATH(THIS.cSource + '.dbf', DBC())) NAME (THIS.cSource) ( ;
		    EventName    C(15), ;
		    EventType    C(15), ;
		    SerialNo     I, ;
		    Username     C(15), ;
		    EventTime    T, ;
		    EventWhere   C(25), ;
		    Comment      M, ;
		    Checksum     I )
		
		  INDEX ON Serialno TAG SerialNo
		  INDEX ON EventTime TAG Time
		  INDEX ON EventType TAG EventType
		  INDEX ON DELETED() TAG Deleted
		
		  * Close the newly created table here so it can be opened later as a shared table.
		  USE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmgroupeditor AS cmbinarykeyeditorabstract OF "cmregkey.vcx" 		&& External Binary key value editor class for Group keys
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: defaultkeyproperties		&& Establish default key properties for user group keys.
		*m: editvalue		&& Call editor form to edit key value.
		*m: validatekeyproperties		&& Validate key properties.
		*p: crequiredcategory
		*p: ladministrator
		*p: lnoreplicate
	*</DefinedPropArrayMethod>

	crequiredcategory = Security.Groups
	ladministrator = .T.
	lnoreplicate = .T.
	Name = "cmgroupeditor"
	
	PROCEDURE defaultkeyproperties		&& Establish default key properties for user group keys.
		LPARAMETERS oKey
		*++
		*>>Establish default key properties for user group keys.
		*--
		  * Default to administratorr only access
		  m.oKey.nAccess = KEY_ACCESS_ADMIN
		
	ENDPROC

	PROCEDURE editvalue		&& Call editor form to edit key value.
		LPARAMETERS oKey
		*++
		*>>Call editor form to edit key value.
		* Called from regedit only. Returns .T. if value changed.
		*--
		LOCAL oDialog
		
		  * The key value contains packed user properties. Pass it along with the 
		  * key name and description to the editor form.
		  m.oDialog = CreateLocalized(THIS.oSecurity.cGroupEditorClass, ;
		                 m.oKey.cValue, m.oKey.cLocName, m.oKey.cDescription, m.oKey.cName)
		  m.oDialog.Show()
		
		  * If changes were made, copy modified values back to registry key properties.
		  IF VARTYPE(m.oDialog) = 'O' AND m.oDialog.uValue
		    m.oKey.cValue = m.oDialog.cGroupKeyValue
		    m.oKey.cDescription = m.oDialog.cDescription
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE validatekeyproperties		&& Validate key properties.
		LPARAMETERS oKey
		*++
		*>>Validate key properties. 
		* Called from keyedit only, to validate a key being created or edited. Return .T. if ok.
		*--
		LOCAL cError
		
		  WITH m.oKey
		    DO CASE
		      CASE NOT EMPTY(.oOldVal.KeyName) ;
		           AND NOT UPPER(TRIM(.cName)) + '.' == UPPER(TRIM(SUBSTR(.oOldVal.KeyName, RAT('.', .oOldVal.KeyName, 2) + 1)))
		        m.cError = 'Group keys cannot be renamed'
		    ENDCASE
		
		    IF NOT EMPTY(m.cError)
		      RETURN THIS.oMessage.Warning(m.cError)
		    ENDIF
		  ENDWITH
		  RETURN DODEFAULT(m.oKey)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmgroupvalue AS cmbinarykeyvalueabstract OF "cmregkey.vcx" 		&& Pack and unpack userGroup values.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: gather		&& Gather all the type specific value parameters into one string field.
		*m: scatter		&& Break the compound value string into its individual components.
		*p: ckeystring
		*p: cname
		*p: cprivileges
		*p: cversion
		*p: lempty
	*</DefinedPropArrayMethod>

	PROTECTED ckeystring
	ckeystring = Soft Classics CodeMine Group Properties
	cname = Group
	cprivileges = 
	cversion = 6.0.0
	lempty = .T.
	Name = "cmgroupvalue"
	
	PROCEDURE gather		&& Gather all the type specific value parameters into one string field.
		LPARAMETERS cName
		*++
		*>>Gather all the type specific value parameters into one string field.
		* cName parameter is obsolete. Preserved for backward compatibility only.
		*--
		  IF PCOUNT() > 0
		    THIS.cName = m.cName
		  ENDIF
		  RETURN cmEncrypt('CodeMine Group' + CR_LF ;
		         + IIF(LEN(THIS.cPrivileges) > 1020, '~' + STR(LEN(THIS.cPrivileges),4), '') ;
		         + THIS.cPrivileges + CR_LF, UPPER(ALLTRIM(THIS.cName)) + THIS.cKeyString)
		
	ENDPROC

	PROCEDURE scatter		&& Break the compound value string into its individual components.
		LPARAMETERS cCodedValue, cName
		*++
		*>>Break the compound value string into its individual components.
		* Returns False if user data is corrupted.
		*--
		LOCAL cValue, nMemoWidth
		  _MLINE = 0
		  THIS.cName = m.cName
		  IF NOT EMPTY(m.cCodedValue)
		    m.cValue = cmEncrypt(m.cCodedValue, UPPER(TRIM(THIS.cName)) + THIS.cKeyString)
		    IF MLINE(m.cValue, 1, _MLINE) == 'CodeMine Group'
		      m.nMemoWidth = SET('MEMOWIDTH')
		      SET MEMOWIDTH TO 1024
		
		      * If privilege string is too long for one mline, then use SUBSTR() to pick it out
		      IF SUBSTR(m.cValue, _MLINE + 2, 1) = '~'
		        LOCAL nLen
		        m.nLen = VAL(SUBSTR(m.cValue, _MLINE + 3, 4))
		        THIS.cPrivileges = SUBSTR(m.cValue, _MLINE + 7, m.nLen)
		        _MLINE = _MLINE + m.nLen + 7
		      ELSE
		        THIS.cPrivileges = MLINE(m.cValue, 1, _MLINE)
		      ENDIF
		
		      THIS.lEmpty = .F.
		      SET MEMOWIDTH TO (m.nMemoWidth)
		      RETURN .T.
		    ENDIF
		  ENDIF
		
		  THIS.lEmpty = .T.
		  THIS.cPrivileges = ''
		  RETURN EMPTY(m.cCodedValue)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmpasswordeditor AS cmbinarykeyeditorabstract OF "cmregkey.vcx" 		&& External Binary key value editor class for Password keys
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: editvalue		&& Call editor form to edit key value.
		*p: ladministrator
		*p: lnoreplicate
	*</DefinedPropArrayMethod>

	ladministrator = .T.
	lnoreplicate = .T.
	Name = "cmpasswordeditor"
	
	PROCEDURE editvalue		&& Call editor form to edit key value.
		LPARAMETERS oKey
		*++
		*>>Call editor form to edit key value.
		* Called from regedit only. Returns .T. if value changed.
		*--
		LOCAL oDialog, oPassword
		
		  m.oDialog = CreateLocalized(THIS.oSecurity.cSetPasswordDialogClass)
		  IF NOT ISNULL(m.oDialog)
		    m.oDialog.Show()
		    IF VARTYPE(m.oDialog) = 'O' AND m.oDialog.uValue
		      m.oPassword = CreateNewObject('cmPasswordValue')
		      m.oPassword.Scatter('', m.oKey.cName)
		      m.oPassword.cPassword = THIS.oSecurity.EncryptPassword(m.oDialog.cPassword)
		      m.oKey.cValue = m.oPassword.Gather()
		      RETURN .T.
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmpasswordvalue AS cmbinarykeyvalueabstract OF "cmregkey.vcx" 		&& Pack and unpack password values
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: gather		&& Gather all the type specific value parameters into one string field.
		*m: scatter		&& Break the compound value string into its individual components.
		*p: ckeystring
		*p: cname
		*p: cpassword
		*p: cversion
		*p: lvalid
	*</DefinedPropArrayMethod>

	PROTECTED ckeystring
	ckeystring = Soft Classics CodeMine Password Properties
	cname = Password
	cpassword = 
	cversion = 6.0.0
	lvalid = .F.
	Name = "cmpasswordvalue"
	
	PROCEDURE gather		&& Gather all the type specific value parameters into one string field.
		*++
		*>>Gather all the type specific value parameters into one string field.
		*--
		  RETURN cmEncrypt('CodeMine Password' + CR_LF + THIS.cPassword, UPPER(TRIM(THIS.cName)) + THIS.cKeyString)
		
	ENDPROC

	PROCEDURE scatter		&& Break the compound value string into its individual components.
		LPARAMETERS cCodedValue, cName
		*++
		*>>Break the compound value string into its individual components.
		* Returns False if user data is corrupted.
		*--
		LOCAL cValue
		  _MLINE = 0
		  THIS.cName = m.cName
		  THIS.lValid = .F.
		  THIS.cPassword = ''
		  IF NOT EMPTY(m.cCodedValue)
		    m.cValue = cmEncrypt(m.cCodedValue, UPPER(TRIM(THIS.cName)) + THIS.cKeyString)
		    IF MLINE(m.cValue, 1, _MLINE) == 'CodeMine Password'
		      THIS.cPassword = MLINE(m.cValue, 1, _MLINE)
		      THIS.lValid = .T.  && Password has not been tampered with
		    ENDIF
		  ENDIF
		  RETURN THIS.lValid OR EMPTY(m.cCodedValue)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmsecurity AS cmserviceabstract OF "cmdataa.vcx" 		&& CodeMine application Security Manager
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterlogon		&& Custom developer code executed just after a new user is logged on.
		*m: autologondialog		&& Use current network login username. No login dialog needed if it is a valid app username.
		*m: beforelogon		&& Custom developer code executed just before a user is allowed to interactively log on. The oUser property contains ref to the user object attempting logon.
		*m: closeeventlog		&& Close the Event log table.
		*m: enabledebugmode		&& Enable Debug mode for the current user.
		*m: enabledevelopermode		&& Enable Developer mode for the current user.
		*m: encryptpassword		&& Encrypt password string
		*m: externallogon		&& Find or create an external user key, and assign a replication ID to it.
		*m: getnetworkusername		&& Return the current Windows Networking username, if any.
		*m: getuserproperty		&& Return Information about the current user.
		*m: hasprivilege		&& Return true if the current user has any of the specified privileges.
		*m: iscurrentpassword		&& Determine if the specified password matches the current logged on user password.
		*m: isloggedon		&& Return .T. if a user is currently logged on.
		*m: ismemberof		&& Return true if the current user is a member of any of the specified groups.
		*m: logoff		&& Log the current user off, and clear all privileges.
		*m: logon		&& Log on a new user. Returns .T. if the supplied username and password is correct
		*m: logondialog		&& Call the login dialog to validate username/password combo.
		*m: openeventlog		&& Open the Event log table. Create a new one if none found.
		*m: ouser_access
		*m: recordevent		&& Record an event in the event log.
		*m: registryupdate		&& Called on initialization and whenever the app registry database is updated.
		*m: setpassword		&& Set the password for the current logged on user.
		*m: setpassworddialog		&& Call the SetPassword dialog to change password for the current logged on user.
		*m: setprivilege		&& Set or remove a privilege for the current logged on user.
		*m: validpassword		&& Determine if the specified password matches the encrypted password string.
		*m: validpassworddialog		&& Get password via dialog, and determine if it matches the encrypted password string.
		*m: validpasswordkey		&& Compare the specified password text against the value of the specified password key.
		*m: validpasswordkeydialog		&& Get password via dialog, and determine if it matches the specified password key.
		*m: _grantaccess		&& Internal method to Accept the specified user as the current logged on user, load privileges, and update last-logged-on time.
		*m: _protectprivileges		&& Make sure that all privileges (except Developer) are set to Aministrator access or lower.
		*p: cauthenticationclass		&& Name of authentication class used for event log authentication.
		*p: cgetpassworddialogclass		&& Form class for accepting and returning a password.
		*p: cgroupeditorclass		&& Form class for editing privilege groups
		*p: clogondialogclass		&& Form class for the main logon dialog.
		*p: csetlogonpassworddialogclass		&& Form class for setting a new user logon password.
		*p: csetpassworddialogclass		&& Form class for entering password key values.
		*p: cusereditorclass		&& Form class for editing user account information
		*p: cversion		&& Internal CodeMine version number of this class.
		*p: ldeveloperhasall		&& If set to .T., the HasPrivilege() will always return .T. for any privilege if the user has Developer privilege enabled.
		*p: lexactcasepasswords		&& If true, passwords must match case exactly as typed. If you change this, you must re-set all passwords. Passwords stored with one setting will never match passwords entered with a different setting.
		*p: llogoffmessage		&& Set to .T. to display an informational message when a user logs off.
		*p: ouser		&& Runtime reference to a user value object for the current logged-on user.
	*</DefinedPropArrayMethod>

	cauthenticationclass = cmAuthentication		&& Name of authentication class used for event log authentication.
	cgetpassworddialogclass = cmSecure.frmGetPassword		&& Form class for accepting and returning a password.
	cgroupeditorclass = cmSecure.frmGroupEditor		&& Form class for editing privilege groups
	clogondialogclass = cmSecure.frmLogon		&& Form class for the main logon dialog.
	csetlogonpassworddialogclass = cmSecure.frmSetLogonPassword		&& Form class for setting a new user logon password.
	csetpassworddialogclass = cmSecure.frmSetPassword		&& Form class for entering password key values.
	cusereditorclass = cmSecure.frmUserEditor		&& Form class for editing user account information
	cversion = 7.1.0		&& Internal CodeMine version number of this class.
	ldeveloperhasall = .F.		&& If set to .T., the HasPrivilege() will always return .T. for any privilege if the user has Developer privilege enabled.
	lexactcasepasswords = .F.		&& If true, passwords must match case exactly as typed. If you change this, you must re-set all passwords. Passwords stored with one setting will never match passwords entered with a different setting.
	llogoffmessage = .T.		&& Set to .T. to display an informational message when a user logs off.
	Name = "cmsecurity"
	ouser = .NULL.		&& Runtime reference to a user value object for the current logged-on user.
	
	PROCEDURE afterlogon		&& Custom developer code executed just after a new user is logged on.
		*++
		*>>Custom developer code executed just after a new user is logged on.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE autologondialog		&& Use current network login username. No login dialog needed if it is a valid app username.
		LPARAMETERS cDefaultUsername, lRequirePassword
		*++
		*>>Use current network login username. No login dialog needed if it is a valid app username.
		*--
		LOCAL cUsername
		
		  m.cUsername = THIS.GetNetworkUsername()
		  IF NOT EMPTY(m.cUserName)
		    m.cUserValue = THIS.oRegistry.GetGlobalKeyValue('Security.Users.' + m.cUsername, 'Username', '')
		    IF NOT EMPTY(m.cUserValue)
		      THIS.oUser.Scatter(m.cUserValue, m.cUsername)
		      IF NOT THIS.oUser.lDisabled
		        IF NOT THIS.oUser.lAutoLogonPassword AND NOT m.lRequirePassword
		          IF THIS._GrantAccess(m.cUsername)
		            RETURN .T.
		          ENDIF
		        ENDIF
		
		        * Network username is valid, but an additional password is required.
		        m.cDefaultUsername = m.cUsername
		      ENDIF
		    ENDIF
		  ENDIF
		
		  RETURN THIS.LogOnDialog(m.cDefaultUsername)
		
	ENDPROC

	PROCEDURE beforelogon		&& Custom developer code executed just before a user is allowed to interactively log on. The oUser property contains ref to the user object attempting logon.
		*++
		*>>Custom developer code executed just before a user is allowed to interactively log on. The oUser property contains ref to the user object attempting logon.
		*--
		  * Return True to allow logon to proceed.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE closeeventlog		&& Close the Event log table.
		*++
		*>>Close the Event log table.
		*--
		  IF NOT ISNULL(THIS.oEventLog)
		    RETURN THIS.oEventLog.Close()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE enabledebugmode		&& Enable Debug mode for the current user.
		*++
		*>>Enable Debug mode for the current user.
		* Allows developers a way to perform
		* debuging functions without giving end users direct access to Debug privileges.
		*--
		  IF NOT THIS.HasPrivilege('Debug')
		    IF NOT THIS.ValidPasswordKeyDialog('Security.Debug Password', ;
		                                      THIS.oMessage.TranslateString('%txtDebugMode'))
		      RETURN .F.
		    ENDIF
		
		    * Password (if any) has been validated, apply the desired privileges.
		    THIS.SetPrivilege('Debug', .T.)
		    THIS.RecordEvent(EVENT_SEC_DEBUGMODE, EVENT_TYPE_SECURITY)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE enabledevelopermode		&& Enable Developer mode for the current user.
		*++
		*>>Enable Developer mode for the current user.
		* Allows developers a way to perform
		* maintenance functions without giving end users direct access to Developer privileges.
		* Also disables key replication, so all key updates affect the global default value.
		*--
		  IF NOT THIS.HasPrivilege('Developer')
		    IF NOT THIS.ValidPasswordKeyDialog('Security.Developer Password', ;
		                                     THIS.oMessage.TranslateString('%txtDeveloperMode'))
		      RETURN .F.
		    ENDIF
		
		    * Password (if any) has been validated, apply the desired privileges.
		    THIS.SetPrivilege('Developer', .T.)
		    THIS.RecordEvent(EVENT_SEC_DEVMODE, EVENT_TYPE_SECURITY)
		  ENDIF
		
		  * In developer mode, replication is disabled and all keys reference default values.
		  THIS.cReplicationID = ''
		  RETURN .T.
		
	ENDPROC

	PROCEDURE encryptpassword		&& Encrypt password string
		LPARAMETERS cPassword
		*++
		*>>Encrypt password string
		*--
		LOCAL cEncrypted
		  m.cEncrypted = ''
		  IF NOT EMPTY(m.cPassword)
		    IF NOT THIS.lExactCasePasswords
		      m.cPassword = UPPER(m.cPassword)
		    ENDIF
		
		    * Combine two checksum values to create result string.
		    m.cEncrypted = SYS(2007, m.cPassword + UPPER(m.cPassword) + LOWER(m.cPassword))
		    m.cEncrypted = m.cEncrypted + SYS(2007, m.cPassword + cmEncrypt(m.cPassword, m.cEncrypted))
		  ENDIF
		  RETURN m.cEncrypted
		
	ENDPROC

	PROCEDURE externallogon		&& Find or create an external user key, and assign a replication ID to it.
		LPARAMETERS cUsername
		*++
		*>>Find or create an external user key, and assign a replication ID to it.
		*--
		LOCAL cUserValue
		
		  IF NOT EMPTY(m.cUserName)
		    THIS.oUser = CreateNewObject('cmUsernameValue')
		    m.cUserValue = THIS.oRegistry.GetGlobalKeyValue('Security.Users.' + m.cUsername, 'Username', '')
		    THIS.oUser.Scatter(m.cUserValue, m.cUsername)
		
		    * If there is no user record for this user yet. Create one.
		    IF THIS.oUser.lEmpty
		      * Assign a replication ID to this new user.
		      m.cUserValue = THIS.oUser.Gather(m.cUsername)
		      THIS.oRegistry.SetKeyValueEx('Security.Users.' + m.cUsername,,,'Username', m.cUserValue, 'User account added by External Logon')
		    ENDIF
		
		    RETURN THIS._GrantAccess(m.cUsername)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getnetworkusername		&& Return the current Windows Networking username, if any.
		LPARAMETERS cDefaultUsername
		*++
		*>>Return the current Windows Networking username, if any.
		*--
		  RETURN cmGetUserName(THIS.oRegistry.Get('DBCpath'))
		
	ENDPROC

	PROCEDURE getuserproperty		&& Return Information about the current user.
		LPARAMETERS cItem
		*++
		*>>Return Information about the current user.
		* Security properties are protected, so this method provides read-only access to them.
		*--
		  m.cItem = UPPER(LEFT(m.cItem, 4))
		  DO CASE
		    CASE m.cItem = 'USER'
		      RETURN PROPER(THIS.cUsername)
		    CASE m.cItem = 'FULL'
		      RETURN THIS.cFullName
		    CASE m.cItem = 'REPL'    && User key replication ID
		      RETURN THIS.cReplicationID
		    CASE m.cItem = 'LOCK'    && Password locked.
		      RETURN THIS.lPasswordLocked
		    CASE m.cItem = 'REQU'    && Password required flag
		      RETURN THIS.lPasswordRequired
		    CASE m.cItem = 'CHAN'    && Password must be changed flag
		      RETURN THIS.lPasswordMustChange
		    CASE m.cItem = 'LENG'    && Minimum Password length
		      RETURN THIS.nMinPasswordLength
		    CASE m.cItem = 'GROU'
		      RETURN THIS.cGroups
		    CASE m.cItem = 'PRIV'
		      RETURN THIS.cPrivileges
		    CASE m.cItem = 'TIME'
		      RETURN THIS.tLogonTime
		    CASE m.cItem = 'LAST'
		      RETURN THIS.tLastLogonTime
		  ENDCASE
		  ERROR 'GetUserProperty: Invalid parameter'
		
	ENDPROC

	PROCEDURE hasprivilege		&& Return true if the current user has any of the specified privileges.
		LPARAMETERS cPrivileges, cTestValues
		*++
		*>>Return true if the current user has any of the specified privileges.
		*--
		LOCAL cPriv
		
		  * If an explicit set of test privileges was specified, use them, otherwise test
		  * against the privileges of the current logged on user.
		  m.cTestValues = ',' + UPPER(IIF(VARTYPE(m.cTestValues) = 'C', m.cTestValues, THIS.cPrivileges)) + ','
		
		  IF THIS.lDeveloperHasAll AND ',DEVELOPER,' $ ',' + UPPER(THIS.cPrivileges) + ','
		    RETURN .T.
		  ENDIF
		  
		  IF UPPER(m.goapp.cUser) = 'ADMIN'
		     RETURN .t.
		  ENDIF 
		  
		  DO WHILE NOT EMPTY(m.cPrivileges)
		    m.cPriv = GetToken(@m.cPrivileges, ',')
		    IF ',' + UPPER(TRIM(m.cPriv)) + ',' $ ',' + UPPER(THIS.cPrivileges) + ','
		      RETURN .T.
		    ENDIF
		  ENDDO
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Init
		*++
		* CodeMine Security classes.
		*
		* Copyright 1996-2001 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('oRegistry', FindGlobalObject('cmRegistry', '7.0', .T.))
		  THIS.AddProperty('oMessage', FindGlobalObject('cmMessage', '7.0', .T.))
		  THIS.AddProperty('oStateManager', FindGlobalObject('cmStateManager'))
		  THIS.AddProperty('oEventLog', .NULL.)
		
		  * Properties for controling Event log
		  THIS.AddProperty('lEventLogEnabled', .NULL.)    && Event log enabled
		  THIS.AddProperty('dCheckEventRecycleDate', {})  && Date last checked for recycled records.
		  THIS.AddProperty('nEventHistoryLength', 10)     && Days before event log records are reused.
		  THIS.AddProperty('cEventFilterList', '')        && List of event types to filter.
		
		  * Internal properties describing the current logged-on user.
		  THIS.AddProperty('nSysPrivState', 0)            && State table index for system privilege state.
		  THIS.AddProperty('cReplicationID', '')
		  THIS.AddProperty('cUsername', '')
		  THIS.AddProperty('cPassword', '')
		  THIS.AddProperty('cFullName', '')
		  THIS.AddProperty('cPrivileges', '')
		  THIS.AddProperty('cGroups', '')
		  THIS.AddProperty('lPasswordLocked', .F.)
		  THIS.AddProperty('lPasswordMustChange', .F.)
		  THIS.AddProperty('lPasswordRequired', .F.)
		  THIS.AddProperty('nMinPasswordLength', 0)
		  THIS.AddProperty('tLogonTime', {//::})
		  THIS.AddProperty('tLastLogonTime', {//::})
		
		  * Create a local instance of the authentication object for our own use.
		  THIS.AddNewObject('cmAuthentication', THIS.cAuthenticationClass)
		
		  * If we are unable to access the shared appreg tables, security object cannot run.
		  IF ISNULL(THIS.oRegistry.GetRootCursor('%Shared'))
		    RETURN .F.
		  ENDIF
		
		  * Create the system privilege state if the state manager is present (which it should always be).
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.Subscribe('Registry Update Shared', THIS)
		    THIS.nSysPrivState = THIS.oStateManager.DefineState('System Privilege')
		  ENDIF
		
		  * Check privilege key protections, and upgrade to 7.0 settings if necessary
		  THIS._ProtectPrivileges()
		
	ENDPROC

	PROCEDURE iscurrentpassword		&& Determine if the specified password matches the current logged on user password.
		LPARAMETERS cPassword
		*++
		*>>Determine if the specified password matches the current logged on user password.
		*--
		LOCAL cUser
		  IF THIS.IsLoggedOn()
		    m.cUser = THIS.oRegistry.GetGlobalKeyValue( ;
		                        'Security.Users.' + THIS.cUsername, 'Username', '')
		    IF NOT EMPTY(m.cUser)
		      THIS.oUser.Scatter(m.cUser, THIS.cUsername)
		      IF THIS.lExactCasePasswords
		        RETURN THIS.EncryptPassword(ALLTRIM(m.cPassword)) == THIS.oUser.cPassword
		      ELSE
		        RETURN THIS.EncryptPassword(UPPER(ALLTRIM(m.cPassword))) == THIS.oUser.cPassword
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isloggedon		&& Return .T. if a user is currently logged on.
		*++
		*>>Return .T. if a user is currently logged on.
		*--
		  RETURN NOT EMPTY(THIS.cUsername)
		
	ENDPROC

	PROCEDURE ismemberof		&& Return true if the current user is a member of any of the specified groups.
		LPARAMETERS cGroups
		*++
		*>>Return true if the current user is a member of any of the specified groups.
		*--
		LOCAL cGroup
		  DO WHILE NOT EMPTY(m.cGroups)
		    m.cGroup = GetToken(@m.cGroups, ',')
		    IF ',' + UPPER(TRIM(m.cGroup)) + ',' $ ',' + UPPER(THIS.cGroups) + ','
		      RETURN .T.
		    ENDIF
		  ENDDO
		  RETURN .F.
		
	ENDPROC

	PROCEDURE logoff		&& Log the current user off, and clear all privileges.
		*++
		*>>Log the current user off, and clear all privileges.
		*--
		LOCAL cUsername
		  IF THIS.IsLoggedOn()
		    m.cUsername = THIS.cUsername
		    THIS.RecordEvent(EVENT_SEC_LOGOFF, EVENT_TYPE_SECURITY)
		    THIS.cUsername = ''
		    THIS.cPassword = ''
		    THIS.cFullName = ''
		    THIS.cPrivileges = ''
		    THIS.cGroups = ''
		    THIS.cReplicationID = ''
		
		    * If the global state manager exists, update the privilege state so any objects that 
		    * depend on security privileges will automatically be refreshed.
		    IF THIS.nSysPrivState > 0
		      THIS.oStateManager.Broadcast(THIS.nSysPrivState)
		    ENDIF
		    IF THIS.lLogoffMessage
		      WAIT WINDOW NOWAIT THIS.oMessage.Format(THIS.oMessage.Translate('%MsgLoggedOff'), m.cUsername)
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE logon		&& Log on a new user. Returns .T. if the supplied username and password is correct
		LPARAMETERS cUsername, cPassword
		*++
		*>>Log on a new user. Returns .T. if the supplied username and password is correct
		* and the user was logged on successfuly. Returns .F. otherwise. Caller is 
		* responsible for displaying an error message on failure.
		*--
		LOCAL cUserProperties
		
		  * Log off any current user first.
		  IF THIS.IsLoggedOn()
		    THIS.LogOff()
		  ENDIF
		
		  m.cUsername = ALLTRIM(m.cUsername)
		  m.cUserProperties = THIS.oRegistry.GetGlobalKeyValue('Security.Users.' + m.cUsername, 'Username', '')
		
		  IF NOT EMPTY(m.cUserProperties)
		    THIS.oUser.Scatter(m.cUserProperties, m.cUsername)
		
		    * Check for valid password, and be sure user account is enabled.
		    IF THIS.oUser.lDisabled OR NOT THIS.ValidPassword(THIS.oUser.cPassword, m.cPassword)
		      THIS.oMessage.SetLastMessage('%MsgBadLogon')
		      RETURN .F.
		    ENDIF
		
		    THIS.cPassword = m.cPassword
		    IF THIS.oUser.nPasswordLife > 0
		      THIS.oUser.lPasswordMustChange = THIS.oUser.lPasswordMustChange ;
		                                  OR DATE() - TTOD(THIS.oUser.tLastPasswordChange) >= THIS.oUser.nPasswordLife
		    ENDIF
		
		    * Password expiration is only in effect if a password is required.
		    IF THIS.oUser.lPasswordMustChange AND THIS.oUser.lPasswordRequired
		      IF THIS.oUser.nLoginsLeft = 0 AND THIS.oUser.lPasswordLocked
		        * Account is expired, and password is locked, so we fail.
		        THIS.oMessage.SetLastMessage('%MsgBadLogon')
		        RETURN .F.
		      ENDIF
		
		      THIS.oUser.nLoginsLeft = MAX(0, THIS.oUser.nLoginsLeft - 1)
		      IF NOT THIS.oUser.lPasswordLocked
		        IF THIS.oUser.nLoginsLeft > 0
		          IF THIS.oMessage.Confirm('%msgPasswordExpired', THIS.oUser.nLoginsLeft)
		            m.oDialog = CreateLocalized(THIS.cSetPasswordDialogClass,, THIS.oUser)
		            m.oDialog.Show()
		            IF m.oDialog.ShowWindow == 2
		              READ EVENTS  && Allow for subclassed dialog as TopLevelForm, for SDI apps.
		            ENDIF
		          ENDIF
		        ELSE
		          m.oDialog = CreateLocalized(THIS.cSetPasswordDialogClass, THIS.oMessage.TranslateString('%txtForceChange'), THIS.oUser)
		          m.oDialog.Show()
		          IF m.oDialog.ShowWindow == 2
		            READ EVENTS  && Allow for subclassed dialog as TopLevelForm, for SDI apps.
		          ENDIF
		          IF NOT m.oDialog.ReturnValue()
		            THIS.oMessage.SetLastMessage('%MsgBadLogon')
		            RETURN .F.
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		    RETURN THIS._GrantAccess(m.cUsername)
		  ENDIF
		  THIS.oMessage.SetLastMessage('%MsgBadLogon')
		  RETURN .F.
		
	ENDPROC

	PROCEDURE logondialog		&& Call the login dialog to validate username/password combo.
		LPARAMETERS cDefaultUsername
		*++
		*>>Call the login dialog to validate username/password combo.
		*--
		LOCAL oLogon
		  m.oLogon = CreateLocalized(THIS.cLogonDialogClass, m.cDefaultUsername, m.goapp.ccompanyname)
		  IF VARTYPE(m.oLogon) = 'O'
		    m.oLogon.Show()
		    IF VARTYPE(m.oLogon) = 'O'   && Dialog could be released in dev env, so test again.
		      IF m.oLogon.ShowWindow == 2
		        READ EVENTS  && Allow for subclassed dialog as TopLevelForm, for SDI app logon.
		      ENDIF
		      RETURN m.oLogon.ReturnValue()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE openeventlog		&& Open the Event log table. Create a new one if none found.
		*++
		*>>Open the Event log table. Create a new one if none found.
		*--
		LOCAL oShared
		
		  * Create the event log cursor object the first time it is accessed.
		  IF ISNULL(THIS.oEventLog)
		    THIS.oEventLog = CreateNewObject('cmEventLogCursor')
		    IF VARTYPE(THIS.oEventLog) != 'O'
		      RETURN .F.   && Failed to create the eventlog cursor.
		    ENDIF
		  ENDIF
		
		  * Open (or re-open) the event log.
		  IF NOT THIS.oEventLog.IsOpen()
		    IF NOT THIS.oEventLog.Open()
		      THIS.oMessage.Warning('%msgEventLogMissing')
		      THIS.lEventLogEnabled = .F.  && Can't log any more
		      RETURN .F.
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE ouser_access
		  * Create a user value object the first time we need it.
		  IF ISNULL(THIS.oUser)
		    THIS.oUser = CreateNewObject('cmUsernameValue')
		  ENDIF
		  RETURN THIS.oUser
		
	ENDPROC

	PROCEDURE recordevent		&& Record an event in the event log.
		LPARAMETERS cEventName, cEventType, cComment
		*++
		*>>Record an event in the event log.
		*--
		LOCAL nSerialNumber, nSelect, lStatus
		
		  m.nSelect = SELECT()
		
		  * Validate parameters, and insert default values where needed.
		  IF EMPTY(m.cEventName)
		    ERROR 11  && Missing parameter
		  ENDIF
		  IF EMPTY(m.cEventType)
		    m.cEventType = EVENT_TYPE_APP
		  ENDIF
		  IF EMPTY(m.cComment) OR VARTYPE(m.cComment) != 'C'
		    m.cComment = ''
		  ENDIF
		
		  * If this event type is in the filter list, don't record it.
		  IF NOT THIS.lEventLogEnabled ;
		  OR ',' + UPPER(m.cEventType) + ',' $ THIS.cEventFilterList + ','
		    RETURN .T.
		  ENDIF
		
		  * Make sure the event log is open.
		  IF THIS.OpenEventLog()
		    m.nSerialNumber = VAL(THIS.oRegistry.IncrementCounter('%Shared.Security.Event Log.Serial Number'))
		    IF NOT ISNULL(m.nSerialNumber)
		      * Determine next record to use. If oldest record is past recycle date,
		      * the reuse it, otherwise append a new one.
		      IF THIS.nEventHistoryLength > 0 AND NOT THIS.dCheckEventRecycleDate == DATE()
		        LOCAL dDate
		        * Delete any existing log entries older than the number of days specified in nEventHistoryLength
		        * Use the server date (if log is on a remote server) for deleting obsolete records.
		        m.dDate = THIS.oRegistry.GetDate() - THIS.nEventHistoryLength
		
		        * VFP universal date format is {^yyyy-mm-dd}
		        THIS.oEventLog.DeleteWhere(IIF(THIS.oEventLog.IsField('EventTime'), 'EventTime', 'Time') ;
		                 + ' < {^' + STR(YEAR(m.dDate),4) + '-' + STRTRAN(STR(MONTH(m.dDate),2) + '-' +  STR(DAY(m.dDate),2), ' ', '0') + '}')
		        THIS.dCheckEventRecycleDate = DATE()
		      ENDIF
		
		      WITH THIS.oEventLog
		        .New()
		        REPLACE eventName WITH m.cEventName, eventType WITH m.cEventType, ;
		                serialNo WITH m.nSerialNumber, ;
		                Username WITH THIS.cUserName, ;
		                Comment WITH m.cComment IN (.cWorkarea)
		
		        * EventWhere field may have different names in older versions of the table, or not exist at all.
		        IF .IsField('EventWhere')
		          REPLACE EventWhere WITH SYS(0) IN (.cWorkarea)
		        ELSE
		          IF .IsField('Where')
		            REPLACE Where WITH SYS(0) IN (.cWorkarea)
		          ENDIF
		        ENDIF
		
		        * EventTime field may have different names in different versions of the table. Use server time when available.
		        IF .IsField('EventTime')
		          REPLACE EventTime WITH THIS.oRegistry.GetDateTime() IN (.cWorkarea)
		        ELSE
		          REPLACE Time      WITH THIS.oRegistry.GetDateTime() IN (.cWorkarea)
		        ENDIF
		
		        * Authentication checksum is calculated after all other fields are filled in.
		        REPLACE checksum WITH THIS.cmAuthentication.AuthenticateEvent() IN (.cWorkarea)
		
		        * Commit the new record, and return the result status.
		        m.lStatus = .Update()
		      ENDWITH
		    ENDIF
		  ENDIF
		
		  * Select original workarea, or an empty one if original was the eventlog.
		  SELECT (IIF(m.nSelect == SELECT(), 0, m.nSelect))
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE registryupdate		&& Called on initialization and whenever the app registry database is updated.
		*++
		*>>Called on initialization and whenever the app registry database is updated.
		*--
		LOCAL nIndex, cName, lEnabled
		
		  THIS.nEventHistoryLength = ;
		        THIS.oRegistry.GetGlobalKeyValue('%Shared.Security.Event Log.History Length',, THIS.nEventHistoryLength)
		  THIS.dCheckEventRecycleDate = {}
		  m.lEnabled = THIS.oRegistry.GetGlobalKeyValue('%Shared.Security.Event Log.Enabled',, THIS.lEventLogEnabled)
		
		  * Record when and who enables or disables the event log.
		  IF NOT ISNULL(THIS.lEventLogEnabled) AND THIS.lEventLogEnabled != m.lEnabled
		    THIS.lEventLogEnabled = .T.
		    THIS.RecordEvent(IIF(m.lEnabled, EVENT_SEC_LOGENABLE, EVENT_SEC_LOGDISABLE), EVENT_TYPE_SECURITY)
		
		    * Close the event log if we just disabled event logging.
		    IF NOT m.lEnabled
		      THIS.CloseEventLog
		    ENDIF
		  ENDIF
		  THIS.lEventLogEnabled = NVL(m.lEnabled, .T.)
		
		  * Build a list of event types to exclude from the event log.
		  m.nIndex = 0
		  THIS.cEventFilterList = ''
		  DO WHILE THIS.oRegistry.EnumKeys('%Shared.Security.Event Log.Event Types', KEY_TYPE_LOGICAL, @m.nIndex, @m.cName,, @m.lEnabled) > 0
		    IF NOT m.lEnabled
		      THIS.cEventFilterList = THIS.cEventFilterList + ',' + UPPER(m.cName)
		    ENDIF
		  ENDDO
		
	ENDPROC

	PROCEDURE release
		*++
		*>>Release references to other global objects before we are released.
		*--
		  * Log current user off before final cleanup.
		  THIS.Logoff()
		  THIS.CloseEventLog()
		
		  * Cancel outstanding subscriptions to Registry Update events.
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.UnSubscribe('Registry Update Shared', THIS)
		  ENDIF
		
		  STORE .NULL. TO THIS.oStateManager, THIS.oRegistry, THIS.oMessage
		  RELEASE THIS
		
	ENDPROC

	PROCEDURE setpassword		&& Set the password for the current logged on user.
		LPARAMETERS cNewPassword
		*++
		*>>Set the password for the current logged on user.
		* Programmaticly change current user password, used by the frmSetLogonPassword dialog.
		*--
		LOCAL cUserProperties
		
		  * Reload user details from registry before changing password. A user must currently be logged in.
		  IF THIS.IsLoggedOn()
		    m.cUserProperties = THIS.oRegistry.GetGlobalKeyValue( ;
		                      'Security.Users.' + THIS.cUsername, 'Username', '')
		    IF NOT EMPTY(m.cUserProperties)
		      THIS.oUser.Scatter(m.cUserProperties, THIS.cUsername)
		      IF THIS.oUser.SetPassword(m.cNewPassword)
		        THIS.oRegistry.SetGlobalKeyValue('Security.Users.' + THIS.cUsername, ;
		                                         THIS.oUser.Gather(THIS.cUsername))
		        RETURN .T.
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setpassworddialog		&& Call the SetPassword dialog to change password for the current logged on user.
		LPARAMETERS cPrompt
		*++
		*>>Call the SetPassword dialog to change password for the current logged on user.
		*--
		LOCAL oDialog
		  IF THIS.IsLoggedOn()
		    m.oDialog = CreateLocalized(THIS.cSetLogonPasswordDialogClass, m.cPrompt)
		    IF VARTYPE(m.oDialog) = 'O'
		      m.oDialog.Show()
		      RETURN m.oDialog.ReturnValue()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setprivilege		&& Set or remove a privilege for the current logged on user.
		LPARAMETERS cPriv, lValue, lNoRefresh
		*++
		*>>Set or remove a privilege for the current logged on user.
		* The lNoRefresh parameter is used internally to optimize refreshing 
		* across multiple privilege sets.
		*--
		  IF m.lValue
		    IF NOT THIS.HasPrivilege(m.cPriv)
		      THIS.cPrivileges = THIS.cPrivileges + IIF(EMPTY(THIS.cPrivileges), '', ',') + m.cPriv
		    ENDIF
		  ELSE
		    THIS.cPrivileges = STRTRAN(UPPER(THIS.cPrivileges), UPPER(m.cPriv), '')
		    THIS.cPrivileges = STRTRAN(THIS.cPrivileges, ',,', ',')
		  ENDIF
		
		  * If the global state manager exists, update the privilege state so any objects that 
		  * depend on security privileges will automatically be refreshed.
		  IF NOT m.lNoRefresh AND THIS.nSysPrivState > 0
		    THIS.oStateManager.Broadcast(THIS.nSysPrivState)
		  ENDIF
		  RETURN m.lValue
		
	ENDPROC

	PROCEDURE validpassword		&& Determine if the specified password matches the encrypted password string.
		LPARAMETERS cEncrypted, cPassword
		*++
		*>>Determine if the specified password matches the encrypted password string.
		*--
		  * If the there is no password to match against, accept any password.
		  IF NOT EMPTY(m.cEncrypted)
		    IF THIS.lExactCasePasswords
		      RETURN THIS.EncryptPassword(ALLTRIM(m.cPassword)) == m.cEncrypted
		    ELSE
		      RETURN THIS.EncryptPassword(UPPER(ALLTRIM(m.cPassword))) == m.cEncrypted
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE validpassworddialog		&& Get password via dialog, and determine if it matches the encrypted password string.
		LPARAMETERS cEncrypted, cPrompt
		*++
		*>>Get password via dialog, and determine if it matches the encrypted password string.
		*--
		LOCAL oDialog
		  * If the there is nothing to match against, no need to prompt for password.
		  IF EMPTY(m.cEncrypted)
		    RETURN .T.  && No password is required.
		  ELSE
		    m.oDialog = CreateLocalized(THIS.cGetPasswordDialogClass, m.cPrompt)
		    IF VARTYPE(m.oDialog) = 'O'
		      m.oDialog.Show()
		      IF VARTYPE(m.oDialog) = 'O'   && Dialog could be released in dev env, so re-test here.
		        IF m.oDialog.ShowWindow == 2
		          READ EVENTS  && Allow for subclassed dialog as TopLevelForm, for SDI apps.
		        ENDIF
		        IF m.oDialog.uValue
		          IF ValidPassword(m.cEncrypted, m.oDialog.cPassword)
		            RETURN .T.
		          ENDIF
		          THIS.oMessage.Display('%MsgWrongPassword')
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE validpasswordkey		&& Compare the specified password text against the value of the specified password key.
		LPARAMETERS cKeyName, cPassword
		*++
		*>>Compare the specified password text against the value of the specified password key.
		* Returns true if they match.
		*--
		LOCAL oPassword, cValue
		
		  * A valid password record is required. This prevents people
		  * from gaining unauthorized access by deleting the password key.
		  m.oPassword = CreateNewObject('cmPasswordValue')
		  m.cValue = THIS.oRegistry.GetGlobalKeyValue(m.cKeyName, 'Password', '')
		  m.oPassword.Scatter(m.cValue, SUBSTR(m.cKeyName, RAT('.', m.cKeyName) + 1))
		
		  RETURN m.oPassword.lValid AND THIS.ValidPassword(m.oPassword.cPassword, m.cPassword)
		
	ENDPROC

	PROCEDURE validpasswordkeydialog		&& Get password via dialog, and determine if it matches the specified password key.
		LPARAMETERS cKeyName, cPrompt
		*++
		*>>Get password via dialog, and determine if it matches the specified password key.
		*--
		LOCAL oDialog, oPassword, cValue
		
		  * A valid password record is required. This prevents people
		  * from gaining unauthorized access by deleting the password key.
		  m.oPassword = CreateNewObject('cmPasswordValue')
		  m.cValue = THIS.oRegistry.GetGlobalKeyValue(m.cKeyName, 'Password', '')
		  m.oPassword.Scatter(m.cValue, SUBSTR(m.cKeyName, RAT('.', m.cKeyName) + 1))
		
		  IF m.oPassword.lValid
		    IF EMPTY(m.oPassword.cPassword)
		      RETURN .T.  && No password is required.
		    ELSE
		      * A password is required - call the password dialog to get one interactively.
		      * GetPassword dialog takes 1 param (the prompt), and returns password in param1.
		      m.oDialog = CreateLocalized(THIS.cGetPasswordDialogClass, m.cPrompt)
		      IF VARTYPE(m.oDialog) = 'O'
		        m.oDialog.Show()
		        IF VARTYPE(m.oDialog) = 'O'   && Dialog could be released in dev env, so re-test here.
		          IF m.oDialog.ShowWindow == 2
		            READ EVENTS  && Allow for subclassed dialog as TopLevelForm, for SDI apps.
		          ENDIF
		          IF m.oDialog.uValue
		            IF THIS.ValidPassword(m.oPassword.cPassword, m.oDialog.cPassword)
		              RETURN .T.
		            ENDIF
		            THIS.oMessage.Display('%MsgWrongPassword')
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE _grantaccess		&& Internal method to Accept the specified user as the current logged on user, load privileges, and update last-logged-on time.
		LPARAMETERS cUsername
		*++
		*>>Internal method to Accept the specified user as the current logged on user, load privileges, and update last-logged-on time.
		*--
		LOCAL cGroupName, cGroupValue, cGroupList, cPriv, cPrivList, oGroup
		
		  * Copy user properties from user object to security object.
		  WITH THIS.oUser
		    THIS.cUsername = m.cUsername  && Name user typed into login dialog
		    THIS.cFullName = .cFullName
		    THIS.cGroups = .cGroups
		    THIS.cReplicationID = .cReplicationID
		    THIS.lPasswordLocked = .lPasswordLocked
		    THIS.lPasswordMustChange = .lPasswordMustChange
		    THIS.lPasswordRequired = .lPasswordRequired
		    THIS.nMinPasswordLength = .nMinPasswordLength
		
		    THIS.cPrivileges = ''
		    THIS.SetPrivilege(.cPrivileges, .T., .T.)
		  ENDWITH
		
		  * Add privileges from all member groups to the list of held privileges.
		  m.cGroupList = THIS.oUser.cGroups 
		  m.oGroup = CreateNewObject('cmGroupValue')
		  DO WHILE NOT EMPTY(m.cGroupList)
		    m.cGroupName = GetToken(@m.cGroupList, ',')
		    m.cGroupValue = THIS.oRegistry.GetGlobalKeyValue('Security.Groups.' + m.cGroupName, 'Group', '')
		    IF NOT EMPTY(m.cGroupValue)
		      IF m.oGroup.Scatter(m.cGroupValue, m.cGroupName)
		        m.cPrivList = m.oGroup.cPrivileges
		        DO WHILE NOT EMPTY(m.cPrivList)
		          m.cPriv = GetToken(@m.cPrivList, ',')
		          THIS.SetPrivilege(m.cPriv, .T., .T.)
		        ENDDO
		      ENDIF
		    ENDIF
		  ENDDO
		
		  * Call custom user code to apply additional tests. The user code should call oMessage.SetLastMessage()
		  * if if returns false, to explain the reason for the failure.
		  IF NOT THIS.BeforeLogon()
		    RETURN .F.
		  ENDIF
		
		  * If the global state manager exists, update the privilege state so any objects that 
		  * depend on security privileges will automatically be refreshed.
		  IF THIS.nSysPrivState > 0
		    THIS.oStateManager.Broadcast(THIS.nSysPrivState)
		  ENDIF
		
		  * Update Last-Logged-in time in user record.
		  THIS.tLastLogonTime = THIS.oUser.tLastLogonTime
		  THIS.tLogonTime = DATETIME()
		  THIS.oUser.tLastLogonTime = THIS.tLogonTime
		  THIS.oRegistry.SetGlobalKeyValue('Security.Users.' + m.cUsername, THIS.oUser.Gather(m.cUsername))
		
		  * Record logon event in event log.
		  THIS.RecordEvent(EVENT_SEC_LOGON, EVENT_TYPE_SECURITY)
		  THIS.AfterLogon()
		  RETURN .T.
		
	ENDPROC

	PROCEDURE _protectprivileges		&& Make sure that all privileges (except Developer) are set to Aministrator access or lower.
		*++
		*>>Make sure that all privileges (except Developer) are set to Aministrator access or lower.
		*--
		LOCAL oKey, nAccess, cRoot, cKey, cKeyList
		
		  * If the Privilege category is set to developerAccess, then we need to reset it, and all privileges.
		  * This will upgrade pre-7.0 security tables to work properly with Codemine 7.0.
		  * Under 7.0, only privileges that are accessible by the current user can be assigned. So,
		  * for example, any privilege key set to Developer access cannot be accessed in the 
		  * account editor dialogs, unless the current user has developer privilege. This means
		  * a user cannot create another account with privileges of a higher level than they already hold.
		  m.cRoot = '%Shared.Security.Privileges'
		  IF THIS.oRegistry.GetKeyValueEx(m.cRoot, , , , , @m.nAccess) ;
		  AND m.nAccess = KEY_ACCESS_DEVELOPER
		    THIS.oRegistry.EnumKeysToString(m.cRoot, 'Privilege', @m.cKeyList)
		    DO WHILE NOT EMPTY(m.cKeyList)
		      m.cKey = GetToken(@m.cKeyList, ',')
		      IF NOT PROPER(m.cKey) == 'Developer' AND NOT PROPER(m.cKey) == 'Debug' 
		        THIS.oRegistry.SetKeyValueEx(m.cRoot + '.' + m.cKey, , , 'Privilege', '', , KEY_ACCESS_ADMIN)
		      ENDIF
		    ENDDO
		    THIS.oRegistry.SetKeyValueEx(m.cRoot, , , KEY_TYPE_CATEGORY, 'Privilege', , KEY_ACCESS_ADMIN)
		  ENDIF
		
		  * Also need to change the User ID counter to be base 36 (alphanumeric) to avoid possibility of
		  * using characters that would cause a syntax error used as a literal in SQL Server WHERE clauses.
		  IF THIS.oRegistry.GetKey('%Shared.Security.User ID Counter', @m.oKey) ;
		  AND m.oKey.nCounterFormat > COUNTER_TYPE_BASE62
		    LOCAL oUser
		
		    m.cRoot = '%Shared.Security.Users'
		    m.oKey.nCounterFormat = COUNTER_TYPE_CHAR
		    THIS.oRegistry.SetKey(m.oKey)
		
		    m.oUser = CreateNewObject('cmUsernameValue')
		    THIS.oRegistry.EnumKeysToString(m.cRoot, 'Username', @m.cKeyList)
		    DO WHILE NOT EMPTY(m.cKeyList)
		      m.cKey = GetToken(@m.cKeyList, ',')
		      m.cValue = THIS.oRegistry.GetKeyValue(m.cRoot + '.' + m.cKey, 'Username', '')
		      WITH m.oUser
		        .Scatter(m.cValue, m.cKey)
		        IF  [?] $ .cReplicationID OR ['] $ .cReplicationID
		          * Assign a new UserID to replace the old invalid ones.
		          .cReplicationID = THIS.oRegistry.IncrementCounter('%Shared.Security.User ID Counter')
		          m.cValue = .Gather(m.cKey)
		          THIS.oRegistry.SetKeyValue(m.cRoot + '.' + m.cKey, m.cValue)
		        ENDIF
		      ENDWITH
		    ENDDO
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmusereditor AS cmbinarykeyeditorabstract OF "cmregkey.vcx" 		&& External Binary key value editor class for Username keys
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: defaultkeyproperties		&& Establish default key properties for username keys.
		*m: editvalue		&& Call editor form to edit key value.
		*m: ondeletekey		&& Called before a User is deleted. Deletes all keys replicated for the user we are deleting. Return .T. if ok to delete.
		*m: validatekeyproperties		&& Validate key properties.
		*p: crequiredcategory
		*p: ladministrator
		*p: lnoreplicate
	*</DefinedPropArrayMethod>

	crequiredcategory = Security.Users
	ladministrator = .T.
	lnoreplicate = .T.
	Name = "cmusereditor"
	
	PROCEDURE defaultkeyproperties		&& Establish default key properties for username keys.
		LPARAMETERS oKey
		*++
		*>>Establish default key properties for username keys.
		*--
		  * Default to administratorr only access
		  m.oKey.nAccess = KEY_ACCESS_ADMIN
		
	ENDPROC

	PROCEDURE editvalue		&& Call editor form to edit key value.
		LPARAMETERS oKey
		*++
		*>>Call editor form to edit key value.
		* Called from regedit only. Returns .T. if value changed.
		*--
		LOCAL oDialog
		
		  * The key value contains packed user properties. Pass it along with the 
		  * key name and description to the editor form.
		  m.oDialog = CreateLocalized(THIS.oSecurity.cUserEditorClass, ;
		                 m.oKey.cValue, m.oKey.cName, m.oKey.cDescription)
		  m.oDialog.Show()
		
		  * If changes were made, copy modified values back to registry key properties.
		  IF VARTYPE(m.oDialog) = 'O' AND m.oDialog.uValue
		    m.oKey.cValue = m.oDialog.cUserKeyValue
		    m.oKey.cDescription = m.oDialog.cDescription
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE ondeletekey		&& Called before a User is deleted. Deletes all keys replicated for the user we are deleting. Return .T. if ok to delete.
		LPARAMETERS oKey
		*++
		*>>Called before a User is deleted. Deletes all keys replicated for the user we are deleting. Return .T. if ok to delete.
		*--
		LOCAL oUser
		
		  * Dont't allow deletion of current logged on user. Note that calling
		  * cmSecurity.EnableDeveloperMode() clears the current users replication ID, 
		  * so in developer mode (as opposed to simply developer privilege) it is 
		  * ok to delete current logged on user.
		  IF NOT EMPTY(NVL(m.oKey.cValue, ''))
		    m.oUser = CreateNewObject('cmUsernameValue')
		    m.oUser.Scatter(m.oKey.cValue, m.oKey.cName)
		
		    IF NOT ISNULL(THIS.oSecurity) AND m.oUser.cReplicationID == THIS.oSecurity.cReplicationID
		      RETURN THIS.oMessage.Warning('You cannot delete user record for current logged on user')
		    ENDIF
		
		    * Delete all keys replicated for the user we are deleting.
		    RETURN THIS.oRegistry.DeleteUserReplications(m.oUser.cReplicationID)
		  ENDIF
		
	ENDPROC

	PROCEDURE validatekeyproperties		&& Validate key properties.
		LPARAMETERS oKey
		*++
		*>>Validate key properties.
		* Called from keyedit only, to validate a key being created or edited. Return .T. if ok.
		*--
		  LOCAL cError
		  WITH m.oKey
		    DO CASE
		      CASE NOT EMPTY(.oOldVal.KeyName) ;
		           AND NOT UPPER(TRIM(.cName)) + '.' == UPPER(TRIM(SUBSTR(.oOldVal.KeyName, RAT('.', .oOldVal.KeyName, 2) + 1)))
		        m.cError = 'User keys cannot be renamed'
		
		      CASE NOT UPPER(TRIM(.cName)) == UPPER(TRIM(.cLocName))
		        m.cError = 'Username keys cannot be localized - Localized name must match key name'
		    ENDCASE
		
		    IF NOT EMPTY(m.cError)
		      RETURN THIS.oMessage.Warning(m.cError)
		    ENDIF
		  ENDWITH
		  RETURN DODEFAULT(m.oKey)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmusernamevalue AS cmbinarykeyvalueabstract OF "cmregkey.vcx" 		&& Pack and unpack username values.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: loadtemplateuser		&& Load the value string of the template user account into a local property.
		*m: packvalue
		*m: setpassword		&& Set the password for this user object.
		*m: unpackvalue
		*p: cfullname
		*p: cgroups
		*p: ckeystring
		*p: cpassword
		*p: cprivileges
		*p: creplicationid
		*p: cversion
		*p: lautologonpassword
		*p: ldisabled
		*p: lempty
		*p: lpasswordchanged
		*p: lpasswordlocked
		*p: lpasswordmustchange
		*p: lpasswordrequired
		*p: ngracelogins
		*p: nloginsleft
		*p: nminpasswordlength
		*p: npasswordlife
		*p: tlastlogontime
		*p: tlastpasswordchange
	*</DefinedPropArrayMethod>

	PROTECTED ckeystring
	cfullname = 
	cgroups = 
	ckeystring = Soft Classics CodeMine User Properties
	cname = 
	cpassword = 
	cprivileges = 
	creplicationid = 
	cversion = 7.0.0
	lautologonpassword = .F.
	ldisabled = .F.
	lempty = .T.
	lpasswordchanged = .F.
	lpasswordlocked = .F.
	lpasswordmustchange = .F.
	lpasswordrequired = .F.
	Name = "cmusernamevalue"
	ngracelogins = 1
	nloginsleft = 1
	nminpasswordlength = 0
	npasswordlife = 0
	tlastlogontime = ({//::})
	tlastpasswordchange = ({//::})
	
	PROCEDURE gather
		LPARAMETERS cName
		*++
		*>>Gather all the type specific value parameters into one string field.
		*--
		LOCAL cValue
		
		  IF PCOUNT() > 0
		    THIS.cName = m.cName
		  ENDIF
		
		  IF THIS.lEmpty
		    * Assign a replication ID to this new user.
		    THIS.cReplicationID = THIS.oRegistry.IncrementCounter('%Shared.Security.User ID Counter', 4, 95, 250)
		    IF ISNULL(THIS.cReplicationID)
		      ERROR 'App Registry Corrupted - "%Shared.Security.User ID Counter" not found.'
		    ENDIF
		    THIS.oSecurity.RecordEvent(EVENT_SEC_ADDUSER, EVENT_TYPE_SECURITY, THIS.cName)
		  ELSE
		    IF THIS.lPasswordChanged
		      * Record password change event in event log.
		      THIS.oSecurity.RecordEvent(EVENT_SEC_PASSCHANGE, EVENT_TYPE_SECURITY, THIS.cName)
		    ENDIF
		  ENDIF
		
		  THIS.lEmpty = .F.
		  THIS.lPasswordChanged = .F.
		
		  m.cValue = THIS.PackValue()
		  RETURN cmEncrypt(m.cValue, UPPER(ALLTRIM(THIS.cName)) + THIS.cKeyString)
		
	ENDPROC

	PROCEDURE Init
		*++
		* Copyright 1996-2002 Soft Classics, Ltd. All rights reserved.
		*--
		  THIS.AddProperty('oString', CreateGlobalObject('cmStringTools'))
		  THIS.AddProperty('oSecurity', FindGlobalObject('cmSecurity'))
		  THIS.AddProperty('oRegistry', FindGlobalObject('cmRegistry',, .T.))
		  THIS.AddProperty('cTemplateUserValue', .NULL.)
		  THIS.AddProperty('cTemplateName', .NULL.)
		
	ENDPROC

	PROCEDURE loadtemplateuser		&& Load the value string of the template user account into a local property.
		*++
		*>>Load the value string of the template user account into a local property.
		*--
		  IF ISNULL(THIS.cTemplateUserValue)
		    THIS.cTemplateUserValue = ''
		    THIS.cTemplateName = THIS.oRegistry.GetGlobalKeyValue('Security.Template User Account', KEY_TYPE_CHAR, '')
		    IF NOT EMPTY(THIS.cTemplateName)
		      THIS.cTemplateUserValue = THIS.oRegistry.GetGlobalKeyValue('Security.Users.' + THIS.cTemplateName, 'Username', '')
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE packvalue
		*++
		* Pack individual user properties into a single value string for encryption and storage.
		*--
		  RETURN 'CodeMine User' + CR_LF + THIS.cPassword + CR_LF + THIS.cFullName + CR_LF ;
		       + IIF(LEN(THIS.cPrivileges) > 1020, '~' + STR(LEN(THIS.cPrivileges),4), '') ;
		       + THIS.cPrivileges + CR_LF ;
		       + THIS.cGroups + CR_LF ;
		       + THIS.cReplicationID + CR_LF ;
		       + IIF(THIS.lPasswordMustChange, 'Expired', '') + CR_LF ;
		       + IIF(THIS.lPasswordLocked, 'Locked', '') + CR_LF ;
		       + IIF(THIS.lAutoLogonPassword, 'AutoLogon', '') + CR_LF ;
		       + IIF(THIS.lPasswordRequired, 'Required', '') + CR_LF ;
		       + STR(THIS.nMinPasswordLength, 2) + CR_LF ;
		       + TTOC(THIS.tLastLogonTime, 1) + CR_LF ;
		       + IIF(THIS.lDisabled, 'Disabled', '') + CR_LF ;
		       + STR(THIS.nPasswordLife) + CR_LF ;
		       + STR(THIS.nGraceLogins) + CR_LF ;
		       + STR(THIS.nLoginsLeft) + CR_LF ;
		       + TTOC(THIS.tLastPasswordChange, 1) + CR_LF ;
		       + '#EndCodeMineUser' + CR_LF   && Enduser tag marks end of default data. Custom user data may follow.
		
	ENDPROC

	PROCEDURE scatter
		LPARAMETERS cCodedValue, cName
		*++
		*>>Break the compound value string into its individual components.
		* Returns False if user data is corrupted.
		*--
		LOCAL cValue, nMemoWidth
		
		  THIS.lPasswordChanged = .F.
		
		  _MLINE = 0
		  THIS.cName = m.cName
		  IF EMPTY(m.cCodedValue)
		    THIS.LoadTemplateUser()   && Load template value if not already loaded.
		    IF EMPTY(THIS.cTemplateUserValue)
		      * New username key, and no template account, so use hardcoded defaults.
		      STORE ''  TO THIS.cPrivileges, THIS.cGroups
		      STORE .F. TO THIS.lPasswordMustChange, THIS.lPasswordLocked, ;
		                   THIS.lAutoLogonPassword, THIS.lPasswordRequired
		      THIS.nPasswordLife = 0
		      THIS.nGraceLogins = 1
		    ELSE
		      * Make a recursive call to load values from the template account.
		      THIS.Scatter(THIS.cTemplateUserValue, THIS.cTemplateName)
		    ENDIF
		
		    * These properties are not copied from the template account.
		    THIS.lEmpty = .T.
		    THIS.lDisabled = .F.
		    THIS.cFullName = ''
		    THIS.cPassword = ''
		    THIS.cReplicationID = ''
		    THIS.tLastLogonTime = {//::}
		    THIS.tLastPasswordChange = {//::}
		    RETURN .T.
		  ELSE
		    m.cValue = cmEncrypt(m.cCodedValue, UPPER(TRIM(THIS.cName)) + THIS.cKeyString)
		    IF MLINE(m.cValue, 1, _MLINE) == 'CodeMine User'
		      m.nMemoWidth = SET('MEMOWIDTH')
		      SET MEMOWIDTH TO 1024
		
		      THIS.lEmpty = .F.
		      THIS.UnpackValue(@m.cValue)
		
		      SET MEMOWIDTH TO (m.nMemoWidth)
		      RETURN .T.
		    ENDIF
		  ENDIF
		
		  * User value was corrupted, just blank everything out.
		  THIS.lEmpty = .T.
		  STORE '' TO THIS.cPassword, THIS.cFullName, ;
		              THIS.cPrivileges, THIS.cGroups, THIS.cReplicationID
		  STORE .F. TO THIS.lPasswordMustChange, THIS.lPasswordLocked, ;
		               THIS.lAutoLogonPassword, THIS.lPasswordRequired, THIS.lDisabled
		  THIS.tLastLogonTime = {//::}
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setpassword		&& Set the password for this user object.
		LPARAMETERS cPassword
		*++
		*>>Set the password for this user object.
		*--
		LOCAL cEncrypted
		  m.cEncrypted = THIS.oSecurity.EncryptPassword(m.cPassword)
		  IF NOT THIS.cPassword == m.cEncrypted
		    THIS.lPasswordChanged = .T.
		    THIS.lPasswordMustChange = .F.
		    THIS.tLastPasswordChange = DATETIME()
		    THIS.nLoginsLeft = THIS.nGraceLogins
		    THIS.cPassword = m.cEncrypted
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE unpackvalue
		LPARAMETERS cValue
		*++
		* Unpack the packed value string into individual user properties
		*--
		  THIS.cPassword = MLINE(m.cValue, 1, _MLINE)
		  THIS.cFullName = MLINE(m.cValue, 1, _MLINE)
		
		  * If privilege string is too long for one mline, then use SUBSTR() to pick it out
		  IF SUBSTR(m.cValue, _MLINE + 2, 1) = '~'
		    LOCAL nLen
		    m.nLen = VAL(SUBSTR(m.cValue, _MLINE + 3, 4))
		    THIS.cPrivileges = SUBSTR(m.cValue, _MLINE + 7, m.nLen)
		    _MLINE = _MLINE + m.nLen + 7
		  ELSE
		    THIS.cPrivileges = MLINE(m.cValue, 1, _MLINE)
		  ENDIF
		
		  THIS.cGroups = MLINE(m.cValue, 1, _MLINE)
		  THIS.cReplicationID = MLINE(m.cValue, 1, _MLINE)
		
		  THIS.lPasswordMustChange = NOT EMPTY(MLINE(m.cValue, 1, _MLINE))
		  THIS.lPasswordLocked = NOT EMPTY(MLINE(m.cValue, 1, _MLINE))
		  THIS.lAutoLogonPassword = NOT EMPTY(MLINE(m.cValue, 1, _MLINE))
		  THIS.lPasswordRequired = NOT EMPTY(MLINE(m.cValue, 1, _MLINE))
		  THIS.nMinPasswordLength = VAL(MLINE(m.cValue, 1, _MLINE))
		  THIS.tLastLogonTime = THIS.oString.StringToTime(MLINE(m.cValue, 1, _MLINE))
		  THIS.lDisabled = NOT EMPTY(MLINE(m.cValue, 1, _MLINE))
		  THIS.nPasswordLife = VAL(MLINE(m.cValue, 1, _MLINE))
		  THIS.nGraceLogins = MAX(1, VAL(MLINE(m.cValue, 1, _MLINE)))
		  THIS.nLoginsLeft = VAL(MLINE(m.cValue, 1, _MLINE))
		  THIS.tLastPasswordChange = THIS.oString.StringToTime(MLINE(m.cValue, 1, _MLINE))
		  
		  * Test for normal end of user data token. If later versions add new data lines,
		  * then this will become important to distinguish that data from custom user data 
		  * appended to the string.
		  IF MLINE(m.cValue, 1, _MLINE) == '#EndCodeMineUser'
		    RETURN .T.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE
