*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmforms.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cmcontextmenumanager AS cuscustom OF "codemine.vcx" 		&& CodeMine context menu manager class.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: contextmenuactivate		&& Activate the context menu, and return the identifier associated with the option chosen.
		*m: contextmenubar		&& Define a menu bar for the context menu.
		*m: contextmenubarcheck		&& Set the check-mark for the specified menu bar.
		*m: contextmenubardisable		&& Enable or disbale the specified context menu bar, per the specified expression.
		*m: contextmenuinit		&& Initialize context menu popup.
		*m: contextmenuseparator		&& Add a Separator bar to the context menu, only if any other bars are added after.
		*m: getbarcount		&& Return the number of currently defined ctx menu bars.
		*p: cclass		&& Foundation class name. You should not change this value in any subclasses.
	*</DefinedPropArrayMethod>

	cclass = cmContextMenuManager		&& Foundation class name. You should not change this value in any subclasses.
	Name = "cmcontextmenumanager"
	
	PROCEDURE contextmenuactivate		&& Activate the context menu, and return the identifier associated with the option chosen.
		*++
		*>>Activate the context menu, and return the identifier associated with the option chosen.
		*--
		LOCAL nBar, cPrompt
		
		  * Turn off interrupts while menu is active.
		  IF NOT ISNULL(THISFORM.oStateManager)
		    THISFORM.oStateManager.EnableInterrupts(.F.)
		  ENDIF
		
		  m.cPrompt = ''
		  IF CNTBAR('ctxMenu') > 0
		    ACTIVATE POPUP CtxMenu 
		    m.nBar = BAR()
		    
		    * If a bar was selected, and menu was not programatically released, process the selection.
		    IF m.nBar > 0 AND CNTBAR('ctxMenu') > 0
		      * If we used a translated menu bar name, peek into the menu cache to get the original name.
		      IF NOT ISNULL(THISFORM.oMessage) AND m.nBar <= ALEN(THISFORM.oMessage.aBarCache, 1)
		        m.cPrompt = THISFORM.oMessage.aBarCache[m.nBar, 1]
		      ENDIF
		      * If no cache available, or cache for this bar was empty, use actual prompt text instead.
		      IF EMPTY(m.cPrompt)
		        m.cPrompt = PROMPT()
		      ENDIF
		    ENDIF
		    RELEASE POPUP CtxMenu EXTENDED
		    IF NOT EMPTY(WONTOP()) AND THIS.lReActivateForm
		      ACTIVATE WINDOW (WONTOP())
		    ENDIF
		  ENDIF
		
		  * Turn interrupts back on once menu is closed.
		  IF NOT ISNULL(THISFORM.oStateManager)
		    THISFORM.oStateManager.EnableInterrupts(.T.)
		  ENDIF
		
		  RETURN m.cPrompt
		
	ENDPROC

	PROCEDURE contextmenubar		&& Define a menu bar for the context menu.
		LPARAMETERS nBar, cPrompt, uArg, cStyle, cStatbar
		*++
		*>>Define a menu bar for the context menu.
		*--
		  IF EMPTY(m.cStatbar)
		    m.cStatbar = ''
		  ENDIF
		  IF EMPTY(m.cStyle)
		    m.cStyle = 'N'
		  ENDIF
		  IF NOT ISNULL(THISFORM.oMessage)
		    IF m.cPrompt == '\-'
		      THIS.nSeparatorBar = 0
		    ELSE
		      * Add conditional separator bar before next real bar, if at least one bar already exists.
		      IF NOT EMPTY(THIS.nSeparatorBar) AND CNTBAR('CtxMenu') > 0
		        DEFINE BAR (THIS.nSeparatorBar) OF CtxMenu PROMPT '\-'
		      ENDIF
		      THIS.nSeparatorBar = 0
		
		      * Call Translate() even if no "%" prefix, so bar cache stay current.
		      THISFORM.oMessage.TranslateBar(m.cPrompt, m.nBar, @m.cPrompt, @m.cStatbar)
		    ENDIF
		
		    IF PCOUNT() > 2 AND NOT EMPTY(m.uArg)
		      m.cPrompt = THISFORM.oMessage.Format(m.cPrompt, @m.uArg)
		    ENDIF
		    IF PEMSTATUS(THISFORM, 'Fontname', 5)
		      DEFINE BAR (m.nBar) OF CtxMenu PROMPT m.cPrompt FONT (THISFORM.Fontname), THISFORM.FontSize STYLE (m.cStyle) MESSAGE m.cStatbar
		    ELSE
		      DEFINE BAR (m.nBar) OF CtxMenu PROMPT m.cPrompt STYLE (m.cStyle) MESSAGE m.cStatbar
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE contextmenubarcheck		&& Set the check-mark for the specified menu bar.
		LPARAMETERS nBar, lCheck
		*++
		*>>Set the check-mark for the specified menu bar.
		*--
		  SET MARK OF BAR (m.nBar) OF ctxmenu TO (m.lCheck)
		
	ENDPROC

	PROCEDURE contextmenubardisable		&& Enable or disbale the specified context menu bar, per the specified expression.
		LPARAMETERS nBar, lDisable
		*++
		*>>Enable or disbale the specified context menu bar, per the specified expression.
		*--
		  SET SKIP OF BAR (m.nBar) OF ctxMenu (m.lDisable)
		
	ENDPROC

	PROCEDURE contextmenuinit		&& Initialize context menu popup.
		LPARAMETERS oTarget, nRow, nCol
		*++
		*>>Initialize context menu popup.
		*--
		  THIS.nSeparatorBar = 0
		  THIS.lReActivateForm = .F.
		
		  * Context menus require the global message object for bar translations.
		  IF NOT ISNULL(THISFORM.oMessage)
		    * Default to the object the mouse is over, if no object is specified.
		    IF VARTYPE(m.oTarget) != 'O'
		      m.oTarget = SYS(1270)
		    ENDIF
		    IF TYPE('m.oTarget.Parent.Name') = 'C'
		      m.oTarget = m.oTarget.Parent
		    ENDIF
		    IF m.oTarget.baseclass = 'Toolbar'
		      IF TYPE('_SCREEN.ActiveForm.Name') = 'C'
		        IF _SCREEN.ActiveForm.WindowType = 1
		          RETURN .F.  && No toolbar context menus while a modal form is open.
		        ENDIF
		      ENDIF
		      THIS.lReActivateForm = .T.
		      IF m.oTarget.ShowWindow = 0
		        ACTIVATE SCREEN && Only way to position popup menu over docked toolbars.
		      ENDIF
		      m.nRow = MROW()
		      m.nCol = MCOL()
		      IF m.oTarget.Docked
		        IF m.oTarget.DockPosition = 2   && Right
		          m.nCol = _Screen.Width
		        ENDIF
		        IF m.oTarget.DockPosition = 3   && Bottom
		          m.nRow = _Screen.Height
		        ENDIF
		      ENDIF
		    ELSE
		      IF EMPTY(m.nRow)
		        m.nRow = MROW()
		      ENDIF
		      IF EMPTY(m.nCol)
		        m.nCol = MCOL()
		      ENDIF
		    ENDIF
		
		    DEFINE POPUP CtxMenu MARGIN RELATIVE SHORTCUT FROM m.nRow, m.nCol
		    ON SELECTION POPUP CtxMenu DEACTIVATE POPUP CtxMenu
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE contextmenuseparator		&& Add a Separator bar to the context menu, only if any other bars are added after.
		LPARAMETERS nBar
		*++
		*>>Add a Separator bar to the context menu, only if any other bars are added after.
		*--
		  THIS.nSeparatorBar = m.nBar
		
	ENDPROC

	PROCEDURE getbarcount		&& Return the number of currently defined ctx menu bars.
		*++
		*>>Return the number of currently defined ctx menu bars.
		*--
		  RETURN CNTBAR('ctxMenu')
		
	ENDPROC

	PROCEDURE init
		  THIS.AddProperty('nSeparatorBar', 0)
		  THIS.AddProperty('lReActivateForm')
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmdatachild AS frmdataformcustom OF "..\custom\cforms.vcx" 		&& CodeMine child data form class
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: lexpliciteditmode_access		&& If null, return value from parent form.
		*m: lwritelock_access		&& Modeless child forms share a common write-lock setting with parent form.
		*m: lwritelock_assign		&& Modeless child forms share a common write-lock setting with parent form.
		*p: cmdatamanager		&& Reference to calling form's data manager object
		*p: cmlookupmanager		&& Reference to calling form's lookup manager object
		*p: lsaveonclose		&& Set to .T. if closing this child form should trigger a Save() for the cursors listed in cSaveWorkarea.
		*p: ocaller		&& Object reference to calling parent form.
	*</DefinedPropArrayMethod>

	Caption = "CodeMine Data Modeless Child Form"
	cclass = frmDataChild
	cdataenvironment = 
	cmdatamanager = .NULL.		&& Reference to calling form's data manager object
	cmlookupmanager = .NULL.		&& Reference to calling form's lookup manager object
	DataSession = 1
	DoCreate = .T.
	lexpliciteditmode = .NULL.
	lsaveonclose = .T.		&& Set to .T. if closing this child form should trigger a Save() for the cursors listed in cSaveWorkarea.
	Name = "frmdatachild"
	nchildrefreshmode = 3
	ocaller = .NULL.		&& Object reference to calling parent form.
	
	PROCEDURE Activate
		*++
		*>>Custom activate for frmDataChild forms.
		*--
		  * The parent form keeps a reference to the active child form.
		  IF NOT ISNULL(THIS.oCaller)
		    THIS.cmDataManager.SetActiveChildForm(THIS)
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE beforeclose
		LPARAMETERS nReason
		*++
		*>>Called before form is closed by any means. Returns .T. if OK to close.
		*--
		  * If lSaveOnClose is not set, just close after form level valid passes
		  IF NOT THIS.lSaveOnClose
		    RETURN NOT THIS.cmDataManager.IsChanged(THIS.cSaveWorkarea) OR THIS.ValidateForm(THIS.cSaveWorkarea)
		  ENDIF
		
		  * Defer to standard save/cancel behavior
		  RETURN DODEFAULT(m.nReason)
		
	ENDPROC

	PROCEDURE Deactivate
		*++
		*>>Custom deactivate for frmDataChild forms.
		*--
		  IF NOT ISNULL(THIS.oCaller)
		    THIS.cmDataManager.SetActiveChildForm(.NULL.)
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS oCaller
		*++
		* Custom initialization code for frmDataChild
		*
		* The oCaller parameter is obsolete. A reference to the calling form is now set in the Load() method.
		*--
		  IF EMPTY(THIS.cWorkarea)
		    THIS.cWorkArea = THIS.oCaller.cWorkArea
		  ENDIF
		  IF EMPTY(THIS.cNavWorkarea)
		    THIS.cNavWorkArea = THIS.oCaller.cNavWorkArea
		  ENDIF
		  IF EMPTY(THIS.cListExpression) AND THIS.cWorkArea == THIS.oCaller.cWorkArea
		    THIS.cListExpression = THIS.oCaller.cListExpression
		  ENDIF
		
		  * Make sure change flag for the form is initially set correctly per data state.
		  THIS.lChanged = THIS.cmDataManager.IsChanged(THIS.cSaveWorkarea)
		
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE iseditallowed
		LPARAMETERS cWorkArea, cField
		*++
		*>>Controls whether or not data-bound controls in this child form may be edited.
		*--
		  IF NOT ISNULL(THIS.oCaller)    && Extra test here for cleaner recovery from errors.
		    RETURN DODEFAULT(@m.cWorkArea, @m.cField)
		  ENDIF
		  RETURN NOT THIS.lWriteLock
		
	ENDPROC

	PROCEDURE lexpliciteditmode_access		&& If null, return value from parent form.
		*++
		*>>If null, return value from parent form.
		*--
		  IF NOT ISNULL(THIS.oCaller) AND ISNULL(THIS.lExplicitEditMode)
		    RETURN THIS.oCaller.lExplicitEditMode
		  ENDIF
		  RETURN NVL(THIS.lExplicitEditMode, .F.)
		
	ENDPROC

	PROCEDURE Load
		*++
		*>>Custom Load event code for frmDataChild
		*--
		  SET TALK OFF         && Always force to OFF first to avoid spurious display output.
		
		  * Load a reference to the calling (parent) form, if it is available from the 
		  * custom _Screen property. We don't use _Screen.ActiveForm here so we can guarantee 
		  * consistant operation even if calling form is not currently active.
		  IF PEMSTATUS(_SCREEN, 'oCallingForm', 5)
		    IF NOT ISNULL(_SCREEN.oCallingForm)      && Override current oCaller only if not null.
		      THIS.oCaller = _SCREEN.oCallingForm
		      _SCREEN.oCallingForm = .NULL.
		    ENDIF
		  ENDIF
		
		  * Fail if we don't have a reference to the calling parent form.
		  IF VARTYPE(THIS.oCaller) != 'O'
		    ASSERT .F. MESSAGE THIS.Name + " frmDataChild forms must be opened via the parent's OpenChild() method"
		    RETURN .F.
		  ENDIF
		
		  THIS.cmDataManager = THIS.oCaller.cmDataManager
		  IF PEMSTATUS(THIS.oCaller, 'cmLookupManager', 5)   && (7.5) Lookup manager is optional in calling form
		    THIS.cmLookupManager = THIS.oCaller.cmLookupManager
		  ENDIF
		
		  * Make sure we don't create any local DM or LM, and call default load code.
		  STORE '' TO  THIS.cDataManagerClass, THIS.cLookupManagerClass
		  IF DODEFAULT()
		    * Warn if there are any cursors defined in a native DE for this form (there shouldnt be any).
		    ASSERT ISNULL(THIS.oCDE) MESSAGE THIS.Name + ': frmDataChild forms cannot have any Data Environment of their own'
		    THIS.oCDE = THIS.oCaller.oCDE
		    IF THIS.AfterLoad()   && Called now, after CDE reference is loaded.
		      RETURN .T.
		    ENDIF
		    RETURN THIS.Abort()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE lwritelock_access		&& Modeless child forms share a common write-lock setting with parent form.
		*++
		*>>Modeless child forms share a common write-lock setting with parent form.
		*--
		  IF NOT ISNULL(THIS.oCaller) AND THIS.lExplicitEditMode
		    RETURN THIS.oCaller.lWriteLock
		  ENDIF
		  RETURN THIS.lWriteLock
		
	ENDPROC

	PROCEDURE lwritelock_assign		&& Modeless child forms share a common write-lock setting with parent form.
		LPARAMETERS lValue
		*++
		*>>Modeless child forms share a common write-lock setting with parent form.
		*--
		  IF NOT ISNULL(THIS.oCaller) AND THIS.lExplicitEditMode
		    THIS.oCaller.lWriteLock = m.lValue
		  ENDIF
		  THIS.lWriteLock = m.lValue
		
	ENDPROC

	PROCEDURE openchild
		LPARAMETERS cClass, uArg1, uArg2, uArg3, uArg4, uArg5
		*++
		*>>Open a child (sibling) form, by passing this call to our parent form's OpenChild() method.
		*--
		  DO CASE
		    CASE PCOUNT() = 1
		      RETURN THIS.oCaller.OpenChild(@m.cClass)
		    CASE PCOUNT() = 2
		      RETURN THIS.oCaller.OpenChild(@m.cClass, @m.uArg1)
		    CASE PCOUNT() = 3
		      RETURN THIS.oCaller.OpenChild(@m.cClass, @m.uArg1, @m.uArg2)
		    CASE PCOUNT() = 4
		      RETURN THIS.oCaller.OpenChild(@m.cClass, @m.uArg1, @m.uArg2, @m.uArg3)
		    CASE PCOUNT() = 5
		      RETURN THIS.oCaller.OpenChild(@m.cClass, @m.uArg1, @m.uArg2, @m.uArg3, @m.uArg4)
		  ENDCASE
		  RETURN THIS.oCaller.OpenChild(@m.cClass, @m.uArg1, @m.uArg2, @m.uArg3, @m.uArg4, @m.uArg5)
		
	ENDPROC

	PROCEDURE setchanged
		LPARAMETERS lValue, cWorkarea
		*++
		*>>Set the child data form's lChanged flag to the specified value by dispatching to the parent form's SetChanged() method.
		*--
		  IF m.lValue AND EMPTY(m.cWorkarea)
		    * If no workarea is affected, then only set for this form.
		    THIS.lChanged = m.lValue
		  ELSE
		    * If a workarea is specified, set flag for parent and all children who share the workarea.
		    THIS.oCaller.SetChanged(m.lValue, @m.cWorkarea)
		  ENDIF
		  THIS.AfterStateChange(THIS.lChanged)
		  RETURN THIS.lChanged
		
	ENDPROC

	PROCEDURE Unload
		*++
		*>>Release the CDE when the form is unloaded
		*--
		  THIS.cmDataManager = .NULL.
		  THIS.cmLookupManager = .NULL.
		
		  * Clear ref to parent form, and do NOT call default 
		  * Unload() code, because we don't want to close the CDE now.
		  THIS.oCaller = .NULL.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmdataform AS frmformcustom OF "..\custom\cforms.vcx" 		&& CodeMine data-access form class
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: beforenav		&& Validate and commit changes as appropriate before changing current record.
		*m: closechild		&& Find an instance of the specified modeless child form, and close it by calling its Close() method.
		*m: cnavworkarea_assign		&& Make sure cNavWorkarea stays in Propercase format.
		*m: confirmdelete		&& Get user confirmation before deleting the current record. Returns .T./.F.
		*m: confirmsave		&& Get user confirmation before performinag an implicit save. Returns .T./.F./.Null.
		*m: csaveworkarea_assign		&& Make sure cSaveWorkarea stays in Propercase format.
		*m: cworkarea_assign		&& Make sure cWorkarea stays in Propercase format.
		*m: delete		&& Toolbar/button/menu interface to Delete the current record from the specified workarea, and make the next available record current.
		*m: edit		&& Toolbar/button/menu interface to Edit the current record, usually by displaying an editing dialog.
		*m: editmode		&& Toolbar/button/menu interface to Toggle Explicit-Edit mode.
		*m: find		&& Toolbar/button/menu interface to Find a record in the primary workarea by interactive key lookup.
		*m: first		&& Toolbar/button/menu interface to Move to the first record in the specified workarea.
		*m: goto		&& Toolbar/button/menu interface to Move to the specified record in the specified workarea.
		*m: last		&& Toolbar/button/menu interface to Move to the last record in the specified workarea.
		*m: list		&& Toolbar/button/menu interface to List available records in the primary workarea, in a separate browse window.
		*m: new		&& Toolbar/button/menu interface to Add a new record to the specified workarea, and make it the current record.
		*m: next		&& Toolbar/button/menu interface to Advance to the next record in the specified workarea.
		*m: openchild		&& Open a single instance of a modeless child data form, based on the frmDataChild class.
		*m: openmodalchild		&& Open a modal child data form, based on the frmModalDataChild class. Returns an object reference to the open (but not yet visible) form.
		*m: prior		&& Toolbar/button/menu interface to Move to the previous record in the specified workarea.
		*m: refreshall		&& Optimize display update by locking screen during refresh. Handles frmDataForm and frmDataChildForm based forms.
		*m: requery		&& Toolbar/button/menu interface to Requery a cursor
		*m: seek		&& Toolbar/button/menu interface to Move to a particular record based on primary key.
		*m: setfilter		&& Toolbar/button/menu interface to set a filter.
		*m: setorder		&& Toolbar/button/menu interface to set record sort order.
		*m: _releasedm		&& Unlink the Data Manager from the CDE.
		*p: cdatamanagerclass		&& Class name of custom programmatic Data Manager object to add to form on Load.
		*p: cfinddialogclass		&& Name of form class for the Find dialog. Must be a form class in a VCX library.
		*p: clistdialogclass		&& Name of form class for the List dialog window. Must be a form class in a VCX library.
		*p: clistexpression		&& Display Expression evaluated for each row in the "List Records" dialog, to build the string displayed in the single column. The List option is disabled if empty.
		*p: clookupmanagerclass		&& Class name of custom programmatic Lookup Manager object to add to form on Load.
		*p: cmsgconfirmdelete		&& Message key/text used for the Delete Confirmation dialog
		*p: cmsgconfirmsave		&& Message key/text used for the Save Confirmation dialog
		*p: cnavworkarea		&& Workarea toolbar buttons apply to. Leave empty to default to the same as cWorkarea.
		*p: crequerydialogclass		&& Name of form class for the Requery dialog. Must be a form class in a VCX library.
		*p: csaveworkarea		&& Root workarea for Save()/Revert() methods. * means all workareas.
		*p: cworkarea		&& Primary workarea name for the form, and default navigation workarea.
		*p: lallowdelete		&& Set .T. to allow deleting records via the "Delete" menu/toolbar option for the form.
		*p: lallowedit		&& Set .T. to enable the "Edit" menu/toolbar option for the form.
		*p: lallownavigation		&& Set to .T. to enable sequential record navigation menu/toolbar options for the form.
		*p: lallownew		&& Set .T. to allow adding new records via the "New" menu/toolbar option for the form.
		*p: lautorequery		&& For client/server forms, when set to .T. and cRequeryDialogClass is set, a requery is performed on form startup
		*p: lconfirmdelete		&& Contains default setting for delete confirmation dialog enable. Set to .NULL. to override at runtime with the "%Local.Data Entry.Confirm Delete" key.
		*p: lconfirmsave		&& Contains default setting for save-on-navigate confirmation dialog enable. Set to .NULL. to override at runtime with the "%Local.Data Entry.Confirm Save on Navigate" key.
		*p: lexpliciteditmode		&& Set to .T. if user must explicitly enable edit mode to modify any form data.
		*p: lexpliciteditmodelock		&& Indicates if edit mode is locked on or not. Set to .T. at design time to enable editmode lock. Set to .NULL. to disable.
		*p: lrememberorder		&& Remember the current record order for tables, and restore on next open
		*p: lrememberrecord		&& Remember the current record position for tables, and restore on next open
		*p: nchildrefreshmode		&& Controls how child forms are refreshed on navigation. 1=Refresh active child only, 2=Refresh parent and active child, 3=Refresh parent and all children.
		*p: nnavupdatemode		&& Determines how unrelated cursors are updated when primary cursor moves. 0=Don't update, 1=Update.
	*</DefinedPropArrayMethod>

	BufferMode = 2
	Caption = "CodeMine Data Form"
	cclass = frmDataForm
	cdataenvironment = cmDataEnvironmentCustom
	cdatamanagerclass = 		&& Class name of custom programmatic Data Manager object to add to form on Load.
	cfinddialogclass = frmFindDialog		&& Name of form class for the Find dialog. Must be a form class in a VCX library.
	clistdialogclass = frmDataListForm		&& Name of form class for the List dialog window. Must be a form class in a VCX library.
	clistexpression = 		&& Display Expression evaluated for each row in the "List Records" dialog, to build the string displayed in the single column. The List option is disabled if empty.
	clookupmanagerclass = 		&& Class name of custom programmatic Lookup Manager object to add to form on Load.
	cmsgconfirmdelete = %msgConfirmDelete		&& Message key/text used for the Delete Confirmation dialog
	cmsgconfirmsave = %msgConfirmSave		&& Message key/text used for the Save Confirmation dialog
	cnavworkarea = 		&& Workarea toolbar buttons apply to. Leave empty to default to the same as cWorkarea.
	crequerydialogclass = 		&& Name of form class for the Requery dialog. Must be a form class in a VCX library.
	csaveworkarea = *		&& Root workarea for Save()/Revert() methods. * means all workareas.
	cworkarea = 		&& Primary workarea name for the form, and default navigation workarea.
	DataSession = 2
	DoCreate = .T.
	lallowdelete = .T.		&& Set .T. to allow deleting records via the "Delete" menu/toolbar option for the form.
	lallowedit = .T.		&& Set .T. to enable the "Edit" menu/toolbar option for the form.
	lallownavigation = .T.		&& Set to .T. to enable sequential record navigation menu/toolbar options for the form.
	lallownew = .T.		&& Set .T. to allow adding new records via the "New" menu/toolbar option for the form.
	lautorequery = .F.		&& For client/server forms, when set to .T. and cRequeryDialogClass is set, a requery is performed on form startup
	lconfirmdelete = .NULL.		&& Contains default setting for delete confirmation dialog enable. Set to .NULL. to override at runtime with the "%Local.Data Entry.Confirm Delete" key.
	lconfirmsave = .NULL.		&& Contains default setting for save-on-navigate confirmation dialog enable. Set to .NULL. to override at runtime with the "%Local.Data Entry.Confirm Save on Navigate" key.
	lexpliciteditmode = .F.		&& Set to .T. if user must explicitly enable edit mode to modify any form data.
	lexpliciteditmodelock = .NULL.		&& Indicates if edit mode is locked on or not. Set to .T. at design time to enable editmode lock. Set to .NULL. to disable.
	lignoreboundproperties = .T.
	lrememberorder = .F.		&& Remember the current record order for tables, and restore on next open
	lrememberposition = .T.
	lrememberrecord = .T.		&& Remember the current record position for tables, and restore on next open
	lremembersize = .T.
	Name = "frmdataform"
	nchildrefreshmode = 3		&& Controls how child forms are refreshed on navigation. 1=Refresh active child only, 2=Refresh parent and active child, 3=Refresh parent and all children.
	nnavupdatemode = 1		&& Determines how unrelated cursors are updated when primary cursor moves. 0=Don't update, 1=Update.
	omessage = .NULL.
	oregistry = .NULL.
	osecurity = .NULL.
	
	PROCEDURE abort
		*++
		*>>Clean up form for release on aborted Load() or Init() events.
		*--
		  THIS._ReleaseDM()
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE beforechange
		LPARAMETERS cWorkarea
		*++
		*>>Called when a data-bound control is modified in a frmDataForm. Return .T. if ok to change.
		*--
		LOCAL lWasChanged
		  * Note that we do not test for readonly state of data at this point. It is the 
		  * responisbility of the caller to determine if cursor is writeable.
		  IF NOT THIS.lWriteLock ;
		  AND (EMPTY(m.cWorkarea) OR THIS.cmDataManager.LockForEdit(@m.cWorkarea))
		    IF NOT EMPTY(m.cWorkarea) OR NOT THIS.lIgnoreBoundProperties
		      m.lWasChanged = THIS.lChanged
		
		      * Always re-set change flags, so child forms with 
		      * different cSaveWorkarea settings will always be updated correctly.
		      THIS.SetChanged(.T., m.cWorkarea)
		      IF NOT m.lWasChanged
		        * Refresh all objects associated with the Form Edit states and actions.
		        IF NOT ISNULL(THIS.oStateManager)
		          * We refresh all form states here. This normally results in a few unnecessary 
		          * buttons being refreshed the first time a change is made to a form control.
		          * This is only a small bit of extra overhead, and makes it easier to 
		          * customize the behaviour for people who want to disable everything when 
		          * the form has uncommited changes.
		          THIS.oStateManager.RefreshAll('Form')
		        ENDIF
		      ENDIF
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE beforeclose
		LPARAMETERS nCloseReason
		*++
		*>>Save or discard any changes, and return .T. if the form can be closed.
		* Provides default behavior for frmDataForm. Individual forms may 
		* subclass this method if necessary.
		*--
		LOCAL lStatus, lCloseForm, lActive, lChanged, cWorkareaList
		
		  * Parent forms must always check all workareas before closing, regardless of cSaveWorkarea
		  IF VARTYPE(THIS.oCaller) == 'O'   && True if this is a child data form
		    m.cWorkareaList = THIS.cSaveWorkarea
		  ELSE
		    m.cWorkareaList = '*'               && Parent (or only) form
		  ENDIF
		
		  * In obsure cases after other errors, QueryUnload() can call us when DM is no longer 
		  * there, so we should check for that case here to close gracefully after errors.
		  IF TYPE('THIS.cmDataManager') != 'O'
		    m.lCloseForm = .T.
		  ELSE
		    * Make sure we use an accurate change flag setting, ignoring any false-positive 
		    * from the current control if no data was actually changed.
		    m.lChanged = THIS.cmDataManager.IsChanged(m.cWorkareaList)
		
		    m.lActive = BITTEST(THIS.nControlFlags , FRMFLAG_ACTIVE)
		    IF INLIST(m.nCloseReason, CLOSE_BY_CANCEL)
		      m.lCloseForm = THIS.Cancel(m.cWorkareaList)                && Same as toolbar cancel
		    ELSE
		      * Never need confirmation if no changes, or for OK/Apply close reasons.
		      m.lStatus = NOT m.lChanged ;
		                  OR INLIST(m.nCloseReason, CLOSE_BY_OK, CLOSE_BY_APPLY) OR THIS.ConfirmClose()
		      DO CASE
		        CASE ISNULL(m.lStatus)            && If User said 'Cancel' just return failure status
		          m.lCloseForm = .F.
		        CASE NOT m.lStatus
		          m.lCloseForm = THIS.CancelAllChanges(m.cWorkareaList)  && Cancel changes, no confirm.
		          * If this is a child form, refresh parent and all other children after cancel.
		          IF PEMSTATUS(THIS, 'oCaller', 5)
		            THISFORM.RefreshAll()
		          ENDIF
		        OTHERWISE
		          m.lCloseForm = THIS.Save(m.cWorkareaList)              && Same as toolbar Save
		      ENDCASE
		    ENDIF
		  ENDIF
		
		  IF m.lCloseForm
		    * Release all child forms on close.
		    IF VARTYPE(THIS.cmChildFormCollection) == 'O'
		      m.lCloseForm = THIS.cmChildFormCollection.Clear()
		    ENDIF
		
		    * Confirmation dialogs may deactivate us, but if we were originally active
		    * we need to clean up menu context, so re-set active flag.
		    IF m.lActive
		      THIS.nControlFlags  = BITSET(THIS.nControlFlags , FRMFLAG_ACTIVE)  && Mark us as the active form.
		    ENDIF
		  ENDIF
		  RETURN m.lCloseForm
		
	ENDPROC

	PROCEDURE beforenav		&& Validate and commit changes as appropriate before changing current record.
		LPARAMETERS cWorkarea, lForceConfirm
		*++
		*>>Validate and commit changes as appropriate before changing current record.
		*  The cWorkarea parameter is required, and specifies the workarea being navigated in.
		*  The lForceConfirm parameter forces confirmation dialog if set to .t.
		*--
		LOCAL lStatus, cWorkareaList
		
		  * The workarea being navigated determines which workarea(s) need to be
		  * checked for changes and/or saved. Force all to Proper case for comparisons.
		  * Note that the primary workarea (cWorkarea) should always be one of
		  * the workareas listed in cSaveWorkarea.
		  m.cWorkarea = PROPER(m.cWorkarea)
		  m.cWorkareaList = IIF(m.cWorkarea == THIS.cWorkarea, THIS.cSaveWorkarea, m.cWorkarea)
		
		  * Validation is needed for all in cSaveWorkarea if:
		  *  1) Current record of cWorkarea (or any child record) is changed, or
		  *  2) cWorkarea is the primary workarea and nNavUpdateMode=1 and any changed in any other cSaveWorkarea cursor
		  IF THIS.cmDataManager.IsRecordChanged(@m.cWorkarea) ;
		  OR (m.cWorkarea == THIS.cWorkarea AND THIS.nNavUpdateMode = 1 AND THIS.cmDataManager.IsChanged(THIS.cSaveWorkarea, @m.cWorkarea))
		    * If row buffering is in effect, we need to save changes before moving record pointer
		    * The buffering mode of the WA being navigated in determines the behavior.
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_NAVIGATING)
		    IF THIS.cmDataManager.GetBufferMode(m.cWorkarea) <= 3
		      m.lStatus = THIS.ConfirmSave(m.cWorkarea,, m.lForceConfirm)
		      DO CASE
		        CASE ISNULL(m.lStatus)
		          m.lStatus = .F.
		        CASE NOT m.lStatus
		          m.lStatus = THIS.CancelAllChanges(m.cWorkareaList)
		        OTHERWISE
		          m.lStatus = THIS.ValidateForm(m.cWorkareaList) AND THIS.SaveAllChanges(m.cWorkareaList)
		      ENDCASE
		    ELSE
		      m.lStatus = THIS.ValidateForm(m.cWorkareaList)
		    ENDIF
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, FRMFLAG_NAVIGATING)
		    RETURN m.lStatus
		  ELSE  && Current record is not changed.
		    * Re-enable writelock in explicit edit mode for row-buffered cursors.
		    IF THIS.lExplicitEditMode AND NOT NVL(THIS.lExplicitEditModeLock, .F.) ;
		    AND THIS.cmDataManager.GetBufferMode(m.cWorkarea) <= 3
		      THIS.lWriteLock = .T.
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE cancel
		LPARAMETERS cWorkareaList
		*++
		*>>Toolbar/button/menu interface to discard all changes to all workareas.
		*--
		LOCAL lStatus
		  IF EMPTY(m.cWorkareaList)
		    m.cWorkareaList = THIS.cSaveWorkarea
		  ENDIF
		
		  * If no data is reported changed, we do the cancel anyway, and refresh the form. This
		  * handles the case where a text/edit box has been edited, but has not lost focus yet,
		  * so the bound data has not been changed. If data manager reports data changed, then
		  * we only proceed after user confirmation.
		  IF NOT THIS.cmDataManager.IsChanged(m.cWorkareaList) OR THIS.ConfirmCancel()
		    * We need to move off current control, especially if in a grid. But skip validation.
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_SKIP_VALID)
		    IF THIS.FlushControlBuffer()
		      m.lStatus = THIS.CancelAllChanges(m.cWorkareaList)
		      THIS.RefreshAll()
		      THIS.ActivateNextControl(.NULL., .T.)
		    ENDIF
		    THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, FRMFLAG_SKIP_VALID)
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE cancelallchanges
		LPARAMETERS cWorkareaList
		*++
		*>>Cancel all changes. Called by Cancel() and whenever form closes without saving changes.
		*--
		  IF THIS.cmDataManager.RevertAll(m.cWorkareaList)
		    * Re-enable writelock if explicit editmode is enabled.
		    IF THIS.lExplicitEditMode AND NOT NVL(THIS.lExplicitEditModeLock,.F.)
		      THIS.lWriteLock = .T.
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE closechild		&& Find an instance of the specified modeless child form, and close it by calling its Close() method.
		LPARAMETERS cClass
		*++
		*>>Find an instance of the specified modeless child form, and close it by calling its Close() method.
		*--
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		  IF PEMSTATUS(THIS, 'cmChildFormCollection', 5)
		    RETURN THIS.cmChildFormCollection.Remove(m.cClass)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE cnavworkarea_assign		&& Make sure cNavWorkarea stays in Propercase format.
		LPARAMETERS cValue
		*++
		*>>Make sure cNavWorkarea stays in Propercase format.
		*--
		  THIS.cNavWorkarea = PROPER(ALLTRIM(m.cValue))
		
	ENDPROC

	PROCEDURE confirmdelete		&& Get user confirmation before deleting the current record. Returns .T./.F.
		LPARAMETERS cWorkarea, cParameter
		*++
		*>>Get user confirmation before deleting the current record. Returns .T./.F.
		*
		* cWorkarea -  May be used by subclasses to selectively issue confirmations.
		* cParameter - Is passed on as a parameter to the confirmation message text.
		*              The default message accepts no parameters.
		*--
		  IF THIS.lConfirmDelete AND NOT ISNULL(THIS.oMessage) AND NOT EMPTY(THIS.cMsgConfirmDelete)
		    IF EMPTY(m.cParameter)
		      * Default parameter is the localized workarea name.
		      m.cParameter = THIS.NiceCursorName(m.cWorkarea)
		    ENDIF
		    RETURN THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_YN, MSG_SEVERITY_QUESTION, ;
		                                THIS.cMsgConfirmDelete,, THISFORM.Caption, m.cParameter)
		  ENDIF
		  RETURN .T.  && Confirmation not required, or no message manager available.
		
	ENDPROC

	PROCEDURE confirmsave		&& Get user confirmation before performinag an implicit save. Returns .T./.F./.Null.
		LPARAMETERS cWorkarea, cParameter, lForce
		*++
		*>>Get user confirmation before performinag an implicit save. Returns .T./.F./.Null.
		* Return values:
		*     .T. Changes should be saved (Yes)
		*        .F. Changes should be discarded (No)
		*        .Null. Do nothing, return failure code to caller (Cancel)
		*
		* cWorkarea -  May be used by subclasses to selectively issue confirmations.
		* cParameter - Is passed on as a parameter to the confirmation message text.
		*              The default message accepts no parameters.
		*--
		  IF NOT ISNULL(THIS.oMessage) AND NOT EMPTY(THIS.cMsgConfirmSave)
		    RETURN (NOT m.lForce AND NOT THIS.lConfirmSave) ;
		           OR THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_YNC, MSG_SEVERITY_QUESTION, THIS.cMsgConfirmSave,, THISFORM.Caption)
		  ENDIF
		  RETURN .T.   && No message manager, so we can't display confirmation dialog.
		
	ENDPROC

	PROCEDURE contextmenubuild
		*++
		*>>Define all the bars for a context menu. Return true if no bars are defined
		*--
		LOCAL nEditmode
		  DODEFAULT()
		  m.nEditmode = THIS.IsEnabled('Editmode')
		  IF NOT EMPTY(m.nEditmode)
		    THISFORM.ContextMenuSeparator(CTX_BAR_FRM_SEP2)
		    THISFORM.ContextMenuBar(CTX_BAR_FRM_EDITMODE, '%barEditmode')
		    IF m.nEditmode > 1
		      THISFORM.ContextMenuBarCheck(CTX_BAR_FRM_EDITMODE, .T.)
		    ENDIF
		    IF m.nEditmode == 2
		      THISFORM.ContextMenuBarDisable(CTX_BAR_FRM_EDITMODE, .T.)
		    ENDIF
		  ENDIF
		
		  THISFORM.ContextMenuSeparator(CTX_BAR_FRM_SEP3)
		  THISFORM.ContextMenuBar(CTX_BAR_FRM_SAVE, '%barSaveForm')
		  THISFORM.ContextMenuBar(CTX_BAR_FRM_CANCEL, '%barRevertForm')
		  IF NOT THIS.IsEnabled('Save')
		    THISFORM.ContextMenuBarDisable(CTX_BAR_FRM_SAVE, .T.)
		  ENDIF
		  IF NOT THIS.IsEnabled('Cancel')
		    THISFORM.ContextMenuBarDisable(CTX_BAR_FRM_CANCEL, .T.)
		  ENDIF
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETERS cOption
		*++
		*>>Execute the selected context menu item.
		* Usually called from context menu 
		* activation, but may also be called directly under program control to simulate user action.
		* Returns true if the option was handled by this method.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%bareditmode'
		      THIS.Editmode()
		    CASE m.cOption = '%barsaveform'
		      THIS.Save()
		    CASE m.cOption = '%barrevertform'
		      THIS.Cancel()
		    OTHERWISE
		      RETURN DODEFAULT(m.cOption)
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE csaveworkarea_assign		&& Make sure cSaveWorkarea stays in Propercase format.
		LPARAMETERS cValue
		*++
		*>>Make sure cSaveWorkarea stays in Propercase format.
		*--
		  THIS.cSaveWorkarea = CHRTRAN(PROPER(CHRTRAN(ALLTRIM(m.cValue), ',', ' ')), ' ', ',')
		
	ENDPROC

	PROCEDURE cworkarea_assign		&& Make sure cWorkarea stays in Propercase format.
		LPARAMETERS cValue
		*++
		*>>Make sure cWorkarea stays in Propercase format.
		*--
		  THIS.cWorkarea = PROPER(ALLTRIM(m.cValue))
		
	ENDPROC

	PROCEDURE delete		&& Toolbar/button/menu interface to Delete the current record from the specified workarea, and make the next available record current.
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to Delete the current record from the specified workarea, and make the next available record current.
		*--
		LOCAL lStatus
		  * Default to the form's navigation workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.ConfirmDelete(m.cWorkarea)
		    IF THIS.cmDataManager.Delete(PROPER(m.cWorkarea))
		      m.lStatus = .T.
		
		      * Turn off editmode if we just deleted the primary cursor record, in row-buffer mode.
		      IF THIS.lExplicitEditMode AND NOT NVL(THIS.lExplicitEditModeLock,.F.) ;
		      AND PROPER(m.cWorkarea) == THIS.cWorkarea AND THIS.cmDataManager.GetBufferMode(m.cWorkarea) <= 3
		        THIS.lWriteLock = .T.
		      ENDIF
		    ENDIF
		
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE Destroy
		  * Close the list window if it is open.
		  IF VARTYPE(THIS.oListForm) = 'O'
		    THIS.oListForm.Release()
		  ENDIF
		  IF VARTYPE(THIS.oFindDialog) = 'O'
		    THIS.oFindDialog.Release()
		  ENDIF
		
		  IF TYPE('THIS.cmDataManager.Name') == 'C'
		    THIS.cmDataManager.UnregisterNavControls(THIS)
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE edit		&& Toolbar/button/menu interface to Edit the current record, usually by displaying an editing dialog.
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to Edit the current record, usually by displaying an editing dialog.
		*--
		LOCAL lStatus
		  * Default to the form's navigation workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    m.lStatus = THIS.cmDataManager.Edit(PROPER(m.cWorkarea))
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE editmode		&& Toolbar/button/menu interface to Toggle Explicit-Edit mode.
		*++
		*>>Toolbar/button/menu interface to Toggle Explicit-Edit mode.
		* If pessimistic buffering, Current record in primary WA is locked before edits are allowed.
		*--
		  IF THIS.lExplicitEditMode
		    IF THIS.lWriteLock
		      * Enable edit-mode and unlock write access to the form
		      IF EMPTY(THIS.cWorkarea) OR THIS.cmDataManager.LockforEdit(THIS.cWorkarea)
		        THIS.lWriteLock = .F.
		
		        * Ctrl+Click means to lock edit mode right away, if editLock is enabled.
		        IF NOT ISNULL(THIS.lExplicitEditModeLock)
		          THIS.lExplicitEditModeLock = cmKeyModifier() > 1
		        ENDIF
		        THIS.RefreshAll()
		        THIS.ActivateNextControl()
		      ENDIF
		    ELSE
		      * If edit mode active but not locked, lock it now.
		      IF NOT THIS.lExplicitEditModeLock    && NULL will take the ELSE case here.
		        THIS.lExplicitEditModeLock = .T.
		      ELSE
		        * Otherwise, Disable edit-mode by locking write access to the form
		        THIS.cmDataManager.RevertAll()   && Cancel any locks (should never get here if any changes exist)
		        THIS.lWriteLock = .T.            && Turn edit mode back off
		        IF NOT ISNULL(THIS.lExplicitEditModeLock)
		          THIS.lExplicitEditModeLock = .F.
		        ENDIF
		      ENDIF
		      THIS.RefreshAll()
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE find		&& Toolbar/button/menu interface to Find a record in the primary workarea by interactive key lookup.
		LPARAMETERS cWorkarea, cExpr
		*++
		*>>Toolbar/button/menu interface to Find a record in the primary workarea by interactive key lookup.
		*--
		LOCAL lStatus, cWorkarea
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      * If no cFindDialogClass specified, and a find expr is specified, 
		      * we displatch to the data manager to directly find the record.
		      IF NOT EMPTY(m.cExpr)
		        m.lStatus = THIS.cmDataManager.Find(m.cExpr, PROPER(m.cWorkarea))
		      ELSE
		        IF NOT EMPTY(THIS.cFindDialogClass)
		          THIS.RefreshAll()  && In case BeforeNav() did a Revert()
		          IF VARTYPE(THIS.oFindDialog) != 'O'
		            THIS.oFindDialog = THIS.OpenModalChild(THIS.cFindDialogClass, THIS, m.cWorkarea)
		          ENDIF
		          IF VARTYPE(THIS.oFindDialog) = 'O'
		            m.lStatus = THIS.oFindDialog.Show()
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE first		&& Toolbar/button/menu interface to Move to the first record in the specified workarea.
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to Move to the first record in the specified workarea.
		*--
		LOCAL lStatus
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      m.lStatus = THIS.cmDataManager.GoTop(PROPER(m.cWorkarea))
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE formvalid
		LPARAMETERS cWorkareaList
		*++
		*>>Custom developer-supplied Form level validation code, called by ValidateForm().
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE goto		&& Toolbar/button/menu interface to Move to the specified record in the specified workarea.
		LPARAMETERS nRecno, cWorkarea
		*++
		*>>Toolbar/button/menu interface to Move to the specified record in the specified workarea.
		*--
		LOCAL lStatus
		  * Default to the form's navigation workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      m.lStatus = THIS.cmDataManager.GoTo(m.nRecno, PROPER(m.cWorkarea))
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE Init
		*++
		* Custom init code to implement the auto-requery feature.
		*--
		  IF THIS.lAutoRequery AND NOT THIS.Requery()
		    RETURN THIS.Abort()
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE iseditallowed
		LPARAMETERS cWorkArea, cField
		*++
		*>>Controls whether or not data-bound controls in this form may be edited.
		* A cursor is read-only at the form level if it is physically read-only, 
		* has no data (record at EOF) or form.lWriteLock is enabled.
		*--
		  IF NOT EMPTY(m.cWorkArea)
		    * DataManager may not exist (due to creation error), or not be available if too high
		    * in Z order of VCX forms (even though PEMSTATUS would say it is there, it really might not be).
		    IF TYPE('THIS.cmDataManager.Name') = 'C'
		      RETURN NOT THIS.lWriteLock AND NOT ISNULL(THIS.oCDE) ;
		             AND NOT THIS.cmDataManager.IsReadOnly(@m.cWorkarea) ;
		             AND THIS.cmDataManager.IsEditAllowed(@m.cWorkarea, IIF(EMPTY(m.cField), '', PROPER(m.cField)))
		    ELSE
		      RETURN .F.
		    ENDIF
		  ENDIF
		  RETURN NOT THIS.lWriteLock
		
	ENDPROC

	PROCEDURE isempty
		LPARAMETERS cWorkArea
		*++
		*>>Return true if the specified workarea is empty - if it has no available records.
		*--
		  IF NOT EMPTY(m.cWorkArea) AND NOT ISNULL(THIS.oCDE)
		    RETURN THIS.cmDataManager.IsEmpty(PROPER(m.cWorkarea))
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE isenabled
		LPARAMETERS cMethod, cWorkArea
		*++
		*>>Used to determine whether or not the specified form method is enabled or disabled (ie can be called) at the current time.
		*--
		LOCAL cNavWorkarea
		
		  m.cMethod = PROPER(m.cMethod)
		  m.cNavWorkarea = IIF(EMPTY(m.cWorkarea), THIS.cNavWorkarea, m.cWorkarea)
		
		  DO CASE
		    CASE m.cMethod == 'Save' OR m.cMethod == 'Cancel'
		      RETURN NOT EMPTY(THIS.cWorkarea) AND THIS.lChanged
		
		    CASE m.cMethod == 'Requery'
		      RETURN NOT EMPTY(THIS.cWorkarea) AND NOT EMPTY(THIS.cRequeryDialogClass)
		
		    CASE m.cMethod == 'Editmode'
		      * 0 - Up/disabled = Edit mode not supported, or no data record.
		      * 1 - Up/enabled = Form with explicit edit mode
		      * 2 - Dn/Disable = Form with explicit edit mode in progress
		      * 3 - Dn/Enabled = Edit mode selected, but no changes made yet.
		      * 4 - Dn&lock/Disabled = Edit mode locked, changes in progress.
		      * 5 - Dn&lock/Enabled = Edit mode locked, but no changes made yet.
		      IF THIS.lExplicitEditMode AND (EMPTY(THIS.cWorkarea) ;
		      OR (NOT THIS.cmDataManager.IsEof(THIS.cWorkarea) ;
		      AND NOT THIS.cmDataManager.IsReadOnly(THIS.cWorkarea)))
		        RETURN IIF(THIS.lWriteLock, 0, 2 + IIF(NVL(THIS.lExplicitEditModeLock,.F.), 2, 0)) + IIF(THIS.lChanged, 0, 1)
		      ENDIF
		      RETURN 0
		
		    CASE m.cMethod == 'List'
		      * Find and list are enabled if Primary workarea is Nav workarea, and >0 records exist.
		      m.cWorkarea = IIF(EMPTY(m.cWorkarea), THIS.cWorkarea, m.cWorkarea)
		      RETURN NOT EMPTY(THIS.cListDialogClass) AND NOT EMPTY(THIS.cListExpression) ;
		             AND NOT EMPTY(m.cWorkarea) AND NOT THIS.cmDataManager.IsEmpty(m.cWorkarea)
		
		    CASE m.cMethod == 'Find'
		      * Find is enabled when a Find Dialog class is specified, primary cursor has records, and
		      * the lookup tag list for the workarea is non-empty.
		      m.cWorkarea = IIF(EMPTY(m.cWorkarea), THIS.cWorkarea, m.cWorkarea)
		      IF NOT EMPTY(THIS.cFindDialogClass) AND NOT EMPTY(m.cWorkarea) AND NOT THIS.cmDataManager.IsEmpty(m.cWorkarea)
		        IF PEMSTATUS(THIS, 'cmLookupManager', 5)
		          RETURN NOT EMPTY(THIS.cmLookupManager.GetLookupTagList(m.cWorkarea))
		        ENDIF
		      ENDIF
		      RETURN .F.
		
		    CASE m.cMethod == 'Setorder'
		      m.cWorkarea = IIF(EMPTY(m.cWorkarea), THIS.cWorkarea, m.cWorkarea)
		      IF NOT EMPTY(m.cWorkarea)
		        IF PEMSTATUS(THIS, 'cmLookupManager', 5)
		          LOCAL cTagList
		          m.cTagList = THIS.cmLookupManager.GetOrderTagList(m.cWorkarea)
		          IF ',' $ m.cTagList
		            RETURN THIS.cmLookupManager.GetDisplayNameFromTag(ORDER(m.cWorkarea), m.cWorkarea) ;
		                   + ',' + THIS.cmLookupManager.GetOrderTagList(m.cWorkarea)
		          ELSE
		            RETURN ''
		          ENDIF
		        ENDIF
		      ENDIF
		      RETURN .F.
		
		    CASE m.cMethod $ 'Next,Last'
		      RETURN NOT EMPTY(m.cNavWorkarea) AND THIS.lAllowNavigation AND NOT THIS.cmDataManager.IsBottom(m.cNavWorkarea)
		
		    CASE m.cMethod $ 'Prior,First'
		      RETURN NOT EMPTY(m.cNavWorkarea) AND THIS.lAllowNavigation AND NOT THIS.cmDataManager.IsTop(m.cNavWorkarea)
		
		    CASE m.cMethod == 'New'
		      RETURN NOT EMPTY(m.cNavWorkarea) AND THIS.lAllowNew AND THIS.cmDataManager.IsNewAllowed(m.cNavWorkarea)
		
		    CASE m.cMethod == 'Delete'
		      RETURN NOT EMPTY(m.cNavWorkarea) AND THIS.lAllowDelete AND THIS.cmDataManager.IsDeleteAllowed(m.cNavWorkarea)
		
		    CASE m.cMethod == 'Edit'
		      * This enables the edit button even on read-only cursors. This allows the an edit 
		      * dialog to display in read-only mode as well as full editing mode.
		      RETURN NOT EMPTY(m.cNavWorkarea) AND THIS.lAllowEdit AND THIS.cmDataManager.IsEditAllowed(m.cNavWorkarea)
		  ENDCASE
		  RETURN DODEFAULT(@m.cMethod, @m.cWorkArea)
		
	ENDPROC

	PROCEDURE isnew
		LPARAMETERS cWorkArea
		*++
		*>>Return true if the current record in specified workarea is newly appended.
		*--
		  IF NOT EMPTY(m.cWorkArea) AND NOT ISNULL(THIS.oCDE)
		    RETURN THIS.cmDataManager.IsNew(PROPER(m.cWorkarea))
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE last		&& Toolbar/button/menu interface to Move to the last record in the specified workarea.
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to Move to the last record in the specified workarea.
		*--
		LOCAL lStatus
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      m.lStatus = THIS.cmDataManager.GoBottom(PROPER(m.cWorkarea))
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE list		&& Toolbar/button/menu interface to List available records in the primary workarea, in a separate browse window.
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to List available records in the primary workarea, in a separate browse window.
		*--
		LOCAL lStatus
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    * If this or any child is changed, Validate it and children
		    IF THIS.BeforeNav(m.cWorkarea) AND NOT EMPTY(THIS.cListDialogClass)
		      THIS.RefreshAll()  && In case BeforeNav() did a Revert()
		
		      * Create or re-activate the list records form. Must share our private datasession
		      * so we can't use statemanager form creation methods.
		      IF ISNULL(THIS.oListForm)
		        THIS.oListForm = THIS.OpenModalChild(THIS.cListDialogClass, THIS, m.cWorkarea, THIS.cListExpression)
		      ENDIF
		      THIS.oListForm.Show()
		      RETURN .T.
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Load
		*++
		* Custom load behaviour for data forms and data child forms.
		*--
		  SET TALK OFF         && Always force to OFF first, in case of private data session
		
		  THIS.AddProperty('oListForm', .NULL.)    && Runtime Object reference to the cListDialogClass form if it is open.
		  THIS.AddProperty('oFindDialog', .NULL.)  && Runtime Object reference to modeless Find Dialog.
		
		  * Remember which data entry preference properties we should read from app-registry settings.
		  IF ISNULL(THIS.lConfirmSave)
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_READ_CONFIRMSAVE)
		  ENDIF
		  IF ISNULL(THIS.lConfirmDelete)
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_READ_CONFIRMDELETE)
		  ENDIF
		
		  IF DODEFAULT()
		    * Make sure these are proper case, for consistent comparisons.
		    THIS.cWorkarea = PROPER(THIS.cWorkarea)
		    THIS.cNavWorkarea = PROPER(THIS.cNavWorkarea)
		    THIS.cSaveWorkarea = CHRTRAN(PROPER(CHRTRAN(ALLTRIM(THIS.cSaveWorkarea), ',', ' ')), ' ', ',')
		
		    IF NOT 'datachild' $ PROPER(THIS.cClass)
		      THIS.AddProperty('oActiveChild', .NULL.)  && Reference to active (modal or modeless) child form.
		
		      * Add a custom data manager object if one is specified.
		      IF NOT PEMSTATUS(THIS, 'cmDataManager', 5)
		        THIS.AddNewObject('cmDataManager', IIF(EMPTY(THIS.cDataManagerClass), 'cmDataManager', THIS.cDataManagerClass), .T.)
		        * If no data manager could be created, we must abort the form.
		        IF NOT PEMSTATUS(THIS, 'cmDataManager', 5)
		          RETURN THIS.Abort()
		        ENDIF
		      ENDIF
		
		      * Add a custom lookup manager object if one is specified.
		      IF NOT PEMSTATUS(THIS, 'cmLookupManager', 5)
		        IF NOT EMPTY(THIS.cLookupManagerClass)
		          THIS.AddNewObject('cmLookupManager', THIS.cLookupManagerClass)
		        ENDIF
		      ENDIF
		
		      * Writelock the form if explicit editmode is enabled
		      IF THIS.lExplicitEditMode
		        THIS.lWriteLock = .T.
		      ENDIF
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE new		&& Toolbar/button/menu interface to Add a new record to the specified workarea, and make it the current record.
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to Add a new record to the specified workarea, and make it the current record.
		*--
		LOCAL lStatus
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      * Add a new record. Insert trigger will fire now if no buffering is in effect.
		      IF THIS.cmDataManager.New(PROPER(m.cWorkarea))
		        m.lStatus = .T.
		        IF THIS.lExplicitEditMode
		          THIS.lWriteLock = .F.
		        ENDIF
		      ENDIF
		    ENDIF
		
		    * Refresh even if no new record added, since BeforeNew() may have moved recptr(s).
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE next		&& Toolbar/button/menu interface to Advance to the next record in the specified workarea.
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to Advance to the next record in the specified workarea.
		*--
		LOCAL lStatus
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      m.lStatus = THIS.cmDataManager.Skip(1, PROPER(m.cWorkarea))
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE openchild		&& Open a single instance of a modeless child data form, based on the frmDataChild class.
		LPARAMETERS cClass, uArg1, uArg2, uArg3, uArg4, uArg5, uArg6
		*++
		*>>Open a single instance of a modeless child data form, based on the frmDataChild class.
		*--
		LOCAL oForm
		  * If the child form collection does not exist yet, create it.
		  IF NOT PEMSTATUS(THIS, 'cmChildFormCollection', 5)
		    THIS.AddNewObject('cmChildFormCollection', THIS.oStateManager.cCollectionManagerClass)
		  ENDIF
		
		  * Localize the class name if necessary.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cClass = THIS.oMessage.LocalizeClass(m.cClass)
		  ENDIF
		
		  * Create and show the new child form.
		  m.oForm = THIS.cmChildFormCollection.Find(m.cClass)
		  IF ISNULL(m.oForm)
		    _SCREEN.AddProperty('oCallingForm', THIS)
		    m.oForm = THIS.cmChildFormCollection.Add(m.cClass, PCOUNT()-1, @m.uArg1, @m.uArg2, @m.uArg3, @m.uArg4, @m.uArg5, @m.uArg6)
		    _SCREEN.oCallingForm = .NULL.
		  ENDIF
		  IF NOT ISNULL(m.oForm)
		    m.oForm.Show()
		  ENDIF
		  RETURN m.oForm
		
	ENDPROC

	PROCEDURE openmodalchild		&& Open a modal child data form, based on the frmModalDataChild class. Returns an object reference to the open (but not yet visible) form.
		LPARAMETERS cClass, uArg1, uArg2, uArg3, uArg4, uArg5, uArg6
		*++
		*>>Open a modal child data form, based on the frmModalDataChild class. Returns an object reference to the open (but not yet visible) form.
		*--
		LOCAL ix, cParamlist, oInstance, cCommand
		
		  m.cParamlist = ''
		  FOR ix = 1 TO PCOUNT() - 1
		    m.cParamlist = m.cParamlist + ',@m.uArg' + STR(m.ix,1)
		  ENDFOR
		
		  * Build the command to Instantiate the form, and pass any parameters to it.
		  IF '.scx' $ LOWER(m.cClass)
		    * Remote app source for the .scx
		    m.cCommand = 'DO FORM "' + m.cClass + '" NAME m.oInstance LINKED NOSHOW'
		    IF NOT EMPTY(m.cParamlist)
		      m.cCommand = m.cCommand + ' WITH ' + STRTRAN(SUBSTR(m.cParamlist, 2), '@', '')
		    ENDIF
		  ELSE
		    m.cCommand = 'm.oInstance = CreateLocalized(m.cClass' + m.cParamList + ')'
		  ENDIF
		
		  * Open the form. Use a screen property to hold a reference to this (parent) form, so
		  * it will be available to the modal child's load() event. This allows the child form 
		  * to set up references to our DM and CDE before controls and data binding are initialized.
		  _SCREEN.AddProperty('oCallingForm', THIS)
		  &cCommand
		  _SCREEN.oCallingForm = .NULL.
		
		  RETURN IIF(VARTYPE(m.oInstance) = 'O', m.oInstance, .NULL.)
		
	ENDPROC

	PROCEDURE prior		&& Toolbar/button/menu interface to Move to the previous record in the specified workarea.
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to Move to the previous record in the specified workarea.
		*--
		LOCAL lStatus
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      m.lStatus = THIS.cmDataManager.Skip(-1, PROPER(m.cWorkarea))
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE Refresh
		*++
		*>>Reset IsReadonly() optimization for each refresh cycle
		*--
		  THISFORM.cmDataManager.ResetOptimization()
		
	ENDPROC

	PROCEDURE refreshall		&& Optimize display update by locking screen during refresh. Handles frmDataForm and frmDataChildForm based forms.
		*++
		*>>Optimize display update by locking screen during refresh. Handles frmDataForm and frmDataChildForm based forms.
		*--
		  * Make sure the primary workarea stays selected, so any grid controls dont get confused.
		  IF NOT EMPTY(THIS.cWorkarea)
		    THIS.cmDataManager.SetDefault(THIS.cWorkarea)
		  ENDIF
		
		  * Set or clear change flag based on actual cursor state.
		  THIS.SetChanged()
		
		  * If explicit editmode is in effect, and data was changed (by a modal dialog for example),
		  * then we need to turn off write-lock, as if the user had enabled editmode directly.
		  IF THIS.lExplicitEditmode AND THIS.lChanged AND THIS.lWriteLock
		    THIS.lWriteLock = .F.
		  ENDIF
		
		  THIS.Lockscreen = .T.
		  THIS.Refresh()
		  THIS.Lockscreen = .F.
		
		  * For fastest screen redraw, force it now rather than waiting for next redraw before idle.
		  THIS.Draw()
		
		  * The nChildRefreshMode property affects which forms in a multi-form set are refreshed.
		  *   1 - Refresh current form (parent or child) only
		  *   2 - Refresh parent and current child
		  *   3 - Refresh parent and all children (default)
		  IF THIS.nChildRefreshMode > 1
		    m.oParent = IIF(TYPE('THIS.oCaller.Name') == 'C', THIS.oCaller, THIS)
		    IF NOT m.oParent.Name == THIS.Name
		      m.oParent.Lockscreen = .T.
		      m.oParent.Refresh()
		      m.oParent.Lockscreen = .F.
		    ENDIF
		
		    DO CASE
		      CASE THIS.nChildRefreshMode == 2
		        IF NOT ISNULL(m.oParent.oActiveChild) AND NOT m.oParent.oActiveChild.Name == THIS.Name
		          m.oParent.oActiveChild.Lockscreen = .T.
		          m.oParent.oActiveChild.Refresh()
		          m.oParent.oActiveChild.Lockscreen = .F.
		        ENDIF
		
		      CASE THIS.nChildRefreshMode == 3
		        IF TYPE('m.oParent.cmChildFormCollection.Name') == 'C'
		          FOR ix = 1 TO m.oParent.cmChildFormCollection.nCount
		            m.oChild = m.oParent.cmChildFormCollection.Forms[m.ix]
		            IF NOT ISNULL(m.oChild) AND NOT m.oChild.Name == THIS.Name
		              m.oChild.Lockscreen = .T.
		              m.oChild.Refresh()
		              m.oChild.Lockscreen = .F.
		            ENDIF
		          ENDFOR
		        ENDIF
		    ENDCASE
		  ENDIF
		
		  * Then refresh all form-related states and actions.
		  * Note that WONTOP() may be empty if certain ActiveX ctls are on the form.
		  IF UPPER(THIS.Name) == WONTOP() OR (EMPTY(WONTOP()) AND UPPER(THIS.Name) == WOUTPUT())
		    IF NOT EMPTY(THIS.cWorkarea)
		      THIS.cmDataManager.SetDefault(THIS.cWorkarea)
		    ENDIF
		    IF NOT ISNULL(THIS.oStatemanager)
		      THIS.oStatemanager.RefreshAll('Form')
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE registryupdate
		*++
		*>>Initialize or update properties from stored registry values. Called on Init and whenever the app registry is changed.
		*--
		  DODEFAULT()
		  IF NOT ISNULL(THIS.oRegistry)
		    IF BITTEST(THIS.nControlFlags, FRMFLAG_READ_CONFIRMSAVE)
		      THIS.lConfirmSave = THIS.oRegistry.GetKeyValue(KEYNAME_CONFIRM_SAVE, KEY_TYPE_LOGICAL, .F.)
		    ENDIF
		    IF BITTEST(THIS.nControlFlags, FRMFLAG_READ_CONFIRMDELETE)
		      THIS.lConfirmDelete = THIS.oRegistry.GetKeyValue(KEYNAME_CONFIRM_DELETE, KEY_TYPE_LOGICAL, .T.)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE Release
		*++
		*>>Special DataForm processing to release all child forms if the parent is explicitly released.
		*--
		  LOCAL ix, oForm
		
		  * Do Default code first, to clear any state manager links to controls on this form.
		  DODEFAULT()
		
		  IF TYPE('THIS.cmChildFormCollection.Name') == 'C'
		    * Release any open child forms first (via release() method, not Close() as would normally be done).
		    * In the normal case, these will have already been closed.
		    FOR ix = 1 TO THIS.cmChildFormCollection.nCount
		      m.oForm = THIS.cmChildFormCollection.Forms[m.ix]
		      IF NOT ISNULL(m.oForm)
		        m.oForm.Release()
		      ENDIF
		    ENDFOR
		  ENDIF
		
		  * Unlink the Data Manager from the CDE. This will not close any cursors. They will
		  * be closed later on when the CDE is released by the form Unload() event.
		  THIS._ReleaseDM()
		
	ENDPROC

	PROCEDURE requery		&& Toolbar/button/menu interface to Requery a cursor
		LPARAMETERS cWorkarea, uP1, uP2, uP3, uP4
		*++
		*>>Toolbar/button/menu interface to Requery a cursor
		*--
		LOCAL lStatus, oDialog
		
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      IF EMPTY(THIS.cRequeryDialogClass)
		        m.lStatus = THIS.cmDataManager.Requery(PROPER(m.cWorkarea), m.uP1, m.uP2, m.uP3, m.uP4)
		      ELSE
		        m.oDialog = CreateLocalized(THIS.cRequeryDialogClass, THIS, m.cWorkarea)
		        m.oDialog.Show()
		        m.lStatus = m.oDialog.ReturnValue()
		      ENDIF
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE save
		LPARAMETERS cWorkareaList
		*++
		*>>Toolbar/button/menu interface for Committing changes from buffered workareas back to disk.
		*--
		LOCAL lStatus
		
		  IF EMPTY(m.cWorkareaList)
		    m.cWorkareaList = THIS.cSaveWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.cmDataManager.IsChanged(m.cWorkareaList)
		      m.lStatus = THIS.ValidateForm(m.cWorkareaList) AND THIS.SaveAllChanges(m.cWorkareaList)
		    ELSE
		      m.lStatus = .T.
		    ENDIF
		
		    * Refresh the form even if nothing was saved, to ensure save/revert action states are acurate.
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE saveallchanges
		LPARAMETERS cWorkareaList
		*++
		*>>Save changes in specified workareas to their source tables on disk.
		* Called by the form.Save() and form.BeforeNav() methods to commit changes.
		*--
		  IF THIS.cmDataManager.UpdateAll(m.cWorkareaList) && Commit specified workareas
		    * Re-enable writelock if explicit editmode is enabled.
		    IF THIS.lExplicitEditMode AND NOT NVL(THIS.lExplicitEditModeLock,.F.)
		      THIS.lWriteLock = .T.
		    ENDIF
		    RETURN .T.
		  ENDIF
		
		  * Note that on error return from dm.UpdateAll() in table-buffered cursors, the recpointer is 
		  * left on the record with error (if the failure was due to data-related validation rules).
		  RETURN .F.
		
	ENDPROC

	PROCEDURE seek		&& Toolbar/button/menu interface to Move to a particular record based on primary key.
		LPARAMETERS uKey, cWorkarea, cIndexTag
		*++
		*>>Toolbar/button/menu interface to Move to a particular record based on primary key.
		*--
		LOCAL lStatus
		  * Default to the form's navigation workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cNavWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      m.lStatus = THIS.cmDataManager.Seek(@m.uKey, PROPER(m.cWorkarea), m.cIndexTag)
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE setchanged
		LPARAMETERS lValue, cWorkarea
		*++
		*>>Set the data form's lChanged flag to the specified value, or the changed state of the cSaveWorkarea cursors.
		*
		* There are 2 cases where this is called:
		* 1 - Artificially set flag to .t. for the specified workarea when a bound control is first edited
		* 2 - Set flag to actual change state of affected workareas
		*--
		LOCAL ix, oForm, nCount, cWorkareaList
		  IF m.lValue
		    IF EMPTY(m.cWorkarea)
		      * No workarea specified, just set the flag for this form.
		      THIS.lChanged = .T.
		    ELSE
		      * Set flag explicitly for every form in set that accesses the specified workarea.
		      m.nCount = 0
		      IF PEMSTATUS(THIS, 'cmChildFormCollection', 5)
		        m.nCount = THIS.cmChildFormCollection.nCount
		      ENDIF
		      FOR ix = 0 TO m.nCount
		        IF m.ix = 0
		          m.oForm = THIS
		        ELSE
		          m.oForm = THIS.cmChildFormCollection.Forms[m.ix]
		        ENDIF
		        IF NOT ISNULL(m.oForm)
		          * Set flag if the form's cSaveWorkarea contains the specified workarea.
		          IF '*' $ m.oForm.cSaveWorkarea ;
		          OR PROPER(m.cWorkarea) + ',' $ m.oForm.cSaveWorkarea + ',' ;
		          OR PROPER(m.cWorkarea) + ',' $ THIS.cmDataManager.GetChildren(m.oForm.cSaveWorkarea, .T.) + ','
		            m.oForm.lChanged = .T.
		          ENDIF
		        ENDIF
		      ENDFOR
		    ENDIF
		  ELSE
		    * Set change flag for every form in set to reflect current data state.
		    THIS.lChanged = THIS.cmDataManager.IsChanged(THIS.cSaveWorkarea)
		    IF PEMSTATUS(THIS, 'cmChildFormCollection', 5)
		      FOR ix = 1 TO THIS.cmChildFormCollection.nCount
		        m.oForm = THIS.cmChildFormCollection.Forms[m.ix]
		        IF NOT ISNULL(m.oForm)
		          m.oForm.lChanged = THIS.cmDataManager.IsChanged(m.oForm.cSaveWorkarea)
		        ENDIF
		      ENDFOR
		    ENDIF
		  ENDIF
		  THIS.AfterStateChange(THIS.lChanged)
		  RETURN THIS.lChanged
		
	ENDPROC

	PROCEDURE setfilter		&& Toolbar/button/menu interface to set a filter.
		LPARAMETERS cFilter, cWorkarea
		*++
		*>>Toolbar/button/menu interface to set a filter.
		*--
		LOCAL lStatus
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      m.lStatus = THIS.cmDataManager.SetFilter(m.cFilter, PROPER(m.cWorkarea))
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE setorder		&& Toolbar/button/menu interface to set record sort order.
		LPARAMETERS cOrder, cWorkarea, cDirection
		*++
		*>>Toolbar/button/menu interface to set record sort order.
		*--
		LOCAL lStatus
		  * Default to the form's primary workarea
		  IF EMPTY(m.cWorkarea)
		    m.cWorkarea = THIS.cWorkarea
		  ENDIF
		
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeNav(m.cWorkarea)
		      * If lookup manager exists, we support localized long tag names.
		      IF PEMSTATUS(THIS, 'cmLookupManager', 5)
		        m.cOrder = THIS.cmLookupManager.GetTagFromDisplayName(m.cOrder, m.cWorkarea)
		      ENDIF
		      m.lStatus = THIS.cmDataManager.SetOrder(m.cOrder, PROPER(m.cWorkarea), m.cDirection)
		    ENDIF
		    THIS.RefreshAll()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE validateform
		LPARAMETERS cWorkareaList
		*++
		*>>Form level field validation driver for frmDataForm.
		*--
		LOCAL lStatus, cWorkareas
		LOCAL ix, oParent, oChild
		
		  IF NOT ISNULL(THIS.oMessage) AND THIS.oMessage.BeginMultiMessage()
		    THIS.nControlFlags  = BITSET(THIS.nControlFlags , FRMFLAG_BATCHING_MESSAGES)
		  ENDIF
		
		  * If a workarea is specified, validate it and all related child workareas.
		  * Build a list of all specified workareaas, and their related children.
		  m.cWorkareas = ''
		  IF NOT EMPTY(m.cWorkareaList) AND NOT '*' $ m.cWorkareaList
		    DO WHILE NOT EMPTY(m.cWorkareaList)
		      LOCAL cWa, cChildren
		      m.cWa = PROPER(GetToken(@m.cWorkareaList, ','))
		      IF NOT EMPTY(m.cWa)
		        m.cWorkareas = m.cWorkareas + IIF(EMPTY(m.cWorkareas), '', ',') + m.cWa
		        m.cChildren = THIS.cmDataManager.GetChildren(m.cWa)
		        IF NOT EMPTY(m.cChildren)
		          m.cWorkareas = m.cWorkareas + IIF(EMPTY(m.cWorkareas), '', ',') + m.cChildren
		        ENDIF
		      ENDIF
		    ENDDO
		  ENDIF
		
		  * The nChildRefreshMode property affects which forms in a multi-form set are validated.
		  *   1 - Validate current form (parent or child) only
		  *   2 - Validate parent and current child (no meaning for parents)
		  *   3 - Validate parent and all children (default)
		  m.lStatus = THIS.ValidateContents(THIS, m.cWorkareas)
		  IF m.lStatus AND THIS.nChildRefreshMode > 1
		    m.oParent = IIF(TYPE('THIS.oCaller.Name') == 'C', THIS.oCaller, THIS)
		    IF NOT m.oParent.Name == THIS.Name
		      m.lStatus = m.lStatus AND THIS.ValidateContents(m.oParent, m.cWorkareas)
		    ENDIF
		
		    DO CASE
		      CASE THIS.nChildRefreshMode == 2
		        IF NOT ISNULL(m.oParent.oActiveChild) AND NOT m.oParent.oActiveChild.Name == THIS.Name
		          m.lStatus = THIS.ValidateContents(m.oParent.oActiveChild, m.cWorkareas)
		        ENDIF
		
		      CASE THIS.nChildRefreshMode == 3
		        IF TYPE('THIS.cmChildFormCollection.Name') == 'C'
		          FOR ix = 1 TO m.oParent.cmChildFormCollection.nCount
		            m.oChild = m.oParent.cmChildFormCollection.Forms[m.ix]
		            IF NOT ISNULL(m.oChild) AND NOT m.oChild.Name == THIS.Name
		              m.lStatus = m.lStatus AND THIS.ValidateContents(m.oChild, m.cWorkareas)
		            ENDIF
		          ENDFOR
		        ENDIF
		    ENDCASE
		  ENDIF
		
		  IF BITTEST(THIS.nControlFlags , FRMFLAG_BATCHING_MESSAGES)
		    THIS.oMessage.EndMultiMessage()
		    THIS.nControlFlags  = BITCLEAR(THIS.nControlFlags , FRMFLAG_BATCHING_MESSAGES)
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE _releasedm		&& Unlink the Data Manager from the CDE.
		*++
		*>>Unlink the Data Manager from the CDE.
		*--
		  * PEMSTATUS() can return false positives for VCX forms, so use a TYPE() test instead.
		  IF TYPE('THIS.cmDataManager.Name') = 'C'
		    * Don't unload if it is only a property reference in a child form.
		    IF PEMSTATUS(THIS, 'cmDataManager', 3) == 'Object'
		      THIS.cmDataManager.UnlinkCDE()
		    ENDIF
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmdatamanagerform AS frmdataformcustom OF "..\custom\cforms.vcx" 		&& CodeMine data form with default data manager and lookup manager classes already in place.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmLookupManager" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmDataManager" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	Caption = "Frmdataform1"
	DoCreate = .T.
	Name = "frmdatamanagerform"

	ADD OBJECT 'cmDataManager' AS cmdatamanagercustom WITH ;
		Height = 15, ;
		Left = 3, ;
		Name = "cmDataManager", ;
		Top = 3, ;
		Width = 15
		*< END OBJECT: ClassLib="..\custom\cdata.vcx" BaseClass="container" />

	ADD OBJECT 'cmLookupManager' AS cmlookupmanager WITH ;
		Height = 13, ;
		Left = 20, ;
		Name = "cmLookupManager", ;
		Top = 4, ;
		Width = 15
		*< END OBJECT: ClassLib="cmlookup.vcx" BaseClass="custom" />

ENDDEFINE

DEFINE CLASS frmform AS form 		&& CodeMine foundation form class.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: abort		&& Clean up form for release on aborted Load() or Init() events.
		*m: activatenextcontrol		&& Sets focus to the specified control, or the one last specified by the SetLastControl() or SetNextControl() methods.
		*m: addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*m: afterload		&& Custom developer code to execute after the default Load() code completes. Return .F. to abort the form load.
		*m: afteropen		&& Custom developer code run just after the form is displayed for the first time.
		*m: afterstatechange		&& Provides a place for Custom Developer code to execute after the "data changed" state of the form changes.
		*m: backgroundrefresh		&& Background refresh event called during first VFP idle time after Init event.
		*m: beforechange		&& Called when data in a control is modified. Return .T. if ok to change data in the form.
		*m: beforeclose		&& Save or discard any changes, and return .T. if the form can be closed.
		*m: beforeopen		&& Custom developer code run just before the form is about to be displayed for the first time. Return .F. to prevent the form from opening.
		*m: beveledbox		&& Draw a sunken box of the specified size and position.
		*m: cancel		&& Toolbar/button/menu interface to CancelAllChanges()
		*m: cancelallchanges		&& Cancel all changes. Called by form.Cancel() and whenever form closes without saving changes.
		*m: close		&& Toolbar/button/menu interface for closing the form. Behaves the same as pressing the window's close button.
		*m: closeformtoolbar		&& Get rid of form-specific toolbars
		*m: confirm		&& Use the Message Manager service to display a Y/N confirmation dialog, with optional detailed explanation text.
		*m: confirmcancel		&& Get user confirmation before discarding all changes to the current form. Returns .T./.F.
		*m: confirmclose		&& Get user confirmation before closing the form if there are uncommitted changes. Returns .T./.F./.Null.
		*m: contextmenuactivate		&& Call context menu manager to activate the context menu, and return the identifier associated with the option chosen.
		*m: contextmenubar		&& Call context menu manager to define a menu bar for the context menu.
		*m: contextmenubarcheck		&& Set the check-mark for the specified menu bar.
		*m: contextmenubardisable		&& Enable or disbale the specified context menu bar, per the specified expression.
		*m: contextmenubuild
		*m: contextmenuexecute
		*m: contextmenuinit		&& Call context menu manager to initialize context menu popup.
		*m: contextmenuseparator		&& Add a Separator bar to the context menu, only if any other bars are added after.
		*m: displayhelp		&& Display context help for the specified object.
		*m: displaymessage		&& Calls the form message object to display an error message.
		*m: displaywarning		&& Use the Message Manager service to display a Warning Message dialog, with optional detailed explanation text.
		*m: flushcontrolbuffer		&& Move focus off current control to flush control data buffer.
		*m: formvalid		&& Custom developer-supplied Form level validation code, called by ValidateForm().
		*m: initializeallhelp		&& Initialize help key translations for all controls in the specified container.
		*m: initializehelp		&& Translate the specified control's help key and set tooltip and statusbar text.
		*m: initsession		&& Initialize data session settings for a private data session. Not called if form runs in the default session.
		*m: iseditallowed		&& Controls whether or not data-bound controls in this form may be edited.
		*m: isempty		&& Return true if the specified workarea is empty - if it has no available records.
		*m: isenabled		&& Determines whether or not the specified form method can be called from a toolbar button.
		*m: isnew		&& Return true if the current record in specified workarea is newly appended.
		*m: isopenallowed		&& Check security settings to see if this form is allowed to be opened. Developer can always open any form.
		*m: loaddataenvironment		&& Load the data environment for the form. Supports Native VFP SCX Data Environments and the CodeMine CDE class.
		*m: loadglobalreferences		&& Check for presence of Codemine Environment. Return .F. to prevent form loading.
		*m: nicecursorname		&& Call message manager to return a user-friendly name for the specified cursor workarea.
		*m: nicefieldname		&& Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		*m: nicename		&& Return a user-friendly name for the specified object.
		*m: oapp_access
		*m: omessage_access
		*m: oname_access
		*m: openformtoolbar		&& Put up any form-specific toolbars
		*m: oregistry_access
		*m: osecurity_access
		*m: ostatemanager_access
		*m: ostring_access
		*m: registryupdate		&& Initialize or update properties from stored registry values. Called on Init and whenever the app registry is changed.
		*m: repositioncontents		&& Reposition the contents of the specified container object after a resize.
		*m: restoresizeandposition		&& Restore last saved window size and position.
		*m: save		&& Toolbar/button/menu interface for SaveAllChanges()
		*m: saveallchanges		&& Save all changes. Called by the form.Save() to apply changes.
		*m: savesizeandposition		&& Save current size and position of window.
		*m: setbackgroundtexture		&& Set the background texture image for the form or the specified container.
		*m: setchanged		&& Set the form's lChanged flag to the specified value.
		*m: setlastcontrol		&& Set the object to recieve focus when the current Form Action method completes un-successfuly.
		*m: setnextcontrol		&& Set the object to recieve focus when the next Form Action method completes successfuly.
		*m: skipvalid		&& Returns .T. if the current control should not enforce field level validation.
		*m: validatecontents		&& Recursive routine to call each control's FormValid() method.
		*m: validateform		&& Form level control validation driver.
		*p: cbindingmanagerclass		&& Name of the data binding manager class to use.
		*p: cclass		&& Foundation form class for this form. Do not modify this value in any subclasses you create.
		*p: ccontextmenuclass		&& Name of the context menu manager class to use. Set it to an empty string to disable context menus.
		*p: cdataenvironment		&& Class name of a custom CodeMine Data Environment (CDE) class to use.
		*p: cdisplayname		&& User-friendly form name used in help and error messages
		*p: cformbackground		&& Form background BMP/JPG image file. Leave empty to use application default background.
		*p: chelpkey		&& Name of form level help message key
		*p: cmenu		&& Form-specific menu program name. This should normally include a '.mpr' extension.
		*p: cmsgconfirmcancel		&& Message key/text used for the Cancel Confirmation dialog
		*p: cmsgconfirmclose		&& Message key/text used for the Close Confirmation dialog
		*p: copenprivilege		&& Coma separated list of privileges that will allow form to open. Privileges are ORed together. Leave empty to allow all users to open form.
		*p: csysregformroot		&& System registry root key used to save form properties. Set in form.load method from cSysregroot and form name.
		*p: csysregroot		&& System registry root key used to save app properties. This value inherited from app object at runtime, if any.
		*p: ctoolbar		&& Form-specific toolbar class name, or empty if none.
		*p: cversion		&& Version number of your form. Set this value to your form's version identification string.
		*p: lbuttontipsonly		&& If this and form.ShowTips are both set to .T. only Commandbutton tooltips are set from cHelpKey
		*p: lcleareventsonclose		&& For Toplevel forms only - closing the last open toplevel form will issue a CLEAR EVENTS.
		*p: lcloseonescape		&& Set to .T. to close the form when escape is pressed.
		*p: lcodeminehelp		&& Set to .T. to enable the CodeMine context help system for this form.
		*p: lconfirmclose		&& Set .T. to require confirmation before closing with uncommitted changes. Set to NULL to override at runtime with the "%Local.Data Entry.Confirm Save on Close" app registry setting.
		*p: lignoreboundproperties		&& Set to True if controls bound to Properties or memvars should not set the form change-flag when modified.
		*p: llocalizecaption		&& Set to .T. to localize the caption property into the current language.
		*p: lrememberposition		&& Save and restore window position if true.
		*p: lremembersize		&& Save and restore window size if true.
		*p: ltoolbarmemory		&& Remember if form-specific toolbars are open or closed when form is first opened.
		*p: lwindowmenu		&& Include this form in the aplication's window menu, if form is modeless.
		*p: lwritelock		&& Set to .T. to write-protect all data-bound fields on the form.
		*p: ncascadeoffset		&& Number of pixels each additional instance of a form is offset from the previous instance
		*p: ncontrolflags		&& Internal bit flags used to control the form.
		*p: oapp		&& Runtime reference to global Application Manager object.
		*p: omessage		&& Runtime reference to the cmMessage global object. Set to .NULL. to instantiate on Load.
		*p: oname		&& Runtime reference to the Personal name parsing service object. Set to .NULL. to instantiate on Load.
		*p: oregistry		&& Runtime reference to CodeMine registry global service object. Set to .NULL. to instantiate on Load.
		*p: osecurity		&& Runtime reference to the cmSecurity global object. Set to .NULL. to instantiate on Load.
		*p: ostatemanager		&& Runtime reference to the cmStateManager Global service object. Set to .NULL. to instantiate on Load.
		*p: ostring		&& Runtime reference to the cmStringTools global service object. Set to .NULL. to instantiate on Load.
	*</DefinedPropArrayMethod>

	AutoCenter = .T.
	Caption = "CodeMine Foundation Form"
	cbindingmanagerclass = cmBindingManagerCustom		&& Name of the data binding manager class to use.
	cclass = frmForm		&& Foundation form class for this form. Do not modify this value in any subclasses you create.
	ccontextmenuclass = cmContextMenuManager		&& Name of the context menu manager class to use. Set it to an empty string to disable context menus.
	cdataenvironment = 		&& Class name of a custom CodeMine Data Environment (CDE) class to use.
	cdisplayname = 		&& User-friendly form name used in help and error messages
	cformbackground = 		&& Form background BMP/JPG image file. Leave empty to use application default background.
	chelpkey = 		&& Name of form level help message key
	cmenu = 		&& Form-specific menu program name. This should normally include a '.mpr' extension.
	cmsgconfirmcancel = %msgConfirmCancel		&& Message key/text used for the Cancel Confirmation dialog
	cmsgconfirmclose = %msgConfirmClose		&& Message key/text used for the Close Confirmation dialog
	copenprivilege = 		&& Coma separated list of privileges that will allow form to open. Privileges are ORed together. Leave empty to allow all users to open form.
	csysregformroot = 		&& System registry root key used to save form properties. Set in form.load method from cSysregroot and form name.
	csysregroot = Software\Soft Classics\CodeMine		&& System registry root key used to save app properties. This value inherited from app object at runtime, if any.
	ctoolbar = 		&& Form-specific toolbar class name, or empty if none.
	cversion = 1.0.0		&& Version number of your form. Set this value to your form's version identification string.
	DoCreate = .T.
	lbuttontipsonly = .F.		&& If this and form.ShowTips are both set to .T. only Commandbutton tooltips are set from cHelpKey
	lcleareventsonclose = .F.		&& For Toplevel forms only - closing the last open toplevel form will issue a CLEAR EVENTS.
	lcloseonescape = .F.		&& Set to .T. to close the form when escape is pressed.
	lcodeminehelp = .T.		&& Set to .T. to enable the CodeMine context help system for this form.
	lconfirmclose = .NULL.		&& Set .T. to require confirmation before closing with uncommitted changes. Set to NULL to override at runtime with the "%Local.Data Entry.Confirm Save on Close" app registry setting.
	lignoreboundproperties = .F.		&& Set to True if controls bound to Properties or memvars should not set the form change-flag when modified.
	llocalizecaption = .F.		&& Set to .T. to localize the caption property into the current language.
	lrememberposition = .F.		&& Save and restore window position if true.
	lremembersize = .F.		&& Save and restore window size if true.
	ltoolbarmemory = .T.		&& Remember if form-specific toolbars are open or closed when form is first opened.
	lwindowmenu = .T.		&& Include this form in the aplication's window menu, if form is modeless.
	lwritelock = .F.		&& Set to .T. to write-protect all data-bound fields on the form.
	MaxButton = .F.
	MinWidth = 75
	Name = "frmform"
	ncascadeoffset = 25		&& Number of pixels each additional instance of a form is offset from the previous instance
	ncontrolflags = 0		&& Internal bit flags used to control the form.
	oapp = .NULL.		&& Runtime reference to global Application Manager object.
	omessage = .NULL.		&& Runtime reference to the cmMessage global object. Set to .NULL. to instantiate on Load.
	oname = .F.		&& Runtime reference to the Personal name parsing service object. Set to .NULL. to instantiate on Load.
	oregistry = .F.		&& Runtime reference to CodeMine registry global service object. Set to .NULL. to instantiate on Load.
	osecurity = .F.		&& Runtime reference to the cmSecurity global object. Set to .NULL. to instantiate on Load.
	ostatemanager = .NULL.		&& Runtime reference to the cmStateManager Global service object. Set to .NULL. to instantiate on Load.
	ostring = .NULL.		&& Runtime reference to the cmStringTools global service object. Set to .NULL. to instantiate on Load.
	ScaleMode = 3
	WhatsThisHelp = .T.
	
	PROCEDURE abort		&& Clean up form for release on aborted Load() or Init() events.
		*++
		*>>Clean up form for release on aborted Load() or Init() events.
		*--
		  * Cancel any outstanding subscriptions to state manager events. 
		  * This includes appreg update events, and links to action buttons on the form.
		  IF VARTYPE(THIS.oStateManager) = 'O'
		    THIS.oStateManager.UnSubscribe('*', THIS)
		  ENDIF
		
		  * Release the CDE now, since we cannot be sure the form.Unload() event will be triggered.
		  IF VARTYPE(THIS.oCDE) = 'O'
		    THIS.oCDE.Release()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Activate
		*++
		* Common form Activeate handler. Establish correct form menu context.
		*--
		  THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_ACTIVE)  && Mark us as the active form.
		  THIS.ActivateNextControl()                         && Set focus to last set control, if any.
		
		  * For modeless windows, put up (or just remove previous) form-specific menu pad.
		  * Form Menu for modal forms is put up by the GotFocus() Event
		  IF NOT ISNULL(THIS.oStateManager) AND THIS.WindowType = 0
		    THIS.oStateManager.SetFormMenu(THIS.cMenu)
		  ENDIF
		
	ENDPROC

	PROCEDURE activatenextcontrol		&& Sets focus to the specified control, or the one last specified by the SetLastControl() or SetNextControl() methods.
		LPARAMETERS oTarget, lResetCell
		*++
		*>>Sets focus to the specified control, or the one last specified by the SetLastControl() or SetNextControl() methods.
		*--
		LOCAL ix, cName, oParent
		
		  IF m.lResetCell
		    * If target control is a grid, and current cell needs refresh after activated, set flag.
		    * This will be the case after a frmDataForm.Cancel() call is completed, because focus is 
		    * moved off control with a SkipValid, possibly leaving its change flag set. If the control 
		    * is in a grid, it will miss the form-level refresh() after the cancel, so othe only chance 
		    * to refresh it comes after it gets focus back after cancel() completes. We use a form-level
		    * flag for this so it remains set until a bound control in this form successfully gets focus.
		    * The BindingManager GotFocus() code will test this flag if the control is in a grid, and 
		    * clear the control's change flag so its contents will be refreshed.
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_REFRESH_CELL)
		  ENDIF
		
		  IF BITTEST(THIS.nControlFlags, FRMFLAG_ACTIVE)   && Only set focus if this form is active
		    m.cName = IIF(NOT EMPTY(THIS.cNextControl), THIS.cNextControl, THIS.cLastControl)
		
		    * Clear next and last object references.
		    STORE '' TO THIS.cLastControl, THIS.cNextControl
		
		    * If a target object was specified, it overrides anything in cNextControl or cLastControl.
		    IF VARTYPE(m.oTarget) != 'O'
		      m.oTarget = .NULL.
		      IF NOT EMPTY(m.cName) AND NOT ISNULL(m.cName)
		        m.cName = SUBSTR(m.cName, AT('.', m.cName) + 1)
		        IF TYPE('THISFORM.' + m.cName) = 'O'
		          m.oTarget = EVALUATE('THISFORM.' + m.cName)
		        ENDIF
		      ENDIF
		    ENDIF
		
		    IF NOT ISNULL(m.oTarget)
		      * If target is contained in a pageframe, make sure the correct page is active.
		      m.oParent = m.oTarget.Parent
		      DO WHILE m.oParent.Baseclass != 'Form'
		        WITH m.oParent
		          IF .Baseclass == 'Page'
		            IF .Parent.ActivePage != .Pageorder
		              IF PEMSTATUS(.Parent, 'SetPage', 5)
		                .Parent.SetPage(.Parent.PageOrderToIndex(.Pageorder), 0, PAGEMASK_NOFOCUS + PAGEMASK_SKIP_VALID)
		              ELSE
		                .Parent.ActivePage = .Pageorder
		              ENDIF
		            ENDIF
		          ENDIF
		        ENDWITH
		        m.oParent = m.oParent.Parent
		      ENDDO
		
		      * Call the target control's SetFocus method to give it focus.
		      m.oTarget.SetFocus()
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		LPARAMETERS cName, cClassAlias, uP1, uP2, uP3, uP4, uP5, uP6, uP7, uP8, uP9
		*++
		*>>Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*--
		LOCAL ix, cParams, cLibrary
		
		  * Translate class alias into actual class name, and extract class library prefix if present.
		  m.cLibrary = .NULL.
		  IF PEMSTATUS(_SCREEN, 'cmGlobalObjectManager', 5)
		    m.cClassAlias = _SCREEN.cmGlobalObjectManager.GetClassName(m.cClassAlias, @m.cLibrary)
		  ENDIF
		
		  m.cParams = ''
		  FOR ix = 1 TO PCOUNT() - 2
		    m.cParams = m.cParams + ', @m.uP' + STR(m.ix,1)
		  ENDFOR
		  RETURN THIS.NewObject(m.cName, m.cClassAlias, m.cLibrary, '' &cParams)
		
	ENDPROC

	PROCEDURE afterload		&& Custom developer code to execute after the default Load() code completes. Return .F. to abort the form load.
		*++
		*>>Custom developer code to execute after the default Load() code completes. Return .F. to abort the form load.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afteropen		&& Custom developer code run just after the form is displayed for the first time.
		*++
		*>>Custom developer code run just after the form is displayed for the first time.
		*--
		
	ENDPROC

	PROCEDURE afterstatechange		&& Provides a place for Custom Developer code to execute after the "data changed" state of the form changes.
		LPARAMETERS lChanged
		*++
		*>>Provides a place for Custom Developer code to execute after the "data changed" state of the form changes.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE backgroundrefresh		&& Background refresh event called during first VFP idle time after Init event.
		*++
		*>>Background refresh event called during first VFP idle time after Init event.
		* If form.ShowTips is enabled, we use this event to translate tooltips and statusbar 
		* text in the background, after the form is first displayed.
		*--
		  IF THIS.ShowTips
		    THIS.InitializeAllHelp(THIS)
		  ENDIF
		
	ENDPROC

	PROCEDURE beforechange		&& Called when data in a control is modified. Return .T. if ok to change data in the form.
		LPARAMETERS cWorkarea
		*++
		*>>Called when data in a control is modified. Return .T. if ok to change data in the form.
		*--
		  IF NOT THIS.lWriteLock
		    IF NOT EMPTY(m.cWorkarea) OR NOT THIS.lIgnoreBoundProperties
		      THIS.SetChanged(.T.)
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE beforeclose		&& Save or discard any changes, and return .T. if the form can be closed.
		LPARAMETERS nCloseReason
		*++
		*>>Save or discard any changes, and return .T. if the form can be closed.
		* Provides default behavior. Individual forms may subclass this method as appropriate.
		*--
		LOCAL lStatus, lCloseForm, lActive
		  m.lActive = BITTEST(THIS.nControlFlags , FRMFLAG_ACTIVE)
		  IF INLIST(m.nCloseReason, CLOSE_BY_CANCEL)
		    m.lCloseForm = THIS.Cancel()        && Same as toolbar cancel
		  ELSE
		    * Never need confirmation if no changes, or for OK/Apply close reasons.
		    m.lStatus = NOT THIS.lChanged ;
		                OR INLIST(m.nCloseReason, CLOSE_BY_OK, CLOSE_BY_APPLY) OR THIS.ConfirmClose()
		    DO CASE
		      CASE ISNULL(m.lStatus)            && If User said 'Cancel' just return failure status
		        m.lCloseForm = .F.
		      CASE NOT m.lStatus
		        m.lCloseForm = THIS.CancelAllChanges()  && Cancel changes, no confirm.
		      OTHERWISE
		        m.lCloseForm = THIS.Save()              && Same as toolbar Save
		    ENDCASE
		  ENDIF
		
		  * Confirmation dialogs may deactivate us, but if we were originally active
		  * we need to clean up menu context, so re-set active flag.
		  IF m.lCloseForm AND m.lActive
		    THIS.nControlFlags  = BITSET(THIS.nControlFlags , FRMFLAG_ACTIVE)  && Mark us as the active form.
		  ENDIF
		  RETURN m.lCloseForm
		
	ENDPROC

	PROCEDURE beforeopen		&& Custom developer code run just before the form is about to be displayed for the first time. Return .F. to prevent the form from opening.
		*++
		*>>Custom developer code run just before the form is about to be displayed for the first time. Return .F. to prevent the form from opening.
		*--
		
	ENDPROC

	PROCEDURE beveledbox		&& Draw a sunken box of the specified size and position.
		LPARAMETERS nXCoord1, nYCoord1, nXCoord2, nYCoord2, lRaised, nWidth
		*#include ..\common\win32.h
		*++
		*>>Draw a sunken box of the specified size and position.
		*--
		  LOCAL ix
		  FOR ix = 0 TO IIF(EMPTY(m.nWidth), 0, m.nWidth - 1)
		    IF m.ix = 0
		      THISFORM.DrawWidth = 1
		    ELSE
		      m.nXCoord1 = m.nXCoord1 + m.ix
		      m.nYCoord1 = m.nYCoord1 + m.ix
		      m.nXCoord2 = m.nXCoord2 - m.ix
		      m.nYCoord2 = m.nYCoord2 - m.ix
		    ENDIF
		    THISFORM.CurrentX = m.nXCoord1
		    THISFORM.CurrentY = m.nYCoord2 - 1
		
		    THISFORM.ForeColor = IIF(m.lRaised, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW))
		    THISFORM.Line(m.nXCoord1, m.nYCoord1)
		    THISFORM.Line(m.nXCoord2 - 1, m.nYCoord1)
		
		    THISFORM.ForeColor = IIF(m.lRaised, GetSysColor(COLOR_BTNSHADOW), GetSysColor(COLOR_BTNHIGHLIGHT))
		    THISFORM.Line(m.nXCoord2 - 1, m.nYCoord2 - 1)
		    THISFORM.Line(m.nXCoord1, m.nYCoord2 - 1)
		  ENDFOR
		
	ENDPROC

	PROCEDURE cancel		&& Toolbar/button/menu interface to CancelAllChanges()
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface to CancelAllChanges()
		* Currently, the cWorkarea parameter is ignored for this method.
		*--
		  * Only issue confirmation dialog if form Change flag is set.
		  RETURN (NOT THIS.lChanged OR THIS.ConfirmCancel()) AND THIS.CancelAllChanges()
		
	ENDPROC

	PROCEDURE cancelallchanges		&& Cancel all changes. Called by form.Cancel() and whenever form closes without saving changes.
		*++
		*>>Cancel all changes. Called by form.Cancel() and whenever form closes without saving changes.
		*--
		  THIS.SetChanged(.F.)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE close		&& Toolbar/button/menu interface for closing the form. Behaves the same as pressing the window's close button.
		LPARAMETERS nCloseReason
		*++
		*>>Toolbar/button/menu interface for closing the form. Behaves the same as pressing the window's close button.
		*--
		  IF THIS.FlushControlBuffer()
		    IF THIS.BeforeClose(IIF(EMPTY(m.nCloseReason), CLOSE_BY_CONTROL, m.nCloseReason))
		      THIS.Release()
		      THIS.Hide()   && Workaround for delayed close while a grid has focus (Another wierd VFP quirk)
		      RETURN .T.
		    ENDIF
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE closeformtoolbar		&& Get rid of form-specific toolbars
		*++
		*>>Get rid of form-specific toolbars
		*--
		  IF NOT EMPTY(THIS.cToolbar) AND NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.RemoveToolbar(THIS.cToolbar)
		  ENDIF
		
	ENDPROC

	PROCEDURE confirm		&& Use the Message Manager service to display a Y/N confirmation dialog, with optional detailed explanation text.
		LPARAMETERS cMsg, cDetails, uP1, uP2, uP3
		*++
		*>>Use the Message Manager service to display a Y/N confirmation dialog, with optional detailed explanation text.
		*--
		LOCAL nSelect, lStatus
		
		  m.lStatus = .T.
		  m.nSelect = SELECT()
		  IF NOT ISNULL(THIS.oMessage)
		    m.lStatus = THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_YN, MSG_SEVERITY_QUESTION, ;
		                                     @m.cMsg, @m.cDetails, m.uP1, m.uP2, m.uP3)
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE confirmcancel		&& Get user confirmation before discarding all changes to the current form. Returns .T./.F.
		*++
		*>>Get user confirmation before discarding all changes to the current form. Returns .T./.F.
		*--
		LOCAL lStatus
		  * The dialog display may trigger fieldValid call, so supress it in this case.
		  THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_SKIP_VALID)
		
		  IF ISNULL(THIS.oMessage) OR EMPTY(THIS.cMsgConfirmCancel)
		    m.lStatus = .T.
		  ELSE
		    m.lStatus = THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_YN, MSG_SEVERITY_QUESTION, THIS.cMsgConfirmCancel,, THISFORM.Caption)
		  ENDIF
		
		  THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, FRMFLAG_SKIP_VALID)
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE confirmclose		&& Get user confirmation before closing the form if there are uncommitted changes. Returns .T./.F./.Null.
		*++
		*>>Get user confirmation before closing the form if there are uncommitted changes. Returns .T./.F./.Null.
		* Return values:
		*     .T. Changes should be saved (Yes)
		*        .F. Changes should be discarded (No)
		*        .Null. Do nothing, return failure code to caller (Cancel)
		*--
		  IF THIS.lConfirmClose AND NOT ISNULL(THIS.oMessage) AND NOT EMPTY(THIS.cMsgConfirmClose)
		    RETURN THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_YNC, MSG_SEVERITY_QUESTION, THIS.cMsgConfirmClose,, THISFORM.Caption)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE contextmenuactivate		&& Call context menu manager to activate the context menu, and return the identifier associated with the option chosen.
		*++
		*>>Call context menu manager to activate the context menu, and return the identifier associated with the option chosen.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuActivate()
		
	ENDPROC

	PROCEDURE contextmenubar		&& Call context menu manager to define a menu bar for the context menu.
		LPARAMETERS nBar, cPrompt, uArg, cStyle, cStatusbar
		*++
		*>>Call context menu manager to define a menu bar for the context menu.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuBar(m.nBar, @m.cPrompt, m.uArg, m.cStyle, @m.cStatusbar)
		
	ENDPROC

	PROCEDURE contextmenubarcheck		&& Set the check-mark for the specified menu bar.
		LPARAMETERS nBar, lCheck
		*++
		*>>Set the check-mark for the specified menu bar.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuBarCheck(m.nBar, m.lCheck)
		
	ENDPROC

	PROCEDURE contextmenubardisable		&& Enable or disbale the specified context menu bar, per the specified expression.
		LPARAMETERS nBar, lDisable
		*++
		*>>Enable or disbale the specified context menu bar, per the specified expression.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuBarDisable(m.nBar, m.lDisable)
		
	ENDPROC

	PROCEDURE contextmenubuild
		*++
		* Define all the bars for a context menu. Return .F. if no bars are defined
		*--
		  IF THIS.cmContextMenu.GetBarCount() = 0
		    * If a control didn't already add bars, and we have help, add a help bar.
		    IF NOT EMPTY(THIS.cHelpKey)
		      THISFORM.ContextMenuBar(CTX_BAR_FRM_HELP, '%barHelp')
		      THISFORM.ContextMenuSeparator(CTX_BAR_FRM_SEP1)
		    ENDIF
		  ELSE
		    THISFORM.ContextMenuSeparator(CTX_BAR_FRM_SEP1)  && Seperator after previously added bars
		  ENDIF
		
		  THISFORM.ContextMenuBar(CTX_BAR_FRM_CENTER, '%barCenter')
		  IF THISFORM.BorderStyle = 3
		    THISFORM.ContextMenuBar(CTX_BAR_FRM_RESTORE, '%barRestoreSize')
		    IF THIS.Width = THIS.nOriginalWidth AND THIS.Height = THIS.nOriginalHeight
		      THISFORM.ContextMenuBarDisable(CTX_BAR_FRM_RESTORE, .T.)
		    ENDIF
		  ENDIF
		
		  * If running in development environment, enable the developer-only ctx menu items.
		  IF (NOT ISNULL(THIS.oApp) AND NOT THIS.oApp.lApplicationStarted) ;
		  OR (NOT ISNULL(THIS.oSecurity) AND THIS.oSecurity.HasPrivilege('Debug'))
		    THISFORM.ContextMenuSeparator(CTX_BAR_FRM_SEP5)
		    IF VERSION(2) != 0   && Standalone EXE doesn't have debug support
		      THISFORM.ContextMenuBar(CTX_BAR_FRM_DEBUG, 'Open Debugger')
		      THISFORM.ContextMenuBar(CTX_BAR_FRM_SUSPEND, 'Suspend')
		    ENDIF
		    THISFORM.ContextMenuBar(CTX_BAR_FRM_REFRESH, 'Refresh')
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETERS cOption
		*++
		* Execute the selected context menu item. Usually called from context menu 
		* activation, but may also be called directly under program control to simulate user action.
		* Returns true if the option was handled by this method.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%barhelp'
		      THIS.ShowWhatsThis(THIS.WhatsThisHelpID)
		
		    CASE m.cOption = '%barcenter'
		      THIS.AutoCenter = .T.
		
		    CASE m.cOption = '%barrestoresize'
		      THIS.Width = THIS.nOriginalWidth
		      THIS.Height = THIS.nOriginalHeight
		
		    * The remaining options are used for Debug mode only.
		    CASE 'Debugger' $ m.cOption
		      IF NOT ISNULL(THIS.oStateManager)
		        THIS.oStateManager.EnableInterrupts(.F., .T.)
		      ENDIF
		      SET STEP ON
		    CASE m.cOption = 'Suspend'
		      IF WEXIST('Command')
		        ACTIVATE WINDOW command
		      ENDIF
		      SUSPEND
		    CASE m.cOption = 'Refresh'
		      IF PEMSTATUS(THIS, 'RefreshAll', 5)
		        THIS.RefreshAll()   && For dataforms
		      ELSE
		        THIS.Refresh()
		      ENDIF
		    OTHERWISE
		      RETURN .F.
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE contextmenuinit		&& Call context menu manager to initialize context menu popup.
		LPARAMETERS oTarget
		*++
		*>>Call context menu manager to initialize context menu popup.
		*--
		  IF PEMSTATUS(THIS, 'cmContextMenu', 5)
		    RETURN THIS.cmContextMenu.ContextMenuInit(m.oTarget)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE contextmenuseparator		&& Add a Separator bar to the context menu, only if any other bars are added after.
		LPARAMETERS nBar
		*++
		*>>Add a Separator bar to the context menu, only if any other bars are added after.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuSeparator(m.nBar)
		
	ENDPROC

	PROCEDURE Deactivate
		*++
		* Common form deactiveate handler. Cleans up form menu context when switching to a new window.
		*--
		  * Suppress disply of default VFP statusbar text, and clear any form-related message.
		  IF VERSION(2) = 0
		    TRY 
		       SET MESSAGE TO ''
		       IF m.goApp.lCloudServer
		          _VFP.StatusBar = 'Company Name: ' + proper(m.goapp.cCompanyName) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ELSE
		          _VFP.StatusBar = 'Data Path: ' + LOWER(m.goapp.cdatafilepath) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		       ENDIF    
		    CATCH
		    ENDTRY    
		  ENDIF
		
		
		  IF NOT EMPTY(THIS.cMenu) AND NOT ISNULL(THIS.oStateManager)
		    LOCAL ix, oNewForm
		
		    m.oNewForm = .NULL.
		    IF NOT THISFORM.Visible
		      * This form is closing, find the new topmost form in global form object array.
		      IF _SCREEN.FormCount > 1 AND NOT EMPTY(WONTOP())
		        FOR ix = 1 TO _SCREEN.FormCount
		          * Find obj ref to topmost form. Exclude forms from COM based apps.
		          IF TYPE('_SCREEN.Forms[m.ix].Baseclass') = 'C' AND UPPER(_SCREEN.Forms[m.ix].name) == WONTOP()
		            m.oNewForm = _SCREEN.Forms[m.ix]
		            EXIT
		          ENDIF
		        ENDFOR
		      ENDIF
		
		      * If no new form, or a non-codemine modeless form, clean up form context now.
		      IF ISNULL(m.oNewForm)
		        THIS.oStateManager.SetFormMenu()
		      ELSE
		        IF m.oNewForm.WindowType = 0
		          IF NOT PEMSTATUS(m.oNewForm, 'lCodeMineHelp', 5)    && Keep this on its own line...
		            THIS.oStateManager.SetFormMenu()
		          ENDIF
		        ENDIF
		      ENDIF
		    ELSE
		      * Another form has become active, get a reference to it.
		      * VFP5 bug prevents us from using TYPE('_SCREEN.ActiveForm.Name') = 'C' here to test
		      * for a new form, or VFP can crash. Access form array as a workaround.
		      * Storing a ref to _SCREEN.Forms[m.ix] in a variable will also cause problems, but only
		      * if focus is currently in a textbox in the deactivating form. Very fragile code here, be careful.
		      IF TYPE('_SCREEN.ActiveForm.BaseClass') = 'C' AND _SCREEN.ActiveForm.BaseClass == 'Form'
		        WITH _SCREEN.ActiveForm
		          IF .Name == THIS.Name
		            THIS.oStateManager.SetFormMenu()
		          ELSE
		            IF .WindowType = 0
		              IF NOT PEMSTATUS(_SCREEN.ActiveForm, 'lCodeMineHelp', 5)
		                THIS.oStateManager.SetFormMenu()
		              ENDIF
		            ENDIF
		          ENDIF
		        ENDWITH
		      ELSE
		        THIS.oStateManager.SetFormMenu()
		      ENDIF
		    ENDIF
		  ENDIF
		  THIS.nControlFlags  = BITCLEAR(THIS.nControlFlags , FRMFLAG_ACTIVE)  && Mark us as no longer active
		
		  * A little trick borrowed from Flash's Codebook, sends output to the 
		  * main VFP window when the command window is active.
		  IF VERSION(2) != 0
		    ACTIVATE SCREEN BOTTOM
		  ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		*++
		* Clean up our form context, and prepare for release.
		*--
		IF NOT ISNULL(THIS.oApp)
		   * Remove us from the application window popup if needed.
		   IF THIS.lWindowMenu
		      THIS.lWindowMenu = .F.
		      THIS.oApp.RebuildWindowPopup()
		   ENDIF
		ENDIF
		
		THIS.VISIBLE = .F.     && Disappear quickly
		
		* If this is the active form, call its deactivate method.
		IF BITTEST(THIS.nControlFlags, FRMFLAG_ACTIVE)
		   THIS.DEACTIVATE()
		ELSE
		   * Trigger "Window Change" state refresh manually if we close while inactive.
		   cmTriggerCallback(CBR_WINDOW_CHANGE)
		ENDIF
		
		* Remove reference to form-specific toolbar, if any.
		THIS.CloseFormToolbar()
		
		* Save the Windows current size and position, as necessary.
		THIS.SaveSizeAndPosition()
		
		* Clear all external object refs, just to be safe.
		STORE .NULL. TO THIS.oRegistry, THIS.oString, THIS.oSecurity, THIS.oMessage, THIS.oApp
		
		TRY
		   IF m.goApp.lCloudServer
		      _VFP.STATUSBAR = 'Company Name: ' + PROPER(m.goApp.cCompanyName) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		   ELSE
		      _VFP.STATUSBAR = 'Data Path: ' + LOWER(m.goApp.cdatafilepath) + '    - Support Subscription Expires: ' + DTOC(m.goapp.Dsupportexpires)
		   ENDIF
		CATCH
		ENDTRY
		
	ENDPROC

	PROCEDURE displayhelp		&& Display context help for the specified object.
		LPARAMETERS oContext
		*++
		*>>Display context help for the specified object.
		*--
		LOCAL oCtl, cKeyList, cClassKeyList, cKey, cLinks, cText, cFullText, cUsedKeys
		
		  m.oCtl = m.oContext
		  IF NOT ISNULL(THIS.oMessage)
		    STORE '' TO m.cKeyList, m.cClassKeyList, m.cFullText, m.cUsedKeys
		    IF PEMSTATUS(m.oContext, 'cHelpKey', 5)
		      IF EMPTY(m.oContext.cHelpKey)
		        IF PEMSTATUS(m.oContext, 'cValueSource', 5)
		          THIS.InitializeHelp(m.oContext)    && Pick up help key associated with bound data, if any
		        ENDIF
		      ENDIF
		
		      * Load help key list and class key list. Class help keys are ignored for read-only controls.
		      m.cKeyList = m.oContext.cHelpKey
		      IF PEMSTATUS(m.oContext, 'cHelpClassKey', 5) 
		        IF (NOT PEMSTATUS(m.oContext, 'lReadOnly', 5) OR NOT m.oContext.lReadOnly)
		          m.cClassKeyList = m.oContext.cHelpClassKey
		        ENDIF
		      ENDIF
		
		      * If we are in a CodeMine based Grid, integrate the grid help with the control's help.
		      IF NOT m.oContext.BaseClass == 'Form' AND m.oContext.Parent.BaseClass == 'Column'
		        IF PEMSTATUS(m.oContext.Parent.Parent, 'cHelpKey', 5)
		          m.cKeyList = m.cKeyList + ',' + m.oContext.Parent.Parent.cHelpKey
		          m.cClassKeyList = m.cClassKeyList + ',' + m.oContext.Parent.Parent.cHelpClassKey
		        ENDIF
		      ENDIF
		    ENDIF
		
		    m.cKeylist = m.cKeylist + ','  && So it always passes the first time through the not empty() test
		    DO WHILE NOT EMPTY(m.cKeylist)
		      DO WHILE NOT EMPTY(m.cKeylist)
		        m.cKey = LOWER(GetToken(@m.cKeyList, ','))
		        IF NOT EMPTY(m.cKey)
		          IF ',' + m.cKey + ',' $ m.cUsedKeys
		            LOOP   && Recursive reference, just skip over it and move on
		          ENDIF
		          m.cUsedKeys = m.cUsedKeys + ',' + m.cKey + ','
		          IF THIS.oMessage.TranslateHelp(m.cKey, , , @m.cText, @m.cLinks)
		            IF NOT EMPTY(m.cText)
		              IF EMPTY(m.cFullText)
		                m.cFullText = '{'    && RTF encoding expects all text enclosed in braces.
		              ENDIF
		              m.cFullText = m.cFullText + m.cText
		            ENDIF
		            IF NOT EMPTY(m.cLinks)
		              m.cKeyList = m.cKeyList + m.cLinks + ','
		            ENDIF
		          ENDIF
		        ENDIF
		      ENDDO
		
		      * If we don't have a help text for the control yet, search up the object hierarchy looking for one.
		      IF EMPTY(m.cFullText)
		        DO WHILE EMPTY(m.cKeyList) AND NOT m.oCtl.BaseClass == 'Form'
		          m.oCtl = m.oCtl.Parent
		          IF PEMSTATUS(m.oCtl, 'cHelpKey', 5)
		            IF ISNULL(m.oCtl.cHelpKey)   && NULL helpkey means to stop looking
		              EXIT
		            ELSE
		              m.cKeyList = m.oCtl.cHelpKey
		            ENDIF
		          ENDIF
		        ENDDO
		      ENDIF
		
		      * When all out of context help keys, append class key list from original control the got the help request.
		      IF EMPTY(m.cKeyList)
		        m.cKeylist = m.cClassKeyList
		        m.cClassKeyList = ''
		      ENDIF
		    ENDDO
		
		    IF NOT EMPTY(m.cFullText)
		      m.cFullText = m.cFullText + '}'
		      IF m.oCtl.BaseClass == 'Form'   && Title type comes from object we got main help text from.
		        THISFORM.oMessage.DisplayHelp(@m.cFullText, '%txtFormHelpTitle', THIS.NiceName(THISFORM))
		      ELSE
		        THISFORM.oMessage.DisplayHelp(@m.cFullText, '%txtFieldHelpTitle', ;
		                                      THIS.NiceName(m.oContext), THIS.NiceName(THISFORM))
		      ENDIF
		      RETURN .T.
		    ELSE
		      THIS.DisplayMessage('%msgNoHelp')
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE displaymessage		&& Calls the form message object to display an error message.
		LPARAMETERS cMsg, uArg1, uArg2, uArg3
		*++
		*>>Calls the form message object to display an error message.
		* May be overridden in user subclass for custom message display.
		*--
		LOCAL lStatus, nSelect
		  * Messages displayed from code inside grid events may cause unexpected default workarea changes,
		  * because of the way grids are implemented in VFP. Preserving workarea across message display
		  * seems to minimize the side effects of this problem.
		  m.nSelect = SELECT()
		  IF NOT ISNULL(THIS.oMessage) AND VARTYPE(THIS.oMessage) == 'O'
		    m.lStatus = THIS.oMessage.Display(m.cMsg, THIS.Caption, @m.uArg1, @m.uArg2, @m.uArg3)
		  ELSE
		    * No Message manager available - use standard VFP dialog.
		    MESSAGEBOX(m.cMsg, 0, THIS.Caption)
		  ENDIF
		  SELECT (m.nSelect)
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE displaywarning		&& Use the Message Manager service to display a Warning Message dialog, with optional detailed explanation text.
		LPARAMETERS cMsg, cDetails, uP1, uP2, uP3
		*++
		*>>Use the Message Manager service to display a Warning Message dialog, with optional detailed explanation text.
		*--
		LOCAL nSelect
		
		  m.nSelect = SELECT()
		  IF NOT ISNULL(THIS.oMessage)
		    THIS.oMessage.Dialog(MSG_DIALOG_CONFIRM_OK, MSG_SEVERITY_WARNING, ;
		                          @m.cMsg, @m.cDetails, THIS.Caption, m.uP1, m.uP2, m.uP3)
		  ELSE
		    MESSAGEBOX(m.cMsg, 48, THIS.Caption)
		  ENDIF
		  SELECT (m.nSelect)
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		*++
		* Handle form level errors, and errors from controls with no handler of their own.
		* Provide custom processing for the following VFP error numbers:
		*  1         - file not found
		*  202       - Invalid path or filename
		*  3, 108, 1705, 1995 - file in use
		*  15        - Not a table
		*  41        - memo missing
		*  19, 114   - damaged index
		*  1707      - Structural CDX not found
		*  1540      - 
		*  1001      - Feature not available
		*--
		LOCAL cFatalMsg
		  DO CASE
		    CASE INLIST(m.nError,1001,1540,1967)               && Dataenvironment already unloaded
		      RETURN .T.                       && Ignore it
		
		    CASE m.nError = 2012 AND THIS.WindowType = 1   && Can't call SetFocus() from within Valid() error.
		      * A VFP bug can cause SetFocus() in modal child forms called from a valid() event to 
		      * incorrectly trigger this error when SetFocus() is used within the child.
		      RETURN .T.
		
		    CASE INLIST(m.nError, 1733, 1752) AND PROPER(m.cMethod) == 'Load' 
		      * Class in use or not found. Common design-time errors when loading CDE, or 
		      * other component objects, so we display the error in a simple dialog, and 
		      * let the Load() method abort the form load cleanly.
		      * No need to localize, since this should only be an error during development.
		      MESSAGEBOX('Form Cannot Load - ' + MESSAGE(), 16, THIS.Caption)
		      RETURN .T.
		
		    CASE m.nError = 1 AND '.PRG' $ SYS(2018)
		      * A prg file not found is a fatal error
		      m.cFatalMsg = 'Procedure ' + PROPER(STRTRAN(SYS(2018), '.PRG', '')) + '() is not found'
		
		    CASE ISNULL(THIS.oMessage)         && Everything else fatal if no message handler
		      m.cFatalMsg = MESSAGE()
		
		    CASE INLIST(m.nError, 1, 202, 2004)
		      THIS.AddProperty('nOpenError', m.nError)  && Set form load error flag
		      THIS.DisplayMessage('%msgFileNotFound', SYS(2018))
		
		      * FilenotFound from DE gets stuck in infinite loop. Cancel is only way out.
		      IF '.dataenvironment.' $ m.cMethod
		        CANCEL
		      ENDIF
		
		    CASE INLIST(m.nError, 3, 108, 1705, 1995)
		      THIS.AddProperty('nOpenError', m.nError)  && Set form load error flag
		      THIS.DisplayMessage('%msgFileInUse', SYS(2018))
		
		    CASE INLIST(m.nError, 15, 19, 41, 114, 1707)
		      THIS.AddProperty('nOpenError', m.nError)  && Set form load error flag
		      THIS.DisplayMessage('%msgFileDamaged', SYS(2018), MESSAGE())
		
		    OTHERWISE
		      m.cFatalMsg = MESSAGE()
		  ENDCASE
		
		  IF NOT EMPTY(m.cFatalMsg)
		    IF ISNULL(THIS.oMessage)
		      ERROR 'Error at line ' + LTRIM(STR(m.nLine)) + ' of ' + m.cMethod + CHR(13) + m.cFatalMsg
		    ELSE
		      RETURN THIS.oMessage.FatalError(m.cFatalMsg, m.cMethod, m.nLine)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE flushcontrolbuffer		&& Move focus off current control to flush control data buffer.
		*++
		*>>Move focus off current control to flush control data buffer.
		* Store reference to object that had focus, so it can be restored later.
		* Also, Grids do not refresh properly when they have focus and the record set changes.
		*--
		LOCAL oCtl, cClass, cName
		
		  IF TYPE('THIS.Activecontrol.BaseClass') = 'C'
		    m.cClass = THIS.Activecontrol.Baseclass 
		    IF m.cClass $ 'Commandbutton,Checkbox,Listbox,Optionbutton,Page' ;
		    OR (m.cClass = 'Olecontrol' AND ('COMCTL.' $ THIS.Activecontrol.oleClass OR 'MSComctlLib.' $ THIS.Activecontrol.oleClass))
		      RETURN .T.
		    ENDIF
		
		    IF NOT PEMSTATUS(THIS, 'chkTemporaryFocus___', 5)
		      * Use a checkbox for temporary focus object because it is small, and has no
		      * effect on default-CommandButton highlight when changing focus.
		      THIS.AddObject('chkTemporaryFocus___', 'Checkbox')
		      WITH THIS.chkTemporaryFocus___
		        .Top = -100
		        .Left = -100
		        .Width = 10
		        .Tabstop = .F.
		        .Visible = .T.
		        .StatusbarText = ' '
		      ENDWITH
		    ENDIF
		
		    m.cName = THIS.Activecontrol.Name
		    m.oCtl = THIS.Activecontrol.Parent
		
		    * If the tempfocus control doesn't have focus now, it means a validation rule failed somewhere.
		    THIS.chkTemporaryFocus___.Setfocus()
		    IF TYPE('THIS.Activecontrol.Name') != 'C' OR NOT UPPER(THIS.Activecontrol.name) == 'CHKTEMPORARYFOCUS___'
		      RETURN .F.
		    ENDIF
		
		    * VFP5 can't be trusted to store object refs here, due to internal bugs. Store object path as workaround.
		    * Cant use sys(1272) either due to bugs that occur only after starting a fresh instance of VFP.
		    DO WHILE NOT m.oCtl.Baseclass == 'Form'
		      m.cName = m.oCtl.Name + '.' + m.cName
		      m.oCtl = m.oCtl.Parent
		    ENDDO
		    m.cName = m.oCtl.Name + '.' + m.cName  && Always pre-pend the form name
		    THIS.cLastControl = m.cName
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE formvalid		&& Custom developer-supplied Form level validation code, called by ValidateForm().
		*++
		*>>Custom developer-supplied Form level validation code, called by ValidateForm().
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE GotFocus
		*++
		* Called when the form (or any contained control) first gets focus.
		*--
		  * If this is a modal form, put up its form menu now, if any.
		  * No need to remove pre-existing form menu if this form has none, since it will be disabled.
		  IF NOT ISNULL(THIS.oStateManager) AND THIS.WindowType = 1 AND NOT EMPTY(THIS.cMenu)
		    THIS.oStateManager.SetFormMenu(THIS.cMenu, .T.)  && Force reload of menu, even if same name as existing one.
		  ENDIF
		
		  * Call the form AfterOpen() event the first time we get focus.
		  IF NOT BITTEST(THIS.nControlFlags, FRMFLAG_OPEN)
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_OPEN)
		    THIS.Afteropen()
		  ENDIF
		
	ENDPROC

	PROCEDURE Init
		*++
		* Initialize the form
		*--
		  * Turn off minimize button for modal windows.
		  IF THIS.WindowType = 1
		    THIS.MinButton = .F.
		  ENDIF
		  IF THIS.lCodemineHelp OR THIS.lCloseOnEscape
		    THIS.KeyPreview = .T.
		  ENDIF
		
		  * Get default caption and display name from help key
		  IF NOT EMPTY(THIS.cHelpKey) AND EMPTY(THIS.cDisplayName)
		    THIS.InitializeHelp(THIS)
		  ENDIF
		  IF EMPTY(THIS.Caption)
		    THIS.Caption = THIS.cDisplayName
		  ENDIF
		
		  * Localize the caption if localization is enabled
		  IF THIS.lLocalizeCaption AND NOT ISNULL(THIS.oMessage)
		    THIS.Caption = THIS.oMessage.Localize(THIS.Caption)
		  ENDIF
		
		  * Append instance number to form title, and add window to window popup.
		  * Do it here, so user has a chance to parameterize the title.
		  IF NOT EMPTY(THIS.Caption) AND THIS.nInstance > 1
		    THIS.Caption = THIS.Caption + ' (' + LTRIM(STR(THIS.nInstance)) + ')'
		  ENDIF
		
		  THIS.OpenFormToolbar()
		  IF NOT ISNULL(THIS.oApp)
		    IF THIS.WindowType = 0 AND THIS.lWindowMenu
		      THIS.oApp.RebuildWindowPopup()
		    ELSE
		      THIS.lWindowMenu = .F.
		    ENDIF
		  ENDIF
		
		  * Restore last saved size and position as appropriate.
		  THIS.RestoreSizeAndPosition()
		
		  * If tooltips are enabled, translate tooltip text in the background during idle time.
		  IF THIS.ShowTips AND NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.RequestBackgroundRefresh(THIS)
		  ENDIF
		
		  * Background image doesn't always stay on bottom, so put it back, just in case.
		  IF PEMSTATUS(THIS, '_imgBackgroundTexture', 5)
		    THIS._imgBackgroundTexture.ZOrder(1)
		  ENDIF
		
		  IF NOT THIS.BeforeOpen()
		    RETURN THIS.Abort()
		  ENDIF
		
	ENDPROC

	PROCEDURE initializeallhelp		&& Initialize help key translations for all controls in the specified container.
		LPARAMETERS oParent
		*++
		*>>Initialize help key translations for all controls in the specified container.
		*--
		LOCAL ix, oCtl
		  * Recursive loop to translate tooltips and statusbar text for contained controls.
		  FOR ix = 1 TO m.oParent.ControlCount
		    * Another workaround for VFP5.0 object reference count bug.
		    * Must clear reference variable before re-assigning a new value.
		    m.oCtl = .NULL.
		    m.oCtl = m.oParent.Controls[m.ix]
		    DO CASE
		      CASE m.oCtl.BaseClass == 'Container' AND NOT PEMSTATUS(m.oCtl, 'SetTipStatus', 5)
		        THIS.InitializeAllHelp(m.oCtl)
		      CASE m.oCtl.BaseClass == 'Pageframe'
		        LOCAL nPage
		        FOR nPage = 1 TO m.oCtl.PageCount
		          IF m.oCtl.Pages[m.nPage].Enabled
		            THIS.InitializeAllHelp(m.oCtl.Pages[m.nPage])
		          ENDIF
		        ENDFOR
		      OTHERWISE
		        IF PEMSTATUS(m.oCtl, 'cHelpKey', 5)
		          IF PEMSTATUS(m.oCtl, 'nControlFlags', 5)
		            THIS.InitializeHelp(m.oCtl)
		          ENDIF
		        ENDIF
		    ENDCASE
		  ENDFOR
		
	ENDPROC

	PROCEDURE initializehelp		&& Translate the specified control's help key and set tooltip and statusbar text.
		LPARAMETERS oCtl
		*++
		*>>Translate the specified control's help key and set tooltip and statusbar text.
		* 1) Load data-related help for bound controls with no helpkey set.
		* 2) Translate tooltoptext and statusbartext
		*
		* Even though this method can be a little slow, it is only called for one control
		* at a time, the first time it gets focus, so there is little performance impact.
		* Toolbars with tooltips enabled translate all controls in the background during
		* VFP idle time, so again there is little performance lost.
		*--
		LOCAL cKey, cShortText, cTipText
		
		  IF NOT BITTEST(m.oCtl.nControlFlags, CTLFLAG_HELP_INITIALIZED) AND NOT ISNULL(THIS.oMessage)
		    * If no field help key for control bound to a cursor field, look for help key associated with data
		    STORE '' TO m.cTipText, m.cShortText
		    IF EMPTY(m.oCtl.cHelpKey) 
		      IF PEMSTATUS(m.oCtl, 'cValueSource', 5)
		        IF NOT EMPTY(m.oCtl.cValueSource) AND NOT EMPTY(m.oCtl.cWorkarea)
		          m.cKey = '%fld' + SUBSTR(m.oCtl.cValueSource, RAT('.', m.oCtl.cValueSource) + 1)
		          IF THIS.oMessage.TranslateHelp(m.cKey, @m.cShortText, @m.cTipText)
		            m.oCtl.cHelpKey = m.cKey
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		
		    * Translate statusbar and tooltip text
		    IF EMPTY(m.oCtl.cHelpKey) AND PEMSTATUS(m.oCtl, 'cHelpClassKey', 5)
		      * If no help key, try to get status & tip text from first class help key
		      m.cKey = GetToken(m.oCtl.cHelpClassKey, ',')
		    ELSE
		      * If cKey is empty, THIS.cHelpkey has not been translated yet.
		      m.cKey = IIF(EMPTY(m.cKey), m.oCtl.cHelpKey, '')
		    ENDIF
		    IF NOT EMPTY(m.cKey)
		      THIS.oMessage.TranslateHelp(m.cKey, @m.cShortText, @m.cTipText)
		    ENDIF
		
		    * For an EXE, set empty statusbar text to a Space, to prevent display of VFP workarea info on statusbar.
		    IF EMPTY(m.cShortText)
		      m.cShortText = IIF(VERSION(2) = 0, ' ', '')
		    ENDIF
		
		    IF PEMSTATUS(m.oCtl, 'ButtonCount', 5)
		      LOCAL ix, cLastStatus, cLastTip
		      m.cLastStatus = ''
		      m.cLastTip = GetToken(@m.cTipText, ',')  && First tip is group control name
		      IF EMPTY(m.oCtl.cDisplayName)
		        m.oCtl.cDisplayName = m.cLastTip
		      ENDIF
		      FOR ix = 1 TO m.oCtl.ButtonCount
		        IF NOT EMPTY(m.cTipText)
		          m.cLastTip = GetToken(@m.cTipText, ',')
		        ENDIF
		        IF NOT EMPTY(m.cShortText)
		          m.cLastStatus = GetToken(@m.cShortText, ',')
		        ENDIF
		
		        * Store whatever we came up with only if nothing else was explicitly specified by the app developer.
		        IF EMPTY(m.oCtl.Buttons[m.ix].ToolTipText) AND (NOT THIS.lButtonTipsOnly OR m.oCtl.Baseclass == 'Commandbutton')
		          m.oCtl.Buttons[m.ix].ToolTipText = m.cLastTip
		        ENDIF
		        IF EMPTY(m.oCtl.Buttons[m.ix].StatusbarText)
		          m.oCtl.Buttons[m.ix].StatusbarText = m.cLastStatus
		        ENDIF
		      ENDFOR
		    ELSE
		      IF PEMSTATUS(m.oCtl, 'cDisplayName', 5)
		        IF EMPTY(m.oCtl.cDisplayName)
		          m.oCtl.cDisplayName = m.cTipText
		        ENDIF
		      ENDIF
		      IF PEMSTATUS(m.oCtl, 'SetTipStatus', 5)
		        * Custom control objects don't have tip & statusbartext, but controls contined inside them might.
		        m.oCtl.SetTipStatus(m.cTipText, m.cShortText)
		      ELSE
		        * If showing tooltips set the tooltip text for the control. If lButtonTipsOnly is .T. then
		        * only set the tiptext for button controls.
		        IF PEMSTATUS(m.oCtl, 'ToolTipText', 5)
		          IF THIS.ShowTips AND EMPTY(m.oCtl.ToolTipText) ;
		          AND (NOT THIS.lButtonTipsOnly OR (m.oCtl.Baseclass == 'Commandbutton' ;
		               OR (m.oCtl.Baseclass == 'Checkbox' AND m.oCtl.Style = 1)))
		            m.oCtl.ToolTipText = m.cTipText
		          ENDIF
		        ENDIF
		        IF PEMSTATUS(m.oCtl, 'StatusbarText', 5)
		          IF EMPTY(m.oCtl.StatusbarText) AND LEN(m.cShortText) > 0
		            m.oCtl.StatusbarText = m.cShortText
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		
		    * Remember that help has been translated so we dont waste time doing it again.
		    m.oCtl.nControlFlags = BITSET(m.oCtl.nControlFlags, CTLFLAG_HELP_INITIALIZED)
		  ENDIF
		
	ENDPROC

	PROCEDURE initsession		&& Initialize data session settings for a private data session. Not called if form runs in the default session.
		*++
		*>>Initialize data session settings for a private data session. Not called if form runs in the default session.
		*--
		  SET DELETED ON              && Deleted must be ON for correct operation.
		  SET MULTILOCKS ON
		
	ENDPROC

	PROCEDURE iseditallowed		&& Controls whether or not data-bound controls in this form may be edited.
		LPARAMETERS cWorkArea, cField
		*++
		*>>Controls whether or not data-bound controls in this form may be edited.
		*--
		  IF NOT EMPTY(m.cWorkArea)
		    RETURN NOT THIS.lWriteLock AND NOT ISREADONLY(m.cWorkarea) AND NOT EOF(m.cWorkarea)
		  ENDIF
		  RETURN NOT THIS.lWriteLock
		
	ENDPROC

	PROCEDURE isempty		&& Return true if the specified workarea is empty - if it has no available records.
		LPARAMETERS cWorkArea
		*++
		*>>Return true if the specified workarea is empty - if it has no available records.
		*--
		  IF NOT EMPTY(m.cWorkArea) AND USED(m.cWorkarea)
		    RETURN EOF(m.cWorkarea)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isenabled		&& Determines whether or not the specified form method can be called from a toolbar button.
		LPARAMETERS cMethod, cWorkArea
		*++
		*>>Determines whether or not the specified form method can be called from a toolbar button.
		*
		* Form Methods used by pre-defined default system actions.
		*    Save, Cancel, Editmode
		*    Report
		*    Close
		*    Next, Last, Prior, First
		*    List, Find, Requery
		*    New, Delete
		*--
		  m.cMethod = PROPER(m.cMethod)
		  DO CASE
		    CASE m.cMethod == 'Close'
		      * Closable property determines if we can be closed or not.
		      RETURN THIS.Closable
		    CASE m.cMethod == 'Save' OR m.cMethod == 'Cancel'
		      * Save & Cancel toolbar interface is disabled by default in non-data forms.
		      RETURN .F.
		  ENDCASE
		
		  * All other methods default to enabled, if they exist (which they won't, unless developer adds them).
		  RETURN .T.
		
	ENDPROC

	PROCEDURE isnew		&& Return true if the current record in specified workarea is newly appended.
		LPARAMETERS cWorkArea
		*++
		*>>Return true if the current record in specified workarea is newly appended.
		*--
		  IF NOT EMPTY(m.cWorkArea) AND CURSORGETPROP('Buffering', m.cWorkarea) > 1
		    RETURN GETFLDSTATE(0, m.cWorkarea) > 2
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isopenallowed		&& Check security settings to see if this form is allowed to be opened. Developer can always open any form.
		*++
		*>>Check security settings to see if this form is allowed to be opened. Developer can always open any form.
		*--
		  IF NOT EMPTY(THIS.cOpenPrivilege) AND NOT ISNULL(THIS.oSecurity) ;
		  AND NOT THIS.oSecurity.HasPrivilege('Developer') 
		    LOCAL cPriv, cPrivs
		    m.cPrivs = THIS.cOpenPrivilege
		    DO WHILE NOT EMPTY(m.cPrivs)
		      m.cPriv = GetToken(@m.cPrivs, ',')
		      IF NOT EMPTY(m.cPriv) AND THIS.oSecurity.HasPrivilege(m.cPriv)
		        RETURN .T.
		      ENDIF
		    ENDDO
		    THIS.DisplayMessage('%msgNoPrivilege')
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		*++
		* Preview keys for F1 context help, Close-on-Escape, and Page change keys.
		*--
		  DO CASE
		    CASE THIS.lCodemineHelp AND m.nKeyCode = 28
		      NODEFAULT
		      IF TYPE('THIS.ActiveControl.Name') = 'C'
		        IF PEMSTATUS(THIS.ActiveControl, 'ShowWhatsThis', 5)
		          THIS.DisplayHelp(THIS.ActiveControl)
		          RETURN
		        ENDIF
		      ENDIF
		      THIS.DisplayHelp(THIS)
		
		    CASE THIS.lCloseOnEscape AND m.nKeyCode = 27
		      NODEFAULT
		      THIS.Close()
		
		    CASE m.nShiftAltCtrl = 0 AND (m.nKeyCode == 19 OR m.nKeyCode == 4)  && Left=19, Right=4
		      LOCAL oCtl
		      IF TYPE('THIS.ActiveControl.Name') == 'C' AND THIS.ActiveControl.BaseClass == 'Page'
		        m.oCtl = THIS.ActiveControl.Parent
		        IF PEMSTATUS(m.oCtl, 'SetPage', 5)
		          m.oCtl.SetPage(0, IIF(m.nKeyCode = 19, -1, 1))
		          NODEFAULT
		        ENDIF
		      ENDIF
		      
		    CASE m.nShiftAltCtrl = 0 AND (m.nKeyCode == 18 OR m.nKeyCode == 3)  && pgup=18, pgdn=3
		      LOCAL oCtl, nPage
		      IF TYPE('THIS.ActiveControl.Name') == 'C'
		        m.oCtl = THIS.ActiveControl
		        DO WHILE NOT m.oCtl.BaseClass == 'Form'
		          IF m.oCtl.BaseClass == 'Grid'
		            IF PEMSTATUS(m.oCtl, 'lGridGetsPageKeys', 5)
		              IF m.oCtl.lGridGetsPageKeys
		                EXIT
		              ENDIF
		            ENDIF
		          ENDIF
		          IF m.oCtl.BaseClass == 'Pageframe'
		            IF PEMSTATUS(m.oCtl, 'lPageChangeKeys', 5)
		              IF m.oCtl.lPageChangeKeys
		                * Use pg up/down to change pages in the current pageFrame.
		                m.oCtl.SetPage(0, IIF(m.nKeyCode = 18, -1, 1))
		                NODEFAULT
		                EXIT
		              ENDIF
		            ENDIF
		          ENDIF
		          m.oCtl = m.oCtl.Parent
		        ENDDO
		      ENDIF
		  ENDCASE
		
	ENDPROC

	PROCEDURE Load
		*++
		* Initialize datasession and data environment.
		*--
		  SET TALK OFF         && Too messy, keep it off
		
		  * Add private properties only used internaly. 
		  THIS.AddProperty('lChanged')            && Form contains uncommited changes.
		  THIS.AddProperty('nInstance', 1)        && Instance number of this form
		  THIS.AddProperty('nOriginalWidth', 0)   && Original width of container, set by Init method.
		  THIS.AddProperty('nOriginalHeight', 0)  && Original height of container, set by Init method.
		  THIS.AddProperty('nOpenError', 0)       && Contains the VFP error number of last file open error.
		  THIS.AddProperty('oCDE', .NULL.)        && Runtime reference to CodeMine Data Environment Class
		  THIS.AddProperty('cLastControl')        && Contains full object path of the control that had focus before the current commandbutton was pressed.
		  THIS.AddProperty('cNextControl')        && Contains full object path of the control to recieve focus on the next form Activate, or call to ActivateNextControl().
		
		  * Init session settings for a private data session.
		  IF THIS.DataSession = 2
		    THIS.InitSession()
		  ENDIF
		
		  * Load references to global objects needed by this form.
		  IF NOT THIS.LoadGlobalReferences()
		    RETURN .F.
		  ENDIF
		
		  * Check security settings to see if this form is allowed to be opened.
		  IF NOT THIS.IsOpenAllowed()
		    RETURN .F.
		  ENDIF
		
		  * Create context menu manager if the form does not already contain one.
		  IF NOT EMPTY(THIS.cContextMenuClass)
		    IF NOT PEMSTATUS(THIS, 'cmContextMenu', 5)
		      THIS.AddNewObject('cmContextMenu', THIS.cContextMenuClass)
		    ENDIF
		  ENDIF
		
		  * Create a default Data Binding Manager if the form does not already contain one.
		  IF NOT EMPTY(THIS.cBindingManagerClass)
		    IF NOT PEMSTATUS(THISFORM, 'cmBindingManager', 5)
		      THIS.AddNewObject('cmBindingManager', THIS.cBindingManagerClass)
		    ENDIF
		  ENDIF
		
		  * If this form is modeless, make sure it has a unique name.
		  * Name must be determined early on to access stored system registry keys
		  * containing data related info, such as current record.
		  IF THIS.WindowType = 0
		    LOCAL ix, nInstance, cName
		    m.nInstance = 1
		    m.cName = THIS.Name + '001'
		    FOR ix = 2 TO _SCREEN.FormCount      && This new form is alway index 1.
		      IF TYPE('_SCREEN.Forms[m.ix].Baseclass') = 'C'
		        IF _SCREEN.Forms[m.ix].BaseClass == 'Form' AND _SCREEN.Forms[m.ix].Name == m.cName
		          m.nInstance = m.nInstance + 1
		          m.cName = THIS.Name + PADL(LTRIM(STR(m.nInstance,3)), 3, '0')
		          m.ix = 1                       && This will restart the loop at 2, after auto-increment
		        ENDIF
		      ENDIF
		    ENDFOR
		
		    * Assign the new form name and update the title.
		    THIS.Name = m.cName
		    THIS.nInstance = m.nInstance
		  ENDIF
		
		  * Determine system registry key to use for this form. If application object exists,
		  * it has an application-specific key name. Form controls may need to access this property
		  * from their init methods, so we need to set it early.
		  IF NOT ISNULL(THIS.oApp)
		    THIS.cSysRegRoot = THIS.oApp.cSysRegRoot
		    IF EMPTY(THIS.Icon)
		      THIS.Icon = THIS.oApp.cIcon     && Get default icon while we're here
		    ENDIF
		  ENDIF
		  THIS.cSysRegFormRoot = THIS.cSysRegRoot + '\Forms\' + THIS.Name
		
		  * Load the data environment for the form.
		  IF NOT THIS.LoadDataEnvironment()
		    RETURN THIS.Abort()
		  ENDIF
		
		  * The data env must be opened now, before VFP tries to resolve control binding - especially in grids.
		  * Note that DM level rule objects have not yet been linked, so any BeforeOpen() rules 
		  * will not fire if the rule classes are placed in the Form container, rather than in the CDE container.
		  IF (VARTYPE(THIS.oCDE) = 'O' AND NOT THIS.oCDE.OpenAll())
		    RETURN THIS.Abort()
		  ENDIF
		
		  * Remember which data entry preference properties we should read from app-registry settings.
		  IF ISNULL(THIS.lConfirmClose)
		    THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_READ_CONFIRMCLOSE)
		  ENDIF
		
		  * Store original size for use by form's reposition method. Need to save size before any on-form
		  * controls get a chance to modify the form size.
		  THIS.nOriginalWidth = THIS.Width
		  THIS.nOriginalHeight = THIS.Height
		
		  * Set background texture. Must be done before form size is restored, and before any stretchy-resize ctl is added.
		  THIS.SetBackgroundTexture()
		
		  * Call user AfterLoad() event for custom developer post-load code. Needs to be called after 
		  * Data Env is loaded, but before any controls are initialized. Called later for dataChild forms.
		  IF NOT 'datachild' $ PROPER(THIS.cClass)
		    IF NOT THIS.AfterLoad()
		      RETURN THIS.Abort()
		    ENDIF
		  ENDIF
		
		  * If we have a reference to the state manager, and are modeless, request update messages 
		  * when local app registry values change. Do this after AfterLoad() completes, so any
		  * runtime-only properties will be available.
		  IF NOT ISNULL(THIS.oStateManager) AND THIS.WindowType = 0
		    THIS.oStateManager.SubscribeNoInit('Registry Update Local', THIS)
		  ENDIF
		  THIS.RegistryUpdate()   && language-specific setup.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE loaddataenvironment		&& Load the data environment for the form. Supports Native VFP SCX Data Environments and the CodeMine CDE class.
		*++
		*>>Load the data environment for the form. Supports Native VFP SCX Data Environments and the CodeMine CDE class.
		*--
		LOCAL oNDE, oCDE, nCdeFlags, aDataObjs[1]
		
		  * Let the CDE know it is part of a form, and if it should expect a DataManager to be there.
		  m.nCdeFlags = CDEMASK_FORM + IIF(PROPER(THIS.cClass) == PROPER('frmDataForm'), CDEMASK_DATAFORM, 0)
		
		  * Find a native data environment object, or create a custom one if cDataEnvironment property is set.
		  STORE .NULL. TO m.oNDE, m.oCDE
		  IF PEMSTATUS(THIS, 'DataEnvironment', 5)
		    IF AMEMBERS(aDataObjs, THIS.DataEnvironment, 2) > 0
		      m.oNDE = THISFORM.DataEnvironment           && Native VFP dataenv contained in SCX file
		    ENDIF
		  ENDIF
		
		  IF NOT EMPTY(THIS.cDataEnvironment)
		    * This class may be a CDE or NDE. We can't tell until after it is created. Since a NDE does not 
		    * accept an Init() parameter, we can not include one here to pass the required flag values to a CDE.
		    * Instead, we use a private variable that the CDE knows to check for.
		    PRIVATE pnCdeControlFlagParameter
		    m.pnCdeControlFlagParameter = m.nCdeFlags
		    m.oCDE = CreateNewObject(THIS.cDataEnvironment)
		    IF VARTYPE(m.oCDE) != 'O'                     && Abort if CDE creation fails
		      RETURN .F.
		    ENDIF
		    IF m.oCDE.Baseclass == 'Dataenvironment'      && If it is a NDE...
		      ASSERT ISNULL(m.oNDE) MESSAGE 'If there is a native SCX data environment, then cDataEnvironment must be a CodeMine DE or empty.'
		      m.oNDE = m.oCDE
		      m.oCDE = .NULL.
		    ENDIF
		  ENDIF
		
		  * If we have cursor definitions in a Native Data Environment, create a Codemine DE from it.
		  IF NOT ISNULL(m.oNDE)
		    IF ISNULL(m.oCDE)
		      m.oCDE = CreateNewObject('cmDataEnvironmentCustom', m.oNDE, m.nCdeFlags)
		    ELSE
		      m.oCDE.LoadNDE(m.oNDE)  && Add native DE cursors to existing CDE
		    ENDIF
		  ENDIF
		  THIS.oCDE = m.oCDE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE loadglobalreferences		&& Check for presence of Codemine Environment. Return .F. to prevent form loading.
		*++
		*>>Check for presence of Codemine Environment. Return .F. to prevent form loading.
		*--
		  * If Codemine.prg is loaded, and Application object exists we can assume environment is ok.
		  IF NOT 'CODEMINE.FLL' $ SET('LIBRARY') ;
		  OR (ISNULL(THIS.oApp) AND BITTEST(THIS.nControlFlags, FRMFLAG_CODEMINE_ENV))
		    MESSAGEBOX('Form cannot load - CodeMine Environment is not running', 16)
		    RETURN .F.
		  ENDIF
		
	ENDPROC

	PROCEDURE nicecursorname		&& Call message manager to return a user-friendly name for the specified cursor workarea.
		LPARAMETERS cWorkarea
		*++
		*>>Call message manager to return a user-friendly name for the specified cursor workarea.
		*--
		  IF PEMSTATUS(THIS, 'cmDataManager', 5)
		    RETURN THIS.cmDataManager.NiceCursorName(@m.cWorkarea)
		  ENDIF
		  RETURN m.cWorkarea
		
	ENDPROC

	PROCEDURE nicefieldname		&& Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		LPARAMETERS cFieldName
		*++
		*>>Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		*--
		  IF PEMSTATUS(THIS, 'cmDataManager', 5)
		    RETURN THIS.cmDataManager.NiceFieldName(LEFT(m.cFieldName, RAT('.', m.cFieldName) - 1), @m.cFieldName)
		  ENDIF
		  RETURN m.cFieldName
		
	ENDPROC

	PROCEDURE nicename		&& Return a user-friendly name for the specified object.
		LPARAMETERS oCtl
		*++
		*>>Return a user-friendly name for the specified object.
		*
		* 1) If the control has caption or cDisplayName property (localized), use that as the name.
		* 2) If control is in a grid, use column heading caption (probably localized).
		* 3) If bound to a cursor field:
		*     3A) If field has a caption, use that (not localized).
		*     3B) Use field name
		* 4) If the control has a linked label, use the label caption.
		* 5) If the control has toolTipText, use that as the name.
		* 6) Use control's name property.
		*--
		LOCAL cName
		
		  * First, check for tooltip or Caption properties.
		  IF PEMSTATUS(m.oCtl, 'cDisplayName', 5)
		    * cDisplayname can be set from control cHelpKey translation.
		    IF EMPTY(m.oCtl.cDisplayName)
		      IF PEMSTATUS(m.oCtl, 'cHelpKey', 5)
		        IF PEMSTATUS(m.oCtl, 'cValueSource', 5)
		          THIS.InitializeHelp(m.oCtl)  && This may fill in cDisplayName
		        ENDIF
		      ENDIF
		    ENDIF
		    IF NOT EMPTY(m.oCtl.cDisplayName)
		      RETURN m.oCtl.cDisplayName
		    ENDIF
		  ENDIF
		  IF PEMSTATUS(m.oCtl, 'Caption', 5)
		    IF NOT EMPTY(m.oCtl.Caption)
		      RETURN m.oCtl.Caption
		    ENDIF
		  ENDIF
		
		  * If in a grid, use the column's caption
		  IF TYPE('m.oCtl.Parent.Baseclass') = 'C' AND m.oCtl.Parent.Baseclass == 'Column'
		    RETURN m.oCtl.Parent.Controls[1].Caption
		  ENDIF
		
		  * Then check for a Codemine databound cValueSource/cWorkarea control
		  IF PEMSTATUS(m.oCtl, 'cValueSource', 5)
		    IF NOT EMPTY(m.oCtl.cWorkArea) AND NOT EMPTY(m.oCtl.cValueSource)
		      m.cName = THIS.NiceFieldName(m.oCtl.cValueSource)
		    ENDIF
		  ENDIF
		
		  * If there is a linked label control, use that caption.
		  IF PEMSTATUS(m.oCtl, 'cLinkedLabel', 5)
		    IF NOT EMPTY(m.oCtl.cLinkedLabel)
		      LOCAL oLabel
		      m.oLabel = EVALUATE('m.oCtl.Parent.' + m.oCtl.cLinkedLabel)
		      m.cName = ALLTRIM(STRTRAN(m.oLabel.Caption, ':', ''))
		    ENDIF
		  ENDIF
		  
		  * As a last chance for an unbound control, use tooltip text.
		  IF EMPTY(m.cName)
		    IF PEMSTATUS(m.oCtl, 'ToolTipText', 5)
		      IF NOT EMPTY(m.oCtl.ToolTipText)
		        m.cName = m.oCtl.ToolTipText
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * If no other name could be found, use the control name itself.
		  IF EMPTY(m.cName)
		    m.cName = PROPER(m.oCtl.Name)
		  ENDIF
		
		  * Store the name in cDisplayName so it will be available faster next time.
		  IF PEMSTATUS(m.oCtl, 'cDisplayName', 5)
		    m.oCtl.cDisplayName = m.cName
		  ENDIF
		  RETURN m.cName
		
	ENDPROC

	PROCEDURE oapp_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF VARTYPE(THIS.oApp) != 'O'
		    IF ISNULL(THIS.oApp)
		      * Set flag indicating that app object and CM environment are required for this form.
		      THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_CODEMINE_ENV)
		    ENDIF
		    IF 'CODEMINE.FXP' $ SET('PROCEDURE')
		      THIS.oApp = FindGlobalObject('appApplication')
		    ELSE
		      RETURN .NULL.
		    ENDIF
		  ENDIF
		  RETURN THIS.oApp
		
	ENDPROC

	PROCEDURE omessage_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oMessage) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oMessage) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oMessage = FindGlobalObject('cmMessage')
		  ENDIF
		  RETURN THIS.oMessage
		
	ENDPROC

	PROCEDURE oname_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oName) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oName) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oName = CreateGlobalObject('cmNameParser')
		  ENDIF
		  RETURN THIS.oName
		
	ENDPROC

	PROCEDURE openformtoolbar		&& Put up any form-specific toolbars
		*++
		*>>Put up any form-specific toolbars
		*--
		  IF NOT EMPTY(THIS.cToolbar) AND NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.AddToolbar(THIS.cToolbar, THIS.lToolbarMemory, .T.)
		  ENDIF
		
	ENDPROC

	PROCEDURE oregistry_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oRegistry) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oRegistry) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oRegistry = FindGlobalObject('cmRegistry')
		  ENDIF
		  RETURN THIS.oRegistry
		
	ENDPROC

	PROCEDURE osecurity_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oSecurity) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oSecurity) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oSecurity = FindGlobalObject('cmSecurity')
		  ENDIF
		  RETURN THIS.oSecurity
		
	ENDPROC

	PROCEDURE ostatemanager_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oStateManager) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oStateManager) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oStateManager = FindGlobalObject('cmStateManager')
		  ENDIF
		  RETURN THIS.oStateManager
		
	ENDPROC

	PROCEDURE ostring_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oString) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oString) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oString = FindGlobalObject('cmStringTools')
		  ENDIF
		  RETURN THIS.oString
		
	ENDPROC

	PROCEDURE QueryUnload
		  * Dont close without going through the release method.
		  NODEFAULT
		
		  * Call the BeforeClose method with the reason the form wants to close.
		  IF THIS.BeforeClose(THIS.releaseType)
		    THIS.Release()
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE registryupdate		&& Initialize or update properties from stored registry values. Called on Init and whenever the app registry is changed.
		*++
		*>>Initialize or update properties from stored registry values. Called on Init and whenever the app registry is changed.
		*--
		  IF NOT ISNULL(THIS.oRegistry) AND BITTEST(THIS.nControlFlags, FRMFLAG_READ_CONFIRMCLOSE)
		    THIS.lConfirmClose = THIS.oRegistry.GetKeyValue(KEYNAME_CONFIRM_CLOSE, KEY_TYPE_LOGICAL, .T.)
		  ENDIF
		
		  * If we are in a private datasession, set up the language-related environment
		  IF THIS.dataSession = 2 AND NOT ISNULL(THIS.oMessage)
		    LOCAL oLanguage
		    * Set language related settings for our datasession.
		    m.oLanguage = THIS.oMessage.cmLanguageValue
		    IF m.oLanguage.lSysFormat
		      SET SYSFORMATS ON
		    ELSE
		      SET SYSFORMATS OFF
		      IF PROPER(m.oLanguage.cCurrencyFormat) = 'Left'
		        SET CURRENCY LEFT
		      ELSE
		        SET CURRENCY RIGHT
		      ENDIF
		      SET CURRENCY TO (m.oLanguage.cCurrencySymbol)
		      SET POINT TO (m.oLanguage.cDecimal)
		      SET SEPARATOR TO (m.oLanguage.cSeparator)
		      SET MARK TO (m.oLanguage.cMark)
		      SET DATE TO (m.oLanguage.cDateFormat)
		      SET HOURS TO (m.oLanguage.nHourFormat)
		      IF m.oLanguage.lCentury
		        SET CENTURY ON
		      ELSE
		        SET CENTURY OFF
		      ENDIF
		    ENDIF
		    SET CENTURY TO (THIS.oMessage.nCentury) ROLLOVER (THIS.oMessage.nRollover)
		    IF THIS.oMessage.lAutoTab
		      SET CONFIRM OFF
		    ELSE
		      SET CONFIRM ON
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE Release
		LPARAMETERS lRelease
		*++
		* Custom release code for foundation form class.
		*--
		  * Cancel any outstanding subscriptions to state manager events. 
		  * This includes appreg update events, and links to action buttons on the form.
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.UnSubscribe('*', THIS)
		  ENDIF
		
		  * When the last toplevel form closes, and Main VFP window is hidden, clear the READ EVENTS.
		  IF THIS.ShowWindow = 2 AND (NOT _SCREEN.Visible OR THIS.lClearEventsOnClose)
		    LOCAL oForm
		    FOR EACH oForm IN _SCREEN.Forms
		      * If we find any other toplevel forms around, don't Clear Events
		      * Other regular forms, defined windows or toolbars don't count.
		      IF m.oForm.BaseClass == 'Form' AND m.oForm.ShowWindow = 2 AND NOT m.oForm.Name == THIS.Name
		        RETURN .T.
		      ENDIF
		    ENDFOR
		    CLEAR EVENTS
		  ENDIF
		
		  * If called by a modal subclass, we may not want to physically release yet.
		  IF PCOUNT() > 0 AND NOT m.lRelease
		    NODEFAULT
		  ENDIF
		
	ENDPROC

	PROCEDURE repositioncontents		&& Reposition the contents of the specified container object after a resize.
		LPARAMETERS oContainer, nHeight, nWidth
		*++
		*>>Reposition the contents of the specified container object after a resize.
		* Parameter may be a form, container, or page.
		*--
		LOCAL cOption, oThis, oParent
		
		  m.oParent = IIF(m.oContainer.Baseclass = 'Page', m.oContainer.parent, m.oContainer)
		  * Some containers don't have Height and width set acurately when their Resize()
		  * event triggers us (like page frames). So, for those cases, caller passes us the real size.
		  IF PCOUNT() = 1
		    m.nHeight = m.oParent.Height
		    m.nWidth = m.oParent.Width
		  ENDIF
		  FOR EACH oThis IN m.oContainer.Controls
		    IF PEMSTATUS(m.oThis, 'cReposition', 5) AND NOT EMPTY(m.oThis.cReposition)
		      * Skip VFP 9+ controls with a non-empty Anchor property setting.
		      IF PEMSTATUS(m.oThis, 'Anchor', 5) AND NOT EMPTY(m.oThis.Anchor)
		        LOOP
		      ENDIF
		
		      m.cOption = UPPER(m.oThis.cReposition)
		
		      * Resize container so the right and bottom edges maintain the same distance from
		      * the corresponding edges of the object that contains them.
		      IF 'HCENTER' $ m.cOption
		        m.oThis.left = (m.nWidth - m.oThis.width) / 2
		      ELSE
		        IF NOT PEMSTATUS(m.oThis, 'nRight', 5)
		          m.oThis.AddProperty('nRight', .NULL.)
		        ENDIF
		        IF ISNULL(m.oThis.nRight)   && Store initial distance from right edge
		          m.oThis.nRight = m.oParent.nOriginalWidth - (m.oThis.left + m.oThis.width)
		        ENDIF
		        IF 'HFOLLOW' $ m.cOption
		          m.oThis.left = m.nWidth - (m.oThis.width + m.oThis.nRight)
		        ENDIF
		        IF 'HSTRETCH' $ m.cOption
		          LOCAL nNewWidth
		          m.nNewWidth = MAX(1,  m.nWidth - (m.oThis.left + m.oThis.nRight))
		          IF m.oThis.BaseClass == 'Pageframe'
		            * This is a workaround for VFP bug, where pageframe reports old size info in Resize() event.
		            m.oThis.Set('Width', m.nNewWidth)
		          ELSE
		            m.oThis.Width = m.nNewWidth
		          ENDIF
		        ENDIF
		      ENDIF
		
		      IF 'VCENTER' $ m.cOption
		        m.oThis.top = (m.nHeight - m.oThis.height) / 2
		      ELSE
		        IF NOT PEMSTATUS(m.oThis, 'nBottom', 5)
		          m.oThis.AddProperty('nBottom', .NULL.)
		        ENDIF
		        IF ISNULL(m.oThis.nBottom)   && Store initial distance from bottom
		          m.oThis.nBottom = m.oParent.nOriginalHeight - (m.oThis.top + m.oThis.height)
		        ENDIF
		        IF 'VFOLLOW' $ m.cOption
		          m.oThis.top = m.nHeight - (m.oThis.height + m.oThis.nBottom)
		        ENDIF
		        IF 'VSTRETCH' $ m.cOption
		          LOCAL nMin, nNewHeight
		          m.nMin = IIF(m.oThis.BaseClass == 'Pageframe' OR m.oThis.BaseClass == 'Grid', 25, 1)
		          m.nNewHeight = MAX(m.nMin, m.nHeight - (m.oThis.Top + m.oThis.nBottom))
		          IF m.oThis.BaseClass == 'Pageframe'
		            * This is a workaround for VFP bug, where pageframe reports old size info in Resize() event.
		            m.oThis.Set('Height', m.nNewHeight)
		          ELSE
		            m.oThis.Height = m.nNewHeight
		          ENDIF
		        ENDIF
		      ENDIF
		
		    ENDIF
		
		    * Trigger "Moved" event for codemine 3d effects labels
		    IF m.oThis.BaseClass == 'Label'
		      IF PEMSTATUS(m.oThis, 'Moved', 5)
		        m.oThis.Moved()
		      ENDIF
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE Resize
		*++
		* Reposition all objects contained in the form after a resize. Lock the
		* screen to speed refresh, and ensure background is cleaned up properly.
		*--
		  THIS.LockScreen = .T.
		  THIS.RepositionContents(THIS)
		  THIS.LockScreen = .F.
		
	ENDPROC

	PROCEDURE restoresizeandposition		&& Restore last saved window size and position.
		*++
		*>>Restore last saved window size and position.
		*--
		LOCAL cPos
		  IF (THIS.lRememberPosition OR THIS.lRememberSize) AND NOT ISNULL(THIS.oApp)
		    * Position info saved as Top,Left,Height,Width,Max
		    IF THIS.oApp.GetPreference(THIS.cSysRegFormRoot + '\Position', @m.cPos) AND LEN(m.cPos) == 17
		      IF THIS.lRememberSize
		        IF THIS.MaxButton AND SUBSTR(m.cPos, 17, 1) == 'M'
		          THIS.WindowState = 2
		          IF NOT THIS.MDIform
		            THIS.Resize()       && Must be called explicitly
		          ENDIF
		        ELSE
		          IF THIS.BorderStyle = 3
		            THIS.Height= VAL(SUBSTR(m.cPos, 9, 4))
		            THIS.Width = VAL(SUBSTR(m.cPos, 13, 4))
		            THIS.Resize()       && Must be called explicitly
		          ENDIF
		        ENDIF
		      ENDIF
		
		      IF (THIS.lRememberPosition AND THIS.WindowState == 0 AND SUBSTR(m.cPos, 17, 1) != 'M')
		        THIS.Top = MAX(0, VAL(SUBSTR(m.cPos, 1, 4)))
		        THIS.Left = MAX(0, VAL(SUBSTR(m.cPos, 5, 4)))
		        * Make sure restored position will be visible in the current main window
		        IF THIS.ShowWindow = 0 AND _SCREEN.Visible AND _SCREEN.ScaleMode = THIS.ScaleMode
		          THIS.Top = MIN(THIS.Top, MAX(0, _SCREEN.Height - 75))
		          THIS.Left = MIN(THIS.Left, MAX(0, _SCREEN.Width - (THIS.Width/2)))
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * If position could not be restored, apply cascade offset to default position.
		  IF THIS.WindowState = 0 AND EMPTY(m.cPos) AND THIS.nInstance > 1 AND THIS.nCascadeOffset > 0
		    THIS.Left = MIN(_SCREEN.Width - 50, THIS.Left + (THIS.nCascadeOffset * (THIS.nInstance - 1)))
		    THIS.Top = MIN(_SCREEN.Height - 50, THIS.Top + (THIS.nCascadeOffset * (THIS.nInstance - 1)))
		  ENDIF
		
	ENDPROC

	PROCEDURE RightClick
		*++
		*>>Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF THIS.ContextMenuInit(THIS) AND THIS.ContextMenuBuild()
		    m.cOption = THIS.ContextMenuActivate()
		    IF NOT EMPTY(m.cOption)
		      THIS.ContextMenuExecute(m.cOption)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE save		&& Toolbar/button/menu interface for SaveAllChanges()
		LPARAMETERS cWorkarea
		*++
		*>>Toolbar/button/menu interface for SaveAllChanges()
		* Currently, the cWorkarea parameter is ignored for this method.
		*--
		LOCAL lStatus
		  IF THIS.FlushControlBuffer()
		    m.lStatus = THIS.ValidateForm() AND THIS.SaveAllChanges()
		    THIS.ActivateNextControl()
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE saveallchanges		&& Save all changes. Called by the form.Save() to apply changes.
		*++
		*>>Save all changes. Called by the form.Save() to apply changes.
		*--
		  THIS.SetChanged(.F.)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE savesizeandposition		&& Save current size and position of window.
		*++
		*>>Save current size and position of window.
		*--
		  IF (THIS.lRememberPosition OR THIS.lRememberSize) AND NOT ISNULL(THIS.oApp)
		    LOCAL cPos
		    * Position infor saved as Top,Left,Height,Width,Max
		    m.cPos = STR(THIS.Top,4) + STR(THIS.Left,4) + STR(THIS.Height,4) + STR(THIS.Width,4) ;
		           + IIF(THIS.WindowState == 2, 'M', ' ')
		    THIS.oApp.SetPreference(THIS.cSysRegFormRoot  + '\Position', m.cPos)
		  ENDIF
		
	ENDPROC

	PROCEDURE setbackgroundtexture		&& Set the background texture image for the form or the specified container.
		LPARAMETERS oTarget
		*++
		*>>Set the background texture image for the form or the specified container.
		*--
		LOCAL cBackGround, lTile
		
		  * If Form or App cFormBackground property is null, we do not apply any background to anything in the form.
		  IF ISNULL(THIS.cFormBackground) OR ISNULL(THIS.oApp) ;
		  OR (ISNULL(THIS.oApp.cFormBackground) AND EMPTY(NVL(THIS.cFormBackground,'')))
		    RETURN .F.
		  ENDIF
		
		  m.cBackground = IIF(EMPTY(THIS.cFormBackground), THIS.oApp.cFormBackground, THIS.cFormBackground)
		  m.lTile = THIS.oApp.lFormBackgroundTile
		
		  * If no target is passed, assume the form.
		  IF PCOUNT() = 0
		    m.oTarget = THIS
		  ENDIF
		
		  IF m.lTile OR EMPTY(m.cBackground) OR NOT FILE(m.cBackground)
		    IF PEMSTATUS(m.oTarget, '_imgBackgroundTexture', 5)
		      m.oTarget._imgBackgroundTexture.Visible = .F.
		    ENDIF
		    IF PEMSTATUS(m.oTarget, 'Picture', 5)
		      m.oTarget.Picture = IIF(EMPTY(m.cBackground), '', m.cBackground)
		    ENDIF
		  ELSE
		    * Create an image control to display stretched background images.
		    IF NOT PEMSTATUS(m.oTarget, '_imgBackgroundTexture', 5)
		      * Target might be a Form, Container, or page in a pageframe.
		      m.oTarget.AddObject('_imgBackgroundTexture', 'imgImage')
		      WITH m.oTarget._imgBackgroundTexture
		        STORE 0 TO .Top, .Left, .nRight, .nBottom
		        .Stretch = 2
		        .BorderStyle = 0
		        .cReposition = 'VSTRETCH,HSTRETCH'
		      ENDWITH
		    ENDIF
		
		    WITH m.oTarget._imgBackgroundTexture
		      IF PEMSTATUS(m.oTarget, 'Width', 5)
		        .Width = m.oTarget.Width + 1
		        .Height = m.oTarget.Height + 1
		      ELSE      && If container is a page, we get dimensions from the parent frame.
		        .Width = m.oTarget.Parent.Width + 1
		        .Height = m.oTarget.Parent.Height + 1
		      ENDIF
		      .Zorder(1)
		      .Picture = m.cBackground
		      .Visible = .T.
		    ENDWITH
		  ENDIF
		
	ENDPROC

	PROCEDURE setchanged		&& Set the form's lChanged flag to the specified value.
		LPARAMETERS lValue, cWorkarea
		*++
		*>>Set the form's lChanged flag to the specified value.
		*--
		  IF PCOUNT() > 0
		    IF THIS.lChanged != m.lValue
		      THIS.lChanged = m.lValue
		      THIS.AfterStateChange(THIS.lChanged)
		    ENDIF
		  ENDIF
		  RETURN THIS.lChanged
		
	ENDPROC

	PROCEDURE setlastcontrol		&& Set the object to recieve focus when the current Form Action method completes un-successfuly.
		LPARAMETERS oControl
		*++
		*>>Set the object to recieve focus when the current Form Action method completes un-successfuly.
		*--
		  THIS.cLastControl = IIF(TYPE('m.oControl.Name') = 'C', SYS(1272, m.oControl), .NULL.)
		
	ENDPROC

	PROCEDURE setnextcontrol		&& Set the object to recieve focus when the next Form Action method completes successfuly.
		LPARAMETERS oControl
		*++
		*>>Set the object to recieve focus when the next Form Action method completes successfuly.
		*--
		  THIS.cNextControl = IIF(PCOUNT() = 1, IIF(TYPE('m.oControl.Name') = 'C', SYS(1272, m.oControl), .NULL.), '')
		
	ENDPROC

	PROCEDURE Show
		LPARAMETERS nMode
		*++
		* Custom Show event processing
		*--
		  * Reposition form controls if maximized on open.
		  IF THIS.WindowState == 2
		    IF PCOUNT() = 1
		      DODEFAULT(m.nMode)
		    ELSE
		      DODEFAULT()
		    ENDIF
		    THIS.RepositionContents(THIS)
		  ENDIF
		
	ENDPROC

	PROCEDURE ShowWhatsThis
		LPARAMETERS nNativeHelpID
		*++
		* Show context help for the form.
		*--
		  IF THIS.lCodemineHelp
		    NODEFAULT
		    THIS.DisplayHelp(THIS)
		  ENDIF
		
	ENDPROC

	PROCEDURE skipvalid		&& Returns .T. if the current control should not enforce field level validation.
		*++
		*>>Returns .T. if the current control should not enforce field level validation.
		* Field validation should be skipped if the user pressed a "Cancel" or "Revert"
		* button. The idea is to prevent a situation where the user must enter a valid value
		* into the current field before being allowed to discard changes.
		*--
		LOCAL lMouseDown
		
		  * Special workaround for VFP bug/quirk. If a control Valid fails when the user clicks on another
		  * form the user cannot re-activate the original window by clicking on the window.
		  * We detect this case here and re-activate the window.
		  m.lMouseDown = (cmLastKey() = -1)
		  IF m.lMouseDown AND NOT BITTEST(THIS.nControlFlags, FRMFLAG_ACTIVE)
		    ACTIVATE WINDOW (THIS.Name) NOSHOW TOP
		  ENDIF
		
		  * Skip validation if form level flag is set.
		  IF BITTEST(THIS.nControlFlags, FRMFLAG_SKIP_VALID)
		    RETURN .T.
		  ENDIF
		
		  * If there is a cancel/revert type button that was just clicked, we also return true.
		  * We need to know what button was clicked BEFORE the When() of the button is called.
		  * The Valid() event of the current control occurs first, so the only way we can tell
		  * if the vilidation was triggered by a cancel button is to play mouse games to see what
		  * button is under the mouse, if the mouse button is down.
		  IF m.lMouseDown
		    m.oCtl = SYS(1270)
		    IF VARTYPE(m.oCtl) = 'O'
		      IF PEMSTATUS(m.oCtl, 'lSkipValid', 5)   && Needs to be in its own IF line
		        IF m.oCtl.lSkipValid
		          * User clicked on a cancel button, skip validation of the current control
		          * if the button is on the same form.
		          DO WHILE TYPE('m.oCtl.Parent') == 'O'
		            m.oCtl = m.oCtl.Parent
		          ENDDO
		          IF m.oCtl.BaseClass == 'Form' AND m.oCtl.Name == THIS.Name
		            RETURN .T.
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.   && Don't skip validation
		
	ENDPROC

	PROCEDURE Unload
		*++
		* Release the CDE when the form is unloaded.
		*
		* Note that this event does not occur if the form is terminated before 
		* the load() event completes successfully.
		*--
		  IF VARTYPE(THIS.oCDE) = 'O'
		    THIS.oCDE.Release()
		  ENDIF
		
	ENDPROC

	PROCEDURE validatecontents		&& Recursive routine to call each control's FormValid() method.
		LPARAMETERS oParent, cWorkareaList
		*++
		*>>Recursive routine to call each control's FormValid() method.
		*--
		LOCAL ix, lStatus, oCtl
		
		  * Call the parent's FormValid() method first, if any.
		  m.lStatus = .T.
		  IF PEMSTATUS(m.oParent, 'FormValid', 5)
		    m.lStatus = IIF(EMPTY(m.cWorkareaList), m.oParent.FormValid(), m.oParent.FormValid(m.cWorkareaList))
		  ENDIF
		
		  FOR ix = 1 TO m.oParent.ControlCount
		    * If multi-message is enabled, keep going even after we find the first error.
		    IF NOT m.lStatus AND NOT BITTEST(THIS.nControlFlags , FRMFLAG_BATCHING_MESSAGES)
		      EXIT
		    ENDIF
		
		    * Another workaround for VFP5.0 object reference count bug.
		    * Must clear reference variable before re-assigning a new value.
		    m.oCtl = .NULL.
		    m.oCtl = m.oParent.Controls[m.ix]
		    DO CASE
		      CASE m.oCtl.BaseClass == 'Container' AND m.oCtl.Visible
		        m.lStatus = THIS.ValidateContents(m.oCtl, @m.cWorkareaList) AND m.lStatus
		
		      CASE m.oCtl.BaseClass == 'Pageframe'
		        LOCAL nPage, lCurrentOnly
		        IF m.oCtl.Visible
		          IF PEMSTATUS(m.oCtl, 'lValidateAllPages', 5)
		            m.lCurrentOnly = NOT m.oCtl.lValidateAllPages
		          ENDIF
		          IF m.lCurrentOnly
		            m.nPage = m.oCtl.PageOrderToIndex(m.oCtl.ActivePage)
		            m.lStatus = THIS.ValidateContents(m.oCtl.Pages[m.nPage], @m.cWorkareaList) AND m.lStatus
		          ELSE
		            THIS.nControlFlags = BITSET(THIS.nControlFlags, FRMFLAG_FORCE_RELOAD)
		            FOR nPage = 1 TO m.oCtl.PageCount
		              IF m.oCtl.Pages[m.nPage].Enabled
		                * Makes sure control values in inactive pages are current before validating.
		                IF m.oCtl.ActivePage != m.oCtl.Pages[m.nPage].PageOrder
		                  m.oCtl.Pages[m.nPage].Refresh()
		                ENDIF
		                m.lStatus = THIS.ValidateContents(m.oCtl.Pages[m.nPage], @m.cWorkareaList) AND m.lStatus
		              ENDIF
		            ENDFOR
		            THIS.nControlFlags = BITCLEAR(THIS.nControlFlags, FRMFLAG_FORCE_RELOAD)
		          ENDIF
		        ENDIF
		
		      OTHERWISE
		        * Call the FormValid method of each control that has one, and is bound to data in specified workarea.
		        * Grid.Formvalid() gets called even when lWritelock is set as long as its not readonly. This
		        * allows Formvalid() to be called even when the grid is empty (ie no records).
		        IF PEMSTATUS(m.oCtl, 'FormValid', 5)
		          IF m.oCtl.Enabled AND m.oCtl.Visible ;
		          AND ((m.oCtl.BaseClass == 'Grid' AND NOT m.oCtl.ReadOnly) OR NOT m.oCtl.lWriteLock) ;
		          AND (EMPTY(m.cWorkareaList) OR PROPER(m.oCtl.cWorkarea) + ',' $ m.cWorkareaList + ',')
		            IF EMPTY(m.oCtl.FormValid())
		              IF m.lStatus     && Set next focus to first control with an error.
		                THIS.SetNextControl(m.oCtl)
		              ENDIF
		              m.lStatus = .F.
		            ENDIF
		          ENDIF
		        ENDIF
		    ENDCASE
		  ENDFOR
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE validateform		&& Form level control validation driver.
		*++
		*>>Form level control validation driver.
		*--
		LOCAL lStatus
		  IF NOT ISNULL(THIS.oMessage) AND THIS.oMessage.BeginMultiMessage()
		    THIS.nControlFlags  = BITSET(THIS.nControlFlags , FRMFLAG_BATCHING_MESSAGES)
		  ENDIF
		
		  m.lStatus = THIS.ValidateContents(THIS)
		
		  IF BITTEST(THIS.nControlFlags , FRMFLAG_BATCHING_MESSAGES)
		    THIS.oMessage.EndMultiMessage()
		    THIS.nControlFlags  = BITCLEAR(THIS.nControlFlags, FRMFLAG_BATCHING_MESSAGES)
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmmodaldatachild AS frmdataformcustom OF "..\custom\cforms.vcx" 		&& Modal Child DataForm, for editing data in one or more cursors with the option to commit or rollback the changes.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: returnvalue		&& Return the form's value, and release it.
		*p: cmdatamanager		&& Reference to calling form's data manager object
		*p: cmlookupmanager		&& Reference to calling form's lookup manager object
		*p: lreleaseonclose		&& If .F. then form will not release when closed. This allows caller to retrieve property values from the form before explicitly releasing it.
		*p: lsaveonclose		&& Set to .T. if closing this child form should trigger a Save() for the cursors listed in cSaveWorkarea.
		*p: ocaller		&& Object reference to calling parent form.
		*p: uvalue		&& Return value for the dialog.
	*</DefinedPropArrayMethod>

	Caption = "Modal Data Child"
	cclass = frmModalDataChild
	cdataenvironment = 
	cfinddialogclass = 
	clistdialogclass = 
	cmdatamanager = .NULL.		&& Reference to calling form's data manager object
	cmlookupmanager = .NULL.		&& Reference to calling form's lookup manager object
	ControlBox = .F.
	csaveworkarea = 
	DataSession = 1
	DoCreate = .T.
	lallowdelete = .F.
	lallowedit = .F.
	lallownavigation = .F.
	lallownew = .F.
	lexpliciteditmode = .NULL.
	lreleaseonclose = .T.		&& If .F. then form will not release when closed. This allows caller to retrieve property values from the form before explicitly releasing it.
	lsaveonclose = .F.		&& Set to .T. if closing this child form should trigger a Save() for the cursors listed in cSaveWorkarea.
	lwindowmenu = .F.
	MinButton = .F.
	Name = "frmmodaldatachild"
	nchildrefreshmode = 1
	ocaller = .NULL.		&& Object reference to calling parent form.
	ShowWindow = 1
	uvalue = .F.		&& Return value for the dialog.
	WindowType = 1
	
	PROCEDURE Activate
		*++
		*>>Custom activate for frmDataChild forms.
		*--
		  * The parent form keeps a reference to the active child form.
		  IF NOT ISNULL(THIS.oCaller)
		    THIS.cmDataManager.SetActiveChildForm(THIS)
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE cancelallchanges
		LPARAMETERS cWorkareaList
		*++
		*>>Set false return value when the dialog is canceled.
		*--
		  THIS.oCDE.LocalTransRollback(UPDATEMASK_NOCLOSE)
		
		  * Dialog return value for caller - Cancel always returns false.
		  THIS.uValue = .F.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Deactivate
		*++
		*>>Custom deactivate for frmDataChild forms.
		*--
		  IF NOT ISNULL(THIS.oCaller)
		    THIS.cmDataManager.SetActiveChildForm(.NULL.)
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE Destroy
		*++
		* When the dialog closes we end the local transaction level we started when we were opened.
		*--
		  IF NOT ISNULL(THIS.oCDE)
		    * Close and commit the local transaction for the dialog.
		    THIS.oCDE.LocalTransCommit()
		  ENDIF
		
		  * Make sure calling form correctly shows any changed made in the dialog.
		  IF THIS.lChanged
		    THIS.oCaller.RefreshAll()
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS oCaller
		*++
		*>>Custom init code for frmModalDataChild.
		*
		* The oCaller parameter is obsolete. A reference to the calling form is now set in the Load() method.
		*--
		  * Default the form title to that of calling form
		  IF EMPTY(THIS.Caption)
		    THIS.Caption = THIS.oCaller.Caption
		  ENDIF
		
		  * Begin a local transaction, so we can restore on cancel.
		  THIS.oCDE.LocalTransBegin()
		
		  * Inherit workarea properties from parent form, if we have no explicit settings of our own.
		  IF EMPTY(THIS.cWorkarea)
		    THIS.cWorkArea = THIS.oCaller.cWorkArea
		    THIS.cNavWorkArea = THIS.oCaller.cNavWorkArea
		  ENDIF
		  IF EMPTY(THIS.cNavWorkarea)
		    THIS.cNavWorkArea = THIS.cWorkArea
		  ENDIF
		  IF EMPTY(THIS.cSaveWorkarea)
		    THIS.cSaveWorkArea = THIS.oCaller.cSaveWorkArea
		  ENDIF
		
		  IF DODEFAULT()
		    * If any in cSaveWorkarea list has a new parent, then we must disable lSaveOnClose.
		    * Note that the cSaveWorkarea should only list parent cursors, not the parent and 
		    * related children. But it is ok to specify a child cursor, without its parent.
		    IF THIS.lSaveOnClose AND NOT '*' $ THIS.cSaveWorkArea
		      LOCAL oCursor, cWorkarea, cWorkareaList
		      m.cWorkareaList = THIS.cSaveWorkArea
		      DO WHILE NOT EMPTY(m.cWorkareaList)
		        m.cWorkarea = GetToken(@m.cWorkareaList, ',')
		        m.oCursor = THIS.oCDE.GetCursor(m.cWorkarea)
		        IF NOT ISNULL(m.oCursor) AND NOT ISNULL(m.oCursor.oParent) AND m.oCursor.oParent.IsNew()
		          THIS.lSaveOnClose = .F.
		          EXIT
		        ENDIF
		      ENDDO
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE iseditallowed
		LPARAMETERS cWorkArea, cField
		*++
		*>>Controls whether or not data-bound controls in this child form may be edited.
		*--
		  IF NOT ISNULL(THIS.oCaller)    && Extra test here for cleaner recovery from errors.
		    RETURN DODEFAULT(@m.cWorkArea, @m.cField)
		  ENDIF
		  RETURN NOT THIS.lWriteLock
		
	ENDPROC

	PROCEDURE isenabled
		LPARAMETERS cMethod, cWorkArea
		*++
		*>>Used to determine whether or not the specified form method is enabled or disabled (ie can be called) at the current time.
		*--
		  DO CASE
		    CASE PROPER(m.cMethod) == 'Editmode' AND NOT EMPTY(THIS.cWorkarea)
		      * 0 - Up/disabled = Edit mode not supported, or no data record.
		      * 1 - Up/enabled = Form with explicit edit mode, not enabled.
		      * 2 - Dn/Disable = Form with explicit edit mode in progress
		      * 3 - Dn/Enabled = Edit mode selected, but no changes made yet.
		      IF THIS.lExplicitEditMode AND NOT THIS.cmDataManager.IsEof(THIS.cWorkarea) AND NOT THIS.cmDataManager.IsReadOnly(THIS.cWorkarea)
		        * Never return state 3 for a modal child dialog. We may inherit an active editmode session but
		        * still have no changes in this child form. Reseting editmode cannot be allowed in this case.
		        RETURN MIN(2, IIF(THIS.lWriteLock, 0, 2) + IIF(THIS.lChanged, 0, 1))
		      ENDIF
		      RETURN 0
		
		    CASE PROPER(m.cMethod) == 'Save' OR PROPER(m.cMethod) == 'Cancel'
		      RETURN .F.    && Save/Revert have no meaning in a modal context.
		  ENDCASE
		
		  * Return default values for remaining methods
		  RETURN DODEFAULT(@m.cMethod, @m.cWorkArea)
		
	ENDPROC

	PROCEDURE Load
		*++
		*>>Custom Load event code for frmModalDataChild
		*--
		  SET TALK OFF         && Always force to OFF first to avoid spurious display output.
		
		  * Load a reference to the calling (parent) form, if it is available from the 
		  * custom _Screen property. We don't use _Screen.ActiveForm here so we can guarantee 
		  * consistant operation even if calling form is not currently active.
		  IF PEMSTATUS(_SCREEN, 'oCallingForm', 5)
		    IF NOT ISNULL(_SCREEN.oCallingForm)      && Override current oCaller only if not null.
		      THIS.oCaller = _SCREEN.oCallingForm
		      _SCREEN.oCallingForm = .NULL.
		    ENDIF
		  ENDIF
		
		  * Use current active form as default parent, if no other reference could be found.
		  IF ISNULL(THIS.oCaller) AND TYPE('_SCREEN.ActiveForm') = 'O'
		    THIS.oCaller = _SCREEN.ActiveForm
		  ENDIF
		
		  * Fail if we still don't have a reference to the calling parent form.
		  IF VARTYPE(THIS.oCaller) != 'O'
		    ASSERT .F. MESSAGE THIS.Name + " Could not find parent form - use parent's OpenModalChild() method."
		    RETURN .F.
		  ENDIF
		
		  THIS.cmDataManager = THIS.oCaller.cmDataManager
		  THIS.cmLookupManager = THIS.oCaller.cmLookupManager
		
		  * Make sure we don't create any DM or LM, and call default load code.
		  STORE '' TO  THIS.cDataManagerClass, THIS.cLookupManagerClass
		  IF DODEFAULT()
		    * Warn if there are any cursors defined in a native DE for this form (there shouldnt be any).
		    ASSERT ISNULL(THIS.oCDE) MESSAGE THIS.Name + ': frmModalDataChild forms cannot have any Data Environment of their own'
		    THIS.oCDE = THIS.oCaller.oCDE
		
		    * Null for lExplicitEditMode means to use whatever setting the parent has.
		    IF ISNULL(THIS.lExplicitEditMode)
		      THIS.lExplicitEditMode = THIS.oCaller.lExplicitEditMode
		    ENDIF
		
		    * For explicit Edit Mode, we inherit initial write lock state from the parent form.
		    IF THIS.lExplicitEditMode
		      IF THIS.oCaller.lExplicitEditMode
		        THIS.lWriteLock = THIS.oCaller.lWriteLock
		      ELSE
		        THIS.lWriteLock = .T.
		      ENDIF
		
		      * If writelock would be set, clear it if form data is already modified.
		      IF THIS.lWriteLock
		        THIS.lWriteLock = NOT THIS.cmDataManager.Ischanged(THIS.cSaveWorkarea)
		      ENDIF
		    ENDIF
		    IF THIS.AfterLoad()   && Called now, after CDE reference is loaded.
		      RETURN .T.
		    ENDIF
		    RETURN THIS.Abort()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE openchild
		LPARAMETERS cClass, uArg1, uArg2, uArg3, uArg4, uArg5
		*++
		*>>Open a child (sibling) form. This is not allowed from a modal child form.
		*--
		  ASSERT .F. MESSAGE THIS.Name + ': OpenChild() cannot be called from a modal form'
		  RETURN .F.
		
	ENDPROC

	PROCEDURE Release
		LPARAMETERS lRelease
		*++
		* Custom release code for Modal dialogs.
		*--
		  m.lRelease = m.lRelease OR THIS.lReleaseOnClose
		
		  * The first time we are called, simply hide the form, so caller has a chance
		  * to retrieve properies from this form before it is really released.
		  IF THIS.Visible AND NOT m.lRelease
		    THIS.Hide()
		
		    * Execute foundation class release() code, but not the default VFP method
		    RETURN frmForm::Release(m.lRelease)
		  ENDIF
		
		  * At this point, do a standard release
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE returnvalue		&& Return the form's value, and release it.
		*++
		*>> Return the form's value, and release it.
		*--
		  THIS.Release(.T.)
		  RETURN THIS.uValue
		
	ENDPROC

	PROCEDURE saveallchanges
		LPARAMETERS cWorkareaList
		*++
		*>>Apply changes to caller and close the current local transaction level.
		*--
		  * If lSaveOnClose is set, in record nagivation in progress, we save changes to source tables.
		  IF THIS.lSaveOnClose OR BITTEST(THIS.nControlFlags, FRMFLAG_NAVIGATING)
		    IF NOT THIS.oCDE.UpdateAll(m.cWorkareaList)
		      RETURN .F.
		    ENDIF
		  ENDIF
		
		  * Commit the current local transaction level.
		  THIS.oCDE.LocalTransCommit(UPDATEMASK_NOCLOSE)
		
		  * Return .T. only if data was changed in this dialog. Otherwise, return the original 
		  * value set at design time. This makes it easy for developer to determine whether 
		  * an OK with no changes is treated as an OK or a cancel (returns T or F).
		  IF THIS.lChanged 
		    THIS.uValue = .T.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Unload
		*++
		*>>Custom Unload event code for frmModalDataChild
		*--
		  * Clear ref to parent form, and do NOT call default 
		  * Unload() code, because we don't want to close the CDE now.
		  THIS.oCaller = .NULL.
		
		  * Return uValue property here, for use with DO FORM TO commands
		  RETURN THIS.uValue
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmmodaldialog AS frmformcustom OF "..\custom\cforms.vcx" 		&& CodeMine base modal dialog class.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: returnvalue		&& Return the form's value, and release it.
		*m: saveallchanges		&& Save all changes. Sets form.uValue to .T. by default.
		*p: cclass
		*p: lreleaseonclose		&& If .F. then form will not release when closed. This allows caller to retrieve property values from the form before explicitly releasing it.
		*p: lwindowmenu
		*p: uvalue		&& Return value for the dialog.
	*</DefinedPropArrayMethod>

	caption = 'Modal Dialog'
	cclass = frmModalDialog
	controlbox = .F.
	height = 124
	lreleaseonclose = .F.		&& If .F. then form will not release when closed. This allows caller to retrieve property values from the form before explicitly releasing it.
	lwindowmenu = .F.
	minbutton = .F.
	Name = "frmmodaldialog"
	showwindow = 1
	uvalue = .F.		&& Return value for the dialog.
	width = 380
	windowtype = 1
	
	PROCEDURE load
		  SET TALK OFF         && Always force to OFF first, in case of private data session
		
		  * Load a reference to the calling (parent) form, if it is available from the 
		  * custom _Screen property. We don't use _Screen.ActiveForm here so we can guarantee 
		  * consistant operation even if calling form is not currently active.
		  THIS.Addproperty('oCaller', .NULL.)
		  IF PEMSTATUS(_SCREEN, 'oCallingForm', 5)
		    IF NOT ISNULL(_SCREEN.oCallingForm)      && Override current oCaller only if not null.
		      THIS.oCaller = _SCREEN.oCallingForm
		      _SCREEN.oCallingForm = .NULL.
		    ENDIF
		  ENDIF
		
		  * Use current active form as default parent, if no other reference could be found.
		  IF ISNULL(THIS.oCaller) AND TYPE('_SCREEN.ActiveForm') = 'O'
		    THIS.oCaller = _SCREEN.ActiveForm
		  ENDIF
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE release
		LPARAMETERS lRelease
		*++
		* Custom release code for Modal dialogs.
		*--
		  m.lRelease = m.lRelease OR THIS.lReleaseOnClose
		
		  * The first time we are called, simply hide the form, so caller has a chance
		  * to retrieve properies from this form before it is really released.
		  IF THIS.Visible AND NOT m.lRelease
		    THIS.Hide()
		
		    * Execute foundation class release() code, but not the default VFP method
		    RETURN frmForm::Release(m.lRelease)
		  ENDIF
		
		  * At this point, do a standard release
		  RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE returnvalue		&& Return the form's value, and release it.
		*++
		*>> Return the form's value, and release it.
		*--
		  THIS.Release(.T.)
		  RETURN THIS.uValue
		
	ENDPROC

	PROCEDURE saveallchanges		&& Save all changes. Sets form.uValue to .T. by default.
		*++
		*>>Save all changes. Sets form.uValue to .T. by default.
		*--
		  THIS.uValue = .T.
		  THIS.SetChanged(.F.)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE unload
		*++
		*>>Custom Unload event code for frmModalDialog
		*--
		  DODEFAULT()
		
		  * Return uValue property, for use with DO FORM TO commands
		  RETURN THIS.uValue
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmrequerydialog AS frmmodaldialogcustom OF "..\custom\cforms.vcx" 		&& Foundation class for parameterized view Requery Dialogs.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Cntokcancelcustom1" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: buildparameterlist		&& Build array of view parameters and values.
		*p: cworkarea		&& Workarea, or list of workareas to requery.
		*p: ltranslatewildcards		&& Set .T. to translate standard wildcard characters (*,?) to SQL wildcards (%,_)
		*p: nparametercount		&& Number of defined view parameters
		*p: ocaller		&& Object reference to calling form
		*a: aparameterlist[1,2]		&& Array of view parameters and values
	*</DefinedPropArrayMethod>

	Caption = "Form"
	cworkarea = 		&& Workarea, or list of workareas to requery.
	DoCreate = .T.
	Height = 190
	ltranslatewildcards = .T.		&& Set .T. to translate standard wildcard characters (*,?) to SQL wildcards (%,_)
	Name = "frmrequerydialog"
	nparametercount = 0		&& Number of defined view parameters
	ocaller = .NULL.		&& Object reference to calling form
	Width = 380

	ADD OBJECT 'Cntokcancelcustom1' AS cntokcancelcustom WITH ;
		Left = 108, ;
		Name = "Cntokcancelcustom1", ;
		Top = 156, ;
		cmdcancel.Name = "cmdcancel", ;
		cmdok.Name = "cmdok"
		*< END OBJECT: ClassLib="..\custom\cbutton.vcx" BaseClass="container" />
	
	PROCEDURE buildparameterlist		&& Build array of view parameters and values.
		LPARAMETER oContainer
		*++
		*>>Build array of all view parameter names and values.
		*--
		LOCAL ix, oThis, uValue
		
		  FOR ix = 1 TO m.oContainer.ControlCount
		    m.oThis = m.oContainer.Controls[m.ix]
		
		    DO CASE
		      CASE m.oThis.BaseClass == 'Container' 
		        THIS.BuildParameterList(m.oThis)
		
		      CASE m.oThis.BaseClass == 'Pageframe'
		        LOCAL nPage
		        FOR nPage = 1 TO m.oThis.PageCount
		         THIS.BuildParameterList(m.oThis.Pages[m.nPage])
		        ENDFOR
		
		      CASE PEMSTATUS(m.oThis, 'cViewParameter', 5) AND NOT EMPTY(m.oThis.cViewParameter)
		        THIS.nParameterCount = THIS.nParameterCount + 1
		        DIMENSION THIS.aParameterList[THIS.nParameterCount, 2]
		        THIS.aParameterList[THIS.nParameterCount, 1] = m.oThis.cViewParameter
		
		        IF PEMSTATUS(m.oThis, 'GetValue', 5)
		          m.uValue = m.oThis.GetValue()
		        ELSE
		          m.uValue = m.oThis.Value
		        ENDIF
		        IF TYPE('m.uValue') = 'C'
		          m.uValue = TRIM(m.uValue)
		          IF THIS.lTranslateWildcards
		            m.uValue = CHRTRAN(m.uValue, '*?', '%_')
		          ENDIF
		        ENDIF
		        THIS.aParameterList[THIS.nParameterCount, 2] = m.uValue
		    ENDCASE
		  ENDFOR
		
	ENDPROC

	PROCEDURE Init
		LPARAMETER oCaller, cWorkarea
		
		THIS.oCaller = m.oCaller
		THIS.cWorkarea = IIF(EMPTY(m.cWorkarea), '', m.cWorkarea)
		
		RETURN DODEFAULT()
		
	ENDPROC

	PROCEDURE saveallchanges
		THIS.nParameterCount = 0
		THIS.BuildParameterList(THIS)
		
		* Define the view parameters PRIVATE, so anyone called by us can access them.
		FOR ix = 1 TO THIS.nParameterCount
		  PRIVATE (THIS.aParameterList[m.ix, 1])
		  STORE THIS.aParameterList[m.ix, 2] TO (THIS.aParameterList[m.ix, 1])
		ENDFOR
		
		* Call the calling form's datamanager to perform the actual requery on the appropriate views.
		IF THIS.oCaller.cmDataManager.Requery(THIS.cWorkarea)
		  THIS.uValue = .T.   && Dialog return value is .T. on successful requery
		ENDIF
		RETURN .T.
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS frmwizarddialog AS frmmodaldialogcustom OF "..\custom\cforms.vcx" 		&& Obsolete. Use pageframe and cntNextBackHistory control on any CodeMine form class instead.
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="pgfSteps" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdBack" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdNext" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Cmdcancel1" UniqueID="" Timestamp="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: stepvalid		&& Validate controls in the current step before advancing to the next one.
		*p: cpromptfinish		&& Prompt for Finish button
		*p: cpromptnext		&& Prompt for next button
	*</DefinedPropArrayMethod>

	Caption = "Wizard"
	cpromptfinish = \<Finish		&& Prompt for Finish button
	cpromptnext = \<Next >>		&& Prompt for next button
	DoCreate = .T.
	Height = 211
	Name = "frmwizarddialog"
	Width = 375

	ADD OBJECT 'cmdBack' AS cmdcommandbutton WITH ;
		Caption = "<< \<Back", ;
		creposition = vfollow,hFollow, ;
		Enabled = .F., ;
		Left = 210, ;
		Name = "cmdBack", ;
		TabIndex = 3, ;
		Top = 182
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Cmdcancel1' AS cmdcancel WITH ;
		creposition = vFollow, ;
		Left = 7, ;
		Name = "Cmdcancel1", ;
		TabIndex = 2, ;
		Top = 182
		*< END OBJECT: ClassLib="cmbutton.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdNext' AS cmdcommandbutton WITH ;
		Caption = "Next >>", ;
		creposition = vfollow,hFollow, ;
		Default = .T., ;
		Left = 291, ;
		Name = "cmdNext", ;
		TabIndex = 4, ;
		Top = 182
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'pgfSteps' AS pgfpageframe WITH ;
		ActivePage = 0, ;
		BorderWidth = 0, ;
		creposition = vStretch,hStretch, ;
		ErasePage = .T., ;
		Height = 167, ;
		Left = 2, ;
		Name = "pgfSteps", ;
		TabIndex = 1, ;
		Tabs = .F., ;
		Top = 4, ;
		Width = 371
		*< END OBJECT: ClassLib="codemine.vcx" BaseClass="pageframe" />
	
	PROCEDURE stepvalid		&& Validate controls in the current step before advancing to the next one.
		LPARAMETER nStep
		  * Do FormValid() for each control on the page of the specified step.
		  RETURN THIS.ValidateContents(THIS.pgfSteps.Pages[m.nStep])
		
	ENDPROC

	PROCEDURE cmdBack.Click
		IF THISFORM.pgfSteps.Activepage > 1
		  THISFORM.pgfSteps.Activepage = THISFORM.pgfSteps.Activepage - 1
		  THIS.Refresh()
		  THISFORM.cmdNext.Refresh()
		  THISFORM.SetNextControl(THISFORM.pgfSteps)
		ENDIF
		THISFORM.ActivateNextControl()
		
	ENDPROC

	PROCEDURE cmdBack.Refresh
		THIS.Enabled = THISFORM.pgfSteps.ActivePage > 1
		
	ENDPROC

	PROCEDURE cmdNext.Click
		IF THISFORM.pgfSteps.Activepage < THISFORM.pgfSteps.Pagecount
		  IF THISFORM.StepValid(THISFORM.pgfSteps.Activepage)
		    THISFORM.pgfSteps.Activepage = THISFORM.pgfSteps.Activepage + 1
		    THISFORM.SetNextControl(THISFORM.pgfSteps)
		    THIS.Refresh()
		    THISFORM.cmdBack.Refresh()
		  ENDIF
		ELSE
		  IF THISFORM.BeforeClose(CLOSE_BY_OK)
		    RETURN THISFORM.Release()
		  ENDIF
		ENDIF
		THISFORM.ActivateNextControl()
		
	ENDPROC

	PROCEDURE cmdNext.Refresh
		IF THISFORM.pgfSteps.Pagecount = THISFORM.pgfSteps.Activepage
		  THIS.Caption = THISFORM.cPromptFinish
		ELSE
		  THIS.Caption = THISFORM.cPromptNext
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS tbrtoolbar AS toolbar 		&& CodeMine base Toolbar class.
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*m: backgroundrefresh		&& Background refresh event called during first VFP idle time after Init event.
		*m: contextmenuactivate		&& Call context menu manager to activate the context menu, and return the identifier associated with the option chosen.
		*m: contextmenubar		&& Call context menu manager to define a menu bar for the context menu.
		*m: contextmenubarcheck		&& Set the check-mark for the specified menu bar.
		*m: contextmenubardisable		&& Enable or disbale the specified context menu bar, per the specified expression.
		*m: contextmenubuild
		*m: contextmenuexecute
		*m: contextmenuinit		&& Call context menu manager to initialize context menu popup.
		*m: contextmenuseparator		&& Add a Separator bar to the context menu, only if any other bars are added after.
		*m: displayhelp		&& Display context help for the specified object.
		*m: displaymessage		&& Calls the form message object to display an error message.
		*m: initializehelp		&& Translate the specified control's help key and set tooltip and statusbar text.
		*m: nicename		&& Return a user-friendly name for the specified control in this toolbar.
		*m: oapp_access
		*m: omessage_access
		*m: oregistry_access
		*m: osecurity_access
		*m: ostatemanager_access
		*m: registryupdate		&& Called when app registry changes, if this toolbar subscribes to Registry Update events.
		*m: restoresizeandposition		&& Restore last saved toolbar size and position.
		*m: savesizeandposition		&& Save current size and position of toolbar.
		*m: toolbarmenubuild
		*p: ccontextmenuclass		&& Name of the context menu manager class to use. Leave blank to disable context menus.
		*p: csysregformroot		&& System registry root key used to save form properties. Set in form.load method from cSysregroot and form name.
		*p: csysregroot		&& System registry root key used to save properties.
		*p: cversion		&& Version number of this form. Set this value to your form's version identification string.
		*p: ldockmenu		&& Set to .T. to enable docking command items in the context menu, or to .F. to disbale the docking commands.
		*p: lembeddedtoolbarmenu		&& Set to .T. to display toolbar captions directly in ctx menu allow open & close, or .T. to use Toolbar dialog. Use NULL to disable all toolbar open/close items.
		*p: lrefreshonwindowchange		&& Toolbar refreshes whenever the active window changes.
		*p: lrememberposition		&& Save and restore window position if true.
		*p: ncontrolflags		&& Internal bit flags used to control the toolbar.
		*p: ndefaultdock		&& Specifies initial position of toolbar. 0=Docked Top, -1 Undocked, 1=Docked Left, 2=Right, 3=Bottom.
		*p: oapp		&& Runtime reference to global application object. Set to .F. to prevent reference.
		*p: omessage		&& Runtime reference to cmMessage service object. Set to .F. to find reference on Load.
		*p: oregistry		&& Runtime reference to CodeMine registry global object. Set to .F. to prevent reference.
		*p: osecurity		&& Runtime reference to cmSecurity global service object. Set to .F. to prevent reference on Load.
		*p: ostatemanager		&& Runtime reference to the cmStateManager Global service object. Set to .F. to prevent reference.
	*</DefinedPropArrayMethod>

	Caption = ""
	ccontextmenuclass = cmContextMenuManager		&& Name of the context menu manager class to use. Leave blank to disable context menus.
	csysregformroot = 		&& System registry root key used to save form properties. Set in form.load method from cSysregroot and form name.
	csysregroot = Software\Soft Classics\CodeMine		&& System registry root key used to save properties.
	cversion = 1.0.0		&& Version number of this form. Set this value to your form's version identification string.
	ldockmenu = .T.		&& Set to .T. to enable docking command items in the context menu, or to .F. to disbale the docking commands.
	lembeddedtoolbarmenu = .T.		&& Set to .T. to display toolbar captions directly in ctx menu allow open & close, or .T. to use Toolbar dialog. Use NULL to disable all toolbar open/close items.
	lrefreshonwindowchange = .T.		&& Toolbar refreshes whenever the active window changes.
	lrememberposition = .T.		&& Save and restore window position if true.
	Name = "tbrtoolbar"
	ncontrolflags = 0		&& Internal bit flags used to control the toolbar.
	ndefaultdock = 0		&& Specifies initial position of toolbar. 0=Docked Top, -1 Undocked, 1=Docked Left, 2=Right, 3=Bottom.
	oapp = .NULL.		&& Runtime reference to global application object. Set to .F. to prevent reference.
	omessage = .NULL.		&& Runtime reference to cmMessage service object. Set to .F. to find reference on Load.
	oregistry = .F.		&& Runtime reference to CodeMine registry global object. Set to .F. to prevent reference.
	osecurity = .NULL.		&& Runtime reference to cmSecurity global service object. Set to .F. to prevent reference on Load.
	ostatemanager = .NULL.		&& Runtime reference to the cmStateManager Global service object. Set to .F. to prevent reference.
	ScaleMode = 3
	
	PROCEDURE addnewobject		&& Add a new instance of the specified class to this container. Supports Class-name mappping features.
		LPARAMETERS cName, cClass, uP1, uP2, uP3, uP4, uP5, uP6, uP7, uP8, uP9
		*++
		*>>Add a new instance of the specified class to this container. Supports Class-name mappping features.
		*--
		LOCAL ix, cParams, cLibrary
		  m.cLibrary = .NULL.
		  IF PEMSTATUS(_SCREEN, 'cmGlobalObjectManager', 5)
		    m.cClass = _SCREEN.cmGlobalObjectManager.GetClassName(m.cClass, @m.cLibrary)
		  ENDIF
		
		  m.cParams = ''
		  FOR ix = 1 TO PCOUNT() - 2
		    m.cParams = m.cParams + ', @m.uP' + STR(m.ix,1)
		  ENDFOR
		  RETURN THIS.NewObject(m.cName, m.cClass, m.cLibrary, '' &cParams)
		
	ENDPROC

	PROCEDURE backgroundrefresh		&& Background refresh event called during first VFP idle time after Init event.
		*++
		*>>Background refresh event called during first VFP idle time after Init event.
		* Use this event to translate tooltips and statusbar text in the background.
		* Also calls Standard refresh method to set initial enable state of contained buttons.
		*--
		LOCAL ix, oCtl
		  FOR ix = 1 TO THIS.ControlCount
		    m.oCtl = THIS.Controls[m.ix]
		    IF PEMSTATUS(m.oCtl, 'cHelpKey', 5)
		      IF PEMSTATUS(m.oCtl, 'nControlFlags', 5)
		        THIS.InitializeHelp(m.oCtl)
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  * Force initial refresh to mimic forms. Gives buttons a chance to enable/disable.
		  THIS.Refresh()
		
	ENDPROC

	PROCEDURE contextmenuactivate		&& Call context menu manager to activate the context menu, and return the identifier associated with the option chosen.
		*++
		*>>Call context menu manager to activate the context menu, and return the identifier associated with the option chosen.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuActivate()
		
	ENDPROC

	PROCEDURE contextmenubar		&& Call context menu manager to define a menu bar for the context menu.
		LPARAMETERS nBar, cPrompt, uArg, cStyle
		*++
		*>>Call context menu manager to define a menu bar for the context menu.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuBar(m.nBar, @m.cPrompt, m.uArg, m.cStyle)
		
	ENDPROC

	PROCEDURE contextmenubarcheck		&& Set the check-mark for the specified menu bar.
		LPARAMETERS nBar, lCheck
		*++
		*>>Set the check-mark for the specified menu bar.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuBarCheck(m.nBar, m.lCheck)
		
	ENDPROC

	PROCEDURE contextmenubardisable		&& Enable or disbale the specified context menu bar, per the specified expression.
		LPARAMETERS nBar, lDisable
		*++
		*>>Enable or disbale the specified context menu bar, per the specified expression.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuBarDisable(m.nBar, m.lDisable)
		
	ENDPROC

	PROCEDURE contextmenubuild
		*++
		* Define all the bars for a toolbar context menu. Return .F. if no bars are defined
		*--
		  IF THIS.cmContextMenu.GetBarCount() > 0
		    THISFORM.ContextMenuSeparator(CTX_BAR_TBR_SEP1)  && Seperator after any previously added bars
		  ENDIF
		
		  IF THIS.lDockMenu
		    THISFORM.ContextMenuBar(CTX_BAR_TBR_DOCKTOP, '%barDockTop')
		    THISFORM.ContextMenuBar(CTX_BAR_TBR_DOCKLEFT, '%barDockLeft')
		    THISFORM.ContextMenuBar(CTX_BAR_TBR_DOCKRIGHT, '%barDockRight')
		    THISFORM.ContextMenuBar(CTX_BAR_TBR_DOCKBOTTOM, '%barDockBottom')
		  ENDIF
		
		  IF NOT ISNULL(THIS.lEmbeddedToolBarMenu) AND NOT ISNULL(THIS.oStateManager)
		    IF THIS.lEmbeddedToolBarMenu
		      THIS.ToolbarMenuBuild()
		    ELSE
		      IF THIS.ControlBox
		        THISFORM.ContextMenuSeparator(CTX_BAR_TBR_SEP2)
		        THISFORM.ContextMenuBar(CTX_BAR_TBR_CLOSE, '%barCloseToolbar')
		      ENDIF
		      THISFORM.ContextMenuSeparator(CTX_BAR_TBR_SEP3)
		      THISFORM.ContextMenuBar(CTX_BAR_TBR_VIEW, '%barViewToolbars')
		    ENDIF
		  ENDIF
		  RETURN THIS.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenuexecute
		LPARAMETERS cOption
		*++
		* Execute the selected context menu item. Usually called from context menu 
		* activation, but may also be called directly under program control to simulate user action.
		* Returns true if the option was handled by this method.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption = '%barclosetoolbar'
		      THIS.Release()
		    CASE m.cOption = '%bardocktop'
		      THIS.Dock(0,0,0)
		    CASE m.cOption = '%bardockleft'
		      THIS.Dock(1,0,0)
		    CASE m.cOption = '%bardockright'
		      THIS.Dock(2,0,0)
		    CASE m.cOption = '%bardockbottom'
		      THIS.Dock(3,0,0)
		    CASE m.cOption = '%barviewtoolbars'
		      THIS.oStateManager.OpenForm('frmViewToolbarsCustom')
		    OTHERWISE
		      LOCAL ix, cName, oTool
		
		      * See if cOption is a toolbar caption name
		      IF THIS.lEmbeddedToolBarMenu
		        DO WHILE THIS.oStateManager.EnumToolbars(@m.ix, @m.cName, @m.oTool) > 0
		          IF m.cOption == PROPER(THIS.oMessage.TranslateString('%' + m.cName))
		            IF ISNULL(m.oTool)
		              THIS.oStateManager.OpenToolbar(m.cName)
		            ELSE
		              THIS.oStateManager.CloseToolbar(m.cName)
		            ENDIF
		            RETURN .T.
		          ENDIF
		        ENDDO
		      ENDIF
		      RETURN .F.
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE contextmenuinit		&& Call context menu manager to initialize context menu popup.
		LPARAMETERS oTarget
		*++
		*>>Call context menu manager to initialize context menu popup.
		*--
		  IF PEMSTATUS(THIS, 'cmContextMenu', 5)
		    RETURN THIS.cmContextMenu.ContextMenuInit(m.oTarget)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE contextmenuseparator		&& Add a Separator bar to the context menu, only if any other bars are added after.
		LPARAMETERS nBar
		*++
		*>>Add a Separator bar to the context menu, only if any other bars are added after.
		*--
		  RETURN THIS.cmContextMenu.ContextMenuSeparator(m.nBar)
		
	ENDPROC

	PROCEDURE DblClick
		  LOCAL oObj
		  m.oObj = SYS(1270)
		  IF m.oObj.Baseclass != 'Toolbar'
		    NODEFAULT
		  ENDIF
		
	ENDPROC

	PROCEDURE Destroy
		*++
		* Toolbar state cleanup
		*--
		  * Un-register the toolbar and all buttons from state manager, if not already done.
		  * State manager may have already been destroyed (via CLEAR ALL) so
		  * check before calling it to avoid messy errors.
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.UnSubscribe('*', THIS)
		  ENDIF
		
		  THIS.SaveSizeAndPosition()
		
		  THIS.Visible = .F.   && Speeds release if not visible.
		  STORE .NULL. TO THIS.oRegistry, THIS.oApp, THIS.oSecurity, THIS.oMessage, THIS.oStateManager
		
	ENDPROC

	PROCEDURE displayhelp		&& Display context help for the specified object.
		LPARAMETERS oContext
		*++
		*>>Display context help for the specified object.
		*--
		  THIS.InitializeHelp(m.oContext)    && Pick up help key associated with bound data, if any
		  IF NOT ISNULL(THIS.oMessage)
		    THISFORM.oMessage.DisplayHelp(m.oContext.cHelpKey, '%txtFieldHelpTitle', THISFORM.NiceName(m.oContext), THISFORM.Caption)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE displaymessage		&& Calls the form message object to display an error message.
		LPARAMETERS cMsg, uArg1, uArg2, uArg3
		*++
		*>>Calls the form message object to display an error message.
		* May be overridden in user subclass for custom message display.
		*--
		  IF NOT ISNULL(THIS.oMessage)
		    RETURN THIS.oMessage.Display(m.cMsg, THIS.Caption, @m.uArg1, @m.uArg2, @m.uArg3)
		  ENDIF
		
		  * No Message manager available - use standard VFP dialog.
		  =MESSAGEBOX(m.cMsg, 0, THIS.Caption)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Init
		*++
		*>>Toolbar Init
		*--
		  * Determine system registry key to use for this toolbar. If application object exists,
		  * it has an application-specific key name.
		  IF NOT ISNULL(THIS.oApp)
		    THIS.cSysRegRoot = THIS.oApp.cSysRegRoot
		  ENDIF
		  THIS.cSysRegFormRoot = THIS.cSysRegRoot + '\Toolbars\' + THIS.Name
		
		  * Add context menu manager, if desired
		  IF NOT EMPTY(THIS.cContextMenuClass)
		    IF NOT PEMSTATUS(THIS, 'cmContextMenu', 5)
		      THIS.AddNewObject('cmContextMenu', THIS.cContextMenuClass)
		    ENDIF
		  ENDIF
		
		  * If there is no caption, look for one in the app registry
		  IF EMPTY(THIS.Caption) AND NOT ISNULL(THIS.oMessage)
		    THIS.Caption = THIS.oMessage.TranslateString('%' + THIS.Name)
		  ENDIF
		
		  * Register this toolbar for refresh whenever the active window changes.
		  IF THIS.lRefreshOnWindowChange
		    THIS.oStateManager.Subscribe('Window Change', THIS)
		  ENDIF
		
		  THIS.oStateManager.RequestBackgroundRefresh(THIS)
		  THIS.RestoreSizeAndPosition()
		
	ENDPROC

	PROCEDURE initializehelp		&& Translate the specified control's help key and set tooltip and statusbar text.
		LPARAMETERS oCtl
		*++
		*>>Translate the specified control's help key and set tooltip and statusbar text.
		*
		* Even though this method can be a little slow, it is only called for one control
		* at a time, the first time it gets focus, so there is little performance impact.
		* Toolbars with tooltips enabled translate all controls in the background during
		* VFP idle time, so again there is little performance lost.
		*--
		LOCAL cShortText, cTipText
		
		  IF NOT BITTEST(m.oCtl.nControlFlags, CTLFLAG_HELP_INITIALIZED) AND NOT ISNULL(THIS.oMessage)
		    * Translate statusbar and tooltip text
		    IF NOT EMPTY(m.oCtl.cHelpKey)
		      THIS.oMessage.TranslateHelp(m.oCtl.cHelpKey, @m.cShortText, @m.cTipText)
		      IF EMPTY(m.oCtl.cDisplayName)
		        m.oCtl.cDisplayName = m.cTipText
		      ENDIF
		      IF THIS.ShowTips AND EMPTY(m.oCtl.ToolTipText)
		        m.oCtl.ToolTipText = m.cTipText
		      ENDIF
		      IF EMPTY(m.oCtl.StatusbarText) AND NOT EMPTY(m.cShortText)
		        m.oCtl.StatusbarText = m.cShortText
		      ENDIF
		    ENDIF
		
		    * Remember that help has been translated so we dont waste time doing it again.
		    m.oCtl.nControlFlags = BITSET(m.oCtl.nControlFlags, CTLFLAG_HELP_INITIALIZED)
		  ENDIF
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		  LOCAL oObj
		  * Trap and discard mouse events that occur over disabled buttons.
		  IF m.nButton = 1
		    m.oObj = SYS(1270)
		    IF TYPE('m.oObj.Baseclass') != 'C' OR m.oObj.Baseclass != 'Toolbar'
		      ??CHR(7)
		      NODEFAULT
		      RETURN .F.
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE nicename		&& Return a user-friendly name for the specified control in this toolbar.
		LPARAMETERS oCtl
		*++
		*>>Return a user-friendly name for the specified control in this toolbar.
		*
		* 1) If the control has caption or cDisplayName property (localized), use that as the name.
		* 2) If the control has toolTipText, use that as the name.
		* 3) Use control's name property.
		*--
		  IF PEMSTATUS(m.oCtl, 'cDisplayName', 5)
		    IF NOT EMPTY(m.oCtl.cDisplayName)
		      RETURN m.oCtl.cDisplayName
		    ENDIF
		  ENDIF
		
		  IF PEMSTATUS(m.oCtl, 'ToolTipText', 5)
		    IF NOT EMPTY(m.oCtl.ToolTipText)
		      RETURN m.oCtl.ToolTipText
		    ENDIF
		  ENDIF
		  RETURN PROPER(m.oCtl.Name)
		
	ENDPROC

	PROCEDURE oapp_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oApp) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oApp) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oApp = FindGlobalObject('appApplication')
		  ENDIF
		  RETURN THIS.oApp
		
	ENDPROC

	PROCEDURE omessage_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oMessage) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oMessage) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oMessage = FindGlobalObject('cmMessage')
		  ENDIF
		  RETURN THIS.oMessage
		
	ENDPROC

	PROCEDURE oregistry_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oRegistry) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oRegistry) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oRegistry = FindGlobalObject('cmRegistry')
		  ENDIF
		  RETURN THIS.oRegistry
		
	ENDPROC

	PROCEDURE osecurity_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oSecurity) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oSecurity) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oSecurity = FindGlobalObject('cmSecurity')
		  ENDIF
		  RETURN THIS.oSecurity
		
	ENDPROC

	PROCEDURE ostatemanager_access
		* To prevent an object from being referenced, set the corresponding property to .F.
		  IF NOT VARTYPE(THIS.oStateManager) $ 'XO'
		    RETURN .NULL.
		  ENDIF
		  IF ISNULL(THIS.oStateManager) AND 'CODEMINE.FXP' $ SET('PROCEDURE')
		    THIS.oStateManager = FindGlobalObject('cmStateManager')
		  ENDIF
		  RETURN THIS.oStateManager
		
	ENDPROC

	PROCEDURE registryupdate		&& Called when app registry changes, if this toolbar subscribes to Registry Update events.
		*++
		*>>Called when app registry changes, if this toolbar subscribes to Registry Update events.
		* Empty method by default. Individual toolbars may subclass this method if needed.
		*--
		
	ENDPROC

	PROCEDURE Release
		*++
		*>>Toolbar Release() method to mimic the behavior of forms.
		*--
		  * Release callback links to any contained buttons.
		  IF NOT ISNULL(THIS.oStateManager)
		    THIS.oStateManager.UnSubscribe('*', THIS)
		  ENDIF
		  RELEASE THIS
		
	ENDPROC

	PROCEDURE restoresizeandposition		&& Restore last saved toolbar size and position.
		*++
		*>>Restore last saved toolbar size and position.
		*--
		LOCAL cPos, nDocked
		
		  * Position infor saved as DockPosition,Top,Left,Width
		  IF THIS.lRememberPosition AND NOT ISNULL(THIS.oApp) ;
		  AND THIS.oApp.GetPreference(THIS.cSysRegFormRoot + '\Position', @m.cPos) AND LEN(m.cPos) == 16
		    m.nDocked = VAL(SUBSTR(m.cPos, 1, 4))
		    IF m.nDocked < 0
		      THIS.Move(MAX(VAL(SUBSTR(m.cPos, 9, 4)), 0), MAX(VAL(SUBSTR(m.cPos, 5, 4)), 0))
		      THIS.Width = VAL(SUBSTR(m.cPos, 13, 4))
		    ELSE
		      THIS.Dock(m.nDocked, VAL(SUBSTR(m.cPos, 9, 4)), VAL(SUBSTR(m.cPos, 5, 4)))
		    ENDIF
		  ELSE
		    THIS.Dock(THIS.nDefaultDock)    && Default to docked
		  ENDIF
		
	ENDPROC

	PROCEDURE RightClick
		*++
		*>>Put up context menu if supported for this form.
		*--
		LOCAL cOption
		  IF THIS.ContextMenuInit() AND THIS.ContextMenuBuild()
		    m.cOption = THIS.ContextMenuActivate()
		    IF NOT EMPTY(m.cOption)
		      THIS.ContextMenuExecute(m.cOption)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE savesizeandposition		&& Save current size and position of toolbar.
		*++
		*>>Save current size and position of toolbar.
		*--
		  IF THIS.Visible AND THIS.lRememberPosition AND NOT ISNULL(THIS.oApp)
		    * Position infor saved as Top,Left,Height,Width,Max
		    THIS.oApp.SetPreference(THIS.cSysRegFormRoot  + '\Position', ;
		      STR(THIS.DockPosition,4) + STR(THIS.Top,4) + STR(THIS.Left,4) + STR(THIS.Width,4) )
		  ENDIF
		
	ENDPROC

	PROCEDURE toolbarmenubuild
		*++
		* Add a check-menu item for each available toolbar.
		*--
		LOCAL ix, cName, oTool
		
		  THIS.ContextMenuSeparator(CTX_BAR_TBR_VIEW)
		
		  DO WHILE THIS.oStateManager.EnumToolbars(@m.ix, @m.cName, @m.oTool) > 0
		    THIS.ContextMenuBar(CTX_BAR_TBR_VIEW + m.ix, THIS.oMessage.TranslateString('%' + m.cName))
		    IF NOT ISNULL(m.oTool)
		      THIS.ContextMenuBarCheck(CTX_BAR_TBR_VIEW + m.ix, .T.)
		      IF NOT m.oTool.ControlBox
		        THIS.ContextMenuBarDisable(CTX_BAR_TBR_VIEW + m.ix, .T.)
		      ENDIF
		    ENDIF
		  ENDDO
		
	ENDPROC

ENDDEFINE
