*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="cmdata.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS cmbindingmanager AS cmdataabstract OF "cmdataa.vcx" 		&& CodeMine Control Data Binding class. Manages the flow of data into and out of interface controls.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_bind.bmp" ClassIcon="..\graphics\_bind.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: beforechange		&& Determine if it is OK to interactively change the control's value.
		*m: contextmenubuild		&& Define common data-bound control context menu bar items.
		*m: contextmenubuilddata		&& Define common data-bound control context menu bar items. Only called for forms with a Data Manager present.
		*m: contextmenubuildhelp		&& Define common data-bound control context menu bar items.
		*m: contextmenubuildmemory		&& Define common data-bound control context menu bar items.
		*m: contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		*m: defaultfrommemory		&& Insert default memory value for a control bound to a field in a New record.
		*m: erroreditmode		&& Called when an attempt is made to edit the value of a control when the form is write locked.
		*m: errorreadonly		&& Called when an attempt is made to edit the value of a read-only control.
		*m: initbinding		&& Common data-bound control binding initialization.
		*m: lautoscroll_access		&& Access method to ensure that Autoscroll can only be enabled in a form.
		*m: ldatamanagerpresent_access		&& Access method to determine whether or not the form has a data maanger.
		*m: loadmemory		&& Load a control value from a stored memory value.
		*m: loadvalue		&& Load and return the value of bound data source, specified in the cValuesource property.
		*m: loadworkarea		&& Derive the value of the control's cWorkarea property from the ControlSource or cValueSource property.
		*m: setvalue		&& Set the specified control's value programatically.
		*m: storememory		&& Save current value in system registry for later use.
		*m: storevalue		&& Write control value back to data source using table or memvar syntax as appropriate. Triggers ctl.AfterChange() on success.
		*m: valid		&& Call the FieldValid() event, and store value to bound datasource on success.
		*m: validneeded		&& Determine if a text editing control needs field level data validation.
		*m: when		&& Common When() event code for Codemine Controls that support data binding.
		*p: lappendformmenu		&& Set to .T. to append form level ctx menu item to the control's menu.
		*p: lappendgridmenu		&& Set to .T. to append grid ctx menu items to the control's menu, when in a grid.
		*p: lautoscroll		&& In a scrollable form, move the viewport if necessary to ensure that the control getting focus is visible.
		*p: ldatamanagerpresent		&& Will be .T. if the form has a cmDataManager class. NULL means to look for the DM at runtime.
		*p: lloadviadatamanager		&& Use cmDataManager to load control value from ControlSource
		*p: lnoinitdata		&& Set to .T. to delay all control data binding until the first Refresh() cycle, instead of during Init().
		*p: lnullforempty		&& If set to .T., Store .NULL. to bound data when value is EMPTY. This is especially usefull for SQL Server data sources.
		*p: lstoreviadatamanager		&& Use cmDataManager to store control value back to ControlSource
		*p: nvalidationmode		&& Determines when FieldValid() event is triggered. Settings: 0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	*</DefinedPropArrayMethod>

	BackColor = 0,128,128
	cclass = cmBindingManager
	Height = 15
	lappendformmenu = .T.		&& Set to .T. to append form level ctx menu item to the control's menu.
	lappendgridmenu = .T.		&& Set to .T. to append grid ctx menu items to the control's menu, when in a grid.
	lautoscroll = .T.		&& In a scrollable form, move the viewport if necessary to ensure that the control getting focus is visible.
	ldatamanagerpresent = .NULL.		&& Will be .T. if the form has a cmDataManager class. NULL means to look for the DM at runtime.
	lloadviadatamanager = .F.		&& Use cmDataManager to load control value from ControlSource
	lnoinitdata = .F.		&& Set to .T. to delay all control data binding until the first Refresh() cycle, instead of during Init().
	lnullforempty = .F.		&& If set to .T., Store .NULL. to bound data when value is EMPTY. This is especially usefull for SQL Server data sources.
	lstoreviadatamanager = .T.		&& Use cmDataManager to store control value back to ControlSource
	Name = "cmbindingmanager"
	nvalidationmode = 0		&& Determines when FieldValid() event is triggered. Settings: 0=Validate only if changed, 1=Changed or New, 2=Always on LostFocus.
	Width = 20
	
	PROCEDURE beforechange		&& Determine if it is OK to interactively change the control's value.
		LPARAMETERS oThis
		*++
		*>>Determine if it is OK to interactively change the control's value.
		* Sets the lChanged flag for the control on success.
		*--
		  IF NOT m.oThis.lChanged
		    * Dispatch to the appropriate error handler on attempt to edit a read-only control.
		    IF m.oThis.lWriteLock
		      IF PEMSTATUS(THISFORM, 'lExplicitEditMode', 5)
		        IF NOT m.oThis.lReadOnly AND THISFORM.lExplicitEditMode AND THISFORM.lWriteLock
		          THIS.ErrorEditMode(m.oThis)
		          RETURN .F.
		        ENDIF
		      ENDIF
		      THIS.ErrorReadonly(m.oThis)
		      RETURN .F.
		    ENDIF
		
		    * Call form.beforeChange to Lock pessimistic datasource, update form change 
		    * flags, and refresh toolbar save/revert buttons as appropriate.
		    IF NOT EMPTY(m.oThis.cValueSource) ;
		    AND (NOT EMPTY(m.oThis.cWorkarea) OR NOT THISFORM.lIgnoreBoundProperties)
		      IF PEMSTATUS(THISFORM, 'BeforeChange', 5)
		        IF EMPTY(m.oThis.cWorkarea)
		          m.oThis.lChanged = THISFORM.BeforeChange()
		        ELSE
		          m.oThis.lChanged = THISFORM.BeforeChange(m.oThis.cWorkarea)
		        ENDIF
		      ELSE
		        m.oThis.lChanged = .T.
		      ENDIF
		    ELSE
		      m.oThis.lChanged = .T.
		    ENDIF
		  ENDIF
		  RETURN m.oThis.lChanged
		
	ENDPROC

	PROCEDURE comments
		*++
		* CodeMine Control Data Binding class. Manages the flow of data into and out of interface controls.
		* This is designed without an Init() method, so we do not need to worry about Z-order within a form.
		*
		* Copyright 2000-2001 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		
	ENDPROC

	PROCEDURE contextmenubuild		&& Define common data-bound control context menu bar items.
		LPARAMETERS oThis
		*++
		*>>Define common data-bound control context menu bar items.
		*--
		LOCAL uValue
		  THIS.ContextMenuBuildHelp(m.oThis)
		
		  IF PEMSTATUS(m.oThis, 'lNativeBinding', 5)  && Add data related options for Codemine data ctls
		    * If value has been edited, enable undo option, except for listboxes.
		    IF m.oThis.lChanged AND NOT m.oThis.BaseClass == 'Listbox'
		      THISFORM.ContextMenuBar(CTX_BAR_CTL_UNDO, '%barUndo')
		    ENDIF
		
		    * Add menu option for setting contents to NULL, if NULL is allowed
		    IF PEMSTATUS(m.oThis, 'lAllowNull', 5)
		      IF m.oThis.lAllowNull AND NOT m.oThis.lWriteLock
		        THISFORM.ContextMenuBar(CTX_BAR_CTL_NULL, '%barNull')
		        THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP2)
		      ENDIF
		    ENDIF
		
		    IF THIS.lDataManagerPresent
		      THIS.ContextMenuBuildData(m.oThis)
		
		      * Add various control value memory menu options.
		      IF PEMSTATUS(m.oThis, 'lValueMemory', 5)
		        IF m.oThis.lValueMemory AND NOT m.oThis.lWriteLock AND NOT ISNULL(THISFORM.oApp)
		          THIS.ContextMenuBuildMemory(m.oThis)
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Add any items specific to the invoking control.
		  m.oThis.ContextMenuBuild()
		
		  * If we are in a grid, append the grid context menu bars.
		  IF THIS.lAppendGridMenu AND BITTEST(m.oThis.nControlFlags, CTLFLAG_INGRID)
		    m.oThis.Parent.Parent.ContextMenuBuild()
		  ENDIF
		
		  * Append form level menu items if desired.
		  IF THIS.lAppendFormMenu
		    THISFORM.ContextMenuBuild()
		  ENDIF
		  RETURN THISFORM.cmContextMenu.GetBarCount() > 0
		
	ENDPROC

	PROCEDURE contextmenubuilddata		&& Define common data-bound control context menu bar items. Only called for forms with a Data Manager present.
		LPARAMETERS oThis
		*++
		*>>Define common data-bound control context menu bar items. Only called for forms with a Data Manager present.
		*--
		LOCAL uValue
		  * Load value where it can easily be tested.
		  m.uValue = m.oThis.GetValue()
		
		  * A VFP5 bug prevents OptionGroup value from being changed to an option button other than the one
		  * that triggered the RightClick. So we can't support revert or insert memory for OptionGroups.
		  * This seems to be fixed in VFP 7.0, so we can allow it now.
		
		  * Add the Revert option. Newly appended records have no OLDVAL(), so they can't revert.
		  IF NOT m.oThis.lWriteLock AND NOT EMPTY(m.oThis.cValueSource) AND NOT EMPTY(m.oThis.cWorkarea)
		    WITH THISFORM.cmDataManager
		      IF NOT .IsNew(m.oThis.cWorkarea) ;
		      AND .GetBufferMode(m.oThis.cWorkarea) > 1 ;
		      AND .IsFieldChanged(m.oThis.cWorkarea, m.oThis.cValueSource)
		        THISFORM.ContextMenuBar(CTX_BAR_CTL_REVERT, '%barRevert')
		      ENDIF
		    ENDWITH
		  ENDIF
		  THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP3)
		
	ENDPROC

	PROCEDURE contextmenubuildhelp		&& Define common data-bound control context menu bar items.
		LPARAMETERS oThis
		*++
		*>>Define common data-bound control context menu bar items.
		*--
		  THISFORM.ContextMenuBar(CTX_BAR_CTL_HELP, '%barHelp')
		  THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP1)
		
	ENDPROC

	PROCEDURE contextmenubuildmemory		&& Define common data-bound control context menu bar items.
		LPARAMETERS oThis
		*++
		*>>Define common data-bound control context menu bar items.
		*--
		LOCAL uValue
		  * Load value where it can easily be tested.
		  m.uValue = m.oThis.GetValue()
		
		  THISFORM.ContextMenuBar(CTX_BAR_CTL_SETMEM, '%barSetMemory')
		  THISFORM.ContextMenuBar(CTX_BAR_CTL_INSMEM, '%barInsertMemory')
		  THISFORM.ContextMenuBar(CTX_BAR_CTL_CLRMEM, '%barClearMemory')
		  IF ISNULL(m.uValue) OR EMPTY(m.uValue)  && Dont allow storing of NULL values in memory.
		    THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_SETMEM, .T.)
		  ENDIF
		  IF NOT THISFORM.oApp.GetPreference(m.oThis.cMemoryKeyRoot + SYS(1272, m.oThis))
		    THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_INSMEM, .T.)
		    THISFORM.ContextMenuBarDisable(CTX_BAR_CTL_CLRMEM, .T.)
		  ENDIF
		  THISFORM.ContextMenuSeparator(CTX_BAR_CTL_SEP4)
		  THISFORM.ContextMenuBar(CTX_BAR_CTL_AUTOMEM, '%barAutoRemember')
		  THISFORM.ContextMenuBarCheck(CTX_BAR_CTL_AUTOMEM, m.oThis.lAutoRemember)
		
	ENDPROC

	PROCEDURE contextmenuexecute		&& Execute the selected context menu item. Usually called directly from context menu activation.
		LPARAMETERS oThis, cOption
		*++
		*>>Execute the selected context menu item. Usually called directly from context menu activation.
		* May also be called directly under program control to simulate user action.
		*--
		  m.cOption = PROPER(m.cOption)
		  DO CASE
		    CASE m.cOption == '%barhelp'
		      m.oThis.ShowWhatsThis(m.oThis.WhatsThisHelpID)
		
		    CASE m.cOption == '%barundo'
		      m.oThis.UndoChanges()
		
		    CASE m.cOption == '%barnull'
		      m.oThis.SetValue(.NULL.)
		
		    CASE m.cOption == '%barrevert'
		      LOCAL uValue
		      m.uValue = THISFORM.cmDataManager.OldValue(m.oThis.cWorkarea, m.oThis.cValueSource)
		      m.oThis.SetValue(m.oThis.LoadTranslation(m.uValue))
		
		    CASE m.cOption == '%barinsertmemory'
		      m.oThis.LoadMemory()
		
		    CASE m.cOption == '%barclearmemory'
		      THISFORM.oApp.ClearPreference(m.oThis.cMemoryKeyRoot + SYS(1272, m.oThis))
		
		    CASE m.cOption == '%barsetmemory'
		      m.oThis.StoreMemory()
		
		    CASE m.cOption == '%barautoremember'
		      m.oThis.lAutoRemember = NOT m.oThis.lAutoRemember
		      THISFORM.oApp.SetPreference(m.oThis.cMemoryKeyRoot + 'AutoRemember\' + SYS(1272, m.oThis), IIF(m.oThis.lAutoRemember, 1, 0))
		
		    OTHERWISE
		      * Defer to grid or form menu execution as appropriate.
		      IF THIS.lAppendGridMenu AND BITTEST(m.oThis.nControlFlags, CTLFLAG_INGRID)
		        IF m.oThis.Parent.Parent.ContextMenuExecute(m.cOption)
		          RETURN .T.
		        ENDIF
		      ENDIF
		      RETURN THIS.lAppendFormMenu AND THISFORM.ContextMenuExecute(m.cOption)
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

	PROCEDURE defaultfrommemory		&& Insert default memory value for a control bound to a field in a New record.
		LPARAMETERS oThis
		*++
		*>>Insert default memory value for a control bound to a field in a New record.
		*--
		  * Load memory value if this is an empty field in a new record, and field has not yet been edited.
		  IF NOT EMPTY(m.oThis.cWorkarea) AND THIS.lDataManagerPresent 
		    IF THISFORM.cmDataManager.IsNew(m.oThis.cWorkarea) ;
		    AND EMPTY(NVL(THISFORM.cmDataManager.FieldValue(m.oThis.cWorkarea, m.oThis.cValueSource), ''))
		      RETURN m.oThis.LoadMemory()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE erroreditmode		&& Called when an attempt is made to edit the value of a control when the form is write locked.
		LPARAMETERS oThis
		*++
		*>>Called when an attempt is made to edit the value of a control when the form is write locked.
		*--
		  IF NOT ISNULL(THISFORM.oMessage)
		    THISFORM.oMessage.FlashMessage('%msgEditMode')
		  ENDIF
		
	ENDPROC

	PROCEDURE errorreadonly		&& Called when an attempt is made to edit the value of a read-only control.
		LPARAMETERS oThis
		*++
		*>>Called when an attempt is made to edit the value of a read-only control.
		*--
		  IF NOT ISNULL(THISFORM.oMessage)
		    THISFORM.oMessage.FlashMessage('%msgReadOnlyField')
		  ENDIF
		
	ENDPROC

	PROCEDURE GotFocus
		LPARAMETERS oThis
		*++
		*>>Common GotFocus() event code for Codemine Controls that support data binding.
		*--
		  * This will suppress the default VFP workarea messages on the status bar.
		  IF EMPTY(_VFP.StatusBar)
		    SET MESSAGE TO (m.oThis.StatusBarText)
		  ENDIF
		
		  WITH m.oThis
		    * If changes are discarded by form.Cancel() while a grid cell has focus, the current cell
		    * will not be refreshed, since focus is moved off grid by FlushControlBuffer().
		    IF .Parent.Baseclass == 'Column'
		      IF BITTEST(THISFORM.nControlFlags, FRMFLAG_REFRESH_CELL)
		        .lChanged = .F.
		      ENDIF
		    ENDIF
		    THISFORM.nControlFlags = BITCLEAR(THISFORM.nControlFlags, FRMFLAG_REFRESH_CELL)
		
		    IF NOT .lChanged
		      * If select-on-entry is set, set flag to tell MouseUp event to select all.
		      IF PEMSTATUS(m.oThis, 'SelectOnEntry', 5)
		        IF .SelectOnEntry OR 'K' $ UPPER(.Format) ;
		        OR (.Parent.BaseClass == 'Column' AND .Parent.SelectOnEntry)
		          .nControlFlags = BITSET(.nControlFlags, CTLFLAG_SELECT_ALL)
		        ENDIF
		      ENDIF
		
		      * Controls in a grid dont get Refresh() events unless they are the active cell,
		      * so we refresh here, resetting ShowControl() settings when we become the "active cell"
		      IF BITTEST(.nControlFlags, CTLFLAG_INGRID)
		        .Refresh()
		      ELSE
		        .LoadValue()             && Make sure most current data is loaded
		      ENDIF
		
		      * Editboxes screw up if they get focus with a null value, so we manually display
		      * the NullDisplay value. But, we cant do that when we have focus, so we blank it out here.
		      IF .BaseClass = 'Editbox' AND BITTEST(.nControlFlags, CTLFLAG_NULL)
		        .Value = ''
		      ENDIF
		
		      * If an unbound control, store "undo" value here.
		      IF EMPTY(.cValueSource)
		        .uOriginalValue = .GetValue()
		      ENDIF
		    ENDIF
		  ENDWITH
		
	ENDPROC

	PROCEDURE initbinding		&& Common data-bound control binding initialization.
		LPARAMETERS oThis
		*++
		*>>Common data-bound control binding initialization.
		*--
		  IF NOT PEMSTATUS(m.oThis, 'nControlFlags', 5)  && Only perform initialization once.
		    LOCAL lLoadFromMemory
		    WITH m.oThis
		      .cReadOnlyDisplay = UPPER(.cReadOnlyDisplay)
		      .AddProperty('uOriginalValue', .NULL.)       && Value restored on Escape or undo command.
		      .AddProperty('nBackColor', .NULL.)           && Holds original background color for This.ShowControl()
		      .AddProperty('nControlFlags', 0)             && Internal flags used to set and determine the state of this control.
		
		      * Handle special settings when control is placed in a grid.
		      IF .Parent.BaseClass == 'Column' ;
		      OR (.Parent.BaseClass == 'Container' AND .Parent.Parent.BaseClass == 'Column')
		        * Make it easy for other code to test for in-a-grid status.
		        .nControlFlags = BITSET(.nControlFlags, CTLFLAG_INGRID)
		
		        * Don't dim individual cells in a grid, just inherit column color
		        .cReadOnlyDisplay = STRTRAN(.cReadOnlyDisplay, 'DIM', '')
		
		        WITH IIF(.Parent.BaseClass == 'Column', .Parent, .Parent.Parent)
		          * Column or grid readonly applies to contained controls.
		          IF .ReadOnly OR .ReadOnly
		            m.oThis.lReadOnly = .T.
		          ENDIF
		
		          * If not Sparse, must use native binding.
		          m.oThis.lNativeBinding = m.oThis.lNativeBinding OR NOT .Sparse
		          IF .Bound
		            IF NOT m.oThis.lNativeBinding
		              * Set flag so Codemine cValueSource will be re-synced with bound column on each refresh.
		              m.oThis.nControlFlags = BITSET(m.oThis.nControlFlags, CTLFLAG_BOUND_COLUMN)
		              .Bound = .F.
		            ENDIF
		          ENDIF
		        ENDWITH
		      ENDIF
		
		      * Disable native read-only flag, and set our own custom flag instead.
		      IF PEMSTATUS(m.oThis, 'ReadOnly', 5)
		        IF .ReadOnly
		          .lReadOnly = .T.
		          .ReadOnly = .F.
		        ENDIF
		      ENDIF
		
		      * If either enabled flag is false, disable the field.
		      .lEnabled = .Enabled AND .lEnabled
		
		      * Initialize value memory key name, if value-memory is available and enabled.
		      IF PEMSTATUS(m.oThis, 'lValueMemory', 5)
		        IF .lValueMemory AND NOT ISNULL(THISFORM.oApp)
		          LOCAL nValue
		          IF EMPTY(.cMemoryKeyRoot)
		            .cMemoryKeyRoot = THISFORM.cSysRegFormRoot + '\ControlMemory\'
		          ENDIF
		          IF THISFORM.oApp.GetPreference(m.oThis.cMemoryKeyRoot + 'AutoRemember\' + SYS(1272, m.oThis), @m.nValue)
		            .lAutoRemember = NOT EMPTY(m.nValue)
		          ENDIF
		
		          * Set flag if control is not bound to a cursor field, to attempt memory restore. We 
		          * do the actual restore after loading any bound value (if bound to a property/memvar)
		          * so if there is a memory value, it will override the original bound value.
		          m.lLoadFromMemory = .T.
		        ENDIF
		      ENDIF
		
		      * Use our manually implemented control value datasource.
		      IF NOT EMPTY(.ControlSource)
		        .cValueSource = .ControlSource
		        IF NOT .lNativeBinding
		          * If unknown workarea, the controls own Error() method will trap the error
		          .ControlSource = ''
		        ENDIF
		      ENDIF
		      THIS.LoadWorkarea(m.oThis)
		
		      * Load initial bound data into the control.
		      * If in a grid column, Data load is done only by gotFocus() when a real instance of the control exists.
		      IF NOT BITTEST(.nControlFlags, CTLFLAG_INGRID)
		        .ShowControl()
		
		        * If we load value here, optimize out the LoadValue() & ShowControl() call from first refresh cycle.
		        DO CASE
		          CASE EMPTY(.cValueSource)
		            .nControlFlags = BITSET(.nControlFlags, CTLFLAG_VALUE_LOADED)
		          CASE (.lNoInitData OR THIS.lNoInitData)
		            * Don't reference bound data until first refresh. Need to re-run LoadWorkarea()
		            * when data is loaded, since the results may depend on the alias existing and open.
		            .nControlFlags = BITSET(.nControlFlags, CTLFLAG_RELOAD_WORKAREA)
		          OTHERWISE
		            .LoadValue()
		            .nControlFlags = BITSET(.nControlFlags, CTLFLAG_VALUE_LOADED)
		        ENDCASE
		
		        * Clear optimization flag if there is a linked label, since the first call 
		        * to ShowControl() may be done before the linked label's Init() was completed.
		        IF PEMSTATUS(m.oThis, 'cLinkedLabel', 5)
		          IF NOT EMPTY(.cLinkedLabel)
		            .nControlFlags = BITCLEAR(.nControlFlags, CTLFLAG_VALUE_LOADED)
		          ENDIF
		        ENDIF
		
		        * If not bound to cursor data and memory is enabled, try to restore saved value from memory.
		        IF m.lLoadFromMemory AND EMPTY(.cWorkarea)
		          .LoadMemory()
		        ENDIF
		      ENDIF
		    ENDWITH
		  ENDIF
		
	ENDPROC

	PROCEDURE lautoscroll_access		&& Access method to ensure that Autoscroll can only be enabled in a form.
		*++
		*>>Access method to ensure that Autoscroll can only be enabled in a form.
		*--
		  RETURN THIS.lAutoScroll AND THIS.Parent.Baseclass == 'Form'
		
	ENDPROC

	PROCEDURE ldatamanagerpresent_access		&& Access method to determine whether or not the form has a data maanger.
		*++
		*>>Access method to determine whether or not the form has a data maanger.
		*--
		  IF ISNULL(THIS.lDataManagerPresent)
		    THIS.lDataManagerPresent = PEMSTATUS(THISFORM, 'cmDataManager', 5)
		  ENDIF
		  RETURN THIS.lDataManagerPresent
		
	ENDPROC

	PROCEDURE loadmemory		&& Load a control value from a stored memory value.
		LPARAMETERS oThis, cType
		*++
		*>>Load a control value from a stored memory value.
		* Return .T. if there was a value stored in memory.
		*
		* Optional cType parameter allows caller to specifiy the datatype to convert to.
		*--
		  IF m.oThis.lValueMemory AND NOT ISNULL(THISFORM.oApp)
		    LOCAL uValue, cValue
		    IF THISFORM.oApp.GetPreference(m.oThis.cMemoryKeyRoot + SYS(1272, m.oThis), @m.uValue)
		      * Get default type from current value if no type specified.
		      m.cType = IIF(EMPTY(m.cType), VARTYPE(m.oThis.GetValue(), .T.), UPPER(m.cType))
		      IF m.cType != 'C'
		        IF ISNULL(THISFORM.oString)   && Make sure we have a reference to global string tools object
		          RETURN .F.
		        ENDIF
		        m.uValue = THISFORM.oString.CharToValue(m.uValue, m.cType)
		      ENDIF
		      RETURN m.oThis.SetValue(m.uValue)
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE loadvalue		&& Load and return the value of bound data source, specified in the cValuesource property.
		LPARAMETERS oThis, uValue
		LOCAL llReturn
		llReturn = .T.
		*++
		*>>Load and return the value of bound data source, specified in the cValuesource property.
		*
		* The uValue parameter must be passed by reference, to recieve loaded value.
		*--
		WITH m.oThis
		   .lChanged = .F.
		
		   * Re-parse workarea out of cValueSource if this is the first load after a delayed bind.
		   IF BITTEST(.nControlFlags, CTLFLAG_RELOAD_WORKAREA)
		      THIS.LoadWorkarea(m.oThis)
		      .nControlFlags = BITCLEAR(.nControlFlags, CTLFLAG_RELOAD_WORKAREA)
		   ENDIF
		
		   IF NOT EMPTY(.cValueSource) AND NOT .lNativeBinding
		      IF NOT .lReadLock
		         IF NOT EMPTY(.cWorkarea) AND (THIS.lLoadViaDataManager AND THIS.lDataManagerPresent)
		            IF swselect(.cWorkarea)
		               m.uValue = .LoadTranslation(THISFORM.cmDataManager.FieldValue(.cWorkarea, .cValueSource))
		            ELSE
		               LOCAL cType
		               m.cType = TYPE(.cValueSource)
		               DO CASE
		                  CASE m.cType $ 'CM'
		                     m.uValue = ''
		                  CASE m.cType $ 'NIY'
		                     m.uValue = 0
		                  CASE m.cType $ 'DT'
		                     m.uValue = {}
		                  OTHERWISE
		                     m.uValue = .NULL.
		               ENDCASE
		            ENDIF
		         ELSE
		            IF EMPTY(.cWorkarea) AND UPPER(LEFT(.cValueSource, 5)) == 'THIS.'
		               m.uValue = .LoadTranslation(EVALUATE('m.oThis.' + SUBSTR(.cValueSource, 6)))
		            ELSE
		               m.uValue = .LoadTranslation(EVALUATE(.cValueSource))
		            ENDIF
		         ENDIF
		      ELSE
		         * Value is "read-locked", so the user is not allowed to see it. Return appropriate empty value.
		         LOCAL cType
		         m.cType = TYPE(.cValueSource)
		         DO CASE
		            CASE m.cType $ 'CM'
		               m.uValue = ''
		            CASE m.cType $ 'NIY'
		               m.uValue = 0
		            CASE m.cType $ 'DT'
		               m.uValue = {}
		            OTHERWISE
		               m.uValue = .NULL.
		         ENDCASE
		      ENDIF
		      llReturn = .t.
		   ELSE 
		      llReturn = .F.
		   ENDIF
		   
		ENDWITH
		
		RETURN llReturn
		
		
	ENDPROC

	PROCEDURE loadworkarea		&& Derive the value of the control's cWorkarea property from the ControlSource or cValueSource property.
		LPARAMETERS oThis
		*++
		*>>Derive the value of the control's cWorkarea property from the ControlSource or cValueSource property.
		* Note that cmDatamanager depends on the workarea being stored in PROPER() case.
		*--
		  IF NOT EMPTY(m.oThis.cValueSource)
		    DO CASE
		      CASE BITTEST(m.oThis.nControlFlags, CTLFLAG_INGRID) AND UPPER(LEFT(m.oThis.cValueSource, 5)) = 'THIS.'
		        * For a control in a grid, the "THIS." prefix in controlSource must refer to the grid, not the control.
		        LOCAL cTarget
		        m.oThis.cWorkarea = ''
		        m.cTarget = SYS(1272, m.oThis.Parent.Parent)
		        m.cTarget = SUBSTR(m.cTarget, AT('.', m.cTarget) + 1)
		        m.oThis.cValueSource = 'THISFORM.' + m.cTarget + SUBSTR(m.oThis.cValueSource, 5)
		
		      CASE OCCURS('.', m.oThis.cValueSource) = 1
		        LOCAL cWorkarea
		
		        * Extract workarea alias from full field name spec.
		        m.cWorkarea = LEFT(m.oThis.cValueSource, AT('.', m.oThis.cValueSource) - 1)
		        IF USED(m.cWorkarea)
		          m.oThis.cWorkarea = PROPER(m.cWorkarea)
		        ELSE
		          IF THIS.lDataManagerPresent AND THISFORM.cmDataManager.IsOpen(m.cWorkarea)
		            m.oThis.cWorkarea = PROPER(m.cWorkarea)
		            * If DM says it is a cursor, but VFP doesn't think it is, we must use DM for all data access
		            STORE .T. TO THIS.lLoadViaDataManager, lStoreViaDataManager
		          ENDIF
		        ENDIF
		
		      CASE TYPE(ALIAS() + '.' + m.oThis.cValueSource) != 'U'
		        m.oThis.cWorkarea = PROPER(ALIAS())
		        m.oThis.cValueSource = m.oThis.cWorkarea + '.' + m.oThis.cValueSource
		
		      OTHERWISE
		        m.oThis.cWorkarea = PROPER(ALLTRIM(m.oThis.cWorkarea))
		        * If an unknown alias is explicitly specified, force data reads through DM (could be an ADO cursor).
		        IF NOT EMPTY(m.oThis.cWorkarea) AND NOT USED(m.oThis.cWorkarea)
		          STORE .T. TO THIS.lLoadViaDataManager, lStoreViaDataManager
		        ENDIF
		    ENDCASE
		  ENDIF
		
	ENDPROC

	PROCEDURE setvalue		&& Set the specified control's value programatically.
		LPARAMETERS oThis, uNewValue
		*++
		*>>Set the specified control's value programatically. 
		*
		* Returns .T. if the value was set, or .F. if a rule event prevented the value from being set.
		*--
		  LOCAL uOldValue, lStatus
		
		  * Call form's change handler first for data-bound controls. We are not subject to 
		  * the same interface constraints imposed by the BindMan.BeforeChange() method used
		  * when the control value is modified interactively.
		  IF NOT m.oThis.lChanged AND NOT EMPTY(m.oThis.cValueSource)
		    IF PEMSTATUS(THISFORM, 'BeforeChange', 5)
		      IF NOT IIF(EMPTY(m.oThis.cWorkarea), THISFORM.BeforeChange(), THISFORM.BeforeChange(m.oThis.cWorkarea))
		        RETURN .F.
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Save original value in case we need to back out on validation error, and set new value.
		  m.uOldValue = m.oThis.GetValue()
		  IF PEMSTATUS(m.oThis, '_SetValue', 5)
		    m.oThis._SetValue(m.uNewValue)      && Use custom Set() method if available.
		  ELSE
		    m.oThis.Value = m.uNewValue
		  ENDIF
		
		  * Set flag so that a Valid() event triggered by a FieldValid() 
		  * message display dialog will not cause recursive validation.
		  m.oThis.nControlFlags = BITSET(m.oThis.nControlFlags, CTLFLAG_SKIP_VALID)
		
		  * Update the value source too, and watch out for DBC rule failure.
		  m.lStatus = NOT EMPTY(m.oThis.FieldValid()) AND m.oThis.StoreValue()
		  m.oThis.nControlFlags = BITCLEAR(m.oThis.nControlFlags, CTLFLAG_SKIP_VALID)
		  IF NOT m.lStatus
		    IF PEMSTATUS(m.oThis, '_SetValue', 5)
		      m.oThis._SetValue(m.uOldValue)      && Use custom Set() method if available.
		    ELSE
		      m.oThis.Value = m.uOldValue
		    ENDIF
		    RETURN .F.
		  ENDIF
		
		  * Field validation passed, update memory if necessary. But don't store nulls.
		  IF m.oThis.lAutoRemember AND NOT ISNULL(m.oThis.GetValue())
		    m.oThis.StoreMemory()
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE storememory		&& Save current value in system registry for later use.
		LPARAMETERS oThis, uValue
		*++
		*>>Save current value in system registry for later use.
		*--
		  LOCAL cValue
		  IF m.oThis.lValueMemory AND NOT ISNULL(THISFORM.oApp) AND NOT ISNULL(m.uValue)
		    * If value is non-string, we need to convert to character before saving.
		    IF VARTYPE(m.uValue) != 'C'
		      IF ISNULL(THISFORM.oString)   && Make sure we have a reference to global string tools object
		        RETURN .F.
		      ENDIF
		      m.cValue = THISFORM.oString.ValueToChar(m.uValue)
		    ELSE
		      m.cValue = m.uValue
		    ENDIF
		    RETURN THISFORM.oApp.SetPreference(m.oThis.cMemoryKeyRoot + SYS(1272, m.oThis), m.cValue)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE storevalue		&& Write control value back to data source using table or memvar syntax as appropriate. Triggers ctl.AfterChange() on success.
		LPARAMETERS oThis, uValue, cDestination
		*++
		*>>Write control value back to data source using table or memvar syntax as appropriate. Triggers ctl.AfterChange() on success.
		*--
		  * Obey the lNullForEmpty setting for writing empty values.
		  IF EMPTY(m.uValue)
		    IF PEMSTATUS(m.oThis, 'lNullForEmpty', 5)
		      IF NVL(m.oThis.lNullForEmpty, THIS.lNullForEmpty)
		        m.uValue = .NULL.
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Even if Native Data Binding is being used, we still go through the motions of updating
		  * the bound field, in order to apply StoreTranslation(), and trigger associated rule events.
		  WITH m.oThis
		    IF PCOUNT() > 2
		      IF EMPTY(m.cDestination)
		        RETURN .T.   && An explicit empty destination is a no-op
		      ENDIF
		    ELSE
		      * Default destination is contained in the cValueSource property
		      m.cDestination = .cValueSource
		    ENDIF
		
		    THIS.AddProperty('nLastError', 0)
		    IF NOT EMPTY(m.cDestination)
		      * Note that this may trigger a field's DBC validation rule.
		      IF NOT EMPTY(.cWorkarea)
		        IF THIS.lStoreViaDataManager AND THIS.lDataManagerPresent
		          IF NOT THISFORM.cmDataManager.Replace(.cWorkarea, m.cDestination, .StoreTranslation(m.uValue), .T.)
		            THIS.nLastError  = 1582   && Validation error
		          ENDIF
		        ELSE
		          REPLACE (m.cDestination) WITH (.StoreTranslation(m.uValue)) IN (.cWorkarea)
		          IF NOT EMPTY(THIS.nLastError)
		            REPLACE (m.cDestination) WITH (OLDVAL(m.cDestination, .cWorkarea)) IN (.cWorkarea)
		          ENDIF
		        ENDIF
		      ELSE
		        IF UPPER(LEFT(.cValueSource, 5)) == 'THIS.'
		          m.cDestination = 'm.oThis.' + SUBSTR(m.cDestination,6)
		        ENDIF
		        STORE .StoreTranslation(m.uValue) TO (m.cDestination)
		      ENDIF
		    ENDIF
		
		    * Clear change flag if no error. Leave unchanged on error return.
		    IF EMPTY(THIS.nLastError)
		      .lChanged = .F.
		
		      * Call AfterChange() manually if data manager was not used. DM will call AfterChange()
		      * for all bound controls when the value is changed.
		      IF NOT (THIS.lStoreViaDataManager AND THIS.lDataManagerPresent) ;
		      OR EMPTY(.cWorkarea) OR EMPTY(m.cDestination)
		        .AfterChange()
		      ENDIF
		    ENDIF
		    RETURN EMPTY(THIS.nLastError)
		  ENDWITH
		
	ENDPROC

	PROCEDURE valid		&& Call the FieldValid() event, and store value to bound datasource on success.
		LPARAMETERS oThis, lForceWrite
		*++
		*>>Call the FieldValid() event, and store value to bound datasource on success.
		*--
		LOCAL uValid
		  m.uValid = m.oThis.FieldValid()
		  IF NOT EMPTY(m.uValid)
		    WITH m.oThis
		      * For discrete-value controls, the control level BeforeChange() event is not triggered
		      * until now, after ctl level validation is complete.
		      IF .BaseClass $ 'Checkbox,Optiongroup,Listbox' OR (.BaseClass = 'Combobox' AND .Style = 2)
		        * Most discrete value ctls dont set lChanged, but combo Style 2 does, so we need to 
		        * clear it before calling BeforeChange().
		        .lChanged = .F.
		        IF NOT .BeforeChange()
		          .UndoChanges()
		          RETURN 0
		        ENDIF
		      ENDIF
		 
		      * Write validated control data back to bound source.
		      IF m.lForceWrite OR .lChanged OR THISFORM.IsNew(.cWorkarea)
		        * Writing data may trigger rules that can fail, which counts as a validation failure.
		        IF NOT .StoreValue()
		          RETURN 0
		        ENDIF
		
		        * Field validation passed, update memory.
		        IF .lAutoRemember
		          .StoreMemory()
		        ENDIF
		      ENDIF
		    ENDWITH
		    RETURN m.uValid
		  ENDIF
		
		  * On validation error, display default error message on boolean return status
		  IF VARTYPE(m.uValid) = 'L'
		    THISFORM.DisplayMessage('%msgFieldValidFailed')
		  ENDIF
		  RETURN 0   && Always return numeric failure code to supress VFP message.
		
	ENDPROC

	PROCEDURE validneeded		&& Determine if a text editing control needs field level data validation.
		LPARAMETERS oThis
		*++
		*>>Determine if a text editing control needs field level data validation.
		*--
		LOCAL nMode
		
		  * nValidationMode settings: 0=Validate if changed, 1=Changed or New, 2=Always.
		  * Use control setting if present, and not NULL, otherwise use internal default.
		  IF PEMSTATUS(m.oThis, 'nValidationMode', 5)
		    m.nMode = IIF(ISNULL(m.oThis.nValidationMode), THIS.nValidationMode, m.oThis.nValidationMode)
		  ELSE
		    m.nMode = THIS.nValidationMode
		  ENDIF
		
		  WITH m.oThis
		    IF (.lChanged OR m.nMode = 2 OR (m.nMode = 1 AND THISFORM.IsNew(.cWorkarea)) ) ;
		    AND NOT BITTEST(.nControlFlags, CTLFLAG_SKIP_VALID)
		      * Determine if field validation needs to be enforced.
		      IF PEMSTATUS(THISFORM, 'SkipValid', 5)
		        IF THISFORM.SkipValid()
		          RETURN .F.
		        ENDIF
		      ENDIF
		      RETURN .T.
		    ENDIF
		  ENDWITH
		  RETURN .F.
		
	ENDPROC

	PROCEDURE when		&& Common When() event code for Codemine Controls that support data binding.
		LPARAMETERS oThis
		*++
		*>>Common When() event code for Codemine Controls that support data binding.
		* If form is scrollable
		*   Scroll form for off-screen controls
		* Else
		*   Return .F. for off-screen controls
		*--
		  * If nControlFlags is not defined for the control, either it isn't a CodeMine control, or
		  * there was an error in its init() event code. So we just return without doing anything,
		  * which helps avoid triggering any further (or recursive) errors.
		  IF NOT PEMSTATUS(m.oThis, 'nControlFlags', 5)
		    RETURN .T.
		  ENDIF
		
		  IF PEMSTATUS(THISFORM, 'InitializeHelp', 5)
		    THISFORM.InitializeHelp(m.oThis)
		  ENDIF
		
		  WITH m.oThis
		    * If in a grid, re-evaluate lWriteLock and other refresh-cycle properties
		    * before deciding whether or not to allow focus.
		    IF .Parent.BaseClass == 'Column'
		      IF BITTEST(.nControlFlags, CTLFLAG_BOUND_COLUMN) AND NOT .cValueSource == .Parent.ControlSource
		        .Set('cValueSource', .Parent.ControlSource)
		      ELSE
		        .ShowControl()
		      ENDIF
		    ENDIF
		
		    * Enforce the NoFocus option for readonly fields. Fields with datasource at EOF never get focus.
		    IF .lWriteLock
		      IF 'NOFOCUS' $ .cReadOnlyDisplay ;
		      OR (NOT EMPTY(.cWorkarea) AND THISFORM.IsEmpty(.cWorkarea))
		        IF .Parent.BaseClass == 'Column'
		          .LoadValue()
		        ENDIF
		        RETURN .F.
		      ENDIF
		    ENDIF
		  ENDWITH
		
		  * Watch for VFP bug where OBJTOCLIENT() doesn't work in a grid.
		  IF THISFORM.ScaleMode = 3 AND NOT m.oThis.Parent.BaseClass == 'Column'
		    LOCAL nTop, nLeft, nWidth
		    m.nTop = OBJTOCLIENT(m.oThis, 1)
		    m.nLeft = OBJTOCLIENT(m.oThis, 2)
		
		    * If form is scrollable (VFP6.0 and later), make sure control is visible in the viewport.
		    IF THIS.lAutoscroll AND THISFORM.ScrollBars != 0
		      IF m.nTop < THISFORM.ViewportTop
		        THISFORM.SetViewport(THISFORM.ViewportLeft, m.nTop)   && Off Top
		      ENDIF
		      IF m.nTop + m.oThis.Height >= THISFORM.ViewportTop + THISFORM.Height
		        THISFORM.SetViewport(THISFORM.ViewportLeft, (m.nTop + m.oThis.Height) - THISFORM.Height)  && Off Bottom
		      ENDIF
		      m.nWidth = MIN(m.oThis.Width, THISFORM.Width - 2)
		      IF m.nLeft < THISFORM.ViewportLeft
		        THISFORM.SetViewport(m.nLeft, THISFORM.ViewportTop)  && Off LEft
		      ENDIF
		      IF m.nLeft + m.nWidth >= THISFORM.ViewportLeft + THISFORM.Width
		        THISFORM.SetViewport((m.nLeft + m.nWidth) - THISFORM.Width, THISFORM.ViewportTop)  && Off Right
		      ENDIF
		      RETURN .T.
		    ENDIF
		
		    * Don't allow focus to controls that are off the form.
		    RETURN m.nTop < THISFORM.Height AND m.nLeft < THISFORM.Width
		  ENDIF
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmconnectionmanager AS cmdataabstract OF "cmdataa.vcx" 		&& Codemine Remote Data Connection and Transaction management class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_connmanager.bmp" ClassIcon="..\graphics\_connmanager.bmp" />

	#INCLUDE "datadefs.h"
	*<DefinedPropArrayMethod>
		*m: addconnection		&& Add an existing VFP connection handle to the pool of managed connections. Typically used to add connections opened by VFP remote views.
		*m: begintrans		&& Start a transaction. If nConnection parameter is specified, add it to list of connections with outstanding remote transactions at the current level.
		*m: committrans		&& End the current transaction level by committing changes.
		*m: connect		&& Return a Codemine Connection ID to a new or existing instance of the specified connection.
		*m: disconnect		&& Decrement use count of the specified connection, and close it when count reaches 0.
		*m: execute		&& Execute the specified SQL statement on the Specifed connection.
		*m: getprop		&& Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		*m: inspectordetails		&& Display object-specific debugging information in the Codemine object inspector.
		*m: nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*m: nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		*m: rollbacktrans		&& Abort the current VFP level transaction.
		*m: setprop		&& Set connection properties, using the same property names as the VFP SQLGETPROP() function.
		*m: _addconnection		&& Internal method to add a connection to our collection of managed connection objects.
		*m: _getconn		&& Return object reference to the connection object identified by nConnID.
		*m: _removeconnection		&& Remove the specified connection object.
		*p: lglobalshare		&& If .T. shared connections can be shared accross Data Sessions. If .F. they are only shared among clients in the same Data Session.
		*p: ntransactionmode		&& 0 = No Transactions, 1 = Remote Transactions Only, 3 = Remote and local transaction as needed (default).
	*</DefinedPropArrayMethod>

	BackColor = 192,255,255
	cclass = cmConnectionManager
	Height = 22
	lglobalshare = .T.		&& If .T. shared connections can be shared accross Data Sessions. If .F. they are only shared among clients in the same Data Session.
	Name = "cmconnectionmanager"
	ntransactionmode = 3		&& 0 = No Transactions, 1 = Remote Transactions Only, 3 = Remote and local transaction as needed (default).
	Width = 36
	
	PROCEDURE addconnection		&& Add an existing VFP connection handle to the pool of managed connections. Typically used to add connections opened by VFP remote views.
		LPARAMETERS cConnection, lShared, nVFPhandle
		*++
		*>>Add an existing VFP connection handle to the pool of managed connections. Typically used to add connections opened by VFP remote views.
		*--
		LOCAL ix, oConn, cShareName
		
		  * If a shared connection, look for existing one of same name and type.
		  * Use a separate suffix for View connections, so SQLPT cursors will not share them.
		  * Need to enhance ConnMan to share PT connections across data sessions to share with view connections.
		  m.cShareName = PROPER(ALLTRIM(m.cConnection)) + '.VFP.view'
		  IF m.lShared
		    FOR EACH oConn IN THIS.Controls
		      * Even if the view is marked to share connections, it may not have been able to.
		      * So, we need to also test that the VFP connection handle is the same as the 
		      * existing connection before we can consider it a match.
		      IF m.oConn.cShareName == m.cShareName AND m.oConn.nVFPhandle = m.nVFPhandle
		        * Increment reference count, and return index of existing connection.
		        m.oConn.Open()
		        RETURN m.oConn.nConnID
		      ENDIF
		    ENDFOR
		  ELSE
		    * Add a suffix to non-shared connection names, so it wont match original name.
		    m.cShareName = m.cShareName + '.Private'
		  ENDIF
		
		  * Create a new connection object, and bind it to the VFP connection handle.
		  m.oConn = THIS._AddConnection(m.cShareName, 'cmConnectionVFP')
		  WITH m.oConn
		    .Open()                && Open with no parameters simply increments use count.
		    .nVFPhandle = m.nVFPhandle
		    .lNoDisconnect = .T.   && Opened by a view, so let view disconnect it.
		    RETURN .nConnID
		  ENDWITH
		
	ENDPROC

	PROCEDURE begintrans		&& Start a transaction. If nConnection parameter is specified, add it to list of connections with outstanding remote transactions at the current level.
		LPARAMETERS nConnId, nFlags
		*++
		*>>Start a transaction. If nConnection parameter is specified, add it to list of connections with outstanding remote transactions at the current level.
		* 
		* If nFlags TRANMASK_FORCENEW is true, an actual nested tranaction level will be started. Otherwise, 
		* the connection will be added to the list of connections involved with the current 
		* transaction level.
		*
		* If no remote connection is involved, pass a 0 for the value of nConnId.
		*--
		LOCAL oConn
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF THIS.nTransactionMode > 0
		    THIS.nMergelevel = THIS.nMergelevel + 1
		    IF (THIS.nTranLevel = 0 OR NOT EMPTY(BITAND(m.nFlags, TRANMASK_FORCENEW)))
		      THIS.nTranLevel = THIS.nTranLevel + 1
		      DIMENSION THIS.aRemoteTransactions[THIS.nTranLevel, 2]
		      THIS.aRemoteTransactions[THIS.nTranLevel, 1] = ''
		      THIS.aRemoteTransactions[THIS.nTranLevel, 2] = THIS.nMergelevel
		
		      IF THIS.nTransactionMode >= 2 AND EMPTY(BITAND(m.nFlags, TRANMASK_REMOTEONLY))
		        BEGIN TRANSACTION
		        THIS.aRemoteTransactions[THIS.nTranLevel, 1] = CHR(0)
		      ENDIF
		    ENDIF
		
		    * If nConnId parameter is specified add it to list 
		    * of connections with outstanding remote transactions at this level.
		    IF NOT EMPTY(m.nConnId) AND NOT CHR(m.nConnId) $ THIS.aRemoteTransactions[THIS.nTranLevel,1]
		      THIS.aRemoteTransactions[THIS.nTranLevel,1] = THIS.aRemoteTransactions[THIS.nTranLevel,1] + CHR(m.nConnId)
		
		      m.oConn = THIS._GetConn(m.nConnID)
		      IF NOT m.oConn.BeginTrans()
		        RETURN .F.   && Error message will already have been stored/displayed, if appropriate
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE committrans		&& End the current transaction level by committing changes.
		*++
		*>>End the current transaction level by committing changes.
		*--
		LOCAL ix, oConn, nConnId, cConnList
		
		  IF (THIS.nMergelevel > 0)
		    IF (THIS.aRemoteTransactions[THIS.nTranLevel, 2] == THIS.nMergelevel)
		      * End the transaction on each remote connection that was part of this level.
		      m.cConnList = THIS.aRemoteTransactions[THIS.nTranLevel, 1]
		      FOR ix = 1 TO LEN(m.cConnList)
		        m.nConnId = ASC(SUBSTR(m.cConnList, m.ix, 1))
		        IF m.nConnId > 0
		          m.oConn = THIS._GetConn(m.nConnID)
		          IF NOT ISNULL(m.oConn) AND NOT m.oConn.CommitTrans()
		            RETURN .F.  && Error message will already have been stored/displayed, if appropriate
		          ENDIF
		        ENDIF
		      ENDFOR
		
		      * End VFP transaction and Force to disk, for increased reliability with native tables.
		      IF LEFT(m.cConnList, 1) == CHR(0)
		        END TRANSACTION
		        FLUSH   && Helps prevent memo damage during system crashes
		      ENDIF
		      THIS.nTranLevel = THIS.nTranLevel - 1
		    ENDIF
		    THIS.nMergelevel = THIS.nMergelevel - 1
		  ENDIF
		
	ENDPROC

	PROCEDURE connect		&& Return a Codemine Connection ID to a new or existing instance of the specified connection.
		LPARAMETERS cConnection, lShared, cType
		*++
		*>>Return a Codemine Connection ID to a new or existing instance of the specified connection.
		*
		* cType - Parameter can be "VFP" or "ADO"
		*--
		LOCAL ix, oConn, cShareName
		
		  IF EMPTY(m.cType)    && Default to a native VFP connection type
		    m.cType = 'VFP'
		  ENDIF
		
		  * If a shared connection, look for existing one of same name and type.
		  m.cShareName = PROPER(ALLTRIM(m.cConnection)) + '.' + UPPER(ALLTRIM(m.cType))
		
		  * If not sharing globally, append a data-session suffix.
		  IF NOT THIS.lGlobalShare
		    m.cShareName = m.cShareName + '.' + LTRIM(STR(SET('DataSesion')))
		  ENDIF
		  IF m.lShared
		    FOR EACH oConn IN THIS.Controls
		      IF m.oConn.cShareName == m.cShareName
		        * Increment reference count, and return index of existing connection.
		        m.oConn.Open()
		        RETURN m.oConn.nConnID
		      ENDIF
		    ENDFOR
		  ELSE
		    * Add a suffix to non-shared connection names, so it wont match original name.
		    m.cShareName = m.cShareName + '.Private'
		  ENDIF
		
		  * Create a new connection if no existing connection was found.
		  m.oConn = THIS._AddConnection(m.cShareName, 'cmConnection' + m.cType)
		  IF m.oConn.Open(m.cConnection)
		    RETURN m.oConn.nConnID
		  ENDIF
		
		  * Error opening connection. Remove it from our collection and return 0.
		  THIS._RemoveConnection(m.oConn)
		  RETURN 0
		
	ENDPROC

	PROCEDURE Destroy
		  * If (due to an error/cancel) we are destroyed with outstanding transactions, roll them back.
		  DO WHILE THIS.nTranLevel > 0
		    THIS.RollbackTrans()
		  ENDDO
		
	ENDPROC

	PROCEDURE disconnect		&& Decrement use count of the specified connection, and close it when count reaches 0.
		LPARAMETERS nConnId
		*++
		*>>Decrement use count of the specified connection, and close it when count reaches 0.
		*--
		LOCAL oConn
		  m.oConn = THIS._GetConn(m.nConnID)
		
		  * Close the connection (or decrement use count). Returns T when use count is 0.
		  IF NOT ISNULL(m.oConn) AND m.oConn.Close()
		    THIS._RemoveConnection(m.oConn)
		  ENDIF
		
	ENDPROC

	PROCEDURE execute		&& Execute the specified SQL statement on the Specifed connection.
		LPARAMETERS nConnId, cSql, cResultCursor
		*++
		*>>Execute the specified SQL statement on the Specifed connection.
		*--
		LOCAL oCursor, uResult, oConn
		
		  * Return discrete value only if no result output cursor specified.
		  m.oConn = THIS._GetConn(m.nConnID)
		  IF EMPTY(m.cResultCursor)
		    RETURN m.oConn.Execute(@m.cSql)
		  ENDIF
		
		  * Return cursor object for result recordset, which may be a VFP cursor, or ADO recordset.
		  m.uResult = m.oConn.Execute(@m.cSql, m.cResultCursor)
		  IF NOT ISNULL(m.uResult)
		    m.oCursor = CreateNewObject('cmCursor')
		    m.oCursor.BindToRecordSet(m.uResult)
		    RETURN m.oCursor
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE getprop		&& Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		LPARAMETERS nConnId, cProperty
		*++
		*>>Return connection properties, using the same property names as the VFP SQLGETPROP() function.
		*--
		LOCAL oConn
		  m.oConn = THIS._GetConn(m.nConnID)
		  RETURN m.oConn.GetProp(PROPER(m.cProperty))
		
	ENDPROC

	PROCEDURE Init
		  DODEFAULT()
		
		  THIS.AddProperty('nConnections', 0)
		  THIS.AddProperty('aRemoteTransactions[1,2]')
		  THIS.AddProperty('nTranLevel', 0)
		  THIS.AddProperty('nMergelevel', 0)
		  THIS.AddProperty('nFirstFreeConnID', 1)
		
	ENDPROC

	PROCEDURE inspectordetails		&& Display object-specific debugging information in the Codemine object inspector.
		LPARAMETERS oNodes, cRoot
		*++
		*>>Display object-specific debugging information in the Codemine object inspector.
		*--
		LOCAL cDetail, oConn
		
		  m.oNodes.Add(m.cRoot, 4, 'ConnMan', 'Managed Connections')
		  FOR EACH oConn IN THIS.Controls
		    WITH m.oConn
		      m.cDetail = 'Connection' + LTRIM(STR(.nConnID))
		      m.oNodes.Add('ConnMan', 4, m.cDetail, '(' + LTRIM(STR(.nConnID)) + ') ' + .cShareName )
		      m.oNodes.Add(m.cDetail, 4, , 'Use Count = ' + LTRIM(STR(.nUseCount)))
		      IF PEMSTATUS(m.oConn, 'nVFPhandle', 5)
		        m.oNodes.Add(m.cDetail, 4, , 'VFP Handle = ' + LTRIM(STR(.nVFPhandle)))
		      ENDIF
		    ENDWITH
		  ENDFOR
		
	ENDPROC

	PROCEDURE nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*++
		*>>Return the nErrorMode value from the highest level available container.
		*--
		  * Connection Manager uses the parent CDE value, when available.
		  IF TYPE('THIS.Parent.nErrorMode') = 'N'
		    RETURN THIS.Parent.nErrorMode
		  ELSE
		    RETURN THIS.nErrorMode
		  ENDIF
		
	ENDPROC

	PROCEDURE nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		LPARAMETERS nValue
		*++
		*>>Set the nErrorMode property in the highest level available container.
		*--
		  * Connection Manager uses the parent CDE value, when available.
		  IF TYPE('THIS.Parent.nErrorMode') = 'N'
		    THIS.Parent.nErrorMode = m.nValue
		  ELSE
		    THIS.nErrorMode = m.nValue
		  ENDIF
		
	ENDPROC

	PROCEDURE rollbacktrans		&& Abort the current VFP level transaction.
		*++
		*>>Abort the current VFP level transaction.
		*--
		LOCAL ix, oConn, nConnId, cConnList
		
		  IF (THIS.nMergelevel > 0)
		    IF (THIS.aRemoteTransactions[THIS.nTranLevel, 2] == THIS.nMergelevel)
		
		      * Roll back the transaction on each remote connection that was part of this level.
		      m.cConnList = THIS.aRemoteTransactions[THIS.nTranLevel, 1]
		      FOR ix = 1 TO LEN(m.cConnList)
		        m.nConnId = ASC(SUBSTR(m.cConnList, m.ix, 1))
		        IF m.nConnId > 0
		          m.oConn = THIS._GetConn(m.nConnID)
		          m.oConn.RollbackTrans()
		        ENDIF
		      ENDFOR
		      IF LEFT(m.cConnList, 1) == CHR(0)
		        ROLLBACK   && Rollback the VFP level transaction as well
		      ENDIF
		      THIS.nTranLevel = THIS.nTranLevel - 1
		    ENDIF
		    THIS.nMergelevel = THIS.nMergelevel - 1
		  ENDIF
		
	ENDPROC

	PROCEDURE setprop		&& Set connection properties, using the same property names as the VFP SQLGETPROP() function.
		LPARAMETERS nConnId, cProperty, uValue
		*++
		*>>Set connection properties, using the same property names as the VFP SQLGETPROP() function.
		*--
		LOCAL oConn
		  m.oConn = THIS._GetConn(m.nConnID)
		  RETURN m.oConn.SetProp(PROPER(m.cProperty), m.uValue)
		
	ENDPROC

	PROCEDURE _addconnection		&& Internal method to add a connection to our collection of managed connection objects.
		LPARAMETERS cShareName, cClass
		*++
		*>>Internal method to add a connection to our collection of managed connection objects.
		* Returns object reference to the newly added connection.
		*--
		LOCAL ix, cObjName, oConn
		
		  FOR ix = THIS.nFirstFreeConnID TO 255   && We only support up to 255 connections.
		    m.cObjName = 'Connection' + LTRIM(STR(m.ix))
		    IF NOT PEMSTATUS(THIS, m.cObjName, 5)
		      THIS.AddObject(m.cObjName, m.cClass)
		      THIS.nConnections = THIS.nConnections + 1
		
		      m.oConn = EVALUATE('THIS.' + m.cObjName)
		      WITH m.oConn
		        .nConnID = m.ix               && This is the ID number used to identify the connection externally.
		        .cShareName = m.cShareName    && Name used to compare against for connection sharing
		      ENDWITH
		
		      * Maintain nFirstFreeConnID to optimize the search for free conn IDs
		      THIS.nFirstFreeConnID = m.ix + 1
		      RETURN m.oConn
		    ENDIF
		  ENDFOR
		
		  ERROR THIS.Name + ' - Maximum number of connections exceeded'
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE _getconn		&& Return object reference to the connection object identified by nConnID.
		LPARAMETERS nConnId
		*++
		*>>Return object reference to the connection object identified by nConnID.
		*--
		LOCAL cObjName
		  m.cObjName = 'Connection' + LTRIM(STR(m.nConnID))
		  IF PEMSTATUS(THIS, m.cObjName, 5)
		    RETURN EVALUATE('THIS.' + m.cObjName)
		  ENDIF
		  ERROR THIS.Name + ' - Invalid Connection ID ' + LTRIM(STR(m.nConnID))
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE _removeconnection		&& Remove the specified connection object.
		LPARAMETERS oConn
		*++
		*>>Remove the specified connection object.
		*--
		  IF m.oConn.nConnID < THIS.nFirstFreeConnID
		    THIS.nFirstFreeConnID = m.oConn.nConnID
		  ENDIF
		  THIS.RemoveObject(m.oConn.Name)
		  THIS.nConnections = THIS.nConnections - 1
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmcursor AS cmdataabstract OF "cmdataa.vcx" 		&& Codemine 7.1 cursor definition class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_cursor.bmp" ClassIcon="..\graphics\_cursor.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: accessclose		&& Call the access object to close the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*m: accessopen		&& Call the access object to open the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*m: accessrequery		&& Call the access object to Requery the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*m: accessupdate		&& Call the access object to update the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*m: accessupdaterecord		&& Call the access object to update the current record in the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*m: addchild		&& Add a relation into the specified child cursor.
		*m: addrule		&& Link a rule object to this cursor.
		*m: bindtorecordset		&& Link this cursor object to an already-open target recordset.
		*m: cforeignkeyfield_access		&& Derive foreign key field name from current index tag, if not explicitly specified.
		*m: clearchildren		&& Remove all child cursor links from this cursor.
		*m: clearrules		&& Remove all rule objects from this cursor.
		*m: clone		&& Create a duplicate of this cursor object, and a duplicate buffer space for the underlying recordset.
		*m: close		&& Close the currently open cursor.
		*m: cprimarykeyfield_access		&& Derive primary key field name from current index tag or cursor properties, if not explicitly specified.
		*m: create		&& Custom code to Create the source tables for this cursor.
		*m: csource_assign
		*m: curvalue		&& Return the Current Underlying value of the specified field.
		*m: delete		&& Delete the current record in this cursor, along with all related child records that have lDeleteWithParent set. Then move to the next non-deleted record in the cursor.
		*m: deleterecord		&& Low level method to Delete a record and its related children. Commits if cursor is row-buffered.
		*m: deletewhere		&& Delete records matching the specified Where expression. For views, records are deleted via direct commands to the server database.
		*m: edit		&& Edit the current record interactively, by triggering the EditRule() event.
		*m: enumchildren		&& Enumerate the related child cursors of this cursor.
		*m: execute		&& Execute an SQL command on the current connection to a remote database. Applies only to cursors based on remote data sources.
		*m: export		&& Custom code to Export data from this cursor.
		*m: fieldtype		&& Return the data type of the specified field. Length and Decimal places are returned in the 2 optional output parameters.
		*m: fieldvalue		&& Return the current local buffered value of the specified field.
		*m: find		&& Find the first record in the cursor that matches the specified expression. If lContinue parameter is .T. the search begins with the current record.
		*m: getbuffermode		&& Return the buffering mode for this cursor as a numeric code. The return values match those of the VFP CURSORGETPROP("Buffering") function.
		*m: getchildren		&& Return a comma separated list of all child workareas related to this cursor.
		*m: getfilter		&& Return the current record filter expression for the cursor.
		*m: getorder		&& Return the current sort order of the cursor.
		*m: getparent		&& Return the relational parent alias (or empty string).
		*m: getposition		&& Return the current record position - by record number for tables, or PK value for views/SQLPT.
		*m: getprop		&& Return various property settings about the cursor.
		*m: gobottom		&& Go to the last record in the cursor
		*m: goto		&& Go to the specified record number in the cursor
		*m: gotop		&& Go to the first record in the cursor
		*m: import		&& Custom code to Import data into this cursor.
		*m: isbottom		&& Return the "Bottom" state of the current record in the cursor.
		*m: ischanged		&& Returns true if any record in this cursor contains uncommited changes, or (optionally) any child record is changed.
		*m: isdeleteallowed		&& Determine whether or not records may be deleted from the specified workarea.
		*m: isdeleted		&& Determine if the current record has been marked deleted.
		*m: iseditallowed		&& Determine if the specified field may be edited. Always returns .F. if the cursor is empty or at EOF.
		*m: isempty		&& Determine whether or not the cursor has any undeleted records.
		*m: iseof		&& Determine whether or not the cursor is at EOF.
		*m: isexclusive		&& Return the current EXCLUSIVE use setting of the cursor. Useful for native VFP tables only.
		*m: isfield		&& Return true if the specified field name is present in this cursor
		*m: isfieldchanged		&& Returns true if the specified field in the current record has been changed.
		*m: isnew		&& Determine if the current record is Newly appended.
		*m: isnewallowed		&& Determine whether or not records may be added to the specified workarea.
		*m: isopen		&& Determine whether or not the cursor is open.
		*m: isoverwriteallowed		&& Return .T. if it is ok to overwrite another users changes during an Update() method call.
		*m: isreadonly		&& Determine if the cursor is read-only.
		*m: isrecordchanged		&& Returns true if the current record contains uncommited changes, or (optionally) any child record is changed.
		*m: isrequired		&& Returns true if the specified field is required - ie cannot be left empty when edited.
		*m: istop		&& Return the "Top" state of the current record in the cursor.
		*m: ldeletewithparent_access		&& lDeleteWithParent should always return False if lRequeryWhenParentMoves is False.
		*m: loaddataaccess		&& Create the data access object for the cursor, based on cursor type.
		*m: localtransbegin		&& Begin a new local transaction level for the cursor (or CDE if we are contained in a CDE).
		*m: localtranscommit		&& Commit and close the current local transaction level.
		*m: localtransrollback		&& Commit and close the current local transaction level.
		*m: lockforedit		&& Obtain whatever locks are necessary before allowing a change to the current record.
		*m: lockrecord		&& Obtain network Lock for the current, or the specified record. Use record number 0 to lock the header.
		*m: loverwrite_access		&& For backward compatability, a global default in DataManager will override cursor setting.
		*m: lqueryremotepk_access		&& Determine if we need to query the server for the assigned PK value after saving a new record.
		*m: lrecyclerecords_access		&& For backward compatability, a global default in DataManager will override cursor setting.
		*m: lrequerywhenparentmoves_assign		&& Clear uCurrentKey property (used for child requery optimization) when lRequeryWhenParentMoves is changed.
		*m: nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*m: nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		*m: new		&& Add a new record to the record set.
		*m: nicecursorname		&& Return a user-friendly name for this cursor, based on the cDisplayName property.
		*m: nicefieldname		&& Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		*m: nlocaltranslevel_access		&& Use the local transaction level of our CDE first. If no CDE, then parent cursor. If no parent, then our own private level.
		*m: nlocaltranslevel_assign		&& Use the local transaction level of our CDE first. If no CDE, then parent cursor. If no parent, then our own private level.
		*m: oconnman_access		&& Find a reference to the connection manager object to use.
		*m: oconn_access		&& Find a reference to the connection object to use.
		*m: oldvalue		&& Return the old (original) value of the specified field.
		*m: open		&& Open the cursor and create the appropriate data access object.
		*m: opendatabase		&& Open the database specified in the cDatabase, if not already open, and make it the current DBC.
		*m: pack		&& Pack the table, removing deleted records. Applies to native VFP tables only. cOption parameter can be empty, 'MEMO' or 'DBF'.
		*m: parentkeychanged		&& Update the FK for all our records related to current parent recored, after the parent's PK was changed. Normally called by parent's PrimaryKeyChanged() method.
		*m: parentritest		&& Enforce parent RI before an update, by ensuring a new child record will not be written without a parent.
		*m: primarykeychanged		&& Reset child foriegn keys in table-buffered children, after our primary key has been changed. Applies to native VFP parent tables only.
		*m: queueuirefresh		&& Call the Data Manager to queue a refresh for UI controls bound to the specified field in this cursor.
		*m: reccount		&& Return the total number of records in the cursor
		*m: recno		&& Return the current record number, or 0 if there is no current record (EOF).
		*m: recordreadytomove		&& Internal method called before record pointer is moved in a cursor.
		*m: recordwasmoved		&& Reset position flags and Re-select child recordsets after the record pointer was moved.
		*m: refreshdata		&& Refresh data in the current record of the cursor.
		*m: reindex		&& Regenerate all existing indexes. Applies to native VFP tables only.
		*m: removechild		&& Remove the specified cursor from our collection of related children.
		*m: removerule		&& Remove the specified rule from our collection of linked rules.
		*m: replace		&& Replace the contents of the specified field with the specified value.
		*m: requery		&& Requery the view.
		*m: restoreposition		&& Restore record pointer to the last saved value if possible.
		*m: revert		&& Discard all buffered changes and unlock this cursor, and all related child cursors.
		*m: revertrecord		&& Discard buffered changes to the current record. If the current record is a newly appened record, the entire record is removed from the buffer, and the record pointer is restored to its previous location.
		*m: saveposition		&& Save current record pointer position.
		*m: seek		&& Seek the record matching the specified key in the cursor
		*m: select		&& Load the recordset matching the specified key - usually a foriegn key matching the current parent record.
		*m: setbuffermode		&& Set the buffering mode for this cursor
		*m: setdefault		&& Set this cursor as the curernt VFP workarea (if it is a native VFP cursor).
		*m: setexclusive		&& Change the EXCLUSIVE use setting of the currently open table. Useful for native VFP cursors only.
		*m: setfilter		&& Set the record filter expression for the cursor, and leave cursor on first matching record.
		*m: setforeignkey		&& Set the foreign key value of child tables in a 1-1 or 1-many relation. Must be overridden for compound foreign keys.
		*m: setorder		&& Set the sort order to the specified tag/field.
		*m: setpath		&& Call application object to get correct runtime paths to data files.
		*m: setposition		&& Set the current record position - by record number for tables, or PK value for views/SQLPT.
		*m: setpositionflags		&& Set the record position flags for a cursor.
		*m: setprimarykey		&& Set the primary key for the current record.
		*m: setprop		&& Set various properties for the cursor.
		*m: skip		&& Skip the specified number of records forward or backwards.
		*m: unlockall		&& Unlock all locks on all records in this cursor.
		*m: unlockrecord		&& Release network lock on the current (or specified) record. Use record number 0 to unlock the header.
		*m: update		&& Write outstanding changes back to the source tables, after (optionally) enforcing all validation rules.
		*m: updaterecord		&& Write outstanding changes to the current record back to the source table.
		*m: validatecursor		&& Trigger the "CursorValid" event for this cursor, and any related children.
		*m: validatefield		&& Validate the specified field in the cursor.
		*m: validaterow		&& Validate the current row in the cursor, and all rows in related children.
		*m: zap		&& Delete all records from the cursor. For tables, the records are physically deleted. For view cursors, the local cursor in emptied, but source tables are unaffected.
		*m: _callafteropen		&& Internal method to Execute the AfterOpen() rule event, and for views the initial AfterRequery() event too.
		*m: _evaluate		&& Evaluate the specified expression in this object's context.
		*m: _executerule		&& Execute a specific rule in associated rule objects.
		*m: _ltcommit		&& Internal method to clear the save state data for the specified local transaction level.
		*m: _ltjoin		&& Internal method to save state data for the current record to the current local transaction level. Does nothing if no Local Transaction is in progress.
		*m: _ltrollback		&& Internal method to roll back the data to last saved current local transaction level.
		*m: _settypefromdbc		&& Set the type for a cursor based on the definition of the cursor in the current DBC.
		*p: cconnection		&& Remote Connection name, or DSNname,userid,password. Used for Non-DBC remote cursors, like SQL passthrough or ADO.
		*p: cdataaccessclass		&& Name of override data access class to use. Leave empty to use default access class based on cursor type.
		*p: cdatabase		&& Full path (absolute or relative) to the DBC. If not empty, then cSource must be the name of a table or view in the DBC.
		*p: cfilter		&& Record filter expression.
		*p: cforeignkeyfield		&& This is the field name of the foreign key field for a child cursor. For tables, this is derived from the relational index expression.
		*p: corder		&& Index order of the cursor. For tables this is the default index tag name.
		*p: cparent		&& Workarea alias name of parent cursor to relate to. Used at design time to specify parent.
		*p: cparentkeyfield		&& Field in parent cursor used as relational link into this cursor. For a 1-1 or 1-many relation, this will usually be the parent's primary key.
		*p: cprimarykeycounter		&& Full key path of the counter key to use for primary key values. Leave blank to use default name generated by PrimaryKey() function.
		*p: cprimarykeyfield		&& Primary Key field name. Leave blank to determine key field from cursor properties or Index at runtime.
		*p: csource		&& Cursor source - usually a table or view name. For free tables, this can include a full path.
		*p: ctype		&& Type of record set to create. If cDatabase is not empty, then cType is determined by the DBC entry (table, lView, or rView).
		*p: cwhere		&& The WHERE clause expression. Used for SQL Passthrough cursors and Dynamic remote views only.
		*p: cworkarea		&& Workarea alias name for this cursor. Used to identify the cursor to rest of the system.
		*p: lallowabort		&& Set to .T. to allow user to cancel record locking retries or query processing by pressing escape. NULL defaults to .T. for tables and .F. for views.
		*p: lautoclose		&& If .T. close the cursor when the cursor object (or its CDE) is released. Otherwise, leave the cursor open.
		*p: lautocreate		&& If .T. the Create() method will be called if a "file-not-found" error is encountered on Open().
		*p: lautoopen		&& If .T., include this cursor with those opened when the CDE.OpenAll() method is called.
		*p: lautopk		&& Automatically assign Primary Key values when new records are added.
		*p: ldeletewithparent		&& When true and this is a child cursor in a relation, deleting the parent record causes all child records to be deleted also. Leave .NULL. to determine default at runtime.
		*p: lexclusive		&& Applies to Tables only - true if should be opened exclusively
		*p: lignore		&& Cursor should not be considered for updates or UI change-flag settings.
		*p: lnocursoronload		&& Used for SQLPT and ADO cursors only. Similar to lNoDataOnLoad, but also prevents the creation of an empty recordset on cursor open.
		*p: lnodataonload		&& Set to .T. to prevent initial download of data when a view is opened. This should usually be set to .T. for parameterized views.
		*p: loverwrite		&& Set to .T. to overwrite other users changes on update collisions, .F. to prompt user, or .NULL. to fail on overwrite condition.
		*p: lqueryremotepk		&& If .T. and this is a remote view with server-assigned PK values, query the server after a new record is saved and update the view record to reflect the value of the PK assigned by the server.
		*p: lreadonly		&& Cursor should be opened phyically read-only.
		*p: lrecyclerecords		&& For direct tables only. Reuse deleted records when adding new, if indexed on DELETED()
		*p: lrememberorder		&& Remember the current index order for tables, and restore on next open. Applies only when cursor is used in a form.
		*p: lrememberrecord		&& Remember the current record position for tables, and restore on next open. Applies only when cursor is used in a form.
		*p: lrequerywhenparentmoves		&& When true and this is a child cursor in a relation, the recorset is filtered or requeried to select only records matching the current parent. Leave .NULL. to determine default at runtime.
		*p: lshareconnection		&& Set to .T. to share the remote cConnection. Used for Non-DBC remote cursors, like SQL passthrough or ADO.
		*p: lupdateonrowchange		&& Set to .T. to force update on row change, even if table buffering (mode 4 or 5). This allows reliable row-buffered behavior in grids.
		*p: luseruntimepath		&& If .T. the design-time DBC or free table path will be stripped at runtime by app.GetFilePath()
		*p: nbuffermode		&& Desired Buffering Mode for the cursor. 0=No buffering, 1=Use default mode, 2=Pessimistic row buffering, 3=Optimistic row buffering, 4=Pessimistic table buffering, 5=Optimistic table buffering.
		*p: nlocaltranslevel		&& Current local transaction level. Should always be 0 at design time.
		*p: nlockretry		&& Number of times to re-try failed network record locks. Set to 0 to never retry. Set to -1 to retry forever.
		*p: nnavigationmode		&& Determines how record navigation flags are set. 0-Nav disable, 1-Normal but no nav for new if record buffered, 2-Normal but no nav on any new, 3-Normal, 4-Nav always enabled.
		*p: nnonupdateablemode		&& Determines behavior of Non-updateable view cursors: 0=Treat as Read-only, 1=Editable but changes ignored, 2=Editable and changes count (requires custom update code).
		*p: oconn		&& Runtime reference to the connection object - added to cm7.5 for sw compatibility with cm8.0.
		*p: oconnman		&& Runtime reference to the connection manager object.
	*</DefinedPropArrayMethod>

	BackColor = 196,238,193
	cclass = cmCursor
	cconnection = 		&& Remote Connection name, or DSNname,userid,password. Used for Non-DBC remote cursors, like SQL passthrough or ADO.
	cdataaccessclass = 		&& Name of override data access class to use. Leave empty to use default access class based on cursor type.
	cdatabase = 		&& Full path (absolute or relative) to the DBC. If not empty, then cSource must be the name of a table or view in the DBC.
	cfilter = 		&& Record filter expression.
	cforeignkeyfield = 		&& This is the field name of the foreign key field for a child cursor. For tables, this is derived from the relational index expression.
	corder = 		&& Index order of the cursor. For tables this is the default index tag name.
	cparent = 		&& Workarea alias name of parent cursor to relate to. Used at design time to specify parent.
	cparentkeyfield = 		&& Field in parent cursor used as relational link into this cursor. For a 1-1 or 1-many relation, this will usually be the parent's primary key.
	cprimarykeycounter = 		&& Full key path of the counter key to use for primary key values. Leave blank to use default name generated by PrimaryKey() function.
	cprimarykeyfield = 		&& Primary Key field name. Leave blank to determine key field from cursor properties or Index at runtime.
	csource = 		&& Cursor source - usually a table or view name. For free tables, this can include a full path.
	ctype = 		&& Type of record set to create. If cDatabase is not empty, then cType is determined by the DBC entry (table, lView, or rView).
	cwhere = 		&& The WHERE clause expression. Used for SQL Passthrough cursors and Dynamic remote views only.
	cworkarea = 		&& Workarea alias name for this cursor. Used to identify the cursor to rest of the system.
	Height = 22
	lallowabort = .NULL.		&& Set to .T. to allow user to cancel record locking retries or query processing by pressing escape. NULL defaults to .T. for tables and .F. for views.
	lautoclose = .T.		&& If .T. close the cursor when the cursor object (or its CDE) is released. Otherwise, leave the cursor open.
	lautocreate = .F.		&& If .T. the Create() method will be called if a "file-not-found" error is encountered on Open().
	lautoopen = .T.		&& If .T., include this cursor with those opened when the CDE.OpenAll() method is called.
	lautopk = .T.		&& Automatically assign Primary Key values when new records are added.
	ldeletewithparent = .NULL.		&& When true and this is a child cursor in a relation, deleting the parent record causes all child records to be deleted also. Leave .NULL. to determine default at runtime.
	lexclusive = .F.		&& Applies to Tables only - true if should be opened exclusively
	lignore = .F.		&& Cursor should not be considered for updates or UI change-flag settings.
	lnocursoronload = .F.		&& Used for SQLPT and ADO cursors only. Similar to lNoDataOnLoad, but also prevents the creation of an empty recordset on cursor open.
	lnodataonload = .F.		&& Set to .T. to prevent initial download of data when a view is opened. This should usually be set to .T. for parameterized views.
	loverwrite = .F.		&& Set to .T. to overwrite other users changes on update collisions, .F. to prompt user, or .NULL. to fail on overwrite condition.
	lqueryremotepk = .T.		&& If .T. and this is a remote view with server-assigned PK values, query the server after a new record is saved and update the view record to reflect the value of the PK assigned by the server.
	lreadonly = .F.		&& Cursor should be opened phyically read-only.
	lrecyclerecords = .F.		&& For direct tables only. Reuse deleted records when adding new, if indexed on DELETED()
	lrememberorder = .F.		&& Remember the current index order for tables, and restore on next open. Applies only when cursor is used in a form.
	lrememberrecord = .F.		&& Remember the current record position for tables, and restore on next open. Applies only when cursor is used in a form.
	lrequerywhenparentmoves = .NULL.		&& When true and this is a child cursor in a relation, the recorset is filtered or requeried to select only records matching the current parent. Leave .NULL. to determine default at runtime.
	lshareconnection = .T.		&& Set to .T. to share the remote cConnection. Used for Non-DBC remote cursors, like SQL passthrough or ADO.
	lupdateonrowchange = .F.		&& Set to .T. to force update on row change, even if table buffering (mode 4 or 5). This allows reliable row-buffered behavior in grids.
	luseruntimepath = .T.		&& If .T. the design-time DBC or free table path will be stripped at runtime by app.GetFilePath()
	Name = "cmcursor"
	nbuffermode = 1		&& Desired Buffering Mode for the cursor. 0=No buffering, 1=Use default mode, 2=Pessimistic row buffering, 3=Optimistic row buffering, 4=Pessimistic table buffering, 5=Optimistic table buffering.
	nlocaltranslevel = 0		&& Current local transaction level. Should always be 0 at design time.
	nlockretry = 20		&& Number of times to re-try failed network record locks. Set to 0 to never retry. Set to -1 to retry forever.
	nnavigationmode = 1		&& Determines how record navigation flags are set. 0-Nav disable, 1-Normal but no nav for new if record buffered, 2-Normal but no nav on any new, 3-Normal, 4-Nav always enabled.
	nnonupdateablemode = 0		&& Determines behavior of Non-updateable view cursors: 0=Treat as Read-only, 1=Editable but changes ignored, 2=Editable and changes count (requires custom update code).
	oconn = .NULL.		&& Runtime reference to the connection object - added to cm7.5 for sw compatibility with cm8.0.
	oconnman = .NULL.		&& Runtime reference to the connection manager object.
	Width = 72
	
	PROCEDURE accessclose		&& Call the access object to close the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*++
		*>>Call the access object to close the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*--
		  RETURN THIS.cmDataAccess.Close()
		
	ENDPROC

	PROCEDURE accessopen		&& Call the access object to open the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		LPARAMETERS nBufferMode
		*++
		*>>Call the access object to open the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*--
		  ASSERT NOT EMPTY(THIS.cSource) MESSAGE THIS.Name + ': No cSource was specified'
		  RETURN THIS.cmDataAccess.Open(THIS.cSource, THIS.nBufferMode)
		
	ENDPROC

	PROCEDURE accessrequery		&& Call the access object to Requery the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		LPARAMETERS luValue1, luValue2, luValue3, luValue4
		*++
		*>>Call the access object to Requery the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*--
		  RETURN THIS.cmDataAccess.Requery()
		
	ENDPROC

	PROCEDURE accessupdate		&& Call the access object to update the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		LPARAMETERS nFlags
		*++
		*>>Call the access object to update the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*--
		  RETURN THIS.cmDataAccess.Update(m.nFlags)
		
	ENDPROC

	PROCEDURE accessupdaterecord		&& Call the access object to update the current record in the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*++
		*>>Call the access object to update the current record in the cursor. May be overridden by custom cursor objects to impliment special behaviors, such as crosstab cursors.
		*--
		  RETURN THIS.cmDataAccess.UpdateRecord()
		
	ENDPROC

	PROCEDURE addchild		&& Add a relation into the specified child cursor.
		LPARAMETERS oChild, cParentKeyExpr, cForeignKeyField
		*++
		*>>Add a relation into the specified child cursor.
		*--
		  IF VARTYPE(m.oChild) = 'O'
		    * Set Link expression, based on fields in the parent record used as comparison value
		    * against active child index, or child view parameter.
		    IF NOT EMPTY(m.cParentKeyExpr)
		      m.oChild.cParentKeyField = m.cParentKeyExpr
		    ENDIF
		    IF NOT EMPTY(m.cForeignKeyField)
		      m.oChild.cForeignKeyField = m.cForeignKeyField
		    ENDIF
		
		    IF EMPTY(m.oChild.cParentKeyField) OR EMPTY(m.oChild.cForeignKeyField)
		       ASSERT .F. MESSAGE 'cParentKeyField OR cForeignKeyField is not set for ' + m.oChild.cDisplayName
		    ELSE
		      * Set a refernce to this cursor as the parent of the new child.
		      m.oChild.oParent = THIS
		      m.oChild.cParent = PROPER(THIS.cWorkarea)
		
		      * Add a reference to new child in our collection of children.
		      THIS.nChildren = THIS.nChildren + 1
		      DIMENSION THIS.aChildren[THIS.nChildren]
		      THIS.aChildren[THIS.nChildren] = m.oChild
		
		      * Set a physical VFP relation if appropriate for the cursor type. This also 
		      * determines default for RI properties for the child, based on cursor type and available indexes.
		      IF m.oChild.cmDataAccess.SetRelation(THIS, m.oChild.cParentKeyField)
		        THIS._ExecuteRule('AfterAddChild', RULEMASK_ANDED,, m.oChild)
		        RETURN .T.
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE addrule		&& Link a rule object to this cursor.
		LPARAMETERS oRule
		*++
		*>>Link a rule object to this cursor.
		*--
		  THIS.nRuleCount = THIS.nRuleCount + 1
		  DIMENSION THIS.aRules[THIS.nRuleCount]
		  THIS.aRules[THIS.nRuleCount] = m.oRule
		
		  * Rule needs a ref to the CDE once it is linked to a cursor
		  IF ISNULL(m.oRule.oCDE)
		    m.oRule.oCDE = THIS.oCDE
		  ENDIF
		
		  * Call the AfterLinked() event in case rule needs to set any of our properties.
		  m.oRule.AfterLinked(THIS)
		
	ENDPROC

	PROCEDURE bindtorecordset		&& Link this cursor object to an already-open target recordset.
		LPARAMETERS uRecordset
		*++
		*>>Link this cursor object to an already-open target recordset.
		*--
		LOCAL nType
		
		  IF VARTYPE(m.uRecordSet) = 'C'
		    * Set cursor workarea to match the alias we are binding to.
		    THIS.cWorkarea = PROPER(m.uRecordSet)
		  ENDIF
		
		  * If cType property is EMPTY, try to determine type based on uRecordset parameter
		  IF EMPTY(THIS.cType)
		    DO CASE
		      CASE VARTYPE(m.uRecordSet) = 'C'
		        * Default type for VFP cursors is determined by the cursor properties.
		        m.nType = CURSORGETPROP('SourceType', m.uRecordset)
		        DO CASE
		          CASE m.nType = 1
		            THIS.cType = 'Lview'
		          CASE m.nType = 2
		            * If no DBC for a remote cursor, it must be a passthrough result set.
		            IF EMPTY(CURSORGETPROP('Database', m.uRecordset))
		              THIS.cType = 'SQLPT'
		            ELSE
		              THIS.cType = 'Rview'
		            ENDIF
		         CASE m.nType = 3
		           THIS.cType = 'Table'
		        ENDCASE
		
		      CASE VARTYPE(m.uRecordSet) = 'O'  && ADO is the only object type currently supported
		        THIS.cType = 'ADO'
		    ENDCASE
		  ENDIF
		
		  * Load the appropriate access object and complete the binding process.
		  THIS.LoadDataAccess()
		  THIS.cmDataAccess.BindToRecordset(m.uRecordset)
		
	ENDPROC

	PROCEDURE cdisplayname_access
		*++
		*>>Use the message manager to generate a default value for cDisplayName if necessary.
		*>>Return a user-friendly name for the specified cursor workarea.
		*
		* 1) If a value is specified in cDisplayName, use that
		* 2) If a %cur string key exists for the cursor name, translate it for the name.
		* 3) Use the long cursor name from DBC (if any)
		*--
		LOCAL cName, cTranslated
		
		  IF EMPTY(THIS.cDisplayName)
		    IF USED(THIS.cWorkarea)  && If it is an open VFP cursor
		      m.cName = PROPER(CURSORGETPROP('SourceName', THIS.cWorkarea))
		      * If it is a free table path, extract only the filename
		      IF ':' $ m.cName OR '\' $ m.cName
		        m.cName = JUSTSTEM(m.cName)
		      ENDIF
		    ELSE
		      m.cName = PROPER(THIS.cWorkarea)
		    ENDIF
		
		    * Look for a text key with a localized name translation for this cursor.
		    IF NOT ISNULL(THIS.oMessage)
		      m.cTranslated = THIS.oMessage.TranslateString('%cur' + m.cName)
		      IF LEFT(m.cTranslated, 1) != '%'
		        m.cName = m.cTranslated
		      ELSE
		        IF USED(THIS.cWorkarea)
		          * If it is a view, try the source table name.
		         IF CURSORGETPROP('SourceType', THIS.cWorkarea) != 3
		            m.cName = GetToken(CURSORGETPROP('Tables', THIS.cWorkarea), ',')
		            m.cName = SUBSTR(m.cName, RAT('!', m.cName) + 1)
		            m.cName = SUBSTR(m.cName, RAT('.', m.cName) + 1)
		            m.cTranslated = THIS.oMessage.TranslateString('%cur' + m.cName)
		            IF LEFT(m.cTranslated, 1) != '%'
		              m.cName = m.cTranslated
		            ENDIF
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		    THIS.cDisplayName = m.cName
		  ENDIF
		  RETURN THIS.cDisplayName
		
	ENDPROC

	PROCEDURE cforeignkeyfield_access		&& Derive foreign key field name from current index tag, if not explicitly specified.
		*++
		*>>Derive foreign key field name from current index tag, if not explicitly specified.
		*--
		  IF EMPTY(THIS.cForeignKeyField)
		    THIS.cForeignKeyField = THIS.cmDataAccess.GetForeignKeyField()
		  ENDIF
		  RETURN THIS.cForeignKeyField
		
	ENDPROC

	PROCEDURE clearchildren		&& Remove all child cursor links from this cursor.
		*++
		*>>Remove all child cursor links from this cursor.
		*--
		LOCAL oChild
		  * Unlink parent ref back to us from each child. When in a CDE, this 
		  * is especially important for cursors added via cde.AddCursor()
		  FOR EACH oChild IN THIS.aChildren
		    IF VARTYPE(m.oChild) = 'O'
		      m.oChild.oParent = .NULL.
		    ENDIF
		  ENDFOR
		
		  THIS.nChildren = 0
		  THIS.aChildren = .NULL.
		  DIMENSION THIS.aChildren[1]
		
	ENDPROC

	PROCEDURE clearrules		&& Remove all rule objects from this cursor.
		*++
		*>>Remove all rule objects from this cursor.
		*--
		LOCAL ix, oRule
		  FOR ix = 1 TO THIS.nRuleCount
		    m.oRule = THIS.aRules[m.ix]
		    IF NOT ISNULL(m.oRule)
		      * Call the rule BeforeUnLinked() event in case rule needs to clean up anything
		      m.oRule.BeforeUnLinked(THIS)
		    ENDIF
		  ENDFOR
		  THIS.nRuleCount = 0
		  THIS.aRules = .NULL.
		  DIMENSION THIS.aRules[1]
		
	ENDPROC

	PROCEDURE clone		&& Create a duplicate of this cursor object, and a duplicate buffer space for the underlying recordset.
		LPARAMETERS cNewAlias, nFlags
		*++
		*>>Create a duplicate of this cursor object, and a duplicate buffer space for the underlying recordset.
		*
		* nFlags Values:
		*  CLONEMASK_NOBUFFER - Do not apply original cursor's buffermode
		*  CLONEMASK_NOCDE - Create free Cursor object outside of CDE
		*--
		LOCAL ix, oClone
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  IF NOT ISNULL(THIS.oCDE) AND NOT BITTEST(m.nFlags, CLONEMASK_NOCDE)
		    m.oClone = THIS.oCDE.AddCursor(m.cNewAlias, THIS.Class, CDEMASK_NORULES)
		  ELSE
		    * Create new cursor object to represent the clone.
		    m.oClone = CREATEOBJECT(THIS.Class)
		  ENDIF
		
		  WITH m.oClone
		    .cType = THIS.cType
		    .cWorkarea = PROPER(m.cNewalias)
		    .cDataAccessClass = THIS.cDataAccessClass
		
		    * Clone underlying recordset, and link to the cloned cursor object
		    .BindToRecordset(THIS.cmDataAccess.Clone(@m.cNewAlias, m.nFlags))
		
		    * Clone gets the same buffering mode as the original
		    .SetBufferMode(THIS.cmDataAccess.GetBufferMode())
		
		    * Copy cursor properties to clone
		    .cDisplayName = THIS.cDisplayName
		    .nLockRetry = THIS.nLockRetry
		    .lOverwrite = THIS.lOverwrite
		    .lAllowAbort = THIS.lAllowAbort
		    .lRecycleRecords = THIS.lRecycleRecords
		    .nNonUpdateableMode = THIS.nNonUpdateableMode
		    .lAutoOpen = .F.                && In case we are created before OpenAll() completes.
		    .lDeleteWithParent = .F.        && Clones dont do this, only original cursor.
		    .lRequeryWhenParentMoves = .F.  && Dont want to requery a clone either...
		  ENDWITH
		
		  * Copy all rule links from ourself to our clone
		  m.oClone.nRuleCount = 0   && Zap any rules linked from cursor class init.
		  FOR ix = 1 TO THIS.nRuleCount
		    IF NOT ISNULL(THIS.aRules[m.ix])
		      m.oClone.AddRule(THIS.aRules[m.ix])
		    ENDIF
		  ENDFOR
		
		  * Set initial clone position flags, and return ref to the new clone.
		  m.oClone.RecordWasMoved()
		  RETURN m.oClone
		
	ENDPROC

	PROCEDURE close		&& Close the currently open cursor.
		*++
		*>>Close the currently open cursor.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    IF NOT EMPTY(THIS.cWorkarea)
		      THIS._ExecuteRule('BeforeClose', RULEMASK_ANDED)
		
		      * If there is an actual cursor open, make sure we clean out update buffers.
		      IF THIS.cmDataAccess.IsOpen()
		        * Discard any pending changes that were not committed by now. This would only
		        * happen if object is being released as part of an error abort process.
		        IF THIS.IsChanged(UPDATEMASK_NOCHILDREN)
		          THIS.Revert(UPDATEMASK_NOCHILDREN)
		        ENDIF
		      ENDIF
		
		      IF THIS.AccessClose()
		        THIS._ExecuteRule('AfterClose', RULEMASK_ANDED)
		
		        * Remove Access Obejct when closed, so a different type may be seleced for future re-opens.
		        THIS.RemoveObject('cmDataAccess')
		        RETURN .T.
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE cprimarykeyfield_access		&& Derive primary key field name from current index tag or cursor properties, if not explicitly specified.
		*++
		*>>Derive primary key field name from current index tag or cursor properties, if not explicitly specified.
		*--
		  IF EMPTY(THIS.cPrimaryKeyField)
		    THIS.cPrimaryKeyField = THIS.cmDataAccess.GetPrimaryKeyField()
		  ENDIF
		  RETURN THIS.cPrimaryKeyField
		
	ENDPROC

	PROCEDURE create		&& Custom code to Create the source tables for this cursor.
		*++
		*>>Custom code to Create the source tables for this cursor.
		*--
		  * Developer custom code here. Default code simply returns failure (false).
		  RETURN .F.
		
	ENDPROC

	PROCEDURE csource_assign
		LPARAMETERS cValue
		*++
		*>>Trim cSource value, and convert line breaks to spaces.
		*--
		  * Helps keep SQL statements assigned at runtime in a consistant format.
		  THIS.cSource = CHRTRAN(LTRIM(m.cValue), CHR(10)+CHR(13), '  ')
		
	ENDPROC

	PROCEDURE curvalue		&& Return the Current Underlying value of the specified field.
		LPARAMETERS cField
		*++
		*>>Return the Current Underlying value of the specified field.
		*--
		  RETURN THIS.cmDataAccess.CurValue(@m.cField)
		
	ENDPROC

	PROCEDURE delete		&& Delete the current record in this cursor, along with all related child records that have lDeleteWithParent set. Then move to the next non-deleted record in the cursor.
		LPARAMETERS nFlags
		*++
		*>>Delete the current record in this cursor, along with all related child records that have lDeleteWithParent set. Then move to the next non-deleted record in the cursor.
		*
		* Note that Delete() cannot be called when a transaction is already in progress, 
		* if there are any related child views, because of requeries.
		*
		*    UPDATEMASK_NOCHILDREN      4 Don't process related child cursors.
		*    UPDATEMASK_COMMIT         64 Commit operation even if not required by buffering mode.
		*--
		LOCAL lTransaction
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF THIS._ExecuteRule('BeforeDelete', RULEMASK_ANDED)
		    * If record exists only in local buffer, no physical delete is necessary for it or any children.
		    IF THIS.cmDataAccess.IsNew()
		      * Note that this will trigger AfterDelete() rule for new buffered records.
		      RETURN THIS.RevertRecord()
		    ELSE
		      * Get rid of any changes in the update buffer in this or related child cursors.
		      * This must be done before a transaction is started. VFP does not allow 
		      * TABLEREVERT() for table buffered cursors while a transaction is active.
		      IF THIS.IsRecordChanged()
		        THIS.RevertRecord(UPDATEMASK_NOUNLOCK)
		      ENDIF
		
		      * If this cursor is row buffered, we need to start a transaction. Even if there are no 
		      * children, transaction may still be needed for remote views with manual xaction set.
		      * Remember that any parent cursor with related child views is treated as row buffered.
		      IF THIS.GetBufferMode() <= 3 AND NOT ISNULL(THIS.oConnMan)
		        m.lTransaction = THIS.oConnMan.BeginTrans(THIS.nConnID)
		      ENDIF
		
		      IF THIS.DeleteRecord(m.nFlags)
		        * Call AfterDelete event now to apply custom developer rule code.
		        THIS._ExecuteRule('AfterDelete', RULEMASK_ANDED)
		
		        * We must move off the deleted record before commiting any transaction started by the UPDATE().
		        * Otherwise, a VFP6 bug can cause records in remote views to be filled with CHR(0) characters.
		        * Use the low-level access mehtod to move, so row validation and child requery are not done now.
		        THIS.cmDataAccess.Skip(1)
		
		        IF m.lTransaction        && End our transaction if we started one
		          THIS.oConnMan.CommitTrans()
		        ENDIF
		
		        * Take care of child recordset selection now that any transaction is Committed.
		        THIS.RecordWasMoved()
		
		        * Remove the row from any registered navigation controls as well.
		        * Nav controls for any children will be rebuilt with new child recordsets.
		        IF NOT ISNULL(THIS.oDM)
		          THIS.oDM.UpdateNavControls('Delete', THIS.cWorkarea)
		        ENDIF
		        RETURN .T.
		      ENDIF
		
		      * Roll back transaction on failure.
		      IF m.lTransaction
		       THIS.oConnMan.RollBackTrans()
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE deleterecord		&& Low level method to Delete a record and its related children. Commits if cursor is row-buffered.
		LPARAMETERS nFlags
		*++
		*>>Low level method to Delete a record and its related children. Commits if cursor is row-buffered.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN     4  Don't process related child cursors.
		*    UPDATEMASK_COMMIT        64  Commit operation even if not required by buffering mode.
		*--
		LOCAL oChild, cKey, lTableBuffered
		
		    m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		    * Call BeforeDeleteRecord rule before deleting each record.
		    IF NOT THIS._ExecuteRule('BeforeDeleteRecord', RULEMASK_ANDED)
		      RETURN .F.
		    ENDIF
		
		    * Set table-buffered flag if cursor is table-buffred, and UPDATEMASK_COMMIT is not set.
		    m.lTableBuffered = (THIS.GetBufferMode() > 3 AND EMPTY(BITAND(m.nFlags, UPDATEMASK_COMMIT)))
		
		    * Delete any related child records first, if the child's lDeleteWithParent property is set.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      FOR EACH oChild IN THIS.aChildren
		        IF NOT ISNULL(m.oChild) AND m.oChild.lDeleteWithParent
		          * For 1-1 relations, use DeleteRecord() so we get the before/after events.
		          IF UPPER(m.oChild.cForeignKeyField) == UPPER(m.oChild.cPrimaryKeyField)
		            IF NOT m.oChild.DeleteRecord(m.nFlags)
		              RETURN .F.
		            ENDIF
		          ELSE
		            * For native tables, DeleteWhere() will call back to DeleteRecord() for each record.
		            * For views (including SQLPT & CA) deletes will go directly against the server, so
		            * no additional Before/After events will be triggered for this child or its children.
		            m.cKey = THIS.FieldValue(m.oChild.cParentKeyField)
		            m.cKey = IIF(VARTYPE(m.cKey, .T.) = 'C', "'" + m.cKey + "'", LTRIM(STR(m.cKey, 16)) )
		            IF NOT m.oChild.DeleteWhere(m.oChild.cForeignKeyField + ' = ' + m.cKey, ;
		                                        BITOR(m.nFlags, IIF(NOT m.lTableBuffered, UPDATEMASK_COMMIT, 0)))
		              RETURN .F.
		            ENDIF
		          ENDIF
		        ENDIF
		      ENDFOR
		    ENDIF
		
		    * Join current local transaction, if there is one, unless delete is being committed right away.
		    IF m.lTableBuffered AND EMPTY(BITAND(m.nFlags, UPDATEMASK_COMMIT))
		      THIS._LTJoin()
		    ENDIF
		
		    * Delete this record and return completion status.
		    IF THIS.cmDataAccess.Delete()  && Mark local cursor record for deletion
		      * Call AfterDeleteRecord rule after delete, but before deletion is committed.
		      THIS._ExecuteRule('AfterDeleteRecord', RULEMASK_ANDED)
		
		      * If Row buffering, Commit this record now. This also leaves it unlocked in pessimistic modes.
		      RETURN m.lTableBuffered OR THIS.AccessUpdateRecord()
		    ENDIF
		    RETURN .F.
		
	ENDPROC

	PROCEDURE deletewhere		&& Delete records matching the specified Where expression. For views, records are deleted via direct commands to the server database.
		LPARAMETERS cWhereExpression, nFlags
		*++
		*>>Delete records matching the specified Where expression. For views, records are deleted via direct commands to the server database.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN     4  Don't process related child cursors.
		*    UPDATEMASK_COMMIT        64  Commit operation even if not required by buffering mode.
		*--
		  * For a native table, this will make callbacks to the cursor.DeleteRecord() method.
		  * For views, deletes will be issued directly against the source (server) tables.
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  RETURN THIS.cmDataAccess.DeleteWhere(m.cWhereExpression, m.nFlags)
		
	ENDPROC

	PROCEDURE Destroy
		*++
		*>>Close the cursor when we are released, if lAutoClose is true.
		*--
		  IF THIS.lAutoClose
		    THIS.Close()
		  ENDIF
		  THIS.ClearRules()
		  RETURN .T.
		
	ENDPROC

	PROCEDURE edit		&& Edit the current record interactively, by triggering the EditRule() event.
		*++
		*>>Edit the current record interactively, by triggering the EditRule() event.
		*--
		  RETURN THIS._ExecuteRule('EditRule', RULEMASK_ANDED)
		
	ENDPROC

	PROCEDURE enumchildren		&& Enumerate the related child cursors of this cursor.
		LPARAMETERS nIndex, oCursor
		*++
		*>>Enumerate the related child cursors of this cursor.
		*--
		LOCAL nStart
		
		  m.nStart = IIF(EMPTY(m.nIndex) OR m.nIndex < 0, 1, m.nIndex + 1)
		  FOR nIndex = m.nStart TO THIS.nChildren
		    IF NOT ISNULL(THIS.aChildren[m.nIndex])
		      m.oCursor = THIS.aChildren[m.nIndex]
		      RETURN m.nIndex
		    ENDIF
		  ENDFOR
		
		  * Reached the end of the cursor collection.
		  m.nIndex = -1
		  m.oCursor = .NULL.
		  RETURN m.nIndex
		
	ENDPROC

	PROCEDURE execute		&& Execute an SQL command on the current connection to a remote database. Applies only to cursors based on remote data sources.
		LPARAMETERS cSql, cResultCursor
		*++
		*>>Execute an SQL command on the current connection to a remote database. Applies only to cursors based on remote data sources.
		*--
		  IF NOT EMPTY(THIS.nConnID) AND NOT ISNULL(THIS.oConnMan)
		    RETURN THIS.oConnMan.Execute(THIS.nConnID, @m.cSql, m.cResultCursor)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE export		&& Custom code to Export data from this cursor.
		*++
		*>>Custom code to Export data from this cursor.
		*--
		  * Developer custom code here.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE fieldtype		&& Return the data type of the specified field. Length and Decimal places are returned in the 2 optional output parameters.
		LPARAMETERS cField, nLength, nDecimals
		*++
		*>>Return the data type of the specified field. Length and Decimal places are returned in the 2 optional output parameters.
		*--
		  IF PCOUNT() = 1
		    RETURN THIS.cmDataAccess.FieldType(@m.cField)
		  ENDIF
		  RETURN THIS.cmDataAccess.FieldType(@m.cField, @m.nLength, @m.nDecimals)
		
	ENDPROC

	PROCEDURE fieldvalue		&& Return the current local buffered value of the specified field.
		LPARAMETERS cField
		*++
		*>>Return the current local buffered value of the specified field.
		*--
		  RETURN THIS.cmDataAccess.FieldValue(@m.cField)
		
	ENDPROC

	PROCEDURE find		&& Find the first record in the cursor that matches the specified expression. If lContinue parameter is .T. the search begins with the current record.
		LPARAMETERS eFor, lContinue
		*++
		*>>Find the first record in the cursor that matches the specified expression. If lContinue parameter is .T. the search begins with the current record.
		*--
		  IF THIS.RecordReadyToMove()
		    IF THIS.cmDataAccess.Find(@m.eFor, m.lContinue)
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE getbuffermode		&& Return the buffering mode for this cursor as a numeric code. The return values match those of the VFP CURSORGETPROP("Buffering") function.
		*++
		*>>Return the buffering mode for this cursor as a numeric code. The return values match those of the VFP CURSORGETPROP("Buffering") function.
		*--
		LOCAL nBufferMode, oChild
		  m.nBufferMode = THIS.cmDataAccess.GetBufferMode()
		
		  IF m.nBufferMode >= 4 
		    * If lUpdateOnRowchange is set, we treat the cursor as if it were row-buffered.
		    IF THIS.lUpdateOnRowchange
		      RETURN (m.nBufferMode - 2)
		    ENDIF
		
		    * If this is a table buffered cursor, with any updatable child views, we need to treat it 
		    * as if it were row buffered, since child view recordsets are requeried whenever parent moves.
		    IF THIS.nChildren > 0
		      FOR EACH oChild IN THIS.aChildren
		        WITH m.oChild
		          * Views & SQLPT may be non-updateable (lReadonly = .T.) even if the cursor is physically writable.
		          IF .lRequeryWhenParentMoves AND .cmDataAccess.lSelectByRequery ;
		          AND NOT (.lReadOnly OR .cmDataAccess.IsReadOnly())
		            RETURN (m.nBufferMode - 2)
		          ENDIF
		        ENDWITH
		      ENDFOR
		    ENDIF
		  ENDIF
		  RETURN m.nBufferMode
		
	ENDPROC

	PROCEDURE getchildren		&& Return a comma separated list of all child workareas related to this cursor.
		LPARAMETERS lGrandChildren
		*++
		*>>Return a comma separated list of all child workareas related to this cursor.
		*--
		LOCAL ix, cChildren, cGrandChildren
		  m.cChildren = ''
		  FOR ix = 1 TO THIS.nChildren
		    IF NOT ISNULL(THIS.aChildren[m.ix])
		      m.cChildren = m.cChildren + IIF(EMPTY(m.cChildren), '', ',') + PROPER(THIS.aChildren[m.ix].cWorkarea)
		      IF m.lGrandChildren
		        m.cGrandChildren = THIS.aChildren[m.ix].GetChildren(m.lGrandChildren)
		        IF NOT EMPTY(m.cGrandChildren)
		          m.cChildren = m.cChildren + ',' + m.cGrandChildren
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDFOR
		  RETURN m.cChildren
		
	ENDPROC

	PROCEDURE getfilter		&& Return the current record filter expression for the cursor.
		*++
		*>>Return the current record filter expression for the cursor.
		*--
		  RETURN THIS.cmDataAccess.GetFilter()
		
	ENDPROC

	PROCEDURE getorder		&& Return the current sort order of the cursor.
		*++
		*>>Return the current sort order of the cursor.
		*--
		  RETURN THIS.cmDataAccess.GetOrder()
		
	ENDPROC

	PROCEDURE getparent		&& Return the relational parent alias (or empty string).
		*++
		*>>Return the relational parent alias (or empty string).
		*--
		  RETURN IIF(ISNULL(THIS.oParent), '', THIS.oParent.cWorkarea)
		
	ENDPROC

	PROCEDURE getposition		&& Return the current record position - by record number for tables, or PK value for views/SQLPT.
		*++
		*>>Return the current record position - by record number for tables, or PK value for views/SQLPT.
		*--
		  RETURN THIS.cmDataAccess.GetPosition()
		
	ENDPROC

	PROCEDURE getprop		&& Return various property settings about the cursor.
		LPARAMETERS cProperty
		*++
		*>>Return various property settings about the cursor.
		*--
		  RETURN THIS.cmDataAccess.GetProp(@m.cProperty)
		
	ENDPROC

	PROCEDURE gobottom		&& Go to the last record in the cursor
		LPARAMETERS lEof
		*++
		*>>Go to the last record in the cursor
		*--
		  IF THIS.RecordReadyToMove()
		    IF THIS.cmDataAccess.GoBottom(m.lEof)
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE goto		&& Go to the specified record number in the cursor
		LPARAMETERS nRecno
		*++
		*>>Go to the specified record number in the cursor
		*--
		  IF THIS.RecordReadyToMove()
		    IF THIS.cmDataAccess.Goto(@m.nRecno)
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE gotop		&& Go to the first record in the cursor
		*++
		*>>Go to the first record in the cursor
		*--
		  IF THIS.RecordReadyToMove()
		    IF THIS.cmDataAccess.GoTop()
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE import		&& Custom code to Import data into this cursor.
		*++
		*>>Custom code to Import data into this cursor.
		*--
		  * Developer custom code here.
		  RETURN .T.
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS cFile, cWorkarea, cFlags
		*++
		* Codemine cursor definition class.
		* Copyright 2000-2003 Soft Classics Ltd. All Rights Reserved Worldwide.
		*
		* cFlags = "EXCLUSIVE", "READONLY", "NODATA", "SQLPT", "LSQLPT"
		*--
		LOCAL oRule
		
		    * VFP has screen update bugs that try to draw a blank square in the shape of this container,
		    * Even though it is not part of _SCREEN and is not Visible. Moving position above top seems 
		    * to avoid the problem.
		    THIS.Top = -1000
		
		    * Create runtime internal-use-only properties now. These are not available at design time.
		    THIS.AddProperty('oCDE', .NULL.)           && Runtime link to CDE object, or NULL if no CDE.
		    THIS.AddProperty('oParent', .NULL.)        && Runtime link to relational parent cursor.
		    THIS.AddProperty('oDM', .NULL.)            && Runtime link to data manager object, or NULL if no DM.
		    THIS.AddProperty('nCursorFlags', 0)        && Internal cursor state flags.
		    THIS.AddProperty('lRowReadOnly', .NULL.)   && If true, current record is read-only.
		    THIS.AddProperty('nOldRecord', 0)          && Restore record pointer here on revert of a newly appended record.
		    THIS.AddProperty('uCurrentKey', .NULL.)    && Current parent key value, for optimizing child requeries.
		    THIS.AddProperty('nChildren', 0)           && Number of related children
		    THIS.AddProperty('aChildren[1]', .NULL.)   && Related children collection
		    THIS.AddProperty('nRuleCount', 0)          && Number of linked rule objects
		    THIS.AddProperty('aRules[1]', .NULL.)      && Linked rule collection
		    THIS.AddProperty('nConnID', 0)             && Connection Manager connection ID for remote data sources
		
		    DODEFAULT()
		
		    THIS.cWorkarea = PROPER(THIS.cWorkarea)
		
		    * Register any rule classes that exist in our container.
		    FOR EACH oRule IN THIS.Controls
		      IF m.oRule.Baseclass == 'Container' AND m.oRule.cClass = 'cmRule'
		        THIS.AddRule(m.oRule)
		      ENDIF
		    ENDFOR
		
		    * If either optional parameter is specified, try to open right away.
		    IF NOT EMPTY(m.cFile)
		      THIS.lAutoOpen = .T.
		
		      * If an explicit path is specified (DBC path or free table path), don't translate it via GetFilePath().
		      IF NOT EMPTY(JUSTPATH(LEFT(m.cFile,255)))  && Should only get here if it is a filename
		        THIS.lUseRuntimePath = .F.
		      ENDIF
		
		      IF '!' $ m.cFile
		        THIS.cDatabase = GetToken(@m.cFile, '!')
		      ENDIF
		      THIS.cSource = m.cFile
		      IF NOT EMPTY(m.cWorkarea)
		        THIS.cWorkarea = PROPER(m.cWorkarea)
		      ENDIF
		
		      * Process optional OPEN modifiers
		      m.cFlags = IIF(EMPTY(m.cFlags), '', UPPER(m.cFlags))
		      IF 'EXCLUSIVE' $ m.cFlags
		        THIS.lExclusive = .T.
		      ENDIF
		      IF 'READONLY' $ m.cFlags OR 'NOUPDATE' $ m.cFlags
		        THIS.lReadonly = .T.
		      ENDIF
		      IF 'NODATA' $ m.cFlags
		        THIS.lNoDataOnLoad = .T.
		      ENDIF
		      IF 'LSQLPT' $ m.cFlags
		        THIS.cType = 'LSQLPT'
		      ENDIF
		      IF 'SQLPT' $ m.cFlags
		        THIS.cType = 'SQLPT'
		      ENDIF
		
		      * Open the data source now if we got a source from the init parameters.
		      IF NOT EMPTY(THIS.cSource)
		        * On open failure, we still return success so object will be created. Use IsOpen()
		        * to test for successful open of cursor after passing Init() parameters. Leaving
		        * the cursor created on failure allows for easy testing of open status, and also allows
		        * changing of property values to retry the open with different paths/options.
		        THIS.Open()
		      ENDIF
		    ENDIF
		    RETURN .T.
		
	ENDPROC

	PROCEDURE isbottom		&& Return the "Bottom" state of the current record in the cursor.
		*++
		*>>Return the "Bottom" state of the current record in the cursor.
		*--
		  * We can't use an access methos directly on the property, because it is added at runtime
		  IF BITTEST(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)
		    THIS.SetPositionFlags()
		  ENDIF
		  RETURN BITTEST(THIS.nCursorFlags, CURSORFLAG_BOTTOM)
		
	ENDPROC

	PROCEDURE ischanged		&& Returns true if any record in this cursor contains uncommited changes, or (optionally) any child record is changed.
		LPARAMETERS nFlags
		*++
		*>>Returns true if any record in this cursor contains uncommited changes, or (optionally) any child record is changed.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN     4  Do not consider records in child cursors.
		*    UPDATEMASK_OBEY_SETKEY     8  For Table-buffered child tables, obey SET KEY restrictions
		*--
		LOCAL oChild
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		    IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		      IF THIS.cmDataAccess.IsChanged()
		        RETURN .T.
		      ENDIF
		    ENDIF
		
		    * Now test related child cursors, if caller wants to include them.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      FOR EACH oChild IN THIS.aChildren
		        IF NOT ISNULL(m.oChild) AND m.oChild.IsChanged(m.nFlags)
		          RETURN .T.
		        ENDIF
		      ENDFOR
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isdeleteallowed		&& Determine whether or not records may be deleted from the specified workarea.
		*++
		*>>Determine whether or not records may be deleted from the specified workarea.
		*--
		  RETURN NOT THIS.IsReadOnly() AND NOT THIS.IsEOF() ;
		         AND THIS._ExecuteRule('IsDeleteAllowedRule', RULEMASK_ANDED)
		
	ENDPROC

	PROCEDURE isdeleted		&& Determine if the current record has been marked deleted.
		*++
		*>>Determine if the current record has been marked deleted.
		*--
		  RETURN THIS.cmDataAccess.IsDeleted()
		
	ENDPROC

	PROCEDURE iseditallowed		&& Determine if the specified field may be edited. Always returns .F. if the cursor is empty or at EOF.
		LPARAMETERS cField
		*++
		*>>Determine if the specified field may be edited. Always returns .F. if the cursor is empty or at EOF.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    RETURN NOT THIS.cmDataAccess.IsEOF() ;
		       AND THIS._ExecuteRule('IsEditAllowedRule', RULEMASK_ANDED, IIF(EMPTY(m.cField), '', m.cField))
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isempty		&& Determine whether or not the cursor has any undeleted records.
		*++
		*>>Determine whether or not the cursor has any undeleted records.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    RETURN THIS.cmDataAccess.IsEmpty()
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE iseof		&& Determine whether or not the cursor is at EOF.
		*++
		*>>Determine whether or not the cursor is at EOF.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    RETURN THIS.cmDataAccess.IsEof()
		  ENDIF
		
	ENDPROC

	PROCEDURE isexclusive		&& Return the current EXCLUSIVE use setting of the cursor. Useful for native VFP tables only.
		*++
		*>>Return the current EXCLUSIVE use setting of the cursor. Useful for native VFP tables only.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    RETURN THIS.cmDataAccess.IsExclusive()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isfield		&& Return true if the specified field name is present in this cursor
		LPARAMETERS cField
		*++
		*>>Return true if the specified field name is present in this cursor
		*--
		  RETURN THIS.cmDataAccess.IsField(SUBSTR(m.cField, RAT('.', m.cField) + 1))
		
	ENDPROC

	PROCEDURE isfieldchanged		&& Returns true if the specified field in the current record has been changed.
		LPARAMETERS cField
		*++
		*>>Returns true if the specified field in the current record has been changed.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    RETURN THIS.cmDataAccess.IsFieldChanged(SUBSTR(m.cField, RAT('.', m.cField) + 1))
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isnew		&& Determine if the current record is Newly appended.
		*++
		*>>Determine if the current record is Newly appended.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    * For unbuffered tables, the only way we can detect a "new" record is by our saved rec pointer.
		    IF THIS.cmDataAccess.GetBufferMode() = 1
		      RETURN NOT EMPTY(THIS.nOldRecord)
		    ENDIF
		    RETURN THIS.cmDataAccess.IsNew()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isnewallowed		&& Determine whether or not records may be added to the specified workarea.
		*++
		*>>Determine whether or not records may be added to the specified workarea.
		*--
		  RETURN NOT THIS.IsReadOnly() AND THIS._ExecuteRule('IsNewAllowedRule', RULEMASK_ANDED)
		
	ENDPROC

	PROCEDURE isopen		&& Determine whether or not the cursor is open.
		*++
		*>>Determine whether or not the cursor is open.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    RETURN THIS.cmDataAccess.IsOpen()
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isoverwriteallowed		&& Return .T. if it is ok to overwrite another users changes during an Update() method call.
		*++
		*>>Return .T. if it is ok to overwrite another users changes during an Update() method call.
		*--
		  * This method is not called if lOverwrite is NULL, so we only need to deal with T/F.
		  IF NOT THIS.lOverwrite AND NOT ISNULL(THIS.oMessage)
		    RETURN THIS.oMessage.Confirm('%msgDataModified', THIS.cDisplayName)
		  ENDIF
		  RETURN THIS.lOverwrite
		
	ENDPROC

	PROCEDURE isreadonly		&& Determine if the cursor is read-only.
		*++
		*>>Determine if the cursor is read-only.
		*--
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    * Use the THIS.lRowReadonly property to optimize out multiple calls on the same record.
		    IF ISNULL(THIS.lRowReadonly)
		      * If this is a child table, and the parent is at EOF() it is temporarily readonly.
		      * This means you can't add records to a child table until there is a parent record.
		      IF NOT ISNULL(THIS.oParent) AND THIS.oParent.IsEOF() AND THIS.cmDataAccess.IsEmpty()
		        RETURN .T.  && Dont set lRowReadonly in this case
		      ENDIF
		      THIS.lRowReadonly = THIS.cmDataAccess.IsReadOnly() OR THIS._ExecuteRule('IsReadOnlyRule', RULEMASK_ORED)
		    ENDIF
		    RETURN THIS.lRowReadonly
		  ENDIF
		  RETURN .T.    && Readonly if no access object (usually means not opened)
		
	ENDPROC

	PROCEDURE isrecordchanged		&& Returns true if the current record contains uncommited changes, or (optionally) any child record is changed.
		LPARAMETERS nFlags
		*++
		*>>Returns true if the current record contains uncommited changes, or (optionally) any child record is changed.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN     4  Do not consider records in child cursors.
		*--
		LOCAL oChild
		  IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		    m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		    IF THIS.cmDataAccess.IsRecordChanged()
		      RETURN .T.
		    ENDIF
		
		    * Now test related child cursors, if caller wants to include them.
		    IF THIS.nChildren > 0 AND EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      FOR EACH oChild IN THIS.aChildren
		        IF NOT ISNULL(m.oChild) AND m.oChild.IsChanged(BITOR(m.nFlags, UPDATEMASK_OBEY_SETKEY))
		          RETURN .T.
		        ENDIF
		      ENDFOR
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE isrequired		&& Returns true if the specified field is required - ie cannot be left empty when edited.
		LPARAMETERS cField
		*++
		*>>Returns true if the specified field is required - ie cannot be left empty when edited.
		*--
		  m.cField = SUBSTR(m.cField, RAT('.', m.cField) + 1)  && Strip off alias name if present.
		  RETURN THIS._ExecuteRule('IsRequiredRule', RULEMASK_ORED, @m.cField)
		
	ENDPROC

	PROCEDURE istop		&& Return the "Top" state of the current record in the cursor.
		*++
		*>>Return the "Top" state of the current record in the cursor.
		*--
		  * We can't use an access methos directly on the property, because it is added at runtime
		  IF BITTEST(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)
		    THIS.SetPositionFlags()
		  ENDIF
		  RETURN BITTEST(THIS.nCursorFlags, CURSORFLAG_TOP)
		
	ENDPROC

	PROCEDURE ldeletewithparent_access		&& lDeleteWithParent should always return False if lRequeryWhenParentMoves is False.
		*++
		*>>lDeleteWithParent should always return False if lRequeryWhenParentMoves is False.
		*--
		  RETURN IIF(THIS.lRequeryWhenParentMoves, THIS.lDeleteWithParent, .F.)
		
	ENDPROC

	PROCEDURE loaddataaccess		&& Create the data access object for the cursor, based on cursor type.
		LPARAMETERS cType
		*++
		*>>Create the data access object for the cursor, based on cursor type.
		*--
		  THIS.cType = IIF(EMPTY(m.cType), PROPER(ALLTRIM(THIS.cType)), PROPER(ALLTRIM(m.cType)))
		  ASSERT NOT EMPTY(THIS.cType) MESSAGE 'cType property cannot be empty for ' + THIS.cDisplayName
		
		  IF NOT PEMSTATUS(THIS, 'cmDataAccess', 5)
		    DO CASE
		      CASE NOT EMPTY(THIS.cDataAccessClass)
		        THIS.AddNewObject('cmDataAccess', THIS.cDataAccessClass)
		      CASE THIS.cType == 'Lview'
		        THIS.AddNewObject('cmDataAccess', 'cmDataAccessLocalView')
		      CASE THIS.cType == 'Rview'
		        THIS.AddNewObject('cmDataAccess', 'cmDataAccessRemoteView')
		      OTHERWISE   && Build default data access class name to use from cursor type property
		        THIS.AddNewObject('cmDataAccess', 'cmDataAccess' + THIS.cType)
		    ENDCASE
		    IF NOT PEMSTATUS(THIS, 'cmDataAccess', 5)
		      RETURN .F.
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE localtransbegin		&& Begin a new local transaction level for the cursor (or CDE if we are contained in a CDE).
		*++
		*>>Begin a new local transaction level for the cursor (or CDE if we are contained in a CDE).
		*--
		  THIS.nLocalTransLevel = THIS.nLocalTransLevel + 1
		
	ENDPROC

	PROCEDURE localtranscommit		&& Commit and close the current local transaction level.
		*++
		*>>Commit and close the current local transaction level.
		*--
		  IF THIS.nLocalTransLevel > 0
		    THIS._LTCommit(THIS.nLocalTransLevel)
		    THIS.nLocalTransLevel = THIS.nLocalTransLevel - 1
		  ENDIF
		
	ENDPROC

	PROCEDURE localtransrollback		&& Commit and close the current local transaction level.
		*++
		*>>Commit and close the current local transaction level.
		*--
		  IF THIS.nLocalTransLevel > 0
		    THIS._LTRollBack(THIS.nLocalTransLevel)
		    THIS.nLocalTransLevel = THIS.nLocalTransLevel - 1
		  ENDIF
		
	ENDPROC

	PROCEDURE lockforedit		&& Obtain whatever locks are necessary before allowing a change to the current record.
		*++
		*>>Obtain whatever locks are necessary before allowing a change to the current record.
		*
		* Used by form to pre-lock pessimistic records.
		* Could be used for local locks too, if implemented.
		*--
		  * If Pessimistic buffering, and not already modified (including new), get a network lock
		  IF INLIST(THIS.cmDataAccess.GetBufferMode(), 2, 4) AND NOT THIS.cmDataAccess.IsRecordChanged()
		    IF NOT THIS.LockRecord()
		      RETURN .F.
		    ENDIF
		  ENDIF
		
		  * Join current local transaction, if there is one.
		  THIS._LTJoin()
		  RETURN .T.
		
	ENDPROC

	PROCEDURE lockrecord		&& Obtain network Lock for the current, or the specified record. Use record number 0 to lock the header.
		LPARAMETERS nRecord
		*++
		*>>Obtain network Lock for the current, or the specified record. Use record number 0 to lock the header.
		*--
		  RETURN THIS.cmDataAccess.LockRecord(m.nRecord)
		
	ENDPROC

	PROCEDURE loverwrite_access		&& For backward compatability, a global default in DataManager will override cursor setting.
		*++
		*>>For backward compatability, a global default in DataManager will override cursor setting.
		*--
		  IF NOT ISNULL(THIS.oDM) AND NOT ISNULL(THIS.oDM.lOverwrite)
		    RETURN THIS.oDM.lOverwrite
		  ENDIF
		  RETURN THIS.lOverwrite
		
	ENDPROC

	PROCEDURE lqueryremotepk_access		&& Determine if we need to query the server for the assigned PK value after saving a new record.
		*++
		*>>Determine if we need to query the server for the assigned PK value after saving a new record.
		*--
		  * A true only applies if the primary key field is not updateable. If user code does not need 
		  * to know the value of server-assigned, performance can be improved by setting to false.
		  IF THIS.lQueryRemotePK ;
		  AND (EMPTY(THIS.cPrimaryKeyField) OR THIS.cmDataAccess.IsPrimaryKeyUpdateable())
		    THIS.lQueryRemotePK = .F.
		  ENDIF
		  RETURN THIS.lQueryRemotePK
		
	ENDPROC

	PROCEDURE lrecyclerecords_access		&& For backward compatability, a global default in DataManager will override cursor setting.
		*++
		*>>For backward compatability, a global default in DataManager will override cursor setting.
		*--
		  IF NOT ISNULL(THIS.oDM) AND NOT ISNULL(THIS.oDM.lRecycleRecords)
		    RETURN THIS.oDM.lRecycleRecords
		  ENDIF
		  RETURN THIS.lRecycleRecords
		
	ENDPROC

	PROCEDURE lrequerywhenparentmoves_assign		&& Clear uCurrentKey property (used for child requery optimization) when lRequeryWhenParentMoves is changed.
		LPARAMETERS lValue
		*++
		*>>Clear uCurrentKey property (used for child requery optimization) when lRequeryWhenParentMoves is changed.
		*--
		  THIS.uCurrentKey = .NULL.
		  THIS.lRequeryWhenParentMoves = m.lValue
		
	ENDPROC

	PROCEDURE nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*++
		*>>Return the nErrorMode value from the highest level available container.
		*--
		  * Cursor object uses CDE property, if available.
		  IF NOT ISNULL(THIS.oCDE)
		    RETURN THIS.oCDE.nErrorMode
		  ENDIF
		  RETURN THIS.nErrorMode
		
	ENDPROC

	PROCEDURE nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		LPARAMETERS nValue
		*++
		*>>Set the nErrorMode property in the highest level available container.
		*--
		  * Cursor object uses CDE property, if available.
		  IF NOT ISNULL(THIS.oCDE)
		    THIS.oCDE.nErrorMode = m.nValue
		  ELSE
		    THIS.nErrorMode = m.nValue
		
		    * If no CDE and a private ConnMan, pass value directly on the ConnMan. 
		    * ConnMan has no link back to cursor, so this is the only way to keep it in sync.
		    IF NOT ISNULL(THIS.oConnMan)
		      THIS.oConnMan.nErrorMode = m.nValue
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE new		&& Add a new record to the record set.
		*++
		*>>Add a new record to the record set.
		*--
		  IF THIS.RecordReadyToMove() AND THIS._ExecuteRule('BeforeNew', RULEMASK_ANDED)
		    IF THIS.cmDataAccess.New()
		      * Add this new record to any local transaction, if one is in effect.
		      THIS._LtJoin(0, LOCALTRANS_REVERT_ON_ROLLBACK)
		
		      * Fill in the appropriate foreign key for this record, if we have a relational parent.
		      IF NOT ISNULL(THIS.oParent) AND THIS.lRequeryWhenParentMoves
		        * It is possible that a custom FK value was assigned by a DBC default rule,
		        * so only assign default FK if the FK field is still empty (or NULL).
		        IF NOT EMPTY(THIS.cForeignKeyField) ;
		        AND EMPTY(NVL(THIS.cmDataAccess.FieldValue(THIS.cForeignKeyField), ''))
		          THIS.SetForeignKey()
		        ENDIF
		      ENDIF
		      THIS._ExecuteRule('AfterNew', RULEMASK_ANDED)
		
		      * If Auto-PK and the primary key field is NULL or EMPTY at this point, we assign a value now.
		      IF THIS.lAutoPK ;
		      AND NOT EMPTY(THIS.cPrimaryKeyField) ;
		      AND THIS.cmDataAccess.IsPrimaryKeyUpdateable() ;
		      AND EMPTY(NVL(THIS.cmDataAccess.FieldValue(THIS.cPrimaryKeyField), ''))
		        THIS.SetPrimaryKey()
		      ENDIF
		
		      * Perform standard post-record-move code, including child recordset selection.
		      THIS.RecordWasMoved(THIS.nOldRecord)
		
		      * Add the new row to any registered navigation controls in the DM.
		      IF NOT ISNULL(THIS.oDM)
		        THIS.oDM.UpdateNavControls('Add', THIS.cWorkarea)
		      ENDIF
		
		      * Trigger AfterNew2() event. On failure return, we delete the new record.
		      IF THIS._ExecuteRule('AfterNew2', RULEMASK_ANDED)
		        RETURN .T.
		      ENDIF
		
		      * AfterNew2() failed - delete the record from the update buffer.
		      THIS.Delete()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE nicecursorname		&& Return a user-friendly name for this cursor, based on the cDisplayName property.
		*++
		*>>Return a user-friendly name for this cursor, based on the cDisplayName property.
		*
		* This method is provided primarily for consistency with the DM/Rule class cursor 
		* interface methods. It is the same as accessing the cDisplayName property of the 
		* cursor directly.
		*--
		  RETURN THIS.cDisplayName
		
	ENDPROC

	PROCEDURE nicefieldname		&& Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		LPARAMETERS cFieldName
		*++
		*>>Return a user-friendly name for the specified cursor field. The field name may include a workarea prefix.
		*
		* 1) If the field has %fld help key, use the name returned from that.
		* 2) If the field has a caption specified in the DBC, use that (minus any trailing colon).
		* 3) Use base field name.
		*--
		LOCAL cField, cName, cTranslated
		
		  * We need both the full field name with workarea prefix, and the field name alone.
		  m.cField = PROPER(SUBSTR(m.cFieldName, RAT('.', m.cFieldName) + 1))
		  m.cFieldName = THIS.cWorkarea + '.' + m.cField
		
		  * Look for a text string key with a localized name translation for this field.
		  IF NOT ISNULL(THIS.oMessage)
		    m.cTranslated = THIS.oMessage.TranslateString('%fld' + m.cField)
		    IF LEFT(m.cTranslated, 1) != '%'
		      m.cName = m.cTranslated
		    ENDIF
		  ENDIF
		
		  IF EMPTY(m.cName)
		    * Look for a caption in the DBC, if there is one.
		    m.cName = DBGetFieldProp(m.cFieldName, 'Caption')
		    IF NOT EMPTY(m.cName)   && May be .F. if no DBC is available
		      m.cName = TRIM(m.cName)
		      IF RIGHT(m.cName, 1) = ':'
		        m.cName = LEFT(m.cName, LEN(m.cName) - 1)
		      ENDIF
		    ENDIF
		  ENDIF
		
		  IF EMPTY(m.cName)
		    m.cName = m.cField
		  ENDIF
		  RETURN m.cName
		
	ENDPROC

	PROCEDURE nlocaltranslevel_access		&& Use the local transaction level of our CDE first. If no CDE, then parent cursor. If no parent, then our own private level.
		*++
		*>>Use the local transaction level of our CDE first. If no CDE, then parent cursor. If no parent, then our own private level.
		*--
		  * If we are in a CDE, then we use the current CDE nLocalTransLevel.
		  IF NOT ISNULL(THIS.oCDE)
		    RETURN THIS.oCDE.nLocalTransLevel
		  ENDIF
		  IF NOT ISNULL(THIS.oParent)
		    RETURN THIS.oParent.nLocalTransLevel
		  ENDIF
		  RETURN THIS.nLocalTransLevel
		
	ENDPROC

	PROCEDURE nlocaltranslevel_assign		&& Use the local transaction level of our CDE first. If no CDE, then parent cursor. If no parent, then our own private level.
		LPARAMETERS nLevel
		*++
		*>>Use the local transaction level of our CDE first. If no CDE, then parent cursor. If no parent, then our own private level.
		*--
		  * If we are in a CDE, then we use the current CDE nLocalTransLevel.
		  IF NOT ISNULL(THIS.oCDE)
		    THIS.oCDE.nLocalTransLevel = m.nLevel
		  ELSE
		    IF NOT ISNULL(THIS.oParent)
		      THIS.oParent.nLocalTransLevel = m.nLevel
		    ENDIF
		  ENDIF
		  THIS.nLocalTransLevel = m.nLevel
		
	ENDPROC

	PROCEDURE oconnman_access		&& Find a reference to the connection manager object to use.
		*++
		*>>Find a reference to the connection manager object to use.
		*--
		  IF ISNULL(THIS.oConnMan)
		    IF NOT ISNULL(THIS.oCDE)
		      RETURN THIS.oCDE.oConnMan
		    ENDIF
		    * If we are contained in another cursor (part of a crosstab cursor), use parent's ConnMan ref.
		    IF TYPE('THIS.Parent.cClass') = 'C' AND LOWER(THIS.Parent.cClass) = 'cmcursor'
		      RETURN THIS.Parent.oConnMan
		    ENDIF
		  ENDIF
		  RETURN THIS.oConnMan
		
	ENDPROC

	PROCEDURE oconn_access		&& Find a reference to the connection object to use.
		*++
		*>>Find a reference to the connection object to use.
		*--
		  IF NOT EMPTY(THIS.nConnID) AND NOT ISNULL(THIS.oConnMan)
		    RETURN THIS.oConnMan._GetConn(THIS.nConnID)
		  ENDIF
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE oldvalue		&& Return the old (original) value of the specified field.
		LPARAMETERS cField
		*++
		*>>Return the old (original) value of the specified field.
		*--
		  RETURN THIS.cmDataAccess.OldValue(@m.cField)
		
	ENDPROC

	PROCEDURE open		&& Open the cursor and create the appropriate data access object.
		*++
		*>>Open the cursor and create the appropriate data access object.
		*--
		LOCAL lStatus
		
		  * If cursor is already open, we don't need to do anything.
		  IF THIS.IsOpen()
		    RETURN .T.
		  ENDIF
		
		  * Perform default path fixup before calling the BeforeOpen() rule.
		  THIS.SetPath()
		
		  * The BeforeOpen() rule can be used to add custom code for runtime file path assignment.
		  IF THIS._ExecuteRule('BeforeOpen', RULEMASK_ANDED)
		    * If both DBC and type are unspecified, see if cSource is an item in the current DBC.
		    IF EMPTY(THIS.cDatabase) AND EMPTY(THIS.cType)
		      * If the specified cSource is in the current DBC, make this the DBC we use.
		      IF NOT THIS._SetTypeFromDBC()
		        THIS.cType = 'Table'   && Table is the only thing it could be at this point
		      ENDIF
		    ENDIF
		
		    * We have a definate cType or cDatabase value at this point.
		    THIS.cType = PROPER(THIS.cType)
		    IF EMPTY(THIS.cDatabase) AND 'view' $ THIS.cType
		      * A view must be part of a dbc, so this is the only option left.
		      THIS.cDatabase = DBC()   && Empty if no current database
		    ENDIF
		
		    IF NOT EMPTY(THIS.cDatabase)
		      * Open the DBC if not already open, and make it the current DBC.
		      IF NOT THIS.OpenDatabase()
		        RETURN .F.
		      ENDIF
		
		      * If we didn't get a specific cursor type, set type based on the DBC definition of the Cursor.
		      * Any error at this point means the cursor was not found in the specified DBC, which is
		      * a fatal error because we cannot determine which access class we need to use.
		      IF EMPTY(THIS.cType) AND NOT THIS._SetTypeFromDBC()
		        * Don't use a formatted string, in case MsgMan doesnt exist yet, but include "\-" to 
		        * prevent path elements from being interpreted as directives when MsgMan does exist.
		        THIS.DisplayMessage('\-Cursor "' + THIS.cSource + '" is not in database "' + THIS.cDatabase + '"')
		        RETURN .F.
		      ENDIF
		    ENDIF
		
		    * Create the data access object for the cursor, based on cursor type.
		    IF NOT PEMSTATUS(THIS, 'cmDataAccess', 5)
		      IF NOT THIS.LoadDataAccess()
		        RETURN .F.
		      ENDIF
		    ENDIF
		
		    * Make sure workarea alias is stored as proper case, for consistent evaluation.
		    STORE PROPER(THIS.cWorkarea) TO THIS.cWorkarea, THIS.cmDataAccess.cWorkarea
		
		    * Open the recordset. Use default buffering mode of 3 if design-time setting is 1.
		    THIS.nBufferMode = IIF(THIS.nBufferMode = 1, 3, THIS.nBufferMode)
		    
		    * If this is a view (any cursor that selects its recordset via Requery), then we 
		    * also trigger an initial call the the BeforeRequery() rule event for all linked rules.
		    IF THIS.cmDataAccess.lSelectByRequery ;
		    AND NOT THIS.lNoDataOnLoad AND NOT THIS.lNoCursorOnLoad
		      THIS._ExecuteRule('BeforeRequery', RULEMASK_ANDED)
		    ENDIF
		
		    IF THIS.lAutoCreate
		      * For auto-create mode, we dont display open errors until we determine the reason.
		      THIS.SetErrorMode(ERRMASK_SILENT_ALL)
		      m.lStatus = THIS.AccessOpen()
		      THIS.SetErrorMode()  && Restore original error mode
		
		      * If open failed due to file-not-found, call the create method.
		      IF NOT m.lStatus 
		        * Test for VFP fileNotFound error code (1) if the table or view is not found.
		        * Also test for SQL Server objectNotFound (208) if the remote table is not found.
		        * Other remote data providers may have different error codes that we dont catch here.
		        IF THIS.cmDataAccess.nLastError = 1 OR THIS.cmDataAccess.nLastSqlError = 208
		          IF THIS.Create()
		            * If create succeeded, try the open again.
		            m.lStatus = THIS.AccessOpen()
		          ENDIF
		        ELSE
		          THIS.oMessage.DisplayLastMessage(,MSG_DIALOG_CONFIRM_OK, MSG_SEVERITY_WARNING)
		        ENDIF
		      ENDIF
		    ELSE
		      * No auto-create, just do one quick open attempt
		      m.lStatus = THIS.AccessOpen()
		    ENDIF
		
		    IF m.lStatus
		      * If we didn't know the DBC before opening a native table, see if it is linked to one now.
		      * If so, set the cDatabse property, and make sure the DBC is the current one.
		      IF THIS.cType == 'Table' AND EMPTY(THIS.cDatabase)
		        THIS.cDatabase = CURSORGETPROP('Database')
		        IF NOT EMPTY(THIS.cDatabase)
		          SET DATABASE TO (THIS.cDatabase)
		        ENDIF
		      ENDIF
		
		      * Execute AfterOpen() and AfterRequery() as appropriate
		      THIS._CallAfterOpen()
		
		      * If we are in a CDE and cde.OpenAll() has not finished, we let the CDE trigger
		      * the initial AfterNav() event. Otherwise, we do it ourself.
		      IF ISNULL(THIS.oCDE) OR THIS.oCDE.lCursorsOpen
		        THIS.RecordWasMoved()
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE opendatabase		&& Open the database specified in the cDatabase, if not already open, and make it the current DBC.
		*++
		*>>Open the database specified in the cDatabase, if not already open, and make it the current DBC.
		*--
		LOCAL cDbcName
		  THIS.nLastError = 0
		  IF NOT EMPTY(THIS.cDatabase)
		    * If no path is specified, remove the .dbc extension so DBUSED will recognize it.
		    m.cDbcName = IIF('\' $ THIS.cDatabase, THIS.cDatabase, STRTRAN(LOWER(THIS.cDatabase), '.dbc', ''))
		    IF DBUSED(m.cDbcName)
		      SET DATABASE TO (m.cDbcName)
		    ELSE
		      OPEN DATABASE (THIS.cDatabase) SHARED
		    ENDIF
		  ENDIF
		  RETURN EMPTY(THIS.nLastError)
		
	ENDPROC

	PROCEDURE pack		&& Pack the table, removing deleted records. Applies to native VFP tables only. cOption parameter can be empty, 'MEMO' or 'DBF'.
		LPARAMETERS cOption
		*++
		*>>Pack the table, removing deleted records. Applies to native VFP tables only. cOption parameter can be empty, 'MEMO' or 'DBF'.
		*
		* This method leaves the cursor as the current VFP workarea.
		*--
		LOCAL oProgress, lWasExclusive
		
		  IF USED(THIS.cWorkarea)
		    m.lWasExclusive = THIS.cmDataAccess.IsExclusive()
		    IF m.lWasExclusive OR THIS.SetExclusive(.T.)
		      * Let VFP display progress in a WAIT WINDOW message
		      m.oProgress = CreateNewObject('cmEnableTalkProgress')
		      THIS.cmDataAccess.Pack(m.cOption)
		      THIS.SetExclusive(m.lWasExclusive)
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE parentkeychanged		&& Update the FK for all our records related to current parent recored, after the parent's PK was changed. Normally called by parent's PrimaryKeyChanged() method.
		*++
		*>>Update the FK for all our records related to current parent recored, after the parent's PK was changed. Normally called by parent's PrimaryKeyChanged() method.
		*--
		  RETURN THIS.cmDataAccess.ParentKeyChanged()
		
	ENDPROC

	PROCEDURE parentritest		&& Enforce parent RI before an update, by ensuring a new child record will not be written without a parent.
		*++
		*>>Enforce parent RI before an update, by ensuring a new child record will not be written without a parent.
		*--
		  * If our parent is a new record (only exists in update buffer), we cannot save child.
		  IF NOT ISNULL(THIS.oParent) AND THIS.oParent.IsNew()
		    THIS.DisplayMessage('%msgSaveParentFirst', THIS.oParent.cDisplayname, THIS.cDisplayname)
		    RETURN .F.
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE primarykeychanged		&& Reset child foriegn keys in table-buffered children, after our primary key has been changed. Applies to native VFP parent tables only.
		*++
		*>>Reset child foriegn keys in table-buffered children, after our primary key has been changed. Applies to native VFP parent tables only.
		*--
		  * Parent Must be a VFP table. Children must be table-buffered.
		  RETURN THIS.cmDataAccess.PrimaryKeyChanged()
		
	ENDPROC

	PROCEDURE queueuirefresh		&& Call the Data Manager to queue a refresh for UI controls bound to the specified field in this cursor.
		LPARAMETERS cFieldWithAlias
		*++
		*>>Call the Data Manager to queue a refresh for UI controls bound to the specified field in this cursor.
		*
		* If this cursor is managed by a form data manager, and the field is displayed in 
		* a bound control on the form, tell the data manager that the conrol needs refreshing.
		*--
		  IF NOT ISNULL(THIS.oDM)
		    THIS.oDM.QueueUIRefresh(@m.cFieldWithAlias)
		  ENDIF
		
	ENDPROC

	PROCEDURE reccount		&& Return the total number of records in the cursor
		*++
		*>>Return the total number of records in the cursor
		*--
		  RETURN THIS.cmDataAccess.RecCount()
		
	ENDPROC

	PROCEDURE recno		&& Return the current record number, or 0 if there is no current record (EOF).
		*++
		*>>Return the current record number, or 0 if there is no current record (EOF).
		*--
		  RETURN THIS.cmDataAccess.Recno()
		
	ENDPROC

	PROCEDURE recordreadytomove		&& Internal method called before record pointer is moved in a cursor.
		LPARAMETERS nFlags
		*++
		*>>Internal method called before record pointer is moved in a cursor.
		*
		* If the UPDATEMASK_COMMIT flag is set in nFlags, then any changes 
		* are commited, even if not normally required by the buffering mode.
		*--
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF IIF(EMPTY(BITAND(m.nFlags, UPDATEMASK_COMMIT)), THIS.IsRecordChanged(), THIS.IsChanged())
		    * If row-buffered, with outstanding changes, need to save before moving record ptr.
		    IF THIS.GetBufferMode() <= 3 OR NOT EMPTY(BITAND(m.nFlags, UPDATEMASK_COMMIT))
		      * Save this record now.
		      IF NOT THIS.Update()
		        RETURN .F.                && Commit error, record movement cannot proceed.
		      ENDIF
		    ELSE
		      * Modified row in Table-Buffered record set must pass row validation before moving.
		      IF NOT THIS.ValidateRow()
		        RETURN .F.                && Validation error, record movement cannot proceed.
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Now execute any developer-defined rules for this event.
		  RETURN THIS._ExecuteRule('BeforeNav', RULEMASK_ANDED)
		
	ENDPROC

	PROCEDURE recordwasmoved		&& Reset position flags and Re-select child recordsets after the record pointer was moved.
		LPARAMETERS nOldRecord
		*++
		*>>Reset position flags and Re-select child recordsets after the record pointer was moved.
		*--
		LOCAL oChild, uKeyValue
		  THIS.lRowReadonly = .NULL.  && Force re-evaluation of row readOnly rules by IsReadonly() method.
		  THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)  && Need to reset position flags
		
		  * Set or Clear old record pointer saved when adding a new buffered record.
		  THIS.nOldRecord = IIF(EMPTY(m.nOldRecord), 0, m.nOldRecord)
		
		  FOR EACH oChild IN THIS.aChildren
		    IF NOT ISNULL(m.oChild) AND m.oChild.lRequeryWhenParentMoves
		      m.uKeyValue = THIS.FieldValue(m.oChild.cParentKeyField)
		
		      * Check if parent record has changed, and optimize out some work if possible.
		      * If key value is NULL, it will return empty recordset, but since the uCurrentKey 
		      * value to force requery is also null, we need to test this as a special case.
		      IF ISNULL(m.oChild.uCurrentKey) OR ISNULL(m.uKeyValue) OR NOT m.oChild.uCurrentKey == m.uKeyValue
		         m.oChild.uCurrentKey = m.uKeyValue
		         m.oChild.Select(@m.uKeyValue)
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  * Now execute any developer-defined rules for this event.
		  THIS._ExecuteRule('AfterNav', RULEMASK_ANDED)
		  RETURN .T.
		
	ENDPROC

	PROCEDURE refreshdata		&& Refresh data in the current record of the cursor.
		*++
		*>>Refresh data in the current record of the cursor.
		*--
		  * If there are any outstanding changes, we must save them before executing the refresh.
		  * In most cases, UI should prevent a refresh call if there are outstanding changes anyway.
		  IF THIS.RecordReadyToMove()
		    IF THIS.cmDataAccess.RefreshData()
		      THIS.RecordWasMoved()
		      RETURN .T.
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE reindex		&& Regenerate all existing indexes. Applies to native VFP tables only.
		*++
		*>>Regenerate all existing indexes. Applies to native VFP tables only.
		*
		* This method leaves the cursor as the current VFP workarea.
		*--
		LOCAL oProgress, lWasExclusive
		
		  IF USED(THIS.cWorkarea)
		    m.lWasExclusive = THIS.cmDataAccess.IsExclusive()
		    IF m.lWasExclusive OR THIS.SetExclusive(.T.)
		      * Let VFP display progress in a WAIT WINDOW message
		      m.oProgress = CreateNewObject('cmEnableTalkProgress')
		      THIS.cmDataAccess.Reindex()
		      THIS.SetExclusive(m.lWasExclusive)
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE removechild		&& Remove the specified cursor from our collection of related children.
		LPARAMETERS cWorkarea
		*++
		*>>Remove the specified cursor from our collection of related children.
		*--
		LOCAL ix, oChild
		  FOR ix = 1 TO THIS.nChildren
		    m.oChild = THIS.aChildren[m.ix]
		    IF NOT ISNULL(m.oChild) AND PROPER(m.oChild.cWorkarea) == PROPER(m.cWorkarea)
		      m.oChild.oParent = .NULL.
		
		      * Remove the reference from our collection of children.
		      =ADEL(THIS.aChildren, m.ix)
		      THIS.nChildren = THIS.nChildren - 1
		      IF THIS.nChildren > 0
		        DIMENSION THIS.aChildren[THIS.nChildren]
		      ELSE
		        THIS.aChildren[1] = .NULL.
		      ENDIF
		
		      * Remove physical VFP relation if appropriate for the cursor type.
		      m.oChild.cmDataAccess.SetRelation(THIS)  && Omit expression to clear any relation
		      RETURN .T.
		    ENDIF
		  ENDFOR
		  RETURN .F.
		
	ENDPROC

	PROCEDURE removerule		&& Remove the specified rule from our collection of linked rules.
		LPARAMETERS cRulename, lClosing
		*++
		*>>Remove the specified rule from our collection of linked rules.
		*--
		LOCAL ix, oRule, lStatus
		  FOR ix = THIS.nRuleCount TO 1 STEP -1   && Backwards because array may shrink during loop.
		    m.oRule = THIS.aRules[m.ix]
		    * Note that this requires that the rule being removed is uniquely named.
		    * If more than one rule has the same name (ie a DM rule and a CDE rule could have the same name)
		    * We generate a warning, and remove all matching rules.
		    IF NOT ISNULL(m.oRule) AND PROPER(m.oRule.Name) == PROPER(m.cRulename)
		      WITH m.oRule
		        * Call the BeforeClose() event if this is a DM rule being unlinked as part of a form close.
		        IF m.lClosing AND THIS.IsOpen()
		          .oThisCursor = THIS
		          .BeforeClose(THIS.cWorkarea)
		          .oThisCursor = .NULL.
		        ENDIF
		
		        * Call the rule BeforeUnLinked() event in case rule needs to clean up anything
		        .BeforeUnLinked(THIS)
		      ENDWITH
		
		      * Remove the reference from our collection of rules.
		      THIS.nRuleCount = THIS.nRuleCount - 1
		      IF THIS.nRuleCount > 0
		        =ADEL(THIS.aRules, m.ix)
		        DIMENSION THIS.aRules[THIS.nRuleCount]
		      ELSE
		        THIS.aRules[1] = .NULL.
		      ENDIF
		      ASSERT NOT m.lStatus MESSAGE THIS.name + ' More than one rule has the name ' + m.cRuleName
		      m.lStatus = .T.
		    ENDIF
		  ENDFOR
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE replace		&& Replace the contents of the specified field with the specified value.
		LPARAMETERS cField, uValue, lRefresh
		*++
		*>>Replace the contents of the specified field with the specified value.
		*--
		LOCAL uOriginal, cFieldOnly
		  * Save original value in case we need to fall back.
		  m.cFieldOnly = SUBSTR(m.cField, RAT('.', m.cField) + 1)
		  m.uOriginal = THIS.cmDataAccess.FieldValue(m.cFieldOnly)
		
		  IF THIS.LockForEdit() ;
		  AND NOT EMPTY(THIS._ExecuteRule('FieldValid', RULEMASK_ANDED, @m.cFieldOnly, @m.uValue)) ;
		  AND THIS.cmDataAccess.Replace(@m.cFieldOnly, @m.uValue)
		    IF NOT THIS._ExecuteRule('AfterChange', RULEMASK_ANDED, @m.cFieldOnly)
		      * If the AfterChange() event fails, it has the same effect as a rule violation.
		      * This allows cascading reverts if the AfterChange() code calls .Replace() for
		      * another field that fails its FieldValid() or DBC field rule.
		      THIS.cmDataAccess.Replace(@m.cFieldOnly, @m.uOriginal)
		      RETURN .F.
		    ENDIF
		
		    * If the field is displayed in a User Interface, refresh the display.
		    THIS.QueueUIRefresh(THIS.cWorkarea + '.' + m.cFieldOnly)
		    IF m.lRefresh AND NOT ISNULL(THIS.oDM)
		      THIS.oDM.RefreshUI()
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE requery		&& Requery the view.
		LPARAMETERS luValue1, luValue2, luValue3, luValue4
		*++
		*>>Requery the view.
		* All parameter variables for parameterized views should be defined as PRIVATE
		* before calling this method, so they will be in scope to the REQUERY() call.
		*--
		* Use full prefix with explicit "l" on these names, to avoid conflicts with view param names.
		LOCAL lnPcount, lcParam, lcParamlist, leParamVal, lcVar, lcType
		
		  * If there are any outstanding changes, we must save them before requery.
		  IF THIS.RecordReadyToMove(UPDATEMASK_COMMIT)
		    * Make sure all local transaction levels are closed before requeryng.
		    THIS._LtCommit(-1)
		
		    * Get view parameter list from DBC
		    m.lcParamlist = THIS.cmDataAccess.GetViewParameters()
		
		    * Define any PRIVATE view paremeter variables needed by the view, if not already defined.
		    * Values for these variables may also be set by developer code in the BeforeRequery() event.
		    m.lnPcount = 0
		    DO WHILE NOT EMPTY(m.lcParamlist)
		      m.lnPcount = m.lnPcount + 1
		      m.leParamVal = 'm.luValue' + CHR(ASC('0')+ m.lnPcount)
		
		      m.lcParam = GetToken(@m.lcParamlist, ';')
		      m.lcVar = GetToken(@m.lcParam, ',')
		      m.lcType = STRTRAN(GetToken(@m.lcParam, ','), "'", '')  && Strip off single quotes
		
		      * If view variable is undefined, or defined as wrong type, define as correct type.
		      IF TYPE(m.lcVar) != m.lcType
		        PRIVATE &lcVar
		        * If a parameter was not specified, use the most recently specified value as default.
		        IF PEMSTATUS(THIS, 'uParam' + STR(m.lnPcount,1), 5)
		          STORE EVALUATE('THIS.uParam' + STR(m.lnPcount,1)) TO (m.lcVar)
		        ELSE
		          DO CASE
		            CASE m.lcType = 'C'
		              STORE '' TO (m.lcVar)
		            CASE m.lcType = 'L'
		              STORE .F. TO (m.lcVar)
		            CASE m.lcType $ 'DT'
		              STORE {} TO (m.lcVar)
		            CASE m.lcType $ 'NFBIY'
		              STORE 0 TO (m.lcVar)
		          ENDCASE
		        ENDIF
		      ENDIF
		
		      * If we were passed a value of the correct type, use it to initialize the view variable
		      * Type must match exactly for logical parameter, otherwise just assume caller knows what 
		      * they are doing, and let ODBC complain if the datatypes cannot be converted.
		      IF PCOUNT() >= m.lnPcount 
		        LOCAL uValue
		        m.uValue =EVALUATE(m.leParamVal)
		        IF (VARTYPE(m.uValue) != 'L' OR VARTYPE(m.uValue) = m.lcType)
		          STORE m.uValue TO (m.lcVar)
		        ENDIF
		      ENDIF
		
		      * Store the parameter value as a default for next tiem around.
		      THIS.AddProperty('uParam' + STR(m.lnPcount,1), EVALUATE(m.lcVar))
		    ENDDO
		
		    IF THIS._ExecuteRule('BeforeRequery', RULEMASK_ANDED)
		      * Now call data access object to do the actual requery.
		      IF THIS.AccessRequery(@m.luValue1, @m.luValue2, @m.luValue3, @m.luValue4)
		        LOCAL ix, oChild
		
		        * Once parent is requeried, we force requery of children, clearing uCurrentKey optimization.
		        m.ix = 0
		        DO WHILE THIS.EnumChildren(@m.ix, @m.oChild) > 0
		          m.oChild.uCurrentKey = .NULL.
		        ENDDO
		
		        * This rule may be used to select a particular record in the new set.
		        THIS._ExecuteRule('AfterRequery', RULEMASK_ANDED)
		
		        * Rebuild any registered navigation controls in the DM.
		        IF NOT ISNULL(THIS.oDM)
		          THIS.oDM.UpdateNavControls('NeedRebuild', THIS.cWorkarea)
		        ENDIF
		
		        THIS.RecordWasMoved()
		        RETURN .T.
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE restoreposition		&& Restore record pointer to the last saved value if possible.
		*++
		*>>Restore record pointer to the last saved value if possible.
		*--
		LOCAL oCursor
		  * Restore our record position. If successful, restore child positions also.
		  IF THIS.cmDataAccess.RestorePosition()
		    FOR EACH oCursor IN THIS.aChildren
		      IF NOT ISNULL(m.oCursor)
		        m.oCursor.RestorePosition()
		      ENDIF
		    ENDFOR
		  ENDIF
		
	ENDPROC

	PROCEDURE revert		&& Discard all buffered changes and unlock this cursor, and all related child cursors.
		LPARAMETERS nFlags
		*++
		*>>Discard all buffered changes and unlock this cursor, and all related child cursors.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOSAVE         1    Dont save/restore record positions.
		*    UPDATEMASK_NOCHILDREN     4  Dont process related child cursors.
		*    UPDATEMASK_OBEY_SETKEY     8  For Table-buffered child tables, obey SET KEY restrictions
		*    UPDATEMASK_NOUNLOCK        16  Don't release any locks
		*    UPDATEMASK_NOEVENTS      32  Don't trigger Before/After Events
		*
		* Note that the UPDATEMASK_NOCHILDREN bit should not be set if the cursor contains 
		* buffered NEW records with any related child records, as this would result in 
		* the child records remaining with no parent.
		*--
		LOCAL oChild, lWasNew
		
		    m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOEVENTS))
		      THIS._ExecuteRule('BeforeRevert', RULEMASK_ANDED + RULEMASK_NOCALLBACK)
		    ENDIF
		
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOSAVE))
		      THIS.SavePosition()
		    ENDIF
		
		    * Close all local transaction levels in progress.
		    THIS._LtCommit(-1)
		
		    * Remember if current record was a new update-buffer-only record.
		    m.lWasNew = THIS.cmDataAccess.IsNew()
		
		    * Revert this and all related children.
		    THIS.cmDataAccess.Revert(m.nFlags)
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      FOR EACH oChild IN THIS.aChildren
		        IF NOT ISNULL(m.oChild)
		          m.oChild.Revert(BITOR(m.nFlags, UPDATEMASK_NOSAVE))
		        ENDIF
		      ENDFOR
		    ENDIF
		
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOSAVE))
		      THIS.RestorePosition()
		    ENDIF
		
		    * Queue request to Rebuild nav controls in UI after reverting changes. Only need rebuild
		    * for table-buffered cursors, or if reverting newly appended buffered records.
		    IF NOT ISNULL(THIS.oDM) AND (m.lWasNew OR THIS.GetBufferMode() > 3)
		      THIS.oDM.UpdateNavControls('NeedRebuild', THIS.cWorkarea)
		    ENDIF
		
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOEVENTS))
		      THIS._ExecuteRule('AfterRevert', RULEMASK_ANDED + RULEMASK_NOCALLBACK)
		    ENDIF
		    THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)
		    RETURN .T.
		
	ENDPROC

	PROCEDURE revertrecord		&& Discard buffered changes to the current record. If the current record is a newly appened record, the entire record is removed from the buffer, and the record pointer is restored to its previous location.
		LPARAMETERS nFlags
		*++
		*>>Discard buffered changes to the current record. If the current record is a newly appened record, the entire record is removed from the buffer, and the record pointer is restored to its previous location.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOSAVE         1    Dont save/restore record positions. Applies here only to children.
		*    UPDATEMASK_NOCHILDREN     4  Dont process related child cursors.
		*    UPDATEMASK_NOUNLOCK        16  Don't release any locks
		*    UPDATEMASK_NOEVENTS      32  Don't trigger Before/AfterRevert() Events
		*--
		LOCAL oChild, lWasNew
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  m.lWasNew = THIS.IsNew()
		
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOEVENTS))
		    THIS._ExecuteRule('BeforeRevert', RULEMASK_ANDED,, .T.)
		  ENDIF
		
		  * Join current local transaction, if there is one.
		  THIS._LtJoin(0, IIF(m.lWasNew, LOCALTRANS_NO_RECORD, 0))
		
		  * Discard changes in current (parent) record first. Important if PK in native table
		  * relation was changed - on revert, child needs to reference parent's original PK.
		  THIS.cmDataAccess.RevertRecord(m.nFlags)
		
		  * If we are reverting a buffered new record, we must discard any buffered related children too.
		  IF m.lWasNew OR EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		    m.nFlags = BITAND(m.nFlags, BITNOT(UPDATEMASK_NOCHILDREN))  && Clear nochildren bit for new records
		    FOR EACH oChild IN THIS.aChildren
		      IF NOT ISNULL(m.oChild)
		        m.oChild.Revert(BITOR(m.nFlags, UPDATEMASK_OBEY_SETKEY))
		      ENDIF
		    ENDFOR
		  ENDIF
		
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOEVENTS))
		    THIS._ExecuteRule('AfterRevert', RULEMASK_ANDED,, .T.)
		  ENDIF
		
		  * In most cases, position flags will be ok, but reset them anyway, just to be sure.
		  THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)
		
		  IF m.lWasNew
		    * Reverting a New record deletes it from the update buffer, so trigger the AfterDelete() event.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOEVENTS))
		      THIS._ExecuteRule('AfterDelete', RULEMASK_ANDED)
		    ENDIF
		
		    * We just removed a bufferd new record, so restore position to old position if available.
		    IF NOT EMPTY(THIS.nOldRecord)
		      THIS.Goto(THIS.nOldRecord)
		    ELSE
		      * We may be left at EOF or on a record not matching current FILTER()
		      * or SET KEY conditions after reverting an appended record. The Skip()
		      * in this case will move us to a valid record in the set, if there is one.
		      THIS.Skip(1)
		    ENDIF
		
		    * Remove the row from any registered navigation controls as well.
		    IF NOT ISNULL(THIS.oDM)
		      THIS.oDM.UpdateNavControls('Delete', THIS.cWorkarea)
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE saveposition		&& Save current record pointer position.
		*++
		*>>Save current record pointer position.
		*--
		LOCAL oCursor, uPosition
		  m.uPosition = THIS.cmDataAccess.SavePosition()
		  FOR EACH oCursor IN THIS.aChildren
		    IF NOT ISNULL(m.oCursor)
		      m.oCursor.SavePosition()
		    ENDIF
		  ENDFOR
		  RETURN m.uPosition
		
	ENDPROC

	PROCEDURE seek		&& Seek the record matching the specified key in the cursor
		LPARAMETERS uKey, cIndex
		*++
		*>>Seek the record matching the specified key in the cursor
		*--
		  IF THIS.RecordReadyToMove()
		    IF THIS.cmDataAccess.Seek(@m.uKey, @m.cIndex)
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE select		&& Load the recordset matching the specified key - usually a foriegn key matching the current parent record.
		LPARAMETERS uKeyValue
		*++
		*>>Load the recordset matching the specified key - usually a foriegn key matching the current parent record.
		*--
		  * If no key value specified, default to the parent key value, if any.
		  IF PCOUNT() = 0 AND NOT ISNULL(THIS.oParent)
		    m.uKeyValue = THIS.oParent.FieldValue(THIS.cParentKeyField)
		  ENDIF
		
		  * Note that BeforeNav() is not called in this case, although AfterNav() is.
		  * The caller is responisble for saving any changes before calling this method.
		  RETURN THIS.cmDataAccess.Select(m.uKeyValue)
		
	ENDPROC

	PROCEDURE setbuffermode		&& Set the buffering mode for this cursor
		LPARAMETERS nMode
		*++
		*>>Set the buffering mode for this cursor
		*
		* 0/1  Sets row and table buffering off.
		* 2  Sets pessimistic row buffering on.
		* 3  Sets optimistic row buffering on.
		* 4  Sets pessimistic table buffering on.
		* 5  Sets optimistic table buffering on.
		*--
		  RETURN THIS.cmDataAccess.SetBufferMode(m.nMode)
		
	ENDPROC

	PROCEDURE setdefault		&& Set this cursor as the curernt VFP workarea (if it is a native VFP cursor).
		*++
		*>>Set this cursor as the curernt VFP workarea (if it is a native VFP cursor).
		*--
		  RETURN THIS.cmDataAccess.SetDefault()
		
	ENDPROC

	PROCEDURE setexclusive		&& Change the EXCLUSIVE use setting of the currently open table. Useful for native VFP cursors only.
		LPARAMETERS lExclusive
		*++
		*>>Change the EXCLUSIVE use setting of the currently open table. Useful for native VFP cursors only.
		*--
		  IF USED(THIS.cWorkarea)
		    IF CURSORGETPROP('SourceType', THIS.cWorkarea) != 3 ;
		    OR (ISNULL(THIS.oParent) AND THIS.nChildren = 0)
		      * Any outstanding changes need to be validated and committed first.
		      RETURN THIS.RecordReadyToMove(UPDATEMASK_COMMIT) AND THIS.cmDataAccess.SetExclusive(m.lExclusive)
		    ENDIF
		
		    * Opening and closing table is required, which would break any native VFP relations.
		    ASSERT .F. MESSAGE 'SetExclusive() is not allowed for VFP tables in a relation'
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setfilter		&& Set the record filter expression for the cursor, and leave cursor on first matching record.
		LPARAMETERS cFilter
		*++
		*>>Set the record filter expression for the cursor, and leave cursor on first matching record.
		*--
		  THIS.cFilter = m.cFilter
		  THIS.cmDataAccess.SetFilter(@m.cFilter)
		  THIS.GoTop()
		
		  * Rebuild any registered navigation controls in the DM.
		  IF NOT ISNULL(THIS.oDM)
		    THIS.oDM.UpdateNavControls('NeedRebuild', THIS.cWorkarea)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setforeignkey		&& Set the foreign key value of child tables in a 1-1 or 1-many relation. Must be overridden for compound foreign keys.
		*++
		*>>Set the foreign key value of child tables in a 1-1 or 1-many relation. Must be overridden for compound foreign keys.
		*--
		LOCAL uKeyValue
		
		  * We need the Key field name for child (this cursor)
		  IF NOT EMPTY(THIS.cForeignKeyField)
		    * cParentKeyField property may be a simple expression, if it was derived from a 
		    * native VFP relation (expressions might be used to match the child index tag expression).
		    * In this case, we need to extract only the field name, and use that field's value. The
		    * parent key field and foriegn key field must always be the same type and size.
		    m.uKeyValue = THIS.oParent.FieldValue(THIS.cmDataAccess.ExtractFieldname(THIS.cParentKeyField))
		    RETURN THIS.Replace(THIS.cForeignKeyField, @m.uKeyValue)
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setorder		&& Set the sort order to the specified tag/field.
		LPARAMETERS cOrder, cDirection
		*++
		*>>Set the sort order to the specified tag/field.
		*--
		  THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)
		  THIS.cOrder = m.cOrder
		  THIS.cmDataAccess.SetOrder(@m.cOrder, @m.cDirection)
		
		  * Rebuild any registered navigation controls in the DM.
		  IF NOT ISNULL(THIS.oDM)
		    THIS.oDM.UpdateNavControls('NeedRebuild', THIS.cWorkarea)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setpath		&& Call application object to get correct runtime paths to data files.
		*++
		*>>Call application object to get correct runtime paths to data files.
		*--
		  IF NOT ISNULL(THIS.oApp) AND THIS.lUseRuntimePath
		    * Give custom app object code the opportunity to translate the default connection.
		    THIS.cConnection = THIS.oApp.GetConnectionString(THIS.cConnection)
		    IF NOT EMPTY(THIS.cDatabase)
		      THIS.cDatabase = THIS.oApp.GetFilePath(THIS.cDatabase)
		    ELSE
		      * Call app object for full file path, unless this is some kind of SQL statement, though
		      * most SQL statements shoudl have a DBC for the connection name string.
		      IF NOT ' ' $ TRIM(LEFT(THIS.cSource, 8))
		        THIS.cSource = THIS.oApp.GetFilePath(THIS.cSource)
		      ENDIF
		    ENDIF
		  ENDIF
		    
		
	ENDPROC

	PROCEDURE setposition		&& Set the current record position - by record number for tables, or PK value for views/SQLPT.
		LPARAMETERS uPosition
		*++
		*>>Set the current record position - by record number for tables, or PK value for views/SQLPT.
		*
		* The uPosition parameter is normally a value previously returned by the GetPosition() method.
		*--
		  RETURN THIS.cmDataAccess.SetPosition(@m.uPosition)
		
	ENDPROC

	PROCEDURE setpositionflags		&& Set the record position flags for a cursor.
		*++
		*>>Set the record position flags for a cursor.
		*
		* Supported nNavigationMode values:
		*        0 - None: flags always true - nav buttons always Disabled.
		*        1 - default: flags set per position, TRUE (no nav) on record mode New
		*        2 - Flags set per position, TRUE (no nav) on all mode New
		*        3 - Flags set per position, new state ignored
		*        4 - Flags always false - nav buttons always enabled.
		*--
		  THIS.nCursorFlags = BITCLEAR(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)
		  DO CASE
		    CASE THIS.nNavigationMode = 0
		      THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_TOP)
		      THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_BOTTOM)
		
		    CASE THIS.nNavigationMode = 4 OR (THIS.GetBufferMode() <= 3 AND THIS.cmDataAccess.IsRecordChanged())
		      * If row-buffered with unsaved changes, we cant test flags, so temporarily leave them enabled.
		      * Flags always false. Allows navigation, but no flag overhead.
		      THIS.nCursorFlags = BITCLEAR(THIS.nCursorFlags, CURSORFLAG_TOP)
		      THIS.nCursorFlags = BITCLEAR(THIS.nCursorFlags, CURSORFLAG_BOTTOM)
		
		    OTHERWISE
		      IF PEMSTATUS(THIS, 'cmDataAccess', 5)
		        DO CASE
		          CASE THIS.cmDataAccess.IsEmpty()
		            * For an empty recordset, always disable sequential navigation
		            THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_TOP)
		            THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_BOTTOM)
		            RETURN .T.
		          CASE THIS.nNavigationMode = 1
		            IF THIS.GetBufferMode() <= 3 AND THIS.cmDataAccess.IsNew()
		              THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_TOP)
		              THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_BOTTOM)
		              RETURN .T.
		            ENDIF
		          CASE THIS.nNavigationMode = 2
		            IF THIS.cmDataAccess.IsNew()
		              THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_TOP)
		              THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_BOTTOM)
		              RETURN .T.
		            ENDIF
		          CASE THIS.nNavigationMode = 3
		            * To leave navigation enabled for new records in Row-buffered mode, we can't test position,
		            * since that would cause a commit. So the best we can do is force-clear the top/bottom flags.
		            IF THIS.GetBufferMode() <= 3 AND THIS.cmDataAccess.IsNew()
		              THIS.nCursorFlags = BITCLEAR(THIS.nCursorFlags, CURSORFLAG_TOP)
		              THIS.nCursorFlags = BITCLEAR(THIS.nCursorFlags, CURSORFLAG_BOTTOM)
		              RETURN .T.
		            ENDIF
		        ENDCASE
		
		        * Default code to set the values of the top/bottom flags.
		        IF THIS.nChildren > 0
		          THIS.SavePosition()  && Necessary for VFP tables in a relation
		          THIS.cmDataAccess.SetPositionFlags()
		          THIS.RestorePosition()
		        ELSE
		          THIS.cmDataAccess.SetPositionFlags()
		        ENDIF
		      ENDIF
		      RETURN .T.
		  ENDCASE
		
	ENDPROC

	PROCEDURE setprimarykey		&& Set the primary key for the current record.
		*++
		*>>Set the primary key for the current record.
		*--
		  * Generate and set default primary key value, if none has already been set.
		  IF NOT EMPTY(THIS.cPrimaryKeyField)
		    THIS.Replace(THIS.cPrimaryKeyField, PrimaryKey(THIS.cWorkarea, THIS.cPrimaryKeyField, THIS.cPrimaryKeyCounter))
		  ENDIF
		
	ENDPROC

	PROCEDURE setprop		&& Set various properties for the cursor.
		LPARAMETERS cProperty, uValue
		*++
		*>>Set various properties for the cursor.
		*--
		  RETURN THIS.cmDataAccess.SetProp(@m.cProperty, m.uValue)
		
	ENDPROC

	PROCEDURE skip		&& Skip the specified number of records forward or backwards.
		LPARAMETERS nRecords
		*++
		*>>Skip the specified number of records forward or backwards.
		* Dont allow past EOF or BOF if possible.
		*--
		  IF THIS.RecordReadyToMove()
		    IF THIS.cmDataAccess.Skip(m.nRecords)
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE unlockall		&& Unlock all locks on all records in this cursor.
		*++
		*>>Unlock all locks on all records in this cursor.
		*--
		  RETURN THIS.cmDataAccess.UnLockRecord(-1)
		
	ENDPROC

	PROCEDURE unlockrecord		&& Release network lock on the current (or specified) record. Use record number 0 to unlock the header.
		LPARAMETERS nRecord
		*++
		*>>Release network lock on the current (or specified) record. Use record number 0 to unlock the header.
		*--
		  RETURN THIS.cmDataAccess.UnLockRecord(m.nRecord)
		
	ENDPROC

	PROCEDURE update		&& Write outstanding changes back to the source tables, after (optionally) enforcing all validation rules.
		LPARAMETERS nFlags
		*++
		*>>Write outstanding changes back to the source tables, after (optionally) enforcing all validation rules.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOSAVE         1    Don't save/restore record positions.
		*    UPDATEMASK_NOVALID         2    Don't validate first.
		*    UPDATEMASK_NOCHILDREN     4  Don't process related child cursors.
		*    UPDATEMASK_OBEY_SETKEY     8  For Table-buffered child tables, obey SET KEY restrictions
		*    UPDATEMASK_NOUNLOCK         16 Don't release any explicit locks
		*--
		LOCAL oCursor, lStatus, lTransaction
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOVALID)) AND NOT THIS.ValidateCursor(m.nFlags)
		    RETURN .F.
		  ENDIF
		  IF THIS.ParentRiTest() ;
		  AND THIS._ExecuteRule('BeforeUpdate', RULEMASK_ANDED + RULEMASK_NOCALLBACK)
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOSAVE))
		      THIS.SavePosition()
		    ENDIF
		
		    * Start a transaction if it is necessary.
		    IF NOT ISNULL(THIS.oConnMan)
		      m.lTransaction = THIS.oConnMan.BeginTrans(THIS.nConnID)
		    ENDIF
		
		    * Clear record-number changed flag. Will be set by during update by access 
		    * layer method if any record numbers are changed as a result of the update.
		    THIS.nCursorFlags = BITCLEAR(THIS.nCursorFlags, CURSORFLAG_RECNO_CHANGED)
		
		    * Commit Updates for this and all related children, stopping if a failure occurs.
		    m.lStatus = THIS.AccessUpdate(m.nFlags)
		    IF m.lStatus AND EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      FOR EACH oCursor IN THIS.aChildren
		        IF NOT ISNULL(m.oCursor)
		          m.lStatus = m.lStatus AND m.oCursor.Update(UPDATEMASK_NOSAVE + UPDATEMASK_NOVALID)
		        ENDIF
		      ENDFOR
		    ENDIF
		
		    * Trigger the AfterUpdate() Rule event for any custom post-update processing.
		    IF m.lStatus
		      m.lStatus = THIS._ExecuteRule('AfterUpdate', RULEMASK_ANDED + RULEMASK_NOCALLBACK)
		    ENDIF
		
		    IF m.lStatus
		      * Commit (clear) all active Local Transaction levels. This
		      * does not end any level, but stored record data for the cursor will be reset.
		      THIS._LtCommit(-1)
		      
		      * If we started a new transaction for this update, complete it now.
		      IF m.lTransaction
		        THIS.oConnMan.CommitTrans()
		      ENDIF
		
		      * Flush any table memos to disk for increased crash survival odds. Will have no effect
		      * if a VFP transaction is still in effect, but those cases are handled by ConnMan.
		      FLUSH
		
		      * Restore record positions after successful commit of the topmost related parent.
		      IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOSAVE))
		        THIS.RestorePosition()
		      ENDIF
		
		      * Rebuild nav controls in UI if buffered appends have been commited (recno changed from - to +).
		      IF NOT ISNULL(THIS.oDM) AND BITTEST(THIS.nCursorFlags, CURSORFLAG_RECNO_CHANGED)
		        THIS.oDM.UpdateNavControls('NeedRebuild', THIS.cWorkarea)
		      ENDIF
		
		      THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)
		      THIS.nOldRecord = 0      && Always Clear this after successful update
		    ELSE
		      IF m.lTransaction
		        THIS.oConnMan.RollbackTrans()
		      ENDIF
		      THIS._ExecuteRule('AfterUpdateFailure', RULEMASK_ANDED + RULEMASK_NOCALLBACK)
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE updaterecord		&& Write outstanding changes to the current record back to the source table.
		LPARAMETERS nFlags
		*++
		*>>Write outstanding changes to the current record back to the source table.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOSAVE         1    Don't save/restore record positions.
		*    UPDATEMASK_NOVALID         2    Don't validate first.
		*    UPDATEMASK_NOCHILDREN     4  Don't process related child cursors.
		*    UPDATEMASK_NOUNLOCK         16 Don't release any locks
		*--
		LOCAL lStatus, nRecno, lTransaction
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOVALID)) AND NOT THIS.ValidateRow(m.nFlags)
		    RETURN .F.
		  ENDIF
		
		  * Call BeforeUpdate() rule first, passing the lCurrentRecordOnly parameter as .T.
		  IF THIS.ParentRiTest() AND THIS._ExecuteRule('BeforeUpdate', RULEMASK_ANDED,, .T.)
		    * Start a transaction if necessary.
		    IF NOT ISNULL(THIS.oConnMan)
		      m.lTransaction = THIS.oConnMan.BeginTrans(THIS.nConnID)
		    ENDIF
		
		    * Save original recno, (which may change after update if a new record).
		    m.nRecno = THIS.cmDataAccess.Recno()
		
		    * Clear record-number changed flag. Will be set by during update by access 
		    * layer method if any record numbers are changed as a result of the update.
		    THIS.nCursorFlags = BITCLEAR(THIS.nCursorFlags, CURSORFLAG_RECNO_CHANGED)
		    m.lStatus = THIS.AccessUpdateRecord()
		
		    IF m.lStatus AND EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      FOR EACH oCursor IN THIS.aChildren
		        IF NOT ISNULL(m.oCursor)
		          m.lStatus = m.lStatus AND m.oCursor.Update(BITOR(m.nFlags, UPDATEMASK_OBEY_SETKEY + UPDATEMASK_NOVALID))
		        ENDIF
		      ENDFOR
		    ENDIF
		
		    * If we started a new transaction, complete it now - one way or the other.
		    IF m.lStatus
		      * Clear local rollback data for current record only. This
		      * does not end any LocTrans level, but stored record state data will be reset.
		      THIS._LtCommit(-1, 0, m.nRecno)
		
		      * If we started a new transaction for this update, complete it now.
		      IF m.lTransaction
		        m.lStatus = THIS.oConnMan.CommitTrans()
		      ENDIF
		
		      * Flush any table memos to disk for increased crash survival odds. Will have no effect
		      * if a VFP transaction is still in effect, but those cases are handled by ConnMan.
		      FLUSH
		
		      * Rebuild nav controls in UI if buffered appends have been commited (recno changed from - to +).
		      IF NOT ISNULL(THIS.oDM) AND BITTEST(THIS.nCursorFlags, CURSORFLAG_RECNO_CHANGED)
		        THIS.oDM.UpdateNavControls('NeedRebuild', THIS.cWorkarea)
		      ENDIF
		
		      THIS._ExecuteRule('AfterUpdate', RULEMASK_ANDED,, .T.)
		      THIS.nCursorFlags = BITSET(THIS.nCursorFlags, CURSORFLAG_RESETFLAGS)
		    ELSE
		      IF m.lTransaction
		        THIS.oConnMan.RollbackTrans()
		      ENDIF
		      THIS._ExecuteRule('AfterUpdateFailure', RULEMASK_ANDED,, .T.)
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE validatecursor		&& Trigger the "CursorValid" event for this cursor, and any related children.
		LPARAMETERS nFlags
		*++
		*>>Trigger the "CursorValid" event for this cursor, and any related children.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN     4  Don't process related child cursors.
		*--
		LOCAL oCursor, lStatus, lRowChanged
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  * Trigger row validation rule if this row, or any related child row has changed.
		  m.lRowChanged = THIS.IsRecordChanged(m.nFlags)
		  m.lStatus = IIF(m.lRowChanged, THIS._ExecuteRule('RowValid', RULEMASK_ANDED), .T.)
		
		  * If any child records are changed (and NOCHILDREN is not set) lRowChanged will already be set.
		  IF m.lRowChanged OR THIS.IsChanged(UPDATEMASK_NOCHILDREN)
		    * Execute CursorValid() rule if any record in the cursor is changed. This rule
		    * is most useful for table-buffered cursors.
		    m.lStatus = m.lStatus AND THIS._ExecuteRule('CursorValid', RULEMASK_ANDED)
		
		    * Recursively check validation for every child.
		    FOR EACH oCursor IN THIS.aChildren
		      IF NOT ISNULL(m.oCursor)
		        m.lStatus = m.lStatus AND m.oCursor.ValidateCursor(m.nFlags)
		      ENDIF
		    ENDFOR
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE validatefield		&& Validate the specified field in the cursor.
		LPARAMETERS cField, uValue
		*++
		*>>Validate the specified field in the cursor.
		*--
		  * If a value is not specified, use the current field data.
		  IF PCOUNT() < 2
		    m.uValue = THIS.FieldValue(m.cField)
		  ENDIF
		  RETURN THIS._ExecuteRule('FieldValid', RULEMASK_ANDED, ;
		                          SUBSTR(m.cField, RAT('.', m.cField) + 1), @m.uValue)
		
	ENDPROC

	PROCEDURE validaterow		&& Validate the current row in the cursor, and all rows in related children.
		LPARAMETERS nFlags
		*++
		*>>Validate the current row in the cursor, and all rows in related children.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN     4  Don't process related child cursors.
		*--
		LOCAL oCursor, lStatus
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  * Trigger row validation rule if this row, or any related child row has changed.
		  IF THIS.IsRecordChanged(m.nFlags)
		    m.lStatus = THIS._ExecuteRule('RowValid', RULEMASK_ANDED)
		
		    * Also validate every related child cursor.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      FOR EACH oCursor IN THIS.aChildren
		        IF NOT ISNULL(m.oCursor)
		          m.lStatus = m.lStatus AND m.oCursor.ValidateCursor(m.nFlags)
		        ENDIF
		      ENDFOR
		    ENDIF
		    RETURN m.lStatus
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE zap		&& Delete all records from the cursor. For tables, the records are physically deleted. For view cursors, the local cursor in emptied, but source tables are unaffected.
		*++
		*>>Delete all records from the cursor. For tables, the records are physically deleted. For view cursors, the local cursor in emptied, but source tables are unaffected.
		*
		* This method leaves the cursor as the current VFP workarea in the data session.
		*--
		LOCAL lWasExclusive
		
		  IF USED(THIS.cWorkarea)
		    m.lWasExclusive = THIS.cmDataAccess.IsExclusive()
		    IF m.lWasExclusive OR THIS.SetExclusive(.T.)
		      THIS.cmDataAccess.Zap()
		      THIS.SetExclusive(m.lWasExclusive)
		      RETURN THIS.RecordWasMoved()
		    ENDIF
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE _callafteropen		&& Internal method to Execute the AfterOpen() rule event, and for views the initial AfterRequery() event too.
		LPARAMETERS nFlags
		*++
		*>>Internal method to Execute the AfterOpen() rule event, and for views the initial AfterRequery() event too.
		*--
		  * OR in any optional control flags. RULEMASK_DM_ONLY should be the only bit ever passed to us.
		  m.nFlags = BITOR(RULEMASK_ANDED, IIF(EMPTY(m.nFlags), 0, m.nFlags))
		
		  * Trigger the AfterOpen() rule in all linked rule objects.
		  THIS._ExecuteRule('AfterOpen', m.nFlags)
		
		  * If this is a view (any cursor that selects its recordset via Requery), then we 
		  * also trigger an initial call the the AfterRequery() rule event for all linked rules.
		  IF THIS.cmDataAccess.lSelectByRequery ;
		  AND NOT THIS.lNoDataOnLoad AND NOT THIS.lNoCursorOnLoad
		    THIS._ExecuteRule('AfterRequery', m.nFlags)
		  ENDIF
		
	ENDPROC

	PROCEDURE _evaluate		&& Evaluate the specified expression in this object's context.
		LPARAMETERS cExpr
		*++
		*>>Evaluate the specified expression in this object's context.
		*
		* Used to evaluate SQLPT cursor DBC field validation expressions. This way
		* the expressions can reference cursor object properties if desired.
		*--
		LOCAL uResult, nSelect
		  m.nSelect = SELECT()
		  SELECT (THIS.cWorkarea)
		  m.uResult = EVALUATE(m.cExpr)
		  SELECT (m.nSelect)
		  RETURN m.uResult
		
	ENDPROC

	PROCEDURE _executerule		&& Execute a specific rule in associated rule objects.
		LPARAMETERS cRule, nFlags, cField, uValue1, uValue2
		*++
		*>>Execute a specific rule in associated rule objects.
		* Returns .T. if rule is successful, and .F. on failure.
		*
		* Internal use only. Call the appropriate cursor or row rule method.
		* Normally called only from managed cursor objects.
		* Row rules take workarea name, but no field name
		* Field rules take workarea name, and field name
		*--
		LOCAL ix, oRule, oOldCursor, lStatus, nSelect, cCustomRule, cParams
		
		  FOR ix = 1 TO THIS.nRuleCount + IIF(BITTEST(m.nFlags, RULEFLAG_NOCALLBACK), 0, 1)
		    IF m.ix > THIS.nRuleCount && DM level events are called after cursor rules object events.
		      * Treat DM level rules just like a rule object, if there is a DM and it has the rule method.
		      m.oRule = .NULL.
		      IF NOT ISNULL(THIS.oDM)
		        IF PEMSTATUS(THIS.oDM, m.cRule, 5)
		          m.oRule = THIS.oDM
		        ENDIF
		      ENDIF
		    ELSE
		      m.oRule = THIS.aRules[m.ix]
		      IF BITTEST(m.nFlags, RULEFLAG_DM_ONLY)
		        IF NOT PROPER(m.oRule.Parent.Name) == 'Cmdatamanager'
		          LOOP
		        ENDIF
		      ENDIF
		    ENDIF
		
		    IF NOT ISNULL(m.oRule)
		      m.cParams = ''
		      IF VARTYPE(m.cField) == 'C'   && Character type means a field name
		        * Check for a field-specific rule method
		        m.cField = PROPER(m.cField)
		        m.cCustomRule = TRIM(THIS.cWorkarea) + '_' + TRIM(m.cField) + '_' + m.cRule
		        IF EMPTY(m.cField) OR NOT PEMSTATUS(m.oRule, m.cCustomRule, 5)
		          m.cCustomRule = m.cRule
		          m.cParams = 'THIS.cWorkarea, @m.cField'
		        ENDIF
		      ELSE
		        * Check for workarea-specific rule method
		        m.cCustomRule = TRIM(THIS.cWorkarea) + '_' + m.cRule
		        IF NOT PEMSTATUS(m.oRule, m.cCustomRule, 5)
		          m.cCustomRule = m.cRule
		          m.cParams = 'THIS.cWorkarea'
		        ENDIF
		      ENDIF
		
		      * Append optional extra arguments to parameter list, if specified.
		      IF PCOUNT() >= 4
		        m.cParams = m.cParams + IIF(EMPTY(m.cParams), '', ', ') + '@m.uValue1'
		        IF PCOUNT() >= 5
		          m.cParams = m.cParams + ', @m.uValue2'
		        ENDIF
		      ENDIF
		
		      WITH m.oRule
		        * Rule events always execute with the target workarea selected
		        m.nSelect = SELECT()
		        IF USED(THIS.cWorkarea)
		          SELECT (THIS.cWorkarea)
		        ENDIF
		
		        * Make sure rule has a link back the the CDE.
		        IF ISNULL(.oCDE)
		          .oCDE = THIS.oCDE
		        ENDIF
		
		        * Execute the Rule, giving it a handy link back to our cursor. Since rules
		        * may be triggered recursively, we preserve and restore original cursor ref value.
		        m.oOldCursor = .oThisCursor
		        .oThisCursor = THIS
		        m.lStatus = EVALUATE('.' + m.cCustomRule + '(' + m.cParams + ')')
		        .oThisCursor = m.oOldCursor
		
		        SELECT (m.nSelect)
		      ENDWITH
		      IF BITTEST(m.nFlags, RULEFLAG_ANDED) != m.lStatus OR ISNULL(m.lStatus)
		        RETURN m.lStatus
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  * ANDed rules default to .T., ORed rules default to .F.
		  RETURN BITTEST(m.nFlags, RULEFLAG_ANDED)
		
	ENDPROC

	PROCEDURE _ltcommit		&& Internal method to clear the save state data for the specified local transaction level.
		LPARAMETERS nTranLevel, nFlags, nRecno
		*++
		*>>Internal method to clear the save state data for the specified local transaction level.
		* Passing a -1 for nTranLevel will reset all local transaction levels
		*--
		  * If we are in a CDE, then default to the current CDE nLocalTransaction level.
		  IF EMPTY(m.nTranLevel)
		    m.nTranLevel = THIS.nLocalTransLevel
		  ENDIF
		  IF NOT EMPTY(m.nTranLevel)
		    m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		    THIS.cmDataAccess.LocalTransClear(MAX(0, m.nTranLevel), m.nRecno)
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      LOCAL oCursor
		      FOR EACH oCursor IN THIS.aChildren
		        IF NOT ISNULL(m.oCursor)
		          m.oCursor._LtCommit(m.nTranLevel)
		        ENDIF
		      ENDFOR
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE _ltjoin		&& Internal method to save state data for the current record to the current local transaction level. Does nothing if no Local Transaction is in progress.
		LPARAMETERS nTranLevel, nFlags
		*++
		*>>Internal method to save state data for the current record to the current local transaction level. Does nothing if no Local Transaction is in progress.
		*--
		  * If we are in a CDE, then default to the current CDE nLocalTransaction level.
		  IF EMPTY(m.nTranLevel)
		    m.nTranLevel = THIS.nLocalTransLevel
		  ENDIF
		  IF m.nTranLevel > 0
		    THIS.cmDataAccess.LocalTransJoin(m.nTranLevel, m.nFlags)
		  ENDIF
		
	ENDPROC

	PROCEDURE _ltrollback		&& Internal method to roll back the data to last saved current local transaction level.
		LPARAMETERS nTranLevel, nFlags, nRecno
		*++
		*>>Internal method to roll back the data to last saved current local transaction level.
		*--
		  * If we are in a CDE, then default to the current CDE nLocalTransaction level.
		  IF EMPTY(m.nTranLevel)
		    m.nTranLevel = THIS.nLocalTransLevel
		  ENDIF
		  IF NOT EMPTY(m.nTranLevel)
		    m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOSAVE))
		      THIS.SavePosition()
		    ENDIF
		
		    THIS.cmDataAccess.LocalTransRollback(m.nTranLevel)
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCHILDREN))
		      LOCAL oCursor
		      FOR EACH oCursor IN THIS.aChildren
		        IF NOT ISNULL(m.oCursor)
		          m.oCursor._LTRollback(m.nTranLevel, UPDATEMASK_NOSAVE)
		        ENDIF
		      ENDFOR
		    ENDIF
		
		    * Restore record positions after rollback of the topmost related parent.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOSAVE))
		      THIS.RestorePosition()
		    ENDIF
		
		    * Queue request to Rebuild nav controls in UI after rolling back changes.
		    IF NOT ISNULL(THIS.oDM)
		      THIS.oDM.UpdateNavControls('NeedRebuild', THIS.cWorkarea)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE _settypefromdbc		&& Set the type for a cursor based on the definition of the cursor in the current DBC.
		*++
		*>>Set the type for a cursor based on the definition of the cursor in the current DBC.
		*--
		  DO CASE
		    CASE EMPTY(DBC()) OR EMPTY(THIS.cSource)
		      RETURN .F.
		
		    CASE '.' $ THIS.cSource OR '\' $ THIS.cSource OR ':' $ THIS.cSource
		      * If there are any path elements specified it must be a table path.
		      THIS.cType = 'Table'
		
		    CASE INDBC(THIS.cSource, 'Table')
		      * If name is in DBC as a table, it must be a table.
		      THIS.cType = 'Table'
		      THIS.cDataBase = DBC()
		
		    CASE INDBC(THIS.cSource, 'View')
		      IF DBGETPROP(THIS.cSource, 'View', 'SourceType') = 1
		        THIS.cType = 'Lview'
		      ELSE
		        THIS.cType = 'Rview'
		      ENDIF
		      THIS.cDataBase = DBC()
		
		    OTHERWISE
		      RETURN .F.
		  ENDCASE
		  RETURN .T.
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmcursorproperties AS custom 		&& Codemine SQL Passthrough cursor property definition object.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_ViewProp.bmp" ClassIcon="..\graphics\_ViewProp.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: definecursor		&& Custom developer code to define field ruels and defaults. Called automaticaly during Init().
		*m: enumdefaults		&& Enumerate fields that have a default value expressions.
		*m: getfielddefault		&& Return the DBC default value expression for the specified field.
		*m: getfieldrule		&& Return the DBC validation expression and error message for the specified field.
		*m: restoreproperties		&& Restore cursor and field-level view properties
		*m: saveproperties		&& Save cursor and field-level view properties
		*m: setfielddefault		&& Set the DBC default value expression for the specified field.
		*m: setfieldrule		&& Set the DBC validation expression and error message for the specified field.
		*p: ckeyfieldlist		&& Comma delimited list of primary key fields for the cursor.
		*p: ctables		&& A comma delimited list of the names of tables from the remote server.
		*p: cupdatablefieldlist		&& Comma delimited list of fields in the view. This list can include fields from local and remote tables.
		*p: cupdatenamelist		&& Comma delimited list of field names and the local field names assigned to the cursor.
		*p: lcomparememo		&& Set to .T. if memo fields (of type Memo, General, or Picture) are included in the WHERE clause for updates.
		*p: lsendupdates		&& Contains true (.T.) if a SQL update query is sent to update tables when an update is made using the view; otherwise, contains false (.F.)
		*p: nbatchupdatecount		&& The number of update statements sent to the remote data source at once.
		*p: nupdatetype		&& 1 = Old data is updated with the new data (the default). 2 = Updates occur by deleting the old data and inserting the new data.
		*p: nwheretype		&& In WHERE clause for updates: 1 = Only key fields, 2 = Key fields and updatable fields, 3 = Key fields and any other modified fields, 4 = Key fields and a comparison of the time stamp.
	*</DefinedPropArrayMethod>

	ckeyfieldlist = 		&& Comma delimited list of primary key fields for the cursor.
	ctables = 		&& A comma delimited list of the names of tables from the remote server.
	cupdatablefieldlist = 		&& Comma delimited list of fields in the view. This list can include fields from local and remote tables.
	cupdatenamelist = 		&& Comma delimited list of field names and the local field names assigned to the cursor.
	height = 17
	lcomparememo = .F.		&& Set to .T. if memo fields (of type Memo, General, or Picture) are included in the WHERE clause for updates.
	lsendupdates = .F.		&& Contains true (.T.) if a SQL update query is sent to update tables when an update is made using the view; otherwise, contains false (.F.)
	Name = "cmcursorproperties"
	nbatchupdatecount = 1		&& The number of update statements sent to the remote data source at once.
	nupdatetype = 1		&& 1 = Old data is updated with the new data (the default). 2 = Updates occur by deleting the old data and inserting the new data.
	nwheretype = 4		&& In WHERE clause for updates: 1 = Only key fields, 2 = Key fields and updatable fields, 3 = Key fields and any other modified fields, 4 = Key fields and a comparison of the time stamp.
	picture = "..\Graphics\_ViewProp.bmp"
	width = 17
	
	PROCEDURE definecursor		&& Custom developer code to define field ruels and defaults. Called automaticaly during Init().
		*++
		*>>Custom developer code to define field ruels and defaults. Called automaticaly during Init().
		*--
		
	ENDPROC

	PROCEDURE enumdefaults		&& Enumerate fields that have a default value expressions.
		LPARAMETERS nIndex, cField, cExpr
		*++
		*>>Enumerate fields that have a default value expressions.
		*--
		  IF EMPTY(m.nIndex) OR m.nIndex < 0
		    m.nIndex = 1
		  ELSE
		    m.nIndex = m.nIndex + 1
		  ENDIF
		  DO WHILE .T.
		    IF m.nIndex <= THIS.nFldProps
		      m.cExpr = THIS.aFldProps[m.nIndex, 1]
		      IF EMPTY(m.cExpr)   && Skip empty ones (field may have only a valid rule)
		        m.nIndex = m.nIndex + 1
		        LOOP
		      ENDIF
		      m.cField = THIS.aFldNames[m.nIndex]
		      m.cField = LEFT(m.cField, LEN(m.cField)-1)   && Strip period suffix
		    ELSE
		      m.nIndex = -1
		    ENDIF
		    EXIT
		  ENDDO
		  RETURN m.nIndex
		
	ENDPROC

	PROCEDURE getfielddefault		&& Return the DBC default value expression for the specified field.
		LPARAMETERS cField
		*++
		*>>Return the DBC default value expression for the specified field.
		*--
		LOCAL ix
		  m.ix = ASCAN(THIS.aFldNames, PROPER(m.cField) + '.')
		  RETURN IIF(m.ix = 0, '', THIS.aFldProps[m.ix, 1])
		
	ENDPROC

	PROCEDURE getfieldrule		&& Return the DBC validation expression and error message for the specified field.
		LPARAMETERS cField, cMsg
		*++
		*>>Return the DBC validation expression and error message for the specified field.
		*--
		LOCAL ix
		  m.ix = ASCAN(THIS.aFldNames, PROPER(m.cField) + '.')
		  IF m.ix > 0
		    m.cMsg = THIS.aFldProps[m.ix, 3]
		    RETURN THIS.aFldProps[m.ix, 2]
		  ENDIF
		  RETURN ''
		
	ENDPROC

	PROCEDURE init
		*++
		* SQL Passthrough cursor property definition object.
		*
		* Copyright 2001-2002 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		  * If name is wrong, object will be ignored at runtime.
		  ASSERT PROPER(THIS.Name) == 'Cmcursorproperties' MESSAGE 'Cursor Properties object must be named "cmCursorProperties"'
		
		  * This defaults to .T., which means that our properties are applied to the view cursor.
		  THIS.AddProperty('lUseSavedProperties', .T.)
		  THIS.AddProperty('cViewSQL', '')
		
		  * Internal properties to store field default and validation expressions.
		  THIS.AddProperty('aFldNames[1]', '')
		  THIS.AddProperty('aFldProps[1,3]', '')  && Default, Validation, Message
		  THIS.AddProperty('nFldProps', 0)        && Number of fields with default or valid expressions.
		
		  THIS.DefineCursor()
		  RETURN .T.
		
	ENDPROC

	PROCEDURE restoreproperties		&& Restore cursor and field-level view properties
		*++
		*>>Restore cursor and field-level view properties
		*--
		  WITH THIS.Parent
		    * Apply correct buffering mode to the new result cursor
		    IF .nBuffermode > 3
		      .cmDataAccess.SetBufferMode(5)
		    ENDIF
		
		    IF THIS.lUseSavedProperties
		      CURSORSETPROP('BatchUpdateCount', THIS.nBatchupdatecount, .cWorkarea)
		      CURSORSETPROP('CompareMemo', THIS.lComparememo, .cWorkarea)
		      CURSORSETPROP('UpdateType', THIS.nUpdatetype, .cWorkarea)
		      CURSORSETPROP('WhereType', THIS.nWheretype, .cWorkarea)
		      CURSORSETPROP('Keyfieldlist', THIS.cKeyfieldlist, .cWorkarea)
		      CURSORSETPROP('Tables', THIS.cTables, .cWorkarea)
		      CURSORSETPROP('Updatablefieldlist', THIS.cUpdatablefieldlist, .cWorkarea)
		      CURSORSETPROP('Updatenamelist', THIS.cUpdatenamelist, .cWorkarea)
		      CURSORSETPROP('SendUpdates', THIS.lSendupdates AND NOT .lReadonly, .cWorkarea)
		    ENDIF
		  ENDWITH
		
	ENDPROC

	PROCEDURE saveproperties		&& Save cursor and field-level view properties
		LPARAMETERS cView
		*++
		*>>Save cursor and field-level view properties
		*
		* Field Level properties:
		*  DefaultValue    - Store for local use by rule code. Store in an array, indexed by field number?
		*  RuleExpression  - Store for local execution
		*  RuleText        - Store for local use by rule code
		*  DataType        - ??? no way to set for a SQL cursor field
		*  KeyField  (L)   - build KeyFieldList
		*  Updatable (L)   - build UpdatableFieldList
		*  UpdateName (remote field name) - build UpdateNameList
		*--
		LOCAL nSelect, nParentID
		
		  IF NOT EMPTY(m.cView)
		    WITH THIS
		      .lUseSavedProperties = .T.
		
		      * Set these properties from the view definition.
		      .nBatchUpdateCount = DBGETPROP(m.cView, 'View', "BatchUpdateCount")
		      .nUpdateType =       DBGETPROP(m.cView, 'View', "UpdateType")
		      .nWheretype =        DBGETPROP(m.cView, 'View', "WhereType")
		      .lComparememo =      DBGETPROP(m.cView, 'View', "CompareMemo")
		      .lSendUpdates =      DBGETPROP(m.cView, 'View', "SendUpdates")
		      .cTables =           DBGETPROP(m.cView, 'View', "Tables")
		      .cViewSQL =          DBGETPROP(m.cView, 'View', "SQL")
		
		      * Scan properties for each individual field in the DBC, for updateable views only.
		      * This makes read-only cursors open a little faster, but means they will not have any DBC rule 
		      * or KeyField information available (which should not matter for non-updateable cursors anyway)
		      IF .lSendupdates AND NOT .Parent.lReadonly
		        m.nSelect = SELECT()
		        SELECT 0
		        USE (DBC()) AGAIN SHARED ORDER ObjectName
		        IF SEEK(STR(1, 10) + PADR('View', LEN(ObjectType)) + PADR(LOWER(m.cView), LEN(ObjectName)))
		          LOCAL ix, cField, cFieldPath, cDefault, cRule
		          m.nParentID = ObjectID
		          SCAN FOR STR(PARENTID)+OBJECTTYPE = STR(m.nParentID, 10) + PADR('Field', LEN(ObjectType)) AND NOT DELETED()
		            m.cField = LOWER(TRIM(ObjectName))
		            m.cFieldPath = m.cView + '.' + m.cField
		            IF DBGETPROP(m.cFieldPath, 'Field', 'KeyField')   && Key VFP Fields
		              .cKeyfieldlist = THIS.cKeyfieldlist + IIF(EMPTY(THIS.cKeyfieldlist), '', ',') + m.cField
		            ENDIF
		            IF DBGETPROP(m.cFieldPath, 'Field', 'Updatable')  && Updatable VFP fields
		              .cUpdatablefieldlist = THIS.cUpdatablefieldlist + IIF(EMPTY(THIS.cUpdatablefieldlist), '', ',') + m.cField
		            ENDIF
		
		            * Store field validation rule and default values in custom properties where they will be easily available later.
		            m.cDefault = DBGETPROP(m.cFieldPath, 'Field', 'DefaultValue')  && Default value for new records
		            IF NOT EMPTY(m.cDefault)
		              .SetFieldDefault(m.cField, m.cDefault)
		            ENDIF
		            m.cRule = DBGETPROP(m.cFieldPath, 'Field', 'RuleExpression')   && Field validation expression
		            IF NOT EMPTY(m.cRule)
		              .SetFieldRule(m.cField, m.cRule, DBGETPROP(m.cFieldPath, 'Field', 'RuleText'))
		            ENDIF
		
		            * Build list of all VFP field names, mapped to the corresponding remote field name.
		            .cUpdateNameList = .cUpdatenamelist + IIF(EMPTY(.cUpdatenamelist), '', ',') ;
		                             + m.cField + ' ' + DBGETPROP(m.cFieldPath, 'Field', 'UpdateName')
		          ENDSCAN
		        ENDIF
		        USE
		        SELECT (m.nSelect)
		      ENDIF
		    ENDWITH
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setfielddefault		&& Set the DBC default value expression for the specified field.
		LPARAMETERS cField, cExpr
		*++
		*>>Set the DBC default value expression for the specified field.
		*--
		LOCAL ix
		  m.cField = PROPER(m.cField) + '.'  && Store in a format immune to SET EXACT setting.
		  m.ix = ASCAN(THIS.aFldNames, m.cField)
		  IF m.ix = 0
		    STORE THIS.nFldProps + 1 TO m.ix, THIS.nFldProps
		    DIMENSION THIS.aFldNames[m.ix]
		    DIMENSION THIS.aFldProps[m.ix, 3]
		  ENDIF
		  THIS.aFldNames[m.ix] = m.cField
		  THIS.aFldProps[m.ix, 1] = m.cExpr
		
	ENDPROC

	PROCEDURE setfieldrule		&& Set the DBC validation expression and error message for the specified field.
		LPARAMETERS cField, cRule, cMsg
		*++
		*>>Set the DBC validation expression and error message for the specified field.
		*--
		LOCAL ix
		  m.cField = PROPER(m.cField) + '.'  && Store in a format immune to SET EXACT setting.
		  m.ix = ASCAN(THIS.aFldNames, m.cField)
		  IF m.ix = 0
		    STORE THIS.nFldProps + 1 TO m.ix, THIS.nFldProps
		    DIMENSION THIS.aFldNames[m.ix]
		    DIMENSION THIS.aFldProps[m.ix, 3]
		  ENDIF
		  THIS.aFldNames[m.ix] = m.cField
		  THIS.aFldProps[m.ix, 2] = m.cRule
		  THIS.aFldProps[m.ix, 3] = IIF(EMPTY(m.cMsg), '', m.cMsg)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdataenvironment AS cmdataabstract OF "..\common\cmdataa.vcx" 		&& Codemine 7.1 Data Environment (CDE) class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_cde.bmp" ClassIcon="..\graphics\_cde.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addcde		&& Add the specified child CDE object to the collection of children managed by this CDE.
		*m: addcursor		&& Add a new cursor to the collection of cursors managed by this CDE. Returns a reference to the cursor object.
		*m: aftercloseall		&& AfterCloseAll event occurs after all tables have been closed.
		*m: afteropenall		&& AfterOpenAll event occurs after all tables have been opened, but before any relations are set.
		*m: afteropenall2		&& AfterOpenAll2 event occurs after all tables have been opened and relations are set, but before and initial record positions have been set.
		*m: afteropenall3		&& AfterOpenAll3 event occurs after all tables have been opened, relations are set, and initial record positions are set.
		*m: afterrevertall		&& AfterRevert event occurs after all changes have been reverted to original values
		*m: afterupdateall		&& AfterUpdateAll event occurs after all changes have been saved to all source tables.
		*m: afterupdateallfailure		&& AfterUpdateAllFailure event occurs after an error occurs preventing successful completion of UpdateAll().
		*m: beforecloseall		&& BeforeCloseAll event occurs before all tables are about to be closed.
		*m: beforeopenall		&& BeforeOpenAll event occurs before all tables are about to be opened.
		*m: beforerevertall		&& BeforeRevert event occurs before all changes are discarded.
		*m: beforeupdateall		&& BeforeUpdateAll event occurs before all changes are saved to all source tables. Return .F. to prevent update.
		*m: cdisplayname_access		&& Fill in a default value for display name if no explicit value is set.
		*m: closeall		&& Close all the cursors in this data environment
		*m: enumcdes		&& Enumerate child CDE objects that have been added to this one.
		*m: enumcursors		&& Enumerate the cursors that are currently part of this CDE.
		*m: getcursor		&& Look up the specified workarea alias, and return a reference to the object responsible for managing it.
		*m: initsession		&& Initialize data session settings
		*m: inspectordetails		&& Display object-specific debugging information in the Codemine object inspector.
		*m: inspectornode		&& Display a cursor's details in an object inspector's node.
		*m: ischanged		&& Returns true if any record in the specified list of cursors contains uncommited changes.
		*m: linkdm		&& Link this CDE to a form Data manager object.
		*m: loadnde		&& Forms call this to load a native DE into this CDE
		*m: localtransbegin		&& Begin a new local transaction level.
		*m: localtranscommit		&& Commit the current local transaction level for all cursors.
		*m: localtransrollback		&& Roll back the current local transaction level.
		*m: nlocaltranslevel_access		&& Use the local transaction level of our host CDE, if we are nested inside another CDE. Otherwise, use our own value.
		*m: nlocaltranslevel_assign		&& Use the local transaction level of our host CDE, if we are nested inside another CDE. Otherwise, use our own value.
		*m: oform_access		&& Find a reference to the form that this object is a part of. Return NULL if not part of a form.
		*m: openall		&& Open all the cursors in this data environment
		*m: release		&& Release Data Environment, and links from all cursors back to rule objects to prevent object release deadlocks.
		*m: removecursor		&& Remove a cursor object from the collection of cursors managed by this CDE.
		*m: revertall		&& Discard changes to all records in specified workareas, release locks, and revert to original values.
		*m: setinitialpositions		&& Set the initial record positions for all open parent tables. Called for root CDE on completion of OpenAll(), or from DM.Init() for CDEs linked to data forms.
		*m: unlinkdm		&& UnLink this CDE from a form Data manager object.
		*m: updateall		&& Write all buffered changes in all workareas to disk for the specified cursors.
		*m: validateall		&& Execute the RowValid() and CursorValid() rules for all cursors in this with uncommited changes, in this or any child CDE.
		*m: _buildcursormap		&& Build a quick lookup array to map all workarea alias names to their Cursor objects.
		*m: _establishrelations		&& After all cursors are open, establish any defined relations between them.
		*m: _getcdebyindex		&& Internal recursive method to get a reference to the next CDE in the tree being enumerated.
		*m: _linkcursor		&& Internal method to link cursor into the cursor map array.
		*m: _linkrulestocursor		&& Internal method used to link rule objects to a cursor.
		*m: _triggerevent		&& Recursive method to trigger the specified event in this CDE, and all contained child CDEs.
		*p: cclass		&& Foundation class name for this class
		*p: cconnectionmanagerclass		&& Name of the Connection and Transaction Manager class to use.
		*p: cprimaryworkarea		&& Primary workarea for this data environment
		*p: lautoopen		&& Set to .T. to call OpenAll() automatically when the CDE is created. Do not set this if CDE is used in a form.
		*p: ldmsetsinitialpositions		&& Set to .F. to set all initial record positions directly from OpenAll(), rather than waiting for the form's data manager to be initialized.
		*p: lprivatedatasession		&& Set to true to run in a private data session. Does not apply to CDEs used by a form, or those nested within parent CDE containers.
		*p: nlocaltranslevel		&& Current local transaction level. Should always be 0 at design time.
		*p: oconnman		&& Runtime reference to the connection manager object.
		*p: odm		&& Internal runtime reference to controlling Data Manager, if one exists.
		*p: oform		&& Runtime reference to the form that this CDE is a linked to, or NULL if not part of a form.
		*p: ohost		&& Runtime reference to the host CDE if we are a linked or contained child in a host CDE. Null if a root level CDE.
		*p: oroot		&& Runtime reference to the root host CDE, useful contained child CDEs are nested multiple levels deep.
	*</DefinedPropArrayMethod>

	backcolor = 255,255,198
	backstyle = 1
	bordercolor = 128,128,128
	borderwidth = 0
	cclass = cmDataEnvironment		&& Foundation class name for this class
	cconnectionmanagerclass = cmConnectionManagerCustom		&& Name of the Connection and Transaction Manager class to use.
	cprimaryworkarea = 		&& Primary workarea for this data environment
	height = 40
	lautoopen = .F.		&& Set to .T. to call OpenAll() automatically when the CDE is created. Do not set this if CDE is used in a form.
	ldmsetsinitialpositions = .T.		&& Set to .F. to set all initial record positions directly from OpenAll(), rather than waiting for the form's data manager to be initialized.
	lprivatedatasession = .F.		&& Set to true to run in a private data session. Does not apply to CDEs used by a form, or those nested within parent CDE containers.
	Name = "cmdataenvironment"
	nlocaltranslevel = 0		&& Current local transaction level. Should always be 0 at design time.
	oconnman = .NULL.		&& Runtime reference to the connection manager object.
	odm = .NULL.		&& Internal runtime reference to controlling Data Manager, if one exists.
	oform = .NULL.		&& Runtime reference to the form that this CDE is a linked to, or NULL if not part of a form.
	ohost = .NULL.		&& Runtime reference to the host CDE if we are a linked or contained child in a host CDE. Null if a root level CDE.
	oroot = .NULL.		&& Runtime reference to the root host CDE, useful contained child CDEs are nested multiple levels deep.
	width = 100
	
	PROCEDURE addcde		&& Add the specified child CDE object to the collection of children managed by this CDE.
		LPARAMETERS oCDE, nFlags
		*++
		*>>Add the specified child CDE object to the collection of children managed by this CDE.
		*
		* nFlags bit values:
		*   CDEMASK_NOEXPOSE  - Don't expose this CDE's cursors to the parent's data binding cursor map.
		*--
		LOCAL oCursor
		
		  * Don't allow linked child CDE's to be added to a child CDE - only to the root parent CDE.
		  IF NOT ISNULL(THIS.oHost) AND EMPTY(BITAND(m.oCDE.nControlFlags, CDEMASK_CHILD))
		    ASSERT .F. MESSAGE 'You can only add child CDEs to the root parent CDE'
		    RETURN .F.
		  ENDIF
		
		  WITH m.oCde
		    .nControlFlags = BITOR(.nControlFlags, IIF(EMPTY(m.nFlags), 0, m.nFlags))
		
		    * For linked children, the host Connection Manager should already exist.
		    .oConnMan = THIS.oConnMan
		
		    * If we are a child, find and keep a ref to the Host and top Root CDE.
		    STORE THIS TO .oHost, .oRoot
		    DO WHILE TYPE('.oRoot.Parent.cClass') = 'C' ;
		    AND PROPER(.oRoot.Parent.cClass) == PROPER('cmDataEnvironment')
		      .oRoot = .oRoot.Parent
		    ENDDO
		  ENDWITH
		
		  * Add the CDE to our child CDE map array.
		  THIS.nCdeCount = THIS.nCdeCount + 1
		  DIMENSION THIS.aCDE[THIS.nCdeCount]
		  THIS.aCDE[THIS.nCdeCount] = m.oCDE
		
		  * If we have a DM link, pass it on to our new nested child CDE.
		  IF NOT ISNULL(THIS.oDM)
		    m.oCDE.LinkDM(THIS.oDM)
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE addcursor		&& Add a new cursor to the collection of cursors managed by this CDE. Returns a reference to the cursor object.
		LPARAMETERS cWorkarea, cClass, nFlags
		*++
		*>>Add a new cursor to the collection of cursors managed by this CDE. Returns a reference to the cursor object.
		*
		* nFlags bit values:
		*   CDEMASK_NORULES  - Don't link rules
		*--
		LOCAL oCursor
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  * We have a VFP cursor workarea alias.
		  * Create a cursor object for the cursor, and bind it to the cursor.
		  THIS.AddNewObject(m.cWorkarea, IIF(EMPTY(m.cClass), 'cmCursorCustom', m.cClass))
		  m.oCursor = EVALUATE('THIS.' + m.cWorkarea)
		  m.oCursor.cWorkarea = m.cWorkarea
		
		  * If there is a matching VFP cursor open, bind it to the new cursor object.
		  IF USED(m.cWorkarea)
		    m.oCursor.BindToRecordset(m.cWorkarea)
		  ENDIF
		
		  * Link the cursor into our cursor map array, and set backlinks to DM and CDE.
		  THIS._LinkCursor(m.oCursor, m.nFlags)
		  RETURN m.oCursor
		
	ENDPROC

	PROCEDURE aftercloseall		&& AfterCloseAll event occurs after all tables have been closed.
		*++
		*>>AfterCloseAll event occurs after all tables have been closed.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afteropenall		&& AfterOpenAll event occurs after all tables have been opened, but before any relations are set.
		*++
		*>>AfterOpenAll event occurs after all tables have been opened, but before any relations are set.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afteropenall2		&& AfterOpenAll2 event occurs after all tables have been opened and relations are set, but before and initial record positions have been set.
		*++
		*>>AfterOpenAll2 event occurs after all tables have been opened and relations are set, but before and initial record positions have been set.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afteropenall3		&& AfterOpenAll3 event occurs after all tables have been opened, relations are set, and initial record positions are set.
		*++
		*>>AfterOpenAll3 event occurs after all tables have been opened, relations are set, and initial record positions are set.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterrevertall		&& AfterRevert event occurs after all changes have been reverted to original values
		LPARAMETERS cWorkareaList
		*++
		*>>AfterRevert event occurs after all changes have been reverted to original values
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterupdateall		&& AfterUpdateAll event occurs after all changes have been saved to all source tables.
		LPARAMETERS cWorkareaList
		*++
		*>>AfterUpdateAll event occurs after all changes have been saved to all source tables.
		* DM level rule accepts optional Workarea list, whereas rule object level accepts a single workarea.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterupdateallfailure		&& AfterUpdateAllFailure event occurs after an error occurs preventing successful completion of UpdateAll().
		LPARAMETERS cWorkareaList
		*++
		*>>AfterUpdateAllFailure event occurs after an error occurs preventing successful completion of UpdateAll().
		* DM level rule accepts optional Workarea list, whereas rule object level accepts a single workarea.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforecloseall		&& BeforeCloseAll event occurs before all tables are about to be closed.
		*++
		*>>BeforeCloseAll event occurs before all tables are about to be closed.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeopenall		&& BeforeOpenAll event occurs before all tables are about to be opened.
		*++
		*>>BeforeOpenAll event occurs before all tables are about to be opened.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforerevertall		&& BeforeRevert event occurs before all changes are discarded.
		LPARAMETERS cWorkareaList
		*++
		*>>BeforeRevert event occurs before all changes are discarded.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeupdateall		&& BeforeUpdateAll event occurs before all changes are saved to all source tables. Return .F. to prevent update.
		LPARAMETERS cWorkareaList
		*++
		*>>BeforeUpdateAll event occurs before all changes are saved to all source tables. Return .F. to prevent update.
		* DM level rule accepts optional Workarea list, whereas rule object level accepts a single workarea.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE cdisplayname_access		&& Fill in a default value for display name if no explicit value is set.
		*++
		*>>Fill in a default value for display name if no explicit value is set.
		*--
		  * Default to the form caption, if we are part of a form
		  IF EMPTY(THIS.cDisplayName) AND NOT ISNULL(THIS.oDM)
		    THIS.cDisplayName = THIS.oDM.Parent.Caption
		  ENDIF
		
		  IF EMPTY(THIS.cDisplayName)
		    RETURN THIS.Name
		  ENDIF
		  RETURN THIS.cDisplayName
		
	ENDPROC

	PROCEDURE closeall		&& Close all the cursors in this data environment
		*++
		*>>Close all the cursors in this data environment
		*--
		LOCAL ix, oCursor, oCde
		
		  * Only trigger BeforeCloseAll() if all cursors were successfully opened.
		  IF THIS.lCursorsOpen
		    THIS.BeforeCloseAll()
		  ENDIF
		
		  * If any outstanding changes remain, discard them before closing.
		  m.ix = 0
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor) > 0
		    IF m.oCursor.lAutoClose AND m.oCursor.IsChanged(UPDATEMASK_NOCHILDREN)
		      m.oCursor.Revert(UPDATEMASK_NOCHILDREN)
		    ENDIF
		  ENDDO
		
		  * Close cursors in any nested CDE containers also.
		  m.ix = 0
		  DO WHILE THIS.EnumCDEs(@m.ix, @m.oCde) > 0
		    m.oCde.CloseAll()
		  ENDDO
		
		  * Close each cursor, unless lAutoClose is set to false.
		  m.ix = 0
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor) > 0
		    IF m.oCursor.lAutoClose AND m.oCursor.IsOpen()
		      m.oCursor.Close()
		    ENDIF
		  ENDDO
		
		  THIS.lCursorsOpen = .F.
		  THIS.AfterCloseAll()
		
	ENDPROC

	PROCEDURE enumcdes		&& Enumerate child CDE objects that have been added to this one.
		LPARAMETERS nIndex, oCDE, nFlags
		*++
		*>>Enumerate child CDE objects that have been added to this one.
		*
		* nFlags bits:
		*        CDEMASK_ENUM_NESTED - Include contained child CDEs layered more than one level deep.
		*                           If not set, only immediate contained children will be enumerated.
		*--
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  * This CDE would be index 0, first child should be index 1
		  m.nIndex = IIF(EMPTY(m.nIndex) OR m.nIndex < 0, 1, m.nIndex + 1)
		  IF NOT EMPTY(BITAND(m.nFlags, CDEMASK_ENUM_NESTED))
		    * Navigate sequentially through all our child CDEs in the tree to all depths.
		    IF NOT ISNULL(THIS._GetCdeByIndex(@m.oCde, m.nIndex))
		      RETURN m.nIndex
		    ENDIF
		  ELSE
		    * Navigate sequentially only through direct child CDEs immediately under this on.
		    FOR nIndex = m.nIndex TO THIS.nCdeCount
		      IF NOT ISNULL(THIS.aCDE[m.nIndex])
		        m.oCDE = THIS.aCDE[m.nIndex]
		        RETURN m.nIndex
		      ENDIF
		    ENDFOR
		  ENDIF
		
		  * Reached the end of the CDEs in this tree.
		  m.nIndex = -1
		  m.oCDE = .NULL.
		  RETURN m.nIndex
		
	ENDPROC

	PROCEDURE enumcursors		&& Enumerate the cursors that are currently part of this CDE.
		LPARAMETERS nIndex, oCursor, nFlags
		*++
		*>>Enumerate the cursors that are currently part of this CDE.
		*
		* nFlags bits:
		*        CDEMASK_ENUM_NESTED      - Include cursors in child nested CDE containers (but not those
		*                                in any higher level parent CDE containers).
		*        CDEMASK_ENUM_NOIGNORED   - Do Not skip over cursors with lIgnore set.
		*--
		LOCAL nStart, ix, oCde, nCDEIx, nCursorIx
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  * Split nIndex value into CDE index (high order 16 bits), and Cursor index (low 16).
		  IF EMPTY(m.nIndex) OR m.nIndex < 0
		    m.nCdeIx = 0
		    m.nCursorIx = 1
		  ELSE
		    m.nCdeIx = BITRSHIFT(m.nIndex, 16)
		    m.nCursorIx = BITAND(m.nIndex, 0xFFFF) + 1
		  ENDIF
		
		  IF m.nCdeIx = 0 OR EMPTY(BITAND(m.nFlags, CDEMASK_ENUM_NESTED))
		    m.oCDE = THIS
		  ELSE
		    m.oCDE = THIS._GetCdeByIndex(m.oCDE, m.nCdeIx)
		  ENDIF
		  DO WHILE NOT ISNULL(m.oCDE)
		    * Scan sequentially through all cursors in the target CDE container.
		    FOR nCursorIx = m.nCursorIx TO m.oCDE.nCursorCount
		      IF NOT ISNULL(m.oCDE.aCursors[m.nCursorIx])
		        m.oCursor = m.oCDE.aCursors[m.nCursorIx]
		        IF EMPTY(BITAND(m.nFlags, CDEMASK_ENUM_NOIGNORED)) OR NOT m.oCursor.lIgnore
		          m.nIndex = INT(BITLSHIFT(m.nCdeIx, 16) + m.nCursorIx)
		          RETURN m.nIndex
		        ENDIF
		      ENDIF
		    ENDFOR
		
		    * If enumerating all cursors in a CDE tree, move on to the next CDE now.
		    IF EMPTY(BITAND(m.nFlags, CDEMASK_ENUM_NESTED))
		      m.oCDE = .NULL.   && Not enumerating cursors in child CDEs.
		    ELSE
		      m.nCursorIx = 1
		      m.nCdeIx = m.nCdeIx + 1
		      m.oCDE = THIS._GetCdeByIndex(@m.oCDE, m.nCdeIx)
		    ENDIF
		  ENDDO
		
		  * Reached the end of the cursor collection.
		  m.nIndex = -1
		  m.oCursor = .NULL.
		  RETURN m.nIndex
		
	ENDPROC

	PROCEDURE getcursor		&& Look up the specified workarea alias, and return a reference to the object responsible for managing it.
		LPARAMETERS cWorkArea
		*++
		*>>Look up the specified workarea alias, and return a reference to the object responsible for managing it.
		*--
		LOCAL lExact, nCursor
		  m.lExact = SET('EXACT') = 'ON'
		  SET EXACT ON
		  m.nCursor = ASCAN(THIS.aCursorNames, PROPER(m.cWorkarea))
		  IF NOT m.lExact
		    SET EXACT OFF
		  ENDIF
		
		  * If we found a cursor, return a reference to it now.
		  IF m.nCursor > 0
		    RETURN THIS.aCursors[m.nCursor]
		  ELSE
		    * Nothing found yet. If there are nested CDEs, look in them next.
		    IF THIS.nCdeCount > 0
		      LOCAL ix, oCDE, oCursor
		      DO WHILE THIS.EnumCDEs(@m.ix, @m.oCDE) > 0
		        IF NOT BITTEST(m.oCDE.nControlFlags, CDEMASK_NOEXPOSE)
		          m.oCursor = m.oCDE.GetCursor(m.cWorkArea)
		          IF NOT ISNULL(m.oCursor)
		            RETURN m.oCursor
		          ENDIF
		        ENDIF
		      ENDDO
		    ENDIF
		  ENDIF
		
		  RETURN .NULL.    && Nothing found anywhere
		
	ENDPROC

	PROCEDURE init
		LPARAMETERS oNDE, nFlags
		*++
		* Initialize object. If oNDE parameter is specified (ref to native DE), then 
		* build our cursor list from it.
		*
		* The nFlags parameter may be a combination of the following butmask values:
		*   CDEMASK_FORM        - CDE is part of a form, ignore lAutoOpen and lPrivateDataSession setting
		*   CDEMASK_DATAFORM    - CDE is part of a Data Form with a DataMaanger object.
		*   CDEMASK_DESIGN_TIME - Created at design time. Dont add any runtime properties.
		*                         Design time creation must always include a oNDE parameter.
		*--
		LOCAL oCtl
		
		  * We also accept nFlags parameter via a PRIVATE variable, so forms can get a value
		  * to us without breaking compatibility when they are creating a Native Data Env class.
		  IF PCOUNT() = 0 AND VARTYPE(m.pnCdeControlFlagParameter) = 'N'
		    m.nFlags = m.pnCdeControlFlagParameter
		  ENDIF
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  * If the CDE is created in "DesignTime" mode, we don't create any runtime properties.
		  * Just load the passed NDE, and return.
		  IF NOT EMPTY(BITAND(m.nFlags, CDEMASK_DESIGN_TIME))
		    RETURN THIS.LoadNDE(m.oNDE)
		  ENDIF
		
		  * Default runtime data object init code.
		  DODEFAULT()
		
		  * In Unattended server mode, we default to all silent messages, except for fatal errors.
		  IF SYS(2335) == '0'
		    THIS.nErrorMode = BITOR(THIS.nErrorMode, ERRMASK_SILENT_WARNING + ERRMASK_SILENT_MESSAGE)
		  ENDIF
		
		  * Seed random number generator for staggered lock retries.
		  RAND(-1)
		
		  * Add internal runtime properties here so they are not available at design time.
		  THIS.AddProperty('nControlFlags', m.nFlags) && Internal CDE control flags.
		  THIS.AddProperty('lCursorsOpen', .F.)       && Property (not flag bit) for easy reading by outside objects.
		  THIS.AddProperty('nDataSessionID', 0)
		  THIS.AddProperty('nCursorCount', 0)
		  THIS.AddProperty('aCursors[1]', .NULL.)
		  THIS.AddProperty('aCursorNames[1]', '')
		  THIS.AddProperty('nCdeCount', 0)
		  THIS.AddProperty('aCde[1]', .NULL.)
		  THIS.AddProperty('oSession', .NULL.)
		
		  * If there are any nested CDEs in our container, add them to our collection of nested CDEs.
		  FOR EACH oCtl IN THIS.Controls
		    IF PEMSTATUS(m.oCtl, 'cClass', 5)
		      IF PROPER(m.oCtl.cClass) == PROPER('cmDataEnvironment')
		        THIS.AddCDE(m.oCtl)
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  * If we are a contained child in a parent CDE, we don't do anything else at Init() time.
		  IF TYPE('THIS.Parent.cClass') == 'C' AND PROPER(THIS.Parent.cClass) == PROPER('cmDataEnvironment')
		    THIS.nControlFlags = BITOR(THIS.nControlFlags, CDEMASK_CHILD)
		    RETURN .T.
		  ENDIF
		
		  IF VARTYPE(m.oNDE) == 'O'  
		    * Load cursor definitions from the specified NDE
		    THIS.LoadNDE(m.oNDE)
		  ELSE
		    * Build internal map of workarea names to cursor object references.
		    THIS._BuildCursorMap()
		  ENDIF
		
		  * If not in a form, perform standalone CDE initialization.
		  IF EMPTY(BITAND(THIS.nControlFlags, CDEMASK_FORM)) 
		    * Create a private data session if lPrivateDataSession is set. If we are in a form, we
		    * cannot start our own data session, so we ignore lPrivateDataSession.
		    IF THIS.lPrivateDataSession AND ISNULL(THIS.oSession)
		      THIS.oSession = CREATEOBJECT('sesPrivateSession')
		      THIS.oSession.Name = THIS.Name
		      SET DATASESSION TO THIS.oSession.DataSessionID
		    ENDIF
		    THIS.nDataSessionID = SET('DATASESSION')
		
		    * Set up data session defaults for our (possibly private) session.
		    THIS.InitSession()
		
		    * Open all cursors if lAutoOpen is set. This only applies when not in a form.
		    IF THIS.lAutoOpen
		      RETURN THIS.OpenAll()
		    ENDIF
		    RETURN .T.
		  ENDIF
		
		  * Set up data session defaults
		  THIS.InitSession()
		  RETURN .T.
		
	ENDPROC

	PROCEDURE initsession		&& Initialize data session settings
		*++
		*>>Initialize data session settings
		*--
		  SET TALK OFF
		  SET DELETED ON            && Deleted must be ON for correct operation.
		  SET MULTILOCKS ON         && MultiLocks must also be ON
		  SET REPROCESS TO 1
		
	ENDPROC

	PROCEDURE inspectordetails		&& Display object-specific debugging information in the Codemine object inspector.
		LPARAMETERS oNodes, cRoot
		*++
		*>>Display object-specific debugging information in the Codemine object inspector.
		*--
		LOCAL ix, oCursor
		
		  m.oNodes.Add(m.cRoot, 4, 'Cursors', 'Managed Cursors')
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor, CDEMASK_ENUM_NESTED) > 0
		    IF ISNULL(m.oCursor.oParent)
		      THIS.InspectorNode(m.oNodes, m.oCursor, 'Cursors')
		    ENDIF
		  ENDDO
		
	ENDPROC

	PROCEDURE inspectornode		&& Display a cursor's details in an object inspector's node.
		LPARAMETERS oNodes, oCursor, cParentNode
		*++
		*>>Display a cursor's details in an object inspector's node.
		*--
		LOCAL cFlags, cText, cAlias, nSelect, oChild
		
		  m.cAlias = m.oCursor.cWorkarea
		  m.cText = m.cAlias + ' ('
		  IF USED(m.cAlias)
		    m.nSelect = SELECT()
		    SELECT (m.cAlias)
		    m.cText = m.cText + 'Record ' + LTRIM(STR(RECNO())) + '/' + LTRIM(STR(RECCOUNT())) + '  ' + SYS(2011)
		    SELECT (m.nSelect)
		  ENDIF
		  m.cFlags = ''
		  IF NOT ISNULL(m.oCursor.oParent)
		    m.cFlags = m.cFlags + 'Child '
		  ENDIF
		
		  IF NOT m.oCursor.IsOpen()
		    m.cFlags = m.cFlags + 'Closed '
		  ELSE
		    IF m.oCursor.IsEmpty()
		      m.cFlags = m.cFlags + 'Empty '
		    ELSE
		      IF m.oCursor.IsTop()
		        m.cFlags = m.cFlags + 'Top '
		      ENDIF
		      IF m.oCursor.IsBottom()
		        m.cFlags = m.cFlags + 'Bottom '
		      ENDIF
		    ENDIF
		  ENDIF
		
		  IF NOT EMPTY(m.cFlags)
		    m.cText = m.cText + ' [' + TRIM(m.cFlags) + ']'
		  ENDIF
		  m.cText = m.cText + ')'
		
		  * Make recursive calls to add related children
		  m.oNodes.Add(m.cParentNode, 4, m.cAlias, m.cText)
		  FOR EACH m.oChild IN m.oCursor.aChildren
		    IF NOT ISNULL(m.oChild)
		      THIS.InspectorNode(m.oNodes, m.oChild, m.cAlias)
		    ENDIF
		  ENDFOR
		
	ENDPROC

	PROCEDURE ischanged		&& Returns true if any record in the specified list of cursors contains uncommited changes.
		LPARAMETERS cWorkareaList, cExclude
		*++
		*>>Returns true if any record in the specified list of cursors contains uncommited changes.
		*--
		LOCAL ix, oTarget, cWorkarea
		
		  * Format list of cursors to exclude, for easy comparisons.
		  m.cExclude = IIF(EMPTY(m.cExclude), '', PROPER(m.cExclude))
		  IF EMPTY(m.cWorkareaList) OR '*' $ m.cWorkareaList
		    * Check all top level parent cursors, and their children, for changes.
		    DO WHILE THIS.EnumCursors(@m.ix, @m.oTarget) > 0
		      WITH m.oTarget
		        IF ISNULL(.oParent) AND NOT .cWorkarea == m.cExclude AND NOT .lIgnore AND .IsChanged()
		          RETURN .T.
		        ENDIF
		      ENDWITH
		    ENDDO
		
		    * If no native cursors are changed, test those in nested CDE containers.
		    m.ix = 0
		    DO WHILE THIS.EnumCDEs(@m.ix, @m.oTarget) > 0
		      IF m.oTarget.IsChanged('', m.cExclude)
		        RETURN .T.
		      ENDIF
		    ENDDO
		  ELSE
		    DO WHILE NOT EMPTY(m.cWorkareaList)
		      m.cWorkarea = PROPER(GetToken(@m.cWorkareaList, ','))
		      IF NOT m.cWorkarea == m.cExclude
		        m.oTarget = THIS.GetCursor(m.cWorkarea)
		        IF NOT ISNULL(m.oTarget) AND m.oTarget.IsChanged()
		          RETURN .T.
		        ENDIF
		      ENDIF
		    ENDDO
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE linkdm		&& Link this CDE to a form Data manager object.
		LPARAMETERS oDM
		*++
		*>>Link this CDE to a form Data manager object.
		*--
		LOCAL ix, oTarget, oRule
		
		  * Link DM to any nested CDEs as well.
		  THIS.oDM = m.oDM
		  DO WHILE THIS.EnumCDEs(@m.ix, @m.oTarget) > 0
		    m.oTarget.LinkDM(m.oDM)
		  ENDDO
		
		  * Loop through all DM level rule objects, and link to their associated cursors.
		  * Rule objects in the CDE container have already been linked by the CDE Init().
		  FOR EACH oRule IN m.oDM.Controls
		    IF m.oRule.Baseclass == 'Container' AND PROPER(m.oRule.cClass) == 'Cmrule'
		      m.oRule.Link(THIS)
		    ENDIF
		  ENDFOR
		
		  m.ix = 0
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oTarget) > 0
		    m.oTarget.oDM = m.oDM
		  ENDDO
		
	ENDPROC

	PROCEDURE loadnde		&& Forms call this to load a native DE into this CDE
		LPARAMETERS oNDE
		*++
		*>>Forms call this to load a native DE into this CDE
		*--
		LOCAL oTemp, aDataObjs[1]
		  IF NOT ISNULL(m.oNDE) AND AMEMBERS(aDataObjs, m.oNDE, 2) > 0
		    ASSERT NOT m.oNDE.AutoOpenTables MESSAGE 'The DataEnvironment.AutoOpenTables properties must be set to .F. for proper operation.'
		    FOR EACH cObjName IN aDataObjs
		      m.oTemp = EVALUATE('m.oNDE.' + m.cObjName)
		      DO CASE
		        CASE m.oTemp.Baseclass == 'Cursor'
		          IF PEMSTATUS(THIS, m.oTemp.Alias, 5)
		            * Design-time error - display diagnostic message for developers.
		            * This should never happen once the app is in production.
		            IF PEMSTATUS(THIS, m.oTemp.Alias, 3) = 'Object'
		              MESSAGEBOX('LoadNDE() - Cursor "' + m.oTemp.Alias + '" already exists in CDE - remove it from the native DE.',THIS.Name)
		            ELSE
		              MESSAGEBOX('LoadNDE() - "' + m.oTemp.Alias + '" is an Invalid Workarea Name because it matches an existing Property or Method name.',THIS.Name)
		            ENDIF
		            LOOP
		          ENDIF
		          THIS.AddObject(m.oTemp.Alias, 'cmCursorCustom')
		          m.oCursor = EVALUATE('THIS.' + m.oTemp.Alias)
		          WITH m.oCursor
		            .cWorkarea = PROPER(m.oTemp.Alias)
		            .cDatabase = PROPER(SYS(2014, m.oTemp.Database))
		            .cSource = m.oTemp.CursorSource
		            .nBufferMode = m.oTemp.BufferModeOverride
		            IF NOT EMPTY(m.oTemp.Order)
		              .cOrder = m.oTemp.Order
		            ENDIF
		            IF NOT EMPTY(m.oTemp.Filter)
		              .cFilter = m.oTemp.Filter
		            ENDIF
		            IF NOT .lReadonly == m.oTemp.Readonly
		              .lReadonly = m.oTemp.Readonly
		            ENDIF
		            IF NOT .lExclusive == m.oTemp.Exclusive
		              .lExclusive = m.oTemp.Exclusive
		            ENDIF
		            IF NOT .lNoDataOnLoad = m.oTemp.NoDataOnLoad
		              .lNoDataOnLoad = m.oTemp.NoDataOnLoad
		            ENDIF
		          ENDWITH
		
		        CASE m.oTemp.Baseclass == 'Cursoradaptor'
		
		        CASE m.oTemp.Baseclass == 'Relation'
		          m.oChild = EVALUATE('THIS.' + m.oTemp.ChildAlias)
		          WITH m.oChild
		            .cParent = m.oTemp.ParentAlias
		            .cParentKeyField = m.oTemp.RelationalExpr
		            .cOrder = m.oTemp.ChildOrder    && Relational order overrides any order set for cursor
		          ENDWITH
		      ENDCASE
		    ENDFOR
		
		    * Copy relevant DE level properties now too
		    IF EMPTY(THIS.cPrimaryWorkarea) AND NOT EMPTY(m.oNDE.InitialSelectedAlias)
		      THIS.cPrimaryWorkarea = m.oNDE.InitialSelectedAlias
		    ENDIF
		
		    * Build (or Rebuild) the cursor map to include the new cursors we just added.
		    IF PEMSTATUS(THIS, 'aCursors', 5)   && Won't be there if created in design mode.
		      * Pass .T. for the lHostOnly parameter so we don't waste time rebuilding contained child maps.
		      THIS._BuildCursorMap(.T.)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE localtransbegin		&& Begin a new local transaction level.
		*++
		*>>Begin a new local transaction level.
		*--
		  THIS.nLocalTransLevel = THIS.nLocalTransLevel + 1
		
	ENDPROC

	PROCEDURE localtranscommit		&& Commit the current local transaction level for all cursors.
		LPARAMETERS nFlags
		*++
		*>>Commit the current local transaction level for all cursors.
		*--
		LOCAL ix, oCursor
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF THIS.nLocalTransLevel > 0
		    DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor, CDEMASK_ENUM_NESTED) > 0
		      IF m.oCursor.IsOpen() AND ISNULL(m.oCursor.oParent)
		        m.oCursor._LtCommit(THIS.nLocalTransLevel)
		      ENDIF
		    ENDDO
		
		    * Close the local transaction level unless caller wants to keep it active.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCLOSE))
		      THIS.nLocalTransLevel = THIS.nLocalTransLevel - 1
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE localtransrollback		&& Roll back the current local transaction level.
		LPARAMETERS nFlags
		*++
		*>>Roll back the current local transaction level.
		*--
		LOCAL ix, oCursor
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF THIS.nLocalTransLevel > 0
		    DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor, CDEMASK_ENUM_NESTED) > 0
		      IF m.oCursor.IsOpen() AND ISNULL(m.oCursor.oParent)
		        m.oCursor._LtRollback(THIS.nLocalTransLevel)
		      ENDIF
		    ENDDO
		
		    * Close the local transaction level unless caller wants to keep it active.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOCLOSE))
		      THIS.nLocalTransLevel = THIS.nLocalTransLevel - 1
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE nlocaltranslevel_access		&& Use the local transaction level of our host CDE, if we are nested inside another CDE. Otherwise, use our own value.
		*++
		*>>Use the local transaction level of our host CDE, if we are nested inside another CDE. Otherwise, use our own value.
		*
		* This means that a local transaction level started in any CDE will affect all cursors in that CDE
		* as well as cursors of any nested CDEs in the same host CDE.
		*--
		  IF NOT ISNULL(THIS.oRoot)
		    RETURN THIS.oRoot.nLocalTransLevel
		  ENDIF
		  RETURN THIS.nLocalTransLevel
		
	ENDPROC

	PROCEDURE nlocaltranslevel_assign		&& Use the local transaction level of our host CDE, if we are nested inside another CDE. Otherwise, use our own value.
		LPARAMETERS nLevel
		*++
		*>>Use the local transaction level of our host CDE, if we are nested inside another CDE. Otherwise, use our own value.
		*--
		  IF NOT ISNULL(THIS.oRoot)
		    THIS.oRoot.nLocalTransLevel = m.nLevel
		  ENDIF
		  THIS.nLocalTransLevel = m.nLevel
		
	ENDPROC

	PROCEDURE oform_access		&& Find a reference to the form that this object is a part of. Return NULL if not part of a form.
		*++
		*>>Find a reference to the form that this object is a part of. Return NULL if not part of a form.
		*--
		  IF ISNULL(THIS.oForm)
		    * Trace reference every time, rather than storing a hard ref in the oForm property.
		    IF NOT ISNULL(THIS.oDM)
		      RETURN THIS.oDM.Parent
		    ENDIF
		    RETURN .NULL.
		  ENDIF
		  RETURN THIS.oForm
		
	ENDPROC

	PROCEDURE openall		&& Open all the cursors in this data environment
		*++
		*>>Open all the cursors in this data environment
		*
		* Returns:
		*  .T. if all cursors were opened successfully, or .F. if one or more cursors could not be opened.
		*  On an error return, all cursors will be left closed.
		*--
		LOCAL ix, oCursor, oCde
		
		  * Create our Connection Manager if we don't already have one.
		  IF ISNULL(THIS.oConnMan)
		    IF NOT ISNULL(THIS.oHost)
		      * Linked and Contained child share ConnMan with host. Linked children will usually
		      * have oConnman set by AddCDE(), but oly if added after host was opened.
		      THIS.oConnMan = THIS.oHost.oConnMan
		      IF ISNULL(THIS.oConnMan)
		        ASSERT .F. MESSAGE 'Cannot call child CDE.OpenAll() before Host CDE.OpenAll()'
		        RETURN .F.
		      ENDIF
		    ELSE
		      THIS.oConnMan = CreateNewObject(THIS.cConnectionManagerClass)
		    ENDIF
		  ENDIF
		
		  * Call custom event code first, and return failure if it fails.
		  IF THIS.BeforeOpenAll()
		    * Loop through all cursors, and open them. Fail if any cursor cannot open.
		    DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor) > 0
		      IF m.oCursor.lAutoOpen
		        * Open the cursor. On open error, close all cursors and return failure.
		        IF NOT m.oCursor.Open()
		          THIS.CloseAll()
		          RETURN .F.
		        ENDIF
		
		        * The first workarea opened (in Z order) becomes default workarea, for compatibility with Native DE.
		        IF EMPTY(THIS.cPrimaryWorkarea)
		          THIS.cPrimaryWorkarea = m.oCursor.cWorkarea
		        ENDIF
		      ENDIF
		    ENDDO
		
		    * Open cursors in any nested CDE containers as well.
		    m.ix = 0
		    DO WHILE THIS.EnumCDEs(@m.ix, @m.oCde) > 0
		      IF NOT m.oCde.OpenAll()
		        THIS.CloseAll()
		        RETURN .F.
		      ENDIF
		
		      * If we have no initial default cursor yet, use the one from the first contained child that has one.
		      IF EMPTY(THIS.cPrimaryWorkarea)
		        THIS.cPrimaryWorkarea = m.oCde.cPrimaryWorkarea
		      ENDIF
		    ENDDO
		
		    THIS.lCursorsOpen = .T.
		    THIS.AfterOpenAll()
		
		    * If not a contained child (including root of a linked child tree), complete post-open processing now.
		    IF EMPTY(BITAND(THIS.nControlFlags, CDEMASK_CHILD))
		      THIS._EstablishRelations()
		    ENDIF
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE release		&& Release Data Environment, and links from all cursors back to rule objects to prevent object release deadlocks.
		*++
		*>>Release Data Environment, and links from all cursors back to rule objects to prevent object release deadlocks.
		*--
		LOCAL ix, oTarget
		  THIS.CloseAll()
		
		  * Release all contained and linked child CDEs first.
		  IF PEMSTATUS(THIS, 'aCDE', 5)
		    m.ix = 0
		    DO WHILE THIS.EnumCDEs(@m.ix, @m.oTarget) > 0
		      m.oTarget.Release()
		    ENDDO
		  ENDIF
		
		  * Clear all rule links to cursors, and release cursor map.
		  IF PEMSTATUS(THIS, 'aCursors', 5)
		    m.ix = 0
		    DO WHILE THIS.EnumCursors(@m.ix, @m.oTarget) > 0
		      WITH m.oTarget
		        .oCDE = .NULL.
		        .oDM = .NULL.
		
		        * Clear inter-links so cursor objects can be released with the cde.
		        .ClearRules()
		        .ClearChildren()
		
		        * Release root CDE property references to cursors in contained child CDEs
		        IF NOT EMPTY(BITAND(THIS.nControlFlags, CDEMASK_CHILD)) AND NOT ISNULL(THIS.oRoot)
		          IF PEMSTATUS(THIS.oRoot, m.oTarget.Name, 5)
		            STORE NULL TO ('THIS.oRoot.' + m.oTarget.Name)
		          ENDIF
		        ENDIF
		      ENDWITH
		    ENDDO
		
		    * After all are closed, clear links
		    THIS.nCursorCount = 0
		    THIS.aCursors = .NULL.
		  ENDIF
		
		  THIS.oSession = .NULL.  && VFP should release this by itself, but sometimes it doesn't...
		  THIS.oHost = .NULL.
		  THIS.oRoot = .NULL.
		  RELEASE THIS
		
	ENDPROC

	PROCEDURE removecursor		&& Remove a cursor object from the collection of cursors managed by this CDE.
		LPARAMETERS cWorkArea
		*++
		*>>Remove a cursor object from the collection of cursors managed by this CDE.
		*--
		LOCAL lExact, nCursor, cName
		
		  m.lExact = SET('EXACT') = 'ON'
		  SET EXACT ON
		  m.nCursor = ASCAN(THIS.aCursorNames, PROPER(m.cWorkarea))
		  IF NOT m.lExact
		    SET EXACT OFF
		  ENDIF
		
		  IF m.nCursor > 0
		    IF NOT ISNULL(THIS.aCursors[m.nCursor])
		      WITH THIS.aCursors[m.nCursor]
		        m.cName = .Name
		
		        * Clear backlink to CDE, and links to children and rules.
		        .ClearChildren()
		        IF NOT ISNULL(.oParent)
		          .oParent.RemoveChild(.cWorkarea)
		        ENDIF
		        IF .lAutoClose
		          .Close()
		        ENDIF
		        .ClearRules()
		        .oCDE = .NULL.
		        .oDM = .NULL.
		      ENDWITH
		    ENDIF
		
		    =ADEL(THIS.aCursors, m.nCursor)
		    =ADEL(THIS.aCursorNames, m.nCursor)
		    THIS.nCursorCount = THIS.nCursorCount - 1
		    IF THIS.nCursorCount > 0
		      DIMENSION THIS.aCursors[THIS.nCursorCount]      && Cursor obj ref array
		      DIMENSION THIS.aCursorNames[THIS.nCursorCount]  && Cursor alias name array
		    ELSE
		      THIS.aCursors = .NULL.
		      THIS.aCursorNames = .NULL.
		    ENDIF
		
		    * Physically remove the cursor object from our container.
		    IF NOT EMPTY(m.cName)
		      IF PEMSTATUS(THIS, m.cName, 5)
		        THIS.RemoveObject(m.cName)
		      ENDIF
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE revertall		&& Discard changes to all records in specified workareas, release locks, and revert to original values.
		LPARAMETERS cWorkareaList, nFlags
		*++
		*>>Discard changes to all records in specified workareas, release locks, and revert to original values.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOVALID     2    Used to supress the BeforeRevertAll() & AfterRevertAll() events
		*--
		LOCAL ix, oTarget
		
		  IF EMPTY(m.cWorkareaList) OR '*' $ m.cWorkareaList
		    m.cWorkareaList = ''
		  ENDIF
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  * BeforeRevertAll() for all CDEs in a tree is only initiated by the topmost CDE in the 
		  * tree. For child CDEs recursed into, the UPDATEMASK_NOVALID flag bit will be set.
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOVALID))
		    IF NOT THIS._TriggerEvent('BeforeRevertAll', m.cWorkareaList)
		      RETURN .F.
		    ENDIF
		
		    * If we have a DataManager, call its BeforeRevert() event now.
		    IF NOT ISNULL(THIS.oDM) AND NOT THIS.oDM.BeforeRevert(m.cWorkareaList)
		      RETURN .F.
		    ENDIF
		  ENDIF
		 
		  * We revert all eligible cursors, even if there are no visible changes. This ensures that all
		  * non-updateable view cursors are reverted, regardless of nNonUpdateableMode setting.
		  IF EMPTY(m.cWorkareaList) OR '*' $ m.cWorkareaList
		    * If no workareaList is specified, process all parent cursors.
		    DO WHILE THIS.EnumCursors(@m.ix, @m.oTarget) > 0
		      * Note that a read-only cursor may have updatable children, so dont filter them out here....
		      IF ISNULL(m.oTarget.oParent) ;
		      AND NOT m.oTarget.lIgnore AND m.oTarget.IsOpen()
		        m.oTarget.Revert()
		      ENDIF
		    ENDDO
		
		    * Revert any nested child CDEs as well.
		    m.ix = 0
		    DO WHILE THIS.EnumCDEs(@m.ix, @m.oTarget) > 0
		      m.oTarget.RevertAll('', UPDATEMASK_NOVALID)
		    ENDDO
		  ELSE
		    * An explicit list of cursors was specified. Process each one in the order listed.
		    * The GetCursor() method will find the cursor anywhere in the CDE tree below us, so
		    * we do not need to recurse the tree ourselves when we have an explict cursor list.
		    DO WHILE NOT EMPTY(m.cWorkareaList)
		      m.oTarget = THIS.GetCursor(GetToken(@m.cWorkareaList, ','))
		      IF NOT ISNULL(oTarget) AND m.oTarget.IsOpen()
		        m.oTarget.Revert()
		      ENDIF
		    ENDDO
		  ENDIF
		
		  * Trigger the various levels of AfterRevertAll() events now.
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOVALID))
		    THIS._TriggerEvent('AfterRevertAll', m.cWorkareaList)
		    IF NOT ISNULL(THIS.oDM) 
		      THIS.oDM.AfterRevert(m.cWorkareaList)
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE setinitialpositions		&& Set the initial record positions for all open parent tables. Called for root CDE on completion of OpenAll(), or from DM.Init() for CDEs linked to data forms.
		*++
		*>>Set the initial record positions for all open parent tables. Called for root CDE on completion of OpenAll(), or from DM.Init() for CDEs linked to data forms.
		*
		* CM 8.0 - For consistent operation in all cases, this method is now also responsible for 
		* triggering the AfterOpenAll2() & 3 events.
		*
		* Note that when this method is called, the THIS.oDM reference will only be non-null if called from 
		* the DM Init() code.
		*--
		LOCAL ix, oCursor
		
		  * Trigger AfterOpenAll2() CDE event for ourself and all contained child CDEs (shouldn't be any linked children yet).
		  THIS._TriggerEvent('AfterOpenAll2')
		
		  * Set initial record position for topmost parent cursors that are part of this CDE container tree.
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor, CDEMASK_ENUM_NESTED) > 0
		    IF m.oCursor.IsOpen()
		      * Re-execute these events for rules contained in DM only, because they missed the original event.
		      IF NOT ISNULL(THIS.oDM)
		        m.oCursor._CallAfterOpen(RULEMASK_DM_ONLY)
		      ENDIF
		
		      IF ISNULL(m.oCursor.oParent)
		        IF NOT ISNULL(THIS.oDM) 
		          * Implement form record-position memory if we have a form DM available.
		          THIS.oDM.SetInitialPosition(m.oCursor.cWorkarea)
		        ENDIF
		
		        * This will normally trigger the first call to the AfterNav() event for the cursor.
		        * It will also select the recordsets for any related child cursors.
		        m.oCursor.RecordWasMoved()
		      ENDIF
		    ENDIF
		  ENDDO
		
		  * Make the primary cursor the current workarea, if we are the root CDE.
		  IF NOT EMPTY(THIS.cPrimaryWorkarea) AND ISNULL(THIS.oHost)
		    m.oCursor = THIS.GetCursor(THIS.cPrimaryWorkarea)
		    ASSERT NOT ISNULL(m.oCursor) MESSAGE THIS.Name + '.cPrimaryWorkarea Alias not found: ' + THIS.cPrimaryWorkarea
		    IF NOT ISNULL(m.oCursor)
		      m.oCursor.SetDefault()
		    ENDIF
		  ENDIF
		
		  * Trigger the last CDE AfterOpen() event (3), once all open operations are complete.
		  THIS._TriggerEvent('AfterOpenAll3')
		  RETURN .T.
		
	ENDPROC

	PROCEDURE unlinkdm		&& UnLink this CDE from a form Data manager object.
		LPARAMETERS oDM
		*++
		*>>UnLink this CDE from a form Data manager object.
		*--
		LOCAL ix, oTarget
		
		  * Unlink DM from any nested CDEs as well.
		  DO WHILE THIS.EnumCDEs(@m.ix, @m.oTarget) > 0
		    m.oTarget.UnLinkDM(m.oDM)
		  ENDDO
		
		  * Force-Trigger the BeforeClose() rule event for all rule objects contained in 
		  * the DM before unlinking.
		  m.ix = 0
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oTarget) > 0
		    IF NOT ISNULL(m.oTarget) AND m.oTarget.lAutoClose AND m.oTarget.IsOpen()
		      m.oTarget._ExecuteRule('BeforeClose', RULEMASK_ANDED + RULEMASK_DM_ONLY)
		    ENDIF
		  ENDDO
		
		  * Loop through all DM level rule objects, and unlink from cursors.
		  FOR EACH oRule IN m.oDM.Controls
		    IF m.oRule.Baseclass == 'Container' AND PROPER(m.oRule.cClass) == 'Cmrule'
		      m.oRule.UnLink(THIS, .T.)
		    ENDIF
		  ENDFOR
		
		  * Clear backlink to DM from ourself and all our cursors.
		  m.ix = 0
		  THIS.oDM = .NULL.
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oTarget) > 0
		    m.oTarget.oDM = .NULL.
		  ENDDO
		
	ENDPROC

	PROCEDURE updateall		&& Write all buffered changes in all workareas to disk for the specified cursors.
		LPARAMETERS cWorkareaList, nFlags
		*++
		*>>Write all buffered changes in all workareas to disk for the specified cursors.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOVALID         2    Don't validate first.
		*    UPDATEMASK_NOCHILDREN     4  Don't process related child cursors.
		*--
		LOCAL lStatus, ix, oTarget
		
		  IF EMPTY(m.cWorkareaList) OR '*' $ m.cWorkareaList
		    m.cWorkareaList = ''
		  ENDIF
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		
		  * All modified cursors must pass validation rules before update may proceed. Validation
		  * for all CDEs in a tree is only initiated by the topmost CDE in the tree. For child 
		  * CDEs recursed into, the UPDATEMASK_NOVALID flag bit will be set.
		  IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOVALID))
		    IF NOT THIS.ValidateAll(m.cWorkareaList) ;
		    OR NOT THIS._TriggerEvent('BeforeUpdateAll', m.cWorkareaList)
		      RETURN .F.
		    ENDIF
		 
		    * If we have a DataManager, call its BeforeUpdate() event now, after validation is complete.
		    * The DM BeforeUpdate() event behaves similarly to a BeofreUpdateAll() event, in that it
		    * is triggered only once per cde.UpdateAll(), not once for each cursor.
		    IF NOT ISNULL(THIS.oDM) AND NOT THIS.oDM.BeforeUpdate(m.cWorkareaList)
		      RETURN .F.
		    ENDIF
		  ENDIF
		
		  * Start a transaction if none is already active.
		  THIS.oConnMan.BeginTrans()
		  m.lStatus = .T.
		
		  * Call Update() for each eligible cursor with outstanding changes. Note that the nNonUpdateableMode 
		  * setting determines whether or not update() will be called for non-updateable views with changes.
		  IF EMPTY(m.cWorkareaList)
		    * If no workareaList is specified, process all parent cursors.
		    m.ix = 0
		    DO WHILE m.lStatus AND THIS.EnumCursors(@m.ix, @m.oTarget) > 0
		      * Note that a read-only cursor may have updatable children, so dont filter them out here....
		      IF ISNULL(m.oTarget.oParent) ;
		      AND NOT m.oTarget.lIgnore AND m.oTarget.IsOpen() AND m.oTarget.IsChanged()
		        m.lStatus = m.oTarget.Update(BITOR(m.nFlags, UPDATEMASK_NOVALID))
		      ENDIF
		    ENDDO
		
		    * Update data in any nested CDEs too.
		    m.ix = 0
		    DO WHILE m.lStatus AND THIS.EnumCDEs(@m.ix, @m.oTarget) > 0
		      m.lStatus = m.oTarget.UpdateAll('', BITOR(m.nFlags, UPDATEMASK_NOVALID))
		    ENDDO
		  ELSE
		    * An explicit list of cursors was specified. Process each one in the order listed.
		    * The GetCursor() method will find the cursor anywhere in the CDE tree below us, so
		    * we do not need to recurse the tree ourselves when we have an explict cursor list.
		    DO WHILE NOT EMPTY(m.cWorkareaList) AND m.lStatus
		      m.oTarget = THIS.GetCursor(GetToken(@m.cWorkareaList, ','))
		      IF NOT ISNULL(oTarget) AND m.oTarget.IsOpen() AND m.oTarget.IsChanged()
		        m.lStatus = m.oTarget.Update(BITOR(m.nFlags, UPDATEMASK_NOVALID))
		      ENDIF
		    ENDDO
		  ENDIF
		
		  IF m.lStatus
		    * Commit the transaction (or merge with previous active transaction level).
		    THIS.oConnMan.CommitTrans()
		
		    * Trigger the various levels of AfterUpdateAll() events now.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOVALID))
		      THIS._TriggerEvent('AfterUpdateAll', m.cWorkareaList)
		      IF NOT ISNULL(THIS.oDM) 
		        THIS.oDM.AfterUpdate(m.cWorkareaList)
		      ENDIF
		    ENDIF
		  ELSE
		    THIS.oConnMan.RollbackTrans()
		
		    * Trigger the various levels of AfterUpdateFailure() events now.
		    IF EMPTY(BITAND(m.nFlags, UPDATEMASK_NOVALID))
		      THIS._TriggerEvent('AfterUpdateAllFailure', m.cWorkareaList)
		      IF NOT ISNULL(THIS.oDM) 
		        THIS.oDM.AfterUpdateFailure(m.cWorkareaList)
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN m.lStatus
		
	ENDPROC

	PROCEDURE validateall		&& Execute the RowValid() and CursorValid() rules for all cursors in this with uncommited changes, in this or any child CDE.
		LPARAMETERS cWorkareaList, nFlags
		*++
		*>>Execute the RowValid() and CursorValid() rules for all cursors in this with uncommited changes, in this or any child CDE.
		*
		* The nFlags parameter contains a bitmask of option flags.
		*    UPDATEMASK_NOCHILDREN     4  Don't validate related child cursors (passed on to cursors).
		*--
		LOCAL ix, oCursor, oCDE
		
		  m.nFlags = IIF(EMPTY(m.nFlags), 0, m.nFlags)
		  IF EMPTY(m.cWorkareaList) OR '*' $ m.cWorkareaList
		    * If no workareaList is specified, process all parent cursors.
		    DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor) > 0
		      * Note that a read-only cursor may have updatable children, so dont filter them out here....
		      IF ISNULL(m.oCursor.oParent) ;
		      AND NOT m.oCursor.lIgnore AND m.oCursor.IsOpen()
		        IF NOT m.oCursor.ValidateCursor(m.nFlags)
		          RETURN .F.
		        ENDIF
		      ENDIF
		    ENDDO
		
		    * Validate all cursors in nested child CDEs now also.
		    m.ix = 0
		    DO WHILE THIS.EnumCDEs(@m.ix, @m.oCDE) > 0
		      IF NOT m.oCDE.ValidateAll('', m.nFlags)
		        RETURN .F.
		      ENDIF
		    ENDDO
		  ELSE
		    * An explicit list of cursors was specified. Process each one in the order listed.
		    * The GetCursor() method will find the cursor anywhere in the CDE tree below us, so
		    * we do not need to recurse the tree ourselves when we have an explict cursor list.
		    DO WHILE NOT EMPTY(m.cWorkareaList)
		      m.oCursor = THIS.GetCursor(GetToken(@m.cWorkareaList, ','))
		      IF NOT ISNULL(oCursor) AND m.oCursor.IsOpen()
		        IF NOT m.oCursor.ValidateCursor(m.nFlags)
		          RETURN .F.
		        ENDIF
		      ENDIF
		    ENDDO
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE _buildcursormap		&& Build a quick lookup array to map all workarea alias names to their Cursor objects.
		LPARAMETERS lHostOnly
		*++
		*>>Build a quick lookup array to map all workarea alias names to their Cursor objects.
		*
		* This array provides a fast way to locate the object responsible for 
		* managing each managed cursor.
		*--
		LOCAL ix, oCursor, oCDE
		
		  FOR EACH oCursor IN THIS.Controls
		    IF m.oCursor.BaseClass == 'Container' AND PROPER(m.oCursor.cClass) == 'Cmcursor'
		      IF NOT BITTEST(m.oCursor.nCursorFlags, CURSORFLAG_MAPPED)
		        * Link the cursor into the cursor map, and link any rule objects to it as well.
		        THIS._LinkCursor(m.oCursor, 0)
		
		        * If this is a cursor in a contained child CDE, add a direct object ref from the Root CDE.
		        IF NOT EMPTY(BITAND(THIS.nControlFlags, CDEMASK_CHILD)) AND NOT ISNULL(THIS.oRoot)
		          IF NOT PEMSTATUS(THIS.oRoot, m.oCursor.Name, 5)
		            THIS.oRoot.AddProperty(m.oCursor.Name, m.oCursor)
		          ENDIF
		        ENDIF
		
		        * Set flag so this cursor won't be added again if we are called twice.
		        m.oCursor.nCursorFlags = BITSET(m.oCursor.nCursorFlags, CURSORFLAG_MAPPED)
		      ENDIF
		    ENDIF
		  ENDFOR
		
		  * Build the map for all our contained child CDE's also (but not linked children).
		  IF NOT m.lHostOnly
		    DO WHILE THIS.EnumCDEs(@m.ix, @m.oCde) > 0
		      IF NOT EMPTY(BITAND(m.oCDE.nControlFlags, CDEMASK_CHILD))
		        m.oCde._BuildCursorMap()
		      ENDIF
		    ENDDO
		  ENDIF
		
	ENDPROC

	PROCEDURE _establishrelations		&& After all cursors are open, establish any defined relations between them.
		*++
		*>>After all cursors are open, establish any defined relations between them.
		*
		* This is called only for a root parent CDE, which in turn processes all contained child CDEs.
		*--
		LOCAL ix, oCursor, oCde
		
		  DO WHILE THIS.EnumCursors(@m.ix, @m.oCursor, CDEMASK_ENUM_NESTED) > 0
		    IF m.oCursor.lAutoOpen
		      * If there is a design-time relation, and it hasn't been resolved yet, do it now.
		      IF NOT EMPTY(m.oCursor.cParent) AND ISNULL(m.oCursor.oParent)
		        IF ISNULL(THIS.oRoot)
		          m.oParent = THIS.GetCursor(m.oCursor.cParent)
		        ELSE
		          * Ref the topmost parent (linked or contained) CDE here, so a parent 
		          * cursor will be found anywhere in the CDE tree.
		          m.oParent = THIS.oRoot.GetCursor(m.oCursor.cParent)
		        ENDIF
		        IF ISNULL(m.oParent) OR NOT m.oParent.AddChild(m.oCursor, m.oCursor.cParentKeyField)
		          * Fatal error occured - most often means parent cursor was not found, or not open yet.
		          ASSERT .F. MESSAGE 'OpenAll() - Unable to set Relation Between "' + m.oCursor.cWorkarea + '" and "' + m.oCursor.cParent + '"'
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDDO
		
		  * If we are called from a DataForm.load() event, we do not set initial record 
		  * positions until InitRelations() is called when the DataManager initializes.
		  * Note that CDEMASK_DATAFORM should never be set for linked child CDEs added at runtime,
		  * so those will call SetInitialPositions() here directly.
		  IF NOT THIS.lDmSetsInitialPositions OR EMPTY(BITAND(THIS.nControlFlags, CDEMASK_DATAFORM))
		    * Not in a data form, linked child root, or form wants us to set initial positions early.
		    THIS.SetInitialPositions()  && Also triggers the AfterOpenAll3() event
		  ENDIF
		
	ENDPROC

	PROCEDURE _getcdebyindex		&& Internal recursive method to get a reference to the next CDE in the tree being enumerated.
		LPARAMETERS oCDE, nTarget, nIndex
		*++
		*>>Internal recursive method to get a reference to the next CDE in the tree being enumerated.
		*--
		LOCAL ix, oChild
		
		  * nIndex parameter may be ommitted from initial call. It is used by recursive calls. 
		  m.nIndex = IIF(EMPTY(m.nIndex), 0, m.nIndex)
		
		  * If this is the one we want, return success
		  IF m.nIndex = m.nTarget
		    m.oCDE = THIS
		    RETURN m.oCDE
		  ENDIF
		
		  * Move to the nextsequential CDE index number. Note this variable 
		  * is passed by reference through all recursion levels.
		  m.nIndex = m.nIndex + 1
		
		  * Process any child CDEs below us.
		  FOR ix = 1 TO THIS.nCdeCount
		    m.oChild = THIS.aCDE[m.ix]
		    IF NOT ISNULL(m.oChild)
		      IF NOT ISNULL(m.oChild._GetCdeByIndex(@m.oCDE, m.nTarget, @m.nIndex))
		        RETURN m.oCDE
		      ENDIF
		    ENDIF
		  ENDFOR
		  RETURN .NULL.
		
	ENDPROC

	PROCEDURE _linkcursor		&& Internal method to link cursor into the cursor map array.
		LPARAMETERS oCursor, nFlags
		*++
		*>>Internal method to link cursor into the cursor map array.
		* Used by _BuildCursorMap() and AddCursor() methods.
		*
		* nFlags bit values:
		*   CDEMASK_NORULES  - Don't link rules
		*--
		LOCAL oCDE
		  m.oCursor.oCDE = THIS                             && Add backlink to this CDE
		  m.oCursor.oDM = THIS.oDM                          && Add backlink to our Data Manager (if any)
		
		  * Add the cursor object to our cursor map array.
		  THIS.nCursorCount = THIS.nCursorCount + 1
		  DIMENSION THIS.aCursors[THIS.nCursorCount]        && Cursor obj ref array
		  DIMENSION THIS.aCursorNames[THIS.nCursorCount]    && Cursor alias name array
		  THIS.aCursorNames[THIS.nCursorCount] = PROPER(m.oCursor.cWorkarea)
		  THIS.aCursors[THIS.nCursorCount] = m.oCursor
		
		  IF NOT ISNULL(THIS.oRoot)
		  ENDIF
		
		  * Link in any matching rule objects contained in the CDE or DM
		  IF NOT BITTEST(m.nFlags, CDEMASK_NORULES)
		    * Link matching rules in this CDE, and any parent CDE we are contained in.
		    THIS._LinkRulesToCursor(m.oCursor, THIS)
		    m.oCDE = THIS
		    DO WHILE NOT EMPTY(BITAND(m.oCDE.nControlFlags, CDEMASK_CHILD))
		      THIS._LinkRulesToCursor(m.oCursor, m.oCDE.Parent)
		      m.oCDE = m.oCDE.Parent
		    ENDDO
		
		    IF NOT ISNULL(THIS.oDM)
		      THIS._LinkRulesToCursor(m.oCursor, THIS.oDM)
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE _linkrulestocursor		&& Internal method used to link rule objects to a cursor.
		LPARAMETERS oCursor, oSource
		*++
		*>>Internal method used to link rule objects to a cursor.
		*--
		LOCAL oRule, cWorkarea
		
		  m.cWorkarea = PROPER(m.oCursor.cWorkarea)
		  FOR EACH oRule IN m.oSource.Controls
		    WITH oRule
		      IF .Baseclass == 'Container' AND PROPER(.cClass) == 'Cmrule'
		        IF .cWorkarea = '*' OR m.cWorkarea + ',' $ .cWorkarea + ','
		          m.oCursor.AddRule(m.oRule)
		        ENDIF
		      ENDIF
		    ENDWITH
		  ENDFOR
		
	ENDPROC

	PROCEDURE _triggerevent		&& Recursive method to trigger the specified event in this CDE, and all contained child CDEs.
		LPARAMETERS cEventName, cParameter
		*++
		*>>Recursive method to trigger the specified event in this CDE, and all contained child CDEs.
		*--
		LOCAL ix, oCde
		  DO WHILE THIS.EnumCDEs(@m.ix, @m.oCde) > 0
		    m.oCde._TriggerEvent(m.cEventName, m.cParameter)
		  ENDDO
		  IF EMPTY(m.cParameter)
		    RETURN EVALUATE('THIS.' + m.cEventName + '()')
		  ELSE
		    RETURN EVALUATE('THIS.' + m.cEventName + '(m.cParameter)')
		  ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmdatamanager AS cmruleabstract OF "..\common\cmdataa.vcx" 		&& CodeMine Form Data Manager class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_DM.bmp" ClassIcon="..\graphics\_DM.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: addcursor		&& Add a new cursor to the Data Manager's list of managed cursors.
		*m: afteropenall		&& Called on startup after CDE is linked to data manager, and all cursors are open.
		*m: afterrevert		&& AfterRevert rule event occurs after changes are discarded.
		*m: afterupdate		&& AfterUpdate event occurs after all changes have been saved to source tables.
		*m: afterupdatefailure		&& AfterUpdateFailure event occurs after an error occurs preventing successful completion of UpdateAll().
		*m: beforecloseall		&& Called on form close, just before CDE is unlinked from data manager, and cursors are closed.
		*m: beforerevert		&& BeforeRevert rule event occurs before changes are discarded.
		*m: beforeupdate		&& BeforeUpdate event occurs before all changes are saved to source tables. Return .F. to prevent update.
		*m: getboundcontrol		&& Find a reference to the first control in the specified container that is bound to the specified field.
		*m: initrelations		&& Allow manual setting of relations not specified in cursor properties at design time.
		*m: inspectordetails		&& Display object-specific debugging information in the Codemine object inspector.
		*m: linkcde		&& Find the main CDE and store a link to it. Also link DM rule objects to their target cursors.
		*m: nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*m: nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		*m: queueuirefresh		&& Queue a refresh for UI controls bound to the specified field in this cursor.
		*m: refreshcontents		&& Recursive method to refresh bound controls in the specified container.
		*m: refreshui		&& Refresh User Interface controls that are bound to cursor fields that have been modified by the Replace() method.
		*m: registernavcontrol		&& Register a navigation control for record add/delete notification.
		*m: requery		&& Requery the specified view, or all managed views if none specified.
		*m: resetoptimization		&& Reset cursor optimization for IsReadonly(), so it only needs to be evaluated once per refresh cycle.
		*m: saveorder		&& Save the current index order of top parent tables, if form.lRememberOrder is set.
		*m: saveposition		&& Save the current record position of top parent cursors, if form.lRememberRecord is set.
		*m: setactivechildform		&& Store a reference to the currently active child form, and return reference to previously active child.
		*m: setcursor		&& Set values for certain cursor properties. Mostly for backward compatibility - better to set cursor properties directly.
		*m: setfocusfield		&& Find the first control in the host form that is bound to the specified field, and set focus to it.
		*m: setinitialposition		&& Set the initial record position for the specified cursor. Called on startup, once for each cursor in the CDE.
		*m: setrecordposition		&& Alternate interface for RecordWasMoved() method, for compatibility with previous versions of CodeMine.
		*m: unlinkcde		&& Unlink the specified CDE from the Data Manager.
		*m: unregisternavcontrols		&& Un-Register all navigation controls contained in the specified form.
		*m: updatenavcontrols		&& Update all registered navigation controls by calling the specified method.
		*p: cclass
		*p: cversion		&& Data Manager class version number
		*p: loverwrite		&& Set to .T. to overwrite other users changes on update collisions, .F. to prompt user on overwrite condition. Leave .NULL. to use individual cursor setting.
		*p: lrecyclerecords		&& Determines if deleted records in cursors based on native VFP tables are reused as new records are added. Leave .NULL. to use individual cursor setting.
	*</DefinedPropArrayMethod>

	backcolor = 231,186,124
	cclass = cmDataManager
	cversion = 7.0.0		&& Data Manager class version number
	loverwrite = .NULL.		&& Set to .T. to overwrite other users changes on update collisions, .F. to prompt user on overwrite condition. Leave .NULL. to use individual cursor setting.
	lrecyclerecords = .NULL.		&& Determines if deleted records in cursors based on native VFP tables are reused as new records are added. Leave .NULL. to use individual cursor setting.
	Name = "cmdatamanager"
	
	PROCEDURE addcursor		&& Add a new cursor to the Data Manager's list of managed cursors.
		LPARAMETERS uCursor, cParentAlias, cParentKeyExpr
		*++
		*>>Add a new cursor to the Data Manager's list of managed cursors.
		*
		* This allows for forms that manualy open tables in the Load or Init() method 
		* instead of using a data environment.
		*--
		LOCAL oCursor, oParent
		  m.oCursor = THIS.oCDE.AddCursor(m.uCursor)
		
		  * If we are a child in a relation, set the relation
		  IF NOT EMPTY(m.cParentAlias)
		    * Note that Child tables must have the order set to the correct FK index.
		    m.oParent = THIS.oCDE.GetCursor(@m.cParentAlias)
		    ASSERT NOT ISNULL(m.oParent) MESSAGE 'DM.AddCursor() - Parent "' + m.cParentAlias + '" not found for "' + m.uCursor + '"'
		    IF NOT ISNULL(m.oParent)
		      m.oParent.AddChild(m.oCursor, m.cParentKeyExpr)
		    ENDIF
		  ENDIF
		  RETURN m.oCursor
		
	ENDPROC

	PROCEDURE afteropenall		&& Called on startup after CDE is linked to data manager, and all cursors are open.
		*++
		*>>Called on startup after CDE is linked to data manager, and all cursors are open.
		*--
		
	ENDPROC

	PROCEDURE afterrevert		&& AfterRevert rule event occurs after changes are discarded.
		LPARAMETERS cWorkareaList, lCurrentRecordOnly
		*++
		*>>AfterRevert rule event occurs after changes are discarded.
		* DM level rule accepts optional Workarea list, whereas rule object level accepts a single workarea.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterupdate		&& AfterUpdate event occurs after all changes have been saved to source tables.
		LPARAMETERS cWorkareaList, lCurrentRecordOnly
		*++
		*>>AfterUpdate event occurs after all changes have been saved to source tables.
		* DM level rule accepts optional Workarea list, whereas rule object level accepts a single workarea.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterupdatefailure		&& AfterUpdateFailure event occurs after an error occurs preventing successful completion of UpdateAll().
		LPARAMETERS cWorkareaList, lCurrentRecordOnly
		*++
		*>>AfterUpdateFailure event occurs after an error occurs preventing successful completion of UpdateAll().
		* DM level rule accepts optional Workarea list, whereas rule object level accepts a single workarea.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforecloseall		&& Called on form close, just before CDE is unlinked from data manager, and cursors are closed.
		*++
		*>>Called on form close, just before CDE is unlinked from data manager, and cursors are closed.
		*--
		
	ENDPROC

	PROCEDURE beforerevert		&& BeforeRevert rule event occurs before changes are discarded.
		LPARAMETERS cWorkareaList, lCurrentRecordOnly
		*++
		*>>BeforeRevert rule event occurs before changes are discarded.
		* DM level rule accepts optional Workarea list, whereas rule object level accepts a single workarea.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeupdate		&& BeforeUpdate event occurs before all changes are saved to source tables. Return .F. to prevent update.
		LPARAMETERS cWorkareaList, lCurrentRecordOnly
		*++
		*>>BeforeUpdate event occurs before all changes are saved to source tables. Return .F. to prevent update.
		* DM level rule accepts optional Workarea list, whereas rule object level accepts a single workarea.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE getboundcontrol		&& Find a reference to the first control in the specified container that is bound to the specified field.
		LPARAMETERS oContainer, cField, oTarget
		*++
		*>>Find a reference to the first control in the specified container that is bound to the specified field.
		*
		* May be called recursively for nested containers. Returns .T. when a matching control is found.
		*--
		LOCAL oCtl
		  FOR EACH oCtl IN m.oContainer.Controls
		    * Only Consider enabled, visible controls. Keep each PEMSTATUS on its own line, since it is tempermental.
		    IF NOT PEMSTATUS(m.oCtl, 'Enabled', 5)  && Dont process anything without an enabled property.
		      LOOP
		    ENDIF
		    IF NOT m.oCtl.Enabled
		      LOOP
		    ENDIF
		    IF PEMSTATUS(m.oCtl, 'Visible', 5)      && Pages dont have visible, but we still process them
		      IF NOT m.oCtl.Visible
		        LOOP
		      ENDIF
		    ENDIF
		
		    DO CASE
		      CASE m.oCtl.BaseClass == 'Container'
		        IF THIS.GetBoundControl(m.oCtl, @m.cField, @m.oTarget)
		          RETURN .T.
		        ENDIF
		
		      CASE m.oCtl.BaseClass == 'Pageframe'
		        LOCAL nPage, nCurrPage
		        * Check the current page first, just in case multiple pages have matching controls.
		        m.nCurrPage = m.oCtl.PageOrderToIndex(m.oCtl.ActivePage)
		        IF THIS.GetBoundControl(m.oCtl.Pages[m.nCurrPage], @m.cField, @m.oTarget)
		          RETURN .T.
		        ENDIF
		        FOR nPage = 1 TO m.oCtl.PageCount
		          IF m.nPage != m.nCurrPage AND m.oCtl.Pages[m.nPage].Enabled = .T. ;
		          AND THIS.GetBoundControl(m.oCtl.Pages[m.nPage], @m.cField, @m.oTarget)
		            RETURN .T.
		          ENDIF
		        ENDFOR
		
		      CASE m.oCtl.BaseClass == 'Grid'
		        LOCAL oCol
		        FOR EACH oCol IN m.oCtl.Columns
		          IF NOT m.oCol.ReadOnly AND m.oCol.Enabled ;
		          AND THIS.GetBoundControl(m.oCol, @m.cField, @m.oTarget)
		            RETURN .T.
		          ENDIF
		        ENDFOR
		
		      CASE PEMSTATUS(m.oCtl, 'cValueSource', 5)
		        IF NOT m.oCtl.lReadOnly AND PROPER(m.oCtl.cValueSource) == m.cField
		          m.oTarget = m.oCtl
		          RETURN .T.
		        ENDIF
		    ENDCASE
		  ENDFOR
		  RETURN .F.    && No matching control found in this container
		
	ENDPROC

	PROCEDURE init
		LPARAMETERS lNoZorderTest
		*++
		* Manage internal hierarchy of cursor data objects from data environment definitions.
		*
		* Copyright 2000,2001 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		LOCAL oCtl
		  * Create runtime-only properties now. These are not available at design time.
		  DODEFAULT()
		  THIS.AddProperty('nNavCount', 0)
		  THIS.AddProperty('aNavControls[1,3]')
		  THIS.AddProperty('cRefreshFieldList', '')
		  THIS.AddProperty('cRefreshWorkareaList', '')
		
		  * Make sure we are at the top of the form's Z-order, ie DM is inited before any data-bound control.
		  * We must be named "cmDataManager", or the form wont be able to find us.
		  ASSERT PROPER(THIS.Name) == 'Cmdatamanager' MESSAGE 'Form Data Manager instance must be named "cmDataManager"'
		  IF NOT m.lNoZorderTest
		    FOR EACH oCtl IN THISFORM.Controls
		      IF m.oCtl.Name == THIS.Name
		        EXIT
		      ENDIF
		      IF NOT m.oCtl.BaseClass $ 'Dataenvironment,Label,Shape,Line,Image,Custom'
		        IF PEMSTATUS(m.oCtl, 'cClass', 5)
		          IF PROPER(m.oCtl.cClass) == PROPER('CmBindingManager')
		            LOOP    && Binding Manager is OK.
		          ENDIF
		        ENDIF
		        MESSAGEBOX('cmDataManager must be first in Z order, "Send to Back" in form/class designer', 48, THISFORM.Caption)
		        EXIT
		      ENDIF
		    ENDFOR
		  ENDIF
		
		  * One way or another, our CDE will be initialized at this point.
		  IF THIS.LinkCDE()
		    * Set default form cWorkarea from Data Environment property, if none is explicitly specified.
		    IF EMPTY(THISFORM.cWorkarea)
		      THISFORM.cWorkarea = PROPER(THIS.oCDE.cPrimaryWorkarea)
		    ENDIF
		    IF EMPTY(THISFORM.cNavWorkarea)
		      THISFORM.cNavWorkarea = THISFORM.cWorkarea
		    ENDIF
		
		    * Add any custom programatic cursor relations. This call is mostly for 
		    * backward compatibility, as the CDE.AfterOpenAll() would be a better 
		    * place to set additional relations if necessary.
		    THIS.InitRelations()
		
		    * Set the initial record positions for all open parent cursors, unless CDE doesnt want us to.
		    IF THIS.oCDE.lDmSetsInitialPositions
		      THIS.oCDE.SetInitialPositions()
		    ENDIF
		    THIS.AfterOpenAll()
		
		    * Make sure the desired form workarea is selected before returning. Note that this will
		    * override the cPrimaryWorkarea property of the CDE, if different.
		    IF NOT EMPTY(THISFORM.cWorkarea) AND NOT PROPER(THISFORM.cWorkarea) == PROPER(THIS.oCDE.cPrimaryWorkarea)
		      THIS.SetDefault(THISFORM.cWorkarea)
		    ENDIF
		  ENDIF
		  RETURN .T.
		
	ENDPROC

	PROCEDURE initrelations		&& Allow manual setting of relations not specified in cursor properties at design time.
		*++
		*>>Allow manual setting of relations not specified in cursor properties at design time.
		* Developer subclasses could also call THIS.SetCursor() here to change default RI properties.
		*
		* Mostly used for backward compatibility. CDE.AfterOpenAll() is the preferred 
		* place to set programatic relations.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE inspectordetails		&& Display object-specific debugging information in the Codemine object inspector.
		LPARAMETERS oNodes, cRoot
		*++
		*>>Display object-specific debugging information in the Codemine object inspector.
		*--
		  IF VARTYPE(THIS.oCDE) = 'O'
		    THIS.oCDE.InspectorDetails(m.oNodes, m.cRoot)
		  ENDIF
		
	ENDPROC

	PROCEDURE linkcde		&& Find the main CDE and store a link to it. Also link DM rule objects to their target cursors.
		*++
		*>>Find the main CDE and store a link to it. Also link DM rule objects to their target cursors.
		*--
		  IF NOT ISNULL(THISFORM.oCDE)
		    * Keep a direct reference to the primary CDE for the form.
		    THIS.oCDE = THISFORM.oCDE
		
		    * CDE also needs a link back to this Data Manager.
		    THISFORM.oCDE.LinkDM(THIS)
		    RETURN .T.
		  ENDIF
		  ASSERT .F. MESSAGE "No CDE was found for this form. Reset the form's cDataEnvironment property to its default value"
		  RETURN .F.
		
	ENDPROC

	PROCEDURE nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*++
		*>>Return the nErrorMode value from the highest level available container.
		*--
		  * DM object uses CDE property, if available.
		  IF NOT ISNULL(THIS.oCDE)
		    RETURN THIS.oCDE.nErrorMode
		  ENDIF
		  RETURN THIS.nErrorMode
		
	ENDPROC

	PROCEDURE nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		LPARAMETERS nValue
		*++
		*>>Set the nErrorMode property in the highest level available container.
		*--
		  * DM object uses CDE property, if available.
		  IF NOT ISNULL(THIS.oCDE)
		    THIS.oCDE.nErrorMode = m.nValue
		  ELSE
		    THIS.nErrorMode = m.nValue
		  ENDIF
		
	ENDPROC

	PROCEDURE queueuirefresh		&& Queue a refresh for UI controls bound to the specified field in this cursor.
		LPARAMETERS cFieldWithAlias
		*++
		*>>Queue a refresh for UI controls bound to the specified field in this cursor.
		*
		* If this cursor is managed by a form data manager, and the field is displayed in 
		* a bound control on the form, tell the data manager that the conrol needs refreshing.
		*--
		LOCAL cWorkarea
		  * Maintain a list of fields and workareas modified, so we can refresh bound controls when finished.
		  IF NOT EMPTY(m.cFieldWithAlias)
		    m.cFieldWithAlias = PROPER(cFieldWithAlias) + ','
		    IF NOT m.cFieldWithAlias $ THIS.cRefreshFieldList
		      THIS.cRefreshFieldList = THIS.cRefreshFieldList + m.cFieldWithAlias
		    ENDIF
		    m.cWorkarea = LEFT(m.cFieldWithAlias, AT('.', m.cFieldWithAlias) - 1) + ','
		    IF NOT m.cWorkarea $ THIS.cRefreshWorkareaList
		      THIS.cRefreshWorkareaList = THIS.cRefreshWorkareaList + m.cWorkarea
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE refreshcontents		&& Recursive method to refresh bound controls in the specified container.
		LPARAMETERS oContainer
		*++
		*>>Recursive method to refresh bound controls in the specified container.
		*--
		LOCAL ix, oThis
		
		  FOR ix = 1 TO m.oContainer.ControlCount
		    m.oThis = m.oContainer.Controls[m.ix]
		    DO CASE
		      CASE m.oThis.BaseClass == 'Container'
		        THIS.RefreshContents(m.oThis)
		
		      CASE m.oThis.BaseClass == 'Pageframe'
		        * Refresh only the active page in a pageframe. Other page 
		        * contents will refresh when their page is activated.
		        LOCAL nPage
		        FOR nPage = 1 TO m.oThis.PageCount
		          IF m.oThis.Pages[m.nPage].PageOrder = m.oThis.ActivePage
		            THIS.RefreshContents(m.oThis.Pages[m.nPage])
		            EXIT
		          ENDIF
		        ENDFOR
		
		      CASE m.oThis.BaseClass == 'Grid'
		        LOCAL nCol
		        FOR nCol = 1 TO m.oThis.ColumnCount
		          THIS.RefreshContents(m.oThis.Columns[m.nCol])
		        ENDFOR
		
		      CASE PEMSTATUS(m.oThis, 'cValueSource', 5)
		        * It is possible (usually via manual SetValue() calls) to trigger this before controls have initialized.
		        * In this case, we do not do the refresh, since they will be refreshed when they finish initialization.
		        IF PEMSTATUS(m.oThis, 'nControlFlags', 5)
		          WITH m.oThis
		            * Note that this will only find controls with alias specified in cValueSource,
		            * or an empty cValuesource, with non-empty cWorkarea (useful for refreshing 
		            * read-only fields displaying expressions).
		            * This will also refresh current row of any nav controls to reflect current data.
		            IF NOT EMPTY(.cWorkarea) AND PROPER(.cValueSource) + ',' $ THIS.cRefreshFieldList
		              * Set flag in the target ctl to prevent possible recursion.
		              IF NOT BITTEST(.nControlFlags, CTLFLAG_REFRESHING)
		                .nControlFlags = BITSET(.nControlFlags, CTLFLAG_REFRESHING)
		                .Refresh()
		                IF NOT EMPTY(.cValueSource)
		                  .AfterChange()  && Trigger UI level AfterChange() event for bound ctls
		                ENDIF
		                .nControlFlags = BITCLEAR(.nControlFlags, CTLFLAG_REFRESHING)
		              ENDIF
		            ENDIF
		          ENDWITH
		        ENDIF
		    ENDCASE
		  ENDFOR
		
	ENDPROC

	PROCEDURE refreshui		&& Refresh User Interface controls that are bound to cursor fields that have been modified by the Replace() method.
		LPARAMETERS cFieldList
		*++
		*>>Refresh User Interface controls that are bound to cursor fields that have been modified by the Replace() method.
		*--
		LOCAL ix, nRefreshMode, cField
		
		  * Optional fieldlist parameter allows explicit addition of fields to queue before refreshing.
		  DO WHILE NOT EMPTY(m.cFieldList)
		    THIS.QueueUIRefresh(GetToken(@m.cFieldList, ','))
		  ENDDO
		
		  *1=Refresh active form only, 2=Refresh parent and active child, 3=Refresh parent and all children.
		  DO CASE
		    CASE ISNULL(THISFORM.oActiveChild)
		      m.nRefreshMode = THISFORM.nChildRefreshMode
		    OTHERWISE
		      m.nRefreshMode = THISFORM.oActiveChild.nChildRefreshMode
		  ENDCASE
		
		  IF NOT ISNULL(THISFORM.oActiveChild) AND m.nRefreshMode == 1
		    THISFORM.oActiveChild.LockScreen = .T.
		    THIS.RefreshContents(THISFORM.oActiveChild)
		    THISFORM.oActiveChild.LockScreen = .F.
		  ELSE
		    * Refresh controls in the parent form of a multi-form set.
		    THISFORM.LockScreen = .T.
		    THIS.RefreshContents(THISFORM)
		    THISFORM.LockScreen = .F.
		
		    IF PEMSTATUS(THISFORM, 'cmChildFormCollection', 5)
		      IF m.nRefreshMode == 2
		        IF NOT ISNULL(THISFORM.oActiveChild)
		          THISFORM.oActiveChild.LockScreen = .T.
		          THIS.RefreshContents(THISFORM.oActiveChild)
		          THISFORM.oActiveChild.LockScreen = .F.
		        ENDIF
		      ELSE
		        FOR ix = 1 TO THISFORM.cmChildFormCollection.nCount
		          m.oChild = THISFORM.cmChildFormCollection.Forms[m.ix]
		          IF NOT ISNULL(m.oChild)
		            THIS.RefreshContents(m.oChild)
		          ENDIF
		        ENDFOR
		      ENDIF
		    ENDIF
		  ENDIF
		
		  * Refresh current row of nav controls associated with the workarea.
		  * This will regenerate the display expression for the current record, in case it changed.
		  * Applies to controls in parent and any/all child forms.
		  THIS.UpdateNavControls('Refresh', THIS.cRefreshWorkareaList)
		
		  THIS.cRefreshFieldList = ''
		  THIS.cRefreshWorkareaList = ''
		
	ENDPROC

	PROCEDURE registernavcontrol		&& Register a navigation control for record add/delete notification.
		LPARAMETERS oNavControl, cWorkarea, oForm
		*++
		*>>Register a navigation control for record add/delete notification.
		*--
		LOCAL cNavName
		  IF PEMSTATUS(THIS, 'nNavCount', 5)   && Z-order error might let us be called before init().
		    THIS.nNavCount = THIS.nNavCount + 1
		    DIMENSION THIS.aNavControls[THIS.nNavCount, 3]
		
		    * We store the object name path, rather than oject reference to work-around 
		    * VFP object reference count bugs.
		    m.cNavName = SYS(1272, m.oNavControl)
		    THIS.aNavControls[THIS.nNavCount, 1] = IIF(PCOUNT() < 3, THIS.Parent, m.oForm)
		    THIS.aNavControls[THIS.nNavCount, 2] = PROPER(TRIM(m.cWorkarea))
		    THIS.aNavControls[THIS.nNavCount, 3] = SUBSTR(m.cNavName, AT('.', m.cNavName) + 1)
		  ENDIF
		
	ENDPROC

	PROCEDURE requery		&& Requery the specified view, or all managed views if none specified.
		LPARAMETERS cWorkAreaList, uP1, uP2, uP3, uP4
		*++
		*>>Requery the specified view, or all managed views if none specified.
		*--
		LOCAL oCursor, cWorkarea, lStatus
		
		  * DM level Requery() supports multiple workareas to maintain compatibility with earlier versions.
		  * Cursor and rule method supports only a single workarea. In most cases, DM should also be called with
		  * only a single workarea.
		  DO WHILE NOT EMPTY(m.cWorkareaList)
		    m.cWorkarea = GetToken(@m.cWorkareaList, ',')
		    m.oCursor = THIS.GetCursor(m.cWorkarea)
		    IF NOT ISNULL(oCursor) 
		      IF NOT m.oCursor.Requery(@m.uP1, @m.uP2, @m.uP3, @m.uP4)
		        RETURN .F.   && Returns .F. on the first requery failure
		      ENDIF
		    ELSE
		      RETURN THIS._BadWorkarea(m.cWorkarea)
		    ENDIF
		  ENDDO
		  RETURN .T.   && If all were successful
		
	ENDPROC

	PROCEDURE resetoptimization		&& Reset cursor optimization for IsReadonly(), so it only needs to be evaluated once per refresh cycle.
		*++
		*>>Reset cursor optimization for IsReadonly(), so it only needs to be evaluated once per refresh cycle.
		*--
		LOCAL ix, oCursor
		  IF NOT ISNULL(THIS.oCDE)
		    DO WHILE THIS.oCDE.EnumCursors(@m.ix, @m.oCursor) > 0
		      m.oCursor.lRowReadonly = .NULL.
		    ENDDO
		  ENDIF
		
	ENDPROC

	PROCEDURE saveorder		&& Save the current index order of top parent tables, if form.lRememberOrder is set.
		*++
		*>>Save the current index order of top parent tables, if form.lRememberOrder is set.
		*--
		LOCAL ix, oCursor
		  IF NOT ISNULL(THISFORM.oApp) AND NOT ISNULL(THIS.oCDE)
		    DO WHILE THIS.oCDE.EnumCursors(@m.ix, @m.oCursor) > 0
		      IF ISNULL(m.oCursor.oParent) AND m.oCursor.IsOpen() ;
		      AND (m.oCursor.lRememberOrder OR m.oCursor.cWorkarea = THISFORM.cWorkarea)
		        THISFORM.oApp.SetPreference(THISFORM.cSysRegFormRoot + '\' + m.oCursor.cWorkarea + 'Order', ;
		                                    m.oCursor.GetOrder())
		      ENDIF
		    ENDDO
		  ENDIF
		
	ENDPROC

	PROCEDURE saveposition		&& Save the current record position of top parent cursors, if form.lRememberRecord is set.
		*++
		*>>Save the current record position of top parent cursors, if form.lRememberRecord is set.
		*--
		LOCAL ix, oCursor
		  IF NOT ISNULL(THISFORM.oApp) AND NOT ISNULL(THIS.oCDE)
		    DO WHILE THIS.oCDE.EnumCursors(@m.ix, @m.oCursor) > 0
		      IF ISNULL(m.oCursor.oParent) AND m.oCursor.IsOpen() ;
		      AND (m.oCursor.lRememberRecord OR m.oCursor.cWorkarea == THISFORM.cWorkarea)
		        THISFORM.oApp.SetPreference(THISFORM.cSysRegFormRoot + '\' + m.oCursor.cWorkarea + 'Position', ;
		                                    m.oCursor.GetPosition())
		      ENDIF
		    ENDDO
		  ENDIF
		
	ENDPROC

	PROCEDURE setactivechildform		&& Store a reference to the currently active child form, and return reference to previously active child.
		LPARAMETERS oActiveChild
		*++
		*>>Store a reference to the currently active child form, and return reference to previously active child.
		*--
		LOCAL oLastActive
		  m.oLastActive = THISFORM.oActiveChild
		  THISFORM.oActiveChild = m.oActiveChild
		  RETURN m.oLastActive
		
	ENDPROC

	PROCEDURE setcursor		&& Set values for certain cursor properties. Mostly for backward compatibility - better to set cursor properties directly.
		LPARAMETERS cItem, cWorkarea, uValue
		*++
		*>>Set values for certain cursor properties. Mostly for backward compatibility - better to set cursor properties directly.
		*
		* Parameters:
		*   cItem  -    Item to set.
		*   cWorkarea - workarea affected
		*   uValue -    new value to set
		*
		*     cItem                 uValue
		*   -------------------+----------------------------------
		*   "RelationType"        "Referential" or "Navigational"
		*      "DeleteWithParent"    .T. or .F. (applies only to children in Navigational relations)
		*--
		LOCAL oCursor
		  m.oCursor = THIS.oCDE.GetCursor(@m.cWorkarea)
		  IF NOT ISNULL(m.oCursor)
		    m.cItem = LEFT(m.cItem, 4)
		    DO CASE
		      CASE PROPER(m.cItem) = 'Dele'
		        m.oCursor.lDeleteWithParent = NOT EMPTY(m.uValue)
		      CASE PROPER(m.cItem) = 'Rela'
		        m.oCursor.lRequeryWhenParentMoves = 'Nav' $ PROPER(m.uValue)
		      OTHERWISE
		        RETURN .F.
		    ENDCASE
		    RETURN .T.
		  ENDIF
		  RETURN THIS._BadWorkarea(m.cWorkarea)
		
	ENDPROC

	PROCEDURE setfocusfield		&& Find the first control in the host form that is bound to the specified field, and set focus to it.
		LPARAMETERS cWorkarea, cField
		*++
		*>>Find the first control in the host form that is bound to the specified field, and set focus to it.
		*--
		LOCAL oCtl
		  IF NOT '.' $ m.cField
		    m.cField = m.cWorkarea + '.' + m.cField
		  ENDIF
		  IF THIS.GetBoundControl(THISFORM, PROPER(m.cField), @m.oCtl)
		    THISFORM.SetNextControl(m.oCtl)
		    RETURN .T.
		  ENDIF
		  RETURN .F.
		
	ENDPROC

	PROCEDURE setinitialposition		&& Set the initial record position for the specified cursor. Called on startup, once for each cursor in the CDE.
		LPARAMETERS cWorkarea
		*++
		*>>Set the initial record position for the specified cursor. Called on startup, once for each cursor in the CDE.
		*--
		LOCAL oCursor, cOrder, uPosition
		
		  IF THISFORM.lRememberRecord OR THISFORM.lRememberOrder
		    m.oCursor = THIS.oCDE.GetCursor(@m.cWorkarea)
		    IF NOT ISNULL(m.oCursor) AND ISNULL(m.oCursor.oParent)
		      * Restore saved index order if desired (and appropriate for cursor type).
		      IF THISFORM.lRememberOrder AND m.oCursor.cType == 'Table'
		        IF m.oCursor.lRememberOrder OR PROPER(m.cWorkarea) == PROPER(THISFORM.cWorkarea)
		          IF THISFORM.oApp.GetPreference(THISFORM.cSysRegFormRoot + '\' + m.oCursor.cWorkarea + 'Order', @m.cOrder)
		            m.oCursor.SetOrder(m.cOrder)
		          ENDIF
		        ENDIF
		      ENDIF
		
		      * Restore saved record position if desired (and appropriate for cursor type).
		      IF THISFORM.lRememberRecord
		        IF m.oCursor.lRememberRecord OR PROPER(m.cWorkarea) == PROPER(THISFORM.cWorkarea)
		          IF THISFORM.oApp.GetPreference(THISFORM.cSysRegFormRoot + '\' + m.oCursor.cWorkarea + 'Position', @m.uPosition)
		            RETURN m.oCursor.SetPosition(m.uPosition)   && Return .T. if successful
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDIF
		  ENDIF
		  RETURN .F.  && Return false if we didnt set any position for this cursor.
		
	ENDPROC

	PROCEDURE setrecordposition		&& Alternate interface for RecordWasMoved() method, for compatibility with previous versions of CodeMine.
		LPARAMETERS cWorkArea
		*++
		*>>Alternate interface for RecordWasMoved() method, for compatibility with previous versions of CodeMine.
		*--
		  RETURN THIS.RecordWasMoved(@m.cWorkArea)
		
	ENDPROC

	PROCEDURE unlinkcde		&& Unlink the specified CDE from the Data Manager.
		*++
		*>>Unlink the specified CDE from the Data Manager.
		*--
		  * Save current record and order info for all top parent tables.
		  IF NOT ISNULL(THIS.oCDE)
		    * Call our internal BeforeCloseAll() event, since we are closing down.
		    THIS.BeforeCloseAll()
		
		    IF THISFORM.lRememberRecord
		      THIS.SavePosition()
		    ENDIF
		    IF THISFORM.lRememberOrder
		      THIS.SaveOrder()
		    ENDIF
		
		    * Unlink any rules placed directly on the form. Rules in 
		    * the CDE and cursors stay linked until the CDE is released later.
		    FOR EACH oRule IN THISFORM.Controls
		      IF m.oRule.Baseclass == 'Container'
		        IF PEMSTATUS(m.oRule, 'cClass', 5)   && See if this is a rule object
		          IF PROPER(m.oRule.cClass) == 'Cmrule'
		            m.oRule.UnLink(THIS.oCDE, .T.)
		          ENDIF
		        ENDIF
		      ENDIF
		    ENDFOR
		
		    * Remove object reference links from CDE into the form's DM.
		    THIS.oCDE.UnlinkDM(THIS)
		    THIS.oCDE = .NULL.    && Clear DM link to CDE
		  ENDIF
		
	ENDPROC

	PROCEDURE unregisternavcontrols		&& Un-Register all navigation controls contained in the specified form.
		LPARAMETERS oTarget
		*++
		*>>Un-Register all navigation controls contained in the specified form.
		*--
		LOCAL ix, oForm
		  m.ix = 1
		  DO WHILE m.ix <= THIS.nNavCount
		    m.oForm = THIS.aNavControls[m.ix, 1]
		
		    * Note this depends on each form having a unique name, which Codemine form classes enforce.
		    IF ISNULL(m.oForm) OR m.oForm.Name == m.oTarget.Name
		      ADEL(THIS.aNavControls, m.ix)
		      THIS.nNavCount = THIS.nNavCount - 1        
		    ELSE
		      m.ix = m.ix + 1
		    ENDIF
		  ENDDO
		
	ENDPROC

	PROCEDURE updatenavcontrols		&& Update all registered navigation controls by calling the specified method.
		LPARAMETERS cMethod, cWorkareaList
		*++
		*>>Update all registered navigation controls by calling the specified method.
		*--
		LOCAL ix, oForm, nSelect
		
		  * If a single workarea is specified, convert to comma seperated list format
		  IF NOT EMPTY(m.cWorkareaList) AND NOT ',' $ m.cWorkareaList
		    m.cWorkareaList = PROPER(m.cWorkareaList) + ','
		  ENDIF
		
		  * Scan all nav controls in parent, and all child forms.
		  FOR ix = 1 TO THIS.nNavCount
		    m.oForm = THIS.aNavControls[m.ix, 1]
		    IF NOT ISNULL(m.oForm) ;
		    AND (EMPTY(m.cWorkareaList) OR THIS.aNavControls[m.ix, 2] + ',' $ m.cWorkareaList)
		      m.nSelect = SELECT()
		      SELECT (THIS.aNavControls[m.ix, 2])
		      EVALUATE('m.oForm.' + THIS.aNavControls[m.ix, 3] + '.' + m.cMethod + '()')
		      SELECT (m.nSelect)
		    ENDIF
		  ENDFOR
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmrule AS cmruleabstract OF "..\common\cmdataa.vcx" 		&& CodeMine reusable data Rule class.
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_Rule.bmp" ClassIcon="..\graphics\_Rule.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: afterclose		&& Called after a cursor is closed.
		*m: afterlinked		&& This event occurs after the rule object is linked to a new cursor object. An object reference to the cursor is passed as the parameter.
		*m: beforeopen		&& Called before a cursor is about to be opened.
		*m: beforeunlinked		&& This event occurs just before the rule object is unlinked from a cursor object. An object reference to the (usually closed) cursor is passed as the parameter.
		*m: calc1		&& This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*m: calc2		&& This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*m: calc3		&& This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*m: link		&& Link this rule to the appropriate cursors in the specified CDE, based on matches of cursor.cWorkarea property with the rule's cWorkarea.
		*m: nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*m: nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		*m: setfocusfield		&& If in a form, find the first control bound to the specified field, and set focus to it.
		*m: unlink		&& UnLink this rule from all cursors in the specified CDE. The lClosing parameter will be .T. for DM rules being unlinked during a form close.
		*p: cclass
		*p: cworkarea		&& The cursor alias, or list of aliases, that this rule should apply to.
	*</DefinedPropArrayMethod>

	backcolor = 128,164,250
	cclass = cmRule
	cworkarea = *		&& The cursor alias, or list of aliases, that this rule should apply to.
	Name = "cmrule"
	
	PROCEDURE afterclose		&& Called after a cursor is closed.
		LPARAMETERS cWorkarea
		*++
		*>>Called after a cursor is closed.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE afterlinked		&& This event occurs after the rule object is linked to a new cursor object. An object reference to the cursor is passed as the parameter.
		LPARAMETERS oCursor
		*++
		*>>This event occurs after the rule object is linked to a new cursor object. An object reference to the cursor is passed as the parameter.
		*
		* Developers can use this event to set cursor properties as necessary for the rule code to function correctly.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeopen		&& Called before a cursor is about to be opened.
		LPARAMETERS cWorkarea
		*++
		*>>Called before a cursor is about to be opened.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE beforeunlinked		&& This event occurs just before the rule object is unlinked from a cursor object. An object reference to the (usually closed) cursor is passed as the parameter.
		LPARAMETERS oCursor
		*++
		*>>This event occurs just before the rule object is unlinked from a cursor object. An object reference to the (usually closed) cursor is passed as the parameter.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE calc1		&& This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*++
		*>>This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*
		* Using these empty placeholder methods means you won't need to create a special 
		* rule subclass just to add a couple of your own methods for custom code.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE calc2		&& This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*++
		*>>This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*
		* Using these empty placeholder methods means you won't need to create a special 
		* rule subclass just to add a couple of your own methods for custom code.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE calc3		&& This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*++
		*>>This is an empty method that may be subclassed by the developer for custom rule code that may need to be called from more than one place.
		*
		* Using these empty placeholder methods means you won't need to create a special 
		* rule subclass just to add a couple of your own methods for custom code.
		*--
		  RETURN .T.
		
	ENDPROC

	PROCEDURE init
		*++
		* CodeMine Reusable Rule class.
		*
		* Copyright 2000-2001 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		  THIS.cWorkarea = CHRTRAN(PROPER(CHRTRAN(ALLTRIM(THIS.cWorkarea), ',', ' ')), ' ', ',')
		  DODEFAULT()
		  
		  * We allow rules to be placed directly on a dataform, but do not scan the form looking for them.
		  * Instead, since we know the CDE is already loaded once form controls begin their Init(), we
		  * explicitly link each rule to the CDE here, if we determine it is placed directly in the form.
		  IF THIS.Parent.Baseclass == 'Form'
		    THIS.Link(THISFORM.oCDE)
		  ENDIF
		
	ENDPROC

	PROCEDURE link		&& Link this rule to the appropriate cursors in the specified CDE, based on matches of cursor.cWorkarea property with the rule's cWorkarea.
		LPARAMETERS oCDE
		*++
		*>>Link this rule to the appropriate cursors in the specified CDE, based on matches of cursor.cWorkarea property with the rule's cWorkarea.
		*--
		LOCAL ix, oCursor, lLinked
		  DO WHILE m.oCDE.EnumCursors(@m.ix, @m.oCursor, CDEMASK_ENUM_NESTED) > 0
		    IF THIS.cWorkarea = '*' OR PROPER(m.oCursor.cWorkarea) + ',' $ THIS.cWorkarea + ','
		      m.lLinked = m.oCursor.AddRule(THIS)
		    ENDIF
		  ENDDO
		  ASSERT m.lLinked MESSAGE 'No cursor found for rule: ' + THIS.Name
		
	ENDPROC

	PROCEDURE nerrormode_access		&& Return the nErrorMode value from the highest level available container.
		*++
		*>>Return the nErrorMode value from the highest level available container.
		*--
		  * Rule object uses CDE property, if available.
		  IF NOT ISNULL(THIS.oCDE)
		    RETURN THIS.oCDE.nErrorMode
		  ENDIF
		
		  * If no CDE, then we're probably contained in a free (non-CDE) cursor. We might also be 
		  * in a form whose CDE was released, or not yet linked, so test for parent property first.
		  * Rule must always be created as a child object of CDE, DM, Form, or Cursor.
		  IF PEMSTATUS(THIS.Parent, 'nErrorMode', 5)
		    RETURN THIS.Parent.nErrorMode
		  ELSE
		    RETURN THIS.nErrorMode
		  ENDIF
		
	ENDPROC

	PROCEDURE nerrormode_assign		&& Set the nErrorMode property in the highest level available container.
		LPARAMETERS nValue
		*++
		*>>Set the nErrorMode property in the highest level available container.
		*--
		  * Rule object uses CDE property, if available.
		  IF NOT ISNULL(THIS.oCDE)
		    THIS.oCDE.nErrorMode = m.nValue
		  ELSE
		    * If no CDE, then we're probably contained in a free (non-CDE) cursor. We might also be 
		    * in a form whose CDE was released, or not yet linked, so test for parent property first.
		    IF PEMSTATUS(THIS.Parent, 'nErrorMode', 5)
		      THIS.Parent.nErrorMode = m.nValue
		    ELSE
		      THIS.nErrorMode = m.nValue
		    ENDIF
		  ENDIF
		
	ENDPROC

	PROCEDURE setfocusfield		&& If in a form, find the first control bound to the specified field, and set focus to it.
		LPARAMETERS cWorkarea, cFieldname
		*++
		*>>If in a form, find the first control bound to the specified field, and set focus to it.
		*--
		  * Rule method dispatches to dataManager method code for implementation.
		  IF NOT ISNULL(THIS.oCDE) AND NOT ISNULL(THIS.oCDE.oDM)
		    THIS.oCDE.oDM.SetFocusField(cWorkarea, cFieldname)
		  ENDIF
		
	ENDPROC

	PROCEDURE unlink		&& UnLink this rule from all cursors in the specified CDE. The lClosing parameter will be .T. for DM rules being unlinked during a form close.
		LPARAMETERS oCDE, lClosing
		*++
		*>>UnLink this rule from all cursors in the specified CDE. The lClosing parameter will be .T. for DM rules being unlinked during a form close.
		*--
		LOCAL ix, lLinked, oCursor
		  DO WHILE m.oCDE.EnumCursors(@m.ix, @m.oCursor, CDEMASK_ENUM_NESTED) > 0
		    * This also triggers the BeforeClose() rule event if lClosing flag is true.
		    m.oCursor.RemoveRule(THIS.Name, m.lClosing)
		  ENDDO
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cmsqlproperties AS custom 		&& Codemine SQL Passthrough cursor property definition object.
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="..\graphics\_viewprop.bmp" ClassIcon="..\graphics\_viewprop.bmp" />

	#INCLUDE "codemine.h"
	*<DefinedPropArrayMethod>
		*m: definecursor		&& Custom developer code to define field ruels and defaults. Called automaticaly during Init().
		*m: enumdefaults		&& Enumerate fields that have a default value expressions.
		*m: getfielddefault		&& Return the DBC default value expression for the specified field.
		*m: getfieldrule		&& Return the DBC validation expression and error message for the specified field.
		*m: restoreproperties		&& Restore cursor and field-level view properties
		*m: saveproperties		&& Save cursor and field-level view properties
		*m: setfielddefault		&& Set the DBC default value expression for the specified field.
		*m: setfieldrule		&& Set the DBC validation expression and error message for the specified field.
		*p: ckeyfieldlist		&& Comma delimited list of primary key fields for the cursor.
		*p: ctables		&& A comma delimited list of the names of tables from the remote server.
		*p: cupdatablefieldlist		&& Comma delimited list of fields in the view. This list can include fields from local and remote tables.
		*p: cupdatenamelist		&& Comma delimited list of field names and the local field names assigned to the cursor.
		*p: lcomparememo		&& Set to .T. if memo fields (of type Memo, General, or Picture) are included in the WHERE clause for updates.
		*p: lsendupdates		&& Contains true (.T.) if a SQL update query is sent to update tables when an update is made using the view; otherwise, contains false (.F.)
		*p: nbatchupdatecount		&& The number of update statements sent to the remote data source at once.
		*p: nupdatetype		&& 1 = Old data is updated with the new data (the default). 2 = Updates occur by deleting the old data and inserting the new data.
		*p: nwheretype		&& In WHERE clause for updates: 1 = Only key fields, 2 = Key fields and updatable fields, 3 = Key fields and any other modified fields, 4 = Key fields and a comparison of the time stamp.
	*</DefinedPropArrayMethod>

	ckeyfieldlist = 		&& Comma delimited list of primary key fields for the cursor.
	ctables = 		&& A comma delimited list of the names of tables from the remote server.
	cupdatablefieldlist = 		&& Comma delimited list of fields in the view. This list can include fields from local and remote tables.
	cupdatenamelist = 		&& Comma delimited list of field names and the local field names assigned to the cursor.
	Height = 17
	lcomparememo = .F.		&& Set to .T. if memo fields (of type Memo, General, or Picture) are included in the WHERE clause for updates.
	lsendupdates = .F.		&& Contains true (.T.) if a SQL update query is sent to update tables when an update is made using the view; otherwise, contains false (.F.)
	Name = "cmsqlproperties"
	nbatchupdatecount = 1		&& The number of update statements sent to the remote data source at once.
	nupdatetype = 1		&& 1 = Old data is updated with the new data (the default). 2 = Updates occur by deleting the old data and inserting the new data.
	nwheretype = 4		&& In WHERE clause for updates: 1 = Only key fields, 2 = Key fields and updatable fields, 3 = Key fields and any other modified fields, 4 = Key fields and a comparison of the time stamp.
	Picture = ..\graphics\_viewprop.bmp
	Width = 17
	
	PROCEDURE definecursor		&& Custom developer code to define field ruels and defaults. Called automaticaly during Init().
		*++
		*>>Custom developer code to define field ruels and defaults. Called automaticaly during Init().
		*--
		
	ENDPROC

	PROCEDURE enumdefaults		&& Enumerate fields that have a default value expressions.
		LPARAMETERS nIndex, cField, cExpr
		*++
		*>>Enumerate fields that have a default value expressions.
		*--
		  IF EMPTY(m.nIndex) OR m.nIndex < 0
		    m.nIndex = 1
		  ELSE
		    m.nIndex = m.nIndex + 1
		  ENDIF
		  DO WHILE .T.
		    IF m.nIndex <= THIS.nFldProps
		      m.cExpr = THIS.aFldProps[m.nIndex, 1]
		      IF EMPTY(m.cExpr)   && Skip empty ones (field may have only a valid rule)
		        m.nIndex = m.nIndex + 1
		        LOOP
		      ENDIF
		      m.cField = THIS.aFldNames[m.nIndex]
		      m.cField = LEFT(m.cField, LEN(m.cField)-1)   && Strip period suffix
		    ELSE
		      m.nIndex = -1
		    ENDIF
		    EXIT
		  ENDDO
		  RETURN m.nIndex
		
	ENDPROC

	PROCEDURE getfielddefault		&& Return the DBC default value expression for the specified field.
		LPARAMETERS cField
		*++
		*>>Return the DBC default value expression for the specified field.
		*--
		LOCAL ix
		  m.ix = ASCAN(THIS.aFldNames, PROPER(m.cField) + '.')
		  RETURN IIF(m.ix = 0, '', THIS.aFldProps[m.ix, 1])
		
	ENDPROC

	PROCEDURE getfieldrule		&& Return the DBC validation expression and error message for the specified field.
		LPARAMETERS cField, cMsg
		*++
		*>>Return the DBC validation expression and error message for the specified field.
		*--
		LOCAL ix
		  m.ix = ASCAN(THIS.aFldNames, PROPER(m.cField) + '.')
		  IF m.ix > 0
		    m.cMsg = THIS.aFldProps[m.ix, 3]
		    RETURN THIS.aFldProps[m.ix, 2]
		  ENDIF
		  RETURN ''
		
	ENDPROC

	PROCEDURE Init
		*++
		* SQL Passthrough cursor property definition object.
		*
		* Copyright 2001-2002 Soft Classics Ltd. All Rights Reserved Worldwide.
		*--
		  * If name is wrong, object will be ignored at runtime.
		  ASSERT PROPER(THIS.Name) == 'Cmsqlproperties' MESSAGE 'Cursor Properties object must be named "cmSqlProperties"'
		
		  * This defaults to .T., which means that our properties are applied to the view cursor.
		  THIS.AddProperty('lUseSavedProperties', .T.)
		  THIS.AddProperty('cViewSQL', '')
		
		  * Internal properties to store field default and validation expressions.
		  THIS.AddProperty('aFldNames[1]', '')
		  THIS.AddProperty('aFldProps[1,3]', '')  && Default, Validation, Message
		  THIS.AddProperty('nFldProps', 0)        && Number of fields with default or valid expressions.
		
		  THIS.DefineCursor()
		  RETURN .T.
		
	ENDPROC

	PROCEDURE restoreproperties		&& Restore cursor and field-level view properties
		*++
		*>>Restore cursor and field-level view properties
		*--
		  WITH THIS.Parent
		    * Apply correct buffering mode to the new result cursor
		    IF .nBuffermode > 3
		      .cmDataAccess.SetBufferMode(5)
		    ENDIF
		
		    IF THIS.lUseSavedProperties
		      CURSORSETPROP('BatchUpdateCount', THIS.nBatchupdatecount, .cWorkarea)
		      CURSORSETPROP('CompareMemo', THIS.lComparememo, .cWorkarea)
		      CURSORSETPROP('UpdateType', THIS.nUpdatetype, .cWorkarea)
		      CURSORSETPROP('WhereType', THIS.nWheretype, .cWorkarea)
		      CURSORSETPROP('Keyfieldlist', THIS.cKeyfieldlist, .cWorkarea)
		      CURSORSETPROP('Tables', THIS.cTables, .cWorkarea)
		      CURSORSETPROP('Updatablefieldlist', THIS.cUpdatablefieldlist, .cWorkarea)
		      CURSORSETPROP('Updatenamelist', THIS.cUpdatenamelist, .cWorkarea)
		      CURSORSETPROP('SendUpdates', THIS.lSendupdates AND NOT .lReadonly, .cWorkarea)
		    ENDIF
		  ENDWITH
		
	ENDPROC

	PROCEDURE saveproperties		&& Save cursor and field-level view properties
		LPARAMETERS cView
		*++
		*>>Save cursor and field-level view properties
		*
		* Field Level properties:
		*  DefaultValue    - Store for local use by rule code. Store in an array, indexed by field number?
		*  RuleExpression  - Store for local execution
		*  RuleText        - Store for local use by rule code
		*  DataType        - ??? no way to set for a SQL cursor field
		*  KeyField  (L)   - build KeyFieldList
		*  Updatable (L)   - build UpdatableFieldList
		*  UpdateName (remote field name) - build UpdateNameList
		*--
		    IF NOT EMPTY(m.cView)
		      WITH THIS
		        .lUseSavedProperties = .T.
		
		        * Set these properties from the view definition.
		        .nBatchUpdateCount = DBGETPROP(m.cView, 'View', "BatchUpdateCount")
		        .nUpdateType =       DBGETPROP(m.cView, 'View', "UpdateType")
		        .nWheretype =        DBGETPROP(m.cView, 'View', "WhereType")
		        .lComparememo =      DBGETPROP(m.cView, 'View', "CompareMemo")
		        .lSendUpdates =      DBGETPROP(m.cView, 'View', "SendUpdates")
		        .cTables =           DBGETPROP(m.cView, 'View', "Tables")
		        .cViewSQL =          DBGETPROP(m.cView, 'View', "SQL")
		
		        * Scan properties for each individual field in the DBC, for updateable views only.
		        * This makes read-only cursors open a little faster, but means they will not have any DBC rule 
		        * or KeyField information available (which should not matter for non-updateable cursors anyway)
		        IF .lSendupdates AND NOT .Parent.lReadonly
		          LOCAL cDbcAlias
		          m.nSelect = SELECT()
		          m.cDbcAlias = '__Dbc__' + JUSTSTEM(DBC())
		          IF USED(m.cDbcAlias)
		            SELECT (m.cDbcAlias)
		          ELSE
		            SELECT 0
		            IF FILE(DBC())
		              USE (DBC()) AGAIN SHARED ORDER ObjectName ALIAS (m.cDbcAlias)
		            ELSE
		              LOCAL oPlugin, cPluginApp
		              * If an open DBC file cannot be found, that probably means it is "included" in a 
		              * separate APP file. Look for the Plugin App manager and see if it can open the file.
		              m.oPlugin = FindGlobalObject('cmPluginManager')
		              IF NOT ISNULL(m.oPlugin)
		                m.cPluginApp = m.oPlugin.GetFilePlugin(DBC())
		                IF NOT EMPTY(m.cPluginApp)
		                  DO ('OpenTable') IN (m.cPluginApp) WITH DBC(), m.cDbcAlias
		                ENDIF
		              ENDIF
		            ENDIF
		          ENDIF
		          IF USED(m.cDbcAlias) ;
		          AND SEEK(STR(1, 10) + PADR('View', LEN(ObjectType)) + PADR(LOWER(m.cView), LEN(ObjectName)))
		            LOCAL ix, cField, cFieldPath, cDefault, cRule
		            m.nParentID = ObjectID
		            SCAN FOR STR(PARENTID)+OBJECTTYPE = STR(m.nParentID, 10) + PADR('Field', LEN(ObjectType)) AND NOT DELETED()
		              m.cField = LOWER(TRIM(ObjectName))
		              m.cFieldPath = m.cView + '.' + m.cField
		              IF DBGETPROP(m.cFieldPath, 'Field', 'KeyField')   && Key VFP Fields
		                .cKeyfieldlist = THIS.cKeyfieldlist + IIF(EMPTY(THIS.cKeyfieldlist), '', ',') + m.cField
		              ENDIF
		              IF DBGETPROP(m.cFieldPath, 'Field', 'Updatable')  && Updatable VFP fields
		                .cUpdatablefieldlist = THIS.cUpdatablefieldlist + IIF(EMPTY(THIS.cUpdatablefieldlist), '', ',') + m.cField
		              ENDIF
		
		              * Store field validation rule and default values in custom properties where they will be easily available later.
		              m.cDefault = DBGETPROP(m.cFieldPath, 'Field', 'DefaultValue')  && Default value for new records
		              IF NOT EMPTY(m.cDefault)
		                .SetFieldDefault(m.cField, m.cDefault)
		              ENDIF
		              m.cRule = DBGETPROP(m.cFieldPath, 'Field', 'RuleExpression')   && Field validation expression
		              IF NOT EMPTY(m.cRule)
		                .SetFieldRule(m.cField, m.cRule, DBGETPROP(m.cFieldPath, 'Field', 'RuleText'))
		              ENDIF
		
		              * Build list of all VFP field names, mapped to the corresponding remote field name.
		              .cUpdateNameList = .cUpdatenamelist + IIF(EMPTY(.cUpdatenamelist), '', ',') ;
		                               + m.cField + ' ' + DBGETPROP(m.cFieldPath, 'Field', 'UpdateName')
		            ENDSCAN
		          ENDIF
		          SELECT (m.nSelect)
		        ENDIF
		      ENDWITH
		      RETURN .T.
		    ENDIF
		    RETURN .F.
		
	ENDPROC

	PROCEDURE setfielddefault		&& Set the DBC default value expression for the specified field.
		LPARAMETERS cField, cExpr
		*++
		*>>Set the DBC default value expression for the specified field.
		*--
		LOCAL ix
		  m.cField = PROPER(m.cField) + '.'  && Store in a format immune to SET EXACT setting.
		  m.ix = ASCAN(THIS.aFldNames, m.cField)
		  IF m.ix = 0
		    STORE THIS.nFldProps + 1 TO m.ix, THIS.nFldProps
		    DIMENSION THIS.aFldNames[m.ix]
		    DIMENSION THIS.aFldProps[m.ix, 3]
		  ENDIF
		  THIS.aFldNames[m.ix] = m.cField
		  THIS.aFldProps[m.ix, 1] = m.cExpr
		
	ENDPROC

	PROCEDURE setfieldrule		&& Set the DBC validation expression and error message for the specified field.
		LPARAMETERS cField, cRule, cMsg
		*++
		*>>Set the DBC validation expression and error message for the specified field.
		*--
		LOCAL ix
		  m.cField = PROPER(m.cField) + '.'  && Store in a format immune to SET EXACT setting.
		  m.ix = ASCAN(THIS.aFldNames, m.cField)
		  IF m.ix = 0
		    STORE THIS.nFldProps + 1 TO m.ix, THIS.nFldProps
		    DIMENSION THIS.aFldNames[m.ix]
		    DIMENSION THIS.aFldProps[m.ix, 3]
		  ENDIF
		  THIS.aFldNames[m.ix] = m.cField
		  THIS.aFldProps[m.ix, 2] = m.cRule
		  THIS.aFldProps[m.ix, 3] = IIF(EMPTY(m.cMsg), '', m.cMsg)
		
	ENDPROC

ENDDEFINE
